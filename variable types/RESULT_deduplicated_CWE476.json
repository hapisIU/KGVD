[
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 94,
    "critical_vars": [
      "sr->fid_ofile",
      "sr"
    ],
    "function": "smb_com_flush",
    "filename": "illumos-gate/CVE-2016-6561/CVE-2016-6561_CWE-476_6d1c73b5858fefc6161c7d686345f0dc887ea799_smb_flush.c.diff",
    "function_code": "smb_com_flush(smb_request_t *sr)\n{\n\tsmb_ofile_t\t*file;\n\tsmb_llist_t\t*flist;\n\tint\t\trc;\n\n\tif (smb_flush_required == 0) {\n\t\trc = smbsr_encode_empty_result(sr);\n\t\treturn ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);\n\t}\n\n\tif (sr->smb_fid != 0xffff) {\n\t\tsmbsr_lookup_file(sr);\n\t\tif (sr->fid_ofile == NULL) {\n\t\t\tsmbsr_error(sr, NT_STATUS_INVALID_HANDLE,\n\t\t\t    ERRDOS, ERRbadfid);\n\t\t\treturn (SDRC_ERROR);\n\t\t}\n\n\t\tsmb_flush_file(sr, sr->fid_ofile);\n\t} else {\n\t\tflist = &sr->tid_tree->t_ofile_list;\n\t\tsmb_llist_enter(flist, RW_READER);\n\t\tfile = smb_llist_head(flist);\n\t\twhile (file) {\n\t\t\tmutex_enter(&file->f_mutex);\n\t\t\tsmb_flush_file(sr, file);\n\t\t\tmutex_exit(&file->f_mutex);\n\t\t\tfile = smb_llist_next(flist, file);\n\t\t}\n\t\tsmb_llist_exit(flist);\n\t}\n\n\trc = smbsr_encode_empty_result(sr);\n\treturn ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 93,
    "critical_vars": [
      "sr->fid_ofile",
      "sr"
    ],
    "function": "smb_com_flush",
    "filename": "illumos-gate/CVE-2016-6561/CVE-2016-6561_CWE-476_6d1c73b5858fefc6161c7d686345f0dc887ea799_smb_flush.c.diff",
    "function_code": "smb_com_flush(smb_request_t *sr)\n{\n\tsmb_ofile_t\t*file;\n\tsmb_llist_t\t*flist;\n\tint\t\trc;\n\n\tif (smb_flush_required == 0) {\n\t\trc = smbsr_encode_empty_result(sr);\n\t\treturn ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);\n\t}\n\n\tif (sr->smb_fid != 0xffff) {\n\t\tsmbsr_lookup_file(sr);\n\t\tif (sr->fid_ofile == NULL) {\n\t\t\tsmbsr_error(sr, NT_STATUS_INVALID_HANDLE,\n\t\t\t    ERRDOS, ERRbadfid);\n\t\t\treturn (SDRC_ERROR);\n\t\t}\n\t\tsmb_ofile_flush(sr, sr->fid_ofile);\n\t} else {\n\t\tflist = &sr->tid_tree->t_ofile_list;\n\t\tsmb_llist_enter(flist, RW_READER);\n\t\tfile = smb_llist_head(flist);\n\t\twhile (file) {\n\t\t\tmutex_enter(&file->f_mutex);\n\t\t\tsmb_ofile_flush(sr, file);\n\t\t\tmutex_exit(&file->f_mutex);\n\t\t\tfile = smb_llist_next(flist, file);\n\t\t}\n\t\tsmb_llist_exit(flist);\n\t}\n\n\trc = smbsr_encode_empty_result(sr);\n\treturn ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 54,
    "critical_vars": [
      "of"
    ],
    "function": "smb2_flush",
    "filename": "illumos-gate/CVE-2016-6561/CVE-2016-6561_CWE-476_6d1c73b5858fefc6161c7d686345f0dc887ea799_smb2_flush.c.diff",
    "function_code": "smb2_flush(smb_request_t *sr)\n{\n\tsmb_ofile_t *of = NULL;\n\tuint16_t StructSize;\n\tuint16_t reserved1;\n\tuint32_t reserved2;\n\tsmb2fid_t smb2fid;\n\tuint32_t status;\n\tint rc = 0;\n\n\t/*\n\t * SMB2 Flush request\n\t */\n\trc = smb_mbc_decodef(\n\t    &sr->smb_data, \"wwlqq\",\n\t    &StructSize,\t\t/* w */\n\t    &reserved1,\t\t\t/* w */\n\t    &reserved2,\t\t\t/* l */\n\t    &smb2fid.persistent,\t/* q */\n\t    &smb2fid.temporal);\t\t/* q */\n\tif (rc)\n\t\treturn (SDRC_ERROR);\n\tif (StructSize != 24)\n\t\treturn (SDRC_ERROR);\n\n\tstatus = smb2sr_lookup_fid(sr, &smb2fid);\n\tif (status) {\n\t\tsmb2sr_put_error(sr, status);\n\t\treturn (SDRC_SUCCESS);\n\t}\n\tof = sr->fid_ofile;\n\n\t/*\n\t * XXX - todo:\n\t * Flush named pipe should drain writes.\n\t */\n\tif ((of->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)\n\t\t(void) smb_fsop_commit(sr, of->f_cr, of->f_node);\n\n\t/*\n\t * SMB2 Flush reply\n\t */\n\t(void) smb_mbc_encodef(\n\t    &sr->reply, \"wwl\",\n\t    4,\t/* StructSize */\t/* w */\n\t    0); /* reserved */\t\t/* w */\n\n\treturn (SDRC_SUCCESS);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 55,
    "critical_vars": [
      "sr->fid_ofile",
      "sr"
    ],
    "function": "smb2_flush",
    "filename": "illumos-gate/CVE-2016-6561/CVE-2016-6561_CWE-476_6d1c73b5858fefc6161c7d686345f0dc887ea799_smb2_flush.c.diff",
    "function_code": "smb2_flush(smb_request_t *sr)\n{\n\tuint16_t StructSize;\n\tuint16_t reserved1;\n\tuint32_t reserved2;\n\tsmb2fid_t smb2fid;\n\tuint32_t status;\n\tint rc = 0;\n\n\t/*\n\t * SMB2 Flush request\n\t */\n\trc = smb_mbc_decodef(\n\t    &sr->smb_data, \"wwlqq\",\n\t    &StructSize,\t\t/* w */\n\t    &reserved1,\t\t\t/* w */\n\t    &reserved2,\t\t\t/* l */\n\t    &smb2fid.persistent,\t/* q */\n\t    &smb2fid.temporal);\t\t/* q */\n\tif (rc)\n\t\treturn (SDRC_ERROR);\n\tif (StructSize != 24)\n\t\treturn (SDRC_ERROR);\n\n\tstatus = smb2sr_lookup_fid(sr, &smb2fid);\n\tif (status) {\n\t\tsmb2sr_put_error(sr, status);\n\t\treturn (SDRC_SUCCESS);\n\t}\n\n\tsmb_ofile_flush(sr, sr->fid_ofile);\n\n\t/*\n\t * SMB2 Flush reply\n\t */\n\t(void) smb_mbc_encodef(\n\t    &sr->reply, \"wwl\",\n\t    4,\t/* StructSize */\t/* w */\n\t    0); /* reserved */\t\t/* w */\n\n\treturn (SDRC_SUCCESS);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 485,
    "critical_vars": [
      "l"
    ],
    "function": "formUpdateBuffer",
    "filename": "w3m/CVE-2018-6197/CVE-2018-6197_CWE-476_7fdc83b0364005a0b5ed869230dd81752ba022e8_form.c.diff",
    "function_code": "formUpdateBuffer(Anchor *a, Buffer *buf, FormItemList *form)\n{\n    Buffer save;\n    char *p;\n    int spos, epos, rows, c_rows, pos, col = 0;\n    Line *l;\n\n    copyBuffer(&save, buf);\n    gotoLine(buf, a->start.line);\n    switch (form->type) {\n    case FORM_TEXTAREA:\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n#endif\t\t\t\t/* MENU_SELECT */\n\tspos = a->start.pos;\n\tepos = a->end.pos;\n\tbreak;\n    default:\n\tspos = a->start.pos + 1;\n\tepos = a->end.pos - 1;\n    }\n    switch (form->type) {\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n\tif (buf->currentLine == NULL ||\n\t    spos >= buf->currentLine->len || spos < 0)\n\t    break;\n\tif (form->checked)\n\t    buf->currentLine->lineBuf[spos] = '*';\n\telse\n\t    buf->currentLine->lineBuf[spos] = ' ';\n\tbreak;\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_TEXTAREA:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n\tif (form->type == FORM_SELECT) {\n\t    p = form->label->ptr;\n\t    updateSelectOption(form, form->select_option);\n\t}\n\telse\n#endif\t\t\t\t/* MENU_SELECT */\n\t{\n\t    if (!form->value)\n\t\tbreak;\n\t    p = form->value->ptr;\n\t}\n\tl = buf->currentLine;\n\tif (!l)\n\t    break;\n\tif (form->type == FORM_TEXTAREA) {\n\t    int n = a->y - buf->currentLine->linenumber;\n\t    if (n > 0)\n\t\tfor (; l && n; l = l->prev, n--) ;\n\t    else if (n < 0)\n\t\tfor (; l && n; l = l->prev, n++) ;\n\t    if (!l)\n\t\tbreak;\n\t}\n\trows = form->rows ? form->rows : 1;\n\tcol = COLPOS(l, a->start.pos);\n\tfor (c_rows = 0; c_rows < rows; c_rows++, l = l->next) {\n\t    if (l == NULL)\n\t\tbreak;\n\t    if (rows > 1) {\n\t\tpos = columnPos(l, col);\n\t\ta = retrieveAnchor(buf->formitem, l->linenumber, pos);\n\t\tif (a == NULL)\n\t\t    break;\n\t\tspos = a->start.pos;\n\t\tepos = a->end.pos;\n\t    }\n\t    if (a->start.line != a->end.line || spos > epos || epos >= l->len ||\n\t\tspos < 0 || epos < 0 || COLPOS(l, epos) < col)\n\t\tbreak;\n\t    pos = form_update_line(l, &p, spos, epos, COLPOS(l, epos) - col,\n\t\t\t\t   rows > 1,\n\t\t\t\t   form->type == FORM_INPUT_PASSWORD);\n\t    if (pos != epos) {\n\t\tshiftAnchorPosition(buf->href, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->name, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->img, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->formitem, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t    }\n\t}\n\tbreak;\n    }\n    copyBuffer(buf, &save);\n    arrangeLine(buf);\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 525,
    "line_new": 525,
    "critical_vars": [
      "cookie_name"
    ],
    "function": "CookieWndProc",
    "filename": "selenium/CVE-2023-5590/CVE-2023-5590_CWE-476_023a0d52f106321838ab1c0997e76693f4dcbdf6_CookieManager.cpp.diff",
    "function_code": "LRESULT CALLBACK CookieWndProc(int nCode, WPARAM wParam, LPARAM lParam) {\n  CWPSTRUCT* call_window_proc_struct = reinterpret_cast<CWPSTRUCT*>(lParam);\n  if (WM_COPYDATA == call_window_proc_struct->message) {\n    COPYDATASTRUCT* data = reinterpret_cast<COPYDATASTRUCT*>(call_window_proc_struct->lParam);\n    webdriver::HookProcessor::CopyDataToBuffer(data->cbData, data->lpData);\n  } else if (WD_GET_ALL_COOKIES == call_window_proc_struct->message) {\n    std::wstring url = webdriver::HookProcessor::CopyWStringFromBuffer();\n    int driver_process_id = static_cast<int>(call_window_proc_struct->wParam);\n\n    CComPtr<IUri> uri_pointer;\n    HRESULT hr = ::CreateUri(url.c_str(), Uri_CREATE_ALLOW_RELATIVE, 0, &uri_pointer);\n    DWORD scheme = 0;\n    uri_pointer->GetScheme(&scheme);\n    CComBSTR scheme_bstr;\n    uri_pointer->GetSchemeName(&scheme_bstr);\n    CComBSTR host_bstr;\n    uri_pointer->GetHost(&host_bstr);\n    CComBSTR path_bstr;\n    uri_pointer->GetPath(&path_bstr);\n    \n    std::wstring parsed_uri = scheme_bstr;\n    parsed_uri.append(L\"://\");\n    parsed_uri.append(host_bstr);\n    parsed_uri.append(path_bstr);\n\n    InternetGetCookieEx2Proc get_cookie_proc = NULL;\n    InternetFreeCookiesProc free_cookies_proc = NULL;\n    HMODULE wininet_handle = ::GetModuleHandle(L\"wininet\");\n    if (wininet_handle) {\n      get_cookie_proc = reinterpret_cast<InternetGetCookieEx2Proc>(::GetProcAddress(wininet_handle, \"InternetGetCookieEx2\"));\n      free_cookies_proc = reinterpret_cast<InternetFreeCookiesProc>(::GetProcAddress(wininet_handle, \"InternetFreeCookies\"));\n    }\n\n    DWORD cookie_count = 0;\n    INTERNETCOOKIE2* cookie_pointer = NULL;\n    DWORD success = 1;\n    if (get_cookie_proc) {\n      success = get_cookie_proc(parsed_uri.c_str(),\n                                NULL,\n                                INTERNET_COOKIE_NON_SCRIPT,\n                                &cookie_pointer,\n                                &cookie_count);\n    }\n\n    if (success == 0) {\n      // Mimic the format of the old persistent cookie files for ease of\n      // transmission back to the driver and parsing.\n      std::wstring all_cookies = L\"\";\n      for (DWORD cookie_index = 0; cookie_index < cookie_count; ++cookie_index) {\n        if (all_cookies.size() > 0) {\n          all_cookies.append(L\"\\n*\\n\");\n        }\n        INTERNETCOOKIE2* current_cookie = cookie_pointer + cookie_index;\n        std::wstring cookie_name = L\"\";\n        if (current_cookie->pwszName) {\n          // Note that the spec appears to allow \"nameless\" cookies,\n          // which clients like Selenium may not support.\n          cookie_name = current_cookie->pwszName;\n        }\n        std::wstring cookie_value = L\"\";\n        if (current_cookie->pwszValue) {\n          cookie_value = current_cookie->pwszValue;\n        }\n\n        // TODO: The spec does not allow a cookie with an empty name\n        // and value. It's unclear what the driver could do in this\n        // case, but we should probably handle it somehow in the off\n        // chance it ever comes up.\n        std::wstring cookie_domain = L\"\";\n        if (current_cookie->pwszDomain) {\n          cookie_domain = current_cookie->pwszDomain;\n        }\n        std::wstring cookie_path = L\"\";\n        if (current_cookie->pwszPath) {\n          cookie_path = current_cookie->pwszPath;\n        }\n        DWORD flags = current_cookie->dwFlags;\n        FILETIME expires = current_cookie->ftExpires;\n        all_cookies.append(cookie_name).append(L\"\\n\");\n        all_cookies.append(cookie_value).append(L\"\\n\");\n        all_cookies.append(cookie_domain).append(L\"/\").append(cookie_path).append(L\"\\n\");\n        all_cookies.append(std::to_wstring(flags)).append(L\"\\n\");\n        // If the expiration time is set, add it to the string for the cookie.\n        // If not, append empty fields to the record so subsequent parsing\n        // of the string will still work.\n        if (current_cookie->fExpiresSet) {\n          all_cookies.append(std::to_wstring(expires.dwLowDateTime)).append(L\"\\n\");\n          all_cookies.append(std::to_wstring(expires.dwHighDateTime)).append(L\"\\n\");\n        } else {\n          all_cookies.append(L\"\\n\\n\");\n        }\n      }\n      free_cookies_proc(cookie_pointer, cookie_count);\n      webdriver::HookProcessor::CopyWStringToBuffer(all_cookies);\n    } else {\n      webdriver::HookProcessor::SetDataBufferSize(sizeof(wchar_t));\n    }\n    webdriver::HookProcessor::WriteBufferToPipe(driver_process_id);\n  } else if (WD_GET_HTTPONLY_COOKIES == call_window_proc_struct->message ||\n             WD_GET_SCRIPTABLE_COOKIES == call_window_proc_struct->message ||\n             WD_GET_SECURE_COOKIES == call_window_proc_struct->message) {\n    std::wstring url = webdriver::HookProcessor::CopyWStringFromBuffer();\n    int driver_process_id = static_cast<int>(call_window_proc_struct->wParam);\n\n    DWORD get_cookie_flags = 0;\n    if (WD_GET_HTTPONLY_COOKIES == call_window_proc_struct->message ||\n      WD_GET_SECURE_COOKIES == call_window_proc_struct->message) {\n      get_cookie_flags = INTERNET_COOKIE_HTTPONLY;\n    }\n\n    CComPtr<IUri> uri_pointer;\n    HRESULT hr = ::CreateUri(url.c_str(), Uri_CREATE_ALLOW_RELATIVE, 0, &uri_pointer);\n    DWORD scheme = 0;\n    uri_pointer->GetScheme(&scheme);\n    CComBSTR scheme_bstr;\n    uri_pointer->GetSchemeName(&scheme_bstr);\n    CComBSTR host_bstr;\n    uri_pointer->GetHost(&host_bstr);\n    CComBSTR path_bstr;\n    uri_pointer->GetPath(&path_bstr);\n\n    // Get only the cookies for the base URL, omitting port, if there is one.\n    // N.B., we only return cookies secure cookies when browsing a site using\n    // SSL. The browser won't see cookies with the 'secure' flag for sites\n    // visited using plain http.\n    std::wstring parsed_uri = L\"http\";\n    if ((WD_GET_SECURE_COOKIES == call_window_proc_struct->message ||\n         WD_GET_SCRIPTABLE_COOKIES == call_window_proc_struct->message) &&\n        URL_SCHEME_HTTPS == scheme) {\n      parsed_uri.append(L\"s\");\n    }\n    parsed_uri.append(L\"://\");\n    parsed_uri.append(host_bstr);\n    parsed_uri.append(path_bstr);\n\n    // Call InternetGetCookieEx once to get the size of the buffer needed,\n    // then call again with the appropriately sized buffer allocated.\n    DWORD buffer_size = 0;\n    BOOL success = ::InternetGetCookieEx(parsed_uri.c_str(),\n                                         NULL,\n                                         NULL,\n                                         &buffer_size,\n                                         get_cookie_flags,\n                                         NULL);\n    if (success) {\n      webdriver::HookProcessor::SetDataBufferSize(buffer_size);\n      ::InternetGetCookieEx(parsed_uri.c_str(),\n                            NULL,\n                            reinterpret_cast<LPTSTR>(webdriver::HookProcessor::GetDataBufferAddress()),\n                            &buffer_size,\n                            get_cookie_flags,\n                            NULL);\n\n      webdriver::HookProcessor::WriteBufferToPipe(driver_process_id);\n    } else {\n      if (ERROR_NO_MORE_ITEMS == ::GetLastError()) {\n        webdriver::HookProcessor::SetDataBufferSize(sizeof(wchar_t));\n        webdriver::HookProcessor::WriteBufferToPipe(driver_process_id);\n      }\n    }\n  } else if (WD_GET_COOKIE_CACHE_FILES == call_window_proc_struct->message) {\n    int driver_process_id = static_cast<int>(call_window_proc_struct->wParam);\n    std::wstring file_list = L\"\";\n    std::wstring url = webdriver::HookProcessor::CopyWStringFromBuffer();\n\n    // We need to remove the port to find the entry in the cache.\n    CComPtr<IUri> uri_pointer;\n    HRESULT hr = ::CreateUri(url.c_str(), Uri_CREATE_ALLOW_RELATIVE, 0, &uri_pointer);\n    CComBSTR host_bstr;\n    uri_pointer->GetHost(&host_bstr);\n    CComBSTR path_bstr;\n    uri_pointer->GetPath(&path_bstr);\n    std::wstring parsed_uri = host_bstr;\n    parsed_uri.append(path_bstr);\n\n    // A 2048-byte buffer should be large enough to handle cookie\n    // cache entries in all but the most extreme cases.\n    HANDLE cache_enum_handle = NULL;\n    DWORD entry_size = 2048;\n    LPINTERNET_CACHE_ENTRY_INFO entry = NULL;\n    std::vector<char> entry_buffer(entry_size);\n    entry = reinterpret_cast<INTERNET_CACHE_ENTRY_INFO*>(&entry_buffer[0]);\n    cache_enum_handle = ::FindFirstUrlCacheEntry(L\"cookie:\",\n                                                 entry,\n                                                 &entry_size);\n    if (cache_enum_handle == NULL &&\n        ERROR_INSUFFICIENT_BUFFER == ::GetLastError()) {\n      entry_buffer.resize(entry_size);\n      entry = reinterpret_cast<INTERNET_CACHE_ENTRY_INFO*>(&entry_buffer[0]);\n      cache_enum_handle = ::FindFirstUrlCacheEntry(L\"cookie:\",\n                                                   entry,\n                                                   &entry_size);\n    }\n    while (cache_enum_handle != NULL) {\n      if (COOKIE_CACHE_ENTRY == (entry->CacheEntryType & COOKIE_CACHE_ENTRY)) {\n        std::wstring name = entry->lpszSourceUrlName;\n        size_t name_separator_pos(name.find_first_of(L\"@\"));\n        std::wstring domain = name.substr(name_separator_pos + 1);\n        if (parsed_uri.find(domain) != std::wstring::npos) {\n          if (file_list.size() > 0) {\n            file_list.append(L\"|\");\n          }\n          file_list.append(entry->lpszLocalFileName);\n        }\n      }\n      BOOL success = ::FindNextUrlCacheEntry(cache_enum_handle,\n                                             entry,\n                                             &entry_size);\n      if (!success) {\n        DWORD error = ::GetLastError();\n        if (ERROR_INSUFFICIENT_BUFFER == error) {\n          entry_buffer.resize(entry_size);\n          BOOL other_success = ::FindNextUrlCacheEntry(cache_enum_handle,\n                                                       entry,\n                                                       &entry_size);\n        } else if (ERROR_NO_MORE_ITEMS == error) {\n          ::FindCloseUrlCache(cache_enum_handle);\n          cache_enum_handle = NULL;\n        }\n      }\n    }\n    webdriver::HookProcessor::CopyWStringToBuffer(file_list);\n    webdriver::HookProcessor::WriteBufferToPipe(driver_process_id);\n  } else if (WD_SET_COOKIE == call_window_proc_struct->message) {\n    DWORD set_cookie_flags = static_cast<DWORD>(call_window_proc_struct->wParam);\n    std::wstring cookie_data = webdriver::HookProcessor::CopyWStringFromBuffer();\n    size_t url_separator_pos = cookie_data.find_first_of(L\"|\");\n    std::wstring url = cookie_data.substr(0, url_separator_pos);\n    std::wstring cookie = cookie_data.substr(url_separator_pos + 1);\n\n    CComPtr<IUri> uri_pointer;\n    HRESULT hr = ::CreateUri(url.c_str(), Uri_CREATE_ALLOW_RELATIVE, 0, &uri_pointer);\n    CComBSTR scheme_bstr;\n    uri_pointer->GetSchemeName(&scheme_bstr);\n    CComBSTR host_bstr;\n    uri_pointer->GetHost(&host_bstr);\n    std::wstring parsed_uri = scheme_bstr;\n    parsed_uri.append(L\"://\");\n    parsed_uri.append(host_bstr);\n\n    // Leverage the shared data buffer size to return the error code\n    // back to the driver, if necessary.\n    DWORD cookie_set = ::InternetSetCookieEx(parsed_uri.c_str(),\n                                             NULL,\n                                             cookie.c_str(),\n                                             set_cookie_flags,\n                                             NULL);\n    if (cookie_set) {\n      webdriver::HookProcessor::SetDataBufferSize(0);\n    } else {\n      DWORD error = ::GetLastError();\n      webdriver::HookProcessor::SetDataBufferSize(error);\n    }\n  }\n  return ::CallNextHookEx(NULL, nCode, wParam, lParam);\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 2077,
    "line_new": 2077,
    "critical_vars": [
      "device_path"
    ],
    "function": "btrfs_rm_device",
    "filename": "linux/CVE-2021-3739/CVE-2021-3739_CWE-476_e4571b8c5e9ffa1e85c0c671995bd4dcc5c75091_volumes.c.diff",
    "function_code": "int btrfs_rm_device(struct btrfs_fs_info *fs_info, const char *device_path,\n\t\t    u64 devid)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_fs_devices *cur_devices;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tu64 num_devices;\n\tint ret = 0;\n\n\tmutex_lock(&uuid_mutex);\n\n\tnum_devices = btrfs_num_devices(fs_info);\n\n\tret = btrfs_check_raid_min_devices(fs_info, num_devices - 1);\n\tif (ret)\n\t\tgoto out;\n\n\tdevice = btrfs_find_device_by_devspec(fs_info, devid, device_path);\n\n\tif (IS_ERR(device)) {\n\t\tif (PTR_ERR(device) == -ENOENT &&\n\t\t    device_path && strcmp(device_path, \"missing\") == 0)\n\t\t\tret = BTRFS_ERROR_DEV_MISSING_NOT_FOUND;\n\t\telse\n\t\t\tret = PTR_ERR(device);\n\t\tgoto out;\n\t}\n\n\tif (btrfs_pinned_by_swapfile(fs_info, device)) {\n\t\tbtrfs_warn_in_rcu(fs_info,\n\t\t  \"cannot remove device %s (devid %llu) due to active swapfile\",\n\t\t\t\t  rcu_str_deref(device->name), device->devid);\n\t\tret = -ETXTBSY;\n\t\tgoto out;\n\t}\n\n\tif (test_bit(BTRFS_DEV_STATE_REPLACE_TGT, &device->dev_state)) {\n\t\tret = BTRFS_ERROR_DEV_TGT_REPLACE;\n\t\tgoto out;\n\t}\n\n\tif (test_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state) &&\n\t    fs_info->fs_devices->rw_devices == 1) {\n\t\tret = BTRFS_ERROR_DEV_ONLY_WRITABLE;\n\t\tgoto out;\n\t}\n\n\tif (test_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state)) {\n\t\tmutex_lock(&fs_info->chunk_mutex);\n\t\tlist_del_init(&device->dev_alloc_list);\n\t\tdevice->fs_devices->rw_devices--;\n\t\tmutex_unlock(&fs_info->chunk_mutex);\n\t}\n\n\tmutex_unlock(&uuid_mutex);\n\tret = btrfs_shrink_device(device, 0);\n\tif (!ret)\n\t\tbtrfs_reada_remove_dev(device);\n\tmutex_lock(&uuid_mutex);\n\tif (ret)\n\t\tgoto error_undo;\n\n\t/*\n\t * TODO: the superblock still includes this device in its num_devices\n\t * counter although write_all_supers() is not locked out. This\n\t * could give a filesystem state which requires a degraded mount.\n\t */\n\tret = btrfs_rm_dev_item(device);\n\tif (ret)\n\t\tgoto error_undo;\n\n\tclear_bit(BTRFS_DEV_STATE_IN_FS_METADATA, &device->dev_state);\n\tbtrfs_scrub_cancel_dev(device);\n\n\t/*\n\t * the device list mutex makes sure that we don't change\n\t * the device list while someone else is writing out all\n\t * the device supers. Whoever is writing all supers, should\n\t * lock the device list mutex before getting the number of\n\t * devices in the super block (super_copy). Conversely,\n\t * whoever updates the number of devices in the super block\n\t * (super_copy) should hold the device list mutex.\n\t */\n\n\t/*\n\t * In normal cases the cur_devices == fs_devices. But in case\n\t * of deleting a seed device, the cur_devices should point to\n\t * its own fs_devices listed under the fs_devices->seed.\n\t */\n\tcur_devices = device->fs_devices;\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tlist_del_rcu(&device->dev_list);\n\n\tcur_devices->num_devices--;\n\tcur_devices->total_devices--;\n\t/* Update total_devices of the parent fs_devices if it's seed */\n\tif (cur_devices != fs_devices)\n\t\tfs_devices->total_devices--;\n\n\tif (test_bit(BTRFS_DEV_STATE_MISSING, &device->dev_state))\n\t\tcur_devices->missing_devices--;\n\n\tbtrfs_assign_next_active_device(device, NULL);\n\n\tif (device->bdev) {\n\t\tcur_devices->open_devices--;\n\t\t/* remove sysfs entry */\n\t\tbtrfs_sysfs_remove_device(device);\n\t}\n\n\tnum_devices = btrfs_super_num_devices(fs_info->super_copy) - 1;\n\tbtrfs_set_super_num_devices(fs_info->super_copy, num_devices);\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\t/*\n\t * at this point, the device is zero sized and detached from\n\t * the devices list.  All that's left is to zero out the old\n\t * supers and free the device.\n\t */\n\tif (test_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state))\n\t\tbtrfs_scratch_superblocks(fs_info, device->bdev,\n\t\t\t\t\t  device->name->str);\n\n\tbtrfs_close_bdev(device);\n\tsynchronize_rcu();\n\tbtrfs_free_device(device);\n\n\tif (cur_devices->open_devices == 0) {\n\t\tlist_del_init(&cur_devices->seed_list);\n\t\tclose_fs_devices(cur_devices);\n\t\tfree_fs_devices(cur_devices);\n\t}\n\nout:\n\tmutex_unlock(&uuid_mutex);\n\treturn ret;\n\nerror_undo:\n\tbtrfs_reada_undo_remove_dev(device);\n\tif (test_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state)) {\n\t\tmutex_lock(&fs_info->chunk_mutex);\n\t\tlist_add(&device->dev_alloc_list,\n\t\t\t &fs_devices->alloc_list);\n\t\tdevice->fs_devices->rw_devices++;\n\t\tmutex_unlock(&fs_info->chunk_mutex);\n\t}\n\tgoto out;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 1968,
    "critical_vars": [
      "&used_address->name",
      "msg->msg_name"
    ],
    "function": "__sys_sendmsg",
    "filename": "linux/CVE-2011-4594/CVE-2011-4594_CWE-476_bc909d9ddbf7778371e36a651d6e4194b1cc7d4c_socket.c.diff",
    "function_code": "static int __sys_sendmsg(struct socket *sock, struct msghdr __user *msg,\n\t\t\t struct msghdr *msg_sys, unsigned flags,\n\t\t\t struct used_address *used_address)\n{\n\tstruct compat_msghdr __user *msg_compat =\n\t    (struct compat_msghdr __user *)msg;\n\tstruct sockaddr_storage address;\n\tstruct iovec iovstack[UIO_FASTIOV], *iov = iovstack;\n\tunsigned char ctl[sizeof(struct cmsghdr) + 20]\n\t    __attribute__ ((aligned(sizeof(__kernel_size_t))));\n\t/* 20 is size of ipv6_pktinfo */\n\tunsigned char *ctl_buf = ctl;\n\tint err, ctl_len, iov_size, total_len;\n\n\terr = -EFAULT;\n\tif (MSG_CMSG_COMPAT & flags) {\n\t\tif (get_compat_msghdr(msg_sys, msg_compat))\n\t\t\treturn -EFAULT;\n\t} else if (copy_from_user(msg_sys, msg, sizeof(struct msghdr)))\n\t\treturn -EFAULT;\n\n\t/* do not move before msg_sys is valid */\n\terr = -EMSGSIZE;\n\tif (msg_sys->msg_iovlen > UIO_MAXIOV)\n\t\tgoto out;\n\n\t/* Check whether to allocate the iovec area */\n\terr = -ENOMEM;\n\tiov_size = msg_sys->msg_iovlen * sizeof(struct iovec);\n\tif (msg_sys->msg_iovlen > UIO_FASTIOV) {\n\t\tiov = sock_kmalloc(sock->sk, iov_size, GFP_KERNEL);\n\t\tif (!iov)\n\t\t\tgoto out;\n\t}\n\n\t/* This will also move the address data into kernel space */\n\tif (MSG_CMSG_COMPAT & flags) {\n\t\terr = verify_compat_iovec(msg_sys, iov,\n\t\t\t\t\t  (struct sockaddr *)&address,\n\t\t\t\t\t  VERIFY_READ);\n\t} else\n\t\terr = verify_iovec(msg_sys, iov,\n\t\t\t\t   (struct sockaddr *)&address,\n\t\t\t\t   VERIFY_READ);\n\tif (err < 0)\n\t\tgoto out_freeiov;\n\ttotal_len = err;\n\n\terr = -ENOBUFS;\n\n\tif (msg_sys->msg_controllen > INT_MAX)\n\t\tgoto out_freeiov;\n\tctl_len = msg_sys->msg_controllen;\n\tif ((MSG_CMSG_COMPAT & flags) && ctl_len) {\n\t\terr =\n\t\t    cmsghdr_from_user_compat_to_kern(msg_sys, sock->sk, ctl,\n\t\t\t\t\t\t     sizeof(ctl));\n\t\tif (err)\n\t\t\tgoto out_freeiov;\n\t\tctl_buf = msg_sys->msg_control;\n\t\tctl_len = msg_sys->msg_controllen;\n\t} else if (ctl_len) {\n\t\tif (ctl_len > sizeof(ctl)) {\n\t\t\tctl_buf = sock_kmalloc(sock->sk, ctl_len, GFP_KERNEL);\n\t\t\tif (ctl_buf == NULL)\n\t\t\t\tgoto out_freeiov;\n\t\t}\n\t\terr = -EFAULT;\n\t\t/*\n\t\t * Careful! Before this, msg_sys->msg_control contains a user pointer.\n\t\t * Afterwards, it will be a kernel pointer. Thus the compiler-assisted\n\t\t * checking falls down on this.\n\t\t */\n\t\tif (copy_from_user(ctl_buf,\n\t\t\t\t   (void __user __force *)msg_sys->msg_control,\n\t\t\t\t   ctl_len))\n\t\t\tgoto out_freectl;\n\t\tmsg_sys->msg_control = ctl_buf;\n\t}\n\tmsg_sys->msg_flags = flags;\n\n\tif (sock->file->f_flags & O_NONBLOCK)\n\t\tmsg_sys->msg_flags |= MSG_DONTWAIT;\n\t/*\n\t * If this is sendmmsg() and current destination address is same as\n\t * previously succeeded address, omit asking LSM's decision.\n\t * used_address->name_len is initialized to UINT_MAX so that the first\n\t * destination address never matches.\n\t */\n\tif (used_address && used_address->name_len == msg_sys->msg_namelen &&\n\t    !memcmp(&used_address->name, msg->msg_name,\n\t\t    used_address->name_len)) {\n\t\terr = sock_sendmsg_nosec(sock, msg_sys, total_len);\n\t\tgoto out_freectl;\n\t}\n\terr = sock_sendmsg(sock, msg_sys, total_len);\n\t/*\n\t * If this is sendmmsg() and sending to current destination address was\n\t * successful, remember it.\n\t */\n\tif (used_address && err >= 0) {\n\t\tused_address->name_len = msg_sys->msg_namelen;\n\t\tmemcpy(&used_address->name, msg->msg_name,\n\t\t       used_address->name_len);\n\t}\n\nout_freectl:\n\tif (ctl_buf != ctl)\n\t\tsock_kfree_s(sock->sk, ctl_buf, ctl_len);\nout_freeiov:\n\tif (iov != iovstack)\n\t\tsock_kfree_s(sock->sk, iov, iov_size);\nout:\n\treturn err;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1968,
    "critical_vars": [
      "msg_sys->msg_name",
      "&used_address->name"
    ],
    "function": "__sys_sendmsg",
    "filename": "linux/CVE-2011-4594/CVE-2011-4594_CWE-476_bc909d9ddbf7778371e36a651d6e4194b1cc7d4c_socket.c.diff",
    "function_code": "static int __sys_sendmsg(struct socket *sock, struct msghdr __user *msg,\n\t\t\t struct msghdr *msg_sys, unsigned flags,\n\t\t\t struct used_address *used_address)\n{\n\tstruct compat_msghdr __user *msg_compat =\n\t    (struct compat_msghdr __user *)msg;\n\tstruct sockaddr_storage address;\n\tstruct iovec iovstack[UIO_FASTIOV], *iov = iovstack;\n\tunsigned char ctl[sizeof(struct cmsghdr) + 20]\n\t    __attribute__ ((aligned(sizeof(__kernel_size_t))));\n\t/* 20 is size of ipv6_pktinfo */\n\tunsigned char *ctl_buf = ctl;\n\tint err, ctl_len, iov_size, total_len;\n\n\terr = -EFAULT;\n\tif (MSG_CMSG_COMPAT & flags) {\n\t\tif (get_compat_msghdr(msg_sys, msg_compat))\n\t\t\treturn -EFAULT;\n\t} else if (copy_from_user(msg_sys, msg, sizeof(struct msghdr)))\n\t\treturn -EFAULT;\n\n\t/* do not move before msg_sys is valid */\n\terr = -EMSGSIZE;\n\tif (msg_sys->msg_iovlen > UIO_MAXIOV)\n\t\tgoto out;\n\n\t/* Check whether to allocate the iovec area */\n\terr = -ENOMEM;\n\tiov_size = msg_sys->msg_iovlen * sizeof(struct iovec);\n\tif (msg_sys->msg_iovlen > UIO_FASTIOV) {\n\t\tiov = sock_kmalloc(sock->sk, iov_size, GFP_KERNEL);\n\t\tif (!iov)\n\t\t\tgoto out;\n\t}\n\n\t/* This will also move the address data into kernel space */\n\tif (MSG_CMSG_COMPAT & flags) {\n\t\terr = verify_compat_iovec(msg_sys, iov,\n\t\t\t\t\t  (struct sockaddr *)&address,\n\t\t\t\t\t  VERIFY_READ);\n\t} else\n\t\terr = verify_iovec(msg_sys, iov,\n\t\t\t\t   (struct sockaddr *)&address,\n\t\t\t\t   VERIFY_READ);\n\tif (err < 0)\n\t\tgoto out_freeiov;\n\ttotal_len = err;\n\n\terr = -ENOBUFS;\n\n\tif (msg_sys->msg_controllen > INT_MAX)\n\t\tgoto out_freeiov;\n\tctl_len = msg_sys->msg_controllen;\n\tif ((MSG_CMSG_COMPAT & flags) && ctl_len) {\n\t\terr =\n\t\t    cmsghdr_from_user_compat_to_kern(msg_sys, sock->sk, ctl,\n\t\t\t\t\t\t     sizeof(ctl));\n\t\tif (err)\n\t\t\tgoto out_freeiov;\n\t\tctl_buf = msg_sys->msg_control;\n\t\tctl_len = msg_sys->msg_controllen;\n\t} else if (ctl_len) {\n\t\tif (ctl_len > sizeof(ctl)) {\n\t\t\tctl_buf = sock_kmalloc(sock->sk, ctl_len, GFP_KERNEL);\n\t\t\tif (ctl_buf == NULL)\n\t\t\t\tgoto out_freeiov;\n\t\t}\n\t\terr = -EFAULT;\n\t\t/*\n\t\t * Careful! Before this, msg_sys->msg_control contains a user pointer.\n\t\t * Afterwards, it will be a kernel pointer. Thus the compiler-assisted\n\t\t * checking falls down on this.\n\t\t */\n\t\tif (copy_from_user(ctl_buf,\n\t\t\t\t   (void __user __force *)msg_sys->msg_control,\n\t\t\t\t   ctl_len))\n\t\t\tgoto out_freectl;\n\t\tmsg_sys->msg_control = ctl_buf;\n\t}\n\tmsg_sys->msg_flags = flags;\n\n\tif (sock->file->f_flags & O_NONBLOCK)\n\t\tmsg_sys->msg_flags |= MSG_DONTWAIT;\n\t/*\n\t * If this is sendmmsg() and current destination address is same as\n\t * previously succeeded address, omit asking LSM's decision.\n\t * used_address->name_len is initialized to UINT_MAX so that the first\n\t * destination address never matches.\n\t */\n\tif (used_address && msg_sys->msg_name &&\n\t    used_address->name_len == msg_sys->msg_namelen &&\n\t    !memcmp(&used_address->name, msg_sys->msg_name,\n\t\t    used_address->name_len)) {\n\t\terr = sock_sendmsg_nosec(sock, msg_sys, total_len);\n\t\tgoto out_freectl;\n\t}\n\terr = sock_sendmsg(sock, msg_sys, total_len);\n\t/*\n\t * If this is sendmmsg() and sending to current destination address was\n\t * successful, remember it.\n\t */\n\tif (used_address && err >= 0) {\n\t\tused_address->name_len = msg_sys->msg_namelen;\n\t\tif (msg_sys->msg_name)\n\t\t\tmemcpy(&used_address->name, msg_sys->msg_name,\n\t\t\t       used_address->name_len);\n\t}\n\nout_freectl:\n\tif (ctl_buf != ctl)\n\t\tsock_kfree_s(sock->sk, ctl_buf, ctl_len);\nout_freeiov:\n\tif (iov != iovstack)\n\t\tsock_kfree_s(sock->sk, iov, iov_size);\nout:\n\treturn err;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 5695,
    "critical_vars": [
      "skb"
    ],
    "function": "sctp_sock_migrate",
    "filename": "linux/CVE-2011-2482/CVE-2011-2482_CWE-476_ea2bc483ff5caada7c4aa0d5fbf87d3a6590273d_socket.c.diff",
    "function_code": "static void sctp_sock_migrate(struct sock *oldsk, struct sock *newsk,\n\t\t\t      struct sctp_association *assoc,\n\t\t\t      sctp_socket_type_t type)\n{\n\tstruct sctp_sock *oldsp = sctp_sk(oldsk);\n\tstruct sctp_sock *newsp = sctp_sk(newsk);\n\tstruct sctp_bind_bucket *pp; /* hash list port iterator */\n\tstruct sctp_endpoint *newep = newsp->ep;\n\tstruct sk_buff *skb, *tmp;\n\tstruct sctp_ulpevent *event;\n\tint flags = 0;\n\n\t/* Migrate socket buffer sizes and all the socket level options to the\n\t * new socket.\n\t */\n\tnewsk->sk_sndbuf = oldsk->sk_sndbuf;\n\tnewsk->sk_rcvbuf = oldsk->sk_rcvbuf;\n\t/* Brute force copy old sctp opt. */\n\tinet_sk_copy_descendant(newsk, oldsk);\n\n\t/* Restore the ep value that was overwritten with the above structure\n\t * copy.\n\t */\n\tnewsp->ep = newep;\n\tnewsp->hmac = NULL;\n\n\t/* Hook this new socket in to the bind_hash list. */\n\tpp = sctp_sk(oldsk)->bind_hash;\n\tsk_add_bind_node(newsk, &pp->owner);\n\tsctp_sk(newsk)->bind_hash = pp;\n\tinet_sk(newsk)->num = inet_sk(oldsk)->num;\n\n\t/* Copy the bind_addr list from the original endpoint to the new\n\t * endpoint so that we can handle restarts properly\n\t */\n\tif (PF_INET6 == assoc->base.sk->sk_family)\n\t\tflags = SCTP_ADDR6_ALLOWED;\n\tif (assoc->peer.ipv4_address)\n\t\tflags |= SCTP_ADDR4_PEERSUPP;\n\tif (assoc->peer.ipv6_address)\n\t\tflags |= SCTP_ADDR6_PEERSUPP;\n\tsctp_bind_addr_copy(&newsp->ep->base.bind_addr,\n\t\t\t     &oldsp->ep->base.bind_addr,\n\t\t\t     SCTP_SCOPE_GLOBAL, GFP_KERNEL, flags);\n\n\t/* Move any messages in the old socket's receive queue that are for the\n\t * peeled off association to the new socket's receive queue.\n\t */\n\tsctp_skb_for_each(skb, &oldsk->sk_receive_queue, tmp) {\n\t\tevent = sctp_skb2event(skb);\n\t\tif (event->asoc == assoc) {\n\t\t\tsctp_sock_rfree(skb);\n\t\t\t__skb_unlink(skb, &oldsk->sk_receive_queue);\n\t\t\t__skb_queue_tail(&newsk->sk_receive_queue, skb);\n\t\t\tsctp_skb_set_owner_r(skb, newsk);\n\t\t}\n\t}\n\n\t/* Clean up any messages pending delivery due to partial\n\t * delivery.   Three cases:\n\t * 1) No partial deliver;  no work.\n\t * 2) Peeling off partial delivery; keep pd_lobby in new pd_lobby.\n\t * 3) Peeling off non-partial delivery; move pd_lobby to receive_queue.\n\t */\n\tskb_queue_head_init(&newsp->pd_lobby);\n\tsctp_sk(newsk)->pd_mode = assoc->ulpq.pd_mode;\n\n\tif (sctp_sk(oldsk)->pd_mode) {\n\t\tstruct sk_buff_head *queue;\n\n\t\t/* Decide which queue to move pd_lobby skbs to. */\n\t\tif (assoc->ulpq.pd_mode) {\n\t\t\tqueue = &newsp->pd_lobby;\n\t\t} else\n\t\t\tqueue = &newsk->sk_receive_queue;\n\n\t\t/* Walk through the pd_lobby, looking for skbs that\n\t\t * need moved to the new socket.\n\t\t */\n\t\tsctp_skb_for_each(skb, &oldsp->pd_lobby, tmp) {\n\t\t\tevent = sctp_skb2event(skb);\n\t\t\tif (event->asoc == assoc) {\n\t\t\t\tsctp_sock_rfree(skb);\n\t\t\t\t__skb_unlink(skb, &oldsp->pd_lobby);\n\t\t\t\t__skb_queue_tail(queue, skb);\n\t\t\t\tsctp_skb_set_owner_r(skb, newsk);\n\t\t\t}\n\t\t}\n\n\t\t/* Clear up any skbs waiting for the partial\n\t\t * delivery to finish.\n\t\t */\n\t\tif (assoc->ulpq.pd_mode)\n\t\t\tsctp_clear_pd(oldsk);\n\n\t}\n\n\t/* Set the type of socket to indicate that it is peeled off from the\n\t * original UDP-style socket or created with the accept() call on a\n\t * TCP-style socket..\n\t */\n\tnewsp->type = type;\n\n\t/* Mark the new socket \"in-use\" by the user so that any packets\n\t * that may arrive on the association after we've moved it are\n\t * queued to the backlog.  This prevents a potential race between\n\t * backlog processing on the old socket and new-packet processing\n\t * on the new socket.\n\t */\n\tsctp_lock_sock(newsk);\n\tsctp_assoc_migrate(assoc, newsk);\n\n\t/* If the association on the newsk is already closed before accept()\n\t * is called, set RCV_SHUTDOWN flag.\n\t */\n\tif (sctp_state(assoc, CLOSED) && sctp_style(newsk, TCP))\n\t\tnewsk->sk_shutdown |= RCV_SHUTDOWN;\n\n\tnewsk->sk_state = SCTP_SS_ESTABLISHED;\n\tsctp_release_sock(newsk);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 5725,
    "critical_vars": [
      "skb"
    ],
    "function": "sctp_sock_migrate",
    "filename": "linux/CVE-2011-2482/CVE-2011-2482_CWE-476_ea2bc483ff5caada7c4aa0d5fbf87d3a6590273d_socket.c.diff",
    "function_code": "static void sctp_sock_migrate(struct sock *oldsk, struct sock *newsk,\n\t\t\t      struct sctp_association *assoc,\n\t\t\t      sctp_socket_type_t type)\n{\n\tstruct sctp_sock *oldsp = sctp_sk(oldsk);\n\tstruct sctp_sock *newsp = sctp_sk(newsk);\n\tstruct sctp_bind_bucket *pp; /* hash list port iterator */\n\tstruct sctp_endpoint *newep = newsp->ep;\n\tstruct sk_buff *skb, *tmp;\n\tstruct sctp_ulpevent *event;\n\tint flags = 0;\n\n\t/* Migrate socket buffer sizes and all the socket level options to the\n\t * new socket.\n\t */\n\tnewsk->sk_sndbuf = oldsk->sk_sndbuf;\n\tnewsk->sk_rcvbuf = oldsk->sk_rcvbuf;\n\t/* Brute force copy old sctp opt. */\n\tinet_sk_copy_descendant(newsk, oldsk);\n\n\t/* Restore the ep value that was overwritten with the above structure\n\t * copy.\n\t */\n\tnewsp->ep = newep;\n\tnewsp->hmac = NULL;\n\n\t/* Hook this new socket in to the bind_hash list. */\n\tpp = sctp_sk(oldsk)->bind_hash;\n\tsk_add_bind_node(newsk, &pp->owner);\n\tsctp_sk(newsk)->bind_hash = pp;\n\tinet_sk(newsk)->num = inet_sk(oldsk)->num;\n\n\t/* Copy the bind_addr list from the original endpoint to the new\n\t * endpoint so that we can handle restarts properly\n\t */\n\tif (PF_INET6 == assoc->base.sk->sk_family)\n\t\tflags = SCTP_ADDR6_ALLOWED;\n\tif (assoc->peer.ipv4_address)\n\t\tflags |= SCTP_ADDR4_PEERSUPP;\n\tif (assoc->peer.ipv6_address)\n\t\tflags |= SCTP_ADDR6_PEERSUPP;\n\tsctp_bind_addr_copy(&newsp->ep->base.bind_addr,\n\t\t\t     &oldsp->ep->base.bind_addr,\n\t\t\t     SCTP_SCOPE_GLOBAL, GFP_KERNEL, flags);\n\n\t/* Move any messages in the old socket's receive queue that are for the\n\t * peeled off association to the new socket's receive queue.\n\t */\n\tsctp_skb_for_each(skb, &oldsk->sk_receive_queue, tmp) {\n\t\tevent = sctp_skb2event(skb);\n\t\tif (event->asoc == assoc) {\n\t\t\tsctp_sock_rfree_frag(skb);\n\t\t\t__skb_unlink(skb, &oldsk->sk_receive_queue);\n\t\t\t__skb_queue_tail(&newsk->sk_receive_queue, skb);\n\t\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\t\t}\n\t}\n\n\t/* Clean up any messages pending delivery due to partial\n\t * delivery.   Three cases:\n\t * 1) No partial deliver;  no work.\n\t * 2) Peeling off partial delivery; keep pd_lobby in new pd_lobby.\n\t * 3) Peeling off non-partial delivery; move pd_lobby to receive_queue.\n\t */\n\tskb_queue_head_init(&newsp->pd_lobby);\n\tsctp_sk(newsk)->pd_mode = assoc->ulpq.pd_mode;\n\n\tif (sctp_sk(oldsk)->pd_mode) {\n\t\tstruct sk_buff_head *queue;\n\n\t\t/* Decide which queue to move pd_lobby skbs to. */\n\t\tif (assoc->ulpq.pd_mode) {\n\t\t\tqueue = &newsp->pd_lobby;\n\t\t} else\n\t\t\tqueue = &newsk->sk_receive_queue;\n\n\t\t/* Walk through the pd_lobby, looking for skbs that\n\t\t * need moved to the new socket.\n\t\t */\n\t\tsctp_skb_for_each(skb, &oldsp->pd_lobby, tmp) {\n\t\t\tevent = sctp_skb2event(skb);\n\t\t\tif (event->asoc == assoc) {\n\t\t\t\tsctp_sock_rfree_frag(skb);\n\t\t\t\t__skb_unlink(skb, &oldsp->pd_lobby);\n\t\t\t\t__skb_queue_tail(queue, skb);\n\t\t\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\t\t\t}\n\t\t}\n\n\t\t/* Clear up any skbs waiting for the partial\n\t\t * delivery to finish.\n\t\t */\n\t\tif (assoc->ulpq.pd_mode)\n\t\t\tsctp_clear_pd(oldsk);\n\n\t}\n\n\tsctp_skb_for_each(skb, &assoc->ulpq.reasm, tmp) {\n\t\tsctp_sock_rfree_frag(skb);\n\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\t}\n\n\tsctp_skb_for_each(skb, &assoc->ulpq.lobby, tmp) {\n\t\tsctp_sock_rfree_frag(skb);\n\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\t}\n\n\t/* Set the type of socket to indicate that it is peeled off from the\n\t * original UDP-style socket or created with the accept() call on a\n\t * TCP-style socket..\n\t */\n\tnewsp->type = type;\n\n\t/* Mark the new socket \"in-use\" by the user so that any packets\n\t * that may arrive on the association after we've moved it are\n\t * queued to the backlog.  This prevents a potential race between\n\t * backlog processing on the old socket and new-packet processing\n\t * on the new socket.\n\t */\n\tsctp_lock_sock(newsk);\n\tsctp_assoc_migrate(assoc, newsk);\n\n\t/* If the association on the newsk is already closed before accept()\n\t * is called, set RCV_SHUTDOWN flag.\n\t */\n\tif (sctp_state(assoc, CLOSED) && sctp_style(newsk, TCP))\n\t\tnewsk->sk_shutdown |= RCV_SHUTDOWN;\n\n\tnewsk->sk_state = SCTP_SS_ESTABLISHED;\n\tsctp_release_sock(newsk);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 7976,
    "critical_vars": [
      "req->ctx->file_data"
    ],
    "function": "io_files_update_with_index_alloc",
    "filename": "linux/CVE-2022-4127/CVE-2022-4127_CWE-476_d785a773bed966a75ca1f11d108ae1897189975b_io_uring.c.diff",
    "function_code": "\nstatic int io_files_update_with_index_alloc(struct io_kiocb *req,\n\t\t\t\t\t    unsigned int issue_flags)\n{\n\t__s32 __user *fds = u64_to_user_ptr(req->rsrc_update.arg);\n\tunsigned int done;\n\tstruct file *file;\n\tint ret, fd;\n\n\tif (!req->ctx->file_data)\n\t\treturn -ENXIO;\n\n\tfor (done = 0; done < req->rsrc_update.nr_args; done++) {\n\t\tif (copy_from_user(&fd, &fds[done], sizeof(fd))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tfile = fget(fd);\n\t\tif (!file) {\n\t\t\tret = -EBADF;\n\t\t\tbreak;\n\t\t}\n\t\tret = io_fixed_fd_install(req, issue_flags, file,\n\t\t\t\t\t  IORING_FILE_INDEX_ALLOC);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (copy_to_user(&fds[done], &ret, sizeof(ret))) {\n\t\t\t__io_close_fixed(req, issue_flags, ret);\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (done)\n\t\treturn done;\n\treturn ret;",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1672,
    "critical_vars": [
      "rq->rx_ring[0].base"
    ],
    "function": "vmxnet3_rq_cleanup",
    "filename": "linux/CVE-2023-4459/CVE-2023-4459_CWE-476_edf410cb74dc612fd47ef5be319c5a0bcd6e6ccd_vmxnet3_drv.c.diff",
    "function_code": "vmxnet3_rq_cleanup(struct vmxnet3_rx_queue *rq,\n\t\t   struct vmxnet3_adapter *adapter)\n{\n\tu32 i, ring_idx;\n\tstruct Vmxnet3_RxDesc *rxd;\n\n\t/* ring has already been cleaned up */\n\tif (!rq->rx_ring[0].base)\n\t\treturn;\n\n\tfor (ring_idx = 0; ring_idx < 2; ring_idx++) {\n\t\tfor (i = 0; i < rq->rx_ring[ring_idx].size; i++) {\n#ifdef __BIG_ENDIAN_BITFIELD\n\t\t\tstruct Vmxnet3_RxDesc rxDesc;\n#endif\n\t\t\tvmxnet3_getRxDesc(rxd,\n\t\t\t\t&rq->rx_ring[ring_idx].base[i].rxd, &rxDesc);\n\n\t\t\tif (rxd->btype == VMXNET3_RXD_BTYPE_HEAD &&\n\t\t\t\t\trq->buf_info[ring_idx][i].skb) {\n\t\t\t\tdma_unmap_single(&adapter->pdev->dev, rxd->addr,\n\t\t\t\t\t\t rxd->len, DMA_FROM_DEVICE);\n\t\t\t\tdev_kfree_skb(rq->buf_info[ring_idx][i].skb);\n\t\t\t\trq->buf_info[ring_idx][i].skb = NULL;\n\t\t\t} else if (rxd->btype == VMXNET3_RXD_BTYPE_BODY &&\n\t\t\t\t\trq->buf_info[ring_idx][i].page) {\n\t\t\t\tdma_unmap_page(&adapter->pdev->dev, rxd->addr,\n\t\t\t\t\t       rxd->len, DMA_FROM_DEVICE);\n\t\t\t\tput_page(rq->buf_info[ring_idx][i].page);\n\t\t\t\trq->buf_info[ring_idx][i].page = NULL;\n\t\t\t}\n\t\t}\n\n\t\trq->rx_ring[ring_idx].gen = VMXNET3_INIT_GEN;\n\t\trq->rx_ring[ring_idx].next2fill =\n\t\t\t\t\trq->rx_ring[ring_idx].next2comp = 0;\n\t}\n\n\trq->comp_ring.gen = VMXNET3_INIT_GEN;\n\trq->comp_ring.next2proc = 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 647,
    "line_new": 647,
    "critical_vars": [
      "r"
    ],
    "function": "kvm_vm_ioctl_check_extension",
    "filename": "linux/CVE-2017-15306/CVE-2017-15306_CWE-476_ac64115a66c18c01745bbd3c47a36b124e5fd8c0_powerpc.c.diff",
    "function_code": "int kvm_vm_ioctl_check_extension(struct kvm *kvm, long ext)\n{\n\tint r;\n\t/* Assume we're using HV mode when the HV module is loaded */\n\tint hv_enabled = kvmppc_hv_ops ? 1 : 0;\n\n\tif (kvm) {\n\t\t/*\n\t\t * Hooray - we know which VM type we're running on. Depend on\n\t\t * that rather than the guess above.\n\t\t */\n\t\thv_enabled = is_kvmppc_hv_enabled(kvm);\n\t}\n\n\tswitch (ext) {\n#ifdef CONFIG_BOOKE\n\tcase KVM_CAP_PPC_BOOKE_SREGS:\n\tcase KVM_CAP_PPC_BOOKE_WATCHDOG:\n\tcase KVM_CAP_PPC_EPR:\n#else\n\tcase KVM_CAP_PPC_SEGSTATE:\n\tcase KVM_CAP_PPC_HIOR:\n\tcase KVM_CAP_PPC_PAPR:\n#endif\n\tcase KVM_CAP_PPC_UNSET_IRQ:\n\tcase KVM_CAP_PPC_IRQ_LEVEL:\n\tcase KVM_CAP_ENABLE_CAP:\n\tcase KVM_CAP_ENABLE_CAP_VM:\n\tcase KVM_CAP_ONE_REG:\n\tcase KVM_CAP_IOEVENTFD:\n\tcase KVM_CAP_DEVICE_CTRL:\n\tcase KVM_CAP_IMMEDIATE_EXIT:\n\t\tr = 1;\n\t\tbreak;\n\tcase KVM_CAP_PPC_PAIRED_SINGLES:\n\tcase KVM_CAP_PPC_OSI:\n\tcase KVM_CAP_PPC_GET_PVINFO:\n#if defined(CONFIG_KVM_E500V2) || defined(CONFIG_KVM_E500MC)\n\tcase KVM_CAP_SW_TLB:\n#endif\n\t\t/* We support this only for PR */\n\t\tr = !hv_enabled;\n\t\tbreak;\n#ifdef CONFIG_KVM_MPIC\n\tcase KVM_CAP_IRQ_MPIC:\n\t\tr = 1;\n\t\tbreak;\n#endif\n\n#ifdef CONFIG_PPC_BOOK3S_64\n\tcase KVM_CAP_SPAPR_TCE:\n\tcase KVM_CAP_SPAPR_TCE_64:\n\t\t/* fallthrough */\n\tcase KVM_CAP_SPAPR_TCE_VFIO:\n\tcase KVM_CAP_PPC_RTAS:\n\tcase KVM_CAP_PPC_FIXUP_HCALL:\n\tcase KVM_CAP_PPC_ENABLE_HCALL:\n#ifdef CONFIG_KVM_XICS\n\tcase KVM_CAP_IRQ_XICS:\n#endif\n\t\tr = 1;\n\t\tbreak;\n\n\tcase KVM_CAP_PPC_ALLOC_HTAB:\n\t\tr = hv_enabled;\n\t\tbreak;\n#endif /* CONFIG_PPC_BOOK3S_64 */\n#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE\n\tcase KVM_CAP_PPC_SMT:\n\t\tr = 0;\n\t\tif (kvm) {\n\t\t\tif (kvm->arch.emul_smt_mode > 1)\n\t\t\t\tr = kvm->arch.emul_smt_mode;\n\t\t\telse\n\t\t\t\tr = kvm->arch.smt_mode;\n\t\t} else if (hv_enabled) {\n\t\t\tif (cpu_has_feature(CPU_FTR_ARCH_300))\n\t\t\t\tr = 1;\n\t\t\telse\n\t\t\t\tr = threads_per_subcore;\n\t\t}\n\t\tbreak;\n\tcase KVM_CAP_PPC_SMT_POSSIBLE:\n\t\tr = 1;\n\t\tif (hv_enabled) {\n\t\t\tif (!cpu_has_feature(CPU_FTR_ARCH_300))\n\t\t\t\tr = ((threads_per_subcore << 1) - 1);\n\t\t\telse\n\t\t\t\t/* P9 can emulate dbells, so allow any mode */\n\t\t\t\tr = 8 | 4 | 2 | 1;\n\t\t}\n\t\tbreak;\n\tcase KVM_CAP_PPC_RMA:\n\t\tr = 0;\n\t\tbreak;\n\tcase KVM_CAP_PPC_HWRNG:\n\t\tr = kvmppc_hwrng_present();\n\t\tbreak;\n\tcase KVM_CAP_PPC_MMU_RADIX:\n\t\tr = !!(hv_enabled && radix_enabled());\n\t\tbreak;\n\tcase KVM_CAP_PPC_MMU_HASH_V3:\n\t\tr = !!(hv_enabled && !radix_enabled() &&\n\t\t       cpu_has_feature(CPU_FTR_ARCH_300));\n\t\tbreak;\n#endif\n\tcase KVM_CAP_SYNC_MMU:\n#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE\n\t\tr = hv_enabled;\n#elif defined(KVM_ARCH_WANT_MMU_NOTIFIER)\n\t\tr = 1;\n#else\n\t\tr = 0;\n#endif\n\t\tbreak;\n#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE\n\tcase KVM_CAP_PPC_HTAB_FD:\n\t\tr = hv_enabled;\n\t\tbreak;\n#endif\n\tcase KVM_CAP_NR_VCPUS:\n\t\t/*\n\t\t * Recommending a number of CPUs is somewhat arbitrary; we\n\t\t * return the number of present CPUs for -HV (since a host\n\t\t * will have secondary threads \"offline\"), and for other KVM\n\t\t * implementations just count online CPUs.\n\t\t */\n\t\tif (hv_enabled)\n\t\t\tr = num_present_cpus();\n\t\telse\n\t\t\tr = num_online_cpus();\n\t\tbreak;\n\tcase KVM_CAP_NR_MEMSLOTS:\n\t\tr = KVM_USER_MEM_SLOTS;\n\t\tbreak;\n\tcase KVM_CAP_MAX_VCPUS:\n\t\tr = KVM_MAX_VCPUS;\n\t\tbreak;\n#ifdef CONFIG_PPC_BOOK3S_64\n\tcase KVM_CAP_PPC_GET_SMMU_INFO:\n\t\tr = 1;\n\t\tbreak;\n\tcase KVM_CAP_SPAPR_MULTITCE:\n\t\tr = 1;\n\t\tbreak;\n\tcase KVM_CAP_SPAPR_RESIZE_HPT:\n\t\t/* Disable this on POWER9 until code handles new HPTE format */\n\t\tr = !!hv_enabled && !cpu_has_feature(CPU_FTR_ARCH_300);\n\t\tbreak;\n#endif\n#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE\n\tcase KVM_CAP_PPC_FWNMI:\n\t\tr = hv_enabled;\n\t\tbreak;\n#endif\n\tcase KVM_CAP_PPC_HTM:\n\t\tr = cpu_has_feature(CPU_FTR_TM_COMP) && hv_enabled;\n\t\tbreak;\n\tdefault:\n\t\tr = 0;\n\t\tbreak;\n\t}\n\treturn r;\n\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 727,
    "critical_vars": [
      "new_n0->back_pointer"
    ],
    "function": "assoc_array_insert_into_terminal_node",
    "filename": "linux/CVE-2017-12193/CVE-2017-12193_CWE-476_ea6789980fdaa610d7eb63602c746bf6ec70cd2b_assoc_array.c.diff",
    "function_code": "static bool assoc_array_insert_into_terminal_node(struct assoc_array_edit *edit,\n\t\t\t\t\t\t  const struct assoc_array_ops *ops,\n\t\t\t\t\t\t  const void *index_key,\n\t\t\t\t\t\t  struct assoc_array_walk_result *result)\n{\n\tstruct assoc_array_shortcut *shortcut, *new_s0;\n\tstruct assoc_array_node *node, *new_n0, *new_n1, *side;\n\tstruct assoc_array_ptr *ptr;\n\tunsigned long dissimilarity, base_seg, blank;\n\tsize_t keylen;\n\tbool have_meta;\n\tint level, diff;\n\tint slot, next_slot, free_slot, i, j;\n\n\tnode\t= result->terminal_node.node;\n\tlevel\t= result->terminal_node.level;\n\tedit->segment_cache[ASSOC_ARRAY_FAN_OUT] = result->terminal_node.slot;\n\n\tpr_devel(\"-->%s()\\n\", __func__);\n\n\t/* We arrived at a node which doesn't have an onward node or shortcut\n\t * pointer that we have to follow.  This means that (a) the leaf we\n\t * want must go here (either by insertion or replacement) or (b) we\n\t * need to split this node and insert in one of the fragments.\n\t */\n\tfree_slot = -1;\n\n\t/* Firstly, we have to check the leaves in this node to see if there's\n\t * a matching one we should replace in place.\n\t */\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tptr = node->slots[i];\n\t\tif (!ptr) {\n\t\t\tfree_slot = i;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ops->compare_object(assoc_array_ptr_to_leaf(ptr), index_key)) {\n\t\t\tpr_devel(\"replace in slot %d\\n\", i);\n\t\t\tedit->leaf_p = &node->slots[i];\n\t\t\tedit->dead_leaf = node->slots[i];\n\t\t\tpr_devel(\"<--%s() = ok [replace]\\n\", __func__);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/* If there is a free slot in this node then we can just insert the\n\t * leaf here.\n\t */\n\tif (free_slot >= 0) {\n\t\tpr_devel(\"insert in free slot %d\\n\", free_slot);\n\t\tedit->leaf_p = &node->slots[free_slot];\n\t\tedit->adjust_count_on = node;\n\t\tpr_devel(\"<--%s() = ok [insert]\\n\", __func__);\n\t\treturn true;\n\t}\n\n\t/* The node has no spare slots - so we're either going to have to split\n\t * it or insert another node before it.\n\t *\n\t * Whatever, we're going to need at least two new nodes - so allocate\n\t * those now.  We may also need a new shortcut, but we deal with that\n\t * when we need it.\n\t */\n\tnew_n0 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);\n\tif (!new_n0)\n\t\treturn false;\n\tedit->new_meta[0] = assoc_array_node_to_ptr(new_n0);\n\tnew_n1 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);\n\tif (!new_n1)\n\t\treturn false;\n\tedit->new_meta[1] = assoc_array_node_to_ptr(new_n1);\n\n\t/* We need to find out how similar the leaves are. */\n\tpr_devel(\"no spare slots\\n\");\n\thave_meta = false;\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tptr = node->slots[i];\n\t\tif (assoc_array_ptr_is_meta(ptr)) {\n\t\t\tedit->segment_cache[i] = 0xff;\n\t\t\thave_meta = true;\n\t\t\tcontinue;\n\t\t}\n\t\tbase_seg = ops->get_object_key_chunk(\n\t\t\tassoc_array_ptr_to_leaf(ptr), level);\n\t\tbase_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;\n\t\tedit->segment_cache[i] = base_seg & ASSOC_ARRAY_FAN_MASK;\n\t}\n\n\tif (have_meta) {\n\t\tpr_devel(\"have meta\\n\");\n\t\tgoto split_node;\n\t}\n\n\t/* The node contains only leaves */\n\tdissimilarity = 0;\n\tbase_seg = edit->segment_cache[0];\n\tfor (i = 1; i < ASSOC_ARRAY_FAN_OUT; i++)\n\t\tdissimilarity |= edit->segment_cache[i] ^ base_seg;\n\n\tpr_devel(\"only leaves; dissimilarity=%lx\\n\", dissimilarity);\n\n\tif ((dissimilarity & ASSOC_ARRAY_FAN_MASK) == 0) {\n\t\t/* The old leaves all cluster in the same slot.  We will need\n\t\t * to insert a shortcut if the new node wants to cluster with them.\n\t\t */\n\t\tif ((edit->segment_cache[ASSOC_ARRAY_FAN_OUT] ^ base_seg) == 0)\n\t\t\tgoto all_leaves_cluster_together;\n\n\t\t/* Otherwise we can just insert a new node ahead of the old\n\t\t * one.\n\t\t */\n\t\tgoto present_leaves_cluster_but_not_new_leaf;\n\t}\n\nsplit_node:\n\tpr_devel(\"split node\\n\");\n\n\t/* We need to split the current node; we know that the node doesn't\n\t * simply contain a full set of leaves that cluster together (it\n\t * contains meta pointers and/or non-clustering leaves).\n\t *\n\t * We need to expel at least two leaves out of a set consisting of the\n\t * leaves in the node and the new leaf.\n\t *\n\t * We need a new node (n0) to replace the current one and a new node to\n\t * take the expelled nodes (n1).\n\t */\n\tedit->set[0].to = assoc_array_node_to_ptr(new_n0);\n\tnew_n0->back_pointer = node->back_pointer;\n\tnew_n0->parent_slot = node->parent_slot;\n\tnew_n1->back_pointer = assoc_array_node_to_ptr(new_n0);\n\tnew_n1->parent_slot = -1; /* Need to calculate this */\n\ndo_split_node:\n\tpr_devel(\"do_split_node\\n\");\n\n\tnew_n0->nr_leaves_on_branch = node->nr_leaves_on_branch;\n\tnew_n1->nr_leaves_on_branch = 0;\n\n\t/* Begin by finding two matching leaves.  There have to be at least two\n\t * that match - even if there are meta pointers - because any leaf that\n\t * would match a slot with a meta pointer in it must be somewhere\n\t * behind that meta pointer and cannot be here.  Further, given N\n\t * remaining leaf slots, we now have N+1 leaves to go in them.\n\t */\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tslot = edit->segment_cache[i];\n\t\tif (slot != 0xff)\n\t\t\tfor (j = i + 1; j < ASSOC_ARRAY_FAN_OUT + 1; j++)\n\t\t\t\tif (edit->segment_cache[j] == slot)\n\t\t\t\t\tgoto found_slot_for_multiple_occupancy;\n\t}\nfound_slot_for_multiple_occupancy:\n\tpr_devel(\"same slot: %x %x [%02x]\\n\", i, j, slot);\n\tBUG_ON(i >= ASSOC_ARRAY_FAN_OUT);\n\tBUG_ON(j >= ASSOC_ARRAY_FAN_OUT + 1);\n\tBUG_ON(slot >= ASSOC_ARRAY_FAN_OUT);\n\n\tnew_n1->parent_slot = slot;\n\n\t/* Metadata pointers cannot change slot */\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++)\n\t\tif (assoc_array_ptr_is_meta(node->slots[i]))\n\t\t\tnew_n0->slots[i] = node->slots[i];\n\t\telse\n\t\t\tnew_n0->slots[i] = NULL;\n\tBUG_ON(new_n0->slots[slot] != NULL);\n\tnew_n0->slots[slot] = assoc_array_node_to_ptr(new_n1);\n\n\t/* Filter the leaf pointers between the new nodes */\n\tfree_slot = -1;\n\tnext_slot = 0;\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tif (assoc_array_ptr_is_meta(node->slots[i]))\n\t\t\tcontinue;\n\t\tif (edit->segment_cache[i] == slot) {\n\t\t\tnew_n1->slots[next_slot++] = node->slots[i];\n\t\t\tnew_n1->nr_leaves_on_branch++;\n\t\t} else {\n\t\t\tdo {\n\t\t\t\tfree_slot++;\n\t\t\t} while (new_n0->slots[free_slot] != NULL);\n\t\t\tnew_n0->slots[free_slot] = node->slots[i];\n\t\t}\n\t}\n\n\tpr_devel(\"filtered: f=%x n=%x\\n\", free_slot, next_slot);\n\n\tif (edit->segment_cache[ASSOC_ARRAY_FAN_OUT] != slot) {\n\t\tdo {\n\t\t\tfree_slot++;\n\t\t} while (new_n0->slots[free_slot] != NULL);\n\t\tedit->leaf_p = &new_n0->slots[free_slot];\n\t\tedit->adjust_count_on = new_n0;\n\t} else {\n\t\tedit->leaf_p = &new_n1->slots[next_slot++];\n\t\tedit->adjust_count_on = new_n1;\n\t}\n\n\tBUG_ON(next_slot <= 1);\n\n\tedit->set_backpointers_to = assoc_array_node_to_ptr(new_n0);\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tif (edit->segment_cache[i] == 0xff) {\n\t\t\tptr = node->slots[i];\n\t\t\tBUG_ON(assoc_array_ptr_is_leaf(ptr));\n\t\t\tif (assoc_array_ptr_is_node(ptr)) {\n\t\t\t\tside = assoc_array_ptr_to_node(ptr);\n\t\t\t\tedit->set_backpointers[i] = &side->back_pointer;\n\t\t\t} else {\n\t\t\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\t\t\tedit->set_backpointers[i] = &shortcut->back_pointer;\n\t\t\t}\n\t\t}\n\t}\n\n\tptr = node->back_pointer;\n\tif (!ptr)\n\t\tedit->set[0].ptr = &edit->array->root;\n\telse if (assoc_array_ptr_is_node(ptr))\n\t\tedit->set[0].ptr = &assoc_array_ptr_to_node(ptr)->slots[node->parent_slot];\n\telse\n\t\tedit->set[0].ptr = &assoc_array_ptr_to_shortcut(ptr)->next_node;\n\tedit->excised_meta[0] = assoc_array_node_to_ptr(node);\n\tpr_devel(\"<--%s() = ok [split node]\\n\", __func__);\n\treturn true;\n\npresent_leaves_cluster_but_not_new_leaf:\n\t/* All the old leaves cluster in the same slot, but the new leaf wants\n\t * to go into a different slot, so we create a new node to hold the new\n\t * leaf and a pointer to a new node holding all the old leaves.\n\t */\n\tpr_devel(\"present leaves cluster but not new leaf\\n\");\n\n\tnew_n0->back_pointer = node->back_pointer;\n\tnew_n0->parent_slot = node->parent_slot;\n\tnew_n0->nr_leaves_on_branch = node->nr_leaves_on_branch;\n\tnew_n1->back_pointer = assoc_array_node_to_ptr(new_n0);\n\tnew_n1->parent_slot = edit->segment_cache[0];\n\tnew_n1->nr_leaves_on_branch = node->nr_leaves_on_branch;\n\tedit->adjust_count_on = new_n0;\n\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++)\n\t\tnew_n1->slots[i] = node->slots[i];\n\n\tnew_n0->slots[edit->segment_cache[0]] = assoc_array_node_to_ptr(new_n0);\n\tedit->leaf_p = &new_n0->slots[edit->segment_cache[ASSOC_ARRAY_FAN_OUT]];\n\n\tedit->set[0].ptr = &assoc_array_ptr_to_node(node->back_pointer)->slots[node->parent_slot];\n\tedit->set[0].to = assoc_array_node_to_ptr(new_n0);\n\tedit->excised_meta[0] = assoc_array_node_to_ptr(node);\n\tpr_devel(\"<--%s() = ok [insert node before]\\n\", __func__);\n\treturn true;\n\nall_leaves_cluster_together:\n\t/* All the leaves, new and old, want to cluster together in this node\n\t * in the same slot, so we have to replace this node with a shortcut to\n\t * skip over the identical parts of the key and then place a pair of\n\t * nodes, one inside the other, at the end of the shortcut and\n\t * distribute the keys between them.\n\t *\n\t * Firstly we need to work out where the leaves start diverging as a\n\t * bit position into their keys so that we know how big the shortcut\n\t * needs to be.\n\t *\n\t * We only need to make a single pass of N of the N+1 leaves because if\n\t * any keys differ between themselves at bit X then at least one of\n\t * them must also differ with the base key at bit X or before.\n\t */\n\tpr_devel(\"all leaves cluster together\\n\");\n\tdiff = INT_MAX;\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tint x = ops->diff_objects(assoc_array_ptr_to_leaf(node->slots[i]),\n\t\t\t\t\t  index_key);\n\t\tif (x < diff) {\n\t\t\tBUG_ON(x < 0);\n\t\t\tdiff = x;\n\t\t}\n\t}\n\tBUG_ON(diff == INT_MAX);\n\tBUG_ON(diff < level + ASSOC_ARRAY_LEVEL_STEP);\n\n\tkeylen = round_up(diff, ASSOC_ARRAY_KEY_CHUNK_SIZE);\n\tkeylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT;\n\n\tnew_s0 = kzalloc(sizeof(struct assoc_array_shortcut) +\n\t\t\t keylen * sizeof(unsigned long), GFP_KERNEL);\n\tif (!new_s0)\n\t\treturn false;\n\tedit->new_meta[2] = assoc_array_shortcut_to_ptr(new_s0);\n\n\tedit->set[0].to = assoc_array_shortcut_to_ptr(new_s0);\n\tnew_s0->back_pointer = node->back_pointer;\n\tnew_s0->parent_slot = node->parent_slot;\n\tnew_s0->next_node = assoc_array_node_to_ptr(new_n0);\n\tnew_n0->back_pointer = assoc_array_shortcut_to_ptr(new_s0);\n\tnew_n0->parent_slot = 0;\n\tnew_n1->back_pointer = assoc_array_node_to_ptr(new_n0);\n\tnew_n1->parent_slot = -1; /* Need to calculate this */\n\n\tnew_s0->skip_to_level = level = diff & ~ASSOC_ARRAY_LEVEL_STEP_MASK;\n\tpr_devel(\"skip_to_level = %d [diff %d]\\n\", level, diff);\n\tBUG_ON(level <= 0);\n\n\tfor (i = 0; i < keylen; i++)\n\t\tnew_s0->index_key[i] =\n\t\t\tops->get_key_chunk(index_key, i * ASSOC_ARRAY_KEY_CHUNK_SIZE);\n\n\tblank = ULONG_MAX << (level & ASSOC_ARRAY_KEY_CHUNK_MASK);\n\tpr_devel(\"blank off [%zu] %d: %lx\\n\", keylen - 1, level, blank);\n\tnew_s0->index_key[keylen - 1] &= ~blank;\n\n\t/* This now reduces to a node splitting exercise for which we'll need\n\t * to regenerate the disparity table.\n\t */\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tptr = node->slots[i];\n\t\tbase_seg = ops->get_object_key_chunk(assoc_array_ptr_to_leaf(ptr),\n\t\t\t\t\t\t     level);\n\t\tbase_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;\n\t\tedit->segment_cache[i] = base_seg & ASSOC_ARRAY_FAN_MASK;\n\t}\n\n\tbase_seg = ops->get_key_chunk(index_key, level);\n\tbase_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;\n\tedit->segment_cache[ASSOC_ARRAY_FAN_OUT] = base_seg & ASSOC_ARRAY_FAN_MASK;\n\tgoto do_split_node;\n}",
    "label": "True"
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 527,
    "line_new": 527,
    "critical_vars": [
      "index_key",
      "ptr"
    ],
    "function": "assoc_array_insert_into_terminal_node",
    "filename": "linux/CVE-2016-7914/CVE-2016-7914_CWE-476_8d4a2ec1e0b41b0cf9a0c5cd4511da7f8e4f3de2_assoc_array.c.diff",
    "function_code": "static bool assoc_array_insert_into_terminal_node(struct assoc_array_edit *edit,\n\t\t\t\t\t\t  const struct assoc_array_ops *ops,\n\t\t\t\t\t\t  const void *index_key,\n\t\t\t\t\t\t  struct assoc_array_walk_result *result)\n{\n\tstruct assoc_array_shortcut *shortcut, *new_s0;\n\tstruct assoc_array_node *node, *new_n0, *new_n1, *side;\n\tstruct assoc_array_ptr *ptr;\n\tunsigned long dissimilarity, base_seg, blank;\n\tsize_t keylen;\n\tbool have_meta;\n\tint level, diff;\n\tint slot, next_slot, free_slot, i, j;\n\n\tnode\t= result->terminal_node.node;\n\tlevel\t= result->terminal_node.level;\n\tedit->segment_cache[ASSOC_ARRAY_FAN_OUT] = result->terminal_node.slot;\n\n\tpr_devel(\"-->%s()\\n\", __func__);\n\n\t/* We arrived at a node which doesn't have an onward node or shortcut\n\t * pointer that we have to follow.  This means that (a) the leaf we\n\t * want must go here (either by insertion or replacement) or (b) we\n\t * need to split this node and insert in one of the fragments.\n\t */\n\tfree_slot = -1;\n\n\t/* Firstly, we have to check the leaves in this node to see if there's\n\t * a matching one we should replace in place.\n\t */\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tptr = node->slots[i];\n\t\tif (!ptr) {\n\t\t\tfree_slot = i;\n\t\t\tcontinue;\n\t\t}\n\t\tif (assoc_array_ptr_is_leaf(ptr) &&\n\t\t    ops->compare_object(assoc_array_ptr_to_leaf(ptr),\n\t\t\t\t\tindex_key)) {\n\t\t\tpr_devel(\"replace in slot %d\\n\", i);\n\t\t\tedit->leaf_p = &node->slots[i];\n\t\t\tedit->dead_leaf = node->slots[i];\n\t\t\tpr_devel(\"<--%s() = ok [replace]\\n\", __func__);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/* If there is a free slot in this node then we can just insert the\n\t * leaf here.\n\t */\n\tif (free_slot >= 0) {\n\t\tpr_devel(\"insert in free slot %d\\n\", free_slot);\n\t\tedit->leaf_p = &node->slots[free_slot];\n\t\tedit->adjust_count_on = node;\n\t\tpr_devel(\"<--%s() = ok [insert]\\n\", __func__);\n\t\treturn true;\n\t}\n\n\t/* The node has no spare slots - so we're either going to have to split\n\t * it or insert another node before it.\n\t *\n\t * Whatever, we're going to need at least two new nodes - so allocate\n\t * those now.  We may also need a new shortcut, but we deal with that\n\t * when we need it.\n\t */\n\tnew_n0 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);\n\tif (!new_n0)\n\t\treturn false;\n\tedit->new_meta[0] = assoc_array_node_to_ptr(new_n0);\n\tnew_n1 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);\n\tif (!new_n1)\n\t\treturn false;\n\tedit->new_meta[1] = assoc_array_node_to_ptr(new_n1);\n\n\t/* We need to find out how similar the leaves are. */\n\tpr_devel(\"no spare slots\\n\");\n\thave_meta = false;\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tptr = node->slots[i];\n\t\tif (assoc_array_ptr_is_meta(ptr)) {\n\t\t\tedit->segment_cache[i] = 0xff;\n\t\t\thave_meta = true;\n\t\t\tcontinue;\n\t\t}\n\t\tbase_seg = ops->get_object_key_chunk(\n\t\t\tassoc_array_ptr_to_leaf(ptr), level);\n\t\tbase_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;\n\t\tedit->segment_cache[i] = base_seg & ASSOC_ARRAY_FAN_MASK;\n\t}\n\n\tif (have_meta) {\n\t\tpr_devel(\"have meta\\n\");\n\t\tgoto split_node;\n\t}\n\n\t/* The node contains only leaves */\n\tdissimilarity = 0;\n\tbase_seg = edit->segment_cache[0];\n\tfor (i = 1; i < ASSOC_ARRAY_FAN_OUT; i++)\n\t\tdissimilarity |= edit->segment_cache[i] ^ base_seg;\n\n\tpr_devel(\"only leaves; dissimilarity=%lx\\n\", dissimilarity);\n\n\tif ((dissimilarity & ASSOC_ARRAY_FAN_MASK) == 0) {\n\t\t/* The old leaves all cluster in the same slot.  We will need\n\t\t * to insert a shortcut if the new node wants to cluster with them.\n\t\t */\n\t\tif ((edit->segment_cache[ASSOC_ARRAY_FAN_OUT] ^ base_seg) == 0)\n\t\t\tgoto all_leaves_cluster_together;\n\n\t\t/* Otherwise we can just insert a new node ahead of the old\n\t\t * one.\n\t\t */\n\t\tgoto present_leaves_cluster_but_not_new_leaf;\n\t}\n\nsplit_node:\n\tpr_devel(\"split node\\n\");\n\n\t/* We need to split the current node; we know that the node doesn't\n\t * simply contain a full set of leaves that cluster together (it\n\t * contains meta pointers and/or non-clustering leaves).\n\t *\n\t * We need to expel at least two leaves out of a set consisting of the\n\t * leaves in the node and the new leaf.\n\t *\n\t * We need a new node (n0) to replace the current one and a new node to\n\t * take the expelled nodes (n1).\n\t */\n\tedit->set[0].to = assoc_array_node_to_ptr(new_n0);\n\tnew_n0->back_pointer = node->back_pointer;\n\tnew_n0->parent_slot = node->parent_slot;\n\tnew_n1->back_pointer = assoc_array_node_to_ptr(new_n0);\n\tnew_n1->parent_slot = -1; /* Need to calculate this */\n\ndo_split_node:\n\tpr_devel(\"do_split_node\\n\");\n\n\tnew_n0->nr_leaves_on_branch = node->nr_leaves_on_branch;\n\tnew_n1->nr_leaves_on_branch = 0;\n\n\t/* Begin by finding two matching leaves.  There have to be at least two\n\t * that match - even if there are meta pointers - because any leaf that\n\t * would match a slot with a meta pointer in it must be somewhere\n\t * behind that meta pointer and cannot be here.  Further, given N\n\t * remaining leaf slots, we now have N+1 leaves to go in them.\n\t */\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tslot = edit->segment_cache[i];\n\t\tif (slot != 0xff)\n\t\t\tfor (j = i + 1; j < ASSOC_ARRAY_FAN_OUT + 1; j++)\n\t\t\t\tif (edit->segment_cache[j] == slot)\n\t\t\t\t\tgoto found_slot_for_multiple_occupancy;\n\t}\nfound_slot_for_multiple_occupancy:\n\tpr_devel(\"same slot: %x %x [%02x]\\n\", i, j, slot);\n\tBUG_ON(i >= ASSOC_ARRAY_FAN_OUT);\n\tBUG_ON(j >= ASSOC_ARRAY_FAN_OUT + 1);\n\tBUG_ON(slot >= ASSOC_ARRAY_FAN_OUT);\n\n\tnew_n1->parent_slot = slot;\n\n\t/* Metadata pointers cannot change slot */\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++)\n\t\tif (assoc_array_ptr_is_meta(node->slots[i]))\n\t\t\tnew_n0->slots[i] = node->slots[i];\n\t\telse\n\t\t\tnew_n0->slots[i] = NULL;\n\tBUG_ON(new_n0->slots[slot] != NULL);\n\tnew_n0->slots[slot] = assoc_array_node_to_ptr(new_n1);\n\n\t/* Filter the leaf pointers between the new nodes */\n\tfree_slot = -1;\n\tnext_slot = 0;\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tif (assoc_array_ptr_is_meta(node->slots[i]))\n\t\t\tcontinue;\n\t\tif (edit->segment_cache[i] == slot) {\n\t\t\tnew_n1->slots[next_slot++] = node->slots[i];\n\t\t\tnew_n1->nr_leaves_on_branch++;\n\t\t} else {\n\t\t\tdo {\n\t\t\t\tfree_slot++;\n\t\t\t} while (new_n0->slots[free_slot] != NULL);\n\t\t\tnew_n0->slots[free_slot] = node->slots[i];\n\t\t}\n\t}\n\n\tpr_devel(\"filtered: f=%x n=%x\\n\", free_slot, next_slot);\n\n\tif (edit->segment_cache[ASSOC_ARRAY_FAN_OUT] != slot) {\n\t\tdo {\n\t\t\tfree_slot++;\n\t\t} while (new_n0->slots[free_slot] != NULL);\n\t\tedit->leaf_p = &new_n0->slots[free_slot];\n\t\tedit->adjust_count_on = new_n0;\n\t} else {\n\t\tedit->leaf_p = &new_n1->slots[next_slot++];\n\t\tedit->adjust_count_on = new_n1;\n\t}\n\n\tBUG_ON(next_slot <= 1);\n\n\tedit->set_backpointers_to = assoc_array_node_to_ptr(new_n0);\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tif (edit->segment_cache[i] == 0xff) {\n\t\t\tptr = node->slots[i];\n\t\t\tBUG_ON(assoc_array_ptr_is_leaf(ptr));\n\t\t\tif (assoc_array_ptr_is_node(ptr)) {\n\t\t\t\tside = assoc_array_ptr_to_node(ptr);\n\t\t\t\tedit->set_backpointers[i] = &side->back_pointer;\n\t\t\t} else {\n\t\t\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\t\t\tedit->set_backpointers[i] = &shortcut->back_pointer;\n\t\t\t}\n\t\t}\n\t}\n\n\tptr = node->back_pointer;\n\tif (!ptr)\n\t\tedit->set[0].ptr = &edit->array->root;\n\telse if (assoc_array_ptr_is_node(ptr))\n\t\tedit->set[0].ptr = &assoc_array_ptr_to_node(ptr)->slots[node->parent_slot];\n\telse\n\t\tedit->set[0].ptr = &assoc_array_ptr_to_shortcut(ptr)->next_node;\n\tedit->excised_meta[0] = assoc_array_node_to_ptr(node);\n\tpr_devel(\"<--%s() = ok [split node]\\n\", __func__);\n\treturn true;\n\npresent_leaves_cluster_but_not_new_leaf:\n\t/* All the old leaves cluster in the same slot, but the new leaf wants\n\t * to go into a different slot, so we create a new node to hold the new\n\t * leaf and a pointer to a new node holding all the old leaves.\n\t */\n\tpr_devel(\"present leaves cluster but not new leaf\\n\");\n\n\tnew_n0->back_pointer = node->back_pointer;\n\tnew_n0->parent_slot = node->parent_slot;\n\tnew_n0->nr_leaves_on_branch = node->nr_leaves_on_branch;\n\tnew_n1->back_pointer = assoc_array_node_to_ptr(new_n0);\n\tnew_n1->parent_slot = edit->segment_cache[0];\n\tnew_n1->nr_leaves_on_branch = node->nr_leaves_on_branch;\n\tedit->adjust_count_on = new_n0;\n\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++)\n\t\tnew_n1->slots[i] = node->slots[i];\n\n\tnew_n0->slots[edit->segment_cache[0]] = assoc_array_node_to_ptr(new_n0);\n\tedit->leaf_p = &new_n0->slots[edit->segment_cache[ASSOC_ARRAY_FAN_OUT]];\n\n\tedit->set[0].ptr = &assoc_array_ptr_to_node(node->back_pointer)->slots[node->parent_slot];\n\tedit->set[0].to = assoc_array_node_to_ptr(new_n0);\n\tedit->excised_meta[0] = assoc_array_node_to_ptr(node);\n\tpr_devel(\"<--%s() = ok [insert node before]\\n\", __func__);\n\treturn true;\n\nall_leaves_cluster_together:\n\t/* All the leaves, new and old, want to cluster together in this node\n\t * in the same slot, so we have to replace this node with a shortcut to\n\t * skip over the identical parts of the key and then place a pair of\n\t * nodes, one inside the other, at the end of the shortcut and\n\t * distribute the keys between them.\n\t *\n\t * Firstly we need to work out where the leaves start diverging as a\n\t * bit position into their keys so that we know how big the shortcut\n\t * needs to be.\n\t *\n\t * We only need to make a single pass of N of the N+1 leaves because if\n\t * any keys differ between themselves at bit X then at least one of\n\t * them must also differ with the base key at bit X or before.\n\t */\n\tpr_devel(\"all leaves cluster together\\n\");\n\tdiff = INT_MAX;\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tint x = ops->diff_objects(assoc_array_ptr_to_leaf(node->slots[i]),\n\t\t\t\t\t  index_key);\n\t\tif (x < diff) {\n\t\t\tBUG_ON(x < 0);\n\t\t\tdiff = x;\n\t\t}\n\t}\n\tBUG_ON(diff == INT_MAX);\n\tBUG_ON(diff < level + ASSOC_ARRAY_LEVEL_STEP);\n\n\tkeylen = round_up(diff, ASSOC_ARRAY_KEY_CHUNK_SIZE);\n\tkeylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT;\n\n\tnew_s0 = kzalloc(sizeof(struct assoc_array_shortcut) +\n\t\t\t keylen * sizeof(unsigned long), GFP_KERNEL);\n\tif (!new_s0)\n\t\treturn false;\n\tedit->new_meta[2] = assoc_array_shortcut_to_ptr(new_s0);\n\n\tedit->set[0].to = assoc_array_shortcut_to_ptr(new_s0);\n\tnew_s0->back_pointer = node->back_pointer;\n\tnew_s0->parent_slot = node->parent_slot;\n\tnew_s0->next_node = assoc_array_node_to_ptr(new_n0);\n\tnew_n0->back_pointer = assoc_array_shortcut_to_ptr(new_s0);\n\tnew_n0->parent_slot = 0;\n\tnew_n1->back_pointer = assoc_array_node_to_ptr(new_n0);\n\tnew_n1->parent_slot = -1; /* Need to calculate this */\n\n\tnew_s0->skip_to_level = level = diff & ~ASSOC_ARRAY_LEVEL_STEP_MASK;\n\tpr_devel(\"skip_to_level = %d [diff %d]\\n\", level, diff);\n\tBUG_ON(level <= 0);\n\n\tfor (i = 0; i < keylen; i++)\n\t\tnew_s0->index_key[i] =\n\t\t\tops->get_key_chunk(index_key, i * ASSOC_ARRAY_KEY_CHUNK_SIZE);\n\n\tblank = ULONG_MAX << (level & ASSOC_ARRAY_KEY_CHUNK_MASK);\n\tpr_devel(\"blank off [%zu] %d: %lx\\n\", keylen - 1, level, blank);\n\tnew_s0->index_key[keylen - 1] &= ~blank;\n\n\t/* This now reduces to a node splitting exercise for which we'll need\n\t * to regenerate the disparity table.\n\t */\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tptr = node->slots[i];\n\t\tbase_seg = ops->get_object_key_chunk(assoc_array_ptr_to_leaf(ptr),\n\t\t\t\t\t\t     level);\n\t\tbase_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;\n\t\tedit->segment_cache[i] = base_seg & ASSOC_ARRAY_FAN_MASK;\n\t}\n\n\tbase_seg = ops->get_key_chunk(index_key, level);\n\tbase_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;\n\tedit->segment_cache[ASSOC_ARRAY_FAN_OUT] = base_seg & ASSOC_ARRAY_FAN_MASK;\n\tgoto do_split_node;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 108,
    "critical_vars": [
      "evtchn_to_irq[row][col]"
    ],
    "function": "clear_evtchn_to_irq_row",
    "filename": "linux/CVE-2020-27675/CVE-2020-27675_CWE-476_073d0552ead5bfc7a3a9c01de590e924f11b5dd2_events_base.c.diff",
    "function_code": "static void clear_evtchn_to_irq_row(unsigned row)\n{\n\tunsigned col;\n\n\tfor (col = 0; col < EVTCHN_PER_ROW; col++)\n\t\tevtchn_to_irq[row][col] = -1;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 126,
    "critical_vars": [
      "evtchn_to_irq[row][col]"
    ],
    "function": "clear_evtchn_to_irq_row",
    "filename": "linux/CVE-2020-27675/CVE-2020-27675_CWE-476_073d0552ead5bfc7a3a9c01de590e924f11b5dd2_events_base.c.diff",
    "function_code": "static void clear_evtchn_to_irq_row(unsigned row)\n{\n\tunsigned col;\n\n\tfor (col = 0; col < EVTCHN_PER_ROW; col++)\n\t\tWRITE_ONCE(evtchn_to_irq[row][col], -1);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 145,
    "critical_vars": [
      "evtchn_to_irq[row][col]"
    ],
    "function": "set_evtchn_to_irq",
    "filename": "linux/CVE-2020-27675/CVE-2020-27675_CWE-476_073d0552ead5bfc7a3a9c01de590e924f11b5dd2_events_base.c.diff",
    "function_code": "static int set_evtchn_to_irq(evtchn_port_t evtchn, unsigned int irq)\n{\n\tunsigned row;\n\tunsigned col;\n\n\tif (evtchn >= xen_evtchn_max_channels())\n\t\treturn -EINVAL;\n\n\trow = EVTCHN_ROW(evtchn);\n\tcol = EVTCHN_COL(evtchn);\n\n\tif (evtchn_to_irq[row] == NULL) {\n\t\t/* Unallocated irq entries return -1 anyway */\n\t\tif (irq == -1)\n\t\t\treturn 0;\n\n\t\tevtchn_to_irq[row] = (int *)get_zeroed_page(GFP_KERNEL);\n\t\tif (evtchn_to_irq[row] == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tclear_evtchn_to_irq_row(row);\n\t}\n\n\tevtchn_to_irq[row][col] = irq;\n\treturn 0;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 163,
    "critical_vars": [
      "evtchn_to_irq[row][col]",
      "irq"
    ],
    "function": "set_evtchn_to_irq",
    "filename": "linux/CVE-2020-27675/CVE-2020-27675_CWE-476_073d0552ead5bfc7a3a9c01de590e924f11b5dd2_events_base.c.diff",
    "function_code": "static int set_evtchn_to_irq(evtchn_port_t evtchn, unsigned int irq)\n{\n\tunsigned row;\n\tunsigned col;\n\n\tif (evtchn >= xen_evtchn_max_channels())\n\t\treturn -EINVAL;\n\n\trow = EVTCHN_ROW(evtchn);\n\tcol = EVTCHN_COL(evtchn);\n\n\tif (evtchn_to_irq[row] == NULL) {\n\t\t/* Unallocated irq entries return -1 anyway */\n\t\tif (irq == -1)\n\t\t\treturn 0;\n\n\t\tevtchn_to_irq[row] = (int *)get_zeroed_page(GFP_KERNEL);\n\t\tif (evtchn_to_irq[row] == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tclear_evtchn_to_irq_row(row);\n\t}\n\n\tWRITE_ONCE(evtchn_to_irq[row][col], irq);\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 1100,
    "critical_vars": [
      "asoc->peer.auth_capable"
    ],
    "function": "sctp_assoc_update",
    "filename": "linux/CVE-2014-5077/CVE-2014-5077_CWE-476_1be9a950c646c9092fb3618197f7b6bfb50e82aa_associola.c.diff",
    "function_code": "void sctp_assoc_update(struct sctp_association *asoc,\n\t\t       struct sctp_association *new)\n{\n\tstruct sctp_transport *trans;\n\tstruct list_head *pos, *temp;\n\n\t/* Copy in new parameters of peer. */\n\tasoc->c = new->c;\n\tasoc->peer.rwnd = new->peer.rwnd;\n\tasoc->peer.sack_needed = new->peer.sack_needed;\n\tasoc->peer.auth_capable = new->peer.auth_capable;\n\tasoc->peer.i = new->peer.i;\n\tsctp_tsnmap_init(&asoc->peer.tsn_map, SCTP_TSN_MAP_INITIAL,\n\t\t\t asoc->peer.i.initial_tsn, GFP_ATOMIC);\n\n\t/* Remove any peer addresses not present in the new association. */\n\tlist_for_each_safe(pos, temp, &asoc->peer.transport_addr_list) {\n\t\ttrans = list_entry(pos, struct sctp_transport, transports);\n\t\tif (!sctp_assoc_lookup_paddr(new, &trans->ipaddr)) {\n\t\t\tsctp_assoc_rm_peer(asoc, trans);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (asoc->state >= SCTP_STATE_ESTABLISHED)\n\t\t\tsctp_transport_reset(trans);\n\t}\n\n\t/* If the case is A (association restart), use\n\t * initial_tsn as next_tsn. If the case is B, use\n\t * current next_tsn in case data sent to peer\n\t * has been discarded and needs retransmission.\n\t */\n\tif (asoc->state >= SCTP_STATE_ESTABLISHED) {\n\t\tasoc->next_tsn = new->next_tsn;\n\t\tasoc->ctsn_ack_point = new->ctsn_ack_point;\n\t\tasoc->adv_peer_ack_point = new->adv_peer_ack_point;\n\n\t\t/* Reinitialize SSN for both local streams\n\t\t * and peer's streams.\n\t\t */\n\t\tsctp_ssnmap_clear(asoc->ssnmap);\n\n\t\t/* Flush the ULP reassembly and ordered queue.\n\t\t * Any data there will now be stale and will\n\t\t * cause problems.\n\t\t */\n\t\tsctp_ulpq_flush(&asoc->ulpq);\n\n\t\t/* reset the overall association error count so\n\t\t * that the restarted association doesn't get torn\n\t\t * down on the next retransmission timer.\n\t\t */\n\t\tasoc->overall_error_count = 0;\n\n\t} else {\n\t\t/* Add any peer addresses from the new association. */\n\t\tlist_for_each_entry(trans, &new->peer.transport_addr_list,\n\t\t\t\ttransports) {\n\t\t\tif (!sctp_assoc_lookup_paddr(asoc, &trans->ipaddr))\n\t\t\t\tsctp_assoc_add_peer(asoc, &trans->ipaddr,\n\t\t\t\t\t\t    GFP_ATOMIC, trans->state);\n\t\t}\n\n\t\tasoc->ctsn_ack_point = asoc->next_tsn - 1;\n\t\tasoc->adv_peer_ack_point = asoc->ctsn_ack_point;\n\t\tif (!asoc->ssnmap) {\n\t\t\t/* Move the ssnmap. */\n\t\t\tasoc->ssnmap = new->ssnmap;\n\t\t\tnew->ssnmap = NULL;\n\t\t}\n\n\t\tif (!asoc->assoc_id) {\n\t\t\t/* get a new association id since we don't have one\n\t\t\t * yet.\n\t\t\t */\n\t\t\tsctp_assoc_set_id(asoc, GFP_ATOMIC);\n\t\t}\n\t}\n\n\t/* SCTP-AUTH: Save the peer parameters from the new associations\n\t * and also move the association shared keys over\n\t */\n\tkfree(asoc->peer.peer_random);\n\tasoc->peer.peer_random = new->peer.peer_random;\n\tnew->peer.peer_random = NULL;\n\n\tkfree(asoc->peer.peer_chunks);\n\tasoc->peer.peer_chunks = new->peer.peer_chunks;\n\tnew->peer.peer_chunks = NULL;\n\n\tkfree(asoc->peer.peer_hmacs);\n\tasoc->peer.peer_hmacs = new->peer.peer_hmacs;\n\tnew->peer.peer_hmacs = NULL;\n\n\tsctp_auth_key_put(asoc->asoc_shared_key);\n\tsctp_auth_asoc_init_active_key(asoc, GFP_ATOMIC);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 208,
    "critical_vars": [
      "out"
    ],
    "function": "get_endpoints",
    "filename": "linux/CVE-2017-16532/CVE-2017-16532_CWE-476_7c80f9e4a588f1925b07134bb2e3689335f6c6d8_usbtest.c.diff",
    "function_code": "get_endpoints(struct usbtest_dev *dev, struct usb_interface *intf)\n{\n\tint\t\t\t\ttmp;\n\tstruct usb_host_interface\t*alt;\n\tstruct usb_host_endpoint\t*in, *out;\n\tstruct usb_host_endpoint\t*iso_in, *iso_out;\n\tstruct usb_host_endpoint\t*int_in, *int_out;\n\tstruct usb_device\t\t*udev;\n\n\tfor (tmp = 0; tmp < intf->num_altsetting; tmp++) {\n\t\tunsigned\tep;\n\n\t\tin = out = NULL;\n\t\tiso_in = iso_out = NULL;\n\t\tint_in = int_out = NULL;\n\t\talt = intf->altsetting + tmp;\n\n\t\tif (override_alt >= 0 &&\n\t\t\t\toverride_alt != alt->desc.bAlternateSetting)\n\t\t\tcontinue;\n\n\t\t/* take the first altsetting with in-bulk + out-bulk;\n\t\t * ignore other endpoints and altsettings.\n\t\t */\n\t\tfor (ep = 0; ep < alt->desc.bNumEndpoints; ep++) {\n\t\t\tstruct usb_host_endpoint\t*e;\n\t\t\tint edi;\n\n\t\t\te = alt->endpoint + ep;\n\t\t\tedi = usb_endpoint_dir_in(&e->desc);\n\n\t\t\tswitch (usb_endpoint_type(&e->desc)) {\n\t\t\tcase USB_ENDPOINT_XFER_BULK:\n\t\t\t\tendpoint_update(edi, &in, &out, e);\n\t\t\t\tcontinue;\n\t\t\tcase USB_ENDPOINT_XFER_INT:\n\t\t\t\tif (dev->info->intr)\n\t\t\t\t\tendpoint_update(edi, &int_in, &int_out, e);\n\t\t\t\tcontinue;\n\t\t\tcase USB_ENDPOINT_XFER_ISOC:\n\t\t\t\tif (dev->info->iso)\n\t\t\t\t\tendpoint_update(edi, &iso_in, &iso_out, e);\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tdefault:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif ((in && out)  ||  iso_in || iso_out || int_in || int_out)\n\t\t\tgoto found;\n\t}\n\treturn -EINVAL;\n\nfound:\n\tudev = testdev_to_usbdev(dev);\n\tdev->info->alt = alt->desc.bAlternateSetting;\n\tif (alt->desc.bAlternateSetting != 0) {\n\t\ttmp = usb_set_interface(udev,\n\t\t\t\talt->desc.bInterfaceNumber,\n\t\t\t\talt->desc.bAlternateSetting);\n\t\tif (tmp < 0)\n\t\t\treturn tmp;\n\t}\n\n\tif (in)\n\t\tdev->in_pipe = usb_rcvbulkpipe(udev,\n\t\t\tin->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);\n\tif (out)\n\t\tdev->out_pipe = usb_sndbulkpipe(udev,\n\t\t\tout->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);\n\n\tif (iso_in) {\n\t\tdev->iso_in = &iso_in->desc;\n\t\tdev->in_iso_pipe = usb_rcvisocpipe(udev,\n\t\t\t\tiso_in->desc.bEndpointAddress\n\t\t\t\t\t& USB_ENDPOINT_NUMBER_MASK);\n\t}\n\n\tif (iso_out) {\n\t\tdev->iso_out = &iso_out->desc;\n\t\tdev->out_iso_pipe = usb_sndisocpipe(udev,\n\t\t\t\tiso_out->desc.bEndpointAddress\n\t\t\t\t\t& USB_ENDPOINT_NUMBER_MASK);\n\t}\n\n\tif (int_in) {\n\t\tdev->int_in = &int_in->desc;\n\t\tdev->in_int_pipe = usb_rcvintpipe(udev,\n\t\t\t\tint_in->desc.bEndpointAddress\n\t\t\t\t\t& USB_ENDPOINT_NUMBER_MASK);\n\t}\n\n\tif (int_out) {\n\t\tdev->int_out = &int_out->desc;\n\t\tdev->out_int_pipe = usb_sndintpipe(udev,\n\t\t\t\tint_out->desc.bEndpointAddress\n\t\t\t\t\t& USB_ENDPOINT_NUMBER_MASK);\n\t}\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 58,
    "critical_vars": [
      "indev"
    ],
    "function": "nf_nat_redirect_ipv4",
    "filename": "linux/CVE-2015-8787/CVE-2015-8787_CWE-476_94f9cd81436c85d8c3a318ba92e236ede73752fc_nf_nat_redirect.c.diff",
    "function_code": "nf_nat_redirect_ipv4(struct sk_buff *skb,\n\t\t     const struct nf_nat_ipv4_multi_range_compat *mr,\n\t\t     unsigned int hooknum)\n{\n\tstruct nf_conn *ct;\n\tenum ip_conntrack_info ctinfo;\n\t__be32 newdst;\n\tstruct nf_nat_range newrange;\n\n\tNF_CT_ASSERT(hooknum == NF_INET_PRE_ROUTING ||\n\t\t     hooknum == NF_INET_LOCAL_OUT);\n\n\tct = nf_ct_get(skb, &ctinfo);\n\tNF_CT_ASSERT(ct && (ctinfo == IP_CT_NEW || ctinfo == IP_CT_RELATED));\n\n\t/* Local packets: make them go to loopback */\n\tif (hooknum == NF_INET_LOCAL_OUT) {\n\t\tnewdst = htonl(0x7F000001);\n\t} else {\n\t\tstruct in_device *indev;\n\t\tstruct in_ifaddr *ifa;\n\n\t\tnewdst = 0;\n\n\t\trcu_read_lock();\n\t\tindev = __in_dev_get_rcu(skb->dev);\n\t\tif (indev != NULL) {\n\t\t\tifa = indev->ifa_list;\n\t\t\tnewdst = ifa->ifa_local;\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tif (!newdst)\n\t\t\treturn NF_DROP;\n\t}\n\n\t/* Transfer from original range. */\n\tmemset(&newrange.min_addr, 0, sizeof(newrange.min_addr));\n\tmemset(&newrange.max_addr, 0, sizeof(newrange.max_addr));\n\tnewrange.flags\t     = mr->range[0].flags | NF_NAT_RANGE_MAP_IPS;\n\tnewrange.min_addr.ip = newdst;\n\tnewrange.max_addr.ip = newdst;\n\tnewrange.min_proto   = mr->range[0].min;\n\tnewrange.max_proto   = mr->range[0].max;\n\n\t/* Hand modified range to generic setup. */\n\treturn nf_nat_setup_info(ct, &newrange, NF_NAT_MANIP_DST);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 58,
    "critical_vars": [
      "indev",
      "indev->ifa_list"
    ],
    "function": "nf_nat_redirect_ipv4",
    "filename": "linux/CVE-2015-8787/CVE-2015-8787_CWE-476_94f9cd81436c85d8c3a318ba92e236ede73752fc_nf_nat_redirect.c.diff",
    "function_code": "nf_nat_redirect_ipv4(struct sk_buff *skb,\n\t\t     const struct nf_nat_ipv4_multi_range_compat *mr,\n\t\t     unsigned int hooknum)\n{\n\tstruct nf_conn *ct;\n\tenum ip_conntrack_info ctinfo;\n\t__be32 newdst;\n\tstruct nf_nat_range newrange;\n\n\tNF_CT_ASSERT(hooknum == NF_INET_PRE_ROUTING ||\n\t\t     hooknum == NF_INET_LOCAL_OUT);\n\n\tct = nf_ct_get(skb, &ctinfo);\n\tNF_CT_ASSERT(ct && (ctinfo == IP_CT_NEW || ctinfo == IP_CT_RELATED));\n\n\t/* Local packets: make them go to loopback */\n\tif (hooknum == NF_INET_LOCAL_OUT) {\n\t\tnewdst = htonl(0x7F000001);\n\t} else {\n\t\tstruct in_device *indev;\n\t\tstruct in_ifaddr *ifa;\n\n\t\tnewdst = 0;\n\n\t\trcu_read_lock();\n\t\tindev = __in_dev_get_rcu(skb->dev);\n\t\tif (indev && indev->ifa_list) {\n\t\t\tifa = indev->ifa_list;\n\t\t\tnewdst = ifa->ifa_local;\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tif (!newdst)\n\t\t\treturn NF_DROP;\n\t}\n\n\t/* Transfer from original range. */\n\tmemset(&newrange.min_addr, 0, sizeof(newrange.min_addr));\n\tmemset(&newrange.max_addr, 0, sizeof(newrange.max_addr));\n\tnewrange.flags\t     = mr->range[0].flags | NF_NAT_RANGE_MAP_IPS;\n\tnewrange.min_addr.ip = newdst;\n\tnewrange.max_addr.ip = newdst;\n\tnewrange.min_proto   = mr->range[0].min;\n\tnewrange.max_proto   = mr->range[0].max;\n\n\t/* Hand modified range to generic setup. */\n\treturn nf_nat_setup_info(ct, &newrange, NF_NAT_MANIP_DST);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 66,
    "critical_vars": [
      "sq_pid"
    ],
    "function": "io_uring_show_fdinfo",
    "filename": "linux/CVE-2023-46862/CVE-2023-46862_CWE-476_7644b1a1c9a7ae8ab99175989bfc8676055edb46_fdinfo.c.diff",
    "function_code": "__cold void io_uring_show_fdinfo(struct seq_file *m, struct file *f)\n{\n\tstruct io_ring_ctx *ctx = f->private_data;\n\tstruct io_overflow_cqe *ocqe;\n\tstruct io_rings *r = ctx->rings;\n\tunsigned int sq_mask = ctx->sq_entries - 1, cq_mask = ctx->cq_entries - 1;\n\tunsigned int sq_head = READ_ONCE(r->sq.head);\n\tunsigned int sq_tail = READ_ONCE(r->sq.tail);\n\tunsigned int cq_head = READ_ONCE(r->cq.head);\n\tunsigned int cq_tail = READ_ONCE(r->cq.tail);\n\tunsigned int cq_shift = 0;\n\tunsigned int sq_shift = 0;\n\tunsigned int sq_entries, cq_entries;\n\tint sq_pid = -1, sq_cpu = -1;\n\tbool has_lock;\n\tunsigned int i;\n\n\tif (ctx->flags & IORING_SETUP_CQE32)\n\t\tcq_shift = 1;\n\tif (ctx->flags & IORING_SETUP_SQE128)\n\t\tsq_shift = 1;\n\n\t/*\n\t * we may get imprecise sqe and cqe info if uring is actively running\n\t * since we get cached_sq_head and cached_cq_tail without uring_lock\n\t * and sq_tail and cq_head are changed by userspace. But it's ok since\n\t * we usually use these info when it is stuck.\n\t */\n\tseq_printf(m, \"SqMask:\\t0x%x\\n\", sq_mask);\n\tseq_printf(m, \"SqHead:\\t%u\\n\", sq_head);\n\tseq_printf(m, \"SqTail:\\t%u\\n\", sq_tail);\n\tseq_printf(m, \"CachedSqHead:\\t%u\\n\", ctx->cached_sq_head);\n\tseq_printf(m, \"CqMask:\\t0x%x\\n\", cq_mask);\n\tseq_printf(m, \"CqHead:\\t%u\\n\", cq_head);\n\tseq_printf(m, \"CqTail:\\t%u\\n\", cq_tail);\n\tseq_printf(m, \"CachedCqTail:\\t%u\\n\", ctx->cached_cq_tail);\n\tseq_printf(m, \"SQEs:\\t%u\\n\", sq_tail - sq_head);\n\tsq_entries = min(sq_tail - sq_head, ctx->sq_entries);\n\tfor (i = 0; i < sq_entries; i++) {\n\t\tunsigned int entry = i + sq_head;\n\t\tstruct io_uring_sqe *sqe;\n\t\tunsigned int sq_idx;\n\n\t\tif (ctx->flags & IORING_SETUP_NO_SQARRAY)\n\t\t\tbreak;\n\t\tsq_idx = READ_ONCE(ctx->sq_array[entry & sq_mask]);\n\t\tif (sq_idx > sq_mask)\n\t\t\tcontinue;\n\t\tsqe = &ctx->sq_sqes[sq_idx << sq_shift];\n\t\tseq_printf(m, \"%5u: opcode:%s, fd:%d, flags:%x, off:%llu, \"\n\t\t\t      \"addr:0x%llx, rw_flags:0x%x, buf_index:%d \"\n\t\t\t      \"user_data:%llu\",\n\t\t\t   sq_idx, io_uring_get_opcode(sqe->opcode), sqe->fd,\n\t\t\t   sqe->flags, (unsigned long long) sqe->off,\n\t\t\t   (unsigned long long) sqe->addr, sqe->rw_flags,\n\t\t\t   sqe->buf_index, sqe->user_data);\n\t\tif (sq_shift) {\n\t\t\tu64 *sqeb = (void *) (sqe + 1);\n\t\t\tint size = sizeof(struct io_uring_sqe) / sizeof(u64);\n\t\t\tint j;\n\n\t\t\tfor (j = 0; j < size; j++) {\n\t\t\t\tseq_printf(m, \", e%d:0x%llx\", j,\n\t\t\t\t\t\t(unsigned long long) *sqeb);\n\t\t\t\tsqeb++;\n\t\t\t}\n\t\t}\n\t\tseq_printf(m, \"\\n\");\n\t}\n\tseq_printf(m, \"CQEs:\\t%u\\n\", cq_tail - cq_head);\n\tcq_entries = min(cq_tail - cq_head, ctx->cq_entries);\n\tfor (i = 0; i < cq_entries; i++) {\n\t\tunsigned int entry = i + cq_head;\n\t\tstruct io_uring_cqe *cqe = &r->cqes[(entry & cq_mask) << cq_shift];\n\n\t\tseq_printf(m, \"%5u: user_data:%llu, res:%d, flag:%x\",\n\t\t\t   entry & cq_mask, cqe->user_data, cqe->res,\n\t\t\t   cqe->flags);\n\t\tif (cq_shift)\n\t\t\tseq_printf(m, \", extra1:%llu, extra2:%llu\\n\",\n\t\t\t\t\tcqe->big_cqe[0], cqe->big_cqe[1]);\n\t\tseq_printf(m, \"\\n\");\n\t}\n\n\t/*\n\t * Avoid ABBA deadlock between the seq lock and the io_uring mutex,\n\t * since fdinfo case grabs it in the opposite direction of normal use\n\t * cases. If we fail to get the lock, we just don't iterate any\n\t * structures that could be going away outside the io_uring mutex.\n\t */\n\thas_lock = mutex_trylock(&ctx->uring_lock);\n\n\tif (has_lock && (ctx->flags & IORING_SETUP_SQPOLL)) {\n\t\tstruct io_sq_data *sq = ctx->sq_data;\n\n\t\tif (mutex_trylock(&sq->lock)) {\n\t\t\tif (sq->thread) {\n\t\t\t\tsq_pid = task_pid_nr(sq->thread);\n\t\t\t\tsq_cpu = task_cpu(sq->thread);\n\t\t\t}\n\t\t\tmutex_unlock(&sq->lock);\n\t\t}\n\t}\n\n\tseq_printf(m, \"SqThread:\\t%d\\n\", sq_pid);\n\tseq_printf(m, \"SqThreadCpu:\\t%d\\n\", sq_cpu);\n\tseq_printf(m, \"UserFiles:\\t%u\\n\", ctx->nr_user_files);\n\tfor (i = 0; has_lock && i < ctx->nr_user_files; i++) {\n\t\tstruct file *f = io_file_from_index(&ctx->file_table, i);\n\n\t\tif (f)\n\t\t\tseq_printf(m, \"%5u: %s\\n\", i, file_dentry(f)->d_iname);\n\t\telse\n\t\t\tseq_printf(m, \"%5u: <none>\\n\", i);\n\t}\n\tseq_printf(m, \"UserBufs:\\t%u\\n\", ctx->nr_user_bufs);\n\tfor (i = 0; has_lock && i < ctx->nr_user_bufs; i++) {\n\t\tstruct io_mapped_ubuf *buf = ctx->user_bufs[i];\n\t\tunsigned int len = buf->ubuf_end - buf->ubuf;\n\n\t\tseq_printf(m, \"%5u: 0x%llx/%u\\n\", i, buf->ubuf, len);\n\t}\n\tif (has_lock && !xa_empty(&ctx->personalities)) {\n\t\tunsigned long index;\n\t\tconst struct cred *cred;\n\n\t\tseq_printf(m, \"Personalities:\\n\");\n\t\txa_for_each(&ctx->personalities, index, cred)\n\t\t\tio_uring_show_cred(m, index, cred);\n\t}\n\n\tseq_puts(m, \"PollList:\\n\");\n\tfor (i = 0; i < (1U << ctx->cancel_table.hash_bits); i++) {\n\t\tstruct io_hash_bucket *hb = &ctx->cancel_table.hbs[i];\n\t\tstruct io_hash_bucket *hbl = &ctx->cancel_table_locked.hbs[i];\n\t\tstruct io_kiocb *req;\n\n\t\tspin_lock(&hb->lock);\n\t\thlist_for_each_entry(req, &hb->list, hash_node)\n\t\t\tseq_printf(m, \"  op=%d, task_works=%d\\n\", req->opcode,\n\t\t\t\t\ttask_work_pending(req->task));\n\t\tspin_unlock(&hb->lock);\n\n\t\tif (!has_lock)\n\t\t\tcontinue;\n\t\thlist_for_each_entry(req, &hbl->list, hash_node)\n\t\t\tseq_printf(m, \"  op=%d, task_works=%d\\n\", req->opcode,\n\t\t\t\t\ttask_work_pending(req->task));\n\t}\n\n\tif (has_lock)\n\t\tmutex_unlock(&ctx->uring_lock);\n\n\tseq_puts(m, \"CqOverflowList:\\n\");\n\tspin_lock(&ctx->completion_lock);\n\tlist_for_each_entry(ocqe, &ctx->cq_overflow_list, list) {\n\t\tstruct io_uring_cqe *cqe = &ocqe->cqe;\n\n\t\tseq_printf(m, \"  user_data=%llu, res=%d, flags=%x\\n\",\n\t\t\t   cqe->user_data, cqe->res, cqe->flags);\n\n\t}\n\n\tspin_unlock(&ctx->completion_lock);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 146,
    "critical_vars": [
      "sq"
    ],
    "function": "io_uring_show_fdinfo",
    "filename": "linux/CVE-2023-46862/CVE-2023-46862_CWE-476_7644b1a1c9a7ae8ab99175989bfc8676055edb46_fdinfo.c.diff",
    "function_code": "__cold void io_uring_show_fdinfo(struct seq_file *m, struct file *f)\n{\n\tstruct io_ring_ctx *ctx = f->private_data;\n\tstruct io_sq_data *sq = NULL;\n\tstruct io_overflow_cqe *ocqe;\n\tstruct io_rings *r = ctx->rings;\n\tunsigned int sq_mask = ctx->sq_entries - 1, cq_mask = ctx->cq_entries - 1;\n\tunsigned int sq_head = READ_ONCE(r->sq.head);\n\tunsigned int sq_tail = READ_ONCE(r->sq.tail);\n\tunsigned int cq_head = READ_ONCE(r->cq.head);\n\tunsigned int cq_tail = READ_ONCE(r->cq.tail);\n\tunsigned int cq_shift = 0;\n\tunsigned int sq_shift = 0;\n\tunsigned int sq_entries, cq_entries;\n\tbool has_lock;\n\tunsigned int i;\n\n\tif (ctx->flags & IORING_SETUP_CQE32)\n\t\tcq_shift = 1;\n\tif (ctx->flags & IORING_SETUP_SQE128)\n\t\tsq_shift = 1;\n\n\t/*\n\t * we may get imprecise sqe and cqe info if uring is actively running\n\t * since we get cached_sq_head and cached_cq_tail without uring_lock\n\t * and sq_tail and cq_head are changed by userspace. But it's ok since\n\t * we usually use these info when it is stuck.\n\t */\n\tseq_printf(m, \"SqMask:\\t0x%x\\n\", sq_mask);\n\tseq_printf(m, \"SqHead:\\t%u\\n\", sq_head);\n\tseq_printf(m, \"SqTail:\\t%u\\n\", sq_tail);\n\tseq_printf(m, \"CachedSqHead:\\t%u\\n\", ctx->cached_sq_head);\n\tseq_printf(m, \"CqMask:\\t0x%x\\n\", cq_mask);\n\tseq_printf(m, \"CqHead:\\t%u\\n\", cq_head);\n\tseq_printf(m, \"CqTail:\\t%u\\n\", cq_tail);\n\tseq_printf(m, \"CachedCqTail:\\t%u\\n\", ctx->cached_cq_tail);\n\tseq_printf(m, \"SQEs:\\t%u\\n\", sq_tail - sq_head);\n\tsq_entries = min(sq_tail - sq_head, ctx->sq_entries);\n\tfor (i = 0; i < sq_entries; i++) {\n\t\tunsigned int entry = i + sq_head;\n\t\tstruct io_uring_sqe *sqe;\n\t\tunsigned int sq_idx;\n\n\t\tif (ctx->flags & IORING_SETUP_NO_SQARRAY)\n\t\t\tbreak;\n\t\tsq_idx = READ_ONCE(ctx->sq_array[entry & sq_mask]);\n\t\tif (sq_idx > sq_mask)\n\t\t\tcontinue;\n\t\tsqe = &ctx->sq_sqes[sq_idx << sq_shift];\n\t\tseq_printf(m, \"%5u: opcode:%s, fd:%d, flags:%x, off:%llu, \"\n\t\t\t      \"addr:0x%llx, rw_flags:0x%x, buf_index:%d \"\n\t\t\t      \"user_data:%llu\",\n\t\t\t   sq_idx, io_uring_get_opcode(sqe->opcode), sqe->fd,\n\t\t\t   sqe->flags, (unsigned long long) sqe->off,\n\t\t\t   (unsigned long long) sqe->addr, sqe->rw_flags,\n\t\t\t   sqe->buf_index, sqe->user_data);\n\t\tif (sq_shift) {\n\t\t\tu64 *sqeb = (void *) (sqe + 1);\n\t\t\tint size = sizeof(struct io_uring_sqe) / sizeof(u64);\n\t\t\tint j;\n\n\t\t\tfor (j = 0; j < size; j++) {\n\t\t\t\tseq_printf(m, \", e%d:0x%llx\", j,\n\t\t\t\t\t\t(unsigned long long) *sqeb);\n\t\t\t\tsqeb++;\n\t\t\t}\n\t\t}\n\t\tseq_printf(m, \"\\n\");\n\t}\n\tseq_printf(m, \"CQEs:\\t%u\\n\", cq_tail - cq_head);\n\tcq_entries = min(cq_tail - cq_head, ctx->cq_entries);\n\tfor (i = 0; i < cq_entries; i++) {\n\t\tunsigned int entry = i + cq_head;\n\t\tstruct io_uring_cqe *cqe = &r->cqes[(entry & cq_mask) << cq_shift];\n\n\t\tseq_printf(m, \"%5u: user_data:%llu, res:%d, flag:%x\",\n\t\t\t   entry & cq_mask, cqe->user_data, cqe->res,\n\t\t\t   cqe->flags);\n\t\tif (cq_shift)\n\t\t\tseq_printf(m, \", extra1:%llu, extra2:%llu\\n\",\n\t\t\t\t\tcqe->big_cqe[0], cqe->big_cqe[1]);\n\t\tseq_printf(m, \"\\n\");\n\t}\n\n\t/*\n\t * Avoid ABBA deadlock between the seq lock and the io_uring mutex,\n\t * since fdinfo case grabs it in the opposite direction of normal use\n\t * cases. If we fail to get the lock, we just don't iterate any\n\t * structures that could be going away outside the io_uring mutex.\n\t */\n\thas_lock = mutex_trylock(&ctx->uring_lock);\n\n\tif (has_lock && (ctx->flags & IORING_SETUP_SQPOLL)) {\n\t\tsq = ctx->sq_data;\n\t\tif (!sq->thread)\n\t\t\tsq = NULL;\n\t}\n\n\tseq_printf(m, \"SqThread:\\t%d\\n\", sq ? task_pid_nr(sq->thread) : -1);\n\tseq_printf(m, \"SqThreadCpu:\\t%d\\n\", sq ? task_cpu(sq->thread) : -1);\n\tseq_printf(m, \"UserFiles:\\t%u\\n\", ctx->nr_user_files);\n\tfor (i = 0; has_lock && i < ctx->nr_user_files; i++) {\n\t\tstruct file *f = io_file_from_index(&ctx->file_table, i);\n\n\t\tif (f)\n\t\t\tseq_printf(m, \"%5u: %s\\n\", i, file_dentry(f)->d_iname);\n\t\telse\n\t\t\tseq_printf(m, \"%5u: <none>\\n\", i);\n\t}\n\tseq_printf(m, \"UserBufs:\\t%u\\n\", ctx->nr_user_bufs);\n\tfor (i = 0; has_lock && i < ctx->nr_user_bufs; i++) {\n\t\tstruct io_mapped_ubuf *buf = ctx->user_bufs[i];\n\t\tunsigned int len = buf->ubuf_end - buf->ubuf;\n\n\t\tseq_printf(m, \"%5u: 0x%llx/%u\\n\", i, buf->ubuf, len);\n\t}\n\tif (has_lock && !xa_empty(&ctx->personalities)) {\n\t\tunsigned long index;\n\t\tconst struct cred *cred;\n\n\t\tseq_printf(m, \"Personalities:\\n\");\n\t\txa_for_each(&ctx->personalities, index, cred)\n\t\t\tio_uring_show_cred(m, index, cred);\n\t}\n\n\tseq_puts(m, \"PollList:\\n\");\n\tfor (i = 0; i < (1U << ctx->cancel_table.hash_bits); i++) {\n\t\tstruct io_hash_bucket *hb = &ctx->cancel_table.hbs[i];\n\t\tstruct io_hash_bucket *hbl = &ctx->cancel_table_locked.hbs[i];\n\t\tstruct io_kiocb *req;\n\n\t\tspin_lock(&hb->lock);\n\t\thlist_for_each_entry(req, &hb->list, hash_node)\n\t\t\tseq_printf(m, \"  op=%d, task_works=%d\\n\", req->opcode,\n\t\t\t\t\ttask_work_pending(req->task));\n\t\tspin_unlock(&hb->lock);\n\n\t\tif (!has_lock)\n\t\t\tcontinue;\n\t\thlist_for_each_entry(req, &hbl->list, hash_node)\n\t\t\tseq_printf(m, \"  op=%d, task_works=%d\\n\", req->opcode,\n\t\t\t\t\ttask_work_pending(req->task));\n\t}\n\n\tif (has_lock)\n\t\tmutex_unlock(&ctx->uring_lock);\n\n\tseq_puts(m, \"CqOverflowList:\\n\");\n\tspin_lock(&ctx->completion_lock);\n\tlist_for_each_entry(ocqe, &ctx->cq_overflow_list, list) {\n\t\tstruct io_uring_cqe *cqe = &ocqe->cqe;\n\n\t\tseq_printf(m, \"  user_data=%llu, res=%d, flags=%x\\n\",\n\t\t\t   cqe->user_data, cqe->res, cqe->flags);\n\n\t}\n\n\tspin_unlock(&ctx->completion_lock);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 341,
    "critical_vars": [
      "cm_id->device"
    ],
    "function": "rds_ib_laddr_check",
    "filename": "linux/CVE-2013-7339/CVE-2013-7339_CWE-476_c2349758acf1874e4c2b93fe41d072336f1a31d0_ib.c.diff",
    "function_code": "static int rds_ib_laddr_check(__be32 addr)\n{\n\tint ret;\n\tstruct rdma_cm_id *cm_id;\n\tstruct sockaddr_in sin;\n\n\t/* Create a CMA ID and try to bind it. This catches both\n\t * IB and iWARP capable NICs.\n\t */\n\tcm_id = rdma_create_id(NULL, NULL, RDMA_PS_TCP, IB_QPT_RC);\n\tif (IS_ERR(cm_id))\n\t\treturn PTR_ERR(cm_id);\n\n\tmemset(&sin, 0, sizeof(sin));\n\tsin.sin_family = AF_INET;\n\tsin.sin_addr.s_addr = addr;\n\n\t/* rdma_bind_addr will only succeed for IB & iWARP devices */\n\tret = rdma_bind_addr(cm_id, (struct sockaddr *)&sin);\n\t/* due to this, we will claim to support iWARP devices unless we\n\t   check node_type. */\n\tif (ret || !cm_id->device ||\n\t    cm_id->device->node_type != RDMA_NODE_IB_CA)\n\t\tret = -EADDRNOTAVAIL;\n\n\trdsdebug(\"addr %pI4 ret %d node type %d\\n\",\n\t\t&addr, ret,\n\t\tcm_id->device ? cm_id->device->node_type : -1);\n\n\trdma_destroy_id(cm_id);\n\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 2062,
    "line_new": 2062,
    "critical_vars": [
      "qcadev->bt_en"
    ],
    "function": "qca_serdev_probe",
    "filename": "linux/CVE-2023-23002/CVE-2023-23002_CWE-476_6845667146a28c09b5dfc401c1ad112374087944_hci_qca.c.diff",
    "function_code": "static int qca_serdev_probe(struct serdev_device *serdev)\n{\n\tstruct qca_serdev *qcadev;\n\tstruct hci_dev *hdev;\n\tconst struct qca_device_data *data;\n\tint err;\n\tbool power_ctrl_enabled = true;\n\n\tqcadev = devm_kzalloc(&serdev->dev, sizeof(*qcadev), GFP_KERNEL);\n\tif (!qcadev)\n\t\treturn -ENOMEM;\n\n\tqcadev->serdev_hu.serdev = serdev;\n\tdata = device_get_match_data(&serdev->dev);\n\tserdev_device_set_drvdata(serdev, qcadev);\n\tdevice_property_read_string(&serdev->dev, \"firmware-name\",\n\t\t\t\t\t &qcadev->firmware_name);\n\tdevice_property_read_u32(&serdev->dev, \"max-speed\",\n\t\t\t\t &qcadev->oper_speed);\n\tif (!qcadev->oper_speed)\n\t\tBT_DBG(\"UART will pick default operating speed\");\n\n\tif (data &&\n\t    (qca_is_wcn399x(data->soc_type) ||\n\t    qca_is_wcn6750(data->soc_type))) {\n\t\tqcadev->btsoc_type = data->soc_type;\n\t\tqcadev->bt_power = devm_kzalloc(&serdev->dev,\n\t\t\t\t\t\tsizeof(struct qca_power),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!qcadev->bt_power)\n\t\t\treturn -ENOMEM;\n\n\t\tqcadev->bt_power->dev = &serdev->dev;\n\t\terr = qca_init_regulators(qcadev->bt_power, data->vregs,\n\t\t\t\t\t  data->num_vregs);\n\t\tif (err) {\n\t\t\tBT_ERR(\"Failed to init regulators:%d\", err);\n\t\t\treturn err;\n\t\t}\n\n\t\tqcadev->bt_power->vregs_on = false;\n\n\t\tqcadev->bt_en = devm_gpiod_get_optional(&serdev->dev, \"enable\",\n\t\t\t\t\t       GPIOD_OUT_LOW);\n\t\tif (IS_ERR_OR_NULL(qcadev->bt_en) && data->soc_type == QCA_WCN6750) {\n\t\t\tdev_err(&serdev->dev, \"failed to acquire BT_EN gpio\\n\");\n\t\t\tpower_ctrl_enabled = false;\n\t\t}\n\n\t\tqcadev->sw_ctrl = devm_gpiod_get_optional(&serdev->dev, \"swctrl\",\n\t\t\t\t\t       GPIOD_IN);\n\t\tif (IS_ERR_OR_NULL(qcadev->sw_ctrl) && data->soc_type == QCA_WCN6750)\n\t\t\tdev_warn(&serdev->dev, \"failed to acquire SW_CTRL gpio\\n\");\n\n\t\tqcadev->susclk = devm_clk_get_optional(&serdev->dev, NULL);\n\t\tif (IS_ERR(qcadev->susclk)) {\n\t\t\tdev_err(&serdev->dev, \"failed to acquire clk\\n\");\n\t\t\treturn PTR_ERR(qcadev->susclk);\n\t\t}\n\n\t\terr = hci_uart_register_device(&qcadev->serdev_hu, &qca_proto);\n\t\tif (err) {\n\t\t\tBT_ERR(\"wcn3990 serdev registration failed\");\n\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tif (data)\n\t\t\tqcadev->btsoc_type = data->soc_type;\n\t\telse\n\t\t\tqcadev->btsoc_type = QCA_ROME;\n\n\t\tqcadev->bt_en = devm_gpiod_get_optional(&serdev->dev, \"enable\",\n\t\t\t\t\t       GPIOD_OUT_LOW);\n\t\tif (IS_ERR_OR_NULL(qcadev->bt_en)) {\n\t\t\tdev_warn(&serdev->dev, \"failed to acquire enable gpio\\n\");\n\t\t\tpower_ctrl_enabled = false;\n\t\t}\n\n\t\tqcadev->susclk = devm_clk_get_optional(&serdev->dev, NULL);\n\t\tif (IS_ERR(qcadev->susclk)) {\n\t\t\tdev_warn(&serdev->dev, \"failed to acquire clk\\n\");\n\t\t\treturn PTR_ERR(qcadev->susclk);\n\t\t}\n\t\terr = clk_set_rate(qcadev->susclk, SUSCLK_RATE_32KHZ);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = clk_prepare_enable(qcadev->susclk);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = hci_uart_register_device(&qcadev->serdev_hu, &qca_proto);\n\t\tif (err) {\n\t\t\tBT_ERR(\"Rome serdev registration failed\");\n\t\t\tclk_disable_unprepare(qcadev->susclk);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\thdev = qcadev->serdev_hu.hdev;\n\n\tif (power_ctrl_enabled) {\n\t\tset_bit(HCI_QUIRK_NON_PERSISTENT_SETUP, &hdev->quirks);\n\t\thdev->shutdown = qca_power_off;\n\t}\n\n\tif (data) {\n\t\t/* Wideband speech support must be set per driver since it can't\n\t\t * be queried via hci. Same with the valid le states quirk.\n\t\t */\n\t\tif (data->capabilities & QCA_CAP_WIDEBAND_SPEECH)\n\t\t\tset_bit(HCI_QUIRK_WIDEBAND_SPEECH_SUPPORTED,\n\t\t\t\t&hdev->quirks);\n\n\t\tif (data->capabilities & QCA_CAP_VALID_LE_STATES)\n\t\t\tset_bit(HCI_QUIRK_VALID_LE_STATES, &hdev->quirks);\n\t}\n\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 1445,
    "critical_vars": [
      "resource"
    ],
    "function": "do_prlimit",
    "filename": "linux/CVE-2023-0458/CVE-2023-0458_CWE-476_739790605705ddcf18f21782b9c99ad7d53a8c11_sys.c.diff",
    "function_code": "static int do_prlimit(struct task_struct *tsk, unsigned int resource,\n\t\t      struct rlimit *new_rlim, struct rlimit *old_rlim)\n{\n\tstruct rlimit *rlim;\n\tint retval = 0;\n\n\tif (resource >= RLIM_NLIMITS)\n\t\treturn -EINVAL;\n\tresource = array_index_nospec(resource, RLIM_NLIMITS);\n\n\tif (new_rlim) {\n\t\tif (new_rlim->rlim_cur > new_rlim->rlim_max)\n\t\t\treturn -EINVAL;\n\t\tif (resource == RLIMIT_NOFILE &&\n\t\t\t\tnew_rlim->rlim_max > sysctl_nr_open)\n\t\t\treturn -EPERM;\n\t}\n\n\t/* Holding a refcount on tsk protects tsk->signal from disappearing. */\n\trlim = tsk->signal->rlim + resource;\n\ttask_lock(tsk->group_leader);\n\tif (new_rlim) {\n\t\t/*\n\t\t * Keep the capable check against init_user_ns until cgroups can\n\t\t * contain all limits.\n\t\t */\n\t\tif (new_rlim->rlim_max > rlim->rlim_max &&\n\t\t\t\t!capable(CAP_SYS_RESOURCE))\n\t\t\tretval = -EPERM;\n\t\tif (!retval)\n\t\t\tretval = security_task_setrlimit(tsk, resource, new_rlim);\n\t}\n\tif (!retval) {\n\t\tif (old_rlim)\n\t\t\t*old_rlim = *rlim;\n\t\tif (new_rlim)\n\t\t\t*rlim = *new_rlim;\n\t}\n\ttask_unlock(tsk->group_leader);\n\n\t/*\n\t * RLIMIT_CPU handling. Arm the posix CPU timer if the limit is not\n\t * infinite. In case of RLIM_INFINITY the posix CPU timer code\n\t * ignores the rlimit.\n\t */\n\tif (!retval && new_rlim && resource == RLIMIT_CPU &&\n\t    new_rlim->rlim_cur != RLIM_INFINITY &&\n\t    IS_ENABLED(CONFIG_POSIX_TIMERS)) {\n\t\t/*\n\t\t * update_rlimit_cpu can fail if the task is exiting, but there\n\t\t * may be other tasks in the thread group that are not exiting,\n\t\t * and they need their cpu timers adjusted.\n\t\t *\n\t\t * The group_leader is the last task to be released, so if we\n\t\t * cannot update_rlimit_cpu on it, then the entire process is\n\t\t * exiting and we do not need to update at all.\n\t\t */\n\t\tupdate_rlimit_cpu(tsk->group_leader, new_rlim->rlim_cur);\n\t}\n\n\treturn retval;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 8422,
    "critical_vars": [
      "&r",
      "emulation_type",
      "vcpu"
    ],
    "function": "x86_emulate_instruction",
    "filename": "linux/CVE-2022-1852/CVE-2022-1852_CWE-476_fee060cd52d69c114b62d1a2948ea9648b5131f9_x86.c.diff",
    "function_code": "int x86_emulate_instruction(struct kvm_vcpu *vcpu, gpa_t cr2_or_gpa,\n\t\t\t    int emulation_type, void *insn, int insn_len)\n{\n\tint r;\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\tbool writeback = true;\n\tbool write_fault_to_spt;\n\n\tif (unlikely(!kvm_can_emulate_insn(vcpu, emulation_type, insn, insn_len)))\n\t\treturn 1;\n\n\tvcpu->arch.l1tf_flush_l1d = true;\n\n\t/*\n\t * Clear write_fault_to_shadow_pgtable here to ensure it is\n\t * never reused.\n\t */\n\twrite_fault_to_spt = vcpu->arch.write_fault_to_shadow_pgtable;\n\tvcpu->arch.write_fault_to_shadow_pgtable = false;\n\n\tif (!(emulation_type & EMULTYPE_NO_DECODE)) {\n\t\tkvm_clear_exception_queue(vcpu);\n\n\t\t/*\n\t\t * Return immediately if RIP hits a code breakpoint, such #DBs\n\t\t * are fault-like and are higher priority than any faults on\n\t\t * the code fetch itself.\n\t\t */\n\t\tif (!(emulation_type & EMULTYPE_SKIP) &&\n\t\t    kvm_vcpu_check_code_breakpoint(vcpu, &r))\n\t\t\treturn r;\n\n\t\tr = x86_decode_emulated_instruction(vcpu, emulation_type,\n\t\t\t\t\t\t    insn, insn_len);\n\t\tif (r != EMULATION_OK)  {\n\t\t\tif ((emulation_type & EMULTYPE_TRAP_UD) ||\n\t\t\t    (emulation_type & EMULTYPE_TRAP_UD_FORCED)) {\n\t\t\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (reexecute_instruction(vcpu, cr2_or_gpa,\n\t\t\t\t\t\t  write_fault_to_spt,\n\t\t\t\t\t\t  emulation_type))\n\t\t\t\treturn 1;\n\t\t\tif (ctxt->have_exception) {\n\t\t\t\t/*\n\t\t\t\t * #UD should result in just EMULATION_FAILED, and trap-like\n\t\t\t\t * exception should not be encountered during decode.\n\t\t\t\t */\n\t\t\t\tWARN_ON_ONCE(ctxt->exception.vector == UD_VECTOR ||\n\t\t\t\t\t     exception_type(ctxt->exception.vector) == EXCPT_TRAP);\n\t\t\t\tinject_emulated_exception(vcpu);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn handle_emulation_failure(vcpu, emulation_type);\n\t\t}\n\t}\n\n\tif ((emulation_type & EMULTYPE_VMWARE_GP) &&\n\t    !is_vmware_backdoor_opcode(ctxt)) {\n\t\tkvm_queue_exception_e(vcpu, GP_VECTOR, 0);\n\t\treturn 1;\n\t}\n\n\t/*\n\t * EMULTYPE_SKIP without EMULTYPE_COMPLETE_USER_EXIT is intended for\n\t * use *only* by vendor callbacks for kvm_skip_emulated_instruction().\n\t * The caller is responsible for updating interruptibility state and\n\t * injecting single-step #DBs.\n\t */\n\tif (emulation_type & EMULTYPE_SKIP) {\n\t\tif (ctxt->mode != X86EMUL_MODE_PROT64)\n\t\t\tctxt->eip = (u32)ctxt->_eip;\n\t\telse\n\t\t\tctxt->eip = ctxt->_eip;\n\n\t\tif (emulation_type & EMULTYPE_COMPLETE_USER_EXIT) {\n\t\t\tr = 1;\n\t\t\tgoto writeback;\n\t\t}\n\n\t\tkvm_rip_write(vcpu, ctxt->eip);\n\t\tif (ctxt->eflags & X86_EFLAGS_RF)\n\t\t\tkvm_set_rflags(vcpu, ctxt->eflags & ~X86_EFLAGS_RF);\n\t\treturn 1;\n\t}\n\n\tif (retry_instruction(ctxt, cr2_or_gpa, emulation_type))\n\t\treturn 1;\n\n\t/* this is needed for vmware backdoor interface to work since it\n\t   changes registers values  during IO operation */\n\tif (vcpu->arch.emulate_regs_need_sync_from_vcpu) {\n\t\tvcpu->arch.emulate_regs_need_sync_from_vcpu = false;\n\t\temulator_invalidate_register_cache(ctxt);\n\t}\n\nrestart:\n\tif (emulation_type & EMULTYPE_PF) {\n\t\t/* Save the faulting GPA (cr2) in the address field */\n\t\tctxt->exception.address = cr2_or_gpa;\n\n\t\t/* With shadow page tables, cr2 contains a GVA or nGPA. */\n\t\tif (vcpu->arch.mmu->root_role.direct) {\n\t\t\tctxt->gpa_available = true;\n\t\t\tctxt->gpa_val = cr2_or_gpa;\n\t\t}\n\t} else {\n\t\t/* Sanitize the address out of an abundance of paranoia. */\n\t\tctxt->exception.address = 0;\n\t}\n\n\tr = x86_emulate_insn(ctxt);\n\n\tif (r == EMULATION_INTERCEPTED)\n\t\treturn 1;\n\n\tif (r == EMULATION_FAILED) {\n\t\tif (reexecute_instruction(vcpu, cr2_or_gpa, write_fault_to_spt,\n\t\t\t\t\temulation_type))\n\t\t\treturn 1;\n\n\t\treturn handle_emulation_failure(vcpu, emulation_type);\n\t}\n\n\tif (ctxt->have_exception) {\n\t\tr = 1;\n\t\tif (inject_emulated_exception(vcpu))\n\t\t\treturn r;\n\t} else if (vcpu->arch.pio.count) {\n\t\tif (!vcpu->arch.pio.in) {\n\t\t\t/* FIXME: return into emulator if single-stepping.  */\n\t\t\tvcpu->arch.pio.count = 0;\n\t\t} else {\n\t\t\twriteback = false;\n\t\t\tvcpu->arch.complete_userspace_io = complete_emulated_pio;\n\t\t}\n\t\tr = 0;\n\t} else if (vcpu->mmio_needed) {\n\t\t++vcpu->stat.mmio_exits;\n\n\t\tif (!vcpu->mmio_is_write)\n\t\t\twriteback = false;\n\t\tr = 0;\n\t\tvcpu->arch.complete_userspace_io = complete_emulated_mmio;\n\t} else if (vcpu->arch.complete_userspace_io) {\n\t\twriteback = false;\n\t\tr = 0;\n\t} else if (r == EMULATION_RESTART)\n\t\tgoto restart;\n\telse\n\t\tr = 1;\n\nwriteback:\n\tif (writeback) {\n\t\tunsigned long rflags = static_call(kvm_x86_get_rflags)(vcpu);\n\t\ttoggle_interruptibility(vcpu, ctxt->interruptibility);\n\t\tvcpu->arch.emulate_regs_need_sync_to_vcpu = false;\n\t\tif (!ctxt->have_exception ||\n\t\t    exception_type(ctxt->exception.vector) == EXCPT_TRAP) {\n\t\t\tkvm_pmu_trigger_event(vcpu, PERF_COUNT_HW_INSTRUCTIONS);\n\t\t\tif (ctxt->is_branch)\n\t\t\t\tkvm_pmu_trigger_event(vcpu, PERF_COUNT_HW_BRANCH_INSTRUCTIONS);\n\t\t\tkvm_rip_write(vcpu, ctxt->eip);\n\t\t\tif (r && (ctxt->tf || (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)))\n\t\t\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\t\t\tstatic_call_cond(kvm_x86_update_emulated_instruction)(vcpu);\n\t\t\t__kvm_set_rflags(vcpu, ctxt->eflags);\n\t\t}\n\n\t\t/*\n\t\t * For STI, interrupts are shadowed; so KVM_REQ_EVENT will\n\t\t * do nothing, and it will be requested again as soon as\n\t\t * the shadow expires.  But we still need to check here,\n\t\t * because POPF has no interrupt shadow.\n\t\t */\n\t\tif (unlikely((ctxt->eflags & ~rflags) & X86_EFLAGS_IF))\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t} else\n\t\tvcpu->arch.emulate_regs_need_sync_to_vcpu = true;\n\n\treturn r;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 765,
    "critical_vars": [
      "pf->disk"
    ],
    "function": "pf_detect",
    "filename": "linux/CVE-2019-15922/CVE-2019-15922_CWE-476_58ccd2d31e502c37e108b285bf3d343eb00c235b_pf.c.diff",
    "function_code": "static int pf_detect(void)\n{\n\tstruct pf_unit *pf = units;\n\tint k, unit;\n\n\tprintk(\"%s: %s version %s, major %d, cluster %d, nice %d\\n\",\n\t       name, name, PF_VERSION, major, cluster, nice);\n\n\tpar_drv = pi_register_driver(name);\n\tif (!par_drv) {\n\t\tpr_err(\"failed to register %s driver\\n\", name);\n\t\treturn -1;\n\t}\n\tk = 0;\n\tif (pf_drive_count == 0) {\n\t\tif (pi_init(pf->pi, 1, -1, -1, -1, -1, -1, pf_scratch, PI_PF,\n\t\t\t    verbose, pf->name)) {\n\t\t\tif (!pf_probe(pf) && pf->disk) {\n\t\t\t\tpf->present = 1;\n\t\t\t\tk++;\n\t\t\t} else\n\t\t\t\tpi_release(pf->pi);\n\t\t}\n\n\t} else\n\t\tfor (unit = 0; unit < PF_UNITS; unit++, pf++) {\n\t\t\tint *conf = *drives[unit];\n\t\t\tif (!conf[D_PRT])\n\t\t\t\tcontinue;\n\t\t\tif (pi_init(pf->pi, 0, conf[D_PRT], conf[D_MOD],\n\t\t\t\t    conf[D_UNI], conf[D_PRO], conf[D_DLY],\n\t\t\t\t    pf_scratch, PI_PF, verbose, pf->name)) {\n\t\t\t\tif (pf->disk && !pf_probe(pf)) {\n\t\t\t\t\tpf->present = 1;\n\t\t\t\t\tk++;\n\t\t\t\t} else\n\t\t\t\t\tpi_release(pf->pi);\n\t\t\t}\n\t\t}\n\tif (k)\n\t\treturn 0;\n\n\tprintk(\"%s: No ATAPI disk detected\\n\", name);\n\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n\t\tif (!pf->disk)\n\t\t\tcontinue;\n\t\tblk_cleanup_queue(pf->disk->queue);\n\t\tpf->disk->queue = NULL;\n\t\tblk_mq_free_tag_set(&pf->tag_set);\n\t\tput_disk(pf->disk);\n\t}\n\tpi_unregister_driver(par_drv);\n\treturn -1;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1061,
    "critical_vars": [
      "pf->disk"
    ],
    "function": "pf_exit",
    "filename": "linux/CVE-2019-15922/CVE-2019-15922_CWE-476_58ccd2d31e502c37e108b285bf3d343eb00c235b_pf.c.diff",
    "function_code": "static void __exit pf_exit(void)\n{\n\tstruct pf_unit *pf;\n\tint unit;\n\tunregister_blkdev(major, name);\n\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n\t\tif (!pf->disk)\n\t\t\tcontinue;\n\n\t\tif (pf->present)\n\t\t\tdel_gendisk(pf->disk);\n\n\t\tblk_cleanup_queue(pf->disk->queue);\n\t\tblk_mq_free_tag_set(&pf->tag_set);\n\t\tput_disk(pf->disk);\n\n\t\tif (pf->present)\n\t\t\tpi_release(pf->pi);\n\t}\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 347,
    "line_new": 347,
    "critical_vars": [
      "sgt"
    ],
    "function": "malidp_check_pages_threshold",
    "filename": "linux/CVE-2023-23004/CVE-2023-23004_CWE-476_15342f930ebebcfe36f2415049736a77d7d2e045_malidp_planes.c.diff",
    "function_code": "static bool malidp_check_pages_threshold(struct malidp_plane_state *ms,\n\t\t\t\t\t u32 pgsize)\n{\n\tint i;\n\n\tfor (i = 0; i < ms->n_planes; i++) {\n\t\tstruct drm_gem_object *obj;\n\t\tstruct drm_gem_cma_object *cma_obj;\n\t\tstruct sg_table *sgt;\n\t\tstruct scatterlist *sgl;\n\n\t\tobj = drm_gem_fb_get_obj(ms->base.fb, i);\n\t\tcma_obj = to_drm_gem_cma_obj(obj);\n\n\t\tif (cma_obj->sgt)\n\t\t\tsgt = cma_obj->sgt;\n\t\telse\n\t\t\tsgt = obj->funcs->get_sg_table(obj);\n\n\t\tif (IS_ERR(sgt))\n\t\t\treturn false;\n\n\t\tsgl = sgt->sgl;\n\n\t\twhile (sgl) {\n\t\t\tif (sgl->length < pgsize) {\n\t\t\t\tif (!cma_obj->sgt)\n\t\t\t\t\tkfree(sgt);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tsgl = sg_next(sgl);\n\t\t}\n\t\tif (!cma_obj->sgt)\n\t\t\tkfree(sgt);\n\t}\n\n\treturn true;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 388,
    "critical_vars": [
      "mp"
    ],
    "function": "dbFree",
    "filename": "linux/CVE-2023-4385/CVE-2023-4385_CWE-476_0d4837fdb796f99369cf7691d33de1b856bcaf1f_jfs_dmap.c.diff",
    "function_code": "int dbFree(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct super_block *sb = ipbmap->i_sb;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* block to be freed better be within the mapsize. */\n\tif (unlikely((blkno == 0) || (blkno + nblocks > bmp->db_mapsize))) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ip->i_sb, \"block to be freed is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/**\n\t * TRIM the blocks, when mounted with discard option\n\t */\n\tif (JFS_SBI(sb)->flag & JFS_DISCARD)\n\t\tif (JFS_SBI(sb)->minblks_trim <= nblocks)\n\t\t\tjfs_issue_discard(ipbmap, blkno, nblocks);\n\n\t/*\n\t * free the blocks a dmap at a time.\n\t */\n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\t/* release previous dmap if any */\n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the number of blocks to be freed from\n\t\t * this dmap.\n\t\t */\n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\n\t\t/* free the blocks. */\n\t\tif ((rc = dbFreeDmap(bmp, dp, blkno, nb))) {\n\t\t\tjfs_error(ip->i_sb, \"error in block map\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\t/* write the last buffer. */\n\twrite_metapage(mp);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (0);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 388,
    "critical_vars": [
      "mp"
    ],
    "function": "dbFree",
    "filename": "linux/CVE-2023-4385/CVE-2023-4385_CWE-476_0d4837fdb796f99369cf7691d33de1b856bcaf1f_jfs_dmap.c.diff",
    "function_code": "int dbFree(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct super_block *sb = ipbmap->i_sb;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* block to be freed better be within the mapsize. */\n\tif (unlikely((blkno == 0) || (blkno + nblocks > bmp->db_mapsize))) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ip->i_sb, \"block to be freed is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/**\n\t * TRIM the blocks, when mounted with discard option\n\t */\n\tif (JFS_SBI(sb)->flag & JFS_DISCARD)\n\t\tif (JFS_SBI(sb)->minblks_trim <= nblocks)\n\t\t\tjfs_issue_discard(ipbmap, blkno, nblocks);\n\n\t/*\n\t * free the blocks a dmap at a time.\n\t */\n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\t/* release previous dmap if any */\n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the number of blocks to be freed from\n\t\t * this dmap.\n\t\t */\n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\n\t\t/* free the blocks. */\n\t\tif ((rc = dbFreeDmap(bmp, dp, blkno, nb))) {\n\t\t\tjfs_error(ip->i_sb, \"error in block map\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\t/* write the last buffer. */\n\tif (mp)\n\t\twrite_metapage(mp);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (0);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 208,
    "critical_vars": [
      "r"
    ],
    "function": "unimac_mdio_probe",
    "filename": "linux/CVE-2018-8043/CVE-2018-8043_CWE-476_297a6961ffb8ff4dc66c9fbf53b924bd1dda05d5_mdio-bcm-unimac.c.diff",
    "function_code": "static int unimac_mdio_probe(struct platform_device *pdev)\n{\n\tstruct unimac_mdio_pdata *pdata = pdev->dev.platform_data;\n\tstruct unimac_mdio_priv *priv;\n\tstruct device_node *np;\n\tstruct mii_bus *bus;\n\tstruct resource *r;\n\tint ret;\n\n\tnp = pdev->dev.of_node;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!r)\n\t\treturn -EINVAL;\n\n\t/* Just ioremap, as this MDIO block is usually integrated into an\n\t * Ethernet MAC controller register range\n\t */\n\tpriv->base = devm_ioremap(&pdev->dev, r->start, resource_size(r));\n\tif (!priv->base) {\n\t\tdev_err(&pdev->dev, \"failed to remap register\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv->mii_bus = mdiobus_alloc();\n\tif (!priv->mii_bus)\n\t\treturn -ENOMEM;\n\n\tbus = priv->mii_bus;\n\tbus->priv = priv;\n\tif (pdata) {\n\t\tbus->name = pdata->bus_name;\n\t\tpriv->wait_func = pdata->wait_func;\n\t\tpriv->wait_func_data = pdata->wait_func_data;\n\t\tbus->phy_mask = ~pdata->phy_mask;\n\t} else {\n\t\tbus->name = \"unimac MII bus\";\n\t\tpriv->wait_func_data = priv;\n\t\tpriv->wait_func = unimac_mdio_poll;\n\t}\n\tbus->parent = &pdev->dev;\n\tbus->read = unimac_mdio_read;\n\tbus->write = unimac_mdio_write;\n\tbus->reset = unimac_mdio_reset;\n\tsnprintf(bus->id, MII_BUS_ID_SIZE, \"%s-%d\", pdev->name, pdev->id);\n\n\tret = of_mdiobus_register(bus, np);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"MDIO bus registration failed\\n\");\n\t\tgoto out_mdio_free;\n\t}\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tdev_info(&pdev->dev, \"Broadcom UniMAC MDIO bus at 0x%p\\n\", priv->base);\n\n\treturn 0;\n\nout_mdio_free:\n\tmdiobus_free(bus);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 3169,
    "critical_vars": [
      "tb[NFTA_EXPR_NAME]"
    ],
    "function": "nft_expr_inner_parse",
    "filename": "linux/CVE-2023-5972/CVE-2023-5972_CWE-476_505ce0630ad5d31185695f8a29dde8d29f28faa7_nf_tables_api.c.diff",
    "function_code": "int nft_expr_inner_parse(const struct nft_ctx *ctx, const struct nlattr *nla,\n\t\t\t struct nft_expr_info *info)\n{\n\tstruct nlattr *tb[NFTA_EXPR_MAX + 1];\n\tconst struct nft_expr_type *type;\n\tint err;\n\n\terr = nla_parse_nested_deprecated(tb, NFTA_EXPR_MAX, nla,\n\t\t\t\t\t  nft_expr_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[NFTA_EXPR_DATA] || !tb[NFTA_EXPR_NAME])\n\t\treturn -EINVAL;\n\n\ttype = __nft_expr_type_get(ctx->family, tb[NFTA_EXPR_NAME]);\n\tif (!type)\n\t\treturn -ENOENT;\n\n\tif (!type->inner_ops)\n\t\treturn -EOPNOTSUPP;\n\n\terr = nla_parse_nested_deprecated(info->tb, type->maxattr,\n\t\t\t\t\t  tb[NFTA_EXPR_DATA],\n\t\t\t\t\t  type->policy, NULL);\n\tif (err < 0)\n\t\tgoto err_nla_parse;\n\n\tinfo->attr = nla;\n\tinfo->ops = type->inner_ops;\n\n\treturn 0;\n\nerr_nla_parse:\n\treturn err;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 301,
    "critical_vars": [
      "tb"
    ],
    "function": "nft_inner_init",
    "filename": "linux/CVE-2023-5972/CVE-2023-5972_CWE-476_52177bbf19e6e9398375a148d2e13ed492b40b80_nft_inner.c.diff",
    "function_code": "static int nft_inner_init(const struct nft_ctx *ctx,\n\t\t\t  const struct nft_expr *expr,\n\t\t\t  const struct nlattr * const tb[])\n{\n\tstruct nft_inner *priv = nft_expr_priv(expr);\n\tu32 flags, hdrsize, type, num;\n\tstruct nft_expr_info expr_info;\n\tint err;\n\n\tif (!tb[NFTA_INNER_FLAGS] ||\n\t    !tb[NFTA_INNER_NUM] ||\n\t    !tb[NFTA_INNER_HDRSIZE] ||\n\t    !tb[NFTA_INNER_TYPE] ||\n\t    !tb[NFTA_INNER_EXPR])\n\t\treturn -EINVAL;\n\n\tflags = ntohl(nla_get_be32(tb[NFTA_INNER_FLAGS]));\n\tif (flags & ~NFT_INNER_MASK)\n\t\treturn -EOPNOTSUPP;\n\n\tnum = ntohl(nla_get_be32(tb[NFTA_INNER_NUM]));\n\tif (num != 0)\n\t\treturn -EOPNOTSUPP;\n\n\thdrsize = ntohl(nla_get_be32(tb[NFTA_INNER_HDRSIZE]));\n\ttype = ntohl(nla_get_be32(tb[NFTA_INNER_TYPE]));\n\n\tif (type > U8_MAX)\n\t\treturn -EINVAL;\n\n\tif (flags & NFT_INNER_HDRSIZE) {\n\t\tif (hdrsize == 0 || hdrsize > 64)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\tpriv->flags = flags;\n\tpriv->hdrsize = hdrsize;\n\tpriv->type = type;\n\n\terr = nft_expr_inner_parse(ctx, tb[NFTA_INNER_EXPR], &expr_info);\n\tif (err < 0)\n\t\treturn err;\n\n\tpriv->expr.ops = expr_info.ops;\n\n\tif (!strcmp(expr_info.ops->type->name, \"payload\"))\n\t\tpriv->expr_type = NFT_INNER_EXPR_PAYLOAD;\n\telse if (!strcmp(expr_info.ops->type->name, \"meta\"))\n\t\tpriv->expr_type = NFT_INNER_EXPR_META;\n\telse\n\t\treturn -EINVAL;\n\n\terr = expr_info.ops->init(ctx, (struct nft_expr *)&priv->expr,\n\t\t\t\t  (const struct nlattr * const*)expr_info.tb);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 769,
    "critical_vars": [
      "&key->flags"
    ],
    "function": "keyctl_read_key",
    "filename": "linux/CVE-2017-12192/CVE-2017-12192_CWE-476_37863c43b2c6464f252862bf2e9768264e961678_keyctl.c.diff",
    "function_code": "long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\n\t/* find the key first */\n\tkey_ref = lookup_user_key(keyid, 0, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags)) {\n\t\tret = -ENOKEY;\n\t\tgoto error2;\n\t}\n\n\t/* see if we can read it directly */\n\tret = key_permission(key_ref, KEY_NEED_READ);\n\tif (ret == 0)\n\t\tgoto can_read_key;\n\tif (ret != -EACCES)\n\t\tgoto error2;\n\n\t/* we can't; see if it's searchable from this process's keyrings\n\t * - we automatically take account of the fact that it may be\n\t *   dangling off an instantiation key\n\t */\n\tif (!is_key_possessed(key_ref)) {\n\t\tret = -EACCES;\n\t\tgoto error2;\n\t}\n\n\t/* the key is probably readable - now try to read it */\ncan_read_key:\n\tret = -EOPNOTSUPP;\n\tif (key->type->read) {\n\t\t/* Read the data with the semaphore held (since we might sleep)\n\t\t * to protect against the key being updated or revoked.\n\t\t */\n\t\tdown_read(&key->sem);\n\t\tret = key_validate(key);\n\t\tif (ret == 0)\n\t\t\tret = key->type->read(key, buffer, buflen);\n\t\tup_read(&key->sem);\n\t}\n\nerror2:\n\tkey_put(key);\nerror:\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 187,
    "critical_vars": [
      "node->nd_item.ci_parent"
    ],
    "function": "*to_o2nm_cluster_from_node",
    "filename": "linux/CVE-2017-18216/CVE-2017-18216_CWE-476_853bc26a7ea39e354b9f8889ae7ad1492ffa28d2_nodemanager.c.diff",
    "function_code": "static struct o2nm_cluster *to_o2nm_cluster_from_node(struct o2nm_node *node)\n{\n\t/* through the first node_set .parent\n\t * mycluster/nodes/mynode == o2nm_cluster->o2nm_node_group->o2nm_node */\n\tif (node->nd_item.ci_parent)\n\t\treturn to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);\n\telse\n\t\treturn NULL;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 197,
    "critical_vars": [
      "*cluster"
    ],
    "function": "o2nm_node_num_store",
    "filename": "linux/CVE-2017-18216/CVE-2017-18216_CWE-476_853bc26a7ea39e354b9f8889ae7ad1492ffa28d2_nodemanager.c.diff",
    "function_code": "static ssize_t o2nm_node_num_store(struct config_item *item, const char *page,\n\t\t\t\t   size_t count)\n{\n\tstruct o2nm_node *node = to_o2nm_node(item);\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n\tunsigned long tmp;\n\tchar *p = (char *)page;\n\tint ret = 0;\n\n\ttmp = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\n\tif (tmp >= O2NM_MAX_NODES)\n\t\treturn -ERANGE;\n\n\t/* once we're in the cl_nodes tree networking can look us up by\n\t * node number and try to use our address and port attributes\n\t * to connect to this node.. make sure that they've been set\n\t * before writing the node attribute? */\n\tif (!test_bit(O2NM_NODE_ATTR_ADDRESS, &node->nd_set_attributes) ||\n\t    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))\n\t\treturn -EINVAL; /* XXX */\n\n\twrite_lock(&cluster->cl_nodes_lock);\n\tif (cluster->cl_nodes[tmp])\n\t\tret = -EEXIST;\n\telse if (test_and_set_bit(O2NM_NODE_ATTR_NUM,\n\t\t\t&node->nd_set_attributes))\n\t\tret = -EBUSY;\n\telse  {\n\t\tcluster->cl_nodes[tmp] = node;\n\t\tnode->nd_num = tmp;\n\t\tset_bit(tmp, cluster->cl_nodes_bitmap);\n\t}\n\twrite_unlock(&cluster->cl_nodes_lock);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 203,
    "critical_vars": [
      "*cluster"
    ],
    "function": "o2nm_node_num_store",
    "filename": "linux/CVE-2017-18216/CVE-2017-18216_CWE-476_853bc26a7ea39e354b9f8889ae7ad1492ffa28d2_nodemanager.c.diff",
    "function_code": "static ssize_t o2nm_node_num_store(struct config_item *item, const char *page,\n\t\t\t\t   size_t count)\n{\n\tstruct o2nm_node *node = to_o2nm_node(item);\n\tstruct o2nm_cluster *cluster;\n\tunsigned long tmp;\n\tchar *p = (char *)page;\n\tint ret = 0;\n\n\ttmp = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\n\tif (tmp >= O2NM_MAX_NODES)\n\t\treturn -ERANGE;\n\n\t/* once we're in the cl_nodes tree networking can look us up by\n\t * node number and try to use our address and port attributes\n\t * to connect to this node.. make sure that they've been set\n\t * before writing the node attribute? */\n\tif (!test_bit(O2NM_NODE_ATTR_ADDRESS, &node->nd_set_attributes) ||\n\t    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))\n\t\treturn -EINVAL; /* XXX */\n\n\to2nm_lock_subsystem();\n\tcluster = to_o2nm_cluster_from_node(node);\n\tif (!cluster) {\n\t\to2nm_unlock_subsystem();\n\t\treturn -EINVAL;\n\t}\n\n\twrite_lock(&cluster->cl_nodes_lock);\n\tif (cluster->cl_nodes[tmp])\n\t\tret = -EEXIST;\n\telse if (test_and_set_bit(O2NM_NODE_ATTR_NUM,\n\t\t\t&node->nd_set_attributes))\n\t\tret = -EBUSY;\n\telse  {\n\t\tcluster->cl_nodes[tmp] = node;\n\t\tnode->nd_num = tmp;\n\t\tset_bit(tmp, cluster->cl_nodes_bitmap);\n\t}\n\twrite_unlock(&cluster->cl_nodes_lock);\n\to2nm_unlock_subsystem();\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 272,
    "critical_vars": [
      "*cluster"
    ],
    "function": "o2nm_node_ipv4_address_store",
    "filename": "linux/CVE-2017-18216/CVE-2017-18216_CWE-476_853bc26a7ea39e354b9f8889ae7ad1492ffa28d2_nodemanager.c.diff",
    "function_code": "static ssize_t o2nm_node_ipv4_address_store(struct config_item *item,\n\t\t\t\t\t    const char *page,\n\t\t\t\t\t    size_t count)\n{\n\tstruct o2nm_node *node = to_o2nm_node(item);\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n\tint ret, i;\n\tstruct rb_node **p, *parent;\n\tunsigned int octets[4];\n\t__be32 ipv4_addr = 0;\n\n\tret = sscanf(page, \"%3u.%3u.%3u.%3u\", &octets[3], &octets[2],\n\t\t     &octets[1], &octets[0]);\n\tif (ret != 4)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(octets); i++) {\n\t\tif (octets[i] > 255)\n\t\t\treturn -ERANGE;\n\t\tbe32_add_cpu(&ipv4_addr, octets[i] << (i * 8));\n\t}\n\n\tret = 0;\n\twrite_lock(&cluster->cl_nodes_lock);\n\tif (o2nm_node_ip_tree_lookup(cluster, ipv4_addr, &p, &parent))\n\t\tret = -EEXIST;\n\telse if (test_and_set_bit(O2NM_NODE_ATTR_ADDRESS,\n\t\t\t&node->nd_set_attributes))\n\t\tret = -EBUSY;\n\telse {\n\t\trb_link_node(&node->nd_ip_node, parent, p);\n\t\trb_insert_color(&node->nd_ip_node, &cluster->cl_node_ip_tree);\n\t}\n\twrite_unlock(&cluster->cl_nodes_lock);\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy(&node->nd_ipv4_address, &ipv4_addr, sizeof(ipv4_addr));\n\n\treturn count;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 287,
    "critical_vars": [
      "*cluster"
    ],
    "function": "o2nm_node_ipv4_address_store",
    "filename": "linux/CVE-2017-18216/CVE-2017-18216_CWE-476_853bc26a7ea39e354b9f8889ae7ad1492ffa28d2_nodemanager.c.diff",
    "function_code": "static ssize_t o2nm_node_ipv4_address_store(struct config_item *item,\n\t\t\t\t\t    const char *page,\n\t\t\t\t\t    size_t count)\n{\n\tstruct o2nm_node *node = to_o2nm_node(item);\n\tstruct o2nm_cluster *cluster;\n\tint ret, i;\n\tstruct rb_node **p, *parent;\n\tunsigned int octets[4];\n\t__be32 ipv4_addr = 0;\n\n\tret = sscanf(page, \"%3u.%3u.%3u.%3u\", &octets[3], &octets[2],\n\t\t     &octets[1], &octets[0]);\n\tif (ret != 4)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(octets); i++) {\n\t\tif (octets[i] > 255)\n\t\t\treturn -ERANGE;\n\t\tbe32_add_cpu(&ipv4_addr, octets[i] << (i * 8));\n\t}\n\n\to2nm_lock_subsystem();\n\tcluster = to_o2nm_cluster_from_node(node);\n\tif (!cluster) {\n\t\to2nm_unlock_subsystem();\n\t\treturn -EINVAL;\n\t}\n\n\tret = 0;\n\twrite_lock(&cluster->cl_nodes_lock);\n\tif (o2nm_node_ip_tree_lookup(cluster, ipv4_addr, &p, &parent))\n\t\tret = -EEXIST;\n\telse if (test_and_set_bit(O2NM_NODE_ATTR_ADDRESS,\n\t\t\t&node->nd_set_attributes))\n\t\tret = -EBUSY;\n\telse {\n\t\trb_link_node(&node->nd_ip_node, parent, p);\n\t\trb_insert_color(&node->nd_ip_node, &cluster->cl_node_ip_tree);\n\t}\n\twrite_unlock(&cluster->cl_nodes_lock);\n\to2nm_unlock_subsystem();\n\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy(&node->nd_ipv4_address, &ipv4_addr, sizeof(ipv4_addr));\n\n\treturn count;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 318,
    "critical_vars": [
      "*cluster"
    ],
    "function": "o2nm_node_local_store",
    "filename": "linux/CVE-2017-18216/CVE-2017-18216_CWE-476_853bc26a7ea39e354b9f8889ae7ad1492ffa28d2_nodemanager.c.diff",
    "function_code": "static ssize_t o2nm_node_local_store(struct config_item *item, const char *page,\n\t\t\t\t     size_t count)\n{\n\tstruct o2nm_node *node = to_o2nm_node(item);\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n\tunsigned long tmp;\n\tchar *p = (char *)page;\n\tssize_t ret;\n\n\ttmp = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\n\ttmp = !!tmp; /* boolean of whether this node wants to be local */\n\n\t/* setting local turns on networking rx for now so we require having\n\t * set everything else first */\n\tif (!test_bit(O2NM_NODE_ATTR_ADDRESS, &node->nd_set_attributes) ||\n\t    !test_bit(O2NM_NODE_ATTR_NUM, &node->nd_set_attributes) ||\n\t    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))\n\t\treturn -EINVAL; /* XXX */\n\n\t/* the only failure case is trying to set a new local node\n\t * when a different one is already set */\n\tif (tmp && tmp == cluster->cl_has_local &&\n\t    cluster->cl_local_node != node->nd_num)\n\t\treturn -EBUSY;\n\n\t/* bring up the rx thread if we're setting the new local node. */\n\tif (tmp && !cluster->cl_has_local) {\n\t\tret = o2net_start_listening(node);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (!tmp && cluster->cl_has_local &&\n\t    cluster->cl_local_node == node->nd_num) {\n\t\to2net_stop_listening(node);\n\t\tcluster->cl_local_node = O2NM_INVALID_NODE_NUM;\n\t}\n\n\tnode->nd_local = tmp;\n\tif (node->nd_local) {\n\t\tcluster->cl_has_local = tmp;\n\t\tcluster->cl_local_node = node->nd_num;\n\t}\n\n\treturn count;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 342,
    "critical_vars": [
      "*cluster"
    ],
    "function": "o2nm_node_local_store",
    "filename": "linux/CVE-2017-18216/CVE-2017-18216_CWE-476_853bc26a7ea39e354b9f8889ae7ad1492ffa28d2_nodemanager.c.diff",
    "function_code": "static ssize_t o2nm_node_local_store(struct config_item *item, const char *page,\n\t\t\t\t     size_t count)\n{\n\tstruct o2nm_node *node = to_o2nm_node(item);\n\tstruct o2nm_cluster *cluster;\n\tunsigned long tmp;\n\tchar *p = (char *)page;\n\tssize_t ret;\n\n\ttmp = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\n\ttmp = !!tmp; /* boolean of whether this node wants to be local */\n\n\t/* setting local turns on networking rx for now so we require having\n\t * set everything else first */\n\tif (!test_bit(O2NM_NODE_ATTR_ADDRESS, &node->nd_set_attributes) ||\n\t    !test_bit(O2NM_NODE_ATTR_NUM, &node->nd_set_attributes) ||\n\t    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))\n\t\treturn -EINVAL; /* XXX */\n\n\to2nm_lock_subsystem();\n\tcluster = to_o2nm_cluster_from_node(node);\n\tif (!cluster) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* the only failure case is trying to set a new local node\n\t * when a different one is already set */\n\tif (tmp && tmp == cluster->cl_has_local &&\n\t    cluster->cl_local_node != node->nd_num) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t/* bring up the rx thread if we're setting the new local node. */\n\tif (tmp && !cluster->cl_has_local) {\n\t\tret = o2net_start_listening(node);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (!tmp && cluster->cl_has_local &&\n\t    cluster->cl_local_node == node->nd_num) {\n\t\to2net_stop_listening(node);\n\t\tcluster->cl_local_node = O2NM_INVALID_NODE_NUM;\n\t}\n\n\tnode->nd_local = tmp;\n\tif (node->nd_local) {\n\t\tcluster->cl_has_local = tmp;\n\t\tcluster->cl_local_node = node->nd_num;\n\t}\n\n\tret = count;\n\nout:\n\to2nm_unlock_subsystem();\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 1398,
    "critical_vars": [
      "v4l2_buf"
    ],
    "function": "tw5864_handle_frame",
    "filename": "linux/CVE-2019-20806/CVE-2019-20806_CWE-476_2e7682ebfc750177a4944eeb56e97a3f05734528_tw5864-video.c.diff",
    "function_code": "static void tw5864_handle_frame(struct tw5864_h264_frame *frame)\n{\n#define SKIP_VLCBUF_BYTES 3\n\tstruct tw5864_input *input = frame->input;\n\tstruct tw5864_dev *dev = input->root;\n\tstruct tw5864_buf *vb;\n\tstruct vb2_v4l2_buffer *v4l2_buf;\n\tint frame_len = frame->vlc_len - SKIP_VLCBUF_BYTES;\n\tu8 *dst = input->buf_cur_ptr;\n\tu8 tail_mask, vlc_mask = 0;\n\tint i;\n\tu8 vlc_first_byte = ((u8 *)(frame->vlc.addr + SKIP_VLCBUF_BYTES))[0];\n\tunsigned long flags;\n\tint zero_run;\n\tu8 *src;\n\tu8 *src_end;\n\n#ifdef DEBUG\n\tif (frame->checksum !=\n\t    tw5864_vlc_checksum((u32 *)frame->vlc.addr, frame_len))\n\t\tdev_err(&dev->pci->dev,\n\t\t\t\"Checksum of encoded frame doesn't match!\\n\");\n#endif\n\n\tspin_lock_irqsave(&input->slock, flags);\n\tvb = input->vb;\n\tinput->vb = NULL;\n\tspin_unlock_irqrestore(&input->slock, flags);\n\n\tv4l2_buf = to_vb2_v4l2_buffer(&vb->vb.vb2_buf);\n\n\tif (!vb) { /* Gone because of disabling */\n\t\tdev_dbg(&dev->pci->dev, \"vb is empty, dropping frame\\n\");\n\t\treturn;\n\t}\n\n\t/*\n\t * Check for space.\n\t * Mind the overhead of startcode emulation prevention.\n\t */\n\tif (input->buf_cur_space_left < frame_len * 5 / 4) {\n\t\tdev_err_once(&dev->pci->dev,\n\t\t\t     \"Left space in vb2 buffer, %d bytes, is less than considered safely enough to put frame of length %d. Dropping this frame.\\n\",\n\t\t\t     input->buf_cur_space_left, frame_len);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 8 - input->tail_nb_bits; i++)\n\t\tvlc_mask |= 1 << i;\n\ttail_mask = (~vlc_mask) & 0xff;\n\n\tdst[0] = (input->tail & tail_mask) | (vlc_first_byte & vlc_mask);\n\tframe_len--;\n\tdst++;\n\n\t/* H.264 startcode emulation prevention */\n\tsrc = frame->vlc.addr + SKIP_VLCBUF_BYTES + 1;\n\tsrc_end = src + frame_len;\n\tzero_run = 0;\n\tfor (; src < src_end; src++) {\n\t\tif (zero_run < 2) {\n\t\t\tif (*src == 0)\n\t\t\t\t++zero_run;\n\t\t\telse\n\t\t\t\tzero_run = 0;\n\t\t} else {\n\t\t\tif ((*src & ~0x03) == 0)\n\t\t\t\t*dst++ = 0x03;\n\t\t\tzero_run = *src == 0;\n\t\t}\n\t\t*dst++ = *src;\n\t}\n\n\tvb2_set_plane_payload(&vb->vb.vb2_buf, 0,\n\t\t\t      dst - (u8 *)vb2_plane_vaddr(&vb->vb.vb2_buf, 0));\n\n\tvb->vb.vb2_buf.timestamp = frame->timestamp;\n\tv4l2_buf->field = V4L2_FIELD_INTERLACED;\n\tv4l2_buf->sequence = frame->seqno;\n\n\t/* Check for motion flags */\n\tif (frame->gop_seqno /* P-frame */ &&\n\t    tw5864_is_motion_triggered(frame)) {\n\t\tstruct v4l2_event ev = {\n\t\t\t.type = V4L2_EVENT_MOTION_DET,\n\t\t\t.u.motion_det = {\n\t\t\t\t.flags = V4L2_EVENT_MD_FL_HAVE_FRAME_SEQ,\n\t\t\t\t.frame_sequence = v4l2_buf->sequence,\n\t\t\t},\n\t\t};\n\n\t\tv4l2_event_queue(&input->vdev, &ev);\n\t}\n\n\tvb2_buffer_done(&vb->vb.vb2_buf, VB2_BUF_STATE_DONE);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 1403,
    "critical_vars": [
      "v4l2_buf"
    ],
    "function": "tw5864_handle_frame",
    "filename": "linux/CVE-2019-20806/CVE-2019-20806_CWE-476_2e7682ebfc750177a4944eeb56e97a3f05734528_tw5864-video.c.diff",
    "function_code": "static void tw5864_handle_frame(struct tw5864_h264_frame *frame)\n{\n#define SKIP_VLCBUF_BYTES 3\n\tstruct tw5864_input *input = frame->input;\n\tstruct tw5864_dev *dev = input->root;\n\tstruct tw5864_buf *vb;\n\tstruct vb2_v4l2_buffer *v4l2_buf;\n\tint frame_len = frame->vlc_len - SKIP_VLCBUF_BYTES;\n\tu8 *dst = input->buf_cur_ptr;\n\tu8 tail_mask, vlc_mask = 0;\n\tint i;\n\tu8 vlc_first_byte = ((u8 *)(frame->vlc.addr + SKIP_VLCBUF_BYTES))[0];\n\tunsigned long flags;\n\tint zero_run;\n\tu8 *src;\n\tu8 *src_end;\n\n#ifdef DEBUG\n\tif (frame->checksum !=\n\t    tw5864_vlc_checksum((u32 *)frame->vlc.addr, frame_len))\n\t\tdev_err(&dev->pci->dev,\n\t\t\t\"Checksum of encoded frame doesn't match!\\n\");\n#endif\n\n\tspin_lock_irqsave(&input->slock, flags);\n\tvb = input->vb;\n\tinput->vb = NULL;\n\tspin_unlock_irqrestore(&input->slock, flags);\n\n\tif (!vb) { /* Gone because of disabling */\n\t\tdev_dbg(&dev->pci->dev, \"vb is empty, dropping frame\\n\");\n\t\treturn;\n\t}\n\n\tv4l2_buf = to_vb2_v4l2_buffer(&vb->vb.vb2_buf);\n\n\t/*\n\t * Check for space.\n\t * Mind the overhead of startcode emulation prevention.\n\t */\n\tif (input->buf_cur_space_left < frame_len * 5 / 4) {\n\t\tdev_err_once(&dev->pci->dev,\n\t\t\t     \"Left space in vb2 buffer, %d bytes, is less than considered safely enough to put frame of length %d. Dropping this frame.\\n\",\n\t\t\t     input->buf_cur_space_left, frame_len);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 8 - input->tail_nb_bits; i++)\n\t\tvlc_mask |= 1 << i;\n\ttail_mask = (~vlc_mask) & 0xff;\n\n\tdst[0] = (input->tail & tail_mask) | (vlc_first_byte & vlc_mask);\n\tframe_len--;\n\tdst++;\n\n\t/* H.264 startcode emulation prevention */\n\tsrc = frame->vlc.addr + SKIP_VLCBUF_BYTES + 1;\n\tsrc_end = src + frame_len;\n\tzero_run = 0;\n\tfor (; src < src_end; src++) {\n\t\tif (zero_run < 2) {\n\t\t\tif (*src == 0)\n\t\t\t\t++zero_run;\n\t\t\telse\n\t\t\t\tzero_run = 0;\n\t\t} else {\n\t\t\tif ((*src & ~0x03) == 0)\n\t\t\t\t*dst++ = 0x03;\n\t\t\tzero_run = *src == 0;\n\t\t}\n\t\t*dst++ = *src;\n\t}\n\n\tvb2_set_plane_payload(&vb->vb.vb2_buf, 0,\n\t\t\t      dst - (u8 *)vb2_plane_vaddr(&vb->vb.vb2_buf, 0));\n\n\tvb->vb.vb2_buf.timestamp = frame->timestamp;\n\tv4l2_buf->field = V4L2_FIELD_INTERLACED;\n\tv4l2_buf->sequence = frame->seqno;\n\n\t/* Check for motion flags */\n\tif (frame->gop_seqno /* P-frame */ &&\n\t    tw5864_is_motion_triggered(frame)) {\n\t\tstruct v4l2_event ev = {\n\t\t\t.type = V4L2_EVENT_MOTION_DET,\n\t\t\t.u.motion_det = {\n\t\t\t\t.flags = V4L2_EVENT_MD_FL_HAVE_FRAME_SEQ,\n\t\t\t\t.frame_sequence = v4l2_buf->sequence,\n\t\t\t},\n\t\t};\n\n\t\tv4l2_event_queue(&input->vdev, &ev);\n\t}\n\n\tvb2_buffer_done(&vb->vb.vb2_buf, VB2_BUF_STATE_DONE);\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 86,
    "line_new": 54,
    "critical_vars": [
      "err"
    ],
    "function": "crypto_rng_reset",
    "filename": "linux/CVE-2017-15116/CVE-2017-15116_CWE-476_94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6_rng.c.diff",
    "function_code": "int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)\n{\n\tu8 *buf = NULL;\n\tint err;\n\n\tif (!seed && slen) {\n\t\tbuf = kmalloc(slen, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\n\t\tget_random_bytes(buf, slen);\n\t\tseed = buf;\n\t}\n\n\terr = crypto_rng_alg(tfm)->seed(tfm, seed, slen);\n\n\tkfree(buf);\n\treturn err;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 149,
    "critical_vars": [
      "*ipimap"
    ],
    "function": "jfs_evict_inode",
    "filename": "linux/CVE-2022-3202/CVE-2022-3202_CWE-476_a53046291020ec41e09181396c1e829287b48d47_inode.c.diff",
    "function_code": "void jfs_evict_inode(struct inode *inode)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(inode);\n\n\tjfs_info(\"In jfs_evict_inode, inode = 0x%p\", inode);\n\n\tif (!inode->i_nlink && !is_bad_inode(inode)) {\n\t\tdquot_initialize(inode);\n\n\t\tif (JFS_IP(inode)->fileset == FILESYSTEM_I) {\n\t\t\tstruct inode *ipimap = JFS_SBI(inode->i_sb)->ipimap;\n\t\t\ttruncate_inode_pages_final(&inode->i_data);\n\n\t\t\tif (test_cflag(COMMIT_Freewmap, inode))\n\t\t\t\tjfs_free_zero_link(inode);\n\n\t\t\tif (ipimap && JFS_IP(ipimap)->i_imap)\n\t\t\t\tdiFree(inode);\n\n\t\t\t/*\n\t\t\t * Free the inode from the quota allocation.\n\t\t\t */\n\t\t\tdquot_free_inode(inode);\n\t\t}\n\t} else {\n\t\ttruncate_inode_pages_final(&inode->i_data);\n\t}\n\tclear_inode(inode);\n\tdquot_drop(inode);\n\n\tBUG_ON(!list_empty(&ji->anon_inode_list));\n\n\tspin_lock_irq(&ji->ag_lock);\n\tif (ji->active_ag != -1) {\n\t\tstruct bmap *bmap = JFS_SBI(inode->i_sb)->bmap;\n\t\tatomic_dec(&bmap->db_active[ji->active_ag]);\n\t\tji->active_ag = -1;\n\t}\n\tspin_unlock_irq(&ji->ag_lock);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 154,
    "critical_vars": [
      "inode->i_sb"
    ],
    "function": "jfs_evict_inode",
    "filename": "linux/CVE-2022-3202/CVE-2022-3202_CWE-476_a53046291020ec41e09181396c1e829287b48d47_inode.c.diff",
    "function_code": "void jfs_evict_inode(struct inode *inode)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(inode);\n\n\tjfs_info(\"In jfs_evict_inode, inode = 0x%p\", inode);\n\n\tif (!inode->i_nlink && !is_bad_inode(inode)) {\n\t\tdquot_initialize(inode);\n\n\t\tif (JFS_IP(inode)->fileset == FILESYSTEM_I) {\n\t\t\ttruncate_inode_pages_final(&inode->i_data);\n\n\t\t\tif (test_cflag(COMMIT_Freewmap, inode))\n\t\t\t\tjfs_free_zero_link(inode);\n\n\t\t\tif (JFS_SBI(inode->i_sb)->ipimap)\n\t\t\t\tdiFree(inode);\n\n\t\t\t/*\n\t\t\t * Free the inode from the quota allocation.\n\t\t\t */\n\t\t\tdquot_free_inode(inode);\n\t\t}\n\t} else {\n\t\ttruncate_inode_pages_final(&inode->i_data);\n\t}\n\tclear_inode(inode);\n\tdquot_drop(inode);\n\n\tBUG_ON(!list_empty(&ji->anon_inode_list));\n\n\tspin_lock_irq(&ji->ag_lock);\n\tif (ji->active_ag != -1) {\n\t\tstruct bmap *bmap = JFS_SBI(inode->i_sb)->bmap;\n\t\tatomic_dec(&bmap->db_active[ji->active_ag]);\n\t\tji->active_ag = -1;\n\t}\n\tspin_unlock_irq(&ji->ag_lock);\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 794,
    "critical_vars": [
      "error"
    ],
    "function": "xfs_attr_shortform_to_leaf",
    "filename": "linux/CVE-2018-13094/CVE-2018-13094_CWE-476_bb3d48dcf86a97dc25fe9fc2c11938e19cb4399a_xfs_attr_leaf.c.diff",
    "function_code": "xfs_attr_shortform_to_leaf(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t**leaf_bp)\n{\n\txfs_inode_t *dp;\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\txfs_da_args_t nargs;\n\tchar *tmpbuffer;\n\tint error, i, size;\n\txfs_dablk_t blkno;\n\tstruct xfs_buf *bp;\n\txfs_ifork_t *ifp;\n\n\ttrace_xfs_attr_sf_to_leaf(args);\n\n\tdp = args->dp;\n\tifp = dp->i_afp;\n\tsf = (xfs_attr_shortform_t *)ifp->if_u1.if_data;\n\tsize = be16_to_cpu(sf->hdr.totsize);\n\ttmpbuffer = kmem_alloc(size, KM_SLEEP);\n\tASSERT(tmpbuffer != NULL);\n\tmemcpy(tmpbuffer, ifp->if_u1.if_data, size);\n\tsf = (xfs_attr_shortform_t *)tmpbuffer;\n\n\txfs_idata_realloc(dp, -size, XFS_ATTR_FORK);\n\txfs_bmap_local_to_extents_empty(dp, XFS_ATTR_FORK);\n\n\tbp = NULL;\n\terror = xfs_da_grow_inode(args, &blkno);\n\tif (error) {\n\t\t/*\n\t\t * If we hit an IO error middle of the transaction inside\n\t\t * grow_inode(), we may have inconsistent data. Bail out.\n\t\t */\n\t\tif (error == -EIO)\n\t\t\tgoto out;\n\t\txfs_idata_realloc(dp, size, XFS_ATTR_FORK);\t/* try to put */\n\t\tmemcpy(ifp->if_u1.if_data, tmpbuffer, size);\t/* it back */\n\t\tgoto out;\n\t}\n\n\tASSERT(blkno == 0);\n\terror = xfs_attr3_leaf_create(args, blkno, &bp);\n\tif (error) {\n\t\terror = xfs_da_shrink_inode(args, 0, bp);\n\t\tbp = NULL;\n\t\tif (error)\n\t\t\tgoto out;\n\t\txfs_idata_realloc(dp, size, XFS_ATTR_FORK);\t/* try to put */\n\t\tmemcpy(ifp->if_u1.if_data, tmpbuffer, size);\t/* it back */\n\t\tgoto out;\n\t}\n\n\tmemset((char *)&nargs, 0, sizeof(nargs));\n\tnargs.dp = dp;\n\tnargs.geo = args->geo;\n\tnargs.firstblock = args->firstblock;\n\tnargs.dfops = args->dfops;\n\tnargs.total = args->total;\n\tnargs.whichfork = XFS_ATTR_FORK;\n\tnargs.trans = args->trans;\n\tnargs.op_flags = XFS_DA_OP_OKNOENT;\n\n\tsfe = &sf->list[0];\n\tfor (i = 0; i < sf->hdr.count; i++) {\n\t\tnargs.name = sfe->nameval;\n\t\tnargs.namelen = sfe->namelen;\n\t\tnargs.value = &sfe->nameval[nargs.namelen];\n\t\tnargs.valuelen = sfe->valuelen;\n\t\tnargs.hashval = xfs_da_hashname(sfe->nameval,\n\t\t\t\t\t\tsfe->namelen);\n\t\tnargs.flags = XFS_ATTR_NSP_ONDISK_TO_ARGS(sfe->flags);\n\t\terror = xfs_attr3_leaf_lookup_int(bp, &nargs); /* set a->index */\n\t\tASSERT(error == -ENOATTR);\n\t\terror = xfs_attr3_leaf_add(bp, &nargs);\n\t\tASSERT(error != -ENOSPC);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe);\n\t}\n\terror = 0;\n\t*leaf_bp = bp;\nout:\n\tkmem_free(tmpbuffer);\n\treturn error;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 795,
    "critical_vars": [
      "args",
      "bp"
    ],
    "function": "xfs_attr_shortform_to_leaf",
    "filename": "linux/CVE-2018-13094/CVE-2018-13094_CWE-476_bb3d48dcf86a97dc25fe9fc2c11938e19cb4399a_xfs_attr_leaf.c.diff",
    "function_code": "xfs_attr_shortform_to_leaf(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t**leaf_bp)\n{\n\txfs_inode_t *dp;\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\txfs_da_args_t nargs;\n\tchar *tmpbuffer;\n\tint error, i, size;\n\txfs_dablk_t blkno;\n\tstruct xfs_buf *bp;\n\txfs_ifork_t *ifp;\n\n\ttrace_xfs_attr_sf_to_leaf(args);\n\n\tdp = args->dp;\n\tifp = dp->i_afp;\n\tsf = (xfs_attr_shortform_t *)ifp->if_u1.if_data;\n\tsize = be16_to_cpu(sf->hdr.totsize);\n\ttmpbuffer = kmem_alloc(size, KM_SLEEP);\n\tASSERT(tmpbuffer != NULL);\n\tmemcpy(tmpbuffer, ifp->if_u1.if_data, size);\n\tsf = (xfs_attr_shortform_t *)tmpbuffer;\n\n\txfs_idata_realloc(dp, -size, XFS_ATTR_FORK);\n\txfs_bmap_local_to_extents_empty(dp, XFS_ATTR_FORK);\n\n\tbp = NULL;\n\terror = xfs_da_grow_inode(args, &blkno);\n\tif (error) {\n\t\t/*\n\t\t * If we hit an IO error middle of the transaction inside\n\t\t * grow_inode(), we may have inconsistent data. Bail out.\n\t\t */\n\t\tif (error == -EIO)\n\t\t\tgoto out;\n\t\txfs_idata_realloc(dp, size, XFS_ATTR_FORK);\t/* try to put */\n\t\tmemcpy(ifp->if_u1.if_data, tmpbuffer, size);\t/* it back */\n\t\tgoto out;\n\t}\n\n\tASSERT(blkno == 0);\n\terror = xfs_attr3_leaf_create(args, blkno, &bp);\n\tif (error) {\n\t\t/* xfs_attr3_leaf_create may not have instantiated a block */\n\t\tif (bp && (xfs_da_shrink_inode(args, 0, bp) != 0))\n\t\t\tgoto out;\n\t\txfs_idata_realloc(dp, size, XFS_ATTR_FORK);\t/* try to put */\n\t\tmemcpy(ifp->if_u1.if_data, tmpbuffer, size);\t/* it back */\n\t\tgoto out;\n\t}\n\n\tmemset((char *)&nargs, 0, sizeof(nargs));\n\tnargs.dp = dp;\n\tnargs.geo = args->geo;\n\tnargs.firstblock = args->firstblock;\n\tnargs.dfops = args->dfops;\n\tnargs.total = args->total;\n\tnargs.whichfork = XFS_ATTR_FORK;\n\tnargs.trans = args->trans;\n\tnargs.op_flags = XFS_DA_OP_OKNOENT;\n\n\tsfe = &sf->list[0];\n\tfor (i = 0; i < sf->hdr.count; i++) {\n\t\tnargs.name = sfe->nameval;\n\t\tnargs.namelen = sfe->namelen;\n\t\tnargs.value = &sfe->nameval[nargs.namelen];\n\t\tnargs.valuelen = sfe->valuelen;\n\t\tnargs.hashval = xfs_da_hashname(sfe->nameval,\n\t\t\t\t\t\tsfe->namelen);\n\t\tnargs.flags = XFS_ATTR_NSP_ONDISK_TO_ARGS(sfe->flags);\n\t\terror = xfs_attr3_leaf_lookup_int(bp, &nargs); /* set a->index */\n\t\tASSERT(error == -ENOATTR);\n\t\terror = xfs_attr3_leaf_add(bp, &nargs);\n\t\tASSERT(error != -ENOSPC);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe);\n\t}\n\terror = 0;\n\t*leaf_bp = bp;\nout:\n\tkmem_free(tmpbuffer);\n\treturn error;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 317,
    "critical_vars": [
      "disk"
    ],
    "function": "pcd_init_units",
    "filename": "linux/CVE-2019-15923/CVE-2019-15923_CWE-476_f0d1762554014ce0ae347b9f0d088f2c157c8c72_pcd.c.diff",
    "function_code": "static void pcd_init_units(void)\n{\n\tstruct pcd_unit *cd;\n\tint unit;\n\n\tpcd_drive_count = 0;\n\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\tstruct gendisk *disk = alloc_disk(1);\n\n\t\tif (!disk)\n\t\t\tcontinue;\n\n\t\tdisk->queue = blk_mq_init_sq_queue(&cd->tag_set, &pcd_mq_ops,\n\t\t\t\t\t\t   1, BLK_MQ_F_SHOULD_MERGE);\n\t\tif (IS_ERR(disk->queue)) {\n\t\t\tput_disk(disk);\n\t\t\tdisk->queue = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tINIT_LIST_HEAD(&cd->rq_list);\n\t\tdisk->queue->queuedata = cd;\n\t\tblk_queue_bounce_limit(disk->queue, BLK_BOUNCE_HIGH);\n\t\tcd->disk = disk;\n\t\tcd->pi = &cd->pia;\n\t\tcd->present = 0;\n\t\tcd->last_sense = 0;\n\t\tcd->changed = 1;\n\t\tcd->drive = (*drives[unit])[D_SLV];\n\t\tif ((*drives[unit])[D_PRT])\n\t\t\tpcd_drive_count++;\n\n\t\tcd->name = &cd->info.name[0];\n\t\tsnprintf(cd->name, sizeof(cd->info.name), \"%s%d\", name, unit);\n\t\tcd->info.ops = &pcd_dops;\n\t\tcd->info.handle = cd;\n\t\tcd->info.speed = 0;\n\t\tcd->info.capacity = 1;\n\t\tcd->info.mask = 0;\n\t\tdisk->major = major;\n\t\tdisk->first_minor = unit;\n\t\tstrcpy(disk->disk_name, cd->name);\t/* umm... */\n\t\tdisk->fops = &pcd_bdops;\n\t\tdisk->flags = GENHD_FL_BLOCK_EVENTS_ON_EXCL_WRITE;\n\t}\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 754,
    "critical_vars": [
      "cd->disk"
    ],
    "function": "pcd_detect",
    "filename": "linux/CVE-2019-15923/CVE-2019-15923_CWE-476_f0d1762554014ce0ae347b9f0d088f2c157c8c72_pcd.c.diff",
    "function_code": "static int pcd_detect(void)\n{\n\tchar id[18];\n\tint k, unit;\n\tstruct pcd_unit *cd;\n\n\tprintk(\"%s: %s version %s, major %d, nice %d\\n\",\n\t       name, name, PCD_VERSION, major, nice);\n\n\tpar_drv = pi_register_driver(name);\n\tif (!par_drv) {\n\t\tpr_err(\"failed to register %s driver\\n\", name);\n\t\treturn -1;\n\t}\n\n\tk = 0;\n\tif (pcd_drive_count == 0) { /* nothing spec'd - so autoprobe for 1 */\n\t\tcd = pcd;\n\t\tif (pi_init(cd->pi, 1, -1, -1, -1, -1, -1, pcd_buffer,\n\t\t\t    PI_PCD, verbose, cd->name)) {\n\t\t\tif (!pcd_probe(cd, -1, id) && cd->disk) {\n\t\t\t\tcd->present = 1;\n\t\t\t\tk++;\n\t\t\t} else\n\t\t\t\tpi_release(cd->pi);\n\t\t}\n\t} else {\n\t\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\t\tint *conf = *drives[unit];\n\t\t\tif (!conf[D_PRT])\n\t\t\t\tcontinue;\n\t\t\tif (!pi_init(cd->pi, 0, conf[D_PRT], conf[D_MOD],\n\t\t\t\t     conf[D_UNI], conf[D_PRO], conf[D_DLY],\n\t\t\t\t     pcd_buffer, PI_PCD, verbose, cd->name)) \n\t\t\t\tcontinue;\n\t\t\tif (!pcd_probe(cd, conf[D_SLV], id) && cd->disk) {\n\t\t\t\tcd->present = 1;\n\t\t\t\tk++;\n\t\t\t} else\n\t\t\t\tpi_release(cd->pi);\n\t\t}\n\t}\n\tif (k)\n\t\treturn 0;\n\n\tprintk(\"%s: No CD-ROM drive found\\n\", name);\n\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\tif (!cd->disk)\n\t\t\tcontinue;\n\t\tblk_cleanup_queue(cd->disk->queue);\n\t\tcd->disk->queue = NULL;\n\t\tblk_mq_free_tag_set(&cd->tag_set);\n\t\tput_disk(cd->disk);\n\t}\n\tpi_unregister_driver(par_drv);\n\treturn -1;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1017,
    "critical_vars": [
      "cd->disk"
    ],
    "function": "pcd_init",
    "filename": "linux/CVE-2019-15923/CVE-2019-15923_CWE-476_f0d1762554014ce0ae347b9f0d088f2c157c8c72_pcd.c.diff",
    "function_code": "static int __init pcd_init(void)\n{\n\tstruct pcd_unit *cd;\n\tint unit;\n\n\tif (disable)\n\t\treturn -EINVAL;\n\n\tpcd_init_units();\n\n\tif (pcd_detect())\n\t\treturn -ENODEV;\n\n\t/* get the atapi capabilities page */\n\tpcd_probe_capabilities();\n\n\tif (register_blkdev(major, name)) {\n\t\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\t\tif (!cd->disk)\n\t\t\t\tcontinue;\n\n\t\t\tblk_cleanup_queue(cd->disk->queue);\n\t\t\tblk_mq_free_tag_set(&cd->tag_set);\n\t\t\tput_disk(cd->disk);\n\t\t}\n\t\treturn -EBUSY;\n\t}\n\n\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\tif (cd->present) {\n\t\t\tregister_cdrom(&cd->info);\n\t\t\tcd->disk->private_data = cd;\n\t\t\tadd_disk(cd->disk);\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1044,
    "critical_vars": [
      "cd->disk"
    ],
    "function": "pcd_exit",
    "filename": "linux/CVE-2019-15923/CVE-2019-15923_CWE-476_f0d1762554014ce0ae347b9f0d088f2c157c8c72_pcd.c.diff",
    "function_code": "static void __exit pcd_exit(void)\n{\n\tstruct pcd_unit *cd;\n\tint unit;\n\n\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\tif (!cd->disk)\n\t\t\tcontinue;\n\n\t\tif (cd->present) {\n\t\t\tdel_gendisk(cd->disk);\n\t\t\tpi_release(cd->pi);\n\t\t\tunregister_cdrom(&cd->info);\n\t\t}\n\t\tblk_cleanup_queue(cd->disk->queue);\n\t\tblk_mq_free_tag_set(&cd->tag_set);\n\t\tput_disk(cd->disk);\n\t}\n\tunregister_blkdev(major, name);\n\tpi_unregister_driver(par_drv);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 569,
    "critical_vars": [
      "sbi"
    ],
    "function": "create_flush_cmd_control",
    "filename": "linux/CVE-2017-18241/CVE-2017-18241_CWE-476_d4fdf8ba0e5808ba9ad6b44337783bd9935e0982_segment.c.diff",
    "function_code": "int create_flush_cmd_control(struct f2fs_sb_info *sbi)\n{\n\tdev_t dev = sbi->sb->s_bdev->bd_dev;\n\tstruct flush_cmd_control *fcc;\n\tint err = 0;\n\n\tif (SM_I(sbi)->fcc_info) {\n\t\tfcc = SM_I(sbi)->fcc_info;\n\t\tgoto init_thread;\n\t}\n\n\tfcc = kzalloc(sizeof(struct flush_cmd_control), GFP_KERNEL);\n\tif (!fcc)\n\t\treturn -ENOMEM;\n\tatomic_set(&fcc->issued_flush, 0);\n\tatomic_set(&fcc->issing_flush, 0);\n\tinit_waitqueue_head(&fcc->flush_wait_queue);\n\tinit_llist_head(&fcc->issue_list);\n\tSM_I(sbi)->fcc_info = fcc;\n\tif (!test_opt(sbi, FLUSH_MERGE))\n\t\treturn err;\n\ninit_thread:\n\tfcc->f2fs_issue_flush = kthread_run(issue_flush_thread, sbi,\n\t\t\t\t\"f2fs_flush-%u:%u\", MAJOR(dev), MINOR(dev));\n\tif (IS_ERR(fcc->f2fs_issue_flush)) {\n\t\terr = PTR_ERR(fcc->f2fs_issue_flush);\n\t\tkfree(fcc);\n\t\tSM_I(sbi)->fcc_info = NULL;\n\t\treturn err;\n\t}\n\n\treturn err;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 3243,
    "critical_vars": [
      "sbi"
    ],
    "function": "build_segment_manager",
    "filename": "linux/CVE-2017-18241/CVE-2017-18241_CWE-476_d4fdf8ba0e5808ba9ad6b44337783bd9935e0982_segment.c.diff",
    "function_code": "int build_segment_manager(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tstruct f2fs_sm_info *sm_info;\n\tint err;\n\n\tsm_info = kzalloc(sizeof(struct f2fs_sm_info), GFP_KERNEL);\n\tif (!sm_info)\n\t\treturn -ENOMEM;\n\n\t/* init sm info */\n\tsbi->sm_info = sm_info;\n\tsm_info->seg0_blkaddr = le32_to_cpu(raw_super->segment0_blkaddr);\n\tsm_info->main_blkaddr = le32_to_cpu(raw_super->main_blkaddr);\n\tsm_info->segment_count = le32_to_cpu(raw_super->segment_count);\n\tsm_info->reserved_segments = le32_to_cpu(ckpt->rsvd_segment_count);\n\tsm_info->ovp_segments = le32_to_cpu(ckpt->overprov_segment_count);\n\tsm_info->main_segments = le32_to_cpu(raw_super->segment_count_main);\n\tsm_info->ssa_blkaddr = le32_to_cpu(raw_super->ssa_blkaddr);\n\tsm_info->rec_prefree_segments = sm_info->main_segments *\n\t\t\t\t\tDEF_RECLAIM_PREFREE_SEGMENTS / 100;\n\tif (sm_info->rec_prefree_segments > DEF_MAX_RECLAIM_PREFREE_SEGMENTS)\n\t\tsm_info->rec_prefree_segments = DEF_MAX_RECLAIM_PREFREE_SEGMENTS;\n\n\tif (!test_opt(sbi, LFS))\n\t\tsm_info->ipu_policy = 1 << F2FS_IPU_FSYNC;\n\tsm_info->min_ipu_util = DEF_MIN_IPU_UTIL;\n\tsm_info->min_fsync_blocks = DEF_MIN_FSYNC_BLOCKS;\n\tsm_info->min_hot_blocks = DEF_MIN_HOT_BLOCKS;\n\n\tsm_info->trim_sections = DEF_BATCHED_TRIM_SECTIONS;\n\n\tINIT_LIST_HEAD(&sm_info->sit_entry_set);\n\n\tif (test_opt(sbi, FLUSH_MERGE) && !f2fs_readonly(sbi->sb)) {\n\t\terr = create_flush_cmd_control(sbi);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = create_discard_cmd_control(sbi);\n\tif (err)\n\t\treturn err;\n\n\terr = build_sit_info(sbi);\n\tif (err)\n\t\treturn err;\n\terr = build_free_segmap(sbi);\n\tif (err)\n\t\treturn err;\n\terr = build_curseg(sbi);\n\tif (err)\n\t\treturn err;\n\n\t/* reinit free segmap based on SIT */\n\tbuild_sit_entries(sbi);\n\n\tinit_free_segmap(sbi);\n\terr = build_dirty_segmap(sbi);\n\tif (err)\n\t\treturn err;\n\n\tinit_min_max_mtime(sbi);\n\treturn 0;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 185,
    "critical_vars": [
      "priv",
      "vma"
    ],
    "function": "m_stop",
    "filename": "linux/CVE-2011-3637/CVE-2011-3637_CWE-476_76597cd31470fa130784c78fadb4dab2e624a723_task_mmu.c.diff",
    "function_code": "static void m_stop(struct seq_file *m, void *v)\n{\n\tstruct proc_maps_private *priv = m->private;\n\tstruct vm_area_struct *vma = v;\n\n\tvma_stop(priv, vma);\n\tif (priv->task)\n\t\tput_task_struct(priv->task);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 185,
    "critical_vars": [
      "vma"
    ],
    "function": "m_stop",
    "filename": "linux/CVE-2011-3637/CVE-2011-3637_CWE-476_76597cd31470fa130784c78fadb4dab2e624a723_task_mmu.c.diff",
    "function_code": "static void m_stop(struct seq_file *m, void *v)\n{\n\tstruct proc_maps_private *priv = m->private;\n\tstruct vm_area_struct *vma = v;\n\n\tif (!IS_ERR(vma))\n\t\tvma_stop(priv, vma);\n\tif (priv->task)\n\t\tput_task_struct(priv->task);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1991,
    "critical_vars": [
      "interface",
      "os_desc_cfg->interface[interface]"
    ],
    "function": "composite_setup",
    "filename": "linux/CVE-2022-25258/CVE-2022-25258_CWE-476_75e5b4849b81e19e9efe1654b30d7f3151c33c2c_composite.c.diff",
    "function_code": "composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)\n{\n\tstruct usb_composite_dev\t*cdev = get_gadget_data(gadget);\n\tstruct usb_request\t\t*req = cdev->req;\n\tint\t\t\t\tvalue = -EOPNOTSUPP;\n\tint\t\t\t\tstatus = 0;\n\tu16\t\t\t\tw_index = le16_to_cpu(ctrl->wIndex);\n\tu8\t\t\t\tintf = w_index & 0xFF;\n\tu16\t\t\t\tw_value = le16_to_cpu(ctrl->wValue);\n\tu16\t\t\t\tw_length = le16_to_cpu(ctrl->wLength);\n\tstruct usb_function\t\t*f = NULL;\n\tu8\t\t\t\tendp;\n\n\tif (w_length > USB_COMP_EP0_BUFSIZ) {\n\t\tif (ctrl->bRequestType & USB_DIR_IN) {\n\t\t\t/* Cast away the const, we are going to overwrite on purpose. */\n\t\t\t__le16 *temp = (__le16 *)&ctrl->wLength;\n\n\t\t\t*temp = cpu_to_le16(USB_COMP_EP0_BUFSIZ);\n\t\t\tw_length = USB_COMP_EP0_BUFSIZ;\n\t\t} else {\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* partial re-init of the response message; the function or the\n\t * gadget might need to intercept e.g. a control-OUT completion\n\t * when we delegate to it.\n\t */\n\treq->zero = 0;\n\treq->context = cdev;\n\treq->complete = composite_setup_complete;\n\treq->length = 0;\n\tgadget->ep0->driver_data = cdev;\n\n\t/*\n\t * Don't let non-standard requests match any of the cases below\n\t * by accident.\n\t */\n\tif ((ctrl->bRequestType & USB_TYPE_MASK) != USB_TYPE_STANDARD)\n\t\tgoto unknown;\n\n\tswitch (ctrl->bRequest) {\n\n\t/* we handle all standard USB descriptors */\n\tcase USB_REQ_GET_DESCRIPTOR:\n\t\tif (ctrl->bRequestType != USB_DIR_IN)\n\t\t\tgoto unknown;\n\t\tswitch (w_value >> 8) {\n\n\t\tcase USB_DT_DEVICE:\n\t\t\tcdev->desc.bNumConfigurations =\n\t\t\t\tcount_configs(cdev, USB_DT_DEVICE);\n\t\t\tcdev->desc.bMaxPacketSize0 =\n\t\t\t\tcdev->gadget->ep0->maxpacket;\n\t\t\tif (gadget_is_superspeed(gadget)) {\n\t\t\t\tif (gadget->speed >= USB_SPEED_SUPER) {\n\t\t\t\t\tcdev->desc.bcdUSB = cpu_to_le16(0x0320);\n\t\t\t\t\tcdev->desc.bMaxPacketSize0 = 9;\n\t\t\t\t} else {\n\t\t\t\t\tcdev->desc.bcdUSB = cpu_to_le16(0x0210);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (gadget->lpm_capable)\n\t\t\t\t\tcdev->desc.bcdUSB = cpu_to_le16(0x0201);\n\t\t\t\telse\n\t\t\t\t\tcdev->desc.bcdUSB = cpu_to_le16(0x0200);\n\t\t\t}\n\n\t\t\tvalue = min(w_length, (u16) sizeof cdev->desc);\n\t\t\tmemcpy(req->buf, &cdev->desc, value);\n\t\t\tbreak;\n\t\tcase USB_DT_DEVICE_QUALIFIER:\n\t\t\tif (!gadget_is_dualspeed(gadget) ||\n\t\t\t    gadget->speed >= USB_SPEED_SUPER)\n\t\t\t\tbreak;\n\t\t\tdevice_qual(cdev);\n\t\t\tvalue = min_t(int, w_length,\n\t\t\t\tsizeof(struct usb_qualifier_descriptor));\n\t\t\tbreak;\n\t\tcase USB_DT_OTHER_SPEED_CONFIG:\n\t\t\tif (!gadget_is_dualspeed(gadget) ||\n\t\t\t    gadget->speed >= USB_SPEED_SUPER)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tcase USB_DT_CONFIG:\n\t\t\tvalue = config_desc(cdev, w_value);\n\t\t\tif (value >= 0)\n\t\t\t\tvalue = min(w_length, (u16) value);\n\t\t\tbreak;\n\t\tcase USB_DT_STRING:\n\t\t\tvalue = get_string(cdev, req->buf,\n\t\t\t\t\tw_index, w_value & 0xff);\n\t\t\tif (value >= 0)\n\t\t\t\tvalue = min(w_length, (u16) value);\n\t\t\tbreak;\n\t\tcase USB_DT_BOS:\n\t\t\tif (gadget_is_superspeed(gadget) ||\n\t\t\t    gadget->lpm_capable) {\n\t\t\t\tvalue = bos_desc(cdev);\n\t\t\t\tvalue = min(w_length, (u16) value);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase USB_DT_OTG:\n\t\t\tif (gadget_is_otg(gadget)) {\n\t\t\t\tstruct usb_configuration *config;\n\t\t\t\tint otg_desc_len = 0;\n\n\t\t\t\tif (cdev->config)\n\t\t\t\t\tconfig = cdev->config;\n\t\t\t\telse\n\t\t\t\t\tconfig = list_first_entry(\n\t\t\t\t\t\t\t&cdev->configs,\n\t\t\t\t\t\tstruct usb_configuration, list);\n\t\t\t\tif (!config)\n\t\t\t\t\tgoto done;\n\n\t\t\t\tif (gadget->otg_caps &&\n\t\t\t\t\t(gadget->otg_caps->otg_rev >= 0x0200))\n\t\t\t\t\totg_desc_len += sizeof(\n\t\t\t\t\t\tstruct usb_otg20_descriptor);\n\t\t\t\telse\n\t\t\t\t\totg_desc_len += sizeof(\n\t\t\t\t\t\tstruct usb_otg_descriptor);\n\n\t\t\t\tvalue = min_t(int, w_length, otg_desc_len);\n\t\t\t\tmemcpy(req->buf, config->descriptors[0], value);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\t/* any number of configs can work */\n\tcase USB_REQ_SET_CONFIGURATION:\n\t\tif (ctrl->bRequestType != 0)\n\t\t\tgoto unknown;\n\t\tif (gadget_is_otg(gadget)) {\n\t\t\tif (gadget->a_hnp_support)\n\t\t\t\tDBG(cdev, \"HNP available\\n\");\n\t\t\telse if (gadget->a_alt_hnp_support)\n\t\t\t\tDBG(cdev, \"HNP on another port\\n\");\n\t\t\telse\n\t\t\t\tVDBG(cdev, \"HNP inactive\\n\");\n\t\t}\n\t\tspin_lock(&cdev->lock);\n\t\tvalue = set_config(cdev, ctrl, w_value);\n\t\tspin_unlock(&cdev->lock);\n\t\tbreak;\n\tcase USB_REQ_GET_CONFIGURATION:\n\t\tif (ctrl->bRequestType != USB_DIR_IN)\n\t\t\tgoto unknown;\n\t\tif (cdev->config)\n\t\t\t*(u8 *)req->buf = cdev->config->bConfigurationValue;\n\t\telse\n\t\t\t*(u8 *)req->buf = 0;\n\t\tvalue = min(w_length, (u16) 1);\n\t\tbreak;\n\n\t/* function drivers must handle get/set altsetting */\n\tcase USB_REQ_SET_INTERFACE:\n\t\tif (ctrl->bRequestType != USB_RECIP_INTERFACE)\n\t\t\tgoto unknown;\n\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\tbreak;\n\t\tf = cdev->config->interface[intf];\n\t\tif (!f)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * If there's no get_alt() method, we know only altsetting zero\n\t\t * works. There is no need to check if set_alt() is not NULL\n\t\t * as we check this in usb_add_function().\n\t\t */\n\t\tif (w_value && !f->get_alt)\n\t\t\tbreak;\n\n\t\tspin_lock(&cdev->lock);\n\t\tvalue = f->set_alt(f, w_index, w_value);\n\t\tif (value == USB_GADGET_DELAYED_STATUS) {\n\t\t\tDBG(cdev,\n\t\t\t \"%s: interface %d (%s) requested delayed status\\n\",\n\t\t\t\t\t__func__, intf, f->name);\n\t\t\tcdev->delayed_status++;\n\t\t\tDBG(cdev, \"delayed_status count %d\\n\",\n\t\t\t\t\tcdev->delayed_status);\n\t\t}\n\t\tspin_unlock(&cdev->lock);\n\t\tbreak;\n\tcase USB_REQ_GET_INTERFACE:\n\t\tif (ctrl->bRequestType != (USB_DIR_IN|USB_RECIP_INTERFACE))\n\t\t\tgoto unknown;\n\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\tbreak;\n\t\tf = cdev->config->interface[intf];\n\t\tif (!f)\n\t\t\tbreak;\n\t\t/* lots of interfaces only need altsetting zero... */\n\t\tvalue = f->get_alt ? f->get_alt(f, w_index) : 0;\n\t\tif (value < 0)\n\t\t\tbreak;\n\t\t*((u8 *)req->buf) = value;\n\t\tvalue = min(w_length, (u16) 1);\n\t\tbreak;\n\tcase USB_REQ_GET_STATUS:\n\t\tif (gadget_is_otg(gadget) && gadget->hnp_polling_support &&\n\t\t\t\t\t\t(w_index == OTG_STS_SELECTOR)) {\n\t\t\tif (ctrl->bRequestType != (USB_DIR_IN |\n\t\t\t\t\t\t\tUSB_RECIP_DEVICE))\n\t\t\t\tgoto unknown;\n\t\t\t*((u8 *)req->buf) = gadget->host_request_flag;\n\t\t\tvalue = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * USB 3.0 additions:\n\t\t * Function driver should handle get_status request. If such cb\n\t\t * wasn't supplied we respond with default value = 0\n\t\t * Note: function driver should supply such cb only for the\n\t\t * first interface of the function\n\t\t */\n\t\tif (!gadget_is_superspeed(gadget))\n\t\t\tgoto unknown;\n\t\tif (ctrl->bRequestType != (USB_DIR_IN | USB_RECIP_INTERFACE))\n\t\t\tgoto unknown;\n\t\tvalue = 2;\t/* This is the length of the get_status reply */\n\t\tput_unaligned_le16(0, req->buf);\n\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\tbreak;\n\t\tf = cdev->config->interface[intf];\n\t\tif (!f)\n\t\t\tbreak;\n\t\tstatus = f->get_status ? f->get_status(f) : 0;\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tput_unaligned_le16(status & 0x0000ffff, req->buf);\n\t\tbreak;\n\t/*\n\t * Function drivers should handle SetFeature/ClearFeature\n\t * (FUNCTION_SUSPEND) request. function_suspend cb should be supplied\n\t * only for the first interface of the function\n\t */\n\tcase USB_REQ_CLEAR_FEATURE:\n\tcase USB_REQ_SET_FEATURE:\n\t\tif (!gadget_is_superspeed(gadget))\n\t\t\tgoto unknown;\n\t\tif (ctrl->bRequestType != (USB_DIR_OUT | USB_RECIP_INTERFACE))\n\t\t\tgoto unknown;\n\t\tswitch (w_value) {\n\t\tcase USB_INTRF_FUNC_SUSPEND:\n\t\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\t\tbreak;\n\t\t\tf = cdev->config->interface[intf];\n\t\t\tif (!f)\n\t\t\t\tbreak;\n\t\t\tvalue = 0;\n\t\t\tif (f->func_suspend)\n\t\t\t\tvalue = f->func_suspend(f, w_index >> 8);\n\t\t\tif (value < 0) {\n\t\t\t\tERROR(cdev,\n\t\t\t\t      \"func_suspend() returned error %d\\n\",\n\t\t\t\t      value);\n\t\t\t\tvalue = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\nunknown:\n\t\t/*\n\t\t * OS descriptors handling\n\t\t */\n\t\tif (cdev->use_os_string && cdev->os_desc_config &&\n\t\t    (ctrl->bRequestType & USB_TYPE_VENDOR) &&\n\t\t    ctrl->bRequest == cdev->b_vendor_code) {\n\t\t\tstruct usb_configuration\t*os_desc_cfg;\n\t\t\tu8\t\t\t\t*buf;\n\t\t\tint\t\t\t\tinterface;\n\t\t\tint\t\t\t\tcount = 0;\n\n\t\t\treq = cdev->os_desc_req;\n\t\t\treq->context = cdev;\n\t\t\treq->complete = composite_setup_complete;\n\t\t\tbuf = req->buf;\n\t\t\tos_desc_cfg = cdev->os_desc_config;\n\t\t\tw_length = min_t(u16, w_length, USB_COMP_EP0_OS_DESC_BUFSIZ);\n\t\t\tmemset(buf, 0, w_length);\n\t\t\tbuf[5] = 0x01;\n\t\t\tswitch (ctrl->bRequestType & USB_RECIP_MASK) {\n\t\t\tcase USB_RECIP_DEVICE:\n\t\t\t\tif (w_index != 0x4 || (w_value >> 8))\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[6] = w_index;\n\t\t\t\t/* Number of ext compat interfaces */\n\t\t\t\tcount = count_ext_compat(os_desc_cfg);\n\t\t\t\tbuf[8] = count;\n\t\t\t\tcount *= 24; /* 24 B/ext compat desc */\n\t\t\t\tcount += 16; /* header */\n\t\t\t\tput_unaligned_le32(count, buf);\n\t\t\t\tvalue = w_length;\n\t\t\t\tif (w_length > 0x10) {\n\t\t\t\t\tvalue = fill_ext_compat(os_desc_cfg, buf);\n\t\t\t\t\tvalue = min_t(u16, w_length, value);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase USB_RECIP_INTERFACE:\n\t\t\t\tif (w_index != 0x5 || (w_value >> 8))\n\t\t\t\t\tbreak;\n\t\t\t\tinterface = w_value & 0xFF;\n\t\t\t\tif (interface >= MAX_CONFIG_INTERFACES ||\n\t\t\t\t    !os_desc_cfg->interface[interface])\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[6] = w_index;\n\t\t\t\tcount = count_ext_prop(os_desc_cfg,\n\t\t\t\t\tinterface);\n\t\t\t\tput_unaligned_le16(count, buf + 8);\n\t\t\t\tcount = len_ext_prop(os_desc_cfg,\n\t\t\t\t\tinterface);\n\t\t\t\tput_unaligned_le32(count, buf);\n\t\t\t\tvalue = w_length;\n\t\t\t\tif (w_length > 0x0A) {\n\t\t\t\t\tvalue = fill_ext_prop(os_desc_cfg,\n\t\t\t\t\t\t\t      interface, buf);\n\t\t\t\t\tif (value >= 0)\n\t\t\t\t\t\tvalue = min_t(u16, w_length, value);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tgoto check_value;\n\t\t}\n\n\t\tVDBG(cdev,\n\t\t\t\"non-core control req%02x.%02x v%04x i%04x l%d\\n\",\n\t\t\tctrl->bRequestType, ctrl->bRequest,\n\t\t\tw_value, w_index, w_length);\n\n\t\t/* functions always handle their interfaces and endpoints...\n\t\t * punt other recipients (other, WUSB, ...) to the current\n\t\t * configuration code.\n\t\t */\n\t\tif (cdev->config) {\n\t\t\tlist_for_each_entry(f, &cdev->config->functions, list)\n\t\t\t\tif (f->req_match &&\n\t\t\t\t    f->req_match(f, ctrl, false))\n\t\t\t\t\tgoto try_fun_setup;\n\t\t} else {\n\t\t\tstruct usb_configuration *c;\n\t\t\tlist_for_each_entry(c, &cdev->configs, list)\n\t\t\t\tlist_for_each_entry(f, &c->functions, list)\n\t\t\t\t\tif (f->req_match &&\n\t\t\t\t\t    f->req_match(f, ctrl, true))\n\t\t\t\t\t\tgoto try_fun_setup;\n\t\t}\n\t\tf = NULL;\n\n\t\tswitch (ctrl->bRequestType & USB_RECIP_MASK) {\n\t\tcase USB_RECIP_INTERFACE:\n\t\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\t\tbreak;\n\t\t\tf = cdev->config->interface[intf];\n\t\t\tbreak;\n\n\t\tcase USB_RECIP_ENDPOINT:\n\t\t\tif (!cdev->config)\n\t\t\t\tbreak;\n\t\t\tendp = ((w_index & 0x80) >> 3) | (w_index & 0x0f);\n\t\t\tlist_for_each_entry(f, &cdev->config->functions, list) {\n\t\t\t\tif (test_bit(endp, f->endpoints))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (&f->list == &cdev->config->functions)\n\t\t\t\tf = NULL;\n\t\t\tbreak;\n\t\t}\ntry_fun_setup:\n\t\tif (f && f->setup)\n\t\t\tvalue = f->setup(f, ctrl);\n\t\telse {\n\t\t\tstruct usb_configuration\t*c;\n\n\t\t\tc = cdev->config;\n\t\t\tif (!c)\n\t\t\t\tgoto done;\n\n\t\t\t/* try current config's setup */\n\t\t\tif (c->setup) {\n\t\t\t\tvalue = c->setup(c, ctrl);\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\t/* try the only function in the current config */\n\t\t\tif (!list_is_singular(&c->functions))\n\t\t\t\tgoto done;\n\t\t\tf = list_first_entry(&c->functions, struct usb_function,\n\t\t\t\t\t     list);\n\t\t\tif (f->setup)\n\t\t\t\tvalue = f->setup(f, ctrl);\n\t\t}\n\n\t\tgoto done;\n\t}\n\ncheck_value:\n\t/* respond with data transfer before status phase? */\n\tif (value >= 0 && value != USB_GADGET_DELAYED_STATUS) {\n\t\treq->length = value;\n\t\treq->context = cdev;\n\t\treq->zero = value < w_length;\n\t\tvalue = composite_ep0_queue(cdev, req, GFP_ATOMIC);\n\t\tif (value < 0) {\n\t\t\tDBG(cdev, \"ep_queue --> %d\\n\", value);\n\t\t\treq->status = 0;\n\t\t\tcomposite_setup_complete(gadget->ep0, req);\n\t\t}\n\t} else if (value == USB_GADGET_DELAYED_STATUS && w_length != 0) {\n\t\tWARN(cdev,\n\t\t\t\"%s: Delayed status not supported for w_length != 0\",\n\t\t\t__func__);\n\t}\n\ndone:\n\t/* device either stalls (value < 0) or reports success */\n\treturn value;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 156,
    "critical_vars": [
      "&trans->list"
    ],
    "function": "*nft_trans_alloc_gfp",
    "filename": "linux/CVE-2023-1095/CVE-2023-1095_CWE-476_580077855a40741cf511766129702d97ff02f4d9_nf_tables_api.c.diff",
    "function_code": "static struct nft_trans *nft_trans_alloc_gfp(const struct nft_ctx *ctx,\n\t\t\t\t\t     int msg_type, u32 size, gfp_t gfp)\n{\n\tstruct nft_trans *trans;\n\n\ttrans = kzalloc(sizeof(struct nft_trans) + size, gfp);\n\tif (trans == NULL)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&trans->list);\n\ttrans->msg_type = msg_type;\n\ttrans->ctx\t= *ctx;\n\n\treturn trans;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 492,
    "critical_vars": [
      "flags"
    ],
    "function": "xfs_iget_cache_miss",
    "filename": "linux/CVE-2018-13093/CVE-2018-13093_CWE-476_afca6c5b2595fc44383919fba740c194b0b76aff_xfs_icache.c.diff",
    "function_code": "xfs_iget_cache_miss(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag,\n\txfs_trans_t\t\t*tp,\n\txfs_ino_t\t\tino,\n\tstruct xfs_inode\t**ipp,\n\tint\t\t\tflags,\n\tint\t\t\tlock_flags)\n{\n\tstruct xfs_inode\t*ip;\n\tint\t\t\terror;\n\txfs_agino_t\t\tagino = XFS_INO_TO_AGINO(mp, ino);\n\tint\t\t\tiflags;\n\n\tip = xfs_inode_alloc(mp, ino);\n\tif (!ip)\n\t\treturn -ENOMEM;\n\n\terror = xfs_iread(mp, tp, ip, flags);\n\tif (error)\n\t\tgoto out_destroy;\n\n\tif (!xfs_inode_verify_forks(ip)) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_destroy;\n\t}\n\n\ttrace_xfs_iget_miss(ip);\n\n\n\t/*\n\t * If we are allocating a new inode, then check what was returned is\n\t * actually a free, empty inode. If we are not allocating an inode,\n\t * the check we didn't find a free inode.\n\t */\n\tif (flags & XFS_IGET_CREATE) {\n\t\tif (VFS_I(ip)->i_mode != 0) {\n\t\t\txfs_warn(mp,\n\"Corruption detected! Free inode 0x%llx not marked free on disk\",\n\t\t\t\tino);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto out_destroy;\n\t\t}\n\t\tif (ip->i_d.di_nblocks != 0) {\n\t\t\txfs_warn(mp,\n\"Corruption detected! Free inode 0x%llx has blocks allocated!\",\n\t\t\t\tino);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto out_destroy;\n\t\t}\n\t} else if (VFS_I(ip)->i_mode == 0) {\n\t\terror = -ENOENT;\n\t\tgoto out_destroy;\n\t}\n\n\t/*\n\t * Preload the radix tree so we can insert safely under the\n\t * write spinlock. Note that we cannot sleep inside the preload\n\t * region. Since we can be called from transaction context, don't\n\t * recurse into the file system.\n\t */\n\tif (radix_tree_preload(GFP_NOFS)) {\n\t\terror = -EAGAIN;\n\t\tgoto out_destroy;\n\t}\n\n\t/*\n\t * Because the inode hasn't been added to the radix-tree yet it can't\n\t * be found by another thread, so we can do the non-sleeping lock here.\n\t */\n\tif (lock_flags) {\n\t\tif (!xfs_ilock_nowait(ip, lock_flags))\n\t\t\tBUG();\n\t}\n\n\t/*\n\t * These values must be set before inserting the inode into the radix\n\t * tree as the moment it is inserted a concurrent lookup (allowed by the\n\t * RCU locking mechanism) can find it and that lookup must see that this\n\t * is an inode currently under construction (i.e. that XFS_INEW is set).\n\t * The ip->i_flags_lock that protects the XFS_INEW flag forms the\n\t * memory barrier that ensures this detection works correctly at lookup\n\t * time.\n\t */\n\tiflags = XFS_INEW;\n\tif (flags & XFS_IGET_DONTCACHE)\n\t\tiflags |= XFS_IDONTCACHE;\n\tip->i_udquot = NULL;\n\tip->i_gdquot = NULL;\n\tip->i_pdquot = NULL;\n\txfs_iflags_set(ip, iflags);\n\n\t/* insert the new inode */\n\tspin_lock(&pag->pag_ici_lock);\n\terror = radix_tree_insert(&pag->pag_ici_root, agino, ip);\n\tif (unlikely(error)) {\n\t\tWARN_ON(error != -EEXIST);\n\t\tXFS_STATS_INC(mp, xs_ig_dup);\n\t\terror = -EAGAIN;\n\t\tgoto out_preload_end;\n\t}\n\tspin_unlock(&pag->pag_ici_lock);\n\tradix_tree_preload_end();\n\n\t*ipp = ip;\n\treturn 0;\n\nout_preload_end:\n\tspin_unlock(&pag->pag_ici_lock);\n\tradix_tree_preload_end();\n\tif (lock_flags)\n\t\txfs_iunlock(ip, lock_flags);\nout_destroy:\n\t__destroy_inode(VFS_I(ip));\n\txfs_inode_free(ip);\n\treturn error;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 531,
    "critical_vars": [
      "error"
    ],
    "function": "xfs_iget_cache_miss",
    "filename": "linux/CVE-2018-13093/CVE-2018-13093_CWE-476_afca6c5b2595fc44383919fba740c194b0b76aff_xfs_icache.c.diff",
    "function_code": "xfs_iget_cache_miss(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag,\n\txfs_trans_t\t\t*tp,\n\txfs_ino_t\t\tino,\n\tstruct xfs_inode\t**ipp,\n\tint\t\t\tflags,\n\tint\t\t\tlock_flags)\n{\n\tstruct xfs_inode\t*ip;\n\tint\t\t\terror;\n\txfs_agino_t\t\tagino = XFS_INO_TO_AGINO(mp, ino);\n\tint\t\t\tiflags;\n\n\tip = xfs_inode_alloc(mp, ino);\n\tif (!ip)\n\t\treturn -ENOMEM;\n\n\terror = xfs_iread(mp, tp, ip, flags);\n\tif (error)\n\t\tgoto out_destroy;\n\n\tif (!xfs_inode_verify_forks(ip)) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_destroy;\n\t}\n\n\ttrace_xfs_iget_miss(ip);\n\n\n\t/*\n\t * Check the inode free state is valid. This also detects lookup\n\t * racing with unlinks.\n\t */\n\terror = xfs_iget_check_free_state(ip, flags);\n\tif (error)\n\t\tgoto out_destroy;\n\n\t/*\n\t * Preload the radix tree so we can insert safely under the\n\t * write spinlock. Note that we cannot sleep inside the preload\n\t * region. Since we can be called from transaction context, don't\n\t * recurse into the file system.\n\t */\n\tif (radix_tree_preload(GFP_NOFS)) {\n\t\terror = -EAGAIN;\n\t\tgoto out_destroy;\n\t}\n\n\t/*\n\t * Because the inode hasn't been added to the radix-tree yet it can't\n\t * be found by another thread, so we can do the non-sleeping lock here.\n\t */\n\tif (lock_flags) {\n\t\tif (!xfs_ilock_nowait(ip, lock_flags))\n\t\t\tBUG();\n\t}\n\n\t/*\n\t * These values must be set before inserting the inode into the radix\n\t * tree as the moment it is inserted a concurrent lookup (allowed by the\n\t * RCU locking mechanism) can find it and that lookup must see that this\n\t * is an inode currently under construction (i.e. that XFS_INEW is set).\n\t * The ip->i_flags_lock that protects the XFS_INEW flag forms the\n\t * memory barrier that ensures this detection works correctly at lookup\n\t * time.\n\t */\n\tiflags = XFS_INEW;\n\tif (flags & XFS_IGET_DONTCACHE)\n\t\tiflags |= XFS_IDONTCACHE;\n\tip->i_udquot = NULL;\n\tip->i_gdquot = NULL;\n\tip->i_pdquot = NULL;\n\txfs_iflags_set(ip, iflags);\n\n\t/* insert the new inode */\n\tspin_lock(&pag->pag_ici_lock);\n\terror = radix_tree_insert(&pag->pag_ici_root, agino, ip);\n\tif (unlikely(error)) {\n\t\tWARN_ON(error != -EEXIST);\n\t\tXFS_STATS_INC(mp, xs_ig_dup);\n\t\terror = -EAGAIN;\n\t\tgoto out_preload_end;\n\t}\n\tspin_unlock(&pag->pag_ici_lock);\n\tradix_tree_preload_end();\n\n\t*ipp = ip;\n\treturn 0;\n\nout_preload_end:\n\tspin_unlock(&pag->pag_ici_lock);\n\tradix_tree_preload_end();\n\tif (lock_flags)\n\t\txfs_iunlock(ip, lock_flags);\nout_destroy:\n\t__destroy_inode(VFS_I(ip));\n\txfs_inode_free(ip);\n\treturn error;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1823,
    "critical_vars": [
      "intf->altsetting[0].desc.bNumEndpoints"
    ],
    "function": "aiptek_probe",
    "filename": "linux/CVE-2015-7515/CVE-2015-7515_CWE-476_8e20cf2bce122ce9262d6034ee5d5b76fbb92f96_aiptek.c.diff",
    "function_code": "aiptek_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tstruct usb_device *usbdev = interface_to_usbdev(intf);\n\tstruct usb_endpoint_descriptor *endpoint;\n\tstruct aiptek *aiptek;\n\tstruct input_dev *inputdev;\n\tint i;\n\tint speeds[] = { 0,\n\t\tAIPTEK_PROGRAMMABLE_DELAY_50,\n\t\tAIPTEK_PROGRAMMABLE_DELAY_400,\n\t\tAIPTEK_PROGRAMMABLE_DELAY_25,\n\t\tAIPTEK_PROGRAMMABLE_DELAY_100,\n\t\tAIPTEK_PROGRAMMABLE_DELAY_200,\n\t\tAIPTEK_PROGRAMMABLE_DELAY_300\n\t};\n\tint err = -ENOMEM;\n\n\t/* programmableDelay is where the command-line specified\n\t * delay is kept. We make it the first element of speeds[],\n\t * so therefore, your override speed is tried first, then the\n\t * remainder. Note that the default value of 400ms will be tried\n\t * if you do not specify any command line parameter.\n\t */\n\tspeeds[0] = programmableDelay;\n\n\taiptek = kzalloc(sizeof(struct aiptek), GFP_KERNEL);\n\tinputdev = input_allocate_device();\n\tif (!aiptek || !inputdev) {\n\t\tdev_warn(&intf->dev,\n\t\t\t \"cannot allocate memory or input device\\n\");\n\t\tgoto fail1;\n        }\n\n\taiptek->data = usb_alloc_coherent(usbdev, AIPTEK_PACKET_LENGTH,\n\t\t\t\t\t  GFP_ATOMIC, &aiptek->data_dma);\n        if (!aiptek->data) {\n\t\tdev_warn(&intf->dev, \"cannot allocate usb buffer\\n\");\n\t\tgoto fail1;\n\t}\n\n\taiptek->urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!aiptek->urb) {\n\t        dev_warn(&intf->dev, \"cannot allocate urb\\n\");\n\t\tgoto fail2;\n\t}\n\n\taiptek->inputdev = inputdev;\n\taiptek->usbdev = usbdev;\n\taiptek->intf = intf;\n\taiptek->ifnum = intf->altsetting[0].desc.bInterfaceNumber;\n\taiptek->inDelay = 0;\n\taiptek->endDelay = 0;\n\taiptek->previousJitterable = 0;\n\taiptek->lastMacro = -1;\n\n\t/* Set up the curSettings struct. Said struct contains the current\n\t * programmable parameters. The newSetting struct contains changes\n\t * the user makes to the settings via the sysfs interface. Those\n\t * changes are not \"committed\" to curSettings until the user\n\t * writes to the sysfs/.../execute file.\n\t */\n\taiptek->curSetting.pointerMode = AIPTEK_POINTER_EITHER_MODE;\n\taiptek->curSetting.coordinateMode = AIPTEK_COORDINATE_ABSOLUTE_MODE;\n\taiptek->curSetting.toolMode = AIPTEK_TOOL_BUTTON_PEN_MODE;\n\taiptek->curSetting.xTilt = AIPTEK_TILT_DISABLE;\n\taiptek->curSetting.yTilt = AIPTEK_TILT_DISABLE;\n\taiptek->curSetting.mouseButtonLeft = AIPTEK_MOUSE_LEFT_BUTTON;\n\taiptek->curSetting.mouseButtonMiddle = AIPTEK_MOUSE_MIDDLE_BUTTON;\n\taiptek->curSetting.mouseButtonRight = AIPTEK_MOUSE_RIGHT_BUTTON;\n\taiptek->curSetting.stylusButtonUpper = AIPTEK_STYLUS_UPPER_BUTTON;\n\taiptek->curSetting.stylusButtonLower = AIPTEK_STYLUS_LOWER_BUTTON;\n\taiptek->curSetting.jitterDelay = jitterDelay;\n\taiptek->curSetting.programmableDelay = programmableDelay;\n\n\t/* Both structs should have equivalent settings\n\t */\n\taiptek->newSetting = aiptek->curSetting;\n\n\t/* Determine the usb devices' physical path.\n\t * Asketh not why we always pretend we're using \"../input0\",\n\t * but I suspect this will have to be refactored one\n\t * day if a single USB device can be a keyboard & a mouse\n\t * & a tablet, and the inputX number actually will tell\n\t * us something...\n\t */\n\tusb_make_path(usbdev, aiptek->features.usbPath,\n\t\t\tsizeof(aiptek->features.usbPath));\n\tstrlcat(aiptek->features.usbPath, \"/input0\",\n\t\tsizeof(aiptek->features.usbPath));\n\n\t/* Set up client data, pointers to open and close routines\n\t * for the input device.\n\t */\n\tinputdev->name = \"Aiptek\";\n\tinputdev->phys = aiptek->features.usbPath;\n\tusb_to_input_id(usbdev, &inputdev->id);\n\tinputdev->dev.parent = &intf->dev;\n\n\tinput_set_drvdata(inputdev, aiptek);\n\n\tinputdev->open = aiptek_open;\n\tinputdev->close = aiptek_close;\n\n\t/* Now program the capacities of the tablet, in terms of being\n\t * an input device.\n\t */\n\tfor (i = 0; i < ARRAY_SIZE(eventTypes); ++i)\n\t        __set_bit(eventTypes[i], inputdev->evbit);\n\n\tfor (i = 0; i < ARRAY_SIZE(absEvents); ++i)\n\t        __set_bit(absEvents[i], inputdev->absbit);\n\n\tfor (i = 0; i < ARRAY_SIZE(relEvents); ++i)\n\t        __set_bit(relEvents[i], inputdev->relbit);\n\n\t__set_bit(MSC_SERIAL, inputdev->mscbit);\n\n\t/* Set up key and button codes */\n\tfor (i = 0; i < ARRAY_SIZE(buttonEvents); ++i)\n\t\t__set_bit(buttonEvents[i], inputdev->keybit);\n\n\tfor (i = 0; i < ARRAY_SIZE(macroKeyEvents); ++i)\n\t\t__set_bit(macroKeyEvents[i], inputdev->keybit);\n\n\t/*\n\t * Program the input device coordinate capacities. We do not yet\n\t * know what maximum X, Y, and Z values are, so we're putting fake\n\t * values in. Later, we'll ask the tablet to put in the correct\n\t * values.\n\t */\n\tinput_set_abs_params(inputdev, ABS_X, 0, 2999, 0, 0);\n\tinput_set_abs_params(inputdev, ABS_Y, 0, 2249, 0, 0);\n\tinput_set_abs_params(inputdev, ABS_PRESSURE, 0, 511, 0, 0);\n\tinput_set_abs_params(inputdev, ABS_TILT_X, AIPTEK_TILT_MIN, AIPTEK_TILT_MAX, 0, 0);\n\tinput_set_abs_params(inputdev, ABS_TILT_Y, AIPTEK_TILT_MIN, AIPTEK_TILT_MAX, 0, 0);\n\tinput_set_abs_params(inputdev, ABS_WHEEL, AIPTEK_WHEEL_MIN, AIPTEK_WHEEL_MAX - 1, 0, 0);\n\n\t/* Verify that a device really has an endpoint */\n\tif (intf->altsetting[0].desc.bNumEndpoints < 1) {\n\t\tdev_err(&intf->dev,\n\t\t\t\"interface has %d endpoints, but must have minimum 1\\n\",\n\t\t\tintf->altsetting[0].desc.bNumEndpoints);\n\t\terr = -EINVAL;\n\t\tgoto fail3;\n\t}\n\tendpoint = &intf->altsetting[0].endpoint[0].desc;\n\n\t/* Go set up our URB, which is called when the tablet receives\n\t * input.\n\t */\n\tusb_fill_int_urb(aiptek->urb,\n\t\t\t aiptek->usbdev,\n\t\t\t usb_rcvintpipe(aiptek->usbdev,\n\t\t\t\t\tendpoint->bEndpointAddress),\n\t\t\t aiptek->data, 8, aiptek_irq, aiptek,\n\t\t\t endpoint->bInterval);\n\n\taiptek->urb->transfer_dma = aiptek->data_dma;\n\taiptek->urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\t/* Program the tablet. This sets the tablet up in the mode\n\t * specified in newSetting, and also queries the tablet's\n\t * physical capacities.\n\t *\n\t * Sanity check: if a tablet doesn't like the slow programmatic\n\t * delay, we often get sizes of 0x0. Let's use that as an indicator\n\t * to try faster delays, up to 25 ms. If that logic fails, well, you'll\n\t * have to explain to us how your tablet thinks it's 0x0, and yet that's\n\t * not an error :-)\n\t */\n\n\tfor (i = 0; i < ARRAY_SIZE(speeds); ++i) {\n\t\taiptek->curSetting.programmableDelay = speeds[i];\n\t\t(void)aiptek_program_tablet(aiptek);\n\t\tif (input_abs_get_max(aiptek->inputdev, ABS_X) > 0) {\n\t\t\tdev_info(&intf->dev,\n\t\t\t\t \"Aiptek using %d ms programming speed\\n\",\n\t\t\t\t aiptek->curSetting.programmableDelay);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Murphy says that some day someone will have a tablet that fails the\n\t   above test. That's you, Frederic Rodrigo */\n\tif (i == ARRAY_SIZE(speeds)) {\n\t\tdev_info(&intf->dev,\n\t\t\t \"Aiptek tried all speeds, no sane response\\n\");\n\t\terr = -EINVAL;\n\t\tgoto fail3;\n\t}\n\n\t/* Associate this driver's struct with the usb interface.\n\t */\n\tusb_set_intfdata(intf, aiptek);\n\n\t/* Set up the sysfs files\n\t */\n\terr = sysfs_create_group(&intf->dev.kobj, &aiptek_attribute_group);\n\tif (err) {\n\t\tdev_warn(&intf->dev, \"cannot create sysfs group err: %d\\n\",\n\t\t\t err);\n\t\tgoto fail3;\n        }\n\n\t/* Register the tablet as an Input Device\n\t */\n\terr = input_register_device(aiptek->inputdev);\n\tif (err) {\n\t\tdev_warn(&intf->dev,\n\t\t\t \"input_register_device returned err: %d\\n\", err);\n\t\tgoto fail4;\n        }\n\treturn 0;\n\n fail4:\tsysfs_remove_group(&intf->dev.kobj, &aiptek_attribute_group);\n fail3: usb_free_urb(aiptek->urb);\n fail2:\tusb_free_coherent(usbdev, AIPTEK_PACKET_LENGTH, aiptek->data,\n\t\t\t  aiptek->data_dma);\n fail1: usb_set_intfdata(intf, NULL);\n\tinput_free_device(inputdev);\n\tkfree(aiptek);\n\treturn err;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 353,
    "line_new": 353,
    "critical_vars": [
      "ret"
    ],
    "function": "fscrypt_setup_filename",
    "filename": "linux/CVE-2017-7374/CVE-2017-7374_CWE-476_1b53cf9815bb4744958d41f3795d5d5a1d365e2d_fname.c.diff",
    "function_code": "int fscrypt_setup_filename(struct inode *dir, const struct qstr *iname,\n\t\t\t      int lookup, struct fscrypt_name *fname)\n{\n\tint ret = 0, bigname = 0;\n\n\tmemset(fname, 0, sizeof(struct fscrypt_name));\n\tfname->usr_fname = iname;\n\n\tif (!dir->i_sb->s_cop->is_encrypted(dir) ||\n\t\t\t\tfscrypt_is_dot_dotdot(iname)) {\n\t\tfname->disk_name.name = (unsigned char *)iname->name;\n\t\tfname->disk_name.len = iname->len;\n\t\treturn 0;\n\t}\n\tret = fscrypt_get_encryption_info(dir);\n\tif (ret && ret != -EOPNOTSUPP)\n\t\treturn ret;\n\n\tif (dir->i_crypt_info) {\n\t\tret = fscrypt_fname_alloc_buffer(dir, iname->len,\n\t\t\t\t\t\t\t&fname->crypto_buf);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = fname_encrypt(dir, iname, &fname->crypto_buf);\n\t\tif (ret)\n\t\t\tgoto errout;\n\t\tfname->disk_name.name = fname->crypto_buf.name;\n\t\tfname->disk_name.len = fname->crypto_buf.len;\n\t\treturn 0;\n\t}\n\tif (!lookup)\n\t\treturn -ENOKEY;\n\n\t/*\n\t * We don't have the key and we are doing a lookup; decode the\n\t * user-supplied name\n\t */\n\tif (iname->name[0] == '_')\n\t\tbigname = 1;\n\tif ((bigname && (iname->len != 33)) || (!bigname && (iname->len > 43)))\n\t\treturn -ENOENT;\n\n\tfname->crypto_buf.name = kmalloc(32, GFP_KERNEL);\n\tif (fname->crypto_buf.name == NULL)\n\t\treturn -ENOMEM;\n\n\tret = digest_decode(iname->name + bigname, iname->len - bigname,\n\t\t\t\tfname->crypto_buf.name);\n\tif (ret < 0) {\n\t\tret = -ENOENT;\n\t\tgoto errout;\n\t}\n\tfname->crypto_buf.len = ret;\n\tif (bigname) {\n\t\tmemcpy(&fname->hash, fname->crypto_buf.name, 4);\n\t\tmemcpy(&fname->minor_hash, fname->crypto_buf.name + 4, 4);\n\t} else {\n\t\tfname->disk_name.name = fname->crypto_buf.name;\n\t\tfname->disk_name.len = fname->crypto_buf.len;\n\t}\n\treturn 0;\n\nerrout:\n\tfscrypt_fname_free_buffer(&fname->crypto_buf);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 98,
    "critical_vars": [
      "&keyring_key->sem"
    ],
    "function": "validate_user_key",
    "filename": "linux/CVE-2017-7374/CVE-2017-7374_CWE-476_1b53cf9815bb4744958d41f3795d5d5a1d365e2d_keyinfo.c.diff",
    "function_code": "static int validate_user_key(struct fscrypt_info *crypt_info,\n\t\t\tstruct fscrypt_context *ctx, u8 *raw_key,\n\t\t\tconst char *prefix)\n{\n\tchar *description;\n\tstruct key *keyring_key;\n\tstruct fscrypt_key *master_key;\n\tconst struct user_key_payload *ukp;\n\tint res;\n\n\tdescription = kasprintf(GFP_NOFS, \"%s%*phN\", prefix,\n\t\t\t\tFS_KEY_DESCRIPTOR_SIZE,\n\t\t\t\tctx->master_key_descriptor);\n\tif (!description)\n\t\treturn -ENOMEM;\n\n\tkeyring_key = request_key(&key_type_logon, description, NULL);\n\tkfree(description);\n\tif (IS_ERR(keyring_key))\n\t\treturn PTR_ERR(keyring_key);\n\tdown_read(&keyring_key->sem);\n\n\tif (keyring_key->type != &key_type_logon) {\n\t\tprintk_once(KERN_WARNING\n\t\t\t\t\"%s: key type must be logon\\n\", __func__);\n\t\tres = -ENOKEY;\n\t\tgoto out;\n\t}\n\tukp = user_key_payload(keyring_key);\n\tif (ukp->datalen != sizeof(struct fscrypt_key)) {\n\t\tres = -EINVAL;\n\t\tgoto out;\n\t}\n\tmaster_key = (struct fscrypt_key *)ukp->data;\n\tBUILD_BUG_ON(FS_AES_128_ECB_KEY_SIZE != FS_KEY_DERIVATION_NONCE_SIZE);\n\n\tif (master_key->size != FS_AES_256_XTS_KEY_SIZE) {\n\t\tprintk_once(KERN_WARNING\n\t\t\t\t\"%s: key size incorrect: %d\\n\",\n\t\t\t\t__func__, master_key->size);\n\t\tres = -ENOKEY;\n\t\tgoto out;\n\t}\n\tres = derive_key_aes(ctx->nonce, master_key->raw, raw_key);\nout:\n\tup_read(&keyring_key->sem);\n\tkey_put(keyring_key);\n\treturn res;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 105,
    "critical_vars": [
      "&keyring_key->sem"
    ],
    "function": "validate_user_key",
    "filename": "linux/CVE-2017-7374/CVE-2017-7374_CWE-476_1b53cf9815bb4744958d41f3795d5d5a1d365e2d_keyinfo.c.diff",
    "function_code": "static int validate_user_key(struct fscrypt_info *crypt_info,\n\t\t\tstruct fscrypt_context *ctx, u8 *raw_key,\n\t\t\tconst char *prefix)\n{\n\tchar *description;\n\tstruct key *keyring_key;\n\tstruct fscrypt_key *master_key;\n\tconst struct user_key_payload *ukp;\n\tint res;\n\n\tdescription = kasprintf(GFP_NOFS, \"%s%*phN\", prefix,\n\t\t\t\tFS_KEY_DESCRIPTOR_SIZE,\n\t\t\t\tctx->master_key_descriptor);\n\tif (!description)\n\t\treturn -ENOMEM;\n\n\tkeyring_key = request_key(&key_type_logon, description, NULL);\n\tkfree(description);\n\tif (IS_ERR(keyring_key))\n\t\treturn PTR_ERR(keyring_key);\n\n\tif (keyring_key->type != &key_type_logon) {\n\t\tprintk_once(KERN_WARNING\n\t\t\t\t\"%s: key type must be logon\\n\", __func__);\n\t\tres = -ENOKEY;\n\t\tgoto out;\n\t}\n\tdown_read(&keyring_key->sem);\n\tukp = user_key_payload(keyring_key);\n\tif (ukp->datalen != sizeof(struct fscrypt_key)) {\n\t\tres = -EINVAL;\n\t\tup_read(&keyring_key->sem);\n\t\tgoto out;\n\t}\n\tmaster_key = (struct fscrypt_key *)ukp->data;\n\tBUILD_BUG_ON(FS_AES_128_ECB_KEY_SIZE != FS_KEY_DERIVATION_NONCE_SIZE);\n\n\tif (master_key->size != FS_AES_256_XTS_KEY_SIZE) {\n\t\tprintk_once(KERN_WARNING\n\t\t\t\t\"%s: key size incorrect: %d\\n\",\n\t\t\t\t__func__, master_key->size);\n\t\tres = -ENOKEY;\n\t\tup_read(&keyring_key->sem);\n\t\tgoto out;\n\t}\n\tres = derive_key_aes(ctx->nonce, master_key->raw, raw_key);\n\tup_read(&keyring_key->sem);\n\tif (res)\n\t\tgoto out;\n\n\tcrypt_info->ci_keyring_key = keyring_key;\n\treturn 0;\nout:\n\tkey_put(keyring_key);\n\treturn res;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 172,
    "critical_vars": [
      "ci->ci_keyring_key"
    ],
    "function": "put_crypt_info",
    "filename": "linux/CVE-2017-7374/CVE-2017-7374_CWE-476_1b53cf9815bb4744958d41f3795d5d5a1d365e2d_keyinfo.c.diff",
    "function_code": "static void put_crypt_info(struct fscrypt_info *ci)\n{\n\tif (!ci)\n\t\treturn;\n\n\tkey_put(ci->ci_keyring_key);\n\tcrypto_free_skcipher(ci->ci_ctfm);\n\tkmem_cache_free(fscrypt_info_cachep, ci);\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 193,
    "critical_vars": [
      "crypt_info"
    ],
    "function": "fscrypt_get_crypt_info",
    "filename": "linux/CVE-2017-7374/CVE-2017-7374_CWE-476_1b53cf9815bb4744958d41f3795d5d5a1d365e2d_keyinfo.c.diff",
    "function_code": "int fscrypt_get_crypt_info(struct inode *inode)\n{\n\tstruct fscrypt_info *crypt_info;\n\tstruct fscrypt_context ctx;\n\tstruct crypto_skcipher *ctfm;\n\tconst char *cipher_str;\n\tint keysize;\n\tu8 *raw_key = NULL;\n\tint res;\n\n\tres = fscrypt_initialize(inode->i_sb->s_cop->flags);\n\tif (res)\n\t\treturn res;\n\n\tif (!inode->i_sb->s_cop->get_context)\n\t\treturn -EOPNOTSUPP;\nretry:\n\tcrypt_info = ACCESS_ONCE(inode->i_crypt_info);\n\tif (crypt_info) {\n\t\tif (!crypt_info->ci_keyring_key ||\n\t\t\t\tkey_validate(crypt_info->ci_keyring_key) == 0)\n\t\t\treturn 0;\n\t\tfscrypt_put_encryption_info(inode, crypt_info);\n\t\tgoto retry;\n\t}\n\n\tres = inode->i_sb->s_cop->get_context(inode, &ctx, sizeof(ctx));\n\tif (res < 0) {\n\t\tif (!fscrypt_dummy_context_enabled(inode) ||\n\t\t    inode->i_sb->s_cop->is_encrypted(inode))\n\t\t\treturn res;\n\t\t/* Fake up a context for an unencrypted directory */\n\t\tmemset(&ctx, 0, sizeof(ctx));\n\t\tctx.format = FS_ENCRYPTION_CONTEXT_FORMAT_V1;\n\t\tctx.contents_encryption_mode = FS_ENCRYPTION_MODE_AES_256_XTS;\n\t\tctx.filenames_encryption_mode = FS_ENCRYPTION_MODE_AES_256_CTS;\n\t\tmemset(ctx.master_key_descriptor, 0x42, FS_KEY_DESCRIPTOR_SIZE);\n\t} else if (res != sizeof(ctx)) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (ctx.format != FS_ENCRYPTION_CONTEXT_FORMAT_V1)\n\t\treturn -EINVAL;\n\n\tif (ctx.flags & ~FS_POLICY_FLAGS_VALID)\n\t\treturn -EINVAL;\n\n\tcrypt_info = kmem_cache_alloc(fscrypt_info_cachep, GFP_NOFS);\n\tif (!crypt_info)\n\t\treturn -ENOMEM;\n\n\tcrypt_info->ci_flags = ctx.flags;\n\tcrypt_info->ci_data_mode = ctx.contents_encryption_mode;\n\tcrypt_info->ci_filename_mode = ctx.filenames_encryption_mode;\n\tcrypt_info->ci_ctfm = NULL;\n\tcrypt_info->ci_keyring_key = NULL;\n\tmemcpy(crypt_info->ci_master_key, ctx.master_key_descriptor,\n\t\t\t\tsizeof(crypt_info->ci_master_key));\n\n\tres = determine_cipher_type(crypt_info, inode, &cipher_str, &keysize);\n\tif (res)\n\t\tgoto out;\n\n\t/*\n\t * This cannot be a stack buffer because it is passed to the scatterlist\n\t * crypto API as part of key derivation.\n\t */\n\tres = -ENOMEM;\n\traw_key = kmalloc(FS_MAX_KEY_SIZE, GFP_NOFS);\n\tif (!raw_key)\n\t\tgoto out;\n\n\tres = validate_user_key(crypt_info, &ctx, raw_key, FS_KEY_DESC_PREFIX);\n\tif (res && inode->i_sb->s_cop->key_prefix) {\n\t\tint res2 = validate_user_key(crypt_info, &ctx, raw_key,\n\t\t\t\t\t     inode->i_sb->s_cop->key_prefix);\n\t\tif (res2) {\n\t\t\tif (res2 == -ENOKEY)\n\t\t\t\tres = -ENOKEY;\n\t\t\tgoto out;\n\t\t}\n\t} else if (res) {\n\t\tgoto out;\n\t}\n\tctfm = crypto_alloc_skcipher(cipher_str, 0, 0);\n\tif (!ctfm || IS_ERR(ctfm)) {\n\t\tres = ctfm ? PTR_ERR(ctfm) : -ENOMEM;\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s: error %d (inode %u) allocating crypto tfm\\n\",\n\t\t       __func__, res, (unsigned) inode->i_ino);\n\t\tgoto out;\n\t}\n\tcrypt_info->ci_ctfm = ctfm;\n\tcrypto_skcipher_clear_flags(ctfm, ~0);\n\tcrypto_skcipher_set_flags(ctfm, CRYPTO_TFM_REQ_WEAK_KEY);\n\tres = crypto_skcipher_setkey(ctfm, raw_key, keysize);\n\tif (res)\n\t\tgoto out;\n\n\tkzfree(raw_key);\n\traw_key = NULL;\n\tif (cmpxchg(&inode->i_crypt_info, NULL, crypt_info) != NULL) {\n\t\tput_crypt_info(crypt_info);\n\t\tgoto retry;\n\t}\n\treturn 0;\n\nout:\n\tif (res == -ENOKEY)\n\t\tres = 0;\n\tput_crypt_info(crypt_info);\n\tkzfree(raw_key);\n\treturn res;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 342,
    "critical_vars": [
      "ci"
    ],
    "function": "fscrypt_d_revalidate",
    "filename": "linux/CVE-2017-7374/CVE-2017-7374_CWE-476_1b53cf9815bb4744958d41f3795d5d5a1d365e2d_crypto.c.diff",
    "function_code": "static int fscrypt_d_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct dentry *dir;\n\tstruct fscrypt_info *ci;\n\tint dir_has_key, cached_with_key;\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tdir = dget_parent(dentry);\n\tif (!d_inode(dir)->i_sb->s_cop->is_encrypted(d_inode(dir))) {\n\t\tdput(dir);\n\t\treturn 0;\n\t}\n\n\tci = d_inode(dir)->i_crypt_info;\n\tif (ci && ci->ci_keyring_key &&\n\t    (ci->ci_keyring_key->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t\t\t  (1 << KEY_FLAG_REVOKED) |\n\t\t\t\t\t  (1 << KEY_FLAG_DEAD))))\n\t\tci = NULL;\n\n\t/* this should eventually be an flag in d_flags */\n\tspin_lock(&dentry->d_lock);\n\tcached_with_key = dentry->d_flags & DCACHE_ENCRYPTED_WITH_KEY;\n\tspin_unlock(&dentry->d_lock);\n\tdir_has_key = (ci != NULL);\n\tdput(dir);\n\n\t/*\n\t * If the dentry was cached without the key, and it is a\n\t * negative dentry, it might be a valid name.  We can't check\n\t * if the key has since been made available due to locking\n\t * reasons, so we fail the validation so ext4_lookup() can do\n\t * this check.\n\t *\n\t * We also fail the validation if the dentry was created with\n\t * the key present, but we no longer have the key, or vice versa.\n\t */\n\tif ((!cached_with_key && d_is_negative(dentry)) ||\n\t\t\t(!cached_with_key && dir_has_key) ||\n\t\t\t(cached_with_key && !dir_has_key))\n\t\treturn 0;\n\treturn 1;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1424,
    "critical_vars": [
      "regset->get"
    ],
    "function": "fill_thread_core_info",
    "filename": "linux/CVE-2012-1097/CVE-2012-1097_CWE-476_c8e252586f8d5de906385d8cf6385fee289a825e_binfmt_elf.c.diff",
    "function_code": "static int fill_thread_core_info(struct elf_thread_core_info *t,\n\t\t\t\t const struct user_regset_view *view,\n\t\t\t\t long signr, size_t *total)\n{\n\tunsigned int i;\n\n\t/*\n\t * NT_PRSTATUS is the one special case, because the regset data\n\t * goes into the pr_reg field inside the note contents, rather\n\t * than being the whole note contents.  We fill the reset in here.\n\t * We assume that regset 0 is NT_PRSTATUS.\n\t */\n\tfill_prstatus(&t->prstatus, t->task, signr);\n\t(void) view->regsets[0].get(t->task, &view->regsets[0],\n\t\t\t\t    0, sizeof(t->prstatus.pr_reg),\n\t\t\t\t    &t->prstatus.pr_reg, NULL);\n\n\tfill_note(&t->notes[0], \"CORE\", NT_PRSTATUS,\n\t\t  sizeof(t->prstatus), &t->prstatus);\n\t*total += notesize(&t->notes[0]);\n\n\tdo_thread_regset_writeback(t->task, &view->regsets[0]);\n\n\t/*\n\t * Each other regset might generate a note too.  For each regset\n\t * that has no core_note_type or is inactive, we leave t->notes[i]\n\t * all zero and we'll know to skip writing it later.\n\t */\n\tfor (i = 1; i < view->n; ++i) {\n\t\tconst struct user_regset *regset = &view->regsets[i];\n\t\tdo_thread_regset_writeback(t->task, regset);\n\t\tif (regset->core_note_type && regset->get &&\n\t\t    (!regset->active || regset->active(t->task, regset))) {\n\t\t\tint ret;\n\t\t\tsize_t size = regset->n * regset->size;\n\t\t\tvoid *data = kmalloc(size, GFP_KERNEL);\n\t\t\tif (unlikely(!data))\n\t\t\t\treturn 0;\n\t\t\tret = regset->get(t->task, regset,\n\t\t\t\t\t  0, size, data, NULL);\n\t\t\tif (unlikely(ret))\n\t\t\t\tkfree(data);\n\t\t\telse {\n\t\t\t\tif (regset->core_note_type != NT_PRFPREG)\n\t\t\t\t\tfill_note(&t->notes[i], \"LINUX\",\n\t\t\t\t\t\t  regset->core_note_type,\n\t\t\t\t\t\t  size, data);\n\t\t\t\telse {\n\t\t\t\t\tt->prstatus.pr_fpvalid = 1;\n\t\t\t\t\tfill_note(&t->notes[i], \"CORE\",\n\t\t\t\t\t\t  NT_PRFPREG, size, data);\n\t\t\t\t}\n\t\t\t\t*total += notesize(&t->notes[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1027,
    "critical_vars": [
      "kvm",
      "src"
    ],
    "function": "kvm_irq_delivery_to_apic_fast",
    "filename": "linux/CVE-2022-2153/CVE-2022-2153_CWE-476_00b5f37189d24ac3ed46cb7f11742094778c46ce_lapic.c.diff",
    "function_code": "bool kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, int *r, struct dest_map *dest_map)\n{\n\tstruct kvm_apic_map *map;\n\tunsigned long bitmap;\n\tstruct kvm_lapic **dst = NULL;\n\tint i;\n\tbool ret;\n\n\t*r = -1;\n\n\tif (irq->shorthand == APIC_DEST_SELF) {\n\t\tif (KVM_BUG_ON(!src, kvm)) {\n\t\t\t*r = 0;\n\t\t\treturn true;\n\t\t}\n\t\t*r = kvm_apic_set_irq(src->vcpu, irq, dest_map);\n\t\treturn true;\n\t}\n\n\trcu_read_lock();\n\tmap = rcu_dereference(kvm->arch.apic_map);\n\n\tret = kvm_apic_map_get_dest_lapic(kvm, &src, irq, map, &dst, &bitmap);\n\tif (ret) {\n\t\t*r = 0;\n\t\tfor_each_set_bit(i, &bitmap, 16) {\n\t\t\tif (!dst[i])\n\t\t\t\tcontinue;\n\t\t\t*r += kvm_apic_set_irq(dst[i]->vcpu, irq, dest_map);\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 242,
    "critical_vars": [
      "data"
    ],
    "function": "synic_set_msr",
    "filename": "linux/CVE-2022-2153/CVE-2022-2153_CWE-476_b1e34d325397a33d97d845e312d7cf2a8b646b44_hyperv.c.diff",
    "function_code": "static int synic_set_msr(struct kvm_vcpu_hv_synic *synic,\n\t\t\t u32 msr, u64 data, bool host)\n{\n\tstruct kvm_vcpu *vcpu = hv_synic_to_vcpu(synic);\n\tint ret;\n\n\tif (!synic->active && (!host || data))\n\t\treturn 1;\n\n\ttrace_kvm_hv_synic_set_msr(vcpu->vcpu_id, msr, data, host);\n\n\tret = 0;\n\tswitch (msr) {\n\tcase HV_X64_MSR_SCONTROL:\n\t\tsynic->control = data;\n\t\tif (!host)\n\t\t\tsynic_exit(synic, msr);\n\t\tbreak;\n\tcase HV_X64_MSR_SVERSION:\n\t\tif (!host) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t\tsynic->version = data;\n\t\tbreak;\n\tcase HV_X64_MSR_SIEFP:\n\t\tif ((data & HV_SYNIC_SIEFP_ENABLE) && !host &&\n\t\t    !synic->dont_zero_synic_pages)\n\t\t\tif (kvm_clear_guest(vcpu->kvm,\n\t\t\t\t\t    data & PAGE_MASK, PAGE_SIZE)) {\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tsynic->evt_page = data;\n\t\tif (!host)\n\t\t\tsynic_exit(synic, msr);\n\t\tbreak;\n\tcase HV_X64_MSR_SIMP:\n\t\tif ((data & HV_SYNIC_SIMP_ENABLE) && !host &&\n\t\t    !synic->dont_zero_synic_pages)\n\t\t\tif (kvm_clear_guest(vcpu->kvm,\n\t\t\t\t\t    data & PAGE_MASK, PAGE_SIZE)) {\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tsynic->msg_page = data;\n\t\tif (!host)\n\t\t\tsynic_exit(synic, msr);\n\t\tbreak;\n\tcase HV_X64_MSR_EOM: {\n\t\tint i;\n\n\t\tif (!synic->active)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++)\n\t\t\tkvm_hv_notify_acked_sint(vcpu, i);\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:\n\t\tret = synic_set_sint(synic, msr - HV_X64_MSR_SINT0, data, host);\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 670,
    "critical_vars": [
      "config"
    ],
    "function": "stimer_set_config",
    "filename": "linux/CVE-2022-2153/CVE-2022-2153_CWE-476_b1e34d325397a33d97d845e312d7cf2a8b646b44_hyperv.c.diff",
    "function_code": "static int stimer_set_config(struct kvm_vcpu_hv_stimer *stimer, u64 config,\n\t\t\t     bool host)\n{\n\tunion hv_stimer_config new_config = {.as_uint64 = config},\n\t\told_config = {.as_uint64 = stimer->config.as_uint64};\n\tstruct kvm_vcpu *vcpu = hv_stimer_to_vcpu(stimer);\n\tstruct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);\n\tstruct kvm_vcpu_hv_synic *synic = to_hv_synic(vcpu);\n\n\tif (!synic->active && (!host || config))\n\t\treturn 1;\n\n\tif (unlikely(!host && hv_vcpu->enforce_cpuid && new_config.direct_mode &&\n\t\t     !(hv_vcpu->cpuid_cache.features_edx &\n\t\t       HV_STIMER_DIRECT_MODE_AVAILABLE)))\n\t\treturn 1;\n\n\ttrace_kvm_hv_stimer_set_config(hv_stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t       stimer->index, config, host);\n\n\tstimer_cleanup(stimer);\n\tif (old_config.enable &&\n\t    !new_config.direct_mode && new_config.sintx == 0)\n\t\tnew_config.enable = 0;\n\tstimer->config.as_uint64 = new_config.as_uint64;\n\n\tif (stimer->config.enable)\n\t\tstimer_mark_pending(stimer, false);\n\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 699,
    "critical_vars": [
      "count"
    ],
    "function": "stimer_set_count",
    "filename": "linux/CVE-2022-2153/CVE-2022-2153_CWE-476_b1e34d325397a33d97d845e312d7cf2a8b646b44_hyperv.c.diff",
    "function_code": "static int stimer_set_count(struct kvm_vcpu_hv_stimer *stimer, u64 count,\n\t\t\t    bool host)\n{\n\tstruct kvm_vcpu *vcpu = hv_stimer_to_vcpu(stimer);\n\tstruct kvm_vcpu_hv_synic *synic = to_hv_synic(vcpu);\n\n\tif (!synic->active && (!host || count))\n\t\treturn 1;\n\n\ttrace_kvm_hv_stimer_set_count(hv_stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t      stimer->index, count, host);\n\n\tstimer_cleanup(stimer);\n\tstimer->count = count;\n\tif (stimer->count == 0)\n\t\tstimer->config.enable = 0;\n\telse if (stimer->config.auto_enable)\n\t\tstimer->config.enable = 1;\n\n\tif (stimer->config.enable)\n\t\tstimer_mark_pending(stimer, false);\n\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 452,
    "critical_vars": [
      "vcpu",
      "vcpu->kvm"
    ],
    "function": "synic_set_irq",
    "filename": "linux/CVE-2022-2153/CVE-2022-2153_CWE-476_7ec37d1cbe17d8189d9562178d8b29167fe1c31a_hyperv.c.diff",
    "function_code": "static int synic_set_irq(struct kvm_vcpu_hv_synic *synic, u32 sint)\n{\n\tstruct kvm_vcpu *vcpu = hv_synic_to_vcpu(synic);\n\tstruct kvm_lapic_irq irq;\n\tint ret, vector;\n\n\tif (KVM_BUG_ON(!lapic_in_kernel(vcpu), vcpu->kvm))\n\t\treturn -EINVAL;\n\n\tif (sint >= ARRAY_SIZE(synic->sint))\n\t\treturn -EINVAL;\n\n\tvector = synic_get_sint_vector(synic_read_sint(synic, sint));\n\tif (vector < 0)\n\t\treturn -ENOENT;\n\n\tmemset(&irq, 0, sizeof(irq));\n\tirq.shorthand = APIC_DEST_SELF;\n\tirq.dest_mode = APIC_DEST_PHYSICAL;\n\tirq.delivery_mode = APIC_DM_FIXED;\n\tirq.vector = vector;\n\tirq.level = 1;\n\n\tret = kvm_irq_delivery_to_apic(vcpu->kvm, vcpu->arch.apic, &irq, NULL);\n\ttrace_kvm_hv_synic_set_irq(vcpu->vcpu_id, sint, irq.vector, ret);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 648,
    "line_new": 648,
    "critical_vars": [
      "default_dram_type"
    ],
    "function": "memory_tier_init",
    "filename": "linux/CVE-2023-23005/CVE-2023-23005_CWE-476_4a625ceee8a0ab0273534cb6b432ce6b331db5ee_memory-tiers.c.diff",
    "function_code": "static int __init memory_tier_init(void)\n{\n\tint ret, node;\n\tstruct memory_tier *memtier;\n\n\tret = subsys_virtual_register(&memory_tier_subsys, NULL);\n\tif (ret)\n\t\tpanic(\"%s() failed to register memory tier subsystem\\n\", __func__);\n\n#ifdef CONFIG_MIGRATION\n\tnode_demotion = kcalloc(nr_node_ids, sizeof(struct demotion_nodes),\n\t\t\t\tGFP_KERNEL);\n\tWARN_ON(!node_demotion);\n#endif\n\tmutex_lock(&memory_tier_lock);\n\t/*\n\t * For now we can have 4 faster memory tiers with smaller adistance\n\t * than default DRAM tier.\n\t */\n\tdefault_dram_type = alloc_memory_type(MEMTIER_ADISTANCE_DRAM);\n\tif (IS_ERR(default_dram_type))\n\t\tpanic(\"%s() failed to allocate default DRAM tier\\n\", __func__);\n\n\t/*\n\t * Look at all the existing N_MEMORY nodes and add them to\n\t * default memory tier or to a tier if we already have memory\n\t * types assigned.\n\t */\n\tfor_each_node_state(node, N_MEMORY) {\n\t\tmemtier = set_node_memory_tier(node);\n\t\tif (IS_ERR(memtier))\n\t\t\t/*\n\t\t\t * Continue with memtiers we are able to setup\n\t\t\t */\n\t\t\tbreak;\n\t}\n\testablish_demotion_targets();\n\tmutex_unlock(&memory_tier_lock);\n\n\thotplug_memory_notifier(memtier_hotplug_callback, MEMTIER_HOTPLUG_PRI);\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 283,
    "critical_vars": [
      "dynset_expr->ops"
    ],
    "function": "nft_dynset_init",
    "filename": "linux/CVE-2023-6622/CVE-2023-6622_CWE-476_3701cd390fd731ee7ae8b8006246c8db82c72bea_nft_dynset.c.diff",
    "function_code": "static int nft_dynset_init(const struct nft_ctx *ctx,\n\t\t\t   const struct nft_expr *expr,\n\t\t\t   const struct nlattr * const tb[])\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(ctx->net);\n\tstruct nft_dynset *priv = nft_expr_priv(expr);\n\tu8 genmask = nft_genmask_next(ctx->net);\n\tstruct nft_set *set;\n\tu64 timeout;\n\tint err, i;\n\n\tlockdep_assert_held(&nft_net->commit_mutex);\n\n\tif (tb[NFTA_DYNSET_SET_NAME] == NULL ||\n\t    tb[NFTA_DYNSET_OP] == NULL ||\n\t    tb[NFTA_DYNSET_SREG_KEY] == NULL)\n\t\treturn -EINVAL;\n\n\tif (tb[NFTA_DYNSET_FLAGS]) {\n\t\tu32 flags = ntohl(nla_get_be32(tb[NFTA_DYNSET_FLAGS]));\n\t\tif (flags & ~(NFT_DYNSET_F_INV | NFT_DYNSET_F_EXPR))\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (flags & NFT_DYNSET_F_INV)\n\t\t\tpriv->invert = true;\n\t\tif (flags & NFT_DYNSET_F_EXPR)\n\t\t\tpriv->expr = true;\n\t}\n\n\tset = nft_set_lookup_global(ctx->net, ctx->table,\n\t\t\t\t    tb[NFTA_DYNSET_SET_NAME],\n\t\t\t\t    tb[NFTA_DYNSET_SET_ID], genmask);\n\tif (IS_ERR(set))\n\t\treturn PTR_ERR(set);\n\n\tif (set->flags & NFT_SET_OBJECT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (set->ops->update == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\tif (set->flags & NFT_SET_CONSTANT)\n\t\treturn -EBUSY;\n\n\tpriv->op = ntohl(nla_get_be32(tb[NFTA_DYNSET_OP]));\n\tif (priv->op > NFT_DYNSET_OP_DELETE)\n\t\treturn -EOPNOTSUPP;\n\n\ttimeout = 0;\n\tif (tb[NFTA_DYNSET_TIMEOUT] != NULL) {\n\t\tif (!(set->flags & NFT_SET_TIMEOUT))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\terr = nf_msecs_to_jiffies64(tb[NFTA_DYNSET_TIMEOUT], &timeout);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = nft_parse_register_load(tb[NFTA_DYNSET_SREG_KEY], &priv->sreg_key,\n\t\t\t\t      set->klen);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[NFTA_DYNSET_SREG_DATA] != NULL) {\n\t\tif (!(set->flags & NFT_SET_MAP))\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (set->dtype == NFT_DATA_VERDICT)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\terr = nft_parse_register_load(tb[NFTA_DYNSET_SREG_DATA],\n\t\t\t\t\t      &priv->sreg_data, set->dlen);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else if (set->flags & NFT_SET_MAP)\n\t\treturn -EINVAL;\n\n\tif ((tb[NFTA_DYNSET_EXPR] || tb[NFTA_DYNSET_EXPRESSIONS]) &&\n\t    !(set->flags & NFT_SET_EVAL))\n\t\treturn -EINVAL;\n\n\tif (tb[NFTA_DYNSET_EXPR]) {\n\t\tstruct nft_expr *dynset_expr;\n\n\t\tdynset_expr = nft_dynset_expr_alloc(ctx, set,\n\t\t\t\t\t\t    tb[NFTA_DYNSET_EXPR], 0);\n\t\tif (IS_ERR(dynset_expr))\n\t\t\treturn PTR_ERR(dynset_expr);\n\n\t\tpriv->num_exprs++;\n\t\tpriv->expr_array[0] = dynset_expr;\n\n\t\tif (set->num_exprs > 1 ||\n\t\t    (set->num_exprs == 1 &&\n\t\t     dynset_expr->ops != set->exprs[0]->ops)) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err_expr_free;\n\t\t}\n\t} else if (tb[NFTA_DYNSET_EXPRESSIONS]) {\n\t\tstruct nft_expr *dynset_expr;\n\t\tstruct nlattr *tmp;\n\t\tint left;\n\n\t\tif (!priv->expr)\n\t\t\treturn -EINVAL;\n\n\t\ti = 0;\n\t\tnla_for_each_nested(tmp, tb[NFTA_DYNSET_EXPRESSIONS], left) {\n\t\t\tif (i == NFT_SET_EXPR_MAX) {\n\t\t\t\terr = -E2BIG;\n\t\t\t\tgoto err_expr_free;\n\t\t\t}\n\t\t\tif (nla_type(tmp) != NFTA_LIST_ELEM) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto err_expr_free;\n\t\t\t}\n\t\t\tdynset_expr = nft_dynset_expr_alloc(ctx, set, tmp, i);\n\t\t\tif (IS_ERR(dynset_expr)) {\n\t\t\t\terr = PTR_ERR(dynset_expr);\n\t\t\t\tgoto err_expr_free;\n\t\t\t}\n\t\t\tpriv->expr_array[i] = dynset_expr;\n\t\t\tpriv->num_exprs++;\n\n\t\t\tif (set->num_exprs &&\n\t\t\t    dynset_expr->ops != set->exprs[i]->ops) {\n\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\tgoto err_expr_free;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tif (set->num_exprs && set->num_exprs != i) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err_expr_free;\n\t\t}\n\t} else if (set->num_exprs > 0) {\n\t\terr = nft_set_elem_expr_clone(ctx, set, priv->expr_array);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tpriv->num_exprs = set->num_exprs;\n\t}\n\n\tnft_set_ext_prepare(&priv->tmpl);\n\tnft_set_ext_add_length(&priv->tmpl, NFT_SET_EXT_KEY, set->klen);\n\tif (set->flags & NFT_SET_MAP)\n\t\tnft_set_ext_add_length(&priv->tmpl, NFT_SET_EXT_DATA, set->dlen);\n\n\tif (priv->num_exprs)\n\t\tnft_dynset_ext_add_expr(priv);\n\n\tif (set->flags & NFT_SET_TIMEOUT) {\n\t\tif (timeout || set->timeout) {\n\t\t\tnft_set_ext_add(&priv->tmpl, NFT_SET_EXT_TIMEOUT);\n\t\t\tnft_set_ext_add(&priv->tmpl, NFT_SET_EXT_EXPIRATION);\n\t\t}\n\t}\n\n\tpriv->timeout = timeout;\n\n\terr = nf_tables_bind_set(ctx, set, &priv->binding);\n\tif (err < 0)\n\t\tgoto err_expr_free;\n\n\tif (set->size == 0)\n\t\tset->size = 0xffff;\n\n\tpriv->set = set;\n\treturn 0;\n\nerr_expr_free:\n\tfor (i = 0; i < priv->num_exprs; i++)\n\t\tnft_expr_destroy(ctx, priv->expr_array[i]);\n\treturn err;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 284,
    "critical_vars": [
      "i"
    ],
    "function": "nft_dynset_init",
    "filename": "linux/CVE-2023-6622/CVE-2023-6622_CWE-476_3701cd390fd731ee7ae8b8006246c8db82c72bea_nft_dynset.c.diff",
    "function_code": "static int nft_dynset_init(const struct nft_ctx *ctx,\n\t\t\t   const struct nft_expr *expr,\n\t\t\t   const struct nlattr * const tb[])\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(ctx->net);\n\tstruct nft_dynset *priv = nft_expr_priv(expr);\n\tu8 genmask = nft_genmask_next(ctx->net);\n\tstruct nft_set *set;\n\tu64 timeout;\n\tint err, i;\n\n\tlockdep_assert_held(&nft_net->commit_mutex);\n\n\tif (tb[NFTA_DYNSET_SET_NAME] == NULL ||\n\t    tb[NFTA_DYNSET_OP] == NULL ||\n\t    tb[NFTA_DYNSET_SREG_KEY] == NULL)\n\t\treturn -EINVAL;\n\n\tif (tb[NFTA_DYNSET_FLAGS]) {\n\t\tu32 flags = ntohl(nla_get_be32(tb[NFTA_DYNSET_FLAGS]));\n\t\tif (flags & ~(NFT_DYNSET_F_INV | NFT_DYNSET_F_EXPR))\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (flags & NFT_DYNSET_F_INV)\n\t\t\tpriv->invert = true;\n\t\tif (flags & NFT_DYNSET_F_EXPR)\n\t\t\tpriv->expr = true;\n\t}\n\n\tset = nft_set_lookup_global(ctx->net, ctx->table,\n\t\t\t\t    tb[NFTA_DYNSET_SET_NAME],\n\t\t\t\t    tb[NFTA_DYNSET_SET_ID], genmask);\n\tif (IS_ERR(set))\n\t\treturn PTR_ERR(set);\n\n\tif (set->flags & NFT_SET_OBJECT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (set->ops->update == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\tif (set->flags & NFT_SET_CONSTANT)\n\t\treturn -EBUSY;\n\n\tpriv->op = ntohl(nla_get_be32(tb[NFTA_DYNSET_OP]));\n\tif (priv->op > NFT_DYNSET_OP_DELETE)\n\t\treturn -EOPNOTSUPP;\n\n\ttimeout = 0;\n\tif (tb[NFTA_DYNSET_TIMEOUT] != NULL) {\n\t\tif (!(set->flags & NFT_SET_TIMEOUT))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\terr = nf_msecs_to_jiffies64(tb[NFTA_DYNSET_TIMEOUT], &timeout);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = nft_parse_register_load(tb[NFTA_DYNSET_SREG_KEY], &priv->sreg_key,\n\t\t\t\t      set->klen);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[NFTA_DYNSET_SREG_DATA] != NULL) {\n\t\tif (!(set->flags & NFT_SET_MAP))\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (set->dtype == NFT_DATA_VERDICT)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\terr = nft_parse_register_load(tb[NFTA_DYNSET_SREG_DATA],\n\t\t\t\t\t      &priv->sreg_data, set->dlen);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else if (set->flags & NFT_SET_MAP)\n\t\treturn -EINVAL;\n\n\tif ((tb[NFTA_DYNSET_EXPR] || tb[NFTA_DYNSET_EXPRESSIONS]) &&\n\t    !(set->flags & NFT_SET_EVAL))\n\t\treturn -EINVAL;\n\n\tif (tb[NFTA_DYNSET_EXPR]) {\n\t\tstruct nft_expr *dynset_expr;\n\n\t\tdynset_expr = nft_dynset_expr_alloc(ctx, set,\n\t\t\t\t\t\t    tb[NFTA_DYNSET_EXPR], 0);\n\t\tif (IS_ERR(dynset_expr))\n\t\t\treturn PTR_ERR(dynset_expr);\n\n\t\tpriv->num_exprs++;\n\t\tpriv->expr_array[0] = dynset_expr;\n\n\t\tif (set->num_exprs > 1 ||\n\t\t    (set->num_exprs == 1 &&\n\t\t     dynset_expr->ops != set->exprs[0]->ops)) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err_expr_free;\n\t\t}\n\t} else if (tb[NFTA_DYNSET_EXPRESSIONS]) {\n\t\tstruct nft_expr *dynset_expr;\n\t\tstruct nlattr *tmp;\n\t\tint left;\n\n\t\tif (!priv->expr)\n\t\t\treturn -EINVAL;\n\n\t\ti = 0;\n\t\tnla_for_each_nested(tmp, tb[NFTA_DYNSET_EXPRESSIONS], left) {\n\t\t\tif (i == NFT_SET_EXPR_MAX) {\n\t\t\t\terr = -E2BIG;\n\t\t\t\tgoto err_expr_free;\n\t\t\t}\n\t\t\tif (nla_type(tmp) != NFTA_LIST_ELEM) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto err_expr_free;\n\t\t\t}\n\t\t\tdynset_expr = nft_dynset_expr_alloc(ctx, set, tmp, i);\n\t\t\tif (IS_ERR(dynset_expr)) {\n\t\t\t\terr = PTR_ERR(dynset_expr);\n\t\t\t\tgoto err_expr_free;\n\t\t\t}\n\t\t\tpriv->expr_array[i] = dynset_expr;\n\t\t\tpriv->num_exprs++;\n\n\t\t\tif (set->num_exprs) {\n\t\t\t\tif (i >= set->num_exprs) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto err_expr_free;\n\t\t\t\t}\n\t\t\t\tif (dynset_expr->ops != set->exprs[i]->ops) {\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto err_expr_free;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tif (set->num_exprs && set->num_exprs != i) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err_expr_free;\n\t\t}\n\t} else if (set->num_exprs > 0) {\n\t\terr = nft_set_elem_expr_clone(ctx, set, priv->expr_array);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tpriv->num_exprs = set->num_exprs;\n\t}\n\n\tnft_set_ext_prepare(&priv->tmpl);\n\tnft_set_ext_add_length(&priv->tmpl, NFT_SET_EXT_KEY, set->klen);\n\tif (set->flags & NFT_SET_MAP)\n\t\tnft_set_ext_add_length(&priv->tmpl, NFT_SET_EXT_DATA, set->dlen);\n\n\tif (priv->num_exprs)\n\t\tnft_dynset_ext_add_expr(priv);\n\n\tif (set->flags & NFT_SET_TIMEOUT) {\n\t\tif (timeout || set->timeout) {\n\t\t\tnft_set_ext_add(&priv->tmpl, NFT_SET_EXT_TIMEOUT);\n\t\t\tnft_set_ext_add(&priv->tmpl, NFT_SET_EXT_EXPIRATION);\n\t\t}\n\t}\n\n\tpriv->timeout = timeout;\n\n\terr = nf_tables_bind_set(ctx, set, &priv->binding);\n\tif (err < 0)\n\t\tgoto err_expr_free;\n\n\tif (set->size == 0)\n\t\tset->size = 0xffff;\n\n\tpriv->set = set;\n\treturn 0;\n\nerr_expr_free:\n\tfor (i = 0; i < priv->num_exprs; i++)\n\t\tnft_expr_destroy(ctx, priv->expr_array[i]);\n\treturn err;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 880,
    "critical_vars": [
      "rm->atomic.op_active"
    ],
    "function": "rds_cmsg_atomic",
    "filename": "linux/CVE-2018-5333/CVE-2018-5333_CWE-476_7d11f77f84b27cef452cee332f4e469503084737_rdma.c.diff",
    "function_code": "int rds_cmsg_atomic(struct rds_sock *rs, struct rds_message *rm,\n\t\t    struct cmsghdr *cmsg)\n{\n\tstruct page *page = NULL;\n\tstruct rds_atomic_args *args;\n\tint ret = 0;\n\n\tif (cmsg->cmsg_len < CMSG_LEN(sizeof(struct rds_atomic_args))\n\t || rm->atomic.op_active)\n\t\treturn -EINVAL;\n\n\targs = CMSG_DATA(cmsg);\n\n\t/* Nonmasked & masked cmsg ops converted to masked hw ops */\n\tswitch (cmsg->cmsg_type) {\n\tcase RDS_CMSG_ATOMIC_FADD:\n\t\trm->atomic.op_type = RDS_ATOMIC_TYPE_FADD;\n\t\trm->atomic.op_m_fadd.add = args->fadd.add;\n\t\trm->atomic.op_m_fadd.nocarry_mask = 0;\n\t\tbreak;\n\tcase RDS_CMSG_MASKED_ATOMIC_FADD:\n\t\trm->atomic.op_type = RDS_ATOMIC_TYPE_FADD;\n\t\trm->atomic.op_m_fadd.add = args->m_fadd.add;\n\t\trm->atomic.op_m_fadd.nocarry_mask = args->m_fadd.nocarry_mask;\n\t\tbreak;\n\tcase RDS_CMSG_ATOMIC_CSWP:\n\t\trm->atomic.op_type = RDS_ATOMIC_TYPE_CSWP;\n\t\trm->atomic.op_m_cswp.compare = args->cswp.compare;\n\t\trm->atomic.op_m_cswp.swap = args->cswp.swap;\n\t\trm->atomic.op_m_cswp.compare_mask = ~0;\n\t\trm->atomic.op_m_cswp.swap_mask = ~0;\n\t\tbreak;\n\tcase RDS_CMSG_MASKED_ATOMIC_CSWP:\n\t\trm->atomic.op_type = RDS_ATOMIC_TYPE_CSWP;\n\t\trm->atomic.op_m_cswp.compare = args->m_cswp.compare;\n\t\trm->atomic.op_m_cswp.swap = args->m_cswp.swap;\n\t\trm->atomic.op_m_cswp.compare_mask = args->m_cswp.compare_mask;\n\t\trm->atomic.op_m_cswp.swap_mask = args->m_cswp.swap_mask;\n\t\tbreak;\n\tdefault:\n\t\tBUG(); /* should never happen */\n\t}\n\n\trm->atomic.op_notify = !!(args->flags & RDS_RDMA_NOTIFY_ME);\n\trm->atomic.op_silent = !!(args->flags & RDS_RDMA_SILENT);\n\trm->atomic.op_active = 1;\n\trm->atomic.op_recverr = rs->rs_recverr;\n\trm->atomic.op_sg = rds_message_alloc_sgs(rm, 1);\n\tif (!rm->atomic.op_sg) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t/* verify 8 byte-aligned */\n\tif (args->local_addr & 0x7) {\n\t\tret = -EFAULT;\n\t\tgoto err;\n\t}\n\n\tret = rds_pin_pages(args->local_addr, 1, &page, 1);\n\tif (ret != 1)\n\t\tgoto err;\n\tret = 0;\n\n\tsg_set_page(rm->atomic.op_sg, page, 8, offset_in_page(args->local_addr));\n\n\tif (rm->atomic.op_notify || rm->atomic.op_recverr) {\n\t\t/* We allocate an uninitialized notifier here, because\n\t\t * we don't want to do that in the completion handler. We\n\t\t * would have to use GFP_ATOMIC there, and don't want to deal\n\t\t * with failed allocations.\n\t\t */\n\t\trm->atomic.op_notifier = kmalloc(sizeof(*rm->atomic.op_notifier), GFP_KERNEL);\n\t\tif (!rm->atomic.op_notifier) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\trm->atomic.op_notifier->n_user_token = args->user_token;\n\t\trm->atomic.op_notifier->n_status = RDS_RDMA_SUCCESS;\n\t}\n\n\trm->atomic.op_rkey = rds_rdma_cookie_key(args->cookie);\n\trm->atomic.op_remote_addr = args->remote_addr + rds_rdma_cookie_offset(args->cookie);\n\n\treturn ret;\nerr:\n\tif (page)\n\t\tput_page(page);\n\trm->atomic.op_active = 0;\n\tkfree(rm->atomic.op_notifier);\n\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 334,
    "critical_vars": [
      "stackidx"
    ],
    "function": "ipt_do_table",
    "filename": "linux/CVE-2018-1065/CVE-2018-1065_CWE-476_57ebd808a97d7c5b1e1afb937c2db22beba3c1f8_ip_tables.c.diff",
    "function_code": "ipt_do_table(struct sk_buff *skb,\n\t     const struct nf_hook_state *state,\n\t     struct xt_table *table)\n{\n\tunsigned int hook = state->hook;\n\tstatic const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));\n\tconst struct iphdr *ip;\n\t/* Initializing verdict to NF_DROP keeps gcc happy. */\n\tunsigned int verdict = NF_DROP;\n\tconst char *indev, *outdev;\n\tconst void *table_base;\n\tstruct ipt_entry *e, **jumpstack;\n\tunsigned int stackidx, cpu;\n\tconst struct xt_table_info *private;\n\tstruct xt_action_param acpar;\n\tunsigned int addend;\n\n\t/* Initialization */\n\tstackidx = 0;\n\tip = ip_hdr(skb);\n\tindev = state->in ? state->in->name : nulldevname;\n\toutdev = state->out ? state->out->name : nulldevname;\n\t/* We handle fragments by dealing with the first fragment as\n\t * if it was a normal packet.  All other fragments are treated\n\t * normally, except that they will NEVER match rules that ask\n\t * things we don't know, ie. tcp syn flag or ports).  If the\n\t * rule is also a fragment-specific rule, non-fragments won't\n\t * match it. */\n\tacpar.fragoff = ntohs(ip->frag_off) & IP_OFFSET;\n\tacpar.thoff   = ip_hdrlen(skb);\n\tacpar.hotdrop = false;\n\tacpar.state   = state;\n\n\tWARN_ON(!(table->valid_hooks & (1 << hook)));\n\tlocal_bh_disable();\n\taddend = xt_write_recseq_begin();\n\tprivate = READ_ONCE(table->private); /* Address dependency. */\n\tcpu        = smp_processor_id();\n\ttable_base = private->entries;\n\tjumpstack  = (struct ipt_entry **)private->jumpstack[cpu];\n\n\t/* Switch to alternate jumpstack if we're being invoked via TEE.\n\t * TEE issues XT_CONTINUE verdict on original skb so we must not\n\t * clobber the jumpstack.\n\t *\n\t * For recursion via REJECT or SYNPROXY the stack will be clobbered\n\t * but it is no problem since absolute verdict is issued by these.\n\t */\n\tif (static_key_false(&xt_tee_enabled))\n\t\tjumpstack += private->stacksize * __this_cpu_read(nf_skb_duplicated);\n\n\te = get_entry(table_base, private->hook_entry[hook]);\n\n\tdo {\n\t\tconst struct xt_entry_target *t;\n\t\tconst struct xt_entry_match *ematch;\n\t\tstruct xt_counters *counter;\n\n\t\tWARN_ON(!e);\n\t\tif (!ip_packet_match(ip, indev, outdev,\n\t\t    &e->ip, acpar.fragoff)) {\n no_match:\n\t\t\te = ipt_next_entry(e);\n\t\t\tcontinue;\n\t\t}\n\n\t\txt_ematch_foreach(ematch, e) {\n\t\t\tacpar.match     = ematch->u.kernel.match;\n\t\t\tacpar.matchinfo = ematch->data;\n\t\t\tif (!acpar.match->match(skb, &acpar))\n\t\t\t\tgoto no_match;\n\t\t}\n\n\t\tcounter = xt_get_this_cpu_counter(&e->counters);\n\t\tADD_COUNTER(*counter, skb->len, 1);\n\n\t\tt = ipt_get_target(e);\n\t\tWARN_ON(!t->u.kernel.target);\n\n#if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE)\n\t\t/* The packet is traced: log it */\n\t\tif (unlikely(skb->nf_trace))\n\t\t\ttrace_packet(state->net, skb, hook, state->in,\n\t\t\t\t     state->out, table->name, private, e);\n#endif\n\t\t/* Standard target? */\n\t\tif (!t->u.kernel.target->target) {\n\t\t\tint v;\n\n\t\t\tv = ((struct xt_standard_target *)t)->verdict;\n\t\t\tif (v < 0) {\n\t\t\t\t/* Pop from stack? */\n\t\t\t\tif (v != XT_RETURN) {\n\t\t\t\t\tverdict = (unsigned int)(-v) - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (stackidx == 0) {\n\t\t\t\t\te = get_entry(table_base,\n\t\t\t\t\t    private->underflow[hook]);\n\t\t\t\t} else {\n\t\t\t\t\te = jumpstack[--stackidx];\n\t\t\t\t\te = ipt_next_entry(e);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (table_base + v != ipt_next_entry(e) &&\n\t\t\t    !(e->ip.flags & IPT_F_GOTO)) {\n\t\t\t\tif (unlikely(stackidx >= private->stacksize)) {\n\t\t\t\t\tverdict = NF_DROP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tjumpstack[stackidx++] = e;\n\t\t\t}\n\n\t\t\te = get_entry(table_base, v);\n\t\t\tcontinue;\n\t\t}\n\n\t\tacpar.target   = t->u.kernel.target;\n\t\tacpar.targinfo = t->data;\n\n\t\tverdict = t->u.kernel.target->target(skb, &acpar);\n\t\tif (verdict == XT_CONTINUE) {\n\t\t\t/* Target might have changed stuff. */\n\t\t\tip = ip_hdr(skb);\n\t\t\te = ipt_next_entry(e);\n\t\t} else {\n\t\t\t/* Verdict */\n\t\t\tbreak;\n\t\t}\n\t} while (!acpar.hotdrop);\n\n\txt_write_recseq_end(addend);\n\tlocal_bh_enable();\n\n\tif (acpar.hotdrop)\n\t\treturn NF_DROP;\n\telse return verdict;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 355,
    "critical_vars": [
      "stackidx"
    ],
    "function": "ip6t_do_table",
    "filename": "linux/CVE-2018-1065/CVE-2018-1065_CWE-476_57ebd808a97d7c5b1e1afb937c2db22beba3c1f8_ip6_tables.c.diff",
    "function_code": "ip6t_do_table(struct sk_buff *skb,\n\t      const struct nf_hook_state *state,\n\t      struct xt_table *table)\n{\n\tunsigned int hook = state->hook;\n\tstatic const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));\n\t/* Initializing verdict to NF_DROP keeps gcc happy. */\n\tunsigned int verdict = NF_DROP;\n\tconst char *indev, *outdev;\n\tconst void *table_base;\n\tstruct ip6t_entry *e, **jumpstack;\n\tunsigned int stackidx, cpu;\n\tconst struct xt_table_info *private;\n\tstruct xt_action_param acpar;\n\tunsigned int addend;\n\n\t/* Initialization */\n\tstackidx = 0;\n\tindev = state->in ? state->in->name : nulldevname;\n\toutdev = state->out ? state->out->name : nulldevname;\n\t/* We handle fragments by dealing with the first fragment as\n\t * if it was a normal packet.  All other fragments are treated\n\t * normally, except that they will NEVER match rules that ask\n\t * things we don't know, ie. tcp syn flag or ports).  If the\n\t * rule is also a fragment-specific rule, non-fragments won't\n\t * match it. */\n\tacpar.hotdrop = false;\n\tacpar.state   = state;\n\n\tWARN_ON(!(table->valid_hooks & (1 << hook)));\n\n\tlocal_bh_disable();\n\taddend = xt_write_recseq_begin();\n\tprivate = READ_ONCE(table->private); /* Address dependency. */\n\tcpu        = smp_processor_id();\n\ttable_base = private->entries;\n\tjumpstack  = (struct ip6t_entry **)private->jumpstack[cpu];\n\n\t/* Switch to alternate jumpstack if we're being invoked via TEE.\n\t * TEE issues XT_CONTINUE verdict on original skb so we must not\n\t * clobber the jumpstack.\n\t *\n\t * For recursion via REJECT or SYNPROXY the stack will be clobbered\n\t * but it is no problem since absolute verdict is issued by these.\n\t */\n\tif (static_key_false(&xt_tee_enabled))\n\t\tjumpstack += private->stacksize * __this_cpu_read(nf_skb_duplicated);\n\n\te = get_entry(table_base, private->hook_entry[hook]);\n\n\tdo {\n\t\tconst struct xt_entry_target *t;\n\t\tconst struct xt_entry_match *ematch;\n\t\tstruct xt_counters *counter;\n\n\t\tWARN_ON(!e);\n\t\tacpar.thoff = 0;\n\t\tif (!ip6_packet_match(skb, indev, outdev, &e->ipv6,\n\t\t    &acpar.thoff, &acpar.fragoff, &acpar.hotdrop)) {\n no_match:\n\t\t\te = ip6t_next_entry(e);\n\t\t\tcontinue;\n\t\t}\n\n\t\txt_ematch_foreach(ematch, e) {\n\t\t\tacpar.match     = ematch->u.kernel.match;\n\t\t\tacpar.matchinfo = ematch->data;\n\t\t\tif (!acpar.match->match(skb, &acpar))\n\t\t\t\tgoto no_match;\n\t\t}\n\n\t\tcounter = xt_get_this_cpu_counter(&e->counters);\n\t\tADD_COUNTER(*counter, skb->len, 1);\n\n\t\tt = ip6t_get_target_c(e);\n\t\tWARN_ON(!t->u.kernel.target);\n\n#if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE)\n\t\t/* The packet is traced: log it */\n\t\tif (unlikely(skb->nf_trace))\n\t\t\ttrace_packet(state->net, skb, hook, state->in,\n\t\t\t\t     state->out, table->name, private, e);\n#endif\n\t\t/* Standard target? */\n\t\tif (!t->u.kernel.target->target) {\n\t\t\tint v;\n\n\t\t\tv = ((struct xt_standard_target *)t)->verdict;\n\t\t\tif (v < 0) {\n\t\t\t\t/* Pop from stack? */\n\t\t\t\tif (v != XT_RETURN) {\n\t\t\t\t\tverdict = (unsigned int)(-v) - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (stackidx == 0)\n\t\t\t\t\te = get_entry(table_base,\n\t\t\t\t\t    private->underflow[hook]);\n\t\t\t\telse\n\t\t\t\t\te = ip6t_next_entry(jumpstack[--stackidx]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (table_base + v != ip6t_next_entry(e) &&\n\t\t\t    !(e->ipv6.flags & IP6T_F_GOTO)) {\n\t\t\t\tif (unlikely(stackidx >= private->stacksize)) {\n\t\t\t\t\tverdict = NF_DROP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tjumpstack[stackidx++] = e;\n\t\t\t}\n\n\t\t\te = get_entry(table_base, v);\n\t\t\tcontinue;\n\t\t}\n\n\t\tacpar.target   = t->u.kernel.target;\n\t\tacpar.targinfo = t->data;\n\n\t\tverdict = t->u.kernel.target->target(skb, &acpar);\n\t\tif (verdict == XT_CONTINUE)\n\t\t\te = ip6t_next_entry(e);\n\t\telse\n\t\t\t/* Verdict */\n\t\t\tbreak;\n\t} while (!acpar.hotdrop);\n\n\txt_write_recseq_end(addend);\n\tlocal_bh_enable();\n\n\tif (acpar.hotdrop)\n\t\treturn NF_DROP;\n\telse return verdict;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 255,
    "critical_vars": [
      "stackidx"
    ],
    "function": "arpt_do_table",
    "filename": "linux/CVE-2018-1065/CVE-2018-1065_CWE-476_57ebd808a97d7c5b1e1afb937c2db22beba3c1f8_arp_tables.c.diff",
    "function_code": "unsigned int arpt_do_table(struct sk_buff *skb,\n\t\t\t   const struct nf_hook_state *state,\n\t\t\t   struct xt_table *table)\n{\n\tunsigned int hook = state->hook;\n\tstatic const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));\n\tunsigned int verdict = NF_DROP;\n\tconst struct arphdr *arp;\n\tstruct arpt_entry *e, **jumpstack;\n\tconst char *indev, *outdev;\n\tconst void *table_base;\n\tunsigned int cpu, stackidx = 0;\n\tconst struct xt_table_info *private;\n\tstruct xt_action_param acpar;\n\tunsigned int addend;\n\n\tif (!pskb_may_pull(skb, arp_hdr_len(skb->dev)))\n\t\treturn NF_DROP;\n\n\tindev = state->in ? state->in->name : nulldevname;\n\toutdev = state->out ? state->out->name : nulldevname;\n\n\tlocal_bh_disable();\n\taddend = xt_write_recseq_begin();\n\tprivate = READ_ONCE(table->private); /* Address dependency. */\n\tcpu     = smp_processor_id();\n\ttable_base = private->entries;\n\tjumpstack  = (struct arpt_entry **)private->jumpstack[cpu];\n\n\t/* No TEE support for arptables, so no need to switch to alternate\n\t * stack.  All targets that reenter must return absolute verdicts.\n\t */\n\te = get_entry(table_base, private->hook_entry[hook]);\n\n\tacpar.state   = state;\n\tacpar.hotdrop = false;\n\n\tarp = arp_hdr(skb);\n\tdo {\n\t\tconst struct xt_entry_target *t;\n\t\tstruct xt_counters *counter;\n\n\t\tif (!arp_packet_match(arp, skb->dev, indev, outdev, &e->arp)) {\n\t\t\te = arpt_next_entry(e);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcounter = xt_get_this_cpu_counter(&e->counters);\n\t\tADD_COUNTER(*counter, arp_hdr_len(skb->dev), 1);\n\n\t\tt = arpt_get_target_c(e);\n\n\t\t/* Standard target? */\n\t\tif (!t->u.kernel.target->target) {\n\t\t\tint v;\n\n\t\t\tv = ((struct xt_standard_target *)t)->verdict;\n\t\t\tif (v < 0) {\n\t\t\t\t/* Pop from stack? */\n\t\t\t\tif (v != XT_RETURN) {\n\t\t\t\t\tverdict = (unsigned int)(-v) - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (stackidx == 0) {\n\t\t\t\t\te = get_entry(table_base,\n\t\t\t\t\t\t      private->underflow[hook]);\n\t\t\t\t} else {\n\t\t\t\t\te = jumpstack[--stackidx];\n\t\t\t\t\te = arpt_next_entry(e);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (table_base + v\n\t\t\t    != arpt_next_entry(e)) {\n\t\t\t\tif (unlikely(stackidx >= private->stacksize)) {\n\t\t\t\t\tverdict = NF_DROP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tjumpstack[stackidx++] = e;\n\t\t\t}\n\n\t\t\te = get_entry(table_base, v);\n\t\t\tcontinue;\n\t\t}\n\n\t\tacpar.target   = t->u.kernel.target;\n\t\tacpar.targinfo = t->data;\n\t\tverdict = t->u.kernel.target->target(skb, &acpar);\n\n\t\tif (verdict == XT_CONTINUE) {\n\t\t\t/* Target might have changed stuff. */\n\t\t\tarp = arp_hdr(skb);\n\t\t\te = arpt_next_entry(e);\n\t\t} else {\n\t\t\t/* Verdict */\n\t\t\tbreak;\n\t\t}\n\t} while (!acpar.hotdrop);\n\txt_write_recseq_end(addend);\n\tlocal_bh_enable();\n\n\tif (acpar.hotdrop)\n\t\treturn NF_DROP;\n\telse\n\t\treturn verdict;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 44,
    "critical_vars": [
      "fm10k_workqueue"
    ],
    "function": "fm10k_init_module",
    "filename": "linux/CVE-2019-15924/CVE-2019-15924_CWE-476_01ca667133d019edc9f0a1f70a272447c84ec41f_fm10k_main.c.diff",
    "function_code": "static int __init fm10k_init_module(void)\n{\n\tpr_info(\"%s - version %s\\n\", fm10k_driver_string, fm10k_driver_version);\n\tpr_info(\"%s\\n\", fm10k_copyright);\n\n\t/* create driver workqueue */\n\tfm10k_workqueue = alloc_workqueue(\"%s\", WQ_MEM_RECLAIM, 0,\n\t\t\t\t\t  fm10k_driver_name);\n\tif (!fm10k_workqueue)\n\t\treturn -ENOMEM;\n\n\tfm10k_dbg_init();\n\n\treturn fm10k_register_pci_driver();\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1427,
    "critical_vars": [
      "sdp->sd_jdesc"
    ],
    "function": "gfs2_evict_inode",
    "filename": "linux/CVE-2023-3212/CVE-2023-3212_CWE-476_504a10d9e46bc37b23d0a1ae2f28973c8516e636_super.c.diff",
    "function_code": "static void gfs2_evict_inode(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct gfs2_sbd *sdp = sb->s_fs_info;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder gh;\n\tint ret;\n\n\tif (inode->i_nlink || sb_rdonly(sb) || !ip->i_no_addr)\n\t\tgoto out;\n\n\t/*\n\t * In case of an incomplete mount, gfs2_evict_inode() may be called for\n\t * system files without having an active journal to write to.  In that\n\t * case, skip the filesystem evict.\n\t */\n\tif (!sdp->sd_jdesc)\n\t\tgoto out;\n\n\tgfs2_holder_mark_uninitialized(&gh);\n\tret = evict_should_delete(inode, &gh);\n\tif (ret == SHOULD_DEFER_EVICTION)\n\t\tgoto out;\n\tif (ret == SHOULD_DELETE_DINODE)\n\t\tret = evict_unlinked_inode(inode);\n\telse\n\t\tret = evict_linked_inode(inode);\n\n\tif (gfs2_rs_active(&ip->i_res))\n\t\tgfs2_rs_deltree(&ip->i_res);\n\n\tif (gfs2_holder_initialized(&gh))\n\t\tgfs2_glock_dq_uninit(&gh);\n\tif (ret && ret != GLR_TRYFAILED && ret != -EROFS)\n\t\tfs_warn(sdp, \"gfs2_evict_inode: %d\\n\", ret);\nout:\n\ttruncate_inode_pages_final(&inode->i_data);\n\tif (ip->i_qadata)\n\t\tgfs2_assert_warn(sdp, ip->i_qadata->qa_ref == 0);\n\tgfs2_rs_deltree(&ip->i_res);\n\tgfs2_ordered_del_inode(ip);\n\tclear_inode(inode);\n\tgfs2_dir_hash_inval(ip);\n\tif (gfs2_holder_initialized(&ip->i_iopen_gh)) {\n\t\tstruct gfs2_glock *gl = ip->i_iopen_gh.gh_gl;\n\n\t\tglock_clear_object(gl, ip);\n\t\tgfs2_glock_hold(gl);\n\t\tip->i_iopen_gh.gh_flags |= GL_NOCACHE;\n\t\tgfs2_glock_dq_uninit(&ip->i_iopen_gh);\n\t\tgfs2_glock_put_eventually(gl);\n\t}\n\tif (ip->i_gl) {\n\t\tglock_clear_object(ip->i_gl, ip);\n\t\twait_on_bit_io(&ip->i_flags, GIF_GLOP_PENDING, TASK_UNINTERRUPTIBLE);\n\t\tgfs2_glock_add_to_lru(ip->i_gl);\n\t\tgfs2_glock_put_eventually(ip->i_gl);\n\t\tip->i_gl = NULL;\n\t}\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 361,
    "critical_vars": [
      "chan",
      "&sa->rc_bdaddr"
    ],
    "function": "rfcomm_sock_bind",
    "filename": "linux/CVE-2015-8956/CVE-2015-8956_CWE-476_951b6a0717db97ce420547222647bcc40bf1eacd_sock.c.diff",
    "function_code": "static int rfcomm_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_len)\n{\n\tstruct sockaddr_rc *sa = (struct sockaddr_rc *) addr;\n\tstruct sock *sk = sock->sk;\n\tint chan = sa->rc_channel;\n\tint err = 0;\n\n\tBT_DBG(\"sk %p %pMR\", sk, &sa->rc_bdaddr);\n\n\tif (!addr || addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != BT_OPEN) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tif (sk->sk_type != SOCK_STREAM) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\twrite_lock(&rfcomm_sk_list.lock);\n\n\tif (chan && __rfcomm_get_listen_sock_by_addr(chan, &sa->rc_bdaddr)) {\n\t\terr = -EADDRINUSE;\n\t} else {\n\t\t/* Save source address */\n\t\tbacpy(&rfcomm_pi(sk)->src, &sa->rc_bdaddr);\n\t\trfcomm_pi(sk)->channel = chan;\n\t\tsk->sk_state = BT_BOUND;\n\t}\n\n\twrite_unlock(&rfcomm_sk_list.lock);\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 364,
    "critical_vars": [
      "&sa.rc_bdaddr",
      "sa.rc_channel"
    ],
    "function": "rfcomm_sock_bind",
    "filename": "linux/CVE-2015-8956/CVE-2015-8956_CWE-476_951b6a0717db97ce420547222647bcc40bf1eacd_sock.c.diff",
    "function_code": "static int rfcomm_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_len)\n{\n\tstruct sockaddr_rc sa;\n\tstruct sock *sk = sock->sk;\n\tint len, err = 0;\n\n\tif (!addr || addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\n\tmemset(&sa, 0, sizeof(sa));\n\tlen = min_t(unsigned int, sizeof(sa), addr_len);\n\tmemcpy(&sa, addr, len);\n\n\tBT_DBG(\"sk %p %pMR\", sk, &sa.rc_bdaddr);\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != BT_OPEN) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tif (sk->sk_type != SOCK_STREAM) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\twrite_lock(&rfcomm_sk_list.lock);\n\n\tif (sa.rc_channel &&\n\t    __rfcomm_get_listen_sock_by_addr(sa.rc_channel, &sa.rc_bdaddr)) {\n\t\terr = -EADDRINUSE;\n\t} else {\n\t\t/* Save source address */\n\t\tbacpy(&rfcomm_pi(sk)->src, &sa.rc_bdaddr);\n\t\trfcomm_pi(sk)->channel = sa.rc_channel;\n\t\tsk->sk_state = BT_BOUND;\n\t}\n\n\twrite_unlock(&rfcomm_sk_list.lock);\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 1588,
    "line_new": 1589,
    "critical_vars": [
      "block_in_file"
    ],
    "function": "f2fs_read_single_page",
    "filename": "linux/CVE-2019-19815/CVE-2019-19815_CWE-476_4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6_data.c.diff",
    "function_code": "static int f2fs_read_single_page(struct inode *inode, struct page *page,\n\t\t\t\t\tunsigned nr_pages,\n\t\t\t\t\tstruct f2fs_map_blocks *map,\n\t\t\t\t\tstruct bio **bio_ret,\n\t\t\t\t\tsector_t *last_block_in_bio,\n\t\t\t\t\tbool is_readahead)\n{\n\tstruct bio *bio = *bio_ret;\n\tconst unsigned blkbits = inode->i_blkbits;\n\tconst unsigned blocksize = 1 << blkbits;\n\tsector_t block_in_file;\n\tsector_t last_block;\n\tsector_t last_block_in_file;\n\tsector_t block_nr;\n\tint ret = 0;\n\n\tblock_in_file = (sector_t)page_index(page);\n\tlast_block = block_in_file + nr_pages;\n\tlast_block_in_file = (i_size_read(inode) + blocksize - 1) >>\n\t\t\t\t\t\t\tblkbits;\n\tif (last_block > last_block_in_file)\n\t\tlast_block = last_block_in_file;\n\n\t/* just zeroing out page which is beyond EOF */\n\tif (block_in_file >= last_block)\n\t\tgoto zero_out;\n\t/*\n\t * Map blocks using the previous result first.\n\t */\n\tif ((map->m_flags & F2FS_MAP_MAPPED) &&\n\t\t\tblock_in_file > map->m_lblk &&\n\t\t\tblock_in_file < (map->m_lblk + map->m_len))\n\t\tgoto got_it;\n\n\t/*\n\t * Then do more f2fs_map_blocks() calls until we are\n\t * done with this page.\n\t */\n\tmap->m_lblk = block_in_file;\n\tmap->m_len = last_block - block_in_file;\n\n\tret = f2fs_map_blocks(inode, map, 0, F2FS_GET_BLOCK_DEFAULT);\n\tif (ret)\n\t\tgoto out;\ngot_it:\n\tif ((map->m_flags & F2FS_MAP_MAPPED)) {\n\t\tblock_nr = map->m_pblk + block_in_file - map->m_lblk;\n\t\tSetPageMappedToDisk(page);\n\n\t\tif (!PageUptodate(page) && (!PageSwapCache(page) &&\n\t\t\t\t\t!cleancache_get_page(page))) {\n\t\t\tSetPageUptodate(page);\n\t\t\tgoto confused;\n\t\t}\n\n\t\tif (!f2fs_is_valid_blkaddr(F2FS_I_SB(inode), block_nr,\n\t\t\t\t\t\tDATA_GENERIC_ENHANCE_READ)) {\n\t\t\tret = -EFSCORRUPTED;\n\t\t\tgoto out;\n\t\t}\n\t} else {\nzero_out:\n\t\tzero_user_segment(page, 0, PAGE_SIZE);\n\t\tif (!PageUptodate(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * This page will go to BIO.  Do we need to send this\n\t * BIO off first?\n\t */\n\tif (bio && (*last_block_in_bio != block_nr - 1 ||\n\t\t!__same_bdev(F2FS_I_SB(inode), block_nr, bio))) {\nsubmit_and_realloc:\n\t\t__submit_bio(F2FS_I_SB(inode), bio, DATA);\n\t\tbio = NULL;\n\t}\n\tif (bio == NULL) {\n\t\tbio = f2fs_grab_read_bio(inode, block_nr, nr_pages,\n\t\t\t\tis_readahead ? REQ_RAHEAD : 0);\n\t\tif (IS_ERR(bio)) {\n\t\t\tret = PTR_ERR(bio);\n\t\t\tbio = NULL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * If the page is under writeback, we need to wait for\n\t * its completion to see the correct decrypted data.\n\t */\n\tf2fs_wait_on_block_writeback(inode, block_nr);\n\n\tif (bio_add_page(bio, page, blocksize, 0) < blocksize)\n\t\tgoto submit_and_realloc;\n\n\tinc_page_count(F2FS_I_SB(inode), F2FS_RD_DATA);\n\tClearPageError(page);\n\t*last_block_in_bio = block_nr;\n\tgoto out;\nconfused:\n\tif (bio) {\n\t\t__submit_bio(F2FS_I_SB(inode), bio, DATA);\n\t\tbio = NULL;\n\t}\n\tunlock_page(page);\nout:\n\t*bio_ret = bio;\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 1721,
    "critical_vars": [
      "page"
    ],
    "function": "f2fs_mpage_readpages",
    "filename": "linux/CVE-2019-19815/CVE-2019-19815_CWE-476_4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6_data.c.diff",
    "function_code": "static int f2fs_mpage_readpages(struct address_space *mapping,\n\t\t\tstruct list_head *pages, struct page *page,\n\t\t\tunsigned nr_pages, bool is_readahead)\n{\n\tstruct bio *bio = NULL;\n\tsector_t last_block_in_bio = 0;\n\tstruct inode *inode = mapping->host;\n\tstruct f2fs_map_blocks map;\n\tint ret = 0;\n\n\tmap.m_pblk = 0;\n\tmap.m_lblk = 0;\n\tmap.m_len = 0;\n\tmap.m_flags = 0;\n\tmap.m_next_pgofs = NULL;\n\tmap.m_next_extent = NULL;\n\tmap.m_seg_type = NO_CHECK_TYPE;\n\tmap.m_may_create = false;\n\n\tfor (; nr_pages; nr_pages--) {\n\t\tif (pages) {\n\t\t\tpage = list_last_entry(pages, struct page, lru);\n\n\t\t\tprefetchw(&page->flags);\n\t\t\tlist_del(&page->lru);\n\t\t\tif (add_to_page_cache_lru(page, mapping,\n\t\t\t\t\t\t  page_index(page),\n\t\t\t\t\t\t  readahead_gfp_mask(mapping)))\n\t\t\t\tgoto next_page;\n\t\t}\n\n\t\tret = f2fs_read_single_page(inode, page, nr_pages, &map, &bio,\n\t\t\t\t\t&last_block_in_bio, is_readahead);\n\t\tif (ret) {\n\t\t\tSetPageError(page);\n\t\t\tzero_user_segment(page, 0, PAGE_SIZE);\n\t\t\tunlock_page(page);\n\t\t}\nnext_page:\n\t\tif (pages)\n\t\t\tput_page(page);\n\t}\n\tBUG_ON(pages && !list_empty(pages));\n\tif (bio)\n\t\t__submit_bio(F2FS_I_SB(inode), bio, DATA);\n\treturn pages ? 0 : ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 1752,
    "line_new": 1754,
    "critical_vars": [
      "ret"
    ],
    "function": "f2fs_read_data_page",
    "filename": "linux/CVE-2019-19815/CVE-2019-19815_CWE-476_4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6_data.c.diff",
    "function_code": "static int f2fs_read_data_page(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page_file_mapping(page)->host;\n\tint ret = -EAGAIN;\n\n\ttrace_f2fs_readpage(page, DATA);\n\n\t/* If the file has inline data, try to read it directly */\n\tif (f2fs_has_inline_data(inode))\n\t\tret = f2fs_read_inline_data(inode, page);\n\tif (ret == -EAGAIN)\n\t\tret = f2fs_mpage_readpages(page_file_mapping(page),\n\t\t\t\t\t\tNULL, page, 1, false);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 2767,
    "critical_vars": [
      "res.fi"
    ],
    "function": "inet_rtm_getroute",
    "filename": "linux/CVE-2017-13686/CVE-2017-13686_CWE-476_bc3aae2bbac46dd894c89db5d5e98f7f0ef9e205_route.c.diff",
    "function_code": "static int inet_rtm_getroute(struct sk_buff *in_skb, struct nlmsghdr *nlh,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct rtmsg *rtm;\n\tstruct nlattr *tb[RTA_MAX+1];\n\tstruct fib_result res = {};\n\tstruct rtable *rt = NULL;\n\tstruct flowi4 fl4;\n\t__be32 dst = 0;\n\t__be32 src = 0;\n\tu32 iif;\n\tint err;\n\tint mark;\n\tstruct sk_buff *skb;\n\tu32 table_id = RT_TABLE_MAIN;\n\tkuid_t uid;\n\n\terr = nlmsg_parse(nlh, sizeof(*rtm), tb, RTA_MAX, rtm_ipv4_policy,\n\t\t\t  extack);\n\tif (err < 0)\n\t\tgoto errout;\n\n\trtm = nlmsg_data(nlh);\n\n\tskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!skb) {\n\t\terr = -ENOBUFS;\n\t\tgoto errout;\n\t}\n\n\t/* Reserve room for dummy headers, this skb can pass\n\t   through good chunk of routing engine.\n\t */\n\tskb_reset_mac_header(skb);\n\tskb_reset_network_header(skb);\n\n\tsrc = tb[RTA_SRC] ? nla_get_in_addr(tb[RTA_SRC]) : 0;\n\tdst = tb[RTA_DST] ? nla_get_in_addr(tb[RTA_DST]) : 0;\n\tiif = tb[RTA_IIF] ? nla_get_u32(tb[RTA_IIF]) : 0;\n\tmark = tb[RTA_MARK] ? nla_get_u32(tb[RTA_MARK]) : 0;\n\tif (tb[RTA_UID])\n\t\tuid = make_kuid(current_user_ns(), nla_get_u32(tb[RTA_UID]));\n\telse\n\t\tuid = (iif ? INVALID_UID : current_uid());\n\n\t/* Bugfix: need to give ip_route_input enough of an IP header to\n\t * not gag.\n\t */\n\tip_hdr(skb)->protocol = IPPROTO_UDP;\n\tip_hdr(skb)->saddr = src;\n\tip_hdr(skb)->daddr = dst;\n\n\tskb_reserve(skb, MAX_HEADER + sizeof(struct iphdr));\n\n\tmemset(&fl4, 0, sizeof(fl4));\n\tfl4.daddr = dst;\n\tfl4.saddr = src;\n\tfl4.flowi4_tos = rtm->rtm_tos;\n\tfl4.flowi4_oif = tb[RTA_OIF] ? nla_get_u32(tb[RTA_OIF]) : 0;\n\tfl4.flowi4_mark = mark;\n\tfl4.flowi4_uid = uid;\n\n\trcu_read_lock();\n\n\tif (iif) {\n\t\tstruct net_device *dev;\n\n\t\tdev = dev_get_by_index_rcu(net, iif);\n\t\tif (!dev) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto errout_free;\n\t\t}\n\n\t\tskb->protocol\t= htons(ETH_P_IP);\n\t\tskb->dev\t= dev;\n\t\tskb->mark\t= mark;\n\t\terr = ip_route_input_rcu(skb, dst, src, rtm->rtm_tos,\n\t\t\t\t\t dev, &res);\n\n\t\trt = skb_rtable(skb);\n\t\tif (err == 0 && rt->dst.error)\n\t\t\terr = -rt->dst.error;\n\t} else {\n\t\trt = ip_route_output_key_hash_rcu(net, &fl4, &res, skb);\n\t\terr = 0;\n\t\tif (IS_ERR(rt))\n\t\t\terr = PTR_ERR(rt);\n\t\telse\n\t\t\tskb_dst_set(skb, &rt->dst);\n\t}\n\n\tif (err)\n\t\tgoto errout_free;\n\n\tif (rtm->rtm_flags & RTM_F_NOTIFY)\n\t\trt->rt_flags |= RTCF_NOTIFY;\n\n\tif (rtm->rtm_flags & RTM_F_LOOKUP_TABLE)\n\t\ttable_id = rt->rt_table_id;\n\n\tif (rtm->rtm_flags & RTM_F_FIB_MATCH) {\n\t\tif (!res.fi) {\n\t\t\terr = fib_props[res.type].error;\n\t\t\tif (!err)\n\t\t\t\terr = -EHOSTUNREACH;\n\t\t\tgoto errout_free;\n\t\t}\n\t\terr = fib_dump_info(skb, NETLINK_CB(in_skb).portid,\n\t\t\t\t    nlh->nlmsg_seq, RTM_NEWROUTE, table_id,\n\t\t\t\t    rt->rt_type, res.prefix, res.prefixlen,\n\t\t\t\t    fl4.flowi4_tos, res.fi, 0);\n\t} else {\n\t\terr = rt_fill_info(net, dst, src, table_id, &fl4, skb,\n\t\t\t\t   NETLINK_CB(in_skb).portid, nlh->nlmsg_seq);\n\t}\n\tif (err < 0)\n\t\tgoto errout_free;\n\n\trcu_read_unlock();\n\n\terr = rtnl_unicast(skb, net, NETLINK_CB(in_skb).portid);\nerrout:\n\treturn err;\n\nerrout_free:\n\trcu_read_unlock();\n\tkfree_skb(skb);\n\tgoto errout;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 914,
    "critical_vars": [
      "info->attrs[NFC_ATTR_TARGET_INDEX]"
    ],
    "function": "nfc_genl_deactivate_target",
    "filename": "linux/CVE-2019-12984/CVE-2019-12984_CWE-476_385097a3675749cbc9e97c085c0e5dfe4269ca51_netlink.c.diff",
    "function_code": "static int nfc_genl_deactivate_target(struct sk_buff *skb,\n\t\t\t\t      struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tu32 device_idx, target_idx;\n\tint rc;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_TARGET_INDEX])\n\t\treturn -EINVAL;\n\n\tdevice_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(device_idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\ttarget_idx = nla_get_u32(info->attrs[NFC_ATTR_TARGET_INDEX]);\n\n\trc = nfc_deactivate_target(dev, target_idx, NFC_TARGET_MODE_SLEEP);\n\n\tnfc_put_device(dev);\n\treturn rc;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 117,
    "line_new": 117,
    "critical_vars": [
      "page"
    ],
    "function": "module_gzip_decompress",
    "filename": "linux/CVE-2023-22997/CVE-2023-22997_CWE-476_45af1d7aae7d5520d2858f8517a1342646f015db_decompress.c.diff",
    "function_code": "static ssize_t module_gzip_decompress(struct load_info *info,\n\t\t\t\t      const void *buf, size_t size)\n{\n\tstruct z_stream_s s = { 0 };\n\tsize_t new_size = 0;\n\tsize_t gzip_hdr_len;\n\tssize_t retval;\n\tint rc;\n\n\tgzip_hdr_len = module_gzip_header_len(buf, size);\n\tif (!gzip_hdr_len) {\n\t\tpr_err(\"not a gzip compressed module\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ts.next_in = buf + gzip_hdr_len;\n\ts.avail_in = size - gzip_hdr_len;\n\n\ts.workspace = kmalloc(zlib_inflate_workspacesize(), GFP_KERNEL);\n\tif (!s.workspace)\n\t\treturn -ENOMEM;\n\n\trc = zlib_inflateInit2(&s, -MAX_WBITS);\n\tif (rc != Z_OK) {\n\t\tpr_err(\"failed to initialize decompressor: %d\\n\", rc);\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdo {\n\t\tstruct page *page = module_get_next_page(info);\n\n\t\tif (IS_ERR(page)) {\n\t\t\tretval = PTR_ERR(page);\n\t\t\tgoto out_inflate_end;\n\t\t}\n\n\t\ts.next_out = kmap_local_page(page);\n\t\ts.avail_out = PAGE_SIZE;\n\t\trc = zlib_inflate(&s, 0);\n\t\tkunmap_local(s.next_out);\n\n\t\tnew_size += PAGE_SIZE - s.avail_out;\n\t} while (rc == Z_OK);\n\n\tif (rc != Z_STREAM_END) {\n\t\tpr_err(\"decompression failed with status %d\\n\", rc);\n\t\tretval = -EINVAL;\n\t\tgoto out_inflate_end;\n\t}\n\n\tretval = new_size;\n\nout_inflate_end:\n\tzlib_inflateEnd(&s);\nout:\n\tkfree(s.workspace);\n\treturn retval;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 176,
    "line_new": 176,
    "critical_vars": [
      "page"
    ],
    "function": "module_xz_decompress",
    "filename": "linux/CVE-2023-22997/CVE-2023-22997_CWE-476_45af1d7aae7d5520d2858f8517a1342646f015db_decompress.c.diff",
    "function_code": "static ssize_t module_xz_decompress(struct load_info *info,\n\t\t\t\t    const void *buf, size_t size)\n{\n\tstatic const u8 signature[] = { 0xfd, '7', 'z', 'X', 'Z', 0 };\n\tstruct xz_dec *xz_dec;\n\tstruct xz_buf xz_buf;\n\tenum xz_ret xz_ret;\n\tsize_t new_size = 0;\n\tssize_t retval;\n\n\tif (size < sizeof(signature) ||\n\t    memcmp(buf, signature, sizeof(signature))) {\n\t\tpr_err(\"not an xz compressed module\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\txz_dec = xz_dec_init(XZ_DYNALLOC, (u32)-1);\n\tif (!xz_dec)\n\t\treturn -ENOMEM;\n\n\txz_buf.in_size = size;\n\txz_buf.in = buf;\n\txz_buf.in_pos = 0;\n\n\tdo {\n\t\tstruct page *page = module_get_next_page(info);\n\n\t\tif (IS_ERR(page)) {\n\t\t\tretval = PTR_ERR(page);\n\t\t\tgoto out;\n\t\t}\n\n\t\txz_buf.out = kmap_local_page(page);\n\t\txz_buf.out_pos = 0;\n\t\txz_buf.out_size = PAGE_SIZE;\n\t\txz_ret = xz_dec_run(xz_dec, &xz_buf);\n\t\tkunmap_local(xz_buf.out);\n\n\t\tnew_size += xz_buf.out_pos;\n\t} while (xz_buf.out_pos == PAGE_SIZE && xz_ret == XZ_OK);\n\n\tif (xz_ret != XZ_STREAM_END) {\n\t\tpr_err(\"decompression failed with status %d\\n\", xz_ret);\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tretval = new_size;\n\n out:\n\txz_dec_end(xz_dec);\n\treturn retval;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 317,
    "critical_vars": [
      "*newzone",
      "*oldzone"
    ],
    "function": "migrate_page_move_mapping",
    "filename": "linux/CVE-2016-3070/CVE-2016-3070_CWE-476_42cb14b110a5698ccf26ce59c4441722605a3743_migrate.c.diff",
    "function_code": "int migrate_page_move_mapping(struct address_space *mapping,\n\t\tstruct page *newpage, struct page *page,\n\t\tstruct buffer_head *head, enum migrate_mode mode,\n\t\tint extra_count)\n{\n\tstruct zone *oldzone, *newzone;\n\tint dirty;\n\tint expected_count = 1 + extra_count;\n\tvoid **pslot;\n\n\tif (!mapping) {\n\t\t/* Anonymous page without mapping */\n\t\tif (page_count(page) != expected_count)\n\t\t\treturn -EAGAIN;\n\n\t\t/* No turning back from here */\n\t\tset_page_memcg(newpage, page_memcg(page));\n\t\tnewpage->index = page->index;\n\t\tnewpage->mapping = page->mapping;\n\t\tif (PageSwapBacked(page))\n\t\t\tSetPageSwapBacked(newpage);\n\n\t\treturn MIGRATEPAGE_SUCCESS;\n\t}\n\n\toldzone = page_zone(page);\n\tnewzone = page_zone(newpage);\n\n\tspin_lock_irq(&mapping->tree_lock);\n\n\tpslot = radix_tree_lookup_slot(&mapping->page_tree,\n \t\t\t\t\tpage_index(page));\n\n\texpected_count += 1 + page_has_private(page);\n\tif (page_count(page) != expected_count ||\n\t\tradix_tree_deref_slot_protected(pslot, &mapping->tree_lock) != page) {\n\t\tspin_unlock_irq(&mapping->tree_lock);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (!page_freeze_refs(page, expected_count)) {\n\t\tspin_unlock_irq(&mapping->tree_lock);\n\t\treturn -EAGAIN;\n\t}\n\n\t/*\n\t * In the async migration case of moving a page with buffers, lock the\n\t * buffers using trylock before the mapping is moved. If the mapping\n\t * was moved, we later failed to lock the buffers and could not move\n\t * the mapping back due to an elevated page count, we would have to\n\t * block waiting on other references to be dropped.\n\t */\n\tif (mode == MIGRATE_ASYNC && head &&\n\t\t\t!buffer_migrate_lock_buffers(head, mode)) {\n\t\tpage_unfreeze_refs(page, expected_count);\n\t\tspin_unlock_irq(&mapping->tree_lock);\n\t\treturn -EAGAIN;\n\t}\n\n\t/*\n\t * Now we know that no one else is looking at the page:\n\t * no turning back from here.\n\t */\n\tset_page_memcg(newpage, page_memcg(page));\n\tnewpage->index = page->index;\n\tnewpage->mapping = page->mapping;\n\tif (PageSwapBacked(page))\n\t\tSetPageSwapBacked(newpage);\n\n\tget_page(newpage);\t/* add cache reference */\n\tif (PageSwapCache(page)) {\n\t\tSetPageSwapCache(newpage);\n\t\tset_page_private(newpage, page_private(page));\n\t}\n\n\t/* Move dirty while page refs frozen and newpage not yet exposed */\n\tdirty = PageDirty(page);\n\tif (dirty) {\n\t\tClearPageDirty(page);\n\t\tSetPageDirty(newpage);\n\t}\n\n\tradix_tree_replace_slot(pslot, newpage);\n\n\t/*\n\t * Drop cache reference from old page by unfreezing\n\t * to one less reference.\n\t * We know this isn't the last reference.\n\t */\n\tpage_unfreeze_refs(page, expected_count - 1);\n\n\tspin_unlock(&mapping->tree_lock);\n\t/* Leave irq disabled to prevent preemption while updating stats */\n\n\t/*\n\t * If moved to a different zone then also account\n\t * the page for that zone. Other VM counters will be\n\t * taken care of when we establish references to the\n\t * new page and drop references to the old page.\n\t *\n\t * Note that anonymous pages are accounted for\n\t * via NR_FILE_PAGES and NR_ANON_PAGES if they\n\t * are mapped to swap space.\n\t */\n\tif (newzone != oldzone) {\n\t\t__dec_zone_state(oldzone, NR_FILE_PAGES);\n\t\t__inc_zone_state(newzone, NR_FILE_PAGES);\n\t\tif (PageSwapBacked(page) && !PageSwapCache(page)) {\n\t\t\t__dec_zone_state(oldzone, NR_SHMEM);\n\t\t\t__inc_zone_state(newzone, NR_SHMEM);\n\t\t}\n\t\tif (dirty && mapping_cap_account_dirty(mapping)) {\n\t\t\t__dec_zone_state(oldzone, NR_FILE_DIRTY);\n\t\t\t__inc_zone_state(newzone, NR_FILE_DIRTY);\n\t\t}\n\t}\n\tlocal_irq_enable();\n\n\treturn MIGRATEPAGE_SUCCESS;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 400,
    "critical_vars": [
      "page"
    ],
    "function": "migrate_page_move_mapping",
    "filename": "linux/CVE-2016-3070/CVE-2016-3070_CWE-476_42cb14b110a5698ccf26ce59c4441722605a3743_migrate.c.diff",
    "function_code": "int migrate_page_move_mapping(struct address_space *mapping,\n\t\tstruct page *newpage, struct page *page,\n\t\tstruct buffer_head *head, enum migrate_mode mode,\n\t\tint extra_count)\n{\n\tint expected_count = 1 + extra_count;\n\tvoid **pslot;\n\n\tif (!mapping) {\n\t\t/* Anonymous page without mapping */\n\t\tif (page_count(page) != expected_count)\n\t\t\treturn -EAGAIN;\n\n\t\t/* No turning back from here */\n\t\tset_page_memcg(newpage, page_memcg(page));\n\t\tnewpage->index = page->index;\n\t\tnewpage->mapping = page->mapping;\n\t\tif (PageSwapBacked(page))\n\t\t\tSetPageSwapBacked(newpage);\n\n\t\treturn MIGRATEPAGE_SUCCESS;\n\t}\n\n\tspin_lock_irq(&mapping->tree_lock);\n\n\tpslot = radix_tree_lookup_slot(&mapping->page_tree,\n \t\t\t\t\tpage_index(page));\n\n\texpected_count += 1 + page_has_private(page);\n\tif (page_count(page) != expected_count ||\n\t\tradix_tree_deref_slot_protected(pslot, &mapping->tree_lock) != page) {\n\t\tspin_unlock_irq(&mapping->tree_lock);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (!page_freeze_refs(page, expected_count)) {\n\t\tspin_unlock_irq(&mapping->tree_lock);\n\t\treturn -EAGAIN;\n\t}\n\n\t/*\n\t * In the async migration case of moving a page with buffers, lock the\n\t * buffers using trylock before the mapping is moved. If the mapping\n\t * was moved, we later failed to lock the buffers and could not move\n\t * the mapping back due to an elevated page count, we would have to\n\t * block waiting on other references to be dropped.\n\t */\n\tif (mode == MIGRATE_ASYNC && head &&\n\t\t\t!buffer_migrate_lock_buffers(head, mode)) {\n\t\tpage_unfreeze_refs(page, expected_count);\n\t\tspin_unlock_irq(&mapping->tree_lock);\n\t\treturn -EAGAIN;\n\t}\n\n\t/*\n\t * Now we know that no one else is looking at the page:\n\t * no turning back from here.\n\t */\n\tset_page_memcg(newpage, page_memcg(page));\n\tnewpage->index = page->index;\n\tnewpage->mapping = page->mapping;\n\tif (PageSwapBacked(page))\n\t\tSetPageSwapBacked(newpage);\n\n\tget_page(newpage);\t/* add cache reference */\n\tif (PageSwapCache(page)) {\n\t\tSetPageSwapCache(newpage);\n\t\tset_page_private(newpage, page_private(page));\n\t}\n\n\tradix_tree_replace_slot(pslot, newpage);\n\n\t/*\n\t * Drop cache reference from old page by unfreezing\n\t * to one less reference.\n\t * We know this isn't the last reference.\n\t */\n\tpage_unfreeze_refs(page, expected_count - 1);\n\n\t/*\n\t * If moved to a different zone then also account\n\t * the page for that zone. Other VM counters will be\n\t * taken care of when we establish references to the\n\t * new page and drop references to the old page.\n\t *\n\t * Note that anonymous pages are accounted for\n\t * via NR_FILE_PAGES and NR_ANON_PAGES if they\n\t * are mapped to swap space.\n\t */\n\t__dec_zone_page_state(page, NR_FILE_PAGES);\n\t__inc_zone_page_state(newpage, NR_FILE_PAGES);\n\tif (!PageSwapCache(page) && PageSwapBacked(page)) {\n\t\t__dec_zone_page_state(page, NR_SHMEM);\n\t\t__inc_zone_page_state(newpage, NR_SHMEM);\n\t}\n\tspin_unlock_irq(&mapping->tree_lock);\n\n\treturn MIGRATEPAGE_SUCCESS;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 528,
    "critical_vars": [
      "page"
    ],
    "function": "migrate_page_copy",
    "filename": "linux/CVE-2016-3070/CVE-2016-3070_CWE-476_42cb14b110a5698ccf26ce59c4441722605a3743_migrate.c.diff",
    "function_code": "void migrate_page_copy(struct page *newpage, struct page *page)\n{\n\tint cpupid;\n\n\tif (PageHuge(page) || PageTransHuge(page))\n\t\tcopy_huge_page(newpage, page);\n\telse\n\t\tcopy_highpage(newpage, page);\n\n\tif (PageError(page))\n\t\tSetPageError(newpage);\n\tif (PageReferenced(page))\n\t\tSetPageReferenced(newpage);\n\tif (PageUptodate(page))\n\t\tSetPageUptodate(newpage);\n\tif (TestClearPageActive(page)) {\n\t\tVM_BUG_ON_PAGE(PageUnevictable(page), page);\n\t\tSetPageActive(newpage);\n\t} else if (TestClearPageUnevictable(page))\n\t\tSetPageUnevictable(newpage);\n\tif (PageChecked(page))\n\t\tSetPageChecked(newpage);\n\tif (PageMappedToDisk(page))\n\t\tSetPageMappedToDisk(newpage);\n\n\tif (PageDirty(page)) {\n\t\tclear_page_dirty_for_io(page);\n\t\t/*\n\t\t * Want to mark the page and the radix tree as dirty, and\n\t\t * redo the accounting that clear_page_dirty_for_io undid,\n\t\t * but we can't use set_page_dirty because that function\n\t\t * is actually a signal that all of the page has become dirty.\n\t\t * Whereas only part of our page may be dirty.\n\t\t */\n\t\tif (PageSwapBacked(page))\n\t\t\tSetPageDirty(newpage);\n\t\telse\n\t\t\t__set_page_dirty_nobuffers(newpage);\n \t}\n\n\tif (page_is_young(page))\n\t\tset_page_young(newpage);\n\tif (page_is_idle(page))\n\t\tset_page_idle(newpage);\n\n\t/*\n\t * Copy NUMA information to the new page, to prevent over-eager\n\t * future migrations of this same page.\n\t */\n\tcpupid = page_cpupid_xchg_last(page, -1);\n\tpage_cpupid_xchg_last(newpage, cpupid);\n\n\tksm_migrate_page(newpage, page);\n\t/*\n\t * Please do not reorder this without considering how mm/ksm.c's\n\t * get_ksm_page() depends upon ksm_migrate_page() and PageSwapCache().\n\t */\n\tif (PageSwapCache(page))\n\t\tClearPageSwapCache(page);\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\n\t/*\n\t * If any waiters have accumulated on the new page then\n\t * wake them up.\n\t */\n\tif (PageWriteback(newpage))\n\t\tend_page_writeback(newpage);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 551,
    "critical_vars": [
      "newpage"
    ],
    "function": "migrate_page_copy",
    "filename": "linux/CVE-2016-3070/CVE-2016-3070_CWE-476_42cb14b110a5698ccf26ce59c4441722605a3743_migrate.c.diff",
    "function_code": "void migrate_page_copy(struct page *newpage, struct page *page)\n{\n\tint cpupid;\n\n\tif (PageHuge(page) || PageTransHuge(page))\n\t\tcopy_huge_page(newpage, page);\n\telse\n\t\tcopy_highpage(newpage, page);\n\n\tif (PageError(page))\n\t\tSetPageError(newpage);\n\tif (PageReferenced(page))\n\t\tSetPageReferenced(newpage);\n\tif (PageUptodate(page))\n\t\tSetPageUptodate(newpage);\n\tif (TestClearPageActive(page)) {\n\t\tVM_BUG_ON_PAGE(PageUnevictable(page), page);\n\t\tSetPageActive(newpage);\n\t} else if (TestClearPageUnevictable(page))\n\t\tSetPageUnevictable(newpage);\n\tif (PageChecked(page))\n\t\tSetPageChecked(newpage);\n\tif (PageMappedToDisk(page))\n\t\tSetPageMappedToDisk(newpage);\n\n\t/* Move dirty on pages not done by migrate_page_move_mapping() */\n\tif (PageDirty(page))\n\t\tSetPageDirty(newpage);\n\n\tif (page_is_young(page))\n\t\tset_page_young(newpage);\n\tif (page_is_idle(page))\n\t\tset_page_idle(newpage);\n\n\t/*\n\t * Copy NUMA information to the new page, to prevent over-eager\n\t * future migrations of this same page.\n\t */\n\tcpupid = page_cpupid_xchg_last(page, -1);\n\tpage_cpupid_xchg_last(newpage, cpupid);\n\n\tksm_migrate_page(newpage, page);\n\t/*\n\t * Please do not reorder this without considering how mm/ksm.c's\n\t * get_ksm_page() depends upon ksm_migrate_page() and PageSwapCache().\n\t */\n\tif (PageSwapCache(page))\n\t\tClearPageSwapCache(page);\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\n\t/*\n\t * If any waiters have accumulated on the new page then\n\t * wake them up.\n\t */\n\tif (PageWriteback(newpage))\n\t\tend_page_writeback(newpage);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 759,
    "critical_vars": [
      "ses->server->sign"
    ],
    "function": "SMB2_sess_establish_session",
    "filename": "linux/CVE-2018-1066/CVE-2018-1066_CWE-476_cabfb3680f78981d26c078a26e5c748531257ebb_smb2pdu.c.diff",
    "function_code": "SMB2_sess_establish_session(struct SMB2_sess_data *sess_data)\n{\n\tint rc = 0;\n\tstruct cifs_ses *ses = sess_data->ses;\n\n\tmutex_lock(&ses->server->srv_mutex);\n\tif (ses->server->sign && ses->server->ops->generate_signingkey) {\n\t\trc = ses->server->ops->generate_signingkey(ses);\n\t\tkfree(ses->auth_key.response);\n\t\tses->auth_key.response = NULL;\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI,\n\t\t\t\t\"SMB3 session key generation failed\\n\");\n\t\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t\tgoto keygen_exit;\n\t\t}\n\t}\n\tif (!ses->server->session_estab) {\n\t\tses->server->sequence_number = 0x2;\n\t\tses->server->session_estab = true;\n\t}\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tcifs_dbg(FYI, \"SMB2/3 session established successfully\\n\");\n\tspin_lock(&GlobalMid_Lock);\n\tses->status = CifsGood;\n\tses->need_reconnect = false;\n\tspin_unlock(&GlobalMid_Lock);\n\nkeygen_exit:\n\tif (!ses->server->sign) {\n\t\tkfree(ses->auth_key.response);\n\t\tses->auth_key.response = NULL;\n\t}\n\treturn rc;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 102,
    "critical_vars": [
      "_payload"
    ],
    "function": "SYSCALL_DEFINE5",
    "filename": "linux/CVE-2017-15274/CVE-2017-15274_CWE-476_5649645d725c73df4302428ee4e02c869248b4c5_keyctl.c.diff",
    "function_code": "SYSCALL_DEFINE5(add_key, const char __user *, _type,\n\t\tconst char __user *, _description,\n\t\tconst void __user *, _payload,\n\t\tsize_t, plen,\n\t\tkey_serial_t, ringid)\n{\n\tkey_ref_t keyring_ref, key_ref;\n\tchar type[32], *description;\n\tvoid *payload;\n\tlong ret;\n\n\tret = -EINVAL;\n\tif (plen > 1024 * 1024 - 1)\n\t\tgoto error;\n\n\t/* draw all the data into kernel space */\n\tret = key_get_type_from_user(type, _type, sizeof(type));\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdescription = NULL;\n\tif (_description) {\n\t\tdescription = strndup_user(_description, KEY_MAX_DESC_SIZE);\n\t\tif (IS_ERR(description)) {\n\t\t\tret = PTR_ERR(description);\n\t\t\tgoto error;\n\t\t}\n\t\tif (!*description) {\n\t\t\tkfree(description);\n\t\t\tdescription = NULL;\n\t\t} else if ((description[0] == '.') &&\n\t\t\t   (strncmp(type, \"keyring\", 7) == 0)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto error2;\n\t\t}\n\t}\n\n\t/* pull the payload in if one was supplied */\n\tpayload = NULL;\n\n\tif (_payload) {\n\t\tret = -ENOMEM;\n\t\tpayload = kvmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error2;\n\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(payload, _payload, plen) != 0)\n\t\t\tgoto error3;\n\t}\n\n\t/* find the target keyring (which must be writable) */\n\tkeyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error3;\n\t}\n\n\t/* create or update the requested key and add it to the target\n\t * keyring */\n\tkey_ref = key_create_or_update(keyring_ref, type, description,\n\t\t\t\t       payload, plen, KEY_PERM_UNDEF,\n\t\t\t\t       KEY_ALLOC_IN_QUOTA);\n\tif (!IS_ERR(key_ref)) {\n\t\tret = key_ref_to_ptr(key_ref)->serial;\n\t\tkey_ref_put(key_ref);\n\t}\n\telse {\n\t\tret = PTR_ERR(key_ref);\n\t}\n\n\tkey_ref_put(keyring_ref);\n error3:\n\tkvfree(payload);\n error2:\n\tkfree(description);\n error:\n\treturn ret;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 102,
    "critical_vars": [
      "plen"
    ],
    "function": "SYSCALL_DEFINE5",
    "filename": "linux/CVE-2017-15274/CVE-2017-15274_CWE-476_5649645d725c73df4302428ee4e02c869248b4c5_keyctl.c.diff",
    "function_code": "SYSCALL_DEFINE5(add_key, const char __user *, _type,\n\t\tconst char __user *, _description,\n\t\tconst void __user *, _payload,\n\t\tsize_t, plen,\n\t\tkey_serial_t, ringid)\n{\n\tkey_ref_t keyring_ref, key_ref;\n\tchar type[32], *description;\n\tvoid *payload;\n\tlong ret;\n\n\tret = -EINVAL;\n\tif (plen > 1024 * 1024 - 1)\n\t\tgoto error;\n\n\t/* draw all the data into kernel space */\n\tret = key_get_type_from_user(type, _type, sizeof(type));\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdescription = NULL;\n\tif (_description) {\n\t\tdescription = strndup_user(_description, KEY_MAX_DESC_SIZE);\n\t\tif (IS_ERR(description)) {\n\t\t\tret = PTR_ERR(description);\n\t\t\tgoto error;\n\t\t}\n\t\tif (!*description) {\n\t\t\tkfree(description);\n\t\t\tdescription = NULL;\n\t\t} else if ((description[0] == '.') &&\n\t\t\t   (strncmp(type, \"keyring\", 7) == 0)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto error2;\n\t\t}\n\t}\n\n\t/* pull the payload in if one was supplied */\n\tpayload = NULL;\n\n\tif (plen) {\n\t\tret = -ENOMEM;\n\t\tpayload = kvmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error2;\n\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(payload, _payload, plen) != 0)\n\t\t\tgoto error3;\n\t}\n\n\t/* find the target keyring (which must be writable) */\n\tkeyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error3;\n\t}\n\n\t/* create or update the requested key and add it to the target\n\t * keyring */\n\tkey_ref = key_create_or_update(keyring_ref, type, description,\n\t\t\t\t       payload, plen, KEY_PERM_UNDEF,\n\t\t\t\t       KEY_ALLOC_IN_QUOTA);\n\tif (!IS_ERR(key_ref)) {\n\t\tret = key_ref_to_ptr(key_ref)->serial;\n\t\tkey_ref_put(key_ref);\n\t}\n\telse {\n\t\tret = PTR_ERR(key_ref);\n\t}\n\n\tkey_ref_put(keyring_ref);\n error3:\n\tkvfree(payload);\n error2:\n\tkfree(description);\n error:\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 327,
    "critical_vars": [
      "_payload"
    ],
    "function": "keyctl_update_key",
    "filename": "linux/CVE-2017-15274/CVE-2017-15274_CWE-476_5649645d725c73df4302428ee4e02c869248b4c5_keyctl.c.diff",
    "function_code": "long keyctl_update_key(key_serial_t id,\n\t\t       const void __user *_payload,\n\t\t       size_t plen)\n{\n\tkey_ref_t key_ref;\n\tvoid *payload;\n\tlong ret;\n\n\tret = -EINVAL;\n\tif (plen > PAGE_SIZE)\n\t\tgoto error;\n\n\t/* pull the payload in if one was supplied */\n\tpayload = NULL;\n\tif (_payload) {\n\t\tret = -ENOMEM;\n\t\tpayload = kmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error;\n\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(payload, _payload, plen) != 0)\n\t\t\tgoto error2;\n\t}\n\n\t/* find the target key (which must be writable) */\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_WRITE);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error2;\n\t}\n\n\t/* update the key */\n\tret = key_update(key_ref, payload, plen);\n\n\tkey_ref_put(key_ref);\nerror2:\n\tkfree(payload);\nerror:\n\treturn ret;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 327,
    "critical_vars": [
      "plen"
    ],
    "function": "keyctl_update_key",
    "filename": "linux/CVE-2017-15274/CVE-2017-15274_CWE-476_5649645d725c73df4302428ee4e02c869248b4c5_keyctl.c.diff",
    "function_code": "long keyctl_update_key(key_serial_t id,\n\t\t       const void __user *_payload,\n\t\t       size_t plen)\n{\n\tkey_ref_t key_ref;\n\tvoid *payload;\n\tlong ret;\n\n\tret = -EINVAL;\n\tif (plen > PAGE_SIZE)\n\t\tgoto error;\n\n\t/* pull the payload in if one was supplied */\n\tpayload = NULL;\n\tif (plen) {\n\t\tret = -ENOMEM;\n\t\tpayload = kmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error;\n\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(payload, _payload, plen) != 0)\n\t\t\tgoto error2;\n\t}\n\n\t/* find the target key (which must be writable) */\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_WRITE);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error2;\n\t}\n\n\t/* update the key */\n\tret = key_update(key_ref, payload, plen);\n\n\tkey_ref_put(key_ref);\nerror2:\n\tkfree(payload);\nerror:\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 495,
    "critical_vars": [
      "tb",
      "&type",
      "&mask"
    ],
    "function": "mcryptd_create_hash",
    "filename": "linux/CVE-2016-10147/CVE-2016-10147_CWE-476_48a992727d82cb7db076fa15d372178743b1f4cd_mcryptd.c.diff",
    "function_code": "static int mcryptd_create_hash(struct crypto_template *tmpl, struct rtattr **tb,\n\t\t\t      struct mcryptd_queue *queue)\n{\n\tstruct hashd_instance_ctx *ctx;\n\tstruct ahash_instance *inst;\n\tstruct hash_alg_common *halg;\n\tstruct crypto_alg *alg;\n\tu32 type = 0;\n\tu32 mask = 0;\n\tint err;\n\n\tmcryptd_check_internal(tb, &type, &mask);\n\n\thalg = ahash_attr_alg(tb[1], type, mask);\n\tif (IS_ERR(halg))\n\t\treturn PTR_ERR(halg);\n\n\talg = &halg->base;\n\tpr_debug(\"crypto: mcryptd hash alg: %s\\n\", alg->cra_name);\n\tinst = mcryptd_alloc_instance(alg, ahash_instance_headroom(),\n\t\t\t\t\tsizeof(*ctx));\n\terr = PTR_ERR(inst);\n\tif (IS_ERR(inst))\n\t\tgoto out_put_alg;\n\n\tctx = ahash_instance_ctx(inst);\n\tctx->queue = queue;\n\n\terr = crypto_init_ahash_spawn(&ctx->spawn, halg,\n\t\t\t\t      ahash_crypto_instance(inst));\n\tif (err)\n\t\tgoto out_free_inst;\n\n\ttype = CRYPTO_ALG_ASYNC;\n\tif (alg->cra_flags & CRYPTO_ALG_INTERNAL)\n\t\ttype |= CRYPTO_ALG_INTERNAL;\n\tinst->alg.halg.base.cra_flags = type;\n\n\tinst->alg.halg.digestsize = halg->digestsize;\n\tinst->alg.halg.statesize = halg->statesize;\n\tinst->alg.halg.base.cra_ctxsize = sizeof(struct mcryptd_hash_ctx);\n\n\tinst->alg.halg.base.cra_init = mcryptd_hash_init_tfm;\n\tinst->alg.halg.base.cra_exit = mcryptd_hash_exit_tfm;\n\n\tinst->alg.init   = mcryptd_hash_init_enqueue;\n\tinst->alg.update = mcryptd_hash_update_enqueue;\n\tinst->alg.final  = mcryptd_hash_final_enqueue;\n\tinst->alg.finup  = mcryptd_hash_finup_enqueue;\n\tinst->alg.export = mcryptd_hash_export;\n\tinst->alg.import = mcryptd_hash_import;\n\tinst->alg.setkey = mcryptd_hash_setkey;\n\tinst->alg.digest = mcryptd_hash_digest_enqueue;\n\n\terr = ahash_register_instance(tmpl, inst);\n\tif (err) {\n\t\tcrypto_drop_ahash(&ctx->spawn);\nout_free_inst:\n\t\tkfree(inst);\n\t}\n\nout_put_alg:\n\tcrypto_mod_put(alg);\n\treturn err;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 499,
    "critical_vars": [
      "tb",
      "&type",
      "&mask"
    ],
    "function": "mcryptd_create_hash",
    "filename": "linux/CVE-2016-10147/CVE-2016-10147_CWE-476_48a992727d82cb7db076fa15d372178743b1f4cd_mcryptd.c.diff",
    "function_code": "static int mcryptd_create_hash(struct crypto_template *tmpl, struct rtattr **tb,\n\t\t\t      struct mcryptd_queue *queue)\n{\n\tstruct hashd_instance_ctx *ctx;\n\tstruct ahash_instance *inst;\n\tstruct hash_alg_common *halg;\n\tstruct crypto_alg *alg;\n\tu32 type = 0;\n\tu32 mask = 0;\n\tint err;\n\n\tif (!mcryptd_check_internal(tb, &type, &mask))\n\t\treturn -EINVAL;\n\n\thalg = ahash_attr_alg(tb[1], type, mask);\n\tif (IS_ERR(halg))\n\t\treturn PTR_ERR(halg);\n\n\talg = &halg->base;\n\tpr_debug(\"crypto: mcryptd hash alg: %s\\n\", alg->cra_name);\n\tinst = mcryptd_alloc_instance(alg, ahash_instance_headroom(),\n\t\t\t\t\tsizeof(*ctx));\n\terr = PTR_ERR(inst);\n\tif (IS_ERR(inst))\n\t\tgoto out_put_alg;\n\n\tctx = ahash_instance_ctx(inst);\n\tctx->queue = queue;\n\n\terr = crypto_init_ahash_spawn(&ctx->spawn, halg,\n\t\t\t\t      ahash_crypto_instance(inst));\n\tif (err)\n\t\tgoto out_free_inst;\n\n\ttype = CRYPTO_ALG_ASYNC;\n\tif (alg->cra_flags & CRYPTO_ALG_INTERNAL)\n\t\ttype |= CRYPTO_ALG_INTERNAL;\n\tinst->alg.halg.base.cra_flags = type;\n\n\tinst->alg.halg.digestsize = halg->digestsize;\n\tinst->alg.halg.statesize = halg->statesize;\n\tinst->alg.halg.base.cra_ctxsize = sizeof(struct mcryptd_hash_ctx);\n\n\tinst->alg.halg.base.cra_init = mcryptd_hash_init_tfm;\n\tinst->alg.halg.base.cra_exit = mcryptd_hash_exit_tfm;\n\n\tinst->alg.init   = mcryptd_hash_init_enqueue;\n\tinst->alg.update = mcryptd_hash_update_enqueue;\n\tinst->alg.final  = mcryptd_hash_final_enqueue;\n\tinst->alg.finup  = mcryptd_hash_finup_enqueue;\n\tinst->alg.export = mcryptd_hash_export;\n\tinst->alg.import = mcryptd_hash_import;\n\tinst->alg.setkey = mcryptd_hash_setkey;\n\tinst->alg.digest = mcryptd_hash_digest_enqueue;\n\n\terr = ahash_register_instance(tmpl, inst);\n\tif (err) {\n\t\tcrypto_drop_ahash(&ctx->spawn);\nout_free_inst:\n\t\tkfree(inst);\n\t}\n\nout_put_alg:\n\tcrypto_mod_put(alg);\n\treturn err;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1445,
    "critical_vars": [
      "alt->desc.bNumEndpoints"
    ],
    "function": "cit_get_packet_size",
    "filename": "linux/CVE-2020-11668/CVE-2020-11668_CWE-476_a246b4d547708f33ff4d4b9a7a5dbac741dc89d8_xirlink_cit.c.diff",
    "function_code": "static int cit_get_packet_size(struct gspca_dev *gspca_dev)\n{\n\tstruct usb_host_interface *alt;\n\tstruct usb_interface *intf;\n\n\tintf = usb_ifnum_to_if(gspca_dev->dev, gspca_dev->iface);\n\talt = usb_altnum_to_altsetting(intf, gspca_dev->alt);\n\tif (!alt) {\n\t\tpr_err(\"Couldn't get altsetting\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (alt->desc.bNumEndpoints < 1)\n\t\treturn -ENODEV;\n\n\treturn le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 2648,
    "critical_vars": [
      "intfc"
    ],
    "function": "sd_isoc_init",
    "filename": "linux/CVE-2020-11668/CVE-2020-11668_CWE-476_a246b4d547708f33ff4d4b9a7a5dbac741dc89d8_xirlink_cit.c.diff",
    "function_code": "static int sd_isoc_init(struct gspca_dev *gspca_dev)\n{\n\tstruct usb_interface_cache *intfc;\n\tstruct usb_host_interface *alt;\n\tint max_packet_size;\n\n\tswitch (gspca_dev->pixfmt.width) {\n\tcase 160:\n\t\tmax_packet_size = 450;\n\t\tbreak;\n\tcase 176:\n\t\tmax_packet_size = 600;\n\t\tbreak;\n\tdefault:\n\t\tmax_packet_size = 1022;\n\t\tbreak;\n\t}\n\n\tintfc = gspca_dev->dev->actconfig->intf_cache[0];\n\n\tif (intfc->num_altsetting < 2)\n\t\treturn -ENODEV;\n\n\talt = &intfc->altsetting[1];\n\n\tif (alt->desc.bNumEndpoints < 1)\n\t\treturn -ENODEV;\n\n\t/* Start isoc bandwidth \"negotiation\" at max isoc bandwidth */\n\talt->endpoint[0].desc.wMaxPacketSize = cpu_to_le16(max_packet_size);\n\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 2645,
    "critical_vars": [
      "alt"
    ],
    "function": "sd_isoc_init",
    "filename": "linux/CVE-2020-11668/CVE-2020-11668_CWE-476_a246b4d547708f33ff4d4b9a7a5dbac741dc89d8_xirlink_cit.c.diff",
    "function_code": "static int sd_isoc_init(struct gspca_dev *gspca_dev)\n{\n\tstruct usb_host_interface *alt;\n\tint max_packet_size;\n\n\tswitch (gspca_dev->pixfmt.width) {\n\tcase 160:\n\t\tmax_packet_size = 450;\n\t\tbreak;\n\tcase 176:\n\t\tmax_packet_size = 600;\n\t\tbreak;\n\tdefault:\n\t\tmax_packet_size = 1022;\n\t\tbreak;\n\t}\n\n\t/* Start isoc bandwidth \"negotiation\" at max isoc bandwidth */\n\talt = &gspca_dev->dev->actconfig->intf_cache[0]->altsetting[1];\n\talt->endpoint[0].desc.wMaxPacketSize = cpu_to_le16(max_packet_size);\n\n\treturn 0;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 264,
    "critical_vars": [
      "ax25->sk"
    ],
    "function": "ax25_disconnect",
    "filename": "linux/CVE-2022-1205/CVE-2022-1205_CWE-476_fc6d01ff9ef03b66d4a3a23b46fc3c3d8cf92009_ax25_subr.c.diff",
    "function_code": "void ax25_disconnect(ax25_cb *ax25, int reason)\n{\n\tax25_clear_queues(ax25);\n\n\tif (!ax25->sk || !sock_flag(ax25->sk, SOCK_DESTROY))\n\t\tax25_stop_heartbeat(ax25);\n\tax25_stop_t1timer(ax25);\n\tax25_stop_t2timer(ax25);\n\tax25_stop_t3timer(ax25);\n\tax25_stop_idletimer(ax25);\n\n\tax25->state = AX25_STATE_0;\n\n\tax25_link_failed(ax25, reason);\n\n\tif (ax25->sk != NULL) {\n\t\tlocal_bh_disable();\n\t\tbh_lock_sock(ax25->sk);\n\t\tax25->sk->sk_state     = TCP_CLOSE;\n\t\tax25->sk->sk_err       = reason;\n\t\tax25->sk->sk_shutdown |= SEND_SHUTDOWN;\n\t\tif (!sock_flag(ax25->sk, SOCK_DEAD)) {\n\t\t\tax25->sk->sk_state_change(ax25->sk);\n\t\t\tsock_set_flag(ax25->sk, SOCK_DEAD);\n\t\t}\n\t\tbh_unlock_sock(ax25->sk);\n\t\tlocal_bh_enable();\n\t}\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 264,
    "critical_vars": [
      "reason"
    ],
    "function": "ax25_disconnect",
    "filename": "linux/CVE-2022-1205/CVE-2022-1205_CWE-476_fc6d01ff9ef03b66d4a3a23b46fc3c3d8cf92009_ax25_subr.c.diff",
    "function_code": "void ax25_disconnect(ax25_cb *ax25, int reason)\n{\n\tax25_clear_queues(ax25);\n\n\tif (reason == ENETUNREACH) {\n\t\tdel_timer_sync(&ax25->timer);\n\t\tdel_timer_sync(&ax25->t1timer);\n\t\tdel_timer_sync(&ax25->t2timer);\n\t\tdel_timer_sync(&ax25->t3timer);\n\t\tdel_timer_sync(&ax25->idletimer);\n\t} else {\n\t\tif (!ax25->sk || !sock_flag(ax25->sk, SOCK_DESTROY))\n\t\t\tax25_stop_heartbeat(ax25);\n\t\tax25_stop_t1timer(ax25);\n\t\tax25_stop_t2timer(ax25);\n\t\tax25_stop_t3timer(ax25);\n\t\tax25_stop_idletimer(ax25);\n\t}\n\n\tax25->state = AX25_STATE_0;\n\n\tax25_link_failed(ax25, reason);\n\n\tif (ax25->sk != NULL) {\n\t\tlocal_bh_disable();\n\t\tbh_lock_sock(ax25->sk);\n\t\tax25->sk->sk_state     = TCP_CLOSE;\n\t\tax25->sk->sk_err       = reason;\n\t\tax25->sk->sk_shutdown |= SEND_SHUTDOWN;\n\t\tif (!sock_flag(ax25->sk, SOCK_DEAD)) {\n\t\t\tax25->sk->sk_state_change(ax25->sk);\n\t\t\tsock_set_flag(ax25->sk, SOCK_DEAD);\n\t\t}\n\t\tbh_unlock_sock(ax25->sk);\n\t\tlocal_bh_enable();\n\t}\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 92,
    "critical_vars": [
      "s->ax25_dev"
    ],
    "function": "ax25_kill_by_device",
    "filename": "linux/CVE-2022-1205/CVE-2022-1205_CWE-476_fc6d01ff9ef03b66d4a3a23b46fc3c3d8cf92009_af_ax25.c.diff",
    "function_code": "static void ax25_kill_by_device(struct net_device *dev)\n{\n\tax25_dev *ax25_dev;\n\tax25_cb *s;\n\tstruct sock *sk;\n\n\tif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\n\t\treturn;\n\n\tspin_lock_bh(&ax25_list_lock);\nagain:\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->ax25_dev == ax25_dev) {\n\t\t\tsk = s->sk;\n\t\t\tif (!sk) {\n\t\t\t\tspin_unlock_bh(&ax25_list_lock);\n\t\t\t\ts->ax25_dev = NULL;\n\t\t\t\tax25_disconnect(s, ENETUNREACH);\n\t\t\t\tspin_lock_bh(&ax25_list_lock);\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tsock_hold(sk);\n\t\t\tspin_unlock_bh(&ax25_list_lock);\n\t\t\tlock_sock(sk);\n\t\t\ts->ax25_dev = NULL;\n\t\t\tif (sk->sk_socket) {\n\t\t\t\tdev_put_track(ax25_dev->dev, &ax25_dev->dev_tracker);\n\t\t\t\tax25_dev_put(ax25_dev);\n\t\t\t}\n\t\t\tax25_disconnect(s, ENETUNREACH);\n\t\t\trelease_sock(sk);\n\t\t\tspin_lock_bh(&ax25_list_lock);\n\t\t\tsock_put(sk);\n\t\t\t/* The entry could have been deleted from the\n\t\t\t * list meanwhile and thus the next pointer is\n\t\t\t * no longer valid.  Play it safe and restart\n\t\t\t * the scan.  Forward progress is ensured\n\t\t\t * because we set s->ax25_dev to NULL and we\n\t\t\t * are never passed a NULL 'dev' argument.\n\t\t\t */\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock_bh(&ax25_list_lock);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 93,
    "critical_vars": [
      "s->ax25_dev"
    ],
    "function": "ax25_kill_by_device",
    "filename": "linux/CVE-2022-1205/CVE-2022-1205_CWE-476_fc6d01ff9ef03b66d4a3a23b46fc3c3d8cf92009_af_ax25.c.diff",
    "function_code": "static void ax25_kill_by_device(struct net_device *dev)\n{\n\tax25_dev *ax25_dev;\n\tax25_cb *s;\n\tstruct sock *sk;\n\n\tif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\n\t\treturn;\n\n\tspin_lock_bh(&ax25_list_lock);\nagain:\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->ax25_dev == ax25_dev) {\n\t\t\tsk = s->sk;\n\t\t\tif (!sk) {\n\t\t\t\tspin_unlock_bh(&ax25_list_lock);\n\t\t\t\tax25_disconnect(s, ENETUNREACH);\n\t\t\t\ts->ax25_dev = NULL;\n\t\t\t\tspin_lock_bh(&ax25_list_lock);\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tsock_hold(sk);\n\t\t\tspin_unlock_bh(&ax25_list_lock);\n\t\t\tlock_sock(sk);\n\t\t\tax25_disconnect(s, ENETUNREACH);\n\t\t\ts->ax25_dev = NULL;\n\t\t\tif (sk->sk_socket) {\n\t\t\t\tdev_put_track(ax25_dev->dev, &ax25_dev->dev_tracker);\n\t\t\t\tax25_dev_put(ax25_dev);\n\t\t\t}\n\t\t\trelease_sock(sk);\n\t\t\tspin_lock_bh(&ax25_list_lock);\n\t\t\tsock_put(sk);\n\t\t\t/* The entry could have been deleted from the\n\t\t\t * list meanwhile and thus the next pointer is\n\t\t\t * no longer valid.  Play it safe and restart\n\t\t\t * the scan.  Forward progress is ensured\n\t\t\t * because we set s->ax25_dev to NULL and we\n\t\t\t * are never passed a NULL 'dev' argument.\n\t\t\t */\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock_bh(&ax25_list_lock);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 2025,
    "critical_vars": [
      "*sband"
    ],
    "function": "ieee80211_parse_tx_radiotap",
    "filename": "linux/CVE-2021-38206/CVE-2021-38206_CWE-476_bddc0c411a45d3718ac535a070f349be8eca8d48_tx.c.diff",
    "function_code": "bool ieee80211_parse_tx_radiotap(struct sk_buff *skb,\n\t\t\t\t struct net_device *dev)\n{\n\tstruct ieee80211_local *local = wdev_priv(dev->ieee80211_ptr);\n\tstruct ieee80211_radiotap_iterator iterator;\n\tstruct ieee80211_radiotap_header *rthdr =\n\t\t(struct ieee80211_radiotap_header *) skb->data;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_supported_band *sband =\n\t\tlocal->hw.wiphy->bands[info->band];\n\tint ret = ieee80211_radiotap_iterator_init(&iterator, rthdr, skb->len,\n\t\t\t\t\t\t   NULL);\n\tu16 txflags;\n\tu16 rate = 0;\n\tbool rate_found = false;\n\tu8 rate_retries = 0;\n\tu16 rate_flags = 0;\n\tu8 mcs_known, mcs_flags, mcs_bw;\n\tu16 vht_known;\n\tu8 vht_mcs = 0, vht_nss = 0;\n\tint i;\n\n\t/* check for not even having the fixed radiotap header part */\n\tif (unlikely(skb->len < sizeof(struct ieee80211_radiotap_header)))\n\t\treturn false; /* too short to be possibly valid */\n\n\t/* is it a header version we can trust to find length from? */\n\tif (unlikely(rthdr->it_version))\n\t\treturn false; /* only version 0 is supported */\n\n\t/* does the skb contain enough to deliver on the alleged length? */\n\tif (unlikely(skb->len < ieee80211_get_radiotap_len(skb->data)))\n\t\treturn false; /* skb too short for claimed rt header extent */\n\n\tinfo->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT |\n\t\t       IEEE80211_TX_CTL_DONTFRAG;\n\n\t/*\n\t * for every radiotap entry that is present\n\t * (ieee80211_radiotap_iterator_next returns -ENOENT when no more\n\t * entries present, or -EINVAL on error)\n\t */\n\n\twhile (!ret) {\n\t\tret = ieee80211_radiotap_iterator_next(&iterator);\n\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\t/* see if this argument is something we can use */\n\t\tswitch (iterator.this_arg_index) {\n\t\t/*\n\t\t * You must take care when dereferencing iterator.this_arg\n\t\t * for multibyte types... the pointer is not aligned.  Use\n\t\t * get_unaligned((type *)iterator.this_arg) to dereference\n\t\t * iterator.this_arg for type \"type\" safely on all arches.\n\t\t*/\n\t\tcase IEEE80211_RADIOTAP_FLAGS:\n\t\t\tif (*iterator.this_arg & IEEE80211_RADIOTAP_F_FCS) {\n\t\t\t\t/*\n\t\t\t\t * this indicates that the skb we have been\n\t\t\t\t * handed has the 32-bit FCS CRC at the end...\n\t\t\t\t * we should react to that by snipping it off\n\t\t\t\t * because it will be recomputed and added\n\t\t\t\t * on transmission\n\t\t\t\t */\n\t\t\t\tif (skb->len < (iterator._max_length + FCS_LEN))\n\t\t\t\t\treturn false;\n\n\t\t\t\tskb_trim(skb, skb->len - FCS_LEN);\n\t\t\t}\n\t\t\tif (*iterator.this_arg & IEEE80211_RADIOTAP_F_WEP)\n\t\t\t\tinfo->flags &= ~IEEE80211_TX_INTFL_DONT_ENCRYPT;\n\t\t\tif (*iterator.this_arg & IEEE80211_RADIOTAP_F_FRAG)\n\t\t\t\tinfo->flags &= ~IEEE80211_TX_CTL_DONTFRAG;\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_TX_FLAGS:\n\t\t\ttxflags = get_unaligned_le16(iterator.this_arg);\n\t\t\tif (txflags & IEEE80211_RADIOTAP_F_TX_NOACK)\n\t\t\t\tinfo->flags |= IEEE80211_TX_CTL_NO_ACK;\n\t\t\tif (txflags & IEEE80211_RADIOTAP_F_TX_NOSEQNO)\n\t\t\t\tinfo->control.flags |= IEEE80211_TX_CTRL_NO_SEQNO;\n\t\t\tif (txflags & IEEE80211_RADIOTAP_F_TX_ORDER)\n\t\t\t\tinfo->control.flags |=\n\t\t\t\t\tIEEE80211_TX_CTRL_DONT_REORDER;\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_RATE:\n\t\t\trate = *iterator.this_arg;\n\t\t\trate_flags = 0;\n\t\t\trate_found = true;\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_DATA_RETRIES:\n\t\t\trate_retries = *iterator.this_arg;\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_MCS:\n\t\t\tmcs_known = iterator.this_arg[0];\n\t\t\tmcs_flags = iterator.this_arg[1];\n\t\t\tif (!(mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_MCS))\n\t\t\t\tbreak;\n\n\t\t\trate_found = true;\n\t\t\trate = iterator.this_arg[2];\n\t\t\trate_flags = IEEE80211_TX_RC_MCS;\n\n\t\t\tif (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_GI &&\n\t\t\t    mcs_flags & IEEE80211_RADIOTAP_MCS_SGI)\n\t\t\t\trate_flags |= IEEE80211_TX_RC_SHORT_GI;\n\n\t\t\tmcs_bw = mcs_flags & IEEE80211_RADIOTAP_MCS_BW_MASK;\n\t\t\tif (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_BW &&\n\t\t\t    mcs_bw == IEEE80211_RADIOTAP_MCS_BW_40)\n\t\t\t\trate_flags |= IEEE80211_TX_RC_40_MHZ_WIDTH;\n\n\t\t\tif (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_FEC &&\n\t\t\t    mcs_flags & IEEE80211_RADIOTAP_MCS_FEC_LDPC)\n\t\t\t\tinfo->flags |= IEEE80211_TX_CTL_LDPC;\n\n\t\t\tif (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_STBC) {\n\t\t\t\tu8 stbc = u8_get_bits(mcs_flags,\n\t\t\t\t\t\t      IEEE80211_RADIOTAP_MCS_STBC_MASK);\n\n\t\t\t\tinfo->flags |=\n\t\t\t\t\tu32_encode_bits(stbc,\n\t\t\t\t\t\t\tIEEE80211_TX_CTL_STBC);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_VHT:\n\t\t\tvht_known = get_unaligned_le16(iterator.this_arg);\n\t\t\trate_found = true;\n\n\t\t\trate_flags = IEEE80211_TX_RC_VHT_MCS;\n\t\t\tif ((vht_known & IEEE80211_RADIOTAP_VHT_KNOWN_GI) &&\n\t\t\t    (iterator.this_arg[2] &\n\t\t\t     IEEE80211_RADIOTAP_VHT_FLAG_SGI))\n\t\t\t\trate_flags |= IEEE80211_TX_RC_SHORT_GI;\n\t\t\tif (vht_known &\n\t\t\t    IEEE80211_RADIOTAP_VHT_KNOWN_BANDWIDTH) {\n\t\t\t\tif (iterator.this_arg[3] == 1)\n\t\t\t\t\trate_flags |=\n\t\t\t\t\t\tIEEE80211_TX_RC_40_MHZ_WIDTH;\n\t\t\t\telse if (iterator.this_arg[3] == 4)\n\t\t\t\t\trate_flags |=\n\t\t\t\t\t\tIEEE80211_TX_RC_80_MHZ_WIDTH;\n\t\t\t\telse if (iterator.this_arg[3] == 11)\n\t\t\t\t\trate_flags |=\n\t\t\t\t\t\tIEEE80211_TX_RC_160_MHZ_WIDTH;\n\t\t\t}\n\n\t\t\tvht_mcs = iterator.this_arg[4] >> 4;\n\t\t\tvht_nss = iterator.this_arg[4] & 0xF;\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Please update the file\n\t\t * Documentation/networking/mac80211-injection.rst\n\t\t * when parsing new fields here.\n\t\t */\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret != -ENOENT) /* ie, if we didn't simply run out of fields */\n\t\treturn false;\n\n\tif (rate_found) {\n\t\tinfo->control.flags |= IEEE80211_TX_CTRL_RATE_INJECT;\n\n\t\tfor (i = 0; i < IEEE80211_TX_MAX_RATES; i++) {\n\t\t\tinfo->control.rates[i].idx = -1;\n\t\t\tinfo->control.rates[i].flags = 0;\n\t\t\tinfo->control.rates[i].count = 0;\n\t\t}\n\n\t\tif (rate_flags & IEEE80211_TX_RC_MCS) {\n\t\t\tinfo->control.rates[0].idx = rate;\n\t\t} else if (rate_flags & IEEE80211_TX_RC_VHT_MCS) {\n\t\t\tieee80211_rate_set_vht(info->control.rates, vht_mcs,\n\t\t\t\t\t       vht_nss);\n\t\t} else {\n\t\t\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\t\t\tif (rate * 5 != sband->bitrates[i].bitrate)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tinfo->control.rates[0].idx = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (info->control.rates[0].idx < 0)\n\t\t\tinfo->control.flags &= ~IEEE80211_TX_CTRL_RATE_INJECT;\n\n\t\tinfo->control.rates[0].flags = rate_flags;\n\t\tinfo->control.rates[0].count = min_t(u8, rate_retries + 1,\n\t\t\t\t\t\t     local->hw.max_rate_tries);\n\t}\n\n\treturn true;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 2057,
    "critical_vars": [
      "skb"
    ],
    "function": "ieee80211_parse_tx_radiotap",
    "filename": "linux/CVE-2021-38206/CVE-2021-38206_CWE-476_bddc0c411a45d3718ac535a070f349be8eca8d48_tx.c.diff",
    "function_code": "bool ieee80211_parse_tx_radiotap(struct sk_buff *skb,\n\t\t\t\t struct net_device *dev)\n{\n\tstruct ieee80211_local *local = wdev_priv(dev->ieee80211_ptr);\n\tstruct ieee80211_radiotap_iterator iterator;\n\tstruct ieee80211_radiotap_header *rthdr =\n\t\t(struct ieee80211_radiotap_header *) skb->data;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tint ret = ieee80211_radiotap_iterator_init(&iterator, rthdr, skb->len,\n\t\t\t\t\t\t   NULL);\n\tu16 txflags;\n\tu16 rate = 0;\n\tbool rate_found = false;\n\tu8 rate_retries = 0;\n\tu16 rate_flags = 0;\n\tu8 mcs_known, mcs_flags, mcs_bw;\n\tu16 vht_known;\n\tu8 vht_mcs = 0, vht_nss = 0;\n\tint i;\n\n\tif (!ieee80211_validate_radiotap_len(skb))\n\t\treturn false;\n\n\tinfo->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT |\n\t\t       IEEE80211_TX_CTL_DONTFRAG;\n\n\t/*\n\t * for every radiotap entry that is present\n\t * (ieee80211_radiotap_iterator_next returns -ENOENT when no more\n\t * entries present, or -EINVAL on error)\n\t */\n\n\twhile (!ret) {\n\t\tret = ieee80211_radiotap_iterator_next(&iterator);\n\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\t/* see if this argument is something we can use */\n\t\tswitch (iterator.this_arg_index) {\n\t\t/*\n\t\t * You must take care when dereferencing iterator.this_arg\n\t\t * for multibyte types... the pointer is not aligned.  Use\n\t\t * get_unaligned((type *)iterator.this_arg) to dereference\n\t\t * iterator.this_arg for type \"type\" safely on all arches.\n\t\t*/\n\t\tcase IEEE80211_RADIOTAP_FLAGS:\n\t\t\tif (*iterator.this_arg & IEEE80211_RADIOTAP_F_FCS) {\n\t\t\t\t/*\n\t\t\t\t * this indicates that the skb we have been\n\t\t\t\t * handed has the 32-bit FCS CRC at the end...\n\t\t\t\t * we should react to that by snipping it off\n\t\t\t\t * because it will be recomputed and added\n\t\t\t\t * on transmission\n\t\t\t\t */\n\t\t\t\tif (skb->len < (iterator._max_length + FCS_LEN))\n\t\t\t\t\treturn false;\n\n\t\t\t\tskb_trim(skb, skb->len - FCS_LEN);\n\t\t\t}\n\t\t\tif (*iterator.this_arg & IEEE80211_RADIOTAP_F_WEP)\n\t\t\t\tinfo->flags &= ~IEEE80211_TX_INTFL_DONT_ENCRYPT;\n\t\t\tif (*iterator.this_arg & IEEE80211_RADIOTAP_F_FRAG)\n\t\t\t\tinfo->flags &= ~IEEE80211_TX_CTL_DONTFRAG;\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_TX_FLAGS:\n\t\t\ttxflags = get_unaligned_le16(iterator.this_arg);\n\t\t\tif (txflags & IEEE80211_RADIOTAP_F_TX_NOACK)\n\t\t\t\tinfo->flags |= IEEE80211_TX_CTL_NO_ACK;\n\t\t\tif (txflags & IEEE80211_RADIOTAP_F_TX_NOSEQNO)\n\t\t\t\tinfo->control.flags |= IEEE80211_TX_CTRL_NO_SEQNO;\n\t\t\tif (txflags & IEEE80211_RADIOTAP_F_TX_ORDER)\n\t\t\t\tinfo->control.flags |=\n\t\t\t\t\tIEEE80211_TX_CTRL_DONT_REORDER;\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_RATE:\n\t\t\trate = *iterator.this_arg;\n\t\t\trate_flags = 0;\n\t\t\trate_found = true;\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_DATA_RETRIES:\n\t\t\trate_retries = *iterator.this_arg;\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_MCS:\n\t\t\tmcs_known = iterator.this_arg[0];\n\t\t\tmcs_flags = iterator.this_arg[1];\n\t\t\tif (!(mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_MCS))\n\t\t\t\tbreak;\n\n\t\t\trate_found = true;\n\t\t\trate = iterator.this_arg[2];\n\t\t\trate_flags = IEEE80211_TX_RC_MCS;\n\n\t\t\tif (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_GI &&\n\t\t\t    mcs_flags & IEEE80211_RADIOTAP_MCS_SGI)\n\t\t\t\trate_flags |= IEEE80211_TX_RC_SHORT_GI;\n\n\t\t\tmcs_bw = mcs_flags & IEEE80211_RADIOTAP_MCS_BW_MASK;\n\t\t\tif (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_BW &&\n\t\t\t    mcs_bw == IEEE80211_RADIOTAP_MCS_BW_40)\n\t\t\t\trate_flags |= IEEE80211_TX_RC_40_MHZ_WIDTH;\n\n\t\t\tif (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_FEC &&\n\t\t\t    mcs_flags & IEEE80211_RADIOTAP_MCS_FEC_LDPC)\n\t\t\t\tinfo->flags |= IEEE80211_TX_CTL_LDPC;\n\n\t\t\tif (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_STBC) {\n\t\t\t\tu8 stbc = u8_get_bits(mcs_flags,\n\t\t\t\t\t\t      IEEE80211_RADIOTAP_MCS_STBC_MASK);\n\n\t\t\t\tinfo->flags |=\n\t\t\t\t\tu32_encode_bits(stbc,\n\t\t\t\t\t\t\tIEEE80211_TX_CTL_STBC);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_VHT:\n\t\t\tvht_known = get_unaligned_le16(iterator.this_arg);\n\t\t\trate_found = true;\n\n\t\t\trate_flags = IEEE80211_TX_RC_VHT_MCS;\n\t\t\tif ((vht_known & IEEE80211_RADIOTAP_VHT_KNOWN_GI) &&\n\t\t\t    (iterator.this_arg[2] &\n\t\t\t     IEEE80211_RADIOTAP_VHT_FLAG_SGI))\n\t\t\t\trate_flags |= IEEE80211_TX_RC_SHORT_GI;\n\t\t\tif (vht_known &\n\t\t\t    IEEE80211_RADIOTAP_VHT_KNOWN_BANDWIDTH) {\n\t\t\t\tif (iterator.this_arg[3] == 1)\n\t\t\t\t\trate_flags |=\n\t\t\t\t\t\tIEEE80211_TX_RC_40_MHZ_WIDTH;\n\t\t\t\telse if (iterator.this_arg[3] == 4)\n\t\t\t\t\trate_flags |=\n\t\t\t\t\t\tIEEE80211_TX_RC_80_MHZ_WIDTH;\n\t\t\t\telse if (iterator.this_arg[3] == 11)\n\t\t\t\t\trate_flags |=\n\t\t\t\t\t\tIEEE80211_TX_RC_160_MHZ_WIDTH;\n\t\t\t}\n\n\t\t\tvht_mcs = iterator.this_arg[4] >> 4;\n\t\t\tvht_nss = iterator.this_arg[4] & 0xF;\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Please update the file\n\t\t * Documentation/networking/mac80211-injection.rst\n\t\t * when parsing new fields here.\n\t\t */\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret != -ENOENT) /* ie, if we didn't simply run out of fields */\n\t\treturn false;\n\n\tif (rate_found) {\n\t\tstruct ieee80211_supported_band *sband =\n\t\t\tlocal->hw.wiphy->bands[info->band];\n\n\t\tinfo->control.flags |= IEEE80211_TX_CTRL_RATE_INJECT;\n\n\t\tfor (i = 0; i < IEEE80211_TX_MAX_RATES; i++) {\n\t\t\tinfo->control.rates[i].idx = -1;\n\t\t\tinfo->control.rates[i].flags = 0;\n\t\t\tinfo->control.rates[i].count = 0;\n\t\t}\n\n\t\tif (rate_flags & IEEE80211_TX_RC_MCS) {\n\t\t\tinfo->control.rates[0].idx = rate;\n\t\t} else if (rate_flags & IEEE80211_TX_RC_VHT_MCS) {\n\t\t\tieee80211_rate_set_vht(info->control.rates, vht_mcs,\n\t\t\t\t\t       vht_nss);\n\t\t} else if (sband) {\n\t\t\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\t\t\tif (rate * 5 != sband->bitrates[i].bitrate)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tinfo->control.rates[0].idx = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (info->control.rates[0].idx < 0)\n\t\t\tinfo->control.flags &= ~IEEE80211_TX_CTRL_RATE_INJECT;\n\n\t\tinfo->control.rates[0].flags = rate_flags;\n\t\tinfo->control.rates[0].count = min_t(u8, rate_retries + 1,\n\t\t\t\t\t\t     local->hw.max_rate_tries);\n\t}\n\n\treturn true;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 2240,
    "critical_vars": [
      "skb",
      "dev"
    ],
    "function": "ieee80211_monitor_start_xmit",
    "filename": "linux/CVE-2021-38206/CVE-2021-38206_CWE-476_bddc0c411a45d3718ac535a070f349be8eca8d48_tx.c.diff",
    "function_code": "netdev_tx_t ieee80211_monitor_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t struct net_device *dev)\n{\n\tstruct ieee80211_local *local = wdev_priv(dev->ieee80211_ptr);\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr;\n\tstruct ieee80211_sub_if_data *tmp_sdata, *sdata;\n\tstruct cfg80211_chan_def *chandef;\n\tu16 len_rthdr;\n\tint hdrlen;\n\n\tmemset(info, 0, sizeof(*info));\n\tinfo->flags = IEEE80211_TX_CTL_REQ_TX_STATUS |\n\t\t      IEEE80211_TX_CTL_INJECTED;\n\n\t/* Sanity-check and process the injection radiotap header */\n\tif (!ieee80211_parse_tx_radiotap(skb, dev))\n\t\tgoto fail;\n\n\t/* we now know there is a radiotap header with a length we can use */\n\tlen_rthdr = ieee80211_get_radiotap_len(skb->data);\n\n\t/*\n\t * fix up the pointers accounting for the radiotap\n\t * header still being in there.  We are being given\n\t * a precooked IEEE80211 header so no need for\n\t * normal processing\n\t */\n\tskb_set_mac_header(skb, len_rthdr);\n\t/*\n\t * these are just fixed to the end of the rt area since we\n\t * don't have any better information and at this point, nobody cares\n\t */\n\tskb_set_network_header(skb, len_rthdr);\n\tskb_set_transport_header(skb, len_rthdr);\n\n\tif (skb->len < len_rthdr + 2)\n\t\tgoto fail;\n\n\thdr = (struct ieee80211_hdr *)(skb->data + len_rthdr);\n\thdrlen = ieee80211_hdrlen(hdr->frame_control);\n\n\tif (skb->len < len_rthdr + hdrlen)\n\t\tgoto fail;\n\n\t/*\n\t * Initialize skb->protocol if the injected frame is a data frame\n\t * carrying a rfc1042 header\n\t */\n\tif (ieee80211_is_data(hdr->frame_control) &&\n\t    skb->len >= len_rthdr + hdrlen + sizeof(rfc1042_header) + 2) {\n\t\tu8 *payload = (u8 *)hdr + hdrlen;\n\n\t\tif (ether_addr_equal(payload, rfc1042_header))\n\t\t\tskb->protocol = cpu_to_be16((payload[6] << 8) |\n\t\t\t\t\t\t    payload[7]);\n\t}\n\n\trcu_read_lock();\n\n\t/*\n\t * We process outgoing injected frames that have a local address\n\t * we handle as though they are non-injected frames.\n\t * This code here isn't entirely correct, the local MAC address\n\t * isn't always enough to find the interface to use; for proper\n\t * VLAN support we have an nl80211-based mechanism.\n\t *\n\t * This is necessary, for example, for old hostapd versions that\n\t * don't use nl80211-based management TX/RX.\n\t */\n\tsdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\n\tlist_for_each_entry_rcu(tmp_sdata, &local->interfaces, list) {\n\t\tif (!ieee80211_sdata_running(tmp_sdata))\n\t\t\tcontinue;\n\t\tif (tmp_sdata->vif.type == NL80211_IFTYPE_MONITOR ||\n\t\t    tmp_sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\n\t\t\tcontinue;\n\t\tif (ether_addr_equal(tmp_sdata->vif.addr, hdr->addr2)) {\n\t\t\tsdata = tmp_sdata;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\n\tif (!chanctx_conf) {\n\t\ttmp_sdata = rcu_dereference(local->monitor_sdata);\n\t\tif (tmp_sdata)\n\t\t\tchanctx_conf =\n\t\t\t\trcu_dereference(tmp_sdata->vif.chanctx_conf);\n\t}\n\n\tif (chanctx_conf)\n\t\tchandef = &chanctx_conf->def;\n\telse if (!local->use_chanctx)\n\t\tchandef = &local->_oper_chandef;\n\telse\n\t\tgoto fail_rcu;\n\n\t/*\n\t * Frame injection is not allowed if beaconing is not allowed\n\t * or if we need radar detection. Beaconing is usually not allowed when\n\t * the mode or operation (Adhoc, AP, Mesh) does not support DFS.\n\t * Passive scan is also used in world regulatory domains where\n\t * your country is not known and as such it should be treated as\n\t * NO TX unless the channel is explicitly allowed in which case\n\t * your current regulatory domain would not have the passive scan\n\t * flag.\n\t *\n\t * Since AP mode uses monitor interfaces to inject/TX management\n\t * frames we can make AP mode the exception to this rule once it\n\t * supports radar detection as its implementation can deal with\n\t * radar detection by itself. We can do that later by adding a\n\t * monitor flag interfaces used for AP support.\n\t */\n\tif (!cfg80211_reg_can_beacon(local->hw.wiphy, chandef,\n\t\t\t\t     sdata->vif.type))\n\t\tgoto fail_rcu;\n\n\tinfo->band = chandef->chan->band;\n\n\t/* Initialize skb->priority according to frame type and TID class,\n\t * with respect to the sub interface that the frame will actually\n\t * be transmitted on. If the DONT_REORDER flag is set, the original\n\t * skb-priority is preserved to assure frames injected with this\n\t * flag are not reordered relative to each other.\n\t */\n\tieee80211_select_queue_80211(sdata, skb, hdr);\n\tskb_set_queue_mapping(skb, ieee80211_ac_from_tid(skb->priority));\n\n\t/* remove the injection radiotap header */\n\tskb_pull(skb, len_rthdr);\n\n\tieee80211_xmit(sdata, NULL, skb);\n\trcu_read_unlock();\n\n\treturn NETDEV_TX_OK;\n\nfail_rcu:\n\trcu_read_unlock();\nfail:\n\tdev_kfree_skb(skb);\n\treturn NETDEV_TX_OK; /* meaning, we dealt with the skb */\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 2252,
    "critical_vars": [
      "skb"
    ],
    "function": "ieee80211_monitor_start_xmit",
    "filename": "linux/CVE-2021-38206/CVE-2021-38206_CWE-476_bddc0c411a45d3718ac535a070f349be8eca8d48_tx.c.diff",
    "function_code": "netdev_tx_t ieee80211_monitor_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t struct net_device *dev)\n{\n\tstruct ieee80211_local *local = wdev_priv(dev->ieee80211_ptr);\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr;\n\tstruct ieee80211_sub_if_data *tmp_sdata, *sdata;\n\tstruct cfg80211_chan_def *chandef;\n\tu16 len_rthdr;\n\tint hdrlen;\n\n\tmemset(info, 0, sizeof(*info));\n\tinfo->flags = IEEE80211_TX_CTL_REQ_TX_STATUS |\n\t\t      IEEE80211_TX_CTL_INJECTED;\n\n\t/* Sanity-check the length of the radiotap header */\n\tif (!ieee80211_validate_radiotap_len(skb))\n\t\tgoto fail;\n\n\t/* we now know there is a radiotap header with a length we can use */\n\tlen_rthdr = ieee80211_get_radiotap_len(skb->data);\n\n\t/*\n\t * fix up the pointers accounting for the radiotap\n\t * header still being in there.  We are being given\n\t * a precooked IEEE80211 header so no need for\n\t * normal processing\n\t */\n\tskb_set_mac_header(skb, len_rthdr);\n\t/*\n\t * these are just fixed to the end of the rt area since we\n\t * don't have any better information and at this point, nobody cares\n\t */\n\tskb_set_network_header(skb, len_rthdr);\n\tskb_set_transport_header(skb, len_rthdr);\n\n\tif (skb->len < len_rthdr + 2)\n\t\tgoto fail;\n\n\thdr = (struct ieee80211_hdr *)(skb->data + len_rthdr);\n\thdrlen = ieee80211_hdrlen(hdr->frame_control);\n\n\tif (skb->len < len_rthdr + hdrlen)\n\t\tgoto fail;\n\n\t/*\n\t * Initialize skb->protocol if the injected frame is a data frame\n\t * carrying a rfc1042 header\n\t */\n\tif (ieee80211_is_data(hdr->frame_control) &&\n\t    skb->len >= len_rthdr + hdrlen + sizeof(rfc1042_header) + 2) {\n\t\tu8 *payload = (u8 *)hdr + hdrlen;\n\n\t\tif (ether_addr_equal(payload, rfc1042_header))\n\t\t\tskb->protocol = cpu_to_be16((payload[6] << 8) |\n\t\t\t\t\t\t    payload[7]);\n\t}\n\n\trcu_read_lock();\n\n\t/*\n\t * We process outgoing injected frames that have a local address\n\t * we handle as though they are non-injected frames.\n\t * This code here isn't entirely correct, the local MAC address\n\t * isn't always enough to find the interface to use; for proper\n\t * VLAN support we have an nl80211-based mechanism.\n\t *\n\t * This is necessary, for example, for old hostapd versions that\n\t * don't use nl80211-based management TX/RX.\n\t */\n\tsdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\n\tlist_for_each_entry_rcu(tmp_sdata, &local->interfaces, list) {\n\t\tif (!ieee80211_sdata_running(tmp_sdata))\n\t\t\tcontinue;\n\t\tif (tmp_sdata->vif.type == NL80211_IFTYPE_MONITOR ||\n\t\t    tmp_sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\n\t\t\tcontinue;\n\t\tif (ether_addr_equal(tmp_sdata->vif.addr, hdr->addr2)) {\n\t\t\tsdata = tmp_sdata;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\n\tif (!chanctx_conf) {\n\t\ttmp_sdata = rcu_dereference(local->monitor_sdata);\n\t\tif (tmp_sdata)\n\t\t\tchanctx_conf =\n\t\t\t\trcu_dereference(tmp_sdata->vif.chanctx_conf);\n\t}\n\n\tif (chanctx_conf)\n\t\tchandef = &chanctx_conf->def;\n\telse if (!local->use_chanctx)\n\t\tchandef = &local->_oper_chandef;\n\telse\n\t\tgoto fail_rcu;\n\n\t/*\n\t * Frame injection is not allowed if beaconing is not allowed\n\t * or if we need radar detection. Beaconing is usually not allowed when\n\t * the mode or operation (Adhoc, AP, Mesh) does not support DFS.\n\t * Passive scan is also used in world regulatory domains where\n\t * your country is not known and as such it should be treated as\n\t * NO TX unless the channel is explicitly allowed in which case\n\t * your current regulatory domain would not have the passive scan\n\t * flag.\n\t *\n\t * Since AP mode uses monitor interfaces to inject/TX management\n\t * frames we can make AP mode the exception to this rule once it\n\t * supports radar detection as its implementation can deal with\n\t * radar detection by itself. We can do that later by adding a\n\t * monitor flag interfaces used for AP support.\n\t */\n\tif (!cfg80211_reg_can_beacon(local->hw.wiphy, chandef,\n\t\t\t\t     sdata->vif.type))\n\t\tgoto fail_rcu;\n\n\tinfo->band = chandef->chan->band;\n\n\t/* Initialize skb->priority according to frame type and TID class,\n\t * with respect to the sub interface that the frame will actually\n\t * be transmitted on. If the DONT_REORDER flag is set, the original\n\t * skb-priority is preserved to assure frames injected with this\n\t * flag are not reordered relative to each other.\n\t */\n\tieee80211_select_queue_80211(sdata, skb, hdr);\n\tskb_set_queue_mapping(skb, ieee80211_ac_from_tid(skb->priority));\n\n\t/*\n\t * Process the radiotap header. This will now take into account the\n\t * selected chandef above to accurately set injection rates and\n\t * retransmissions.\n\t */\n\tif (!ieee80211_parse_tx_radiotap(skb, dev))\n\t\tgoto fail_rcu;\n\n\t/* remove the injection radiotap header */\n\tskb_pull(skb, len_rthdr);\n\n\tieee80211_xmit(sdata, NULL, skb);\n\trcu_read_unlock();\n\n\treturn NETDEV_TX_OK;\n\nfail_rcu:\n\trcu_read_unlock();\nfail:\n\tdev_kfree_skb(skb);\n\treturn NETDEV_TX_OK; /* meaning, we dealt with the skb */\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 75,
    "line_new": 76,
    "critical_vars": [
      "dmn->uar"
    ],
    "function": "dr_domain_init_resources",
    "filename": "linux/CVE-2023-23006/CVE-2023-23006_CWE-476_6b8b42585886c59a008015083282aae434349094_dr_domain.c.diff",
    "function_code": "static int dr_domain_init_resources(struct mlx5dr_domain *dmn)\n{\n\tint ret;\n\n\tdmn->ste_ctx = mlx5dr_ste_get_ctx(dmn->info.caps.sw_format_ver);\n\tif (!dmn->ste_ctx) {\n\t\tmlx5dr_err(dmn, \"SW Steering on this device is unsupported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tret = mlx5_core_alloc_pd(dmn->mdev, &dmn->pdn);\n\tif (ret) {\n\t\tmlx5dr_err(dmn, \"Couldn't allocate PD, ret: %d\", ret);\n\t\treturn ret;\n\t}\n\n\tdmn->uar = mlx5_get_uars_page(dmn->mdev);\n\tif (IS_ERR(dmn->uar)) {\n\t\tmlx5dr_err(dmn, \"Couldn't allocate UAR\\n\");\n\t\tret = PTR_ERR(dmn->uar);\n\t\tgoto clean_pd;\n\t}\n\n\tdmn->ste_icm_pool = mlx5dr_icm_pool_create(dmn, DR_ICM_TYPE_STE);\n\tif (!dmn->ste_icm_pool) {\n\t\tmlx5dr_err(dmn, \"Couldn't get icm memory\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto clean_uar;\n\t}\n\n\tdmn->action_icm_pool = mlx5dr_icm_pool_create(dmn, DR_ICM_TYPE_MODIFY_ACTION);\n\tif (!dmn->action_icm_pool) {\n\t\tmlx5dr_err(dmn, \"Couldn't get action icm memory\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto free_ste_icm_pool;\n\t}\n\n\tret = mlx5dr_send_ring_alloc(dmn);\n\tif (ret) {\n\t\tmlx5dr_err(dmn, \"Couldn't create send-ring\\n\");\n\t\tgoto free_action_icm_pool;\n\t}\n\n\treturn 0;\n\nfree_action_icm_pool:\n\tmlx5dr_icm_pool_destroy(dmn->action_icm_pool);\nfree_ste_icm_pool:\n\tmlx5dr_icm_pool_destroy(dmn->ste_icm_pool);\nclean_uar:\n\tmlx5_put_uars_page(dmn->mdev, dmn->uar);\nclean_pd:\n\tmlx5_core_dealloc_pd(dmn->mdev, dmn->pdn);\n\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 154,
    "critical_vars": [
      "skb"
    ],
    "function": "send_acknowledge",
    "filename": "linux/CVE-2023-46343/CVE-2023-46343_CWE-476_7937609cd387246aed994e81aa4fa951358fba41_spi.c.diff",
    "function_code": "static int send_acknowledge(struct nci_spi *nspi, u8 acknowledge)\n{\n\tstruct sk_buff *skb;\n\tunsigned char *hdr;\n\tu16 crc;\n\tint ret;\n\n\tskb = nci_skb_alloc(nspi->ndev, 0, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\t/* add the NCI SPI header to the start of the buffer */\n\thdr = skb_push(skb, NCI_SPI_HDR_LEN);\n\thdr[0] = NCI_SPI_DIRECT_WRITE;\n\thdr[1] = NCI_SPI_CRC_ENABLED;\n\thdr[2] = acknowledge << NCI_SPI_ACK_SHIFT;\n\thdr[3] = 0;\n\n\tcrc = crc_ccitt(CRC_INIT, skb->data, skb->len);\n\tskb_put_u8(skb, crc >> 8);\n\tskb_put_u8(skb, crc & 0xFF);\n\n\tret = __nci_spi_send(nspi, skb, 0);\n\n\tkfree_skb(skb);\n\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 534,
    "line_new": 534,
    "critical_vars": [
      ".match_data.cmp"
    ],
    "function": "*request_key_and_link",
    "filename": "linux/CVE-2017-2647/CVE-2017-2647_CWE-476_c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81_request_key.c.diff",
    "function_code": "struct key *request_key_and_link(struct key_type *type,\n\t\t\t\t const char *description,\n\t\t\t\t const void *callout_info,\n\t\t\t\t size_t callout_len,\n\t\t\t\t void *aux,\n\t\t\t\t struct key *dest_keyring,\n\t\t\t\t unsigned long flags)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= type,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t};\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tint ret;\n\n\tkenter(\"%s,%s,%p,%zu,%p,%p,%lx\",\n\t       ctx.index_key.type->name, ctx.index_key.description,\n\t       callout_info, callout_len, aux, dest_keyring, flags);\n\n\tif (type->match_preparse) {\n\t\tret = type->match_preparse(&ctx.match_data);\n\t\tif (ret < 0) {\n\t\t\tkey = ERR_PTR(ret);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/* search all the process keyrings for a key */\n\tkey_ref = search_process_keyrings(&ctx);\n\n\tif (!IS_ERR(key_ref)) {\n\t\tkey = key_ref_to_ptr(key_ref);\n\t\tif (dest_keyring) {\n\t\t\tconstruct_get_dest_keyring(&dest_keyring);\n\t\t\tret = key_link(dest_keyring, key);\n\t\t\tkey_put(dest_keyring);\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_put(key);\n\t\t\t\tkey = ERR_PTR(ret);\n\t\t\t\tgoto error_free;\n\t\t\t}\n\t\t}\n\t} else if (PTR_ERR(key_ref) != -EAGAIN) {\n\t\tkey = ERR_CAST(key_ref);\n\t} else  {\n\t\t/* the search failed, but the keyrings were searchable, so we\n\t\t * should consult userspace if we can */\n\t\tkey = ERR_PTR(-ENOKEY);\n\t\tif (!callout_info)\n\t\t\tgoto error_free;\n\n\t\tkey = construct_key_and_link(&ctx, callout_info, callout_len,\n\t\t\t\t\t     aux, dest_keyring, flags);\n\t}\n\nerror_free:\n\tif (type->match_free)\n\t\ttype->match_free(&ctx.match_data);\nerror:\n\tkleave(\" = %p\", key);\n\treturn key;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 802,
    "critical_vars": [
      "index_key.type->match"
    ],
    "function": "key_create_or_update",
    "filename": "linux/CVE-2017-2647/CVE-2017-2647_CWE-476_c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81_key.c.diff",
    "function_code": "key_ref_t key_create_or_update(key_ref_t keyring_ref,\n\t\t\t       const char *type,\n\t\t\t       const char *description,\n\t\t\t       const void *payload,\n\t\t\t       size_t plen,\n\t\t\t       key_perm_t perm,\n\t\t\t       unsigned long flags)\n{\n\tstruct keyring_index_key index_key = {\n\t\t.description\t= description,\n\t};\n\tstruct key_preparsed_payload prep;\n\tstruct assoc_array_edit *edit;\n\tconst struct cred *cred = current_cred();\n\tstruct key *keyring, *key = NULL;\n\tkey_ref_t key_ref;\n\tint ret;\n\n\t/* look up the key type to see if it's one of the registered kernel\n\t * types */\n\tindex_key.type = key_type_lookup(type);\n\tif (IS_ERR(index_key.type)) {\n\t\tkey_ref = ERR_PTR(-ENODEV);\n\t\tgoto error;\n\t}\n\n\tkey_ref = ERR_PTR(-EINVAL);\n\tif (!index_key.type->match || !index_key.type->instantiate ||\n\t    (!index_key.description && !index_key.type->preparse))\n\t\tgoto error_put_type;\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\n\tkey_check(keyring);\n\n\tkey_ref = ERR_PTR(-ENOTDIR);\n\tif (keyring->type != &key_type_keyring)\n\t\tgoto error_put_type;\n\n\tmemset(&prep, 0, sizeof(prep));\n\tprep.data = payload;\n\tprep.datalen = plen;\n\tprep.quotalen = index_key.type->def_datalen;\n\tprep.trusted = flags & KEY_ALLOC_TRUSTED;\n\tprep.expiry = TIME_T_MAX;\n\tif (index_key.type->preparse) {\n\t\tret = index_key.type->preparse(&prep);\n\t\tif (ret < 0) {\n\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\tgoto error_free_prep;\n\t\t}\n\t\tif (!index_key.description)\n\t\t\tindex_key.description = prep.description;\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (!index_key.description)\n\t\t\tgoto error_free_prep;\n\t}\n\tindex_key.desc_len = strlen(index_key.description);\n\n\tkey_ref = ERR_PTR(-EPERM);\n\tif (!prep.trusted && test_bit(KEY_FLAG_TRUSTED_ONLY, &keyring->flags))\n\t\tgoto error_free_prep;\n\tflags |= prep.trusted ? KEY_ALLOC_TRUSTED : 0;\n\n\tret = __key_link_begin(keyring, &index_key, &edit);\n\tif (ret < 0) {\n\t\tkey_ref = ERR_PTR(ret);\n\t\tgoto error_free_prep;\n\t}\n\n\t/* if we're going to allocate a new key, we're going to have\n\t * to modify the keyring */\n\tret = key_permission(keyring_ref, KEY_NEED_WRITE);\n\tif (ret < 0) {\n\t\tkey_ref = ERR_PTR(ret);\n\t\tgoto error_link_end;\n\t}\n\n\t/* if it's possible to update this type of key, search for an existing\n\t * key of the same type and description in the destination keyring and\n\t * update that instead if possible\n\t */\n\tif (index_key.type->update) {\n\t\tkey_ref = find_key_to_update(keyring_ref, &index_key);\n\t\tif (key_ref)\n\t\t\tgoto found_matching_key;\n\t}\n\n\t/* if the client doesn't provide, decide on the permissions we want */\n\tif (perm == KEY_PERM_UNDEF) {\n\t\tperm = KEY_POS_VIEW | KEY_POS_SEARCH | KEY_POS_LINK | KEY_POS_SETATTR;\n\t\tperm |= KEY_USR_VIEW;\n\n\t\tif (index_key.type->read)\n\t\t\tperm |= KEY_POS_READ;\n\n\t\tif (index_key.type == &key_type_keyring ||\n\t\t    index_key.type->update)\n\t\t\tperm |= KEY_POS_WRITE;\n\t}\n\n\t/* allocate a new key */\n\tkey = key_alloc(index_key.type, index_key.description,\n\t\t\tcred->fsuid, cred->fsgid, cred, perm, flags);\n\tif (IS_ERR(key)) {\n\t\tkey_ref = ERR_CAST(key);\n\t\tgoto error_link_end;\n\t}\n\n\t/* instantiate it and link it into the target keyring */\n\tret = __key_instantiate_and_link(key, &prep, keyring, NULL, &edit);\n\tif (ret < 0) {\n\t\tkey_put(key);\n\t\tkey_ref = ERR_PTR(ret);\n\t\tgoto error_link_end;\n\t}\n\n\tkey_ref = make_key_ref(key, is_key_possessed(keyring_ref));\n\nerror_link_end:\n\t__key_link_end(keyring, &index_key, edit);\nerror_free_prep:\n\tif (index_key.type->preparse)\n\t\tindex_key.type->free_preparse(&prep);\nerror_put_type:\n\tkey_type_put(index_key.type);\nerror:\n\treturn key_ref;\n\n found_matching_key:\n\t/* we found a matching key, so we're going to try to update it\n\t * - we can drop the locks first as we have the key pinned\n\t */\n\t__key_link_end(keyring, &index_key, edit);\n\n\tkey_ref = __key_update(key_ref, &prep);\n\tgoto error_free_prep;\n}",
    "label": "True"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 887,
    "line_new": 895,
    "critical_vars": [
      ".match_data.cmp"
    ],
    "function": "keyring_search",
    "filename": "linux/CVE-2017-2647/CVE-2017-2647_CWE-476_c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81_keyring.c.diff",
    "function_code": "key_ref_t keyring_search(key_ref_t keyring,\n\t\t\t struct key_type *type,\n\t\t\t const char *description)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= type,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tkey_ref_t key;\n\tint ret;\n\n\tif (type->match_preparse) {\n\t\tret = type->match_preparse(&ctx.match_data);\n\t\tif (ret < 0)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\n\tkey = keyring_search_aux(keyring, &ctx);\n\n\tif (type->match_free)\n\t\ttype->match_free(&ctx.match_data);\n\treturn key;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 895,
    "critical_vars": [
      "ctx.match_data.cmp"
    ],
    "function": "keyring_search",
    "filename": "linux/CVE-2017-2647/CVE-2017-2647_CWE-476_c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81_keyring.c.diff",
    "function_code": "key_ref_t keyring_search(key_ref_t keyring,\n\t\t\t struct key_type *type,\n\t\t\t const char *description)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= type,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= type->match,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tkey_ref_t key;\n\tint ret;\n\n\tif (!ctx.match_data.cmp)\n\t\treturn ERR_PTR(-ENOKEY);\n\n\tif (type->match_preparse) {\n\t\tret = type->match_preparse(&ctx.match_data);\n\t\tif (ret < 0)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\n\tkey = keyring_search_aux(keyring, &ctx);\n\n\tif (type->match_free)\n\t\ttype->match_free(&ctx.match_data);\n\treturn key;\n}",
    "label": "True"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 249,
    "line_new": 249,
    "critical_vars": [
      ".match_data.cmp"
    ],
    "function": "*key_get_instantiation_authkey",
    "filename": "linux/CVE-2017-2647/CVE-2017-2647_CWE-476_c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81_request_key_auth.c.diff",
    "function_code": "struct key *key_get_instantiation_authkey(key_serial_t target_id)\n{\n\tchar description[16];\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= &key_type_request_key_auth,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t};\n\tstruct key *authkey;\n\tkey_ref_t authkey_ref;\n\n\tsprintf(description, \"%x\", target_id);\n\n\tauthkey_ref = search_process_keyrings(&ctx);\n\n\tif (IS_ERR(authkey_ref)) {\n\t\tauthkey = ERR_CAST(authkey_ref);\n\t\tif (authkey == ERR_PTR(-EAGAIN))\n\t\t\tauthkey = ERR_PTR(-ENOKEY);\n\t\tgoto error;\n\t}\n\n\tauthkey = key_ref_to_ptr(authkey_ref);\n\tif (test_bit(KEY_FLAG_REVOKED, &authkey->flags)) {\n\t\tkey_put(authkey);\n\t\tauthkey = ERR_PTR(-EKEYREVOKED);\n\t}\n\nerror:\n\treturn authkey;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 189,
    "critical_vars": [
      "alt->desc.bNumEndpoints"
    ],
    "function": "pb0100_start",
    "filename": "linux/CVE-2020-11609/CVE-2020-11609_CWE-476_485b06aadb933190f4bc44e006076bc27a23f205_stv06xx_pb0100.c.diff",
    "function_code": "static int pb0100_start(struct sd *sd)\n{\n\tint err, packet_size, max_packet_size;\n\tstruct usb_host_interface *alt;\n\tstruct usb_interface *intf;\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tstruct cam *cam = &sd->gspca_dev.cam;\n\tu32 mode = cam->cam_mode[sd->gspca_dev.curr_mode].priv;\n\n\tintf = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);\n\talt = usb_altnum_to_altsetting(intf, sd->gspca_dev.alt);\n\tif (!alt)\n\t\treturn -ENODEV;\n\n\tif (alt->desc.bNumEndpoints < 1)\n\t\treturn -ENODEV;\n\n\tpacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n\n\t/* If we don't have enough bandwidth use a lower framerate */\n\tmax_packet_size = sd->sensor->max_packet_size[sd->gspca_dev.curr_mode];\n\tif (packet_size < max_packet_size)\n\t\tstv06xx_write_sensor(sd, PB_ROWSPEED, BIT(4)|BIT(3)|BIT(1));\n\telse\n\t\tstv06xx_write_sensor(sd, PB_ROWSPEED, BIT(5)|BIT(3)|BIT(1));\n\n\t/* Setup sensor window */\n\tif (mode & PB0100_CROP_TO_VGA) {\n\t\tstv06xx_write_sensor(sd, PB_RSTART, 30);\n\t\tstv06xx_write_sensor(sd, PB_CSTART, 20);\n\t\tstv06xx_write_sensor(sd, PB_RWSIZE, 240 - 1);\n\t\tstv06xx_write_sensor(sd, PB_CWSIZE, 320 - 1);\n\t} else {\n\t\tstv06xx_write_sensor(sd, PB_RSTART, 8);\n\t\tstv06xx_write_sensor(sd, PB_CSTART, 4);\n\t\tstv06xx_write_sensor(sd, PB_RWSIZE, 288 - 1);\n\t\tstv06xx_write_sensor(sd, PB_CWSIZE, 352 - 1);\n\t}\n\n\tif (mode & PB0100_SUBSAMPLE) {\n\t\tstv06xx_write_bridge(sd, STV_Y_CTRL, 0x02); /* Wrong, FIXME */\n\t\tstv06xx_write_bridge(sd, STV_X_CTRL, 0x06);\n\n\t\tstv06xx_write_bridge(sd, STV_SCAN_RATE, 0x10);\n\t} else {\n\t\tstv06xx_write_bridge(sd, STV_Y_CTRL, 0x01);\n\t\tstv06xx_write_bridge(sd, STV_X_CTRL, 0x0a);\n\t\t/* larger -> slower */\n\t\tstv06xx_write_bridge(sd, STV_SCAN_RATE, 0x20);\n\t}\n\n\terr = stv06xx_write_sensor(sd, PB_CONTROL, BIT(5)|BIT(3)|BIT(1));\n\tgspca_dbg(gspca_dev, D_STREAM, \"Started stream, status: %d\\n\", err);\n\n\treturn (err < 0) ? err : 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 285,
    "critical_vars": [
      "alt->desc.bNumEndpoints"
    ],
    "function": "stv06xx_start",
    "filename": "linux/CVE-2020-11609/CVE-2020-11609_CWE-476_485b06aadb933190f4bc44e006076bc27a23f205_stv06xx.c.diff",
    "function_code": "static int stv06xx_start(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct usb_host_interface *alt;\n\tstruct usb_interface *intf;\n\tint err, packet_size;\n\n\tintf = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);\n\talt = usb_altnum_to_altsetting(intf, sd->gspca_dev.alt);\n\tif (!alt) {\n\t\tgspca_err(gspca_dev, \"Couldn't get altsetting\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (alt->desc.bNumEndpoints < 1)\n\t\treturn -ENODEV;\n\n\tpacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n\terr = stv06xx_write_bridge(sd, STV_ISO_SIZE_L, packet_size);\n\tif (err < 0)\n\t\treturn err;\n\n\t/* Prepare the sensor for start */\n\terr = sd->sensor->start(sd);\n\tif (err < 0)\n\t\tgoto out;\n\n\t/* Start isochronous streaming */\n\terr = stv06xx_write_bridge(sd, STV_ISO_ENABLE, 1);\n\nout:\n\tif (err < 0)\n\t\tgspca_dbg(gspca_dev, D_STREAM, \"Starting stream failed\\n\");\n\telse\n\t\tgspca_dbg(gspca_dev, D_STREAM, \"Started streaming\\n\");\n\n\treturn (err < 0) ? err : 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 316,
    "critical_vars": [
      "syscall_nr"
    ],
    "function": "ftrace_syscall_enter",
    "filename": "linux/CVE-2014-7826/CVE-2014-7826_CWE-476_086ba77a6db00ed858ff07451bedee197df868c9_trace_syscalls.c.diff",
    "function_code": "static void ftrace_syscall_enter(void *data, struct pt_regs *regs, long id)\n{\n\tstruct trace_array *tr = data;\n\tstruct ftrace_event_file *ftrace_file;\n\tstruct syscall_trace_enter *entry;\n\tstruct syscall_metadata *sys_data;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer;\n\tunsigned long irq_flags;\n\tint pc;\n\tint syscall_nr;\n\tint size;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0 || syscall_nr >= NR_syscalls)\n\t\treturn;\n\n\t/* Here we're inside tp handler's rcu_read_lock_sched (__DO_TRACE) */\n\tftrace_file = rcu_dereference_sched(tr->enter_syscall_files[syscall_nr]);\n\tif (!ftrace_file)\n\t\treturn;\n\n\tif (ftrace_trigger_soft_disabled(ftrace_file))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\tsize = sizeof(*entry) + sizeof(unsigned long) * sys_data->nb_args;\n\n\tlocal_save_flags(irq_flags);\n\tpc = preempt_count();\n\n\tbuffer = tr->trace_buffer.buffer;\n\tevent = trace_buffer_lock_reserve(buffer,\n\t\t\tsys_data->enter_event->event.type, size, irq_flags, pc);\n\tif (!event)\n\t\treturn;\n\n\tentry = ring_buffer_event_data(event);\n\tentry->nr = syscall_nr;\n\tsyscall_get_arguments(current, regs, 0, sys_data->nb_args, entry->args);\n\n\tevent_trigger_unlock_commit(ftrace_file, buffer, event, entry,\n\t\t\t\t    irq_flags, pc);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 363,
    "critical_vars": [
      "syscall_nr"
    ],
    "function": "ftrace_syscall_exit",
    "filename": "linux/CVE-2014-7826/CVE-2014-7826_CWE-476_086ba77a6db00ed858ff07451bedee197df868c9_trace_syscalls.c.diff",
    "function_code": "static void ftrace_syscall_exit(void *data, struct pt_regs *regs, long ret)\n{\n\tstruct trace_array *tr = data;\n\tstruct ftrace_event_file *ftrace_file;\n\tstruct syscall_trace_exit *entry;\n\tstruct syscall_metadata *sys_data;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer;\n\tunsigned long irq_flags;\n\tint pc;\n\tint syscall_nr;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0 || syscall_nr >= NR_syscalls)\n\t\treturn;\n\n\t/* Here we're inside tp handler's rcu_read_lock_sched (__DO_TRACE()) */\n\tftrace_file = rcu_dereference_sched(tr->exit_syscall_files[syscall_nr]);\n\tif (!ftrace_file)\n\t\treturn;\n\n\tif (ftrace_trigger_soft_disabled(ftrace_file))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\tlocal_save_flags(irq_flags);\n\tpc = preempt_count();\n\n\tbuffer = tr->trace_buffer.buffer;\n\tevent = trace_buffer_lock_reserve(buffer,\n\t\t\tsys_data->exit_event->event.type, sizeof(*entry),\n\t\t\tirq_flags, pc);\n\tif (!event)\n\t\treturn;\n\n\tentry = ring_buffer_event_data(event);\n\tentry->nr = syscall_nr;\n\tentry->ret = syscall_get_return_value(current, regs);\n\n\tevent_trigger_unlock_commit(ftrace_file, buffer, event, entry,\n\t\t\t\t    irq_flags, pc);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 570,
    "critical_vars": [
      "syscall_nr"
    ],
    "function": "perf_syscall_enter",
    "filename": "linux/CVE-2014-7826/CVE-2014-7826_CWE-476_086ba77a6db00ed858ff07451bedee197df868c9_trace_syscalls.c.diff",
    "function_code": "static void perf_syscall_enter(void *ignore, struct pt_regs *regs, long id)\n{\n\tstruct syscall_metadata *sys_data;\n\tstruct syscall_trace_enter *rec;\n\tstruct hlist_head *head;\n\tint syscall_nr;\n\tint rctx;\n\tint size;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0 || syscall_nr >= NR_syscalls)\n\t\treturn;\n\tif (!test_bit(syscall_nr, enabled_perf_enter_syscalls))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\thead = this_cpu_ptr(sys_data->enter_event->perf_events);\n\tif (hlist_empty(head))\n\t\treturn;\n\n\t/* get the size after alignment with the u32 buffer size field */\n\tsize = sizeof(unsigned long) * sys_data->nb_args + sizeof(*rec);\n\tsize = ALIGN(size + sizeof(u32), sizeof(u64));\n\tsize -= sizeof(u32);\n\n\trec = (struct syscall_trace_enter *)perf_trace_buf_prepare(size,\n\t\t\t\tsys_data->enter_event->event.type, regs, &rctx);\n\tif (!rec)\n\t\treturn;\n\n\trec->nr = syscall_nr;\n\tsyscall_get_arguments(current, regs, 0, sys_data->nb_args,\n\t\t\t       (unsigned long *)&rec->args);\n\tperf_trace_buf_submit(rec, size, rctx, 0, 1, regs, head, NULL);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 644,
    "critical_vars": [
      "syscall_nr"
    ],
    "function": "perf_syscall_exit",
    "filename": "linux/CVE-2014-7826/CVE-2014-7826_CWE-476_086ba77a6db00ed858ff07451bedee197df868c9_trace_syscalls.c.diff",
    "function_code": "static void perf_syscall_exit(void *ignore, struct pt_regs *regs, long ret)\n{\n\tstruct syscall_metadata *sys_data;\n\tstruct syscall_trace_exit *rec;\n\tstruct hlist_head *head;\n\tint syscall_nr;\n\tint rctx;\n\tint size;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0 || syscall_nr >= NR_syscalls)\n\t\treturn;\n\tif (!test_bit(syscall_nr, enabled_perf_exit_syscalls))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\thead = this_cpu_ptr(sys_data->exit_event->perf_events);\n\tif (hlist_empty(head))\n\t\treturn;\n\n\t/* We can probably do that at build time */\n\tsize = ALIGN(sizeof(*rec) + sizeof(u32), sizeof(u64));\n\tsize -= sizeof(u32);\n\n\trec = (struct syscall_trace_exit *)perf_trace_buf_prepare(size,\n\t\t\t\tsys_data->exit_event->event.type, regs, &rctx);\n\tif (!rec)\n\t\treturn;\n\n\trec->nr = syscall_nr;\n\trec->ret = syscall_get_return_value(current, regs);\n\tperf_trace_buf_submit(rec, size, rctx, 0, 1, regs, head, NULL);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 152,
    "critical_vars": [
      "res"
    ],
    "function": "hi3660_stub_clk_probe",
    "filename": "linux/CVE-2018-10074/CVE-2018-10074_CWE-476_9903e41ae1f5d50c93f268ca3304d4d7c64b9311_clk-hi3660-stub.c.diff",
    "function_code": "static int hi3660_stub_clk_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *res;\n\tunsigned int i;\n\tint ret;\n\n\t/* Use mailbox client without blocking */\n\tstub_clk_chan.cl.dev = dev;\n\tstub_clk_chan.cl.tx_done = NULL;\n\tstub_clk_chan.cl.tx_block = false;\n\tstub_clk_chan.cl.knows_txdone = false;\n\n\t/* Allocate mailbox channel */\n\tstub_clk_chan.mbox = mbox_request_channel(&stub_clk_chan.cl, 0);\n\tif (IS_ERR(stub_clk_chan.mbox))\n\t\treturn PTR_ERR(stub_clk_chan.mbox);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -EINVAL;\n\tfreq_reg = devm_ioremap(dev, res->start, resource_size(res));\n\tif (!freq_reg)\n\t\treturn -ENOMEM;\n\n\tfreq_reg += HI3660_STUB_CLOCK_DATA;\n\n\tfor (i = 0; i < HI3660_CLK_STUB_NUM; i++) {\n\t\tret = devm_clk_hw_register(&pdev->dev, &hi3660_stub_clks[i].hw);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn devm_of_clk_add_hw_provider(&pdev->dev, hi3660_stub_clk_hw_get,\n\t\t\t\t\t   hi3660_stub_clks);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 184,
    "critical_vars": [
      "more"
    ],
    "function": "hash_accept",
    "filename": "linux/CVE-2016-8646/CVE-2016-8646_CWE-476_4afa5f9617927453ac04b24b584f6c718dfb4f45_algif_hash.c.diff",
    "function_code": "static int hash_accept(struct socket *sock, struct socket *newsock, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct hash_ctx *ctx = ask->private;\n\tstruct ahash_request *req = &ctx->req;\n\tchar state[crypto_ahash_statesize(crypto_ahash_reqtfm(req))];\n\tstruct sock *sk2;\n\tstruct alg_sock *ask2;\n\tstruct hash_ctx *ctx2;\n\tbool more;\n\tint err;\n\n\tlock_sock(sk);\n\tmore = ctx->more;\n\terr = more ? crypto_ahash_export(req, state) : 0;\n\trelease_sock(sk);\n\n\tif (err)\n\t\treturn err;\n\n\terr = af_alg_accept(ask->parent, newsock);\n\tif (err)\n\t\treturn err;\n\n\tsk2 = newsock->sk;\n\task2 = alg_sk(sk2);\n\tctx2 = ask2->private;\n\tctx2->more = more;\n\n\tif (!more)\n\t\treturn err;\n\n\terr = crypto_ahash_import(&ctx2->req, state);\n\tif (err) {\n\t\tsock_orphan(sk2);\n\t\tsock_put(sk2);\n\t}\n\n\treturn err;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 186,
    "critical_vars": [
      "err"
    ],
    "function": "hash_accept",
    "filename": "linux/CVE-2016-8646/CVE-2016-8646_CWE-476_4afa5f9617927453ac04b24b584f6c718dfb4f45_algif_hash.c.diff",
    "function_code": "static int hash_accept(struct socket *sock, struct socket *newsock, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct hash_ctx *ctx = ask->private;\n\tstruct ahash_request *req = &ctx->req;\n\tchar state[crypto_ahash_statesize(crypto_ahash_reqtfm(req))];\n\tstruct sock *sk2;\n\tstruct alg_sock *ask2;\n\tstruct hash_ctx *ctx2;\n\tint err;\n\n\terr = crypto_ahash_export(req, state);\n\tif (err)\n\t\treturn err;\n\n\terr = af_alg_accept(ask->parent, newsock);\n\tif (err)\n\t\treturn err;\n\n\tsk2 = newsock->sk;\n\task2 = alg_sk(sk2);\n\tctx2 = ask2->private;\n\tctx2->more = 1;\n\n\terr = crypto_ahash_import(&ctx2->req, state);\n\tif (err) {\n\t\tsock_orphan(sk2);\n\t\tsock_put(sk2);\n\t}\n\n\treturn err;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 1241,
    "critical_vars": [
      "skb"
    ],
    "function": "ipv4_pktinfo_prepare",
    "filename": "linux/CVE-2017-5970/CVE-2017-5970_CWE-476_34b2cef20f19c87999fff3da4071e66937db9644_ip_sockglue.c.diff",
    "function_code": "void ipv4_pktinfo_prepare(const struct sock *sk, struct sk_buff *skb)\n{\n\tstruct in_pktinfo *pktinfo = PKTINFO_SKB_CB(skb);\n\tbool prepare = (inet_sk(sk)->cmsg_flags & IP_CMSG_PKTINFO) ||\n\t\t       ipv6_sk_rxinfo(sk);\n\n\tif (prepare && skb_rtable(skb)) {\n\t\t/* skb->cb is overloaded: prior to this point it is IP{6}CB\n\t\t * which has interface index (iif) as the first member of the\n\t\t * underlying inet{6}_skb_parm struct. This code then overlays\n\t\t * PKTINFO_SKB_CB and in_pktinfo also has iif as the first\n\t\t * element so the iif is picked up from the prior IPCB. If iif\n\t\t * is the loopback interface, then return the sending interface\n\t\t * (e.g., process binds socket to eth0 for Tx which is\n\t\t * redirected to loopback in the rtable/dst).\n\t\t */\n\t\tif (pktinfo->ipi_ifindex == LOOPBACK_IFINDEX)\n\t\t\tpktinfo->ipi_ifindex = inet_iif(skb);\n\n\t\tpktinfo->ipi_spec_dst.s_addr = fib_compute_spec_dst(skb);\n\t} else {\n\t\tpktinfo->ipi_ifindex = 0;\n\t\tpktinfo->ipi_spec_dst.s_addr = 0;\n\t}\n\tskb_dst_drop(skb);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1245,
    "critical_vars": [
      "skb"
    ],
    "function": "ipv4_pktinfo_prepare",
    "filename": "linux/CVE-2017-5970/CVE-2017-5970_CWE-476_34b2cef20f19c87999fff3da4071e66937db9644_ip_sockglue.c.diff",
    "function_code": "void ipv4_pktinfo_prepare(const struct sock *sk, struct sk_buff *skb)\n{\n\tstruct in_pktinfo *pktinfo = PKTINFO_SKB_CB(skb);\n\tbool prepare = (inet_sk(sk)->cmsg_flags & IP_CMSG_PKTINFO) ||\n\t\t       ipv6_sk_rxinfo(sk);\n\n\tif (prepare && skb_rtable(skb)) {\n\t\t/* skb->cb is overloaded: prior to this point it is IP{6}CB\n\t\t * which has interface index (iif) as the first member of the\n\t\t * underlying inet{6}_skb_parm struct. This code then overlays\n\t\t * PKTINFO_SKB_CB and in_pktinfo also has iif as the first\n\t\t * element so the iif is picked up from the prior IPCB. If iif\n\t\t * is the loopback interface, then return the sending interface\n\t\t * (e.g., process binds socket to eth0 for Tx which is\n\t\t * redirected to loopback in the rtable/dst).\n\t\t */\n\t\tif (pktinfo->ipi_ifindex == LOOPBACK_IFINDEX)\n\t\t\tpktinfo->ipi_ifindex = inet_iif(skb);\n\n\t\tpktinfo->ipi_spec_dst.s_addr = fib_compute_spec_dst(skb);\n\t} else {\n\t\tpktinfo->ipi_ifindex = 0;\n\t\tpktinfo->ipi_spec_dst.s_addr = 0;\n\t}\n\t/* We need to keep the dst for __ip_options_echo()\n\t * We could restrict the test to opt.ts_needtime || opt.srr,\n\t * but the following is good enough as IP options are not often used.\n\t */\n\tif (unlikely(IPCB(skb)->opt.optlen))\n\t\tskb_dst_force(skb);\n\telse\n\t\tskb_dst_drop(skb);\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 560,
    "line_new": 560,
    "critical_vars": [
      "host->reg_va09"
    ],
    "function": "ufs_mtk_init_va09_pwr_ctrl",
    "filename": "linux/CVE-2023-23001/CVE-2023-23001_CWE-476_3ba880a12df5aa4488c18281701b5b1bc3d4531a_ufs-mediatek.c.diff",
    "function_code": "static void ufs_mtk_init_va09_pwr_ctrl(struct ufs_hba *hba)\n{\n\tstruct ufs_mtk_host *host = ufshcd_get_variant(hba);\n\n\thost->reg_va09 = regulator_get(hba->dev, \"va09\");\n\tif (IS_ERR(host->reg_va09))\n\t\tdev_info(hba->dev, \"failed to get va09\");\n\telse\n\t\thost->caps |= UFS_MTK_CAP_VA09_PWR_CTRL;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 5048,
    "critical_vars": [
      "ctxt->memopp"
    ],
    "function": "x86_decode_insn",
    "filename": "linux/CVE-2016-8630/CVE-2016-8630_CWE-476_d9092f52d7e61dd1557f2db2400ddb430e85937e_emulate.c.diff",
    "function_code": "int x86_decode_insn(struct x86_emulate_ctxt *ctxt, void *insn, int insn_len)\n{\n\tint rc = X86EMUL_CONTINUE;\n\tint mode = ctxt->mode;\n\tint def_op_bytes, def_ad_bytes, goffset, simd_prefix;\n\tbool op_prefix = false;\n\tbool has_seg_override = false;\n\tstruct opcode opcode;\n\n\tctxt->memop.type = OP_NONE;\n\tctxt->memopp = NULL;\n\tctxt->_eip = ctxt->eip;\n\tctxt->fetch.ptr = ctxt->fetch.data;\n\tctxt->fetch.end = ctxt->fetch.data + insn_len;\n\tctxt->opcode_len = 1;\n\tif (insn_len > 0)\n\t\tmemcpy(ctxt->fetch.data, insn, insn_len);\n\telse {\n\t\trc = __do_insn_fetch_bytes(ctxt, 1);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\treturn rc;\n\t}\n\n\tswitch (mode) {\n\tcase X86EMUL_MODE_REAL:\n\tcase X86EMUL_MODE_VM86:\n\tcase X86EMUL_MODE_PROT16:\n\t\tdef_op_bytes = def_ad_bytes = 2;\n\t\tbreak;\n\tcase X86EMUL_MODE_PROT32:\n\t\tdef_op_bytes = def_ad_bytes = 4;\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase X86EMUL_MODE_PROT64:\n\t\tdef_op_bytes = 4;\n\t\tdef_ad_bytes = 8;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn EMULATION_FAILED;\n\t}\n\n\tctxt->op_bytes = def_op_bytes;\n\tctxt->ad_bytes = def_ad_bytes;\n\n\t/* Legacy prefixes. */\n\tfor (;;) {\n\t\tswitch (ctxt->b = insn_fetch(u8, ctxt)) {\n\t\tcase 0x66:\t/* operand-size override */\n\t\t\top_prefix = true;\n\t\t\t/* switch between 2/4 bytes */\n\t\t\tctxt->op_bytes = def_op_bytes ^ 6;\n\t\t\tbreak;\n\t\tcase 0x67:\t/* address-size override */\n\t\t\tif (mode == X86EMUL_MODE_PROT64)\n\t\t\t\t/* switch between 4/8 bytes */\n\t\t\t\tctxt->ad_bytes = def_ad_bytes ^ 12;\n\t\t\telse\n\t\t\t\t/* switch between 2/4 bytes */\n\t\t\t\tctxt->ad_bytes = def_ad_bytes ^ 6;\n\t\t\tbreak;\n\t\tcase 0x26:\t/* ES override */\n\t\tcase 0x2e:\t/* CS override */\n\t\tcase 0x36:\t/* SS override */\n\t\tcase 0x3e:\t/* DS override */\n\t\t\thas_seg_override = true;\n\t\t\tctxt->seg_override = (ctxt->b >> 3) & 3;\n\t\t\tbreak;\n\t\tcase 0x64:\t/* FS override */\n\t\tcase 0x65:\t/* GS override */\n\t\t\thas_seg_override = true;\n\t\t\tctxt->seg_override = ctxt->b & 7;\n\t\t\tbreak;\n\t\tcase 0x40 ... 0x4f: /* REX */\n\t\t\tif (mode != X86EMUL_MODE_PROT64)\n\t\t\t\tgoto done_prefixes;\n\t\t\tctxt->rex_prefix = ctxt->b;\n\t\t\tcontinue;\n\t\tcase 0xf0:\t/* LOCK */\n\t\t\tctxt->lock_prefix = 1;\n\t\t\tbreak;\n\t\tcase 0xf2:\t/* REPNE/REPNZ */\n\t\tcase 0xf3:\t/* REP/REPE/REPZ */\n\t\t\tctxt->rep_prefix = ctxt->b;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto done_prefixes;\n\t\t}\n\n\t\t/* Any legacy prefix after a REX prefix nullifies its effect. */\n\n\t\tctxt->rex_prefix = 0;\n\t}\n\ndone_prefixes:\n\n\t/* REX prefix. */\n\tif (ctxt->rex_prefix & 8)\n\t\tctxt->op_bytes = 8;\t/* REX.W */\n\n\t/* Opcode byte(s). */\n\topcode = opcode_table[ctxt->b];\n\t/* Two-byte opcode? */\n\tif (ctxt->b == 0x0f) {\n\t\tctxt->opcode_len = 2;\n\t\tctxt->b = insn_fetch(u8, ctxt);\n\t\topcode = twobyte_table[ctxt->b];\n\n\t\t/* 0F_38 opcode map */\n\t\tif (ctxt->b == 0x38) {\n\t\t\tctxt->opcode_len = 3;\n\t\t\tctxt->b = insn_fetch(u8, ctxt);\n\t\t\topcode = opcode_map_0f_38[ctxt->b];\n\t\t}\n\t}\n\tctxt->d = opcode.flags;\n\n\tif (ctxt->d & ModRM)\n\t\tctxt->modrm = insn_fetch(u8, ctxt);\n\n\t/* vex-prefix instructions are not implemented */\n\tif (ctxt->opcode_len == 1 && (ctxt->b == 0xc5 || ctxt->b == 0xc4) &&\n\t    (mode == X86EMUL_MODE_PROT64 || (ctxt->modrm & 0xc0) == 0xc0)) {\n\t\tctxt->d = NotImpl;\n\t}\n\n\twhile (ctxt->d & GroupMask) {\n\t\tswitch (ctxt->d & GroupMask) {\n\t\tcase Group:\n\t\t\tgoffset = (ctxt->modrm >> 3) & 7;\n\t\t\topcode = opcode.u.group[goffset];\n\t\t\tbreak;\n\t\tcase GroupDual:\n\t\t\tgoffset = (ctxt->modrm >> 3) & 7;\n\t\t\tif ((ctxt->modrm >> 6) == 3)\n\t\t\t\topcode = opcode.u.gdual->mod3[goffset];\n\t\t\telse\n\t\t\t\topcode = opcode.u.gdual->mod012[goffset];\n\t\t\tbreak;\n\t\tcase RMExt:\n\t\t\tgoffset = ctxt->modrm & 7;\n\t\t\topcode = opcode.u.group[goffset];\n\t\t\tbreak;\n\t\tcase Prefix:\n\t\t\tif (ctxt->rep_prefix && op_prefix)\n\t\t\t\treturn EMULATION_FAILED;\n\t\t\tsimd_prefix = op_prefix ? 0x66 : ctxt->rep_prefix;\n\t\t\tswitch (simd_prefix) {\n\t\t\tcase 0x00: opcode = opcode.u.gprefix->pfx_no; break;\n\t\t\tcase 0x66: opcode = opcode.u.gprefix->pfx_66; break;\n\t\t\tcase 0xf2: opcode = opcode.u.gprefix->pfx_f2; break;\n\t\t\tcase 0xf3: opcode = opcode.u.gprefix->pfx_f3; break;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Escape:\n\t\t\tif (ctxt->modrm > 0xbf)\n\t\t\t\topcode = opcode.u.esc->high[ctxt->modrm - 0xc0];\n\t\t\telse\n\t\t\t\topcode = opcode.u.esc->op[(ctxt->modrm >> 3) & 7];\n\t\t\tbreak;\n\t\tcase InstrDual:\n\t\t\tif ((ctxt->modrm >> 6) == 3)\n\t\t\t\topcode = opcode.u.idual->mod3;\n\t\t\telse\n\t\t\t\topcode = opcode.u.idual->mod012;\n\t\t\tbreak;\n\t\tcase ModeDual:\n\t\t\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\t\t\topcode = opcode.u.mdual->mode64;\n\t\t\telse\n\t\t\t\topcode = opcode.u.mdual->mode32;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn EMULATION_FAILED;\n\t\t}\n\n\t\tctxt->d &= ~(u64)GroupMask;\n\t\tctxt->d |= opcode.flags;\n\t}\n\n\t/* Unrecognised? */\n\tif (ctxt->d == 0)\n\t\treturn EMULATION_FAILED;\n\n\tctxt->execute = opcode.u.execute;\n\n\tif (unlikely(ctxt->ud) && likely(!(ctxt->d & EmulateOnUD)))\n\t\treturn EMULATION_FAILED;\n\n\tif (unlikely(ctxt->d &\n\t    (NotImpl|Stack|Op3264|Sse|Mmx|Intercept|CheckPerm|NearBranch|\n\t     No16))) {\n\t\t/*\n\t\t * These are copied unconditionally here, and checked unconditionally\n\t\t * in x86_emulate_insn.\n\t\t */\n\t\tctxt->check_perm = opcode.check_perm;\n\t\tctxt->intercept = opcode.intercept;\n\n\t\tif (ctxt->d & NotImpl)\n\t\t\treturn EMULATION_FAILED;\n\n\t\tif (mode == X86EMUL_MODE_PROT64) {\n\t\t\tif (ctxt->op_bytes == 4 && (ctxt->d & Stack))\n\t\t\t\tctxt->op_bytes = 8;\n\t\t\telse if (ctxt->d & NearBranch)\n\t\t\t\tctxt->op_bytes = 8;\n\t\t}\n\n\t\tif (ctxt->d & Op3264) {\n\t\t\tif (mode == X86EMUL_MODE_PROT64)\n\t\t\t\tctxt->op_bytes = 8;\n\t\t\telse\n\t\t\t\tctxt->op_bytes = 4;\n\t\t}\n\n\t\tif ((ctxt->d & No16) && ctxt->op_bytes == 2)\n\t\t\tctxt->op_bytes = 4;\n\n\t\tif (ctxt->d & Sse)\n\t\t\tctxt->op_bytes = 16;\n\t\telse if (ctxt->d & Mmx)\n\t\t\tctxt->op_bytes = 8;\n\t}\n\n\t/* ModRM and SIB bytes. */\n\tif (ctxt->d & ModRM) {\n\t\trc = decode_modrm(ctxt, &ctxt->memop);\n\t\tif (!has_seg_override) {\n\t\t\thas_seg_override = true;\n\t\t\tctxt->seg_override = ctxt->modrm_seg;\n\t\t}\n\t} else if (ctxt->d & MemAbs)\n\t\trc = decode_abs(ctxt, &ctxt->memop);\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\n\tif (!has_seg_override)\n\t\tctxt->seg_override = VCPU_SREG_DS;\n\n\tctxt->memop.addr.mem.seg = ctxt->seg_override;\n\n\t/*\n\t * Decode and fetch the source operand: register, memory\n\t * or immediate.\n\t */\n\trc = decode_operand(ctxt, &ctxt->src, (ctxt->d >> SrcShift) & OpMask);\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\n\t/*\n\t * Decode and fetch the second source operand: register, memory\n\t * or immediate.\n\t */\n\trc = decode_operand(ctxt, &ctxt->src2, (ctxt->d >> Src2Shift) & OpMask);\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\n\t/* Decode and fetch the destination operand: register or memory. */\n\trc = decode_operand(ctxt, &ctxt->dst, (ctxt->d >> DstShift) & OpMask);\n\n\tif (ctxt->rip_relative && likely(ctxt->memopp))\n\t\tctxt->memopp->addr.mem.ea = address_mask(ctxt,\n\t\t\t\t\tctxt->memopp->addr.mem.ea + ctxt->_eip);\n\ndone:\n\treturn (rc != X86EMUL_CONTINUE) ? EMULATION_FAILED : EMULATION_OK;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 762,
    "critical_vars": [
      "new_asoc->peer.auth_capable",
      "net->sctp.auth_enable"
    ],
    "function": "sctp_sf_do_5_1D_ce",
    "filename": "linux/CVE-2014-0101/CVE-2014-0101_CWE-476_ec0223ec48a90cb605244b45f7c62de856403729_sm_statefuns.c.diff",
    "function_code": "sctp_disposition_t sctp_sf_do_5_1D_ce(struct net *net,\n\t\t\t\t      const struct sctp_endpoint *ep,\n\t\t\t\t      const struct sctp_association *asoc,\n\t\t\t\t      const sctp_subtype_t type, void *arg,\n\t\t\t\t      sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_association *new_asoc;\n\tsctp_init_chunk_t *peer_init;\n\tstruct sctp_chunk *repl;\n\tstruct sctp_ulpevent *ev, *ai_ev = NULL;\n\tint error = 0;\n\tstruct sctp_chunk *err_chk_p;\n\tstruct sock *sk;\n\n\t/* If the packet is an OOTB packet which is temporarily on the\n\t * control endpoint, respond with an ABORT.\n\t */\n\tif (ep == sctp_sk(net->sctp.ctl_sock)->ep) {\n\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\t}\n\n\t/* Make sure that the COOKIE_ECHO chunk has a valid length.\n\t * In this case, we check that we have enough for at least a\n\t * chunk header.  More detailed verification is done\n\t * in sctp_unpack_cookie().\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* If the endpoint is not listening or if the number of associations\n\t * on the TCP-style socket exceed the max backlog, respond with an\n\t * ABORT.\n\t */\n\tsk = ep->base.sk;\n\tif (!sctp_sstate(sk, LISTENING) ||\n\t    (sctp_style(sk, TCP) && sk_acceptq_is_full(sk)))\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\n\t/* \"Decode\" the chunk.  We have no optional parameters so we\n\t * are in good shape.\n\t */\n\tchunk->subh.cookie_hdr =\n\t\t(struct sctp_signed_cookie *)chunk->skb->data;\n\tif (!pskb_pull(chunk->skb, ntohs(chunk->chunk_hdr->length) -\n\t\t\t\t\t sizeof(sctp_chunkhdr_t)))\n\t\tgoto nomem;\n\n\t/* 5.1 D) Upon reception of the COOKIE ECHO chunk, Endpoint\n\t * \"Z\" will reply with a COOKIE ACK chunk after building a TCB\n\t * and moving to the ESTABLISHED state.\n\t */\n\tnew_asoc = sctp_unpack_cookie(ep, asoc, chunk, GFP_ATOMIC, &error,\n\t\t\t\t      &err_chk_p);\n\n\t/* FIXME:\n\t * If the re-build failed, what is the proper error path\n\t * from here?\n\t *\n\t * [We should abort the association. --piggy]\n\t */\n\tif (!new_asoc) {\n\t\t/* FIXME: Several errors are possible.  A bad cookie should\n\t\t * be silently discarded, but think about logging it too.\n\t\t */\n\t\tswitch (error) {\n\t\tcase -SCTP_IERROR_NOMEM:\n\t\t\tgoto nomem;\n\n\t\tcase -SCTP_IERROR_STALE_COOKIE:\n\t\t\tsctp_send_stale_cookie_err(net, ep, asoc, chunk, commands,\n\t\t\t\t\t\t   err_chk_p);\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t\tcase -SCTP_IERROR_BAD_SIG:\n\t\tdefault:\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\t}\n\t}\n\n\n\t/* Delay state machine commands until later.\n\t *\n\t * Re-build the bind address for the association is done in\n\t * the sctp_unpack_cookie() already.\n\t */\n\t/* This is a brand-new association, so these are not yet side\n\t * effects--it is safe to run them here.\n\t */\n\tpeer_init = &chunk->subh.cookie_hdr->c.peer_init[0];\n\n\tif (!sctp_process_init(new_asoc, chunk,\n\t\t\t       &chunk->subh.cookie_hdr->c.peer_addr,\n\t\t\t       peer_init, GFP_ATOMIC))\n\t\tgoto nomem_init;\n\n\t/* SCTP-AUTH:  Now that we've populate required fields in\n\t * sctp_process_init, set up the assocaition shared keys as\n\t * necessary so that we can potentially authenticate the ACK\n\t */\n\terror = sctp_auth_asoc_init_active_key(new_asoc, GFP_ATOMIC);\n\tif (error)\n\t\tgoto nomem_init;\n\n\t/* SCTP-AUTH:  auth_chunk pointer is only set when the cookie-echo\n\t * is supposed to be authenticated and we have to do delayed\n\t * authentication.  We've just recreated the association using\n\t * the information in the cookie and now it's much easier to\n\t * do the authentication.\n\t */\n\tif (chunk->auth_chunk) {\n\t\tstruct sctp_chunk auth;\n\t\tsctp_ierror_t ret;\n\n\t\t/* Make sure that we and the peer are AUTH capable */\n\t\tif (!net->sctp.auth_enable || !new_asoc->peer.auth_capable) {\n\t\t\tkfree_skb(chunk->auth_chunk);\n\t\t\tsctp_association_free(new_asoc);\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\t}\n\n\t\t/* set-up our fake chunk so that we can process it */\n\t\tauth.skb = chunk->auth_chunk;\n\t\tauth.asoc = chunk->asoc;\n\t\tauth.sctp_hdr = chunk->sctp_hdr;\n\t\tauth.chunk_hdr = (sctp_chunkhdr_t *)skb_push(chunk->auth_chunk,\n\t\t\t\t\t    sizeof(sctp_chunkhdr_t));\n\t\tskb_pull(chunk->auth_chunk, sizeof(sctp_chunkhdr_t));\n\t\tauth.transport = chunk->transport;\n\n\t\tret = sctp_sf_authenticate(net, ep, new_asoc, type, &auth);\n\n\t\t/* We can now safely free the auth_chunk clone */\n\t\tkfree_skb(chunk->auth_chunk);\n\n\t\tif (ret != SCTP_IERROR_NO_ERROR) {\n\t\t\tsctp_association_free(new_asoc);\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\t}\n\t}\n\n\trepl = sctp_make_cookie_ack(new_asoc, chunk);\n\tif (!repl)\n\t\tgoto nomem_init;\n\n\t/* RFC 2960 5.1 Normal Establishment of an Association\n\t *\n\t * D) IMPLEMENTATION NOTE: An implementation may choose to\n\t * send the Communication Up notification to the SCTP user\n\t * upon reception of a valid COOKIE ECHO chunk.\n\t */\n\tev = sctp_ulpevent_make_assoc_change(new_asoc, 0, SCTP_COMM_UP, 0,\n\t\t\t\t\t     new_asoc->c.sinit_num_ostreams,\n\t\t\t\t\t     new_asoc->c.sinit_max_instreams,\n\t\t\t\t\t     NULL, GFP_ATOMIC);\n\tif (!ev)\n\t\tgoto nomem_ev;\n\n\t/* Sockets API Draft Section 5.3.1.6\n\t * When a peer sends a Adaptation Layer Indication parameter , SCTP\n\t * delivers this notification to inform the application that of the\n\t * peers requested adaptation layer.\n\t */\n\tif (new_asoc->peer.adaptation_ind) {\n\t\tai_ev = sctp_ulpevent_make_adaptation_indication(new_asoc,\n\t\t\t\t\t\t\t    GFP_ATOMIC);\n\t\tif (!ai_ev)\n\t\t\tgoto nomem_aiev;\n\t}\n\n\t/* Add all the state machine commands now since we've created\n\t * everything.  This way we don't introduce memory corruptions\n\t * during side-effect processing and correclty count established\n\t * associations.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_ASOC, SCTP_ASOC(new_asoc));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_ESTABLISHED));\n\tSCTP_INC_STATS(net, SCTP_MIB_CURRESTAB);\n\tSCTP_INC_STATS(net, SCTP_MIB_PASSIVEESTABS);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_START, SCTP_NULL());\n\n\tif (new_asoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE])\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\n\t/* This will send the COOKIE ACK */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\n\t/* Queue the ASSOC_CHANGE event */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev));\n\n\t/* Send up the Adaptation Layer Indication event */\n\tif (ai_ev)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(ai_ev));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem_aiev:\n\tsctp_ulpevent_free(ev);\nnomem_ev:\n\tsctp_chunk_free(repl);\nnomem_init:\n\tsctp_association_free(new_asoc);\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 3480,
    "critical_vars": [
      "alt->desc.bNumEndpoints"
    ],
    "function": "ov511_mode_init_regs",
    "filename": "linux/CVE-2020-11608/CVE-2020-11608_CWE-476_998912346c0da53a6dbb71fab3a138586b596b30_ov519.c.diff",
    "function_code": "static void ov511_mode_init_regs(struct sd *sd)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint hsegs, vsegs, packet_size, fps, needed;\n\tint interlaced = 0;\n\tstruct usb_host_interface *alt;\n\tstruct usb_interface *intf;\n\n\tintf = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);\n\talt = usb_altnum_to_altsetting(intf, sd->gspca_dev.alt);\n\tif (!alt) {\n\t\tgspca_err(gspca_dev, \"Couldn't get altsetting\\n\");\n\t\tsd->gspca_dev.usb_err = -EIO;\n\t\treturn;\n\t}\n\n\tif (alt->desc.bNumEndpoints < 1) {\n\t\tsd->gspca_dev.usb_err = -ENODEV;\n\t\treturn;\n\t}\n\n\tpacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n\treg_w(sd, R51x_FIFO_PSIZE, packet_size >> 5);\n\n\treg_w(sd, R511_CAM_UV_EN, 0x01);\n\treg_w(sd, R511_SNAP_UV_EN, 0x01);\n\treg_w(sd, R511_SNAP_OPTS, 0x03);\n\n\t/* Here I'm assuming that snapshot size == image size.\n\t * I hope that's always true. --claudio\n\t */\n\thsegs = (sd->gspca_dev.pixfmt.width >> 3) - 1;\n\tvsegs = (sd->gspca_dev.pixfmt.height >> 3) - 1;\n\n\treg_w(sd, R511_CAM_PXCNT, hsegs);\n\treg_w(sd, R511_CAM_LNCNT, vsegs);\n\treg_w(sd, R511_CAM_PXDIV, 0x00);\n\treg_w(sd, R511_CAM_LNDIV, 0x00);\n\n\t/* YUV420, low pass filter on */\n\treg_w(sd, R511_CAM_OPTS, 0x03);\n\n\t/* Snapshot additions */\n\treg_w(sd, R511_SNAP_PXCNT, hsegs);\n\treg_w(sd, R511_SNAP_LNCNT, vsegs);\n\treg_w(sd, R511_SNAP_PXDIV, 0x00);\n\treg_w(sd, R511_SNAP_LNDIV, 0x00);\n\n\t/******** Set the framerate ********/\n\tif (frame_rate > 0)\n\t\tsd->frame_rate = frame_rate;\n\n\tswitch (sd->sensor) {\n\tcase SEN_OV6620:\n\t\t/* No framerate control, doesn't like higher rates yet */\n\t\tsd->clockdiv = 3;\n\t\tbreak;\n\n\t/* Note once the FIXME's in mode_init_ov_sensor_regs() are fixed\n\t   for more sensors we need to do this for them too */\n\tcase SEN_OV7620:\n\tcase SEN_OV7620AE:\n\tcase SEN_OV7640:\n\tcase SEN_OV7648:\n\tcase SEN_OV76BE:\n\t\tif (sd->gspca_dev.pixfmt.width == 320)\n\t\t\tinterlaced = 1;\n\t\t/* Fall through */\n\tcase SEN_OV6630:\n\tcase SEN_OV7610:\n\tcase SEN_OV7670:\n\t\tswitch (sd->frame_rate) {\n\t\tcase 30:\n\t\tcase 25:\n\t\t\t/* Not enough bandwidth to do 640x480 @ 30 fps */\n\t\t\tif (sd->gspca_dev.pixfmt.width != 640) {\n\t\t\t\tsd->clockdiv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* For 640x480 case */\n\t\t\t/* fall through */\n\t\tdefault:\n/*\t\tcase 20: */\n/*\t\tcase 15: */\n\t\t\tsd->clockdiv = 1;\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tsd->clockdiv = 2;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tsd->clockdiv = 5;\n\t\t\tbreak;\n\t\t}\n\t\tif (interlaced) {\n\t\t\tsd->clockdiv = (sd->clockdiv + 1) * 2 - 1;\n\t\t\t/* Higher then 10 does not work */\n\t\t\tif (sd->clockdiv > 10)\n\t\t\t\tsd->clockdiv = 10;\n\t\t}\n\t\tbreak;\n\n\tcase SEN_OV8610:\n\t\t/* No framerate control ?? */\n\t\tsd->clockdiv = 0;\n\t\tbreak;\n\t}\n\n\t/* Check if we have enough bandwidth to disable compression */\n\tfps = (interlaced ? 60 : 30) / (sd->clockdiv + 1) + 1;\n\tneeded = fps * sd->gspca_dev.pixfmt.width *\n\t\t\tsd->gspca_dev.pixfmt.height * 3 / 2;\n\t/* 1000 isoc packets/sec */\n\tif (needed > 1000 * packet_size) {\n\t\t/* Enable Y and UV quantization and compression */\n\t\treg_w(sd, R511_COMP_EN, 0x07);\n\t\treg_w(sd, R511_COMP_LUT_EN, 0x03);\n\t} else {\n\t\treg_w(sd, R511_COMP_EN, 0x06);\n\t\treg_w(sd, R511_COMP_LUT_EN, 0x00);\n\t}\n\n\treg_w(sd, R51x_SYS_RESET, OV511_RESET_OMNICE);\n\treg_w(sd, R51x_SYS_RESET, 0);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 3611,
    "critical_vars": [
      "alt->desc.bNumEndpoints"
    ],
    "function": "ov518_mode_init_regs",
    "filename": "linux/CVE-2020-11608/CVE-2020-11608_CWE-476_998912346c0da53a6dbb71fab3a138586b596b30_ov519.c.diff",
    "function_code": "static void ov518_mode_init_regs(struct sd *sd)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint hsegs, vsegs, packet_size;\n\tstruct usb_host_interface *alt;\n\tstruct usb_interface *intf;\n\n\tintf = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);\n\talt = usb_altnum_to_altsetting(intf, sd->gspca_dev.alt);\n\tif (!alt) {\n\t\tgspca_err(gspca_dev, \"Couldn't get altsetting\\n\");\n\t\tsd->gspca_dev.usb_err = -EIO;\n\t\treturn;\n\t}\n\n\tif (alt->desc.bNumEndpoints < 1) {\n\t\tsd->gspca_dev.usb_err = -ENODEV;\n\t\treturn;\n\t}\n\n\tpacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n\tov518_reg_w32(sd, R51x_FIFO_PSIZE, packet_size & ~7, 2);\n\n\t/******** Set the mode ********/\n\treg_w(sd, 0x2b, 0);\n\treg_w(sd, 0x2c, 0);\n\treg_w(sd, 0x2d, 0);\n\treg_w(sd, 0x2e, 0);\n\treg_w(sd, 0x3b, 0);\n\treg_w(sd, 0x3c, 0);\n\treg_w(sd, 0x3d, 0);\n\treg_w(sd, 0x3e, 0);\n\n\tif (sd->bridge == BRIDGE_OV518) {\n\t\t/* Set 8-bit (YVYU) input format */\n\t\treg_w_mask(sd, 0x20, 0x08, 0x08);\n\n\t\t/* Set 12-bit (4:2:0) output format */\n\t\treg_w_mask(sd, 0x28, 0x80, 0xf0);\n\t\treg_w_mask(sd, 0x38, 0x80, 0xf0);\n\t} else {\n\t\treg_w(sd, 0x28, 0x80);\n\t\treg_w(sd, 0x38, 0x80);\n\t}\n\n\thsegs = sd->gspca_dev.pixfmt.width / 16;\n\tvsegs = sd->gspca_dev.pixfmt.height / 4;\n\n\treg_w(sd, 0x29, hsegs);\n\treg_w(sd, 0x2a, vsegs);\n\n\treg_w(sd, 0x39, hsegs);\n\treg_w(sd, 0x3a, vsegs);\n\n\t/* Windows driver does this here; who knows why */\n\treg_w(sd, 0x2f, 0x80);\n\n\t/******** Set the framerate ********/\n\tif (sd->bridge == BRIDGE_OV518PLUS && sd->revision == 0 &&\n\t\t\t\t\t      sd->sensor == SEN_OV7620AE)\n\t\tsd->clockdiv = 0;\n\telse\n\t\tsd->clockdiv = 1;\n\n\t/* Mode independent, but framerate dependent, regs */\n\t/* 0x51: Clock divider; Only works on some cams which use 2 crystals */\n\treg_w(sd, 0x51, 0x04);\n\treg_w(sd, 0x22, 0x18);\n\treg_w(sd, 0x23, 0xff);\n\n\tif (sd->bridge == BRIDGE_OV518PLUS) {\n\t\tswitch (sd->sensor) {\n\t\tcase SEN_OV7620AE:\n\t\t\t/*\n\t\t\t * HdG: 640x480 needs special handling on device\n\t\t\t * revision 2, we check for device revision > 0 to\n\t\t\t * avoid regressions, as we don't know the correct\n\t\t\t * thing todo for revision 1.\n\t\t\t *\n\t\t\t * Also this likely means we don't need to\n\t\t\t * differentiate between the OV7620 and OV7620AE,\n\t\t\t * earlier testing hitting this same problem likely\n\t\t\t * happened to be with revision < 2 cams using an\n\t\t\t * OV7620 and revision 2 cams using an OV7620AE.\n\t\t\t */\n\t\t\tif (sd->revision > 0 &&\n\t\t\t\t\tsd->gspca_dev.pixfmt.width == 640) {\n\t\t\t\treg_w(sd, 0x20, 0x60);\n\t\t\t\treg_w(sd, 0x21, 0x1f);\n\t\t\t} else {\n\t\t\t\treg_w(sd, 0x20, 0x00);\n\t\t\t\treg_w(sd, 0x21, 0x19);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SEN_OV7620:\n\t\t\treg_w(sd, 0x20, 0x00);\n\t\t\treg_w(sd, 0x21, 0x19);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treg_w(sd, 0x21, 0x19);\n\t\t}\n\t} else\n\t\treg_w(sd, 0x71, 0x17);\t/* Compression-related? */\n\n\t/* FIXME: Sensor-specific */\n\t/* Bit 5 is what matters here. Of course, it is \"reserved\" */\n\ti2c_w(sd, 0x54, 0x23);\n\n\treg_w(sd, 0x2f, 0x80);\n\n\tif (sd->bridge == BRIDGE_OV518PLUS) {\n\t\treg_w(sd, 0x24, 0x94);\n\t\treg_w(sd, 0x25, 0x90);\n\t\tov518_reg_w32(sd, 0xc4,    400, 2);\t/* 190h   */\n\t\tov518_reg_w32(sd, 0xc6,    540, 2);\t/* 21ch   */\n\t\tov518_reg_w32(sd, 0xc7,    540, 2);\t/* 21ch   */\n\t\tov518_reg_w32(sd, 0xc8,    108, 2);\t/* 6ch    */\n\t\tov518_reg_w32(sd, 0xca, 131098, 3);\t/* 2001ah */\n\t\tov518_reg_w32(sd, 0xcb,    532, 2);\t/* 214h   */\n\t\tov518_reg_w32(sd, 0xcc,   2400, 2);\t/* 960h   */\n\t\tov518_reg_w32(sd, 0xcd,     32, 2);\t/* 20h    */\n\t\tov518_reg_w32(sd, 0xce,    608, 2);\t/* 260h   */\n\t} else {\n\t\treg_w(sd, 0x24, 0x9f);\n\t\treg_w(sd, 0x25, 0x90);\n\t\tov518_reg_w32(sd, 0xc4,    400, 2);\t/* 190h   */\n\t\tov518_reg_w32(sd, 0xc6,    381, 2);\t/* 17dh   */\n\t\tov518_reg_w32(sd, 0xc7,    381, 2);\t/* 17dh   */\n\t\tov518_reg_w32(sd, 0xc8,    128, 2);\t/* 80h    */\n\t\tov518_reg_w32(sd, 0xca, 183331, 3);\t/* 2cc23h */\n\t\tov518_reg_w32(sd, 0xcb,    746, 2);\t/* 2eah   */\n\t\tov518_reg_w32(sd, 0xcc,   1750, 2);\t/* 6d6h   */\n\t\tov518_reg_w32(sd, 0xcd,     45, 2);\t/* 2dh    */\n\t\tov518_reg_w32(sd, 0xce,    851, 2);\t/* 353h   */\n\t}\n\n\treg_w(sd, 0x2f, 0x80);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 511,
    "critical_vars": [
      "bit",
      "bitmap->bitmap"
    ],
    "function": "ida_free",
    "filename": "linux/CVE-2023-6915/CVE-2023-6915_CWE-476_af73483f4e8b6f5c68c9aa63257bdd929a9c194a_idr.c.diff",
    "function_code": "void ida_free(struct ida *ida, unsigned int id)\n{\n\tXA_STATE(xas, &ida->xa, id / IDA_BITMAP_BITS);\n\tunsigned bit = id % IDA_BITMAP_BITS;\n\tstruct ida_bitmap *bitmap;\n\tunsigned long flags;\n\n\tif ((int)id < 0)\n\t\treturn;\n\n\txas_lock_irqsave(&xas, flags);\n\tbitmap = xas_load(&xas);\n\n\tif (xa_is_value(bitmap)) {\n\t\tunsigned long v = xa_to_value(bitmap);\n\t\tif (bit >= BITS_PER_XA_VALUE)\n\t\t\tgoto err;\n\t\tif (!(v & (1UL << bit)))\n\t\t\tgoto err;\n\t\tv &= ~(1UL << bit);\n\t\tif (!v)\n\t\t\tgoto delete;\n\t\txas_store(&xas, xa_mk_value(v));\n\t} else {\n\t\tif (!test_bit(bit, bitmap->bitmap))\n\t\t\tgoto err;\n\t\t__clear_bit(bit, bitmap->bitmap);\n\t\txas_set_mark(&xas, XA_FREE_MARK);\n\t\tif (bitmap_empty(bitmap->bitmap, IDA_BITMAP_BITS)) {\n\t\t\tkfree(bitmap);\ndelete:\n\t\t\txas_store(&xas, NULL);\n\t\t}\n\t}\n\txas_unlock_irqrestore(&xas, flags);\n\treturn;\n err:\n\txas_unlock_irqrestore(&xas, flags);\n\tWARN(1, \"ida_free called for id=%d which is not allocated.\\n\", id);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 511,
    "critical_vars": [
      "bitmap",
      "bitmap->bitmap",
      "bit"
    ],
    "function": "ida_free",
    "filename": "linux/CVE-2023-6915/CVE-2023-6915_CWE-476_af73483f4e8b6f5c68c9aa63257bdd929a9c194a_idr.c.diff",
    "function_code": "void ida_free(struct ida *ida, unsigned int id)\n{\n\tXA_STATE(xas, &ida->xa, id / IDA_BITMAP_BITS);\n\tunsigned bit = id % IDA_BITMAP_BITS;\n\tstruct ida_bitmap *bitmap;\n\tunsigned long flags;\n\n\tif ((int)id < 0)\n\t\treturn;\n\n\txas_lock_irqsave(&xas, flags);\n\tbitmap = xas_load(&xas);\n\n\tif (xa_is_value(bitmap)) {\n\t\tunsigned long v = xa_to_value(bitmap);\n\t\tif (bit >= BITS_PER_XA_VALUE)\n\t\t\tgoto err;\n\t\tif (!(v & (1UL << bit)))\n\t\t\tgoto err;\n\t\tv &= ~(1UL << bit);\n\t\tif (!v)\n\t\t\tgoto delete;\n\t\txas_store(&xas, xa_mk_value(v));\n\t} else {\n\t\tif (!bitmap || !test_bit(bit, bitmap->bitmap))\n\t\t\tgoto err;\n\t\t__clear_bit(bit, bitmap->bitmap);\n\t\txas_set_mark(&xas, XA_FREE_MARK);\n\t\tif (bitmap_empty(bitmap->bitmap, IDA_BITMAP_BITS)) {\n\t\t\tkfree(bitmap);\ndelete:\n\t\t\txas_store(&xas, NULL);\n\t\t}\n\t}\n\txas_unlock_irqrestore(&xas, flags);\n\treturn;\n err:\n\txas_unlock_irqrestore(&xas, flags);\n\tWARN(1, \"ida_free called for id=%d which is not allocated.\\n\", id);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 204,
    "critical_vars": [
      "&ida"
    ],
    "function": "ida_checks",
    "filename": "linux/CVE-2023-6915/CVE-2023-6915_CWE-476_af73483f4e8b6f5c68c9aa63257bdd929a9c194a_test_ida.c.diff",
    "function_code": "static int ida_checks(void)\n{\n\tIDA_BUG_ON(&ida, !ida_is_empty(&ida));\n\tida_check_alloc(&ida);\n\tida_check_destroy(&ida);\n\tida_check_leaf(&ida, 0);\n\tida_check_leaf(&ida, 1024);\n\tida_check_leaf(&ida, 1024 * 64);\n\tida_check_max(&ida);\n\tida_check_conv(&ida);\n\tida_check_bad_free(&ida);\n\n\tprintk(\"IDA: %u of %u tests passed\\n\", tests_passed, tests_run);\n\treturn (tests_run != tests_passed) ? 0 : -EINVAL;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 787,
    "line_new": 825,
    "critical_vars": [
      "skcipher->setkey"
    ],
    "function": "crypto_skcipher_init_tfm",
    "filename": "linux/CVE-2017-9211/CVE-2017-9211_CWE-476_9933e113c2e87a9f46a40fde8dafbf801dca1ab9_skcipher.c.diff",
    "function_code": "static int crypto_skcipher_init_tfm(struct crypto_tfm *tfm)\n{\n\tstruct crypto_skcipher *skcipher = __crypto_skcipher_cast(tfm);\n\tstruct skcipher_alg *alg = crypto_skcipher_alg(skcipher);\n\n\tif (tfm->__crt_alg->cra_type == &crypto_blkcipher_type)\n\t\treturn crypto_init_skcipher_ops_blkcipher(tfm);\n\n\tif (tfm->__crt_alg->cra_type == &crypto_ablkcipher_type ||\n\t    tfm->__crt_alg->cra_type == &crypto_givcipher_type)\n\t\treturn crypto_init_skcipher_ops_ablkcipher(tfm);\n\n\tskcipher->setkey = skcipher_setkey;\n\tskcipher->encrypt = alg->encrypt;\n\tskcipher->decrypt = alg->decrypt;\n\tskcipher->ivsize = alg->ivsize;\n\tskcipher->keysize = alg->max_keysize;\n\n\tif (alg->exit)\n\t\tskcipher->base.exit = crypto_skcipher_exit_tfm;\n\n\tif (alg->init)\n\t\treturn alg->init(skcipher);\n\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 186,
    "critical_vars": [
      "rs->rs_transport"
    ],
    "function": "__rds_rdma_map",
    "filename": "linux/CVE-2018-7492/CVE-2018-7492_CWE-476_f3069c6d33f6ae63a1668737bc78aaaa51bff7ca_rdma.c.diff",
    "function_code": "static int __rds_rdma_map(struct rds_sock *rs, struct rds_get_mr_args *args,\n\t\t\t\tu64 *cookie_ret, struct rds_mr **mr_ret)\n{\n\tstruct rds_mr *mr = NULL, *found;\n\tunsigned int nr_pages;\n\tstruct page **pages = NULL;\n\tstruct scatterlist *sg;\n\tvoid *trans_private;\n\tunsigned long flags;\n\trds_rdma_cookie_t cookie;\n\tunsigned int nents;\n\tlong i;\n\tint ret;\n\n\tif (rs->rs_bound_addr == 0 || !rs->rs_transport) {\n\t\tret = -ENOTCONN; /* XXX not a great errno */\n\t\tgoto out;\n\t}\n\n\tif (!rs->rs_transport->get_mr) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tnr_pages = rds_pages_in_vec(&args->vec);\n\tif (nr_pages == 0) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Restrict the size of mr irrespective of underlying transport\n\t * To account for unaligned mr regions, subtract one from nr_pages\n\t */\n\tif ((nr_pages - 1) > (RDS_MAX_MSG_SIZE >> PAGE_SHIFT)) {\n\t\tret = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\trdsdebug(\"RDS: get_mr addr %llx len %llu nr_pages %u\\n\",\n\t\targs->vec.addr, args->vec.bytes, nr_pages);\n\n\t/* XXX clamp nr_pages to limit the size of this alloc? */\n\tpages = kcalloc(nr_pages, sizeof(struct page *), GFP_KERNEL);\n\tif (!pages) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmr = kzalloc(sizeof(struct rds_mr), GFP_KERNEL);\n\tif (!mr) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trefcount_set(&mr->r_refcount, 1);\n\tRB_CLEAR_NODE(&mr->r_rb_node);\n\tmr->r_trans = rs->rs_transport;\n\tmr->r_sock = rs;\n\n\tif (args->flags & RDS_RDMA_USE_ONCE)\n\t\tmr->r_use_once = 1;\n\tif (args->flags & RDS_RDMA_INVALIDATE)\n\t\tmr->r_invalidate = 1;\n\tif (args->flags & RDS_RDMA_READWRITE)\n\t\tmr->r_write = 1;\n\n\t/*\n\t * Pin the pages that make up the user buffer and transfer the page\n\t * pointers to the mr's sg array.  We check to see if we've mapped\n\t * the whole region after transferring the partial page references\n\t * to the sg array so that we can have one page ref cleanup path.\n\t *\n\t * For now we have no flag that tells us whether the mapping is\n\t * r/o or r/w. We need to assume r/w, or we'll do a lot of RDMA to\n\t * the zero page.\n\t */\n\tret = rds_pin_pages(args->vec.addr, nr_pages, pages, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tnents = ret;\n\tsg = kcalloc(nents, sizeof(*sg), GFP_KERNEL);\n\tif (!sg) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tWARN_ON(!nents);\n\tsg_init_table(sg, nents);\n\n\t/* Stick all pages into the scatterlist */\n\tfor (i = 0 ; i < nents; i++)\n\t\tsg_set_page(&sg[i], pages[i], PAGE_SIZE, 0);\n\n\trdsdebug(\"RDS: trans_private nents is %u\\n\", nents);\n\n\t/* Obtain a transport specific MR. If this succeeds, the\n\t * s/g list is now owned by the MR.\n\t * Note that dma_map() implies that pending writes are\n\t * flushed to RAM, so no dma_sync is needed here. */\n\ttrans_private = rs->rs_transport->get_mr(sg, nents, rs,\n\t\t\t\t\t\t &mr->r_key);\n\n\tif (IS_ERR(trans_private)) {\n\t\tfor (i = 0 ; i < nents; i++)\n\t\t\tput_page(sg_page(&sg[i]));\n\t\tkfree(sg);\n\t\tret = PTR_ERR(trans_private);\n\t\tgoto out;\n\t}\n\n\tmr->r_trans_private = trans_private;\n\n\trdsdebug(\"RDS: get_mr put_user key is %x cookie_addr %p\\n\",\n\t       mr->r_key, (void *)(unsigned long) args->cookie_addr);\n\n\t/* The user may pass us an unaligned address, but we can only\n\t * map page aligned regions. So we keep the offset, and build\n\t * a 64bit cookie containing <R_Key, offset> and pass that\n\t * around. */\n\tcookie = rds_rdma_make_cookie(mr->r_key, args->vec.addr & ~PAGE_MASK);\n\tif (cookie_ret)\n\t\t*cookie_ret = cookie;\n\n\tif (args->cookie_addr && put_user(cookie, (u64 __user *)(unsigned long) args->cookie_addr)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t/* Inserting the new MR into the rbtree bumps its\n\t * reference count. */\n\tspin_lock_irqsave(&rs->rs_rdma_lock, flags);\n\tfound = rds_mr_tree_walk(&rs->rs_rdma_keys, mr->r_key, mr);\n\tspin_unlock_irqrestore(&rs->rs_rdma_lock, flags);\n\n\tBUG_ON(found && found != mr);\n\n\trdsdebug(\"RDS: get_mr key is %x\\n\", mr->r_key);\n\tif (mr_ret) {\n\t\trefcount_inc(&mr->r_refcount);\n\t\t*mr_ret = mr;\n\t}\n\n\tret = 0;\nout:\n\tkfree(pages);\n\tif (mr)\n\t\trds_mr_put(mr);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 778,
    "line_new": 778,
    "critical_vars": [
      "qcom->urs_usb"
    ],
    "function": "dwc3_qcom_probe",
    "filename": "linux/CVE-2023-22999/CVE-2023-22999_CWE-476_b52fe2dbb3e655eb1483000adfab68a219549e13_dwc3-qcom.c.diff",
    "function_code": "static int dwc3_qcom_probe(struct platform_device *pdev)\n{\n\tstruct device_node\t*np = pdev->dev.of_node;\n\tstruct device\t\t*dev = &pdev->dev;\n\tstruct dwc3_qcom\t*qcom;\n\tstruct resource\t\t*res, *parent_res = NULL;\n\tint\t\t\tret, i;\n\tbool\t\t\tignore_pipe_clk;\n\n\tqcom = devm_kzalloc(&pdev->dev, sizeof(*qcom), GFP_KERNEL);\n\tif (!qcom)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, qcom);\n\tqcom->dev = &pdev->dev;\n\n\tif (has_acpi_companion(dev)) {\n\t\tqcom->acpi_pdata = acpi_device_get_match_data(dev);\n\t\tif (!qcom->acpi_pdata) {\n\t\t\tdev_err(&pdev->dev, \"no supporting ACPI device data\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tqcom->resets = devm_reset_control_array_get_optional_exclusive(dev);\n\tif (IS_ERR(qcom->resets)) {\n\t\tret = PTR_ERR(qcom->resets);\n\t\tdev_err(&pdev->dev, \"failed to get resets, err=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = reset_control_assert(qcom->resets);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to assert resets, err=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tusleep_range(10, 1000);\n\n\tret = reset_control_deassert(qcom->resets);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to deassert resets, err=%d\\n\", ret);\n\t\tgoto reset_assert;\n\t}\n\n\tret = dwc3_qcom_clk_init(qcom, of_clk_get_parent_count(np));\n\tif (ret) {\n\t\tdev_err(dev, \"failed to get clocks\\n\");\n\t\tgoto reset_assert;\n\t}\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\n\tif (np) {\n\t\tparent_res = res;\n\t} else {\n\t\tparent_res = kmemdup(res, sizeof(struct resource), GFP_KERNEL);\n\t\tif (!parent_res)\n\t\t\treturn -ENOMEM;\n\n\t\tparent_res->start = res->start +\n\t\t\tqcom->acpi_pdata->qscratch_base_offset;\n\t\tparent_res->end = parent_res->start +\n\t\t\tqcom->acpi_pdata->qscratch_base_size;\n\n\t\tif (qcom->acpi_pdata->is_urs) {\n\t\t\tqcom->urs_usb = dwc3_qcom_create_urs_usb_platdev(dev);\n\t\t\tif (IS_ERR_OR_NULL(qcom->urs_usb)) {\n\t\t\t\tdev_err(dev, \"failed to create URS USB platdev\\n\");\n\t\t\t\tif (!qcom->urs_usb)\n\t\t\t\t\treturn -ENODEV;\n\t\t\t\telse\n\t\t\t\t\treturn PTR_ERR(qcom->urs_usb);\n\t\t\t}\n\t\t}\n\t}\n\n\tqcom->qscratch_base = devm_ioremap_resource(dev, parent_res);\n\tif (IS_ERR(qcom->qscratch_base)) {\n\t\tret = PTR_ERR(qcom->qscratch_base);\n\t\tgoto clk_disable;\n\t}\n\n\tret = dwc3_qcom_setup_irq(pdev);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to setup IRQs, err=%d\\n\", ret);\n\t\tgoto clk_disable;\n\t}\n\n\t/*\n\t * Disable pipe_clk requirement if specified. Used when dwc3\n\t * operates without SSPHY and only HS/FS/LS modes are supported.\n\t */\n\tignore_pipe_clk = device_property_read_bool(dev,\n\t\t\t\t\"qcom,select-utmi-as-pipe-clk\");\n\tif (ignore_pipe_clk)\n\t\tdwc3_qcom_select_utmi_clk(qcom);\n\n\tif (np)\n\t\tret = dwc3_qcom_of_register_core(pdev);\n\telse\n\t\tret = dwc3_qcom_acpi_register_core(pdev);\n\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register DWC3 Core, err=%d\\n\", ret);\n\t\tgoto depopulate;\n\t}\n\n\tret = dwc3_qcom_interconnect_init(qcom);\n\tif (ret)\n\t\tgoto depopulate;\n\n\tqcom->mode = usb_get_dr_mode(&qcom->dwc3->dev);\n\n\t/* enable vbus override for device mode */\n\tif (qcom->mode == USB_DR_MODE_PERIPHERAL)\n\t\tdwc3_qcom_vbus_override_enable(qcom, true);\n\n\t/* register extcon to override sw_vbus on Vbus change later */\n\tret = dwc3_qcom_register_extcon(qcom);\n\tif (ret)\n\t\tgoto interconnect_exit;\n\n\tdevice_init_wakeup(&pdev->dev, 1);\n\tqcom->is_suspended = false;\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\tpm_runtime_forbid(dev);\n\n\treturn 0;\n\ninterconnect_exit:\n\tdwc3_qcom_interconnect_exit(qcom);\ndepopulate:\n\tif (np)\n\t\tof_platform_depopulate(&pdev->dev);\n\telse\n\t\tplatform_device_put(pdev);\nclk_disable:\n\tfor (i = qcom->num_clocks - 1; i >= 0; i--) {\n\t\tclk_disable_unprepare(qcom->clks[i]);\n\t\tclk_put(qcom->clks[i]);\n\t}\nreset_assert:\n\treset_control_assert(qcom->resets);\n\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 2031,
    "line_new": 2031,
    "critical_vars": [
      "err"
    ],
    "function": "tun_set_iff",
    "filename": "linux/CVE-2018-7191/CVE-2018-7191_CWE-476_5c25f65fd1e42685f7ccd80e0621829c105785d9_tun.c.diff",
    "function_code": "static int tun_set_iff(struct net *net, struct file *file, struct ifreq *ifr)\n{\n\tstruct tun_struct *tun;\n\tstruct tun_file *tfile = file->private_data;\n\tstruct net_device *dev;\n\tint err;\n\n\tif (tfile->detached)\n\t\treturn -EINVAL;\n\n\tdev = __dev_get_by_name(net, ifr->ifr_name);\n\tif (dev) {\n\t\tif (ifr->ifr_flags & IFF_TUN_EXCL)\n\t\t\treturn -EBUSY;\n\t\tif ((ifr->ifr_flags & IFF_TUN) && dev->netdev_ops == &tun_netdev_ops)\n\t\t\ttun = netdev_priv(dev);\n\t\telse if ((ifr->ifr_flags & IFF_TAP) && dev->netdev_ops == &tap_netdev_ops)\n\t\t\ttun = netdev_priv(dev);\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\tif (!!(ifr->ifr_flags & IFF_MULTI_QUEUE) !=\n\t\t    !!(tun->flags & IFF_MULTI_QUEUE))\n\t\t\treturn -EINVAL;\n\n\t\tif (tun_not_capable(tun))\n\t\t\treturn -EPERM;\n\t\terr = security_tun_dev_open(tun->security);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = tun_attach(tun, file, ifr->ifr_flags & IFF_NOFILTER);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (tun->flags & IFF_MULTI_QUEUE &&\n\t\t    (tun->numqueues + tun->numdisabled > 1)) {\n\t\t\t/* One or more queue has already been attached, no need\n\t\t\t * to initialize the device again.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse {\n\t\tchar *name;\n\t\tunsigned long flags = 0;\n\t\tint queues = ifr->ifr_flags & IFF_MULTI_QUEUE ?\n\t\t\t     MAX_TAP_QUEUES : 1;\n\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\terr = security_tun_dev_create();\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t/* Set dev type */\n\t\tif (ifr->ifr_flags & IFF_TUN) {\n\t\t\t/* TUN device */\n\t\t\tflags |= IFF_TUN;\n\t\t\tname = \"tun%d\";\n\t\t} else if (ifr->ifr_flags & IFF_TAP) {\n\t\t\t/* TAP device */\n\t\t\tflags |= IFF_TAP;\n\t\t\tname = \"tap%d\";\n\t\t} else\n\t\t\treturn -EINVAL;\n\n\t\tif (*ifr->ifr_name)\n\t\t\tname = ifr->ifr_name;\n\n\t\tdev = alloc_netdev_mqs(sizeof(struct tun_struct), name,\n\t\t\t\t       NET_NAME_UNKNOWN, tun_setup, queues,\n\t\t\t\t       queues);\n\n\t\tif (!dev)\n\t\t\treturn -ENOMEM;\n\t\terr = dev_get_valid_name(net, dev, name);\n\t\tif (err)\n\t\t\tgoto err_free_dev;\n\n\t\tdev_net_set(dev, net);\n\t\tdev->rtnl_link_ops = &tun_link_ops;\n\t\tdev->ifindex = tfile->ifindex;\n\t\tdev->sysfs_groups[0] = &tun_attr_group;\n\n\t\ttun = netdev_priv(dev);\n\t\ttun->dev = dev;\n\t\ttun->flags = flags;\n\t\ttun->txflt.count = 0;\n\t\ttun->vnet_hdr_sz = sizeof(struct virtio_net_hdr);\n\n\t\ttun->align = NET_SKB_PAD;\n\t\ttun->filter_attached = false;\n\t\ttun->sndbuf = tfile->socket.sk->sk_sndbuf;\n\t\ttun->rx_batched = 0;\n\n\t\ttun->pcpu_stats = netdev_alloc_pcpu_stats(struct tun_pcpu_stats);\n\t\tif (!tun->pcpu_stats) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_free_dev;\n\t\t}\n\n\t\tspin_lock_init(&tun->lock);\n\n\t\terr = security_tun_dev_alloc_security(&tun->security);\n\t\tif (err < 0)\n\t\t\tgoto err_free_stat;\n\n\t\ttun_net_init(dev);\n\t\ttun_flow_init(tun);\n\n\t\tdev->hw_features = NETIF_F_SG | NETIF_F_FRAGLIST |\n\t\t\t\t   TUN_USER_FEATURES | NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t\t   NETIF_F_HW_VLAN_STAG_TX;\n\t\tdev->features = dev->hw_features | NETIF_F_LLTX;\n\t\tdev->vlan_features = dev->features &\n\t\t\t\t     ~(NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t\t       NETIF_F_HW_VLAN_STAG_TX);\n\n\t\tINIT_LIST_HEAD(&tun->disabled);\n\t\terr = tun_attach(tun, file, false);\n\t\tif (err < 0)\n\t\t\tgoto err_free_flow;\n\n\t\terr = register_netdevice(tun->dev);\n\t\tif (err < 0)\n\t\t\tgoto err_detach;\n\t}\n\n\tnetif_carrier_on(tun->dev);\n\n\ttun_debug(KERN_INFO, tun, \"tun_set_iff\\n\");\n\n\ttun->flags = (tun->flags & ~TUN_FEATURES) |\n\t\t(ifr->ifr_flags & TUN_FEATURES);\n\n\t/* Make sure persistent devices do not get stuck in\n\t * xoff state.\n\t */\n\tif (netif_running(tun->dev))\n\t\tnetif_tx_wake_all_queues(tun->dev);\n\n\tstrcpy(ifr->ifr_name, tun->dev->name);\n\treturn 0;\n\nerr_detach:\n\ttun_detach_all(dev);\n\t/* register_netdevice() already called tun_free_netdev() */\n\tgoto err_free_dev;\n\nerr_free_flow:\n\ttun_flow_uninit(tun);\n\tsecurity_tun_dev_free_security(tun->security);\nerr_free_stat:\n\tfree_percpu(tun->pcpu_stats);\nerr_free_dev:\n\tfree_netdev(dev);\n\treturn err;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 1167,
    "critical_vars": [
      "dev_get_valid_name"
    ],
    "function": "dev_get_valid_name",
    "filename": "linux/CVE-2018-7191/CVE-2018-7191_CWE-476_0ad646c81b2182f7fa67ec0c8c825e0ee165696d_dev.c.diff",
    "function_code": "int dev_get_valid_name(struct net *net, struct net_device *dev,\n\t\t       const char *name)\n{\n\tBUG_ON(!net);\n\n\tif (!dev_valid_name(name))\n\t\treturn -EINVAL;\n\n\tif (strchr(name, '%'))\n\t\treturn dev_alloc_name_ns(net, dev, name);\n\telse if (__dev_get_by_name(net, name))\n\t\treturn -EEXIST;\n\telse if (dev->name != name)\n\t\tstrlcpy(dev->name, name, IFNAMSIZ);\n\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 1748,
    "critical_vars": [
      "tag"
    ],
    "function": "srpt_handle_tsk_mgmt",
    "filename": "linux/CVE-2016-6327/CVE-2016-6327_CWE-476_51093254bf879bc9ce96590400a87897c7498463_ib_srpt.c.diff",
    "function_code": "static void srpt_handle_tsk_mgmt(struct srpt_rdma_ch *ch,\n\t\t\t\t struct srpt_recv_ioctx *recv_ioctx,\n\t\t\t\t struct srpt_send_ioctx *send_ioctx)\n{\n\tstruct srp_tsk_mgmt *srp_tsk;\n\tstruct se_cmd *cmd;\n\tstruct se_session *sess = ch->sess;\n\tuint64_t unpacked_lun;\n\tuint32_t tag = 0;\n\tint tcm_tmr;\n\tint rc;\n\n\tBUG_ON(!send_ioctx);\n\n\tsrp_tsk = recv_ioctx->ioctx.buf;\n\tcmd = &send_ioctx->cmd;\n\n\tpr_debug(\"recv tsk_mgmt fn %d for task_tag %lld and cmd tag %lld\"\n\t\t \" cm_id %p sess %p\\n\", srp_tsk->tsk_mgmt_func,\n\t\t srp_tsk->task_tag, srp_tsk->tag, ch->cm_id, ch->sess);\n\n\tsrpt_set_cmd_state(send_ioctx, SRPT_STATE_MGMT);\n\tsend_ioctx->cmd.tag = srp_tsk->tag;\n\ttcm_tmr = srp_tmr_to_tcm(srp_tsk->tsk_mgmt_func);\n\tif (tcm_tmr < 0) {\n\t\tsend_ioctx->cmd.se_tmr_req->response =\n\t\t\tTMR_TASK_MGMT_FUNCTION_NOT_SUPPORTED;\n\t\tgoto fail;\n\t}\n\tunpacked_lun = srpt_unpack_lun((uint8_t *)&srp_tsk->lun,\n\t\t\t\t       sizeof(srp_tsk->lun));\n\n\tif (srp_tsk->tsk_mgmt_func == SRP_TSK_ABORT_TASK) {\n\t\trc = srpt_rx_mgmt_fn_tag(send_ioctx, srp_tsk->task_tag);\n\t\tif (rc < 0) {\n\t\t\tsend_ioctx->cmd.se_tmr_req->response =\n\t\t\t\t\tTMR_TASK_DOES_NOT_EXIST;\n\t\t\tgoto fail;\n\t\t}\n\t\ttag = srp_tsk->task_tag;\n\t}\n\trc = target_submit_tmr(&send_ioctx->cmd, sess, NULL, unpacked_lun,\n\t\t\t\tsrp_tsk, tcm_tmr, GFP_KERNEL, tag,\n\t\t\t\tTARGET_SCF_ACK_KREF);\n\tif (rc != 0) {\n\t\tsend_ioctx->cmd.se_tmr_req->response = TMR_FUNCTION_REJECTED;\n\t\tgoto fail;\n\t}\n\treturn;\nfail:\n\ttransport_send_check_condition_and_sense(cmd, 0, 0); // XXX:\n}",
    "label": "True"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 3838,
    "line_new": 3838,
    "critical_vars": [
      "dev"
    ],
    "function": "btrfs_scrub_dev",
    "filename": "linux/CVE-2019-18885/CVE-2019-18885_CWE-476_09ba3bc9dd150457c506e4661380a6183af651c1_scrub.c.diff",
    "function_code": "int btrfs_scrub_dev(struct btrfs_fs_info *fs_info, u64 devid, u64 start,\n\t\t    u64 end, struct btrfs_scrub_progress *progress,\n\t\t    int readonly, int is_dev_replace)\n{\n\tstruct scrub_ctx *sctx;\n\tint ret;\n\tstruct btrfs_device *dev;\n\tunsigned int nofs_flag;\n\n\tif (btrfs_fs_closing(fs_info))\n\t\treturn -EINVAL;\n\n\tif (fs_info->nodesize > BTRFS_STRIPE_LEN) {\n\t\t/*\n\t\t * in this case scrub is unable to calculate the checksum\n\t\t * the way scrub is implemented. Do not handle this\n\t\t * situation at all because it won't ever happen.\n\t\t */\n\t\tbtrfs_err(fs_info,\n\t\t\t   \"scrub: size assumption nodesize <= BTRFS_STRIPE_LEN (%d <= %d) fails\",\n\t\t       fs_info->nodesize,\n\t\t       BTRFS_STRIPE_LEN);\n\t\treturn -EINVAL;\n\t}\n\n\tif (fs_info->sectorsize != PAGE_SIZE) {\n\t\t/* not supported for data w/o checksums */\n\t\tbtrfs_err_rl(fs_info,\n\t\t\t   \"scrub: size assumption sectorsize != PAGE_SIZE (%d != %lu) fails\",\n\t\t       fs_info->sectorsize, PAGE_SIZE);\n\t\treturn -EINVAL;\n\t}\n\n\tif (fs_info->nodesize >\n\t    PAGE_SIZE * SCRUB_MAX_PAGES_PER_BLOCK ||\n\t    fs_info->sectorsize > PAGE_SIZE * SCRUB_MAX_PAGES_PER_BLOCK) {\n\t\t/*\n\t\t * would exhaust the array bounds of pagev member in\n\t\t * struct scrub_block\n\t\t */\n\t\tbtrfs_err(fs_info,\n\t\t\t  \"scrub: size assumption nodesize and sectorsize <= SCRUB_MAX_PAGES_PER_BLOCK (%d <= %d && %d <= %d) fails\",\n\t\t       fs_info->nodesize,\n\t\t       SCRUB_MAX_PAGES_PER_BLOCK,\n\t\t       fs_info->sectorsize,\n\t\t       SCRUB_MAX_PAGES_PER_BLOCK);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Allocate outside of device_list_mutex */\n\tsctx = scrub_setup_ctx(fs_info, is_dev_replace);\n\tif (IS_ERR(sctx))\n\t\treturn PTR_ERR(sctx);\n\n\tmutex_lock(&fs_info->fs_devices->device_list_mutex);\n\tdev = btrfs_find_device(fs_info->fs_devices, devid, NULL, NULL, true);\n\tif (!dev || (test_bit(BTRFS_DEV_STATE_MISSING, &dev->dev_state) &&\n\t\t     !is_dev_replace)) {\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\tret = -ENODEV;\n\t\tgoto out_free_ctx;\n\t}\n\n\tif (!is_dev_replace && !readonly &&\n\t    !test_bit(BTRFS_DEV_STATE_WRITEABLE, &dev->dev_state)) {\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\tbtrfs_err_in_rcu(fs_info, \"scrub: device %s is not writable\",\n\t\t\t\trcu_str_deref(dev->name));\n\t\tret = -EROFS;\n\t\tgoto out_free_ctx;\n\t}\n\n\tmutex_lock(&fs_info->scrub_lock);\n\tif (!test_bit(BTRFS_DEV_STATE_IN_FS_METADATA, &dev->dev_state) ||\n\t    test_bit(BTRFS_DEV_STATE_REPLACE_TGT, &dev->dev_state)) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\tret = -EIO;\n\t\tgoto out_free_ctx;\n\t}\n\n\tdown_read(&fs_info->dev_replace.rwsem);\n\tif (dev->scrub_ctx ||\n\t    (!is_dev_replace &&\n\t     btrfs_dev_replace_is_ongoing(&fs_info->dev_replace))) {\n\t\tup_read(&fs_info->dev_replace.rwsem);\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\tret = -EINPROGRESS;\n\t\tgoto out_free_ctx;\n\t}\n\tup_read(&fs_info->dev_replace.rwsem);\n\n\tret = scrub_workers_get(fs_info, is_dev_replace);\n\tif (ret) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\tgoto out_free_ctx;\n\t}\n\n\tsctx->readonly = readonly;\n\tdev->scrub_ctx = sctx;\n\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\n\t/*\n\t * checking @scrub_pause_req here, we can avoid\n\t * race between committing transaction and scrubbing.\n\t */\n\t__scrub_blocked_if_needed(fs_info);\n\tatomic_inc(&fs_info->scrubs_running);\n\tmutex_unlock(&fs_info->scrub_lock);\n\n\t/*\n\t * In order to avoid deadlock with reclaim when there is a transaction\n\t * trying to pause scrub, make sure we use GFP_NOFS for all the\n\t * allocations done at btrfs_scrub_pages() and scrub_pages_for_parity()\n\t * invoked by our callees. The pausing request is done when the\n\t * transaction commit starts, and it blocks the transaction until scrub\n\t * is paused (done at specific points at scrub_stripe() or right above\n\t * before incrementing fs_info->scrubs_running).\n\t */\n\tnofs_flag = memalloc_nofs_save();\n\tif (!is_dev_replace) {\n\t\t/*\n\t\t * by holding device list mutex, we can\n\t\t * kick off writing super in log tree sync.\n\t\t */\n\t\tmutex_lock(&fs_info->fs_devices->device_list_mutex);\n\t\tret = scrub_supers(sctx, dev);\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t}\n\n\tif (!ret)\n\t\tret = scrub_enumerate_chunks(sctx, dev, start, end);\n\tmemalloc_nofs_restore(nofs_flag);\n\n\twait_event(sctx->list_wait, atomic_read(&sctx->bios_in_flight) == 0);\n\tatomic_dec(&fs_info->scrubs_running);\n\twake_up(&fs_info->scrub_pause_wait);\n\n\twait_event(sctx->list_wait, atomic_read(&sctx->workers_pending) == 0);\n\n\tif (progress)\n\t\tmemcpy(progress, &sctx->stat, sizeof(*progress));\n\n\tmutex_lock(&fs_info->scrub_lock);\n\tdev->scrub_ctx = NULL;\n\tscrub_workers_put(fs_info);\n\tmutex_unlock(&fs_info->scrub_lock);\n\n\tscrub_put_ctx(sctx);\n\n\treturn ret;\n\nout_free_ctx:\n\tscrub_free_ctx(sctx);\n\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 4015,
    "line_new": 4015,
    "critical_vars": [
      "dev"
    ],
    "function": "btrfs_scrub_progress",
    "filename": "linux/CVE-2019-18885/CVE-2019-18885_CWE-476_09ba3bc9dd150457c506e4661380a6183af651c1_scrub.c.diff",
    "function_code": "int btrfs_scrub_progress(struct btrfs_fs_info *fs_info, u64 devid,\n\t\t\t struct btrfs_scrub_progress *progress)\n{\n\tstruct btrfs_device *dev;\n\tstruct scrub_ctx *sctx = NULL;\n\n\tmutex_lock(&fs_info->fs_devices->device_list_mutex);\n\tdev = btrfs_find_device(fs_info->fs_devices, devid, NULL, NULL, true);\n\tif (dev)\n\t\tsctx = dev->scrub_ctx;\n\tif (sctx)\n\t\tmemcpy(progress, &sctx->stat, sizeof(*progress));\n\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\n\treturn dev ? (sctx ? 0 : -ENOTCONN) : -ENODEV;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 115,
    "critical_vars": [
      "true"
    ],
    "function": "btrfs_init_dev_replace",
    "filename": "linux/CVE-2019-18885/CVE-2019-18885_CWE-476_09ba3bc9dd150457c506e4661380a6183af651c1_dev-replace.c.diff",
    "function_code": "int btrfs_init_dev_replace(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_root *dev_root = fs_info->dev_root;\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tint ret = 0;\n\tstruct btrfs_path *path = NULL;\n\tint item_size;\n\tstruct btrfs_dev_replace_item *ptr;\n\tu64 src_devid;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_DEV_REPLACE_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, dev_root, &key, path, 0, 0);\n\tif (ret) {\nno_valid_dev_replace_entry_found:\n\t\tret = 0;\n\t\tdev_replace->replace_state =\n\t\t\tBTRFS_DEV_REPLACE_ITEM_STATE_NEVER_STARTED;\n\t\tdev_replace->cont_reading_from_srcdev_mode =\n\t\t    BTRFS_DEV_REPLACE_ITEM_CONT_READING_FROM_SRCDEV_MODE_ALWAYS;\n\t\tdev_replace->time_started = 0;\n\t\tdev_replace->time_stopped = 0;\n\t\tatomic64_set(&dev_replace->num_write_errors, 0);\n\t\tatomic64_set(&dev_replace->num_uncorrectable_read_errors, 0);\n\t\tdev_replace->cursor_left = 0;\n\t\tdev_replace->committed_cursor_left = 0;\n\t\tdev_replace->cursor_left_last_write_of_item = 0;\n\t\tdev_replace->cursor_right = 0;\n\t\tdev_replace->srcdev = NULL;\n\t\tdev_replace->tgtdev = NULL;\n\t\tdev_replace->is_valid = 0;\n\t\tdev_replace->item_needs_writeback = 0;\n\t\tgoto out;\n\t}\n\tslot = path->slots[0];\n\teb = path->nodes[0];\n\titem_size = btrfs_item_size_nr(eb, slot);\n\tptr = btrfs_item_ptr(eb, slot, struct btrfs_dev_replace_item);\n\n\tif (item_size != sizeof(struct btrfs_dev_replace_item)) {\n\t\tbtrfs_warn(fs_info,\n\t\t\t\"dev_replace entry found has unexpected size, ignore entry\");\n\t\tgoto no_valid_dev_replace_entry_found;\n\t}\n\n\tsrc_devid = btrfs_dev_replace_src_devid(eb, ptr);\n\tdev_replace->cont_reading_from_srcdev_mode =\n\t\tbtrfs_dev_replace_cont_reading_from_srcdev_mode(eb, ptr);\n\tdev_replace->replace_state = btrfs_dev_replace_replace_state(eb, ptr);\n\tdev_replace->time_started = btrfs_dev_replace_time_started(eb, ptr);\n\tdev_replace->time_stopped =\n\t\tbtrfs_dev_replace_time_stopped(eb, ptr);\n\tatomic64_set(&dev_replace->num_write_errors,\n\t\t     btrfs_dev_replace_num_write_errors(eb, ptr));\n\tatomic64_set(&dev_replace->num_uncorrectable_read_errors,\n\t\t     btrfs_dev_replace_num_uncorrectable_read_errors(eb, ptr));\n\tdev_replace->cursor_left = btrfs_dev_replace_cursor_left(eb, ptr);\n\tdev_replace->committed_cursor_left = dev_replace->cursor_left;\n\tdev_replace->cursor_left_last_write_of_item = dev_replace->cursor_left;\n\tdev_replace->cursor_right = btrfs_dev_replace_cursor_right(eb, ptr);\n\tdev_replace->is_valid = 1;\n\n\tdev_replace->item_needs_writeback = 0;\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\t\tdev_replace->srcdev = NULL;\n\t\tdev_replace->tgtdev = NULL;\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\tdev_replace->srcdev = btrfs_find_device(fs_info->fs_devices,\n\t\t\t\t\t\tsrc_devid, NULL, NULL, true);\n\t\tdev_replace->tgtdev = btrfs_find_device(fs_info->fs_devices,\n\t\t\t\t\t\t\tBTRFS_DEV_REPLACE_DEVID,\n\t\t\t\t\t\t\tNULL, NULL, true);\n\t\t/*\n\t\t * allow 'btrfs dev replace_cancel' if src/tgt device is\n\t\t * missing\n\t\t */\n\t\tif (!dev_replace->srcdev &&\n\t\t    !btrfs_test_opt(fs_info, DEGRADED)) {\n\t\t\tret = -EIO;\n\t\t\tbtrfs_warn(fs_info,\n\t\t\t   \"cannot mount because device replace operation is ongoing and\");\n\t\t\tbtrfs_warn(fs_info,\n\t\t\t   \"srcdev (devid %llu) is missing, need to run 'btrfs dev scan'?\",\n\t\t\t   src_devid);\n\t\t}\n\t\tif (!dev_replace->tgtdev &&\n\t\t    !btrfs_test_opt(fs_info, DEGRADED)) {\n\t\t\tret = -EIO;\n\t\t\tbtrfs_warn(fs_info,\n\t\t\t   \"cannot mount because device replace operation is ongoing and\");\n\t\t\tbtrfs_warn(fs_info,\n\t\t\t   \"tgtdev (devid %llu) is missing, need to run 'btrfs dev scan'?\",\n\t\t\t\tBTRFS_DEV_REPLACE_DEVID);\n\t\t}\n\t\tif (dev_replace->tgtdev) {\n\t\t\tif (dev_replace->srcdev) {\n\t\t\t\tdev_replace->tgtdev->total_bytes =\n\t\t\t\t\tdev_replace->srcdev->total_bytes;\n\t\t\t\tdev_replace->tgtdev->disk_total_bytes =\n\t\t\t\t\tdev_replace->srcdev->disk_total_bytes;\n\t\t\t\tdev_replace->tgtdev->commit_total_bytes =\n\t\t\t\t\tdev_replace->srcdev->commit_total_bytes;\n\t\t\t\tdev_replace->tgtdev->bytes_used =\n\t\t\t\t\tdev_replace->srcdev->bytes_used;\n\t\t\t\tdev_replace->tgtdev->commit_bytes_used =\n\t\t\t\t\tdev_replace->srcdev->commit_bytes_used;\n\t\t\t}\n\t\t\tset_bit(BTRFS_DEV_STATE_REPLACE_TGT,\n\t\t\t\t&dev_replace->tgtdev->dev_state);\n\n\t\t\tWARN_ON(fs_info->fs_devices->rw_devices == 0);\n\t\t\tdev_replace->tgtdev->io_width = fs_info->sectorsize;\n\t\t\tdev_replace->tgtdev->io_align = fs_info->sectorsize;\n\t\t\tdev_replace->tgtdev->sector_size = fs_info->sectorsize;\n\t\t\tdev_replace->tgtdev->fs_info = fs_info;\n\t\t\tset_bit(BTRFS_DEV_STATE_IN_FS_METADATA,\n\t\t\t\t&dev_replace->tgtdev->dev_state);\n\t\t}\n\t\tbreak;\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 1645,
    "line_new": 1645,
    "critical_vars": [
      "device"
    ],
    "function": "btrfs_ioctl_resize",
    "filename": "linux/CVE-2019-18885/CVE-2019-18885_CWE-476_09ba3bc9dd150457c506e4661380a6183af651c1_ioctl.c.diff",
    "function_code": "static noinline int btrfs_ioctl_resize(struct file *file,\n\t\t\t\t\tvoid __user *arg)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tu64 new_size;\n\tu64 old_size;\n\tu64 devid = 1;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_ioctl_vol_args *vol_args;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_device *device = NULL;\n\tchar *sizestr;\n\tchar *retptr;\n\tchar *devstr = NULL;\n\tint ret = 0;\n\tint mod = 0;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tif (test_and_set_bit(BTRFS_FS_EXCL_OP, &fs_info->flags)) {\n\t\tmnt_drop_write_file(file);\n\t\treturn BTRFS_ERROR_DEV_EXCL_RUN_IN_PROGRESS;\n\t}\n\n\tvol_args = memdup_user(arg, sizeof(*vol_args));\n\tif (IS_ERR(vol_args)) {\n\t\tret = PTR_ERR(vol_args);\n\t\tgoto out;\n\t}\n\n\tvol_args->name[BTRFS_PATH_NAME_MAX] = '\\0';\n\n\tsizestr = vol_args->name;\n\tdevstr = strchr(sizestr, ':');\n\tif (devstr) {\n\t\tsizestr = devstr + 1;\n\t\t*devstr = '\\0';\n\t\tdevstr = vol_args->name;\n\t\tret = kstrtoull(devstr, 10, &devid);\n\t\tif (ret)\n\t\t\tgoto out_free;\n\t\tif (!devid) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t\tbtrfs_info(fs_info, \"resizing devid %llu\", devid);\n\t}\n\n\tdevice = btrfs_find_device(fs_info->fs_devices, devid, NULL, NULL, true);\n\tif (!device) {\n\t\tbtrfs_info(fs_info, \"resizer unable to find device %llu\",\n\t\t\t   devid);\n\t\tret = -ENODEV;\n\t\tgoto out_free;\n\t}\n\n\tif (!test_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state)) {\n\t\tbtrfs_info(fs_info,\n\t\t\t   \"resizer unable to apply on readonly device %llu\",\n\t\t       devid);\n\t\tret = -EPERM;\n\t\tgoto out_free;\n\t}\n\n\tif (!strcmp(sizestr, \"max\"))\n\t\tnew_size = device->bdev->bd_inode->i_size;\n\telse {\n\t\tif (sizestr[0] == '-') {\n\t\t\tmod = -1;\n\t\t\tsizestr++;\n\t\t} else if (sizestr[0] == '+') {\n\t\t\tmod = 1;\n\t\t\tsizestr++;\n\t\t}\n\t\tnew_size = memparse(sizestr, &retptr);\n\t\tif (*retptr != '\\0' || new_size == 0) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\tif (test_bit(BTRFS_DEV_STATE_REPLACE_TGT, &device->dev_state)) {\n\t\tret = -EPERM;\n\t\tgoto out_free;\n\t}\n\n\told_size = btrfs_device_get_total_bytes(device);\n\n\tif (mod < 0) {\n\t\tif (new_size > old_size) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t\tnew_size = old_size - new_size;\n\t} else if (mod > 0) {\n\t\tif (new_size > ULLONG_MAX - old_size) {\n\t\t\tret = -ERANGE;\n\t\t\tgoto out_free;\n\t\t}\n\t\tnew_size = old_size + new_size;\n\t}\n\n\tif (new_size < SZ_256M) {\n\t\tret = -EINVAL;\n\t\tgoto out_free;\n\t}\n\tif (new_size > device->bdev->bd_inode->i_size) {\n\t\tret = -EFBIG;\n\t\tgoto out_free;\n\t}\n\n\tnew_size = round_down(new_size, fs_info->sectorsize);\n\n\tbtrfs_info_in_rcu(fs_info, \"new size for %s is %llu\",\n\t\t\t  rcu_str_deref(device->name), new_size);\n\n\tif (new_size > old_size) {\n\t\ttrans = btrfs_start_transaction(root, 0);\n\t\tif (IS_ERR(trans)) {\n\t\t\tret = PTR_ERR(trans);\n\t\t\tgoto out_free;\n\t\t}\n\t\tret = btrfs_grow_device(trans, device, new_size);\n\t\tbtrfs_commit_transaction(trans);\n\t} else if (new_size < old_size) {\n\t\tret = btrfs_shrink_device(device, new_size);\n\t} /* equal, nothing need to do */\n\nout_free:\n\tkfree(vol_args);\nout:\n\tclear_bit(BTRFS_FS_EXCL_OP, &fs_info->flags);\n\tmnt_drop_write_file(file);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 3182,
    "critical_vars": [
      "true"
    ],
    "function": "btrfs_ioctl_dev_info",
    "filename": "linux/CVE-2019-18885/CVE-2019-18885_CWE-476_09ba3bc9dd150457c506e4661380a6183af651c1_ioctl.c.diff",
    "function_code": "static long btrfs_ioctl_dev_info(struct btrfs_fs_info *fs_info,\n\t\t\t\t void __user *arg)\n{\n\tstruct btrfs_ioctl_dev_info_args *di_args;\n\tstruct btrfs_device *dev;\n\tint ret = 0;\n\tchar *s_uuid = NULL;\n\n\tdi_args = memdup_user(arg, sizeof(*di_args));\n\tif (IS_ERR(di_args))\n\t\treturn PTR_ERR(di_args);\n\n\tif (!btrfs_is_empty_uuid(di_args->uuid))\n\t\ts_uuid = di_args->uuid;\n\n\trcu_read_lock();\n\tdev = btrfs_find_device(fs_info->fs_devices, di_args->devid, s_uuid,\n\t\t\t\tNULL, true);\n\n\tif (!dev) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tdi_args->devid = dev->devid;\n\tdi_args->bytes_used = btrfs_device_get_bytes_used(dev);\n\tdi_args->total_bytes = btrfs_device_get_total_bytes(dev);\n\tmemcpy(di_args->uuid, dev->uuid, sizeof(di_args->uuid));\n\tif (dev->name) {\n\t\tstrncpy(di_args->path, rcu_str_deref(dev->name),\n\t\t\t\tsizeof(di_args->path) - 1);\n\t\tdi_args->path[sizeof(di_args->path) - 1] = 0;\n\t} else {\n\t\tdi_args->path[0] = '\\0';\n\t}\n\nout:\n\trcu_read_unlock();\n\tif (ret == 0 && copy_to_user(arg, di_args, sizeof(*di_args)))\n\t\tret = -EFAULT;\n\n\tkfree(di_args);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 987,
    "line_new": 966,
    "critical_vars": [
      "device"
    ],
    "function": "*device_list_add",
    "filename": "linux/CVE-2019-18885/CVE-2019-18885_CWE-476_09ba3bc9dd150457c506e4661380a6183af651c1_volumes.c.diff",
    "function_code": "static noinline struct btrfs_device *device_list_add(const char *path,\n\t\t\t   struct btrfs_super_block *disk_super,\n\t\t\t   bool *new_device_added)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_fs_devices *fs_devices = NULL;\n\tstruct rcu_string *name;\n\tu64 found_transid = btrfs_super_generation(disk_super);\n\tu64 devid = btrfs_stack_device_id(&disk_super->dev_item);\n\tbool has_metadata_uuid = (btrfs_super_incompat_flags(disk_super) &\n\t\tBTRFS_FEATURE_INCOMPAT_METADATA_UUID);\n\tbool fsid_change_in_progress = (btrfs_super_flags(disk_super) &\n\t\t\t\t\tBTRFS_SUPER_FLAG_CHANGING_FSID_V2);\n\n\tif (fsid_change_in_progress) {\n\t\tif (!has_metadata_uuid) {\n\t\t\t/*\n\t\t\t * When we have an image which has CHANGING_FSID_V2 set\n\t\t\t * it might belong to either a filesystem which has\n\t\t\t * disks with completed fsid change or it might belong\n\t\t\t * to fs with no UUID changes in effect, handle both.\n\t\t\t */\n\t\t\tfs_devices = find_fsid_inprogress(disk_super);\n\t\t\tif (!fs_devices)\n\t\t\t\tfs_devices = find_fsid(disk_super->fsid, NULL);\n\t\t} else {\n\t\t\tfs_devices = find_fsid_changed(disk_super);\n\t\t}\n\t} else if (has_metadata_uuid) {\n\t\tfs_devices = find_fsid(disk_super->fsid,\n\t\t\t\t       disk_super->metadata_uuid);\n\t} else {\n\t\tfs_devices = find_fsid(disk_super->fsid, NULL);\n\t}\n\n\n\tif (!fs_devices) {\n\t\tif (has_metadata_uuid)\n\t\t\tfs_devices = alloc_fs_devices(disk_super->fsid,\n\t\t\t\t\t\t      disk_super->metadata_uuid);\n\t\telse\n\t\t\tfs_devices = alloc_fs_devices(disk_super->fsid, NULL);\n\n\t\tif (IS_ERR(fs_devices))\n\t\t\treturn ERR_CAST(fs_devices);\n\n\t\tfs_devices->fsid_change = fsid_change_in_progress;\n\n\t\tmutex_lock(&fs_devices->device_list_mutex);\n\t\tlist_add(&fs_devices->fs_list, &fs_uuids);\n\n\t\tdevice = NULL;\n\t} else {\n\t\tmutex_lock(&fs_devices->device_list_mutex);\n\t\tdevice = btrfs_find_device(fs_devices, devid,\n\t\t\t\tdisk_super->dev_item.uuid, NULL, false);\n\n\t\t/*\n\t\t * If this disk has been pulled into an fs devices created by\n\t\t * a device which had the CHANGING_FSID_V2 flag then replace the\n\t\t * metadata_uuid/fsid values of the fs_devices.\n\t\t */\n\t\tif (has_metadata_uuid && fs_devices->fsid_change &&\n\t\t    found_transid > fs_devices->latest_generation) {\n\t\t\tmemcpy(fs_devices->fsid, disk_super->fsid,\n\t\t\t\t\tBTRFS_FSID_SIZE);\n\t\t\tmemcpy(fs_devices->metadata_uuid,\n\t\t\t\t\tdisk_super->metadata_uuid, BTRFS_FSID_SIZE);\n\n\t\t\tfs_devices->fsid_change = false;\n\t\t}\n\t}\n\n\tif (!device) {\n\t\tif (fs_devices->opened) {\n\t\t\tmutex_unlock(&fs_devices->device_list_mutex);\n\t\t\treturn ERR_PTR(-EBUSY);\n\t\t}\n\n\t\tdevice = btrfs_alloc_device(NULL, &devid,\n\t\t\t\t\t    disk_super->dev_item.uuid);\n\t\tif (IS_ERR(device)) {\n\t\t\tmutex_unlock(&fs_devices->device_list_mutex);\n\t\t\t/* we can safely leave the fs_devices entry around */\n\t\t\treturn device;\n\t\t}\n\n\t\tname = rcu_string_strdup(path, GFP_NOFS);\n\t\tif (!name) {\n\t\t\tbtrfs_free_device(device);\n\t\t\tmutex_unlock(&fs_devices->device_list_mutex);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t\trcu_assign_pointer(device->name, name);\n\n\t\tlist_add_rcu(&device->dev_list, &fs_devices->devices);\n\t\tfs_devices->num_devices++;\n\n\t\tdevice->fs_devices = fs_devices;\n\t\t*new_device_added = true;\n\n\t\tif (disk_super->label[0])\n\t\t\tpr_info(\"BTRFS: device label %s devid %llu transid %llu %s\\n\",\n\t\t\t\tdisk_super->label, devid, found_transid, path);\n\t\telse\n\t\t\tpr_info(\"BTRFS: device fsid %pU devid %llu transid %llu %s\\n\",\n\t\t\t\tdisk_super->fsid, devid, found_transid, path);\n\n\t} else if (!device->name || strcmp(device->name->str, path)) {\n\t\t/*\n\t\t * When FS is already mounted.\n\t\t * 1. If you are here and if the device->name is NULL that\n\t\t *    means this device was missing at time of FS mount.\n\t\t * 2. If you are here and if the device->name is different\n\t\t *    from 'path' that means either\n\t\t *      a. The same device disappeared and reappeared with\n\t\t *         different name. or\n\t\t *      b. The missing-disk-which-was-replaced, has\n\t\t *         reappeared now.\n\t\t *\n\t\t * We must allow 1 and 2a above. But 2b would be a spurious\n\t\t * and unintentional.\n\t\t *\n\t\t * Further in case of 1 and 2a above, the disk at 'path'\n\t\t * would have missed some transaction when it was away and\n\t\t * in case of 2a the stale bdev has to be updated as well.\n\t\t * 2b must not be allowed at all time.\n\t\t */\n\n\t\t/*\n\t\t * For now, we do allow update to btrfs_fs_device through the\n\t\t * btrfs dev scan cli after FS has been mounted.  We're still\n\t\t * tracking a problem where systems fail mount by subvolume id\n\t\t * when we reject replacement on a mounted FS.\n\t\t */\n\t\tif (!fs_devices->opened && found_transid < device->generation) {\n\t\t\t/*\n\t\t\t * That is if the FS is _not_ mounted and if you\n\t\t\t * are here, that means there is more than one\n\t\t\t * disk with same uuid and devid.We keep the one\n\t\t\t * with larger generation number or the last-in if\n\t\t\t * generation are equal.\n\t\t\t */\n\t\t\tmutex_unlock(&fs_devices->device_list_mutex);\n\t\t\treturn ERR_PTR(-EEXIST);\n\t\t}\n\n\t\t/*\n\t\t * We are going to replace the device path for a given devid,\n\t\t * make sure it's the same device if the device is mounted\n\t\t */\n\t\tif (device->bdev) {\n\t\t\tstruct block_device *path_bdev;\n\n\t\t\tpath_bdev = lookup_bdev(path);\n\t\t\tif (IS_ERR(path_bdev)) {\n\t\t\t\tmutex_unlock(&fs_devices->device_list_mutex);\n\t\t\t\treturn ERR_CAST(path_bdev);\n\t\t\t}\n\n\t\t\tif (device->bdev != path_bdev) {\n\t\t\t\tbdput(path_bdev);\n\t\t\t\tmutex_unlock(&fs_devices->device_list_mutex);\n\t\t\t\tbtrfs_warn_in_rcu(device->fs_info,\n\t\t\t\"duplicate device fsid:devid for %pU:%llu old:%s new:%s\",\n\t\t\t\t\tdisk_super->fsid, devid,\n\t\t\t\t\trcu_str_deref(device->name), path);\n\t\t\t\treturn ERR_PTR(-EEXIST);\n\t\t\t}\n\t\t\tbdput(path_bdev);\n\t\t\tbtrfs_info_in_rcu(device->fs_info,\n\t\t\t\t\"device fsid %pU devid %llu moved old:%s new:%s\",\n\t\t\t\tdisk_super->fsid, devid,\n\t\t\t\trcu_str_deref(device->name), path);\n\t\t}\n\n\t\tname = rcu_string_strdup(path, GFP_NOFS);\n\t\tif (!name) {\n\t\t\tmutex_unlock(&fs_devices->device_list_mutex);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t\trcu_string_free(device->name);\n\t\trcu_assign_pointer(device->name, name);\n\t\tif (test_bit(BTRFS_DEV_STATE_MISSING, &device->dev_state)) {\n\t\t\tfs_devices->missing_devices--;\n\t\t\tclear_bit(BTRFS_DEV_STATE_MISSING, &device->dev_state);\n\t\t}\n\t}\n\n\t/*\n\t * Unmount does not free the btrfs_device struct but would zero\n\t * generation along with most of the other members. So just update\n\t * it back. We need it to pick the disk with largest generation\n\t * (as above).\n\t */\n\tif (!fs_devices->opened) {\n\t\tdevice->generation = found_transid;\n\t\tfs_devices->latest_generation = max_t(u64, found_transid,\n\t\t\t\t\t\tfs_devices->latest_generation);\n\t}\n\n\tfs_devices->total_devices = btrfs_super_num_devices(disk_super);\n\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\treturn device;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 2384,
    "critical_vars": [
      "true"
    ],
    "function": "*btrfs_find_device_by_path",
    "filename": "linux/CVE-2019-18885/CVE-2019-18885_CWE-476_09ba3bc9dd150457c506e4661380a6183af651c1_volumes.c.diff",
    "function_code": "static struct btrfs_device *btrfs_find_device_by_path(\n\t\tstruct btrfs_fs_info *fs_info, const char *device_path)\n{\n\tint ret = 0;\n\tstruct btrfs_super_block *disk_super;\n\tu64 devid;\n\tu8 *dev_uuid;\n\tstruct block_device *bdev;\n\tstruct buffer_head *bh;\n\tstruct btrfs_device *device;\n\n\tret = btrfs_get_bdev_and_sb(device_path, FMODE_READ,\n\t\t\t\t    fs_info->bdev_holder, 0, &bdev, &bh);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\tdisk_super = (struct btrfs_super_block *)bh->b_data;\n\tdevid = btrfs_stack_device_id(&disk_super->dev_item);\n\tdev_uuid = disk_super->dev_item.uuid;\n\tif (btrfs_fs_incompat(fs_info, METADATA_UUID))\n\t\tdevice = btrfs_find_device(fs_info->fs_devices, devid, dev_uuid,\n\t\t\t\t\t   disk_super->metadata_uuid, true);\n\telse\n\t\tdevice = btrfs_find_device(fs_info->fs_devices, devid, dev_uuid,\n\t\t\t\t\t   disk_super->fsid, true);\n\n\tbrelse(bh);\n\tif (!device)\n\t\tdevice = ERR_PTR(-ENOENT);\n\tblkdev_put(bdev, FMODE_READ);\n\treturn device;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 2407,
    "critical_vars": [
      "true"
    ],
    "function": "*btrfs_find_device_by_devspec",
    "filename": "linux/CVE-2019-18885/CVE-2019-18885_CWE-476_09ba3bc9dd150457c506e4661380a6183af651c1_volumes.c.diff",
    "function_code": "struct btrfs_device *btrfs_find_device_by_devspec(\n\t\tstruct btrfs_fs_info *fs_info, u64 devid,\n\t\tconst char *device_path)\n{\n\tstruct btrfs_device *device;\n\n\tif (devid) {\n\t\tdevice = btrfs_find_device(fs_info->fs_devices, devid, NULL,\n\t\t\t\t\t   NULL, true);\n\t\tif (!device)\n\t\t\treturn ERR_PTR(-ENOENT);\n\t\treturn device;\n\t}\n\n\tif (!device_path || !device_path[0])\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (strcmp(device_path, \"missing\") == 0) {\n\t\t/* Find first missing device */\n\t\tlist_for_each_entry(device, &fs_info->fs_devices->devices,\n\t\t\t\t    dev_list) {\n\t\t\tif (test_bit(BTRFS_DEV_STATE_IN_FS_METADATA,\n\t\t\t\t     &device->dev_state) && !device->bdev)\n\t\t\t\treturn device;\n\t\t}\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\treturn btrfs_find_device_by_path(fs_info, device_path);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 2550,
    "critical_vars": [
      "true",
      "fs_uuid"
    ],
    "function": "btrfs_finish_sprout",
    "filename": "linux/CVE-2019-18885/CVE-2019-18885_CWE-476_09ba3bc9dd150457c506e4661380a6183af651c1_volumes.c.diff",
    "function_code": "static int btrfs_finish_sprout(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *root = fs_info->chunk_root;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_dev_item *dev_item;\n\tstruct btrfs_device *device;\n\tstruct btrfs_key key;\n\tu8 fs_uuid[BTRFS_FSID_SIZE];\n\tu8 dev_uuid[BTRFS_UUID_SIZE];\n\tu64 devid;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = BTRFS_DEV_ITEMS_OBJECTID;\n\tkey.offset = 0;\n\tkey.type = BTRFS_DEV_ITEM_KEY;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\tleaf = path->nodes[0];\nnext_slot:\n\t\tif (path->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret > 0)\n\t\t\t\tbreak;\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tleaf = path->nodes[0];\n\t\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\t\tbtrfs_release_path(path);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tif (key.objectid != BTRFS_DEV_ITEMS_OBJECTID ||\n\t\t    key.type != BTRFS_DEV_ITEM_KEY)\n\t\t\tbreak;\n\n\t\tdev_item = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t  struct btrfs_dev_item);\n\t\tdevid = btrfs_device_id(leaf, dev_item);\n\t\tread_extent_buffer(leaf, dev_uuid, btrfs_device_uuid(dev_item),\n\t\t\t\t   BTRFS_UUID_SIZE);\n\t\tread_extent_buffer(leaf, fs_uuid, btrfs_device_fsid(dev_item),\n\t\t\t\t   BTRFS_FSID_SIZE);\n\t\tdevice = btrfs_find_device(fs_info->fs_devices, devid, dev_uuid,\n\t\t\t\t\t   fs_uuid, true);\n\t\tBUG_ON(!device); /* Logic error */\n\n\t\tif (device->fs_devices->seeding) {\n\t\t\tbtrfs_set_device_generation(leaf, dev_item,\n\t\t\t\t\t\t    device->generation);\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t}\n\n\t\tpath->slots[0]++;\n\t\tgoto next_slot;\n\t}\n\tret = 0;\nerror:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 6878,
    "critical_vars": [
      "true"
    ],
    "function": "read_one_chunk",
    "filename": "linux/CVE-2019-18885/CVE-2019-18885_CWE-476_09ba3bc9dd150457c506e4661380a6183af651c1_volumes.c.diff",
    "function_code": "static int read_one_chunk(struct btrfs_fs_info *fs_info, struct btrfs_key *key,\n\t\t\t  struct extent_buffer *leaf,\n\t\t\t  struct btrfs_chunk *chunk)\n{\n\tstruct btrfs_mapping_tree *map_tree = &fs_info->mapping_tree;\n\tstruct map_lookup *map;\n\tstruct extent_map *em;\n\tu64 logical;\n\tu64 length;\n\tu64 devid;\n\tu8 uuid[BTRFS_UUID_SIZE];\n\tint num_stripes;\n\tint ret;\n\tint i;\n\n\tlogical = key->offset;\n\tlength = btrfs_chunk_length(leaf, chunk);\n\tnum_stripes = btrfs_chunk_num_stripes(leaf, chunk);\n\n\tret = btrfs_check_chunk_valid(fs_info, leaf, chunk, logical);\n\tif (ret)\n\t\treturn ret;\n\n\tread_lock(&map_tree->map_tree.lock);\n\tem = lookup_extent_mapping(&map_tree->map_tree, logical, 1);\n\tread_unlock(&map_tree->map_tree.lock);\n\n\t/* already mapped? */\n\tif (em && em->start <= logical && em->start + em->len > logical) {\n\t\tfree_extent_map(em);\n\t\treturn 0;\n\t} else if (em) {\n\t\tfree_extent_map(em);\n\t}\n\n\tem = alloc_extent_map();\n\tif (!em)\n\t\treturn -ENOMEM;\n\tmap = kmalloc(map_lookup_size(num_stripes), GFP_NOFS);\n\tif (!map) {\n\t\tfree_extent_map(em);\n\t\treturn -ENOMEM;\n\t}\n\n\tset_bit(EXTENT_FLAG_FS_MAPPING, &em->flags);\n\tem->map_lookup = map;\n\tem->start = logical;\n\tem->len = length;\n\tem->orig_start = 0;\n\tem->block_start = 0;\n\tem->block_len = em->len;\n\n\tmap->num_stripes = num_stripes;\n\tmap->io_width = btrfs_chunk_io_width(leaf, chunk);\n\tmap->io_align = btrfs_chunk_io_align(leaf, chunk);\n\tmap->stripe_len = btrfs_chunk_stripe_len(leaf, chunk);\n\tmap->type = btrfs_chunk_type(leaf, chunk);\n\tmap->sub_stripes = btrfs_chunk_sub_stripes(leaf, chunk);\n\tmap->verified_stripes = 0;\n\tfor (i = 0; i < num_stripes; i++) {\n\t\tmap->stripes[i].physical =\n\t\t\tbtrfs_stripe_offset_nr(leaf, chunk, i);\n\t\tdevid = btrfs_stripe_devid_nr(leaf, chunk, i);\n\t\tread_extent_buffer(leaf, uuid, (unsigned long)\n\t\t\t\t   btrfs_stripe_dev_uuid_nr(chunk, i),\n\t\t\t\t   BTRFS_UUID_SIZE);\n\t\tmap->stripes[i].dev = btrfs_find_device(fs_info->fs_devices,\n\t\t\t\t\t\t\tdevid, uuid, NULL, true);\n\t\tif (!map->stripes[i].dev &&\n\t\t    !btrfs_test_opt(fs_info, DEGRADED)) {\n\t\t\tfree_extent_map(em);\n\t\t\tbtrfs_report_missing_device(fs_info, devid, uuid, true);\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tif (!map->stripes[i].dev) {\n\t\t\tmap->stripes[i].dev =\n\t\t\t\tadd_missing_dev(fs_info->fs_devices, devid,\n\t\t\t\t\t\tuuid);\n\t\t\tif (IS_ERR(map->stripes[i].dev)) {\n\t\t\t\tfree_extent_map(em);\n\t\t\t\tbtrfs_err(fs_info,\n\t\t\t\t\t\"failed to init missing dev %llu: %ld\",\n\t\t\t\t\tdevid, PTR_ERR(map->stripes[i].dev));\n\t\t\t\treturn PTR_ERR(map->stripes[i].dev);\n\t\t\t}\n\t\t\tbtrfs_report_missing_device(fs_info, devid, uuid, false);\n\t\t}\n\t\tset_bit(BTRFS_DEV_STATE_IN_FS_METADATA,\n\t\t\t\t&(map->stripes[i].dev->dev_state));\n\n\t}\n\n\twrite_lock(&map_tree->map_tree.lock);\n\tret = add_extent_mapping(&map_tree->map_tree, em, 0);\n\twrite_unlock(&map_tree->map_tree.lock);\n\tif (ret < 0) {\n\t\tbtrfs_err(fs_info,\n\t\t\t  \"failed to add chunk map, start=%llu len=%llu: %d\",\n\t\t\t  em->start, em->len, ret);\n\t}\n\tfree_extent_map(em);\n\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 7018,
    "critical_vars": [
      "true",
      "fs_uuid"
    ],
    "function": "read_one_dev",
    "filename": "linux/CVE-2019-18885/CVE-2019-18885_CWE-476_09ba3bc9dd150457c506e4661380a6183af651c1_volumes.c.diff",
    "function_code": "static int read_one_dev(struct btrfs_fs_info *fs_info,\n\t\t\tstruct extent_buffer *leaf,\n\t\t\tstruct btrfs_dev_item *dev_item)\n{\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tstruct btrfs_device *device;\n\tu64 devid;\n\tint ret;\n\tu8 fs_uuid[BTRFS_FSID_SIZE];\n\tu8 dev_uuid[BTRFS_UUID_SIZE];\n\n\tdevid = btrfs_device_id(leaf, dev_item);\n\tread_extent_buffer(leaf, dev_uuid, btrfs_device_uuid(dev_item),\n\t\t\t   BTRFS_UUID_SIZE);\n\tread_extent_buffer(leaf, fs_uuid, btrfs_device_fsid(dev_item),\n\t\t\t   BTRFS_FSID_SIZE);\n\n\tif (memcmp(fs_uuid, fs_devices->metadata_uuid, BTRFS_FSID_SIZE)) {\n\t\tfs_devices = open_seed_devices(fs_info, fs_uuid);\n\t\tif (IS_ERR(fs_devices))\n\t\t\treturn PTR_ERR(fs_devices);\n\t}\n\n\tdevice = btrfs_find_device(fs_info->fs_devices, devid, dev_uuid,\n\t\t\t\t   fs_uuid, true);\n\tif (!device) {\n\t\tif (!btrfs_test_opt(fs_info, DEGRADED)) {\n\t\t\tbtrfs_report_missing_device(fs_info, devid,\n\t\t\t\t\t\t\tdev_uuid, true);\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tdevice = add_missing_dev(fs_devices, devid, dev_uuid);\n\t\tif (IS_ERR(device)) {\n\t\t\tbtrfs_err(fs_info,\n\t\t\t\t\"failed to add missing dev %llu: %ld\",\n\t\t\t\tdevid, PTR_ERR(device));\n\t\t\treturn PTR_ERR(device);\n\t\t}\n\t\tbtrfs_report_missing_device(fs_info, devid, dev_uuid, false);\n\t} else {\n\t\tif (!device->bdev) {\n\t\t\tif (!btrfs_test_opt(fs_info, DEGRADED)) {\n\t\t\t\tbtrfs_report_missing_device(fs_info,\n\t\t\t\t\t\tdevid, dev_uuid, true);\n\t\t\t\treturn -ENOENT;\n\t\t\t}\n\t\t\tbtrfs_report_missing_device(fs_info, devid,\n\t\t\t\t\t\t\tdev_uuid, false);\n\t\t}\n\n\t\tif (!device->bdev &&\n\t\t    !test_bit(BTRFS_DEV_STATE_MISSING, &device->dev_state)) {\n\t\t\t/*\n\t\t\t * this happens when a device that was properly setup\n\t\t\t * in the device info lists suddenly goes bad.\n\t\t\t * device->bdev is NULL, and so we have to set\n\t\t\t * device->missing to one here\n\t\t\t */\n\t\t\tdevice->fs_devices->missing_devices++;\n\t\t\tset_bit(BTRFS_DEV_STATE_MISSING, &device->dev_state);\n\t\t}\n\n\t\t/* Move the device to its own fs_devices */\n\t\tif (device->fs_devices != fs_devices) {\n\t\t\tASSERT(test_bit(BTRFS_DEV_STATE_MISSING,\n\t\t\t\t\t\t\t&device->dev_state));\n\n\t\t\tlist_move(&device->dev_list, &fs_devices->devices);\n\t\t\tdevice->fs_devices->num_devices--;\n\t\t\tfs_devices->num_devices++;\n\n\t\t\tdevice->fs_devices->missing_devices--;\n\t\t\tfs_devices->missing_devices++;\n\n\t\t\tdevice->fs_devices = fs_devices;\n\t\t}\n\t}\n\n\tif (device->fs_devices != fs_info->fs_devices) {\n\t\tBUG_ON(test_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state));\n\t\tif (device->generation !=\n\t\t    btrfs_device_generation(leaf, dev_item))\n\t\t\treturn -EINVAL;\n\t}\n\n\tfill_device_from_item(leaf, dev_item, device);\n\tset_bit(BTRFS_DEV_STATE_IN_FS_METADATA, &device->dev_state);\n\tif (test_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state) &&\n\t   !test_bit(BTRFS_DEV_STATE_REPLACE_TGT, &device->dev_state)) {\n\t\tdevice->fs_devices->total_rw_bytes += device->total_bytes;\n\t\tatomic64_add(device->total_bytes - device->bytes_used,\n\t\t\t\t&fs_info->free_chunk_space);\n\t}\n\tret = 0;\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 7612,
    "line_new": 7608,
    "critical_vars": [
      "dev"
    ],
    "function": "btrfs_get_dev_stats",
    "filename": "linux/CVE-2019-18885/CVE-2019-18885_CWE-476_09ba3bc9dd150457c506e4661380a6183af651c1_volumes.c.diff",
    "function_code": "int btrfs_get_dev_stats(struct btrfs_fs_info *fs_info,\n\t\t\tstruct btrfs_ioctl_get_dev_stats *stats)\n{\n\tstruct btrfs_device *dev;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tint i;\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tdev = btrfs_find_device(fs_info->fs_devices, stats->devid, NULL, NULL,\n\t\t\t\ttrue);\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\tif (!dev) {\n\t\tbtrfs_warn(fs_info, \"get dev_stats failed, device not found\");\n\t\treturn -ENODEV;\n\t} else if (!dev->dev_stats_valid) {\n\t\tbtrfs_warn(fs_info, \"get dev_stats failed, not yet valid\");\n\t\treturn -ENODEV;\n\t} else if (stats->flags & BTRFS_DEV_STATS_RESET) {\n\t\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++) {\n\t\t\tif (stats->nr_items > i)\n\t\t\t\tstats->values[i] =\n\t\t\t\t\tbtrfs_dev_stat_read_and_reset(dev, i);\n\t\t\telse\n\t\t\t\tbtrfs_dev_stat_reset(dev, i);\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++)\n\t\t\tif (stats->nr_items > i)\n\t\t\t\tstats->values[i] = btrfs_dev_stat_read(dev, i);\n\t}\n\tif (stats->nr_items > BTRFS_DEV_STAT_VALUES_MAX)\n\t\tstats->nr_items = BTRFS_DEV_STAT_VALUES_MAX;\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 7826,
    "line_new": 7823,
    "critical_vars": [
      "dev"
    ],
    "function": "verify_one_dev_extent",
    "filename": "linux/CVE-2019-18885/CVE-2019-18885_CWE-476_09ba3bc9dd150457c506e4661380a6183af651c1_volumes.c.diff",
    "function_code": "static int verify_one_dev_extent(struct btrfs_fs_info *fs_info,\n\t\t\t\t u64 chunk_offset, u64 devid,\n\t\t\t\t u64 physical_offset, u64 physical_len)\n{\n\tstruct extent_map_tree *em_tree = &fs_info->mapping_tree.map_tree;\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tstruct btrfs_device *dev;\n\tu64 stripe_len;\n\tbool found = false;\n\tint ret = 0;\n\tint i;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, chunk_offset, 1);\n\tread_unlock(&em_tree->lock);\n\n\tif (!em) {\n\t\tbtrfs_err(fs_info,\n\"dev extent physical offset %llu on devid %llu doesn't have corresponding chunk\",\n\t\t\t  physical_offset, devid);\n\t\tret = -EUCLEAN;\n\t\tgoto out;\n\t}\n\n\tmap = em->map_lookup;\n\tstripe_len = calc_stripe_length(map->type, em->len, map->num_stripes);\n\tif (physical_len != stripe_len) {\n\t\tbtrfs_err(fs_info,\n\"dev extent physical offset %llu on devid %llu length doesn't match chunk %llu, have %llu expect %llu\",\n\t\t\t  physical_offset, devid, em->start, physical_len,\n\t\t\t  stripe_len);\n\t\tret = -EUCLEAN;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < map->num_stripes; i++) {\n\t\tif (map->stripes[i].dev->devid == devid &&\n\t\t    map->stripes[i].physical == physical_offset) {\n\t\t\tfound = true;\n\t\t\tif (map->verified_stripes >= map->num_stripes) {\n\t\t\t\tbtrfs_err(fs_info,\n\t\t\t\t\"too many dev extents for chunk %llu found\",\n\t\t\t\t\t  em->start);\n\t\t\t\tret = -EUCLEAN;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmap->verified_stripes++;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) {\n\t\tbtrfs_err(fs_info,\n\t\"dev extent physical offset %llu devid %llu has no corresponding chunk\",\n\t\t\tphysical_offset, devid);\n\t\tret = -EUCLEAN;\n\t}\n\n\t/* Make sure no dev extent is beyond device bondary */\n\tdev = btrfs_find_device(fs_info->fs_devices, devid, NULL, NULL, true);\n\tif (!dev) {\n\t\tbtrfs_err(fs_info, \"failed to find devid %llu\", devid);\n\t\tret = -EUCLEAN;\n\t\tgoto out;\n\t}\n\n\t/* It's possible this device is a dummy for seed device */\n\tif (dev->disk_total_bytes == 0) {\n\t\tdev = btrfs_find_device(fs_info->fs_devices->seed, devid, NULL,\n\t\t\t\t\tNULL, false);\n\t\tif (!dev) {\n\t\t\tbtrfs_err(fs_info, \"failed to find seed devid %llu\",\n\t\t\t\t  devid);\n\t\t\tret = -EUCLEAN;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (physical_offset + physical_len > dev->disk_total_bytes) {\n\t\tbtrfs_err(fs_info,\n\"dev extent devid %llu physical offset %llu len %llu is beyond device boundary %llu\",\n\t\t\t  devid, physical_offset, physical_len,\n\t\t\t  dev->disk_total_bytes);\n\t\tret = -EUCLEAN;\n\t\tgoto out;\n\t}\nout:\n\tfree_extent_map(em);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 70,
    "critical_vars": [
      "ctx->gf128"
    ],
    "function": "ghash_update",
    "filename": "linux/CVE-2011-4081/CVE-2011-4081_CWE-476_7ed47b7d142ec99ad6880bbbec51e9f12b3af74c_ghash-generic.c.diff",
    "function_code": "static int ghash_update(struct shash_desc *desc,\n\t\t\t const u8 *src, unsigned int srclen)\n{\n\tstruct ghash_desc_ctx *dctx = shash_desc_ctx(desc);\n\tstruct ghash_ctx *ctx = crypto_shash_ctx(desc->tfm);\n\tu8 *dst = dctx->buffer;\n\n\tif (!ctx->gf128)\n\t\treturn -ENOKEY;\n\n\tif (dctx->bytes) {\n\t\tint n = min(srclen, dctx->bytes);\n\t\tu8 *pos = dst + (GHASH_BLOCK_SIZE - dctx->bytes);\n\n\t\tdctx->bytes -= n;\n\t\tsrclen -= n;\n\n\t\twhile (n--)\n\t\t\t*pos++ ^= *src++;\n\n\t\tif (!dctx->bytes)\n\t\t\tgf128mul_4k_lle((be128 *)dst, ctx->gf128);\n\t}\n\n\twhile (srclen >= GHASH_BLOCK_SIZE) {\n\t\tcrypto_xor(dst, src, GHASH_BLOCK_SIZE);\n\t\tgf128mul_4k_lle((be128 *)dst, ctx->gf128);\n\t\tsrc += GHASH_BLOCK_SIZE;\n\t\tsrclen -= GHASH_BLOCK_SIZE;\n\t}\n\n\tif (srclen) {\n\t\tdctx->bytes = GHASH_BLOCK_SIZE - srclen;\n\t\twhile (srclen--)\n\t\t\t*dst++ ^= *src++;\n\t}\n\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 125,
    "critical_vars": [
      "ctx->gf128"
    ],
    "function": "ghash_final",
    "filename": "linux/CVE-2011-4081/CVE-2011-4081_CWE-476_7ed47b7d142ec99ad6880bbbec51e9f12b3af74c_ghash-generic.c.diff",
    "function_code": "static int ghash_final(struct shash_desc *desc, u8 *dst)\n{\n\tstruct ghash_desc_ctx *dctx = shash_desc_ctx(desc);\n\tstruct ghash_ctx *ctx = crypto_shash_ctx(desc->tfm);\n\tu8 *buf = dctx->buffer;\n\n\tif (!ctx->gf128)\n\t\treturn -ENOKEY;\n\n\tghash_flush(ctx, dctx);\n\tmemcpy(dst, buf, GHASH_BLOCK_SIZE);\n\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 113,
    "critical_vars": [
      "llcp_sock->dev"
    ],
    "function": "llcp_sock_bind",
    "filename": "linux/CVE-2021-38208/CVE-2021-38208_CWE-476_4ac06a1e013cf5fdd963317ffd3b968560f33bba_llcp_sock.c.diff",
    "function_code": "static int llcp_sock_bind(struct socket *sock, struct sockaddr *addr, int alen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tstruct nfc_llcp_local *local;\n\tstruct nfc_dev *dev;\n\tstruct sockaddr_nfc_llcp llcp_addr;\n\tint len, ret = 0;\n\n\tif (!addr || alen < offsetofend(struct sockaddr, sa_family) ||\n\t    addr->sa_family != AF_NFC)\n\t\treturn -EINVAL;\n\n\tpr_debug(\"sk %p addr %p family %d\\n\", sk, addr, addr->sa_family);\n\n\tmemset(&llcp_addr, 0, sizeof(llcp_addr));\n\tlen = min_t(unsigned int, sizeof(llcp_addr), alen);\n\tmemcpy(&llcp_addr, addr, len);\n\n\t/* This is going to be a listening socket, dsap must be 0 */\n\tif (llcp_addr.dsap != 0)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != LLCP_CLOSED) {\n\t\tret = -EBADFD;\n\t\tgoto error;\n\t}\n\n\tdev = nfc_get_device(llcp_addr.dev_idx);\n\tif (dev == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto put_dev;\n\t}\n\n\tllcp_sock->dev = dev;\n\tllcp_sock->local = nfc_llcp_local_get(local);\n\tllcp_sock->nfc_protocol = llcp_addr.nfc_protocol;\n\tllcp_sock->service_name_len = min_t(unsigned int,\n\t\t\t\t\t    llcp_addr.service_name_len,\n\t\t\t\t\t    NFC_LLCP_MAX_SERVICE_NAME);\n\tllcp_sock->service_name = kmemdup(llcp_addr.service_name,\n\t\t\t\t\t  llcp_sock->service_name_len,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!llcp_sock->service_name) {\n\t\tnfc_llcp_local_put(llcp_sock->local);\n\t\tllcp_sock->local = NULL;\n\t\tllcp_sock->dev = NULL;\n\t\tret = -ENOMEM;\n\t\tgoto put_dev;\n\t}\n\tllcp_sock->ssap = nfc_llcp_get_sdp_ssap(local, llcp_sock);\n\tif (llcp_sock->ssap == LLCP_SAP_MAX) {\n\t\tnfc_llcp_local_put(llcp_sock->local);\n\t\tllcp_sock->local = NULL;\n\t\tkfree(llcp_sock->service_name);\n\t\tllcp_sock->service_name = NULL;\n\t\tllcp_sock->dev = NULL;\n\t\tret = -EADDRINUSE;\n\t\tgoto put_dev;\n\t}\n\n\tllcp_sock->reserved_ssap = llcp_sock->ssap;\n\n\tnfc_llcp_sock_link(&local->sockets, sk);\n\n\tpr_debug(\"Socket bound to SAP %d\\n\", llcp_sock->ssap);\n\n\tsk->sk_state = LLCP_BOUND;\n\nput_dev:\n\tnfc_put_device(dev);\n\nerror:\n\trelease_sock(sk);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 795,
    "critical_vars": [
      "len"
    ],
    "function": "skcipher_accept_parent",
    "filename": "linux/CVE-2015-8970/CVE-2015-8970_CWE-476_dd504589577d8e8e70f51f997ad487a4cb6c026f_algif_skcipher.c.diff",
    "function_code": "static int skcipher_accept_parent(void *private, struct sock *sk)\n{\n\tstruct skcipher_ctx *ctx;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tunsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(private);\n\n\tctx = sock_kmalloc(sk, len, GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(private),\n\t\t\t       GFP_KERNEL);\n\tif (!ctx->iv) {\n\t\tsock_kfree_s(sk, ctx, len);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(ctx->iv, 0, crypto_skcipher_ivsize(private));\n\n\tINIT_LIST_HEAD(&ctx->tsgl);\n\tctx->len = len;\n\tctx->used = 0;\n\tctx->more = 0;\n\tctx->merge = 0;\n\tctx->enc = 0;\n\tatomic_set(&ctx->inflight, 0);\n\taf_alg_init_completion(&ctx->completion);\n\n\task->private = ctx;\n\n\tskcipher_request_set_tfm(&ctx->req, private);\n\tskcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t      af_alg_complete, &ctx->completion);\n\n\tsk->sk_destruct = skcipher_sock_destruct;\n\n\treturn 0;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 824,
    "critical_vars": [
      "*tfm"
    ],
    "function": "skcipher_accept_parent",
    "filename": "linux/CVE-2015-8970/CVE-2015-8970_CWE-476_dd504589577d8e8e70f51f997ad487a4cb6c026f_algif_skcipher.c.diff",
    "function_code": "static int skcipher_accept_parent(void *private, struct sock *sk)\n{\n\tstruct skcipher_ctx *ctx;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_tfm *tfm = private;\n\tstruct crypto_skcipher *skcipher = tfm->skcipher;\n\tunsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(skcipher);\n\n\tif (!tfm->has_key)\n\t\treturn -ENOKEY;\n\n\tctx = sock_kmalloc(sk, len, GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(skcipher),\n\t\t\t       GFP_KERNEL);\n\tif (!ctx->iv) {\n\t\tsock_kfree_s(sk, ctx, len);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(ctx->iv, 0, crypto_skcipher_ivsize(skcipher));\n\n\tINIT_LIST_HEAD(&ctx->tsgl);\n\tctx->len = len;\n\tctx->used = 0;\n\tctx->more = 0;\n\tctx->merge = 0;\n\tctx->enc = 0;\n\tatomic_set(&ctx->inflight, 0);\n\taf_alg_init_completion(&ctx->completion);\n\n\task->private = ctx;\n\n\tskcipher_request_set_tfm(&ctx->req, skcipher);\n\tskcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t      af_alg_complete, &ctx->completion);\n\n\tsk->sk_destruct = skcipher_sock_destruct;\n\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 547,
    "critical_vars": [
      "serial->num_interrupt_in",
      "serial->num_bulk_in"
    ],
    "function": "treo_attach",
    "filename": "linux/CVE-2016-2782/CVE-2016-2782_CWE-476_cac9b50b0d75a1d50d6c056ff65c005f3224c8e0_visor.c.diff",
    "function_code": "static int treo_attach(struct usb_serial *serial)\n{\n\tstruct usb_serial_port *swap_port;\n\n\t/* Only do this endpoint hack for the Handspring devices with\n\t * interrupt in endpoints, which for now are the Treo devices. */\n\tif (!((le16_to_cpu(serial->dev->descriptor.idVendor)\n\t\t\t\t\t\t== HANDSPRING_VENDOR_ID) ||\n\t\t(le16_to_cpu(serial->dev->descriptor.idVendor)\n\t\t\t\t\t\t== KYOCERA_VENDOR_ID)) ||\n\t\t(serial->num_interrupt_in == 0))\n\t\treturn 0;\n\n\tif (serial->num_bulk_in < 2 || serial->num_interrupt_in < 2) {\n\t\tdev_err(&serial->interface->dev, \"missing endpoints\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t/*\n\t* It appears that Treos and Kyoceras want to use the\n\t* 1st bulk in endpoint to communicate with the 2nd bulk out endpoint,\n\t* so let's swap the 1st and 2nd bulk in and interrupt endpoints.\n\t* Note that swapping the bulk out endpoints would break lots of\n\t* apps that want to communicate on the second port.\n\t*/\n#define COPY_PORT(dest, src)\t\t\t\t\t\t\\\n\tdo { \\\n\t\tint i;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tfor (i = 0; i < ARRAY_SIZE(src->read_urbs); ++i) {\t\\\n\t\t\tdest->read_urbs[i] = src->read_urbs[i];\t\t\\\n\t\t\tdest->read_urbs[i]->context = dest;\t\t\\\n\t\t\tdest->bulk_in_buffers[i] = src->bulk_in_buffers[i]; \\\n\t\t}\t\t\t\t\t\t\t\\\n\t\tdest->read_urb = src->read_urb;\t\t\t\t\\\n\t\tdest->bulk_in_endpointAddress = src->bulk_in_endpointAddress;\\\n\t\tdest->bulk_in_buffer = src->bulk_in_buffer;\t\t\\\n\t\tdest->bulk_in_size = src->bulk_in_size;\t\t\t\\\n\t\tdest->interrupt_in_urb = src->interrupt_in_urb;\t\t\\\n\t\tdest->interrupt_in_urb->context = dest;\t\t\t\\\n\t\tdest->interrupt_in_endpointAddress = \\\n\t\t\t\t\tsrc->interrupt_in_endpointAddress;\\\n\t\tdest->interrupt_in_buffer = src->interrupt_in_buffer;\t\\\n\t} while (0);\n\n\tswap_port = kmalloc(sizeof(*swap_port), GFP_KERNEL);\n\tif (!swap_port)\n\t\treturn -ENOMEM;\n\tCOPY_PORT(swap_port, serial->port[0]);\n\tCOPY_PORT(serial->port[0], serial->port[1]);\n\tCOPY_PORT(serial->port[1], swap_port);\n\tkfree(swap_port);\n\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 439,
    "critical_vars": [
      "&i8042_lock"
    ],
    "function": "i8042_start",
    "filename": "linux/CVE-2017-18079/CVE-2017-18079_CWE-476_340d394a789518018f834ff70f7534fc463d3226_i8042.c.diff",
    "function_code": "static int i8042_start(struct serio *serio)\n{\n\tstruct i8042_port *port = serio->port_data;\n\n\tspin_lock_irq(&i8042_lock);\n\tport->exists = true;\n\tspin_unlock_irq(&i8042_lock);\n\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 455,
    "critical_vars": [
      "&i8042_lock"
    ],
    "function": "i8042_stop",
    "filename": "linux/CVE-2017-18079/CVE-2017-18079_CWE-476_340d394a789518018f834ff70f7534fc463d3226_i8042.c.diff",
    "function_code": "static void i8042_stop(struct serio *serio)\n{\n\tstruct i8042_port *port = serio->port_data;\n\n\tspin_lock_irq(&i8042_lock);\n\tport->exists = false;\n\tport->serio = NULL;\n\tspin_unlock_irq(&i8042_lock);\n\n\t/*\n\t * We need to make sure that interrupt handler finishes using\n\t * our serio port before we return from this function.\n\t * We synchronize with both AUX and KBD IRQs because there is\n\t * a (very unlikely) chance that AUX IRQ is raised for KBD port\n\t * and vice versa.\n\t */\n\tsynchronize_irq(I8042_AUX_IRQ);\n\tsynchronize_irq(I8042_KBD_IRQ);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 462,
    "critical_vars": [
      "port->serio"
    ],
    "function": "i8042_stop",
    "filename": "linux/CVE-2017-18079/CVE-2017-18079_CWE-476_340d394a789518018f834ff70f7534fc463d3226_i8042.c.diff",
    "function_code": "static void i8042_stop(struct serio *serio)\n{\n\tstruct i8042_port *port = serio->port_data;\n\n\tport->exists = false;\n\n\t/*\n\t * We synchronize with both AUX and KBD IRQs because there is\n\t * a (very unlikely) chance that AUX IRQ is raised for KBD port\n\t * and vice versa.\n\t */\n\tsynchronize_irq(I8042_AUX_IRQ);\n\tsynchronize_irq(I8042_KBD_IRQ);\n\tport->serio = NULL;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 579,
    "critical_vars": [
      "port->exists"
    ],
    "function": "i8042_interrupt",
    "filename": "linux/CVE-2017-18079/CVE-2017-18079_CWE-476_340d394a789518018f834ff70f7534fc463d3226_i8042.c.diff",
    "function_code": "static irqreturn_t i8042_interrupt(int irq, void *dev_id)\n{\n\tstruct i8042_port *port;\n\tstruct serio *serio;\n\tunsigned long flags;\n\tunsigned char str, data;\n\tunsigned int dfl;\n\tunsigned int port_no;\n\tbool filtered;\n\tint ret = 1;\n\n\tspin_lock_irqsave(&i8042_lock, flags);\n\n\tstr = i8042_read_status();\n\tif (unlikely(~str & I8042_STR_OBF)) {\n\t\tspin_unlock_irqrestore(&i8042_lock, flags);\n\t\tif (irq)\n\t\t\tdbg(\"Interrupt %d, without any data\\n\", irq);\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tdata = i8042_read_data();\n\n\tif (i8042_mux_present && (str & I8042_STR_AUXDATA)) {\n\t\tstatic unsigned long last_transmit;\n\t\tstatic unsigned char last_str;\n\n\t\tdfl = 0;\n\t\tif (str & I8042_STR_MUXERR) {\n\t\t\tdbg(\"MUX error, status is %02x, data is %02x\\n\",\n\t\t\t    str, data);\n/*\n * When MUXERR condition is signalled the data register can only contain\n * 0xfd, 0xfe or 0xff if implementation follows the spec. Unfortunately\n * it is not always the case. Some KBCs also report 0xfc when there is\n * nothing connected to the port while others sometimes get confused which\n * port the data came from and signal error leaving the data intact. They\n * _do not_ revert to legacy mode (actually I've never seen KBC reverting\n * to legacy mode yet, when we see one we'll add proper handling).\n * Anyway, we process 0xfc, 0xfd, 0xfe and 0xff as timeouts, and for the\n * rest assume that the data came from the same serio last byte\n * was transmitted (if transmission happened not too long ago).\n */\n\n\t\t\tswitch (data) {\n\t\t\t\tdefault:\n\t\t\t\t\tif (time_before(jiffies, last_transmit + HZ/10)) {\n\t\t\t\t\t\tstr = last_str;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t/* fall through - report timeout */\n\t\t\t\tcase 0xfc:\n\t\t\t\tcase 0xfd:\n\t\t\t\tcase 0xfe: dfl = SERIO_TIMEOUT; data = 0xfe; break;\n\t\t\t\tcase 0xff: dfl = SERIO_PARITY;  data = 0xfe; break;\n\t\t\t}\n\t\t}\n\n\t\tport_no = I8042_MUX_PORT_NO + ((str >> 6) & 3);\n\t\tlast_str = str;\n\t\tlast_transmit = jiffies;\n\t} else {\n\n\t\tdfl = ((str & I8042_STR_PARITY) ? SERIO_PARITY : 0) |\n\t\t      ((str & I8042_STR_TIMEOUT && !i8042_notimeout) ? SERIO_TIMEOUT : 0);\n\n\t\tport_no = (str & I8042_STR_AUXDATA) ?\n\t\t\t\tI8042_AUX_PORT_NO : I8042_KBD_PORT_NO;\n\t}\n\n\tport = &i8042_ports[port_no];\n\tserio = port->exists ? port->serio : NULL;\n\n\tfilter_dbg(port->driver_bound, data, \"<- i8042 (interrupt, %d, %d%s%s)\\n\",\n\t\t   port_no, irq,\n\t\t   dfl & SERIO_PARITY ? \", bad parity\" : \"\",\n\t\t   dfl & SERIO_TIMEOUT ? \", timeout\" : \"\");\n\n\tfiltered = i8042_filter(data, str, serio);\n\n\tspin_unlock_irqrestore(&i8042_lock, flags);\n\n\tif (likely(port->exists && !filtered))\n\t\tserio_interrupt(serio, data, dfl);\n\n out:\n\treturn IRQ_RETVAL(ret);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 2257,
    "critical_vars": [
      "ppmu"
    ],
    "function": "perf_instruction_pointer",
    "filename": "linux/CVE-2021-38200/CVE-2021-38200_CWE-476_60b7ed54a41b550d50caf7f2418db4a7e75b5bdc_core-book3s.c.diff",
    "function_code": "unsigned long perf_instruction_pointer(struct pt_regs *regs)\n{\n\tbool use_siar = regs_use_siar(regs);\n\tunsigned long siar = mfspr(SPRN_SIAR);\n\n\tif (ppmu && (ppmu->flags & PPMU_P10_DD1)) {\n\t\tif (siar)\n\t\t\treturn siar;\n\t\telse\n\t\t\treturn regs->nip;\n\t} else if (use_siar && siar_valid(regs))\n\t\treturn mfspr(SPRN_SIAR) + perf_ip_adjust(regs);\n\telse if (use_siar)\n\t\treturn 0;\t\t// no valid instruction pointer\n\telse\n\t\treturn regs->nip;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 899,
    "critical_vars": [
      "walk",
      "net"
    ],
    "function": "xfrm_dump_sa_done",
    "filename": "linux/CVE-2023-3106/CVE-2023-3106_CWE-476_1ba5bf993c6a3142e18e68ea6452b347f9cb5635_xfrm_user.c.diff",
    "function_code": "static int xfrm_dump_sa_done(struct netlink_callback *cb)\n{\n\tstruct xfrm_state_walk *walk = (struct xfrm_state_walk *) &cb->args[1];\n\tstruct sock *sk = cb->skb->sk;\n\tstruct net *net = sock_net(sk);\n\n\txfrm_state_walk_done(walk, net);\n\treturn 0;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 899,
    "critical_vars": [
      "cb->args[0]"
    ],
    "function": "xfrm_dump_sa_done",
    "filename": "linux/CVE-2023-3106/CVE-2023-3106_CWE-476_1ba5bf993c6a3142e18e68ea6452b347f9cb5635_xfrm_user.c.diff",
    "function_code": "static int xfrm_dump_sa_done(struct netlink_callback *cb)\n{\n\tstruct xfrm_state_walk *walk = (struct xfrm_state_walk *) &cb->args[1];\n\tstruct sock *sk = cb->skb->sk;\n\tstruct net *net = sock_net(sk);\n\n\tif (cb->args[0])\n\t\txfrm_state_walk_done(walk, net);\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 924,
    "critical_vars": [
      "cb->args[0]"
    ],
    "function": "xfrm_dump_sa",
    "filename": "linux/CVE-2023-3106/CVE-2023-3106_CWE-476_1ba5bf993c6a3142e18e68ea6452b347f9cb5635_xfrm_user.c.diff",
    "function_code": "static int xfrm_dump_sa(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_state_walk *walk = (struct xfrm_state_walk *) &cb->args[1];\n\tstruct xfrm_dump_info info;\n\n\tBUILD_BUG_ON(sizeof(struct xfrm_state_walk) >\n\t\t     sizeof(cb->args) - sizeof(cb->args[0]));\n\n\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\n\tif (!cb->args[0]) {\n\t\tstruct nlattr *attrs[XFRMA_MAX+1];\n\t\tstruct xfrm_address_filter *filter = NULL;\n\t\tu8 proto = 0;\n\t\tint err;\n\n\t\tcb->args[0] = 1;\n\n\t\terr = nlmsg_parse(cb->nlh, 0, attrs, XFRMA_MAX,\n\t\t\t\t  xfrma_policy);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (attrs[XFRMA_ADDRESS_FILTER]) {\n\t\t\tfilter = kmemdup(nla_data(attrs[XFRMA_ADDRESS_FILTER]),\n\t\t\t\t\t sizeof(*filter), GFP_KERNEL);\n\t\t\tif (filter == NULL)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (attrs[XFRMA_PROTO])\n\t\t\tproto = nla_get_u8(attrs[XFRMA_PROTO]);\n\n\t\txfrm_state_walk_init(walk, proto, filter);\n\t}\n\n\t(void) xfrm_state_walk(net, walk, dump_one_state, &info);\n\n\treturn skb->len;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 941,
    "critical_vars": [
      "cb->args[0]"
    ],
    "function": "xfrm_dump_sa",
    "filename": "linux/CVE-2023-3106/CVE-2023-3106_CWE-476_1ba5bf993c6a3142e18e68ea6452b347f9cb5635_xfrm_user.c.diff",
    "function_code": "static int xfrm_dump_sa(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_state_walk *walk = (struct xfrm_state_walk *) &cb->args[1];\n\tstruct xfrm_dump_info info;\n\n\tBUILD_BUG_ON(sizeof(struct xfrm_state_walk) >\n\t\t     sizeof(cb->args) - sizeof(cb->args[0]));\n\n\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\n\tif (!cb->args[0]) {\n\t\tstruct nlattr *attrs[XFRMA_MAX+1];\n\t\tstruct xfrm_address_filter *filter = NULL;\n\t\tu8 proto = 0;\n\t\tint err;\n\n\t\terr = nlmsg_parse(cb->nlh, 0, attrs, XFRMA_MAX,\n\t\t\t\t  xfrma_policy);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (attrs[XFRMA_ADDRESS_FILTER]) {\n\t\t\tfilter = kmemdup(nla_data(attrs[XFRMA_ADDRESS_FILTER]),\n\t\t\t\t\t sizeof(*filter), GFP_KERNEL);\n\t\t\tif (filter == NULL)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (attrs[XFRMA_PROTO])\n\t\t\tproto = nla_get_u8(attrs[XFRMA_PROTO]);\n\n\t\txfrm_state_walk_init(walk, proto, filter);\n\t\tcb->args[0] = 1;\n\t}\n\n\t(void) xfrm_state_walk(net, walk, dump_one_state, &info);\n\n\treturn skb->len;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 546,
    "critical_vars": [
      "version_tlv"
    ],
    "function": "nfc_llcp_build_gb",
    "filename": "linux/CVE-2019-12818/CVE-2019-12818_CWE-476_58bdd544e2933a21a51eecf17c3f5f94038261b5_llcp_core.c.diff",
    "function_code": "static int nfc_llcp_build_gb(struct nfc_llcp_local *local)\n{\n\tu8 *gb_cur, version, version_length;\n\tu8 lto_length, wks_length, miux_length;\n\tu8 *version_tlv = NULL, *lto_tlv = NULL,\n\t   *wks_tlv = NULL, *miux_tlv = NULL;\n\t__be16 wks = cpu_to_be16(local->local_wks);\n\tu8 gb_len = 0;\n\tint ret = 0;\n\n\tversion = LLCP_VERSION_11;\n\tversion_tlv = nfc_llcp_build_tlv(LLCP_TLV_VERSION, &version,\n\t\t\t\t\t 1, &version_length);\n\tif (!version_tlv) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tgb_len += version_length;\n\n\tlto_tlv = nfc_llcp_build_tlv(LLCP_TLV_LTO, &local->lto, 1, &lto_length);\n\tif (!lto_tlv) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tgb_len += lto_length;\n\n\tpr_debug(\"Local wks 0x%lx\\n\", local->local_wks);\n\twks_tlv = nfc_llcp_build_tlv(LLCP_TLV_WKS, (u8 *)&wks, 2, &wks_length);\n\tif (!wks_tlv) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tgb_len += wks_length;\n\n\tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&local->miux, 0,\n\t\t\t\t      &miux_length);\n\tif (!miux_tlv) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tgb_len += miux_length;\n\n\tgb_len += ARRAY_SIZE(llcp_magic);\n\n\tif (gb_len > NFC_MAX_GT_LEN) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tgb_cur = local->gb;\n\n\tmemcpy(gb_cur, llcp_magic, ARRAY_SIZE(llcp_magic));\n\tgb_cur += ARRAY_SIZE(llcp_magic);\n\n\tmemcpy(gb_cur, version_tlv, version_length);\n\tgb_cur += version_length;\n\n\tmemcpy(gb_cur, lto_tlv, lto_length);\n\tgb_cur += lto_length;\n\n\tmemcpy(gb_cur, wks_tlv, wks_length);\n\tgb_cur += wks_length;\n\n\tmemcpy(gb_cur, miux_tlv, miux_length);\n\tgb_cur += miux_length;\n\n\tlocal->gb_len = gb_len;\n\nout:\n\tkfree(version_tlv);\n\tkfree(lto_tlv);\n\tkfree(wks_tlv);\n\tkfree(miux_tlv);\n\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 422,
    "critical_vars": [
      "service_name_tlv"
    ],
    "function": "nfc_llcp_send_connect",
    "filename": "linux/CVE-2019-12818/CVE-2019-12818_CWE-476_58bdd544e2933a21a51eecf17c3f5f94038261b5_llcp_commands.c.diff",
    "function_code": "int nfc_llcp_send_connect(struct nfc_llcp_sock *sock)\n{\n\tstruct nfc_llcp_local *local;\n\tstruct sk_buff *skb;\n\tu8 *service_name_tlv = NULL, service_name_tlv_length;\n\tu8 *miux_tlv = NULL, miux_tlv_length;\n\tu8 *rw_tlv = NULL, rw_tlv_length, rw;\n\tint err;\n\tu16 size = 0;\n\t__be16 miux;\n\n\tpr_debug(\"Sending CONNECT\\n\");\n\n\tlocal = sock->local;\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\tif (sock->service_name != NULL) {\n\t\tservice_name_tlv = nfc_llcp_build_tlv(LLCP_TLV_SN,\n\t\t\t\t\t\t      sock->service_name,\n\t\t\t\t\t\t      sock->service_name_len,\n\t\t\t\t\t\t      &service_name_tlv_length);\n\t\tif (!service_name_tlv) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto error_tlv;\n\t\t}\n\t\tsize += service_name_tlv_length;\n\t}\n\n\t/* If the socket parameters are not set, use the local ones */\n\tmiux = be16_to_cpu(sock->miux) > LLCP_MAX_MIUX ?\n\t\tlocal->miux : sock->miux;\n\trw = sock->rw > LLCP_MAX_RW ? local->rw : sock->rw;\n\n\tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,\n\t\t\t\t      &miux_tlv_length);\n\tif (!miux_tlv) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\tsize += miux_tlv_length;\n\n\trw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);\n\tif (!rw_tlv) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\tsize += rw_tlv_length;\n\n\tpr_debug(\"SKB size %d SN length %zu\\n\", size, sock->service_name_len);\n\n\tskb = llcp_allocate_pdu(sock, LLCP_PDU_CONNECT, size);\n\tif (skb == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\n\tllcp_add_tlv(skb, service_name_tlv, service_name_tlv_length);\n\tllcp_add_tlv(skb, miux_tlv, miux_tlv_length);\n\tllcp_add_tlv(skb, rw_tlv, rw_tlv_length);\n\n\tskb_queue_tail(&local->tx_queue, skb);\n\n\terr = 0;\n\nerror_tlv:\n\tif (err)\n\t\tpr_err(\"error %d\\n\", err);\n\n\tkfree(service_name_tlv);\n\tkfree(miux_tlv);\n\tkfree(rw_tlv);\n\n\treturn err;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 499,
    "critical_vars": [
      "miux_tlv"
    ],
    "function": "nfc_llcp_send_cc",
    "filename": "linux/CVE-2019-12818/CVE-2019-12818_CWE-476_58bdd544e2933a21a51eecf17c3f5f94038261b5_llcp_commands.c.diff",
    "function_code": "int nfc_llcp_send_cc(struct nfc_llcp_sock *sock)\n{\n\tstruct nfc_llcp_local *local;\n\tstruct sk_buff *skb;\n\tu8 *miux_tlv = NULL, miux_tlv_length;\n\tu8 *rw_tlv = NULL, rw_tlv_length, rw;\n\tint err;\n\tu16 size = 0;\n\t__be16 miux;\n\n\tpr_debug(\"Sending CC\\n\");\n\n\tlocal = sock->local;\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\t/* If the socket parameters are not set, use the local ones */\n\tmiux = be16_to_cpu(sock->miux) > LLCP_MAX_MIUX ?\n\t\tlocal->miux : sock->miux;\n\trw = sock->rw > LLCP_MAX_RW ? local->rw : sock->rw;\n\n\tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,\n\t\t\t\t      &miux_tlv_length);\n\tif (!miux_tlv) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\tsize += miux_tlv_length;\n\n\trw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);\n\tif (!rw_tlv) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\tsize += rw_tlv_length;\n\n\tskb = llcp_allocate_pdu(sock, LLCP_PDU_CC, size);\n\tif (skb == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\n\tllcp_add_tlv(skb, miux_tlv, miux_tlv_length);\n\tllcp_add_tlv(skb, rw_tlv, rw_tlv_length);\n\n\tskb_queue_tail(&local->tx_queue, skb);\n\n\terr = 0;\n\nerror_tlv:\n\tif (err)\n\t\tpr_err(\"error %d\\n\", err);\n\n\tkfree(miux_tlv);\n\tkfree(rw_tlv);\n\n\treturn err;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 2429,
    "critical_vars": [
      "error"
    ],
    "function": "expand_downwards",
    "filename": "linux/CVE-2019-9213/CVE-2019-9213_CWE-476_0a1d52994d440e21def1c2174932410b4f2a98a1_mmap.c.diff",
    "function_code": "int expand_downwards(struct vm_area_struct *vma,\n\t\t\t\t   unsigned long address)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct vm_area_struct *prev;\n\tint error;\n\n\taddress &= PAGE_MASK;\n\terror = security_mmap_addr(address);\n\tif (error)\n\t\treturn error;\n\n\t/* Enforce stack_guard_gap */\n\tprev = vma->vm_prev;\n\t/* Check that both stack segments have the same anon_vma? */\n\tif (prev && !(prev->vm_flags & VM_GROWSDOWN) &&\n\t\t\t(prev->vm_flags & (VM_WRITE|VM_READ|VM_EXEC))) {\n\t\tif (address - prev->vm_end < stack_guard_gap)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* We must make sure the anon_vma is allocated. */\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\treturn -ENOMEM;\n\n\t/*\n\t * vma->vm_start/vm_end cannot change under us because the caller\n\t * is required to hold the mmap_sem in read mode.  We need the\n\t * anon_vma lock to serialize against concurrent expand_stacks.\n\t */\n\tanon_vma_lock_write(vma->anon_vma);\n\n\t/* Somebody else might have raced and expanded it already */\n\tif (address < vma->vm_start) {\n\t\tunsigned long size, grow;\n\n\t\tsize = vma->vm_end - address;\n\t\tgrow = (vma->vm_start - address) >> PAGE_SHIFT;\n\n\t\terror = -ENOMEM;\n\t\tif (grow <= vma->vm_pgoff) {\n\t\t\terror = acct_stack_growth(vma, size, grow);\n\t\t\tif (!error) {\n\t\t\t\t/*\n\t\t\t\t * vma_gap_update() doesn't support concurrent\n\t\t\t\t * updates, but we only hold a shared mmap_sem\n\t\t\t\t * lock here, so we need to protect against\n\t\t\t\t * concurrent vma expansions.\n\t\t\t\t * anon_vma_lock_write() doesn't help here, as\n\t\t\t\t * we don't guarantee that all growable vmas\n\t\t\t\t * in a mm share the same root anon vma.\n\t\t\t\t * So, we reuse mm->page_table_lock to guard\n\t\t\t\t * against concurrent vma expansions.\n\t\t\t\t */\n\t\t\t\tspin_lock(&mm->page_table_lock);\n\t\t\t\tif (vma->vm_flags & VM_LOCKED)\n\t\t\t\t\tmm->locked_vm += grow;\n\t\t\t\tvm_stat_account(mm, vma->vm_flags, grow);\n\t\t\t\tanon_vma_interval_tree_pre_update_vma(vma);\n\t\t\t\tvma->vm_start = address;\n\t\t\t\tvma->vm_pgoff -= grow;\n\t\t\t\tanon_vma_interval_tree_post_update_vma(vma);\n\t\t\t\tvma_gap_update(vma);\n\t\t\t\tspin_unlock(&mm->page_table_lock);\n\n\t\t\t\tperf_event_mmap(vma);\n\t\t\t}\n\t\t}\n\t}\n\tanon_vma_unlock_write(vma->anon_vma);\n\tkhugepaged_enter_vma_merge(vma, vma->vm_flags);\n\tvalidate_mm(mm);\n\treturn error;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 2429,
    "critical_vars": [
      "error"
    ],
    "function": "expand_downwards",
    "filename": "linux/CVE-2019-9213/CVE-2019-9213_CWE-476_0a1d52994d440e21def1c2174932410b4f2a98a1_mmap.c.diff",
    "function_code": "int expand_downwards(struct vm_area_struct *vma,\n\t\t\t\t   unsigned long address)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct vm_area_struct *prev;\n\tint error = 0;\n\n\taddress &= PAGE_MASK;\n\tif (address < mmap_min_addr)\n\t\treturn -EPERM;\n\n\t/* Enforce stack_guard_gap */\n\tprev = vma->vm_prev;\n\t/* Check that both stack segments have the same anon_vma? */\n\tif (prev && !(prev->vm_flags & VM_GROWSDOWN) &&\n\t\t\t(prev->vm_flags & (VM_WRITE|VM_READ|VM_EXEC))) {\n\t\tif (address - prev->vm_end < stack_guard_gap)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* We must make sure the anon_vma is allocated. */\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\treturn -ENOMEM;\n\n\t/*\n\t * vma->vm_start/vm_end cannot change under us because the caller\n\t * is required to hold the mmap_sem in read mode.  We need the\n\t * anon_vma lock to serialize against concurrent expand_stacks.\n\t */\n\tanon_vma_lock_write(vma->anon_vma);\n\n\t/* Somebody else might have raced and expanded it already */\n\tif (address < vma->vm_start) {\n\t\tunsigned long size, grow;\n\n\t\tsize = vma->vm_end - address;\n\t\tgrow = (vma->vm_start - address) >> PAGE_SHIFT;\n\n\t\terror = -ENOMEM;\n\t\tif (grow <= vma->vm_pgoff) {\n\t\t\terror = acct_stack_growth(vma, size, grow);\n\t\t\tif (!error) {\n\t\t\t\t/*\n\t\t\t\t * vma_gap_update() doesn't support concurrent\n\t\t\t\t * updates, but we only hold a shared mmap_sem\n\t\t\t\t * lock here, so we need to protect against\n\t\t\t\t * concurrent vma expansions.\n\t\t\t\t * anon_vma_lock_write() doesn't help here, as\n\t\t\t\t * we don't guarantee that all growable vmas\n\t\t\t\t * in a mm share the same root anon vma.\n\t\t\t\t * So, we reuse mm->page_table_lock to guard\n\t\t\t\t * against concurrent vma expansions.\n\t\t\t\t */\n\t\t\t\tspin_lock(&mm->page_table_lock);\n\t\t\t\tif (vma->vm_flags & VM_LOCKED)\n\t\t\t\t\tmm->locked_vm += grow;\n\t\t\t\tvm_stat_account(mm, vma->vm_flags, grow);\n\t\t\t\tanon_vma_interval_tree_pre_update_vma(vma);\n\t\t\t\tvma->vm_start = address;\n\t\t\t\tvma->vm_pgoff -= grow;\n\t\t\t\tanon_vma_interval_tree_post_update_vma(vma);\n\t\t\t\tvma_gap_update(vma);\n\t\t\t\tspin_unlock(&mm->page_table_lock);\n\n\t\t\t\tperf_event_mmap(vma);\n\t\t\t}\n\t\t}\n\t}\n\tanon_vma_unlock_write(vma->anon_vma);\n\tkhugepaged_enter_vma_merge(vma, vma->vm_flags);\n\tvalidate_mm(mm);\n\treturn error;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 33,
    "critical_vars": [
      "bu"
    ],
    "function": "*imcb_file_send_start",
    "filename": "bitlbee/CVE-2016-10189/CVE-2016-10189_CWE-476_701ab8129ba9ea64f569daedca9a8603abad740f_bee_ft.c.diff",
    "function_code": "file_transfer_t *imcb_file_send_start(struct im_connection *ic, char *handle, char *file_name, size_t file_size)\n{\n\tbee_t *bee = ic->bee;\n\tbee_user_t *bu = bee_user_by_handle(bee, ic, handle);\n\n\tif (bee->ui->ft_in_start && bu) {\n\t\treturn bee->ui->ft_in_start(bee, bu, file_name, file_size);\n\t} else {\n\t\treturn NULL;\n\t}\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 149,
    "critical_vars": [
      "px->ft"
    ],
    "function": "prplcb_xfer_new_send_cb",
    "filename": "bitlbee/CVE-2017-5668/CVE-2017-5668_CWE-476_30d598ce7cd3f136ee9d7097f39fa9818a272441_ft.c.diff",
    "function_code": "static gboolean prplcb_xfer_new_send_cb(gpointer data, gint fd, b_input_condition cond)\n{\n\tPurpleXfer *xfer = data;\n\tstruct im_connection *ic = purple_ic_by_pa(xfer->account);\n\tstruct prpl_xfer_data *px = xfer->ui_data;\n\tPurpleBuddy *buddy;\n\tconst char *who;\n\n\tbuddy = purple_find_buddy(xfer->account, xfer->who);\n\twho = buddy ? purple_buddy_get_name(buddy) : xfer->who;\n\n\t/* TODO(wilmer): After spreading some more const goodness in BitlBee,\n\t   remove the evil cast below. */\n\tpx->ft = imcb_file_send_start(ic, (char *) who, xfer->filename, xfer->size);\n\n\tif (!px->ft) {\n\t\treturn FALSE;\n\t}\n\tpx->ft->data = px;\n\n\tpx->ft->accept = prpl_xfer_accept;\n\tpx->ft->canceled = prpl_xfer_canceled;\n\tpx->ft->free = prpl_xfer_free;\n\tpx->ft->write_request = prpl_xfer_write_request;\n\n\treturn FALSE;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "for-Condition",
    "line_old": 547,
    "line_new": 547,
    "critical_vars": [
      "i"
    ],
    "function": "TIFFPrintDirectory",
    "filename": "visit_repo_url/CVE-2018-7456/CVE-2018-7456_CWE-476_be4c85b16e8801a16eec25e80eb9f3dd6a96731b_tif_print.c.diff",
    "function_code": "TIFFPrintDirectory(TIFF* tif, FILE* fd, long flags)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\tchar *sep;\n\tlong l, n;\n\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\tfprintf(fd, \"TIFF Directory at offset 0x%I64x (%I64u)\\n\",\n\t\t(unsigned __int64) tif->tif_diroff,\n\t\t(unsigned __int64) tif->tif_diroff);\n#else\n\tfprintf(fd, \"TIFF Directory at offset 0x%llx (%llu)\\n\",\n\t\t(unsigned long long) tif->tif_diroff,\n\t\t(unsigned long long) tif->tif_diroff);\n#endif\n\tif (TIFFFieldSet(tif,FIELD_SUBFILETYPE)) {\n\t\tfprintf(fd, \"  Subfile Type:\");\n\t\tsep = \" \";\n\t\tif (td->td_subfiletype & FILETYPE_REDUCEDIMAGE) {\n\t\t\tfprintf(fd, \"%sreduced-resolution image\", sep);\n\t\t\tsep = \"/\";\n\t\t}\n\t\tif (td->td_subfiletype & FILETYPE_PAGE) {\n\t\t\tfprintf(fd, \"%smulti-page document\", sep);\n\t\t\tsep = \"/\";\n\t\t}\n\t\tif (td->td_subfiletype & FILETYPE_MASK)\n\t\t\tfprintf(fd, \"%stransparency mask\", sep);\n\t\tfprintf(fd, \" (%lu = 0x%lx)\\n\",\n\t\t    (unsigned long) td->td_subfiletype, (long) td->td_subfiletype);\n\t}\n\tif (TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS)) {\n\t\tfprintf(fd, \"  Image Width: %lu Image Length: %lu\",\n\t\t    (unsigned long) td->td_imagewidth, (unsigned long) td->td_imagelength);\n\t\tif (TIFFFieldSet(tif,FIELD_IMAGEDEPTH))\n\t\t\tfprintf(fd, \" Image Depth: %lu\",\n\t\t\t    (unsigned long) td->td_imagedepth);\n\t\tfprintf(fd, \"\\n\");\n\t}\n\tif (TIFFFieldSet(tif,FIELD_TILEDIMENSIONS)) {\n\t\tfprintf(fd, \"  Tile Width: %lu Tile Length: %lu\",\n\t\t    (unsigned long) td->td_tilewidth, (unsigned long) td->td_tilelength);\n\t\tif (TIFFFieldSet(tif,FIELD_TILEDEPTH))\n\t\t\tfprintf(fd, \" Tile Depth: %lu\",\n\t\t\t    (unsigned long) td->td_tiledepth);\n\t\tfprintf(fd, \"\\n\");\n\t}\n\tif (TIFFFieldSet(tif,FIELD_RESOLUTION)) {\n\t\tfprintf(fd, \"  Resolution: %g, %g\",\n\t\t    td->td_xresolution, td->td_yresolution);\n\t\tif (TIFFFieldSet(tif,FIELD_RESOLUTIONUNIT)) {\n\t\t\tswitch (td->td_resolutionunit) {\n\t\t\tcase RESUNIT_NONE:\n\t\t\t\tfprintf(fd, \" (unitless)\");\n\t\t\t\tbreak;\n\t\t\tcase RESUNIT_INCH:\n\t\t\t\tfprintf(fd, \" pixels/inch\");\n\t\t\t\tbreak;\n\t\t\tcase RESUNIT_CENTIMETER:\n\t\t\t\tfprintf(fd, \" pixels/cm\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfprintf(fd, \" (unit %u = 0x%x)\",\n\t\t\t\t    td->td_resolutionunit,\n\t\t\t\t    td->td_resolutionunit);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfprintf(fd, \"\\n\");\n\t}\n\tif (TIFFFieldSet(tif,FIELD_POSITION))\n\t\tfprintf(fd, \"  Position: %g, %g\\n\",\n\t\t    td->td_xposition, td->td_yposition);\n\tif (TIFFFieldSet(tif,FIELD_BITSPERSAMPLE))\n\t\tfprintf(fd, \"  Bits/Sample: %u\\n\", td->td_bitspersample);\n\tif (TIFFFieldSet(tif,FIELD_SAMPLEFORMAT)) {\n\t\tfprintf(fd, \"  Sample Format: \");\n\t\tswitch (td->td_sampleformat) {\n\t\tcase SAMPLEFORMAT_VOID:\n\t\t\tfprintf(fd, \"void\\n\");\n\t\t\tbreak;\n\t\tcase SAMPLEFORMAT_INT:\n\t\t\tfprintf(fd, \"signed integer\\n\");\n\t\t\tbreak;\n\t\tcase SAMPLEFORMAT_UINT:\n\t\t\tfprintf(fd, \"unsigned integer\\n\");\n\t\t\tbreak;\n\t\tcase SAMPLEFORMAT_IEEEFP:\n\t\t\tfprintf(fd, \"IEEE floating point\\n\");\n\t\t\tbreak;\n\t\tcase SAMPLEFORMAT_COMPLEXINT:\n\t\t\tfprintf(fd, \"complex signed integer\\n\");\n\t\t\tbreak;\n\t\tcase SAMPLEFORMAT_COMPLEXIEEEFP:\n\t\t\tfprintf(fd, \"complex IEEE floating point\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\n\t\t\t    td->td_sampleformat, td->td_sampleformat);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (TIFFFieldSet(tif,FIELD_COMPRESSION)) {\n\t\tconst TIFFCodec* c = TIFFFindCODEC(td->td_compression);\n\t\tfprintf(fd, \"  Compression Scheme: \");\n\t\tif (c)\n\t\t\tfprintf(fd, \"%s\\n\", c->name);\n\t\telse\n\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\n\t\t\t    td->td_compression, td->td_compression);\n\t}\n\tif (TIFFFieldSet(tif,FIELD_PHOTOMETRIC)) {\n\t\tfprintf(fd, \"  Photometric Interpretation: \");\n\t\tif (td->td_photometric < NPHOTONAMES)\n\t\t\tfprintf(fd, \"%s\\n\", photoNames[td->td_photometric]);\n\t\telse {\n\t\t\tswitch (td->td_photometric) {\n\t\t\tcase PHOTOMETRIC_LOGL:\n\t\t\t\tfprintf(fd, \"CIE Log2(L)\\n\");\n\t\t\t\tbreak;\n\t\t\tcase PHOTOMETRIC_LOGLUV:\n\t\t\t\tfprintf(fd, \"CIE Log2(L) (u',v')\\n\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\n\t\t\t\t    td->td_photometric, td->td_photometric);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (TIFFFieldSet(tif,FIELD_EXTRASAMPLES) && td->td_extrasamples) {\n\t\tuint16 i;\n\t\tfprintf(fd, \"  Extra Samples: %u<\", td->td_extrasamples);\n\t\tsep = \"\";\n\t\tfor (i = 0; i < td->td_extrasamples; i++) {\n\t\t\tswitch (td->td_sampleinfo[i]) {\n\t\t\tcase EXTRASAMPLE_UNSPECIFIED:\n\t\t\t\tfprintf(fd, \"%sunspecified\", sep);\n\t\t\t\tbreak;\n\t\t\tcase EXTRASAMPLE_ASSOCALPHA:\n\t\t\t\tfprintf(fd, \"%sassoc-alpha\", sep);\n\t\t\t\tbreak;\n\t\t\tcase EXTRASAMPLE_UNASSALPHA:\n\t\t\t\tfprintf(fd, \"%sunassoc-alpha\", sep);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfprintf(fd, \"%s%u (0x%x)\", sep,\n\t\t\t\t    td->td_sampleinfo[i], td->td_sampleinfo[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsep = \", \";\n\t\t}\n\t\tfprintf(fd, \">\\n\");\n\t}\n\tif (TIFFFieldSet(tif,FIELD_INKNAMES)) {\n\t\tchar* cp;\n\t\tuint16 i;\n\t\tfprintf(fd, \"  Ink Names: \");\n\t\ti = td->td_samplesperpixel;\n\t\tsep = \"\";\n\t\tfor (cp = td->td_inknames; \n\t\t     i > 0 && cp < td->td_inknames + td->td_inknameslen; \n\t\t     cp = strchr(cp,'\\0')+1, i--) {\n\t\t\tsize_t max_chars = \n\t\t\t\ttd->td_inknameslen - (cp - td->td_inknames);\n\t\t\tfputs(sep, fd);\n\t\t\t_TIFFprintAsciiBounded(fd, cp, max_chars);\n\t\t\tsep = \", \";\n\t\t}\n                fputs(\"\\n\", fd);\n\t}\n\tif (TIFFFieldSet(tif,FIELD_THRESHHOLDING)) {\n\t\tfprintf(fd, \"  Thresholding: \");\n\t\tswitch (td->td_threshholding) {\n\t\tcase THRESHHOLD_BILEVEL:\n\t\t\tfprintf(fd, \"bilevel art scan\\n\");\n\t\t\tbreak;\n\t\tcase THRESHHOLD_HALFTONE:\n\t\t\tfprintf(fd, \"halftone or dithered scan\\n\");\n\t\t\tbreak;\n\t\tcase THRESHHOLD_ERRORDIFFUSE:\n\t\t\tfprintf(fd, \"error diffused\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\n\t\t\t    td->td_threshholding, td->td_threshholding);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (TIFFFieldSet(tif,FIELD_FILLORDER)) {\n\t\tfprintf(fd, \"  FillOrder: \");\n\t\tswitch (td->td_fillorder) {\n\t\tcase FILLORDER_MSB2LSB:\n\t\t\tfprintf(fd, \"msb-to-lsb\\n\");\n\t\t\tbreak;\n\t\tcase FILLORDER_LSB2MSB:\n\t\t\tfprintf(fd, \"lsb-to-msb\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\n\t\t\t    td->td_fillorder, td->td_fillorder);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (TIFFFieldSet(tif,FIELD_YCBCRSUBSAMPLING))\n        {\n\t\tfprintf(fd, \"  YCbCr Subsampling: %u, %u\\n\",\n\t\t\ttd->td_ycbcrsubsampling[0], td->td_ycbcrsubsampling[1] );\n\t}\n\tif (TIFFFieldSet(tif,FIELD_YCBCRPOSITIONING)) {\n\t\tfprintf(fd, \"  YCbCr Positioning: \");\n\t\tswitch (td->td_ycbcrpositioning) {\n\t\tcase YCBCRPOSITION_CENTERED:\n\t\t\tfprintf(fd, \"centered\\n\");\n\t\t\tbreak;\n\t\tcase YCBCRPOSITION_COSITED:\n\t\t\tfprintf(fd, \"cosited\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\n\t\t\t    td->td_ycbcrpositioning, td->td_ycbcrpositioning);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (TIFFFieldSet(tif,FIELD_HALFTONEHINTS))\n\t\tfprintf(fd, \"  Halftone Hints: light %u dark %u\\n\",\n\t\t    td->td_halftonehints[0], td->td_halftonehints[1]);\n\tif (TIFFFieldSet(tif,FIELD_ORIENTATION)) {\n\t\tfprintf(fd, \"  Orientation: \");\n\t\tif (td->td_orientation < NORIENTNAMES)\n\t\t\tfprintf(fd, \"%s\\n\", orientNames[td->td_orientation]);\n\t\telse\n\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\n\t\t\t    td->td_orientation, td->td_orientation);\n\t}\n\tif (TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL))\n\t\tfprintf(fd, \"  Samples/Pixel: %u\\n\", td->td_samplesperpixel);\n\tif (TIFFFieldSet(tif,FIELD_ROWSPERSTRIP)) {\n\t\tfprintf(fd, \"  Rows/Strip: \");\n\t\tif (td->td_rowsperstrip == (uint32) -1)\n\t\t\tfprintf(fd, \"(infinite)\\n\");\n\t\telse\n\t\t\tfprintf(fd, \"%lu\\n\", (unsigned long) td->td_rowsperstrip);\n\t}\n\tif (TIFFFieldSet(tif,FIELD_MINSAMPLEVALUE))\n\t\tfprintf(fd, \"  Min Sample Value: %u\\n\", td->td_minsamplevalue);\n\tif (TIFFFieldSet(tif,FIELD_MAXSAMPLEVALUE))\n\t\tfprintf(fd, \"  Max Sample Value: %u\\n\", td->td_maxsamplevalue);\n\tif (TIFFFieldSet(tif,FIELD_SMINSAMPLEVALUE)) {\n\t\tint i;\n\t\tint count = (tif->tif_flags & TIFF_PERSAMPLE) ? td->td_samplesperpixel : 1;\n\t\tfprintf(fd, \"  SMin Sample Value:\");\n\t\tfor (i = 0; i < count; ++i)\n\t\t\tfprintf(fd, \" %g\", td->td_sminsamplevalue[i]);\n\t\tfprintf(fd, \"\\n\");\n\t}\n\tif (TIFFFieldSet(tif,FIELD_SMAXSAMPLEVALUE)) {\n\t\tint i;\n\t\tint count = (tif->tif_flags & TIFF_PERSAMPLE) ? td->td_samplesperpixel : 1;\n\t\tfprintf(fd, \"  SMax Sample Value:\");\n\t\tfor (i = 0; i < count; ++i)\n\t\t\tfprintf(fd, \" %g\", td->td_smaxsamplevalue[i]);\n\t\tfprintf(fd, \"\\n\");\n\t}\n\tif (TIFFFieldSet(tif,FIELD_PLANARCONFIG)) {\n\t\tfprintf(fd, \"  Planar Configuration: \");\n\t\tswitch (td->td_planarconfig) {\n\t\tcase PLANARCONFIG_CONTIG:\n\t\t\tfprintf(fd, \"single image plane\\n\");\n\t\t\tbreak;\n\t\tcase PLANARCONFIG_SEPARATE:\n\t\t\tfprintf(fd, \"separate image planes\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\n\t\t\t    td->td_planarconfig, td->td_planarconfig);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (TIFFFieldSet(tif,FIELD_PAGENUMBER))\n\t\tfprintf(fd, \"  Page Number: %u-%u\\n\",\n\t\t    td->td_pagenumber[0], td->td_pagenumber[1]);\n\tif (TIFFFieldSet(tif,FIELD_COLORMAP)) {\n\t\tfprintf(fd, \"  Color Map: \");\n\t\tif (flags & TIFFPRINT_COLORMAP) {\n\t\t\tfprintf(fd, \"\\n\");\n\t\t\tn = 1L<<td->td_bitspersample;\n\t\t\tfor (l = 0; l < n; l++)\n\t\t\t\tfprintf(fd, \"   %5ld: %5u %5u %5u\\n\",\n\t\t\t\t    l,\n\t\t\t\t    td->td_colormap[0][l],\n\t\t\t\t    td->td_colormap[1][l],\n\t\t\t\t    td->td_colormap[2][l]);\n\t\t} else\n\t\t\tfprintf(fd, \"(present)\\n\");\n\t}\n\tif (TIFFFieldSet(tif,FIELD_REFBLACKWHITE)) {\n\t\tint i;\n\t\tfprintf(fd, \"  Reference Black/White:\\n\");\n\t\tfor (i = 0; i < 3; i++)\n\t\tfprintf(fd, \"    %2d: %5g %5g\\n\", i,\n\t\t\ttd->td_refblackwhite[2*i+0],\n\t\t\ttd->td_refblackwhite[2*i+1]);\n\t}\n\tif (TIFFFieldSet(tif,FIELD_TRANSFERFUNCTION)) {\n\t\tfprintf(fd, \"  Transfer Function: \");\n\t\tif (flags & TIFFPRINT_CURVES) {\n\t\t\tfprintf(fd, \"\\n\");\n\t\t\tn = 1L<<td->td_bitspersample;\n\t\t\tfor (l = 0; l < n; l++) {\n\t\t\t\tuint16 i;\n\t\t\t\tfprintf(fd, \"    %2ld: %5u\",\n\t\t\t\t    l, td->td_transferfunction[0][l]);\n\t\t\t\tfor (i = 1; i < td->td_samplesperpixel; i++)\n\t\t\t\t\tfprintf(fd, \" %5u\",\n\t\t\t\t\t    td->td_transferfunction[i][l]);\n\t\t\t\tfputc('\\n', fd);\n\t\t\t}\n\t\t} else\n\t\t\tfprintf(fd, \"(present)\\n\");\n\t}\n\tif (TIFFFieldSet(tif, FIELD_SUBIFD) && (td->td_subifd)) {\n\t\tuint16 i;\n\t\tfprintf(fd, \"  SubIFD Offsets:\");\n\t\tfor (i = 0; i < td->td_nsubifd; i++)\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\t\tfprintf(fd, \" %5I64u\",\n\t\t\t\t(unsigned __int64) td->td_subifd[i]);\n#else\n\t\t\tfprintf(fd, \" %5llu\",\n\t\t\t\t(unsigned long long) td->td_subifd[i]);\n#endif\n\t\tfputc('\\n', fd);\n\t}\n\n\t/*\n\t** Custom tag support.\n\t*/\n\t{\n\t\tint  i;\n\t\tshort count;\n\n\t\tcount = (short) TIFFGetTagListCount(tif);\n\t\tfor(i = 0; i < count; i++) {\n\t\t\tuint32 tag = TIFFGetTagListEntry(tif, i);\n\t\t\tconst TIFFField *fip;\n\t\t\tuint32 value_count;\n\t\t\tint mem_alloc = 0;\n\t\t\tvoid *raw_data;\n\n\t\t\tfip = TIFFFieldWithTag(tif, tag);\n\t\t\tif(fip == NULL)\n\t\t\t\tcontinue;\n\n\t\t\tif(fip->field_passcount) {\n\t\t\t\tif (fip->field_readcount == TIFF_VARIABLE2 ) {\n\t\t\t\t\tif(TIFFGetField(tif, tag, &value_count, &raw_data) != 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} else if (fip->field_readcount == TIFF_VARIABLE ) {\n\t\t\t\t\tuint16 small_value_count;\n\t\t\t\t\tif(TIFFGetField(tif, tag, &small_value_count, &raw_data) != 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tvalue_count = small_value_count;\n\t\t\t\t} else {\n\t\t\t\t\tassert (fip->field_readcount == TIFF_VARIABLE\n\t\t\t\t\t\t|| fip->field_readcount == TIFF_VARIABLE2);\n\t\t\t\t\tcontinue;\n\t\t\t\t} \n\t\t\t} else {\n\t\t\t\tif (fip->field_readcount == TIFF_VARIABLE\n\t\t\t\t    || fip->field_readcount == TIFF_VARIABLE2)\n\t\t\t\t\tvalue_count = 1;\n\t\t\t\telse if (fip->field_readcount == TIFF_SPP)\n\t\t\t\t\tvalue_count = td->td_samplesperpixel;\n\t\t\t\telse\n\t\t\t\t\tvalue_count = fip->field_readcount;\n\t\t\t\tif (fip->field_tag == TIFFTAG_DOTRANGE\n\t\t\t\t    && strcmp(fip->field_name,\"DotRange\") == 0) {\n\t\t\t\t\t/* TODO: This is an evil exception and should not have been\n\t\t\t\t\t   handled this way ... likely best if we move it into\n\t\t\t\t\t   the directory structure with an explicit field in \n\t\t\t\t\t   libtiff 4.1 and assign it a FIELD_ value */\n\t\t\t\t\tstatic uint16 dotrange[2];\n\t\t\t\t\traw_data = dotrange;\n\t\t\t\t\tTIFFGetField(tif, tag, dotrange+0, dotrange+1);\n\t\t\t\t} else if (fip->field_type == TIFF_ASCII\n\t\t\t\t\t   || fip->field_readcount == TIFF_VARIABLE\n\t\t\t\t\t   || fip->field_readcount == TIFF_VARIABLE2\n\t\t\t\t\t   || fip->field_readcount == TIFF_SPP\n\t\t\t\t\t   || value_count > 1) {\n\t\t\t\t\tif(TIFFGetField(tif, tag, &raw_data) != 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\traw_data = _TIFFmalloc(\n\t\t\t\t\t    _TIFFDataSize(fip->field_type)\n\t\t\t\t\t    * value_count);\n\t\t\t\t\tmem_alloc = 1;\n\t\t\t\t\tif(TIFFGetField(tif, tag, raw_data) != 1) {\n\t\t\t\t\t\t_TIFFfree(raw_data);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Catch the tags which needs to be specially handled\n\t\t\t * and pretty print them. If tag not handled in\n\t\t\t * _TIFFPrettyPrintField() fall down and print it as\n\t\t\t * any other tag.\n\t\t\t */\n\t\t\tif (!_TIFFPrettyPrintField(tif, fip, fd, tag, value_count, raw_data))\n\t\t\t\t_TIFFPrintField(fd, fip, value_count, raw_data);\n\n\t\t\tif(mem_alloc)\n\t\t\t\t_TIFFfree(raw_data);\n\t\t}\n\t}\n        \n\tif (tif->tif_tagmethods.printdir)\n\t\t(*tif->tif_tagmethods.printdir)(tif, fd, flags);\n\n        _TIFFFillStriles( tif );\n        \n\tif ((flags & TIFFPRINT_STRIPS) &&\n\t    TIFFFieldSet(tif,FIELD_STRIPOFFSETS)) {\n\t\tuint32 s;\n\n\t\tfprintf(fd, \"  %lu %s:\\n\",\n\t\t    (unsigned long) td->td_nstrips,\n\t\t    isTiled(tif) ? \"Tiles\" : \"Strips\");\n\t\tfor (s = 0; s < td->td_nstrips; s++)\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\t\tfprintf(fd, \"    %3lu: [%8I64u, %8I64u]\\n\",\n\t\t\t    (unsigned long) s,\n\t\t\t    td->td_stripoffset ? (unsigned __int64) td->td_stripoffset[s] : 0,\n\t\t\t    td->td_stripbytecount ? (unsigned __int64) td->td_stripbytecount[s] : 0);\n#else\n\t\t\tfprintf(fd, \"    %3lu: [%8llu, %8llu]\\n\",\n\t\t\t    (unsigned long) s,\n\t\t\t    td->td_stripoffset ? (unsigned long long) td->td_stripoffset[s] : 0,\n\t\t\t    td->td_stripbytecount ? (unsigned long long) td->td_stripbytecount[s] : 0);\n#endif\n\t}\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 36,
    "line_new": 36,
    "critical_vars": [
      "temp_buffer"
    ],
    "function": "mpeg4video_probe",
    "filename": "libav/CVE-2016-8675/CVE-2016-8675_CWE-476_e5b019725f53b79159931d3a7317107cbbfd0860_m4vdec.c.diff",
    "function_code": "static int mpeg4video_probe(AVProbeData *probe_packet)\n{\n    uint32_t temp_buffer = -1;\n    int VO = 0, VOL = 0, VOP = 0, VISO = 0, res = 0;\n    int i;\n\n    for (i = 0; i < probe_packet->buf_size; i++) {\n        temp_buffer = (temp_buffer << 8) + probe_packet->buf[i];\n        if (temp_buffer & 0xfffffe00)\n            continue;\n        if (temp_buffer < 2)\n            continue;\n\n        if (temp_buffer == VOP_START_CODE)\n            VOP++;\n        else if (temp_buffer == VISUAL_OBJECT_START_CODE)\n            VISO++;\n        else if (temp_buffer >= 0x100 && temp_buffer < 0x120)\n            VO++;\n        else if (temp_buffer >= 0x120 && temp_buffer < 0x130)\n            VOL++;\n        else if (!(0x1AF < temp_buffer && temp_buffer < 0x1B7) &&\n                 !(0x1B9 < temp_buffer && temp_buffer < 0x1C4))\n            res++;\n    }\n\n    if (VOP >= VISO && VOP >= VOL && VO >= VOL && VOL > 0 && res == 0)\n        return AVPROBE_SCORE_EXTENSION;\n    return 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 523,
    "critical_vars": [
      "ret"
    ],
    "function": "nsv_read_chunk",
    "filename": "libav/CVE-2017-9051/CVE-2017-9051_CWE-476_fe6eea99efac66839052af547426518efd970b24_nsvdec.c.diff",
    "function_code": "static int nsv_read_chunk(AVFormatContext *s, int fill_header)\n{\n    NSVContext *nsv = s->priv_data;\n    AVIOContext *pb = s->pb;\n    AVStream *st[2] = {NULL, NULL};\n    NSVStream *nst;\n    AVPacket *pkt;\n    int i, err = 0;\n    uint8_t auxcount; /* number of aux metadata, also 4 bits of vsize */\n    uint32_t vsize;\n    uint16_t asize;\n    uint16_t auxsize;\n    int ret;\n\n    if (nsv->ahead[0].data || nsv->ahead[1].data)\n        return 0; //-1; /* hey! eat what you've in your plate first! */\n\nnull_chunk_retry:\n    if (pb->eof_reached)\n        return -1;\n\n    for (i = 0; i < NSV_MAX_RESYNC_TRIES && nsv->state < NSV_FOUND_NSVS && !err; i++)\n        err = nsv_resync(s);\n    if (err < 0)\n        return err;\n    if (nsv->state == NSV_FOUND_NSVS)\n        err = nsv_parse_NSVs_header(s);\n    if (err < 0)\n        return err;\n    if (nsv->state != NSV_HAS_READ_NSVS && nsv->state != NSV_FOUND_BEEF)\n        return -1;\n\n    auxcount = avio_r8(pb);\n    vsize = avio_rl16(pb);\n    asize = avio_rl16(pb);\n    vsize = (vsize << 4) | (auxcount >> 4);\n    auxcount &= 0x0f;\n    av_log(s, AV_LOG_TRACE, \"NSV CHUNK %\"PRIu8\" aux, %\"PRIu32\" bytes video, %\"PRIu16\" bytes audio\\n\",\n           auxcount, vsize, asize);\n    /* skip aux stuff */\n    for (i = 0; i < auxcount; i++) {\n        uint32_t av_unused auxtag;\n        auxsize = avio_rl16(pb);\n        auxtag = avio_rl32(pb);\n        avio_skip(pb, auxsize);\n        vsize -= auxsize + sizeof(uint16_t) + sizeof(uint32_t); /* that's becoming brain-dead */\n    }\n\n    if (pb->eof_reached)\n        return -1;\n    if (!vsize && !asize) {\n        nsv->state = NSV_UNSYNC;\n        goto null_chunk_retry;\n    }\n\n    /* map back streams to v,a */\n    if (s->nb_streams > 0)\n        st[s->streams[0]->id] = s->streams[0];\n    if (s->nb_streams > 1)\n        st[s->streams[1]->id] = s->streams[1];\n\n    if (vsize && st[NSV_ST_VIDEO]) {\n        nst = st[NSV_ST_VIDEO]->priv_data;\n        pkt = &nsv->ahead[NSV_ST_VIDEO];\n        if ((ret = av_get_packet(pb, pkt, vsize)) < 0)\n            return ret;\n        pkt->stream_index = st[NSV_ST_VIDEO]->index;//NSV_ST_VIDEO;\n        pkt->dts = nst->frame_offset;\n        pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */\n        for (i = 0; i < FFMIN(8, vsize); i++)\n            av_log(s, AV_LOG_TRACE, \"NSV video: [%d] = %02\"PRIx8\"\\n\",\n                   i, pkt->data[i]);\n    }\n    if(st[NSV_ST_VIDEO])\n        ((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset++;\n\n    if (asize && st[NSV_ST_AUDIO]) {\n        nst = st[NSV_ST_AUDIO]->priv_data;\n        pkt = &nsv->ahead[NSV_ST_AUDIO];\n        /* read raw audio specific header on the first audio chunk... */\n        /* on ALL audio chunks ?? seems so! */\n        if (asize && st[NSV_ST_AUDIO]->codecpar->codec_tag == MKTAG('P', 'C', 'M', ' ')/* && fill_header*/) {\n            uint8_t bps;\n            uint8_t channels;\n            uint16_t samplerate;\n            bps = avio_r8(pb);\n            channels = avio_r8(pb);\n            samplerate = avio_rl16(pb);\n            if (!channels || !samplerate)\n                return AVERROR_INVALIDDATA;\n            asize-=4;\n            av_log(s, AV_LOG_TRACE, \"NSV RAWAUDIO: bps %\"PRIu8\", nchan %\"PRIu8\", srate %\"PRIu16\"\\n\",\n                   bps, channels, samplerate);\n            if (fill_header) {\n                st[NSV_ST_AUDIO]->need_parsing = AVSTREAM_PARSE_NONE; /* we know everything */\n                if (bps != 16) {\n                    av_log(s, AV_LOG_TRACE, \"NSV AUDIO bit/sample != 16 (%\"PRIu8\")!!!\\n\", bps);\n                }\n                bps /= channels; // ???\n                if (bps == 8)\n                    st[NSV_ST_AUDIO]->codecpar->codec_id = AV_CODEC_ID_PCM_U8;\n                samplerate /= 4;/* UGH ??? XXX */\n                channels = 1;\n                st[NSV_ST_AUDIO]->codecpar->channels = channels;\n                st[NSV_ST_AUDIO]->codecpar->sample_rate = samplerate;\n                av_log(s, AV_LOG_TRACE, \"NSV RAWAUDIO: bps %\"PRIu8\", nchan %\"PRIu8\", srate %\"PRIu16\"\\n\",\n                       bps, channels, samplerate);\n            }\n        }\n        if ((ret = av_get_packet(pb, pkt, asize)) < 0)\n            return ret;\n        pkt->stream_index = st[NSV_ST_AUDIO]->index;//NSV_ST_AUDIO;\n        pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */\n        if( nsv->state == NSV_HAS_READ_NSVS && st[NSV_ST_VIDEO] ) {\n            /* on a nsvs frame we have new information on a/v sync */\n            pkt->dts = (((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset-1);\n            pkt->dts *= (int64_t)1000        * nsv->framerate.den;\n            pkt->dts += (int64_t)nsv->avsync * nsv->framerate.num;\n            av_log(s, AV_LOG_TRACE, \"NSV AUDIO: sync:%\"PRId16\", dts:%\"PRId64,\n                   nsv->avsync, pkt->dts);\n        }\n        nst->frame_offset++;\n    }\n\n    nsv->state = NSV_UNSYNC;\n    return 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 650,
    "critical_vars": [
      "vq",
      "vq->used"
    ],
    "function": "vq_endchains",
    "filename": "acrn-hypervisor/CVE-2021-36143/CVE-2021-36143_CWE-476_154fe59531c12b82e26d1b24b5531f5066d224f5_virtio.c.diff",
    "function_code": "vq_endchains(struct virtio_vq_info *vq, int used_all_avail)\n{\n\tstruct virtio_base *base;\n\tuint16_t event_idx, new_idx, old_idx;\n\tint intr;\n\n\tif (!vq || !vq->used)\n\t\treturn;\n\n\t/*\n\t * Interrupt generation: if we're using EVENT_IDX,\n\t * interrupt if we've crossed the event threshold.\n\t * Otherwise interrupt is generated if we added \"used\" entries,\n\t * but suppressed by VRING_AVAIL_F_NO_INTERRUPT.\n\t *\n\t * In any case, though, if NOTIFY_ON_EMPTY is set and the\n\t * entire avail was processed, we need to interrupt always.\n\t */\n\n\tatomic_thread_fence();\n\n\tbase = vq->base;\n\told_idx = vq->save_used;\n\tvq->save_used = new_idx = vq->used->idx;\n\tif (used_all_avail &&\n\t    (base->negotiated_caps & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)))\n\t\tintr = 1;\n\telse if (base->negotiated_caps & (1 << VIRTIO_RING_F_EVENT_IDX)) {\n\t\tevent_idx = VQ_USED_EVENT_IDX(vq);\n\t\t/*\n\t\t * This calculation is per docs and the kernel\n\t\t * (see src/sys/dev/virtio/virtio_ring.h).\n\t\t */\n\t\tintr = (uint16_t)(new_idx - event_idx - 1) <\n\t\t\t(uint16_t)(new_idx - old_idx);\n\t} else {\n\t\tintr = new_idx != old_idx &&\n\t\t    !(vq->avail->flags & VRING_AVAIL_F_NO_INTERRUPT);\n\t}\n\tif (intr)\n\t\tvq_interrupt(base, vq);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 44,
    "critical_vars": [
      "ret"
    ],
    "function": "TEST_CASE",
    "filename": "cpp-peglib/CVE-2020-23914/CVE-2020-23914_CWE-476_0061f393de54cf0326621c079dc2988336d1ebb3_test1.cc.diff",
    "function_code": "TEST_CASE(\"Start rule with ignore operator test\", \"[general]\")\n{\n    parser parser(R\"(\n        ~ROOT <- _\n        _ <- ' '\n    )\");\n\n    bool ret = parser;\n    REQUIRE(ret == false);\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 969,
    "line_new": 969,
    "critical_vars": [
      "&uc->ram_list.blocks"
    ],
    "function": "find_ram_offset",
    "filename": "unicorn/CVE-2022-29694/CVE-2022-29694_CWE-476_3d3deac5e6d38602b689c4fef5dac004f07a2e63_exec.c.diff",
    "function_code": "static ram_addr_t find_ram_offset(struct uc_struct *uc, ram_addr_t size)\n{\n    RAMBlock *block, *next_block;\n    ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX;\n\n    assert(size != 0); /* it would hand out same offset multiple times */\n\n    if (QLIST_EMPTY_RCU(&uc->ram_list.blocks)) {\n        return 0;\n    }\n\n    RAMBLOCK_FOREACH(block) {\n        ram_addr_t candidate, next = RAM_ADDR_MAX;\n\n        /* Align blocks to start on a 'long' in the bitmap\n         * which makes the bitmap sync'ing take the fast path.\n         */\n        candidate = block->offset + block->max_length;\n        candidate = ROUND_UP(candidate, BITS_PER_LONG << TARGET_PAGE_BITS);\n\n        /* Search for the closest following block\n         * and find the gap.\n         */\n        RAMBLOCK_FOREACH(next_block) {\n            if (next_block->offset >= candidate) {\n                next = MIN(next, next_block->offset);\n            }\n        }\n\n        /* If it fits remember our place and remember the size\n         * of gap, but keep going so that we might find a smaller\n         * gap to fill so avoiding fragmentation.\n         */\n        if (next - candidate >= size && next - candidate < mingap) {\n            offset = candidate;\n            mingap = next - candidate;\n        }\n    }\n\n    if (offset == RAM_ADDR_MAX) {\n        fprintf(stderr, \"Failed to find gap of requested size: %\" PRIu64 \"\\n\",\n                (uint64_t)size);\n        abort();\n    }\n\n    return offset;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 1047,
    "critical_vars": [
      "uc->invalid_error"
    ],
    "function": "ram_block_add",
    "filename": "unicorn/CVE-2022-29694/CVE-2022-29694_CWE-476_3d3deac5e6d38602b689c4fef5dac004f07a2e63_exec.c.diff",
    "function_code": "static void ram_block_add(struct uc_struct *uc, RAMBlock *new_block)\n{\n    RAMBlock *block;\n    RAMBlock *last_block = NULL;\n\n    new_block->offset = find_ram_offset(uc, new_block->max_length);\n\n    if (!new_block->host) {\n        new_block->host = phys_mem_alloc(uc, new_block->max_length,\n                &new_block->mr->align);\n        if (!new_block->host) {\n            // mmap fails.\n            uc->invalid_error = UC_ERR_NOMEM;\n            // error_setg_errno(errp, errno,\n            //         \"cannot set up guest memory '%s'\",\n            //         memory_region_name(new_block->mr));\n            return;\n        }\n        // memory_try_enable_merging(new_block->host, new_block->max_length);\n    }\n\n    /* Keep the list sorted from biggest to smallest block.  Unlike QTAILQ,\n     * QLIST (which has an RCU-friendly variant) does not have insertion at\n     * tail, so save the last element in last_block.\n     */\n    RAMBLOCK_FOREACH(block) {\n        last_block = block;\n        if (block->max_length < new_block->max_length) {\n            break;\n        }\n    }\n    if (block) {\n        QLIST_INSERT_BEFORE_RCU(block, new_block, next);\n    } else if (last_block) {\n        QLIST_INSERT_AFTER_RCU(last_block, new_block, next);\n    } else { /* list is empty */\n        QLIST_INSERT_HEAD_RCU(&uc->ram_list.blocks, new_block, next);\n    }\n    uc->ram_list.mru_block = NULL;\n\n    /* Write list before version */\n    //smp_wmb();\n\n    cpu_physical_memory_set_dirty_range(new_block->offset,\n                                        new_block->used_length,\n                                        DIRTY_CLIENTS_ALL);\n\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 1065,
    "critical_vars": [
      "block",
      "new_block",
      "next"
    ],
    "function": "ram_block_add",
    "filename": "unicorn/CVE-2022-29694/CVE-2022-29694_CWE-476_3d3deac5e6d38602b689c4fef5dac004f07a2e63_exec.c.diff",
    "function_code": "static void ram_block_add(struct uc_struct *uc, RAMBlock *new_block)\n{\n    RAMBlock *block;\n    RAMBlock *last_block = NULL;\n\n    new_block->offset = find_ram_offset(uc, new_block->max_length);\n\n    if (!new_block->host) {\n        new_block->host = phys_mem_alloc(uc, new_block->max_length,\n                &new_block->mr->align);\n        if (!new_block->host) {\n            // error_setg_errno(errp, errno,\n            //         \"cannot set up guest memory '%s'\",\n            //         memory_region_name(new_block->mr));\n            return;\n        }\n        // memory_try_enable_merging(new_block->host, new_block->max_length);\n    }\n\n    /* Keep the list sorted from biggest to smallest block.  Unlike QTAILQ,\n     * QLIST (which has an RCU-friendly variant) does not have insertion at\n     * tail, so save the last element in last_block.\n     */\n    RAMBLOCK_FOREACH(block) {\n        last_block = block;\n        if (block->max_length < new_block->max_length) {\n            break;\n        }\n    }\n    if (block) {\n        QLIST_INSERT_BEFORE(block, new_block, next);\n    } else if (last_block) {\n        QLIST_INSERT_AFTER(last_block, new_block, next);\n    } else { /* list is empty */\n        QLIST_INSERT_HEAD(&uc->ram_list.blocks, new_block, next);\n    }\n    uc->ram_list.mru_block = NULL;\n\n    /* Write list before version */\n    //smp_wmb();\n\n    cpu_physical_memory_set_dirty_range(new_block->offset,\n                                        new_block->used_length,\n                                        DIRTY_CLIENTS_ALL);\n\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 1105,
    "critical_vars": [
      "uc->invalid_addr"
    ],
    "function": "*qemu_ram_alloc_from_ptr",
    "filename": "unicorn/CVE-2022-29694/CVE-2022-29694_CWE-476_3d3deac5e6d38602b689c4fef5dac004f07a2e63_exec.c.diff",
    "function_code": "RAMBlock *qemu_ram_alloc_from_ptr(struct uc_struct *uc, ram_addr_t size, void *host,\n                                   MemoryRegion *mr)\n{\n    RAMBlock *new_block;\n    ram_addr_t max_size = size;\n\n    size = HOST_PAGE_ALIGN(uc, size);\n    max_size = HOST_PAGE_ALIGN(uc, max_size);\n    new_block = g_malloc0(sizeof(*new_block));\n    if (new_block == NULL)\n        return NULL;\n    new_block->mr = mr;\n    new_block->used_length = size;\n    new_block->max_length = max_size;\n    assert(max_size >= size);\n    new_block->page_size = uc->qemu_real_host_page_size;\n    new_block->host = host;\n    if (host) {\n        new_block->flags |= RAM_PREALLOC;\n    }\n\n    uc->invalid_addr = UC_ERR_OK;\n    ram_block_add(mr->uc, new_block);\n\n    if (uc->invalid_error != UC_ERR_OK) {\n        g_free(new_block);\n        return NULL;\n    }\n\n    return new_block;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 1133,
    "critical_vars": [
      "block",
      "next"
    ],
    "function": "qemu_ram_free",
    "filename": "unicorn/CVE-2022-29694/CVE-2022-29694_CWE-476_3d3deac5e6d38602b689c4fef5dac004f07a2e63_exec.c.diff",
    "function_code": "void qemu_ram_free(struct uc_struct *uc, RAMBlock *block)\n{\n    if (!block) {\n        return;\n    }\n\n    //if (block->host) {\n    //    ram_block_notify_remove(block->host, block->max_length);\n    //}\n\n    QLIST_REMOVE(block, next);\n    uc->ram_list.mru_block = NULL;\n    /* Write list before version */\n    //smp_wmb();\n    // call_rcu(block, reclaim_ramblock, rcu);\n    reclaim_ramblock(uc, block);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 1142,
    "critical_vars": [
      "block",
      "next"
    ],
    "function": "qemu_ram_free",
    "filename": "unicorn/CVE-2022-29694/CVE-2022-29694_CWE-476_3d3deac5e6d38602b689c4fef5dac004f07a2e63_exec.c.diff",
    "function_code": "void qemu_ram_free(struct uc_struct *uc, RAMBlock *block)\n{\n    if (!block) {\n        return;\n    }\n\n    //if (block->host) {\n    //    ram_block_notify_remove(block->host, block->max_length);\n    //}\n\n    QLIST_REMOVE_RCU(block, next);\n    uc->ram_list.mru_block = NULL;\n    /* Write list before version */\n    //smp_wmb();\n    // call_rcu(block, reclaim_ramblock, rcu);\n    reclaim_ramblock(uc, block);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 46,
    "critical_vars": [
      "ram->ram_block"
    ],
    "function": "*memory_map",
    "filename": "unicorn/CVE-2022-29694/CVE-2022-29694_CWE-476_3d3deac5e6d38602b689c4fef5dac004f07a2e63_memory.c.diff",
    "function_code": "MemoryRegion *memory_map(struct uc_struct *uc, hwaddr begin, size_t size, uint32_t perms)\n{\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    memory_region_init_ram(uc, ram, size, perms);\n    if (ram->addr == -1 || !ram->ram_block) {\n        // out of memory\n        g_free(ram);\n        return NULL;\n    }\n\n    memory_region_add_subregion(uc->system_memory, begin, ram);\n\n    if (uc->cpu) {\n        tlb_flush(uc->cpu);\n    }\n\n    return ram;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 67,
    "critical_vars": [
      "ram->ram_block"
    ],
    "function": "*memory_map_ptr",
    "filename": "unicorn/CVE-2022-29694/CVE-2022-29694_CWE-476_3d3deac5e6d38602b689c4fef5dac004f07a2e63_memory.c.diff",
    "function_code": "MemoryRegion *memory_map_ptr(struct uc_struct *uc, hwaddr begin, size_t size, uint32_t perms, void *ptr)\n{\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    memory_region_init_ram_ptr(uc, ram, size, ptr);\n    ram->perms = perms;\n    if (ram->addr == -1 || !ram->ram_block) {\n        // out of memory\n        g_free(ram);\n        return NULL;\n    }\n\n    memory_region_add_subregion(uc->system_memory, begin, ram);\n\n    if (uc->cpu) {\n        tlb_flush(uc->cpu);\n    }\n\n    return ram;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 970,
    "critical_vars": [
      "pce",
      "&obj"
    ],
    "function": "php_wddx_pop_element",
    "filename": "php-src/CVE-2016-10162/CVE-2016-10162_CWE-476_8d2539fa0faf3f63e1d1e7635347c5b9e777d47b_wddx.c.diff",
    "function_code": " */\nstatic void php_wddx_pop_element(void *user_data, const XML_Char *name)\n{\n\tst_entry \t\t\t*ent1, *ent2;\n\twddx_stack \t\t\t*stack = (wddx_stack *)user_data;\n\tHashTable \t\t\t*target_hash;\n\tzend_class_entry \t**pce;\n\tzval\t\t\t\t*obj;\n\tzval\t\t\t\t*tmp;\n\tTSRMLS_FETCH();\n\n/* OBJECTS_FIXME */\n\tif (stack->top == 0) {\n\t\treturn;\n\t}\n\n\tif (!strcmp(name, EL_STRING) || !strcmp(name, EL_NUMBER) ||\n\t\t!strcmp(name, EL_BOOLEAN) || !strcmp(name, EL_NULL) ||\n\t  \t!strcmp(name, EL_ARRAY) || !strcmp(name, EL_STRUCT) ||\n\t\t!strcmp(name, EL_RECORDSET) || !strcmp(name, EL_BINARY) ||\n\t\t!strcmp(name, EL_DATETIME)) {\n\t\twddx_stack_top(stack, (void**)&ent1);\n\n\t\tif (!ent1->data) {\n\t\t\tif (stack->top > 1) {\n\t\t\t\tstack->top--;\n\t\t\t\tefree(ent1);\n\t\t\t} else {\n\t\t\t\tstack->done = 1;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (!strcmp(name, EL_BINARY)) {\n\t\t\tint new_len=0;\n\t\t\tunsigned char *new_str;\n\n\t\t\tnew_str = php_base64_decode(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data), &new_len);\n\t\t\tSTR_FREE(Z_STRVAL_P(ent1->data));\n\t\t\tif (new_str) {\n\t\t\t\tZ_STRVAL_P(ent1->data) = new_str;\n\t\t\t\tZ_STRLEN_P(ent1->data) = new_len;\n\t\t\t} else {\n\t\t\t\tZVAL_EMPTY_STRING(ent1->data);\n\t\t\t}\n\t\t}\n\n\t\t/* Call __wakeup() method on the object. */\n\t\tif (Z_TYPE_P(ent1->data) == IS_OBJECT) {\n\t\t\tzval *fname, *retval = NULL;\n\n\t\t\tMAKE_STD_ZVAL(fname);\n\t\t\tZVAL_STRING(fname, \"__wakeup\", 1);\n\n\t\t\tcall_user_function_ex(NULL, &ent1->data, fname, &retval, 0, 0, 0, NULL TSRMLS_CC);\n\n\t\t\tzval_dtor(fname);\n\t\t\tFREE_ZVAL(fname);\n\t\t\tif (retval) {\n\t\t\t\tzval_ptr_dtor(&retval);\n\t\t\t}\n\t\t}\n\n\t\tif (stack->top > 1) {\n\t\t\tstack->top--;\n\t\t\twddx_stack_top(stack, (void**)&ent2);\n\n\t\t\t/* if non-existent field */\n\t\t\tif (ent2->data == NULL) {\n\t\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\t\tefree(ent1);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (Z_TYPE_P(ent2->data) == IS_ARRAY || Z_TYPE_P(ent2->data) == IS_OBJECT) {\n\t\t\t\ttarget_hash = HASH_OF(ent2->data);\n\n\t\t\t\tif (ent1->varname) {\n\t\t\t\t\tif (!strcmp(ent1->varname, PHP_CLASS_NAME_VAR) &&\n\t\t\t\t\t\tZ_TYPE_P(ent1->data) == IS_STRING && Z_STRLEN_P(ent1->data) &&\n\t\t\t\t\t\tent2->type == ST_STRUCT && Z_TYPE_P(ent2->data) == IS_ARRAY) {\n\t\t\t\t\t\tzend_bool incomplete_class = 0;\n\n\t\t\t\t\t\tzend_str_tolower(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));\n\t\t\t\t\t\tif (zend_hash_find(EG(class_table), Z_STRVAL_P(ent1->data),\n\t\t\t\t\t\t\t\t\t\t   Z_STRLEN_P(ent1->data)+1, (void **) &pce)==FAILURE) {\n\t\t\t\t\t\t\tincomplete_class = 1;\n\t\t\t\t\t\t\tpce = &PHP_IC_ENTRY;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Initialize target object */\n\t\t\t\t\t\tMAKE_STD_ZVAL(obj);\n\t\t\t\t\t\tobject_init_ex(obj, *pce);\n\n\t\t\t\t\t\t/* Merge current hashtable with object's default properties */\n\t\t\t\t\t\tzend_hash_merge(Z_OBJPROP_P(obj),\n\t\t\t\t\t\t\t\t\t\tZ_ARRVAL_P(ent2->data),\n\t\t\t\t\t\t\t\t\t\t(void (*)(void *)) zval_add_ref,\n\t\t\t\t\t\t\t\t\t\t(void *) &tmp, sizeof(zval *), 0);\n\n\t\t\t\t\t\tif (incomplete_class) {\n\t\t\t\t\t\t\tphp_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Clean up old array entry */\n\t\t\t\t\t\tzval_ptr_dtor(&ent2->data);\n\n\t\t\t\t\t\t/* Set stack entry to point to the newly created object */\n\t\t\t\t\t\tent2->data = obj;\n\n\t\t\t\t\t\t/* Clean up class name var entry */\n\t\t\t\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\t\t\t} else if (Z_TYPE_P(ent2->data) == IS_OBJECT) {\n\t\t\t\t\t\tzend_class_entry *old_scope = EG(scope);\n\n\t\t\t\t\t\tEG(scope) = Z_OBJCE_P(ent2->data);\n\t\t\t\t\t\tZ_DELREF_P(ent1->data);\n\t\t\t\t\t\tadd_property_zval(ent2->data, ent1->varname, ent1->data);\n\t\t\t\t\t\tEG(scope) = old_scope;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tzend_symtable_update(target_hash, ent1->varname, strlen(ent1->varname)+1, &ent1->data, sizeof(zval *), NULL);\n\t\t\t\t\t}\n\t\t\t\t\tefree(ent1->varname);\n\t\t\t\t} else\t{\n\t\t\t\t\tzend_hash_next_index_insert(target_hash, &ent1->data, sizeof(zval *), NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t\tefree(ent1);\n\t\t} else {\n\t\t\tstack->done = 1;\n\t\t}\n\t} else if (!strcmp(name, EL_VAR) && stack->varname) {\n\t\tefree(stack->varname);\n\t\tstack->varname = NULL;\n\t} else if (!strcmp(name, EL_FIELD)) {\n\t\tst_entry *ent;\n\t\twddx_stack_top(stack, (void **)&ent);\n\t\tefree(ent);\n\t\tstack->top--;\n\t}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 970,
    "critical_vars": [
      "pce",
      "exception",
      "&obj"
    ],
    "function": "php_wddx_pop_element",
    "filename": "php-src/CVE-2016-10162/CVE-2016-10162_CWE-476_8d2539fa0faf3f63e1d1e7635347c5b9e777d47b_wddx.c.diff",
    "function_code": " */\nstatic void php_wddx_pop_element(void *user_data, const XML_Char *name)\n{\n\tst_entry \t\t\t*ent1, *ent2;\n\twddx_stack \t\t\t*stack = (wddx_stack *)user_data;\n\tHashTable \t\t\t*target_hash;\n\tzend_class_entry \t**pce;\n\tzval\t\t\t\t*obj;\n\tzval\t\t\t\t*tmp;\n\tTSRMLS_FETCH();\n\n/* OBJECTS_FIXME */\n\tif (stack->top == 0) {\n\t\treturn;\n\t}\n\n\tif (!strcmp(name, EL_STRING) || !strcmp(name, EL_NUMBER) ||\n\t\t!strcmp(name, EL_BOOLEAN) || !strcmp(name, EL_NULL) ||\n\t  \t!strcmp(name, EL_ARRAY) || !strcmp(name, EL_STRUCT) ||\n\t\t!strcmp(name, EL_RECORDSET) || !strcmp(name, EL_BINARY) ||\n\t\t!strcmp(name, EL_DATETIME)) {\n\t\twddx_stack_top(stack, (void**)&ent1);\n\n\t\tif (!ent1->data) {\n\t\t\tif (stack->top > 1) {\n\t\t\t\tstack->top--;\n\t\t\t\tefree(ent1);\n\t\t\t} else {\n\t\t\t\tstack->done = 1;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (!strcmp(name, EL_BINARY)) {\n\t\t\tint new_len=0;\n\t\t\tunsigned char *new_str;\n\n\t\t\tnew_str = php_base64_decode(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data), &new_len);\n\t\t\tSTR_FREE(Z_STRVAL_P(ent1->data));\n\t\t\tif (new_str) {\n\t\t\t\tZ_STRVAL_P(ent1->data) = new_str;\n\t\t\t\tZ_STRLEN_P(ent1->data) = new_len;\n\t\t\t} else {\n\t\t\t\tZVAL_EMPTY_STRING(ent1->data);\n\t\t\t}\n\t\t}\n\n\t\t/* Call __wakeup() method on the object. */\n\t\tif (Z_TYPE_P(ent1->data) == IS_OBJECT) {\n\t\t\tzval *fname, *retval = NULL;\n\n\t\t\tMAKE_STD_ZVAL(fname);\n\t\t\tZVAL_STRING(fname, \"__wakeup\", 1);\n\n\t\t\tcall_user_function_ex(NULL, &ent1->data, fname, &retval, 0, 0, 0, NULL TSRMLS_CC);\n\n\t\t\tzval_dtor(fname);\n\t\t\tFREE_ZVAL(fname);\n\t\t\tif (retval) {\n\t\t\t\tzval_ptr_dtor(&retval);\n\t\t\t}\n\t\t}\n\n\t\tif (stack->top > 1) {\n\t\t\tstack->top--;\n\t\t\twddx_stack_top(stack, (void**)&ent2);\n\n\t\t\t/* if non-existent field */\n\t\t\tif (ent2->data == NULL) {\n\t\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\t\tefree(ent1);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (Z_TYPE_P(ent2->data) == IS_ARRAY || Z_TYPE_P(ent2->data) == IS_OBJECT) {\n\t\t\t\ttarget_hash = HASH_OF(ent2->data);\n\n\t\t\t\tif (ent1->varname) {\n\t\t\t\t\tif (!strcmp(ent1->varname, PHP_CLASS_NAME_VAR) &&\n\t\t\t\t\t\tZ_TYPE_P(ent1->data) == IS_STRING && Z_STRLEN_P(ent1->data) &&\n\t\t\t\t\t\tent2->type == ST_STRUCT && Z_TYPE_P(ent2->data) == IS_ARRAY) {\n\t\t\t\t\t\tzend_bool incomplete_class = 0;\n\n\t\t\t\t\t\tzend_str_tolower(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));\n\t\t\t\t\t\tif (zend_hash_find(EG(class_table), Z_STRVAL_P(ent1->data),\n\t\t\t\t\t\t\t\t\t\t   Z_STRLEN_P(ent1->data)+1, (void **) &pce)==FAILURE) {\n\t\t\t\t\t\t\tincomplete_class = 1;\n\t\t\t\t\t\t\tpce = &PHP_IC_ENTRY;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (pce != &PHP_IC_ENTRY && ((*pce)->serialize || (*pce)->unserialize)) {\n\t\t\t\t\t\t\tent2->data = NULL;\n\t\t\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Class %s can not be unserialized\", Z_STRVAL_P(ent1->data));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* Initialize target object */\n\t\t\t\t\t\t\tMAKE_STD_ZVAL(obj);\n\t\t\t\t\t\t\tobject_init_ex(obj, *pce);\n\n\t\t\t\t\t\t\t/* Merge current hashtable with object's default properties */\n\t\t\t\t\t\t\tzend_hash_merge(Z_OBJPROP_P(obj),\n\t\t\t\t\t\t\t\t\t\t\tZ_ARRVAL_P(ent2->data),\n\t\t\t\t\t\t\t\t\t\t\t(void (*)(void *)) zval_add_ref,\n\t\t\t\t\t\t\t\t\t\t\t(void *) &tmp, sizeof(zval *), 0);\n\n\t\t\t\t\t\t\tif (incomplete_class) {\n\t\t\t\t\t\t\t\tphp_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/* Clean up old array entry */\n\t\t\t\t\t\t\tzval_ptr_dtor(&ent2->data);\n\n\t\t\t\t\t\t\t/* Set stack entry to point to the newly created object */\n\t\t\t\t\t\t\tent2->data = obj;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* Clean up class name var entry */\n\t\t\t\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\t\t\t} else if (Z_TYPE_P(ent2->data) == IS_OBJECT) {\n\t\t\t\t\t\tzend_class_entry *old_scope = EG(scope);\n\n\t\t\t\t\t\tEG(scope) = Z_OBJCE_P(ent2->data);\n\t\t\t\t\t\tZ_DELREF_P(ent1->data);\n\t\t\t\t\t\tadd_property_zval(ent2->data, ent1->varname, ent1->data);\n\t\t\t\t\t\tEG(scope) = old_scope;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tzend_symtable_update(target_hash, ent1->varname, strlen(ent1->varname)+1, &ent1->data, sizeof(zval *), NULL);\n\t\t\t\t\t}\n\t\t\t\t\tefree(ent1->varname);\n\t\t\t\t} else\t{\n\t\t\t\t\tzend_hash_next_index_insert(target_hash, &ent1->data, sizeof(zval *), NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t\tefree(ent1);\n\t\t} else {\n\t\t\tstack->done = 1;\n\t\t}\n\t} else if (!strcmp(name, EL_VAR) && stack->varname) {\n\t\tefree(stack->varname);\n\t\tstack->varname = NULL;\n\t} else if (!strcmp(name, EL_FIELD)) {\n\t\tst_entry *ent;\n\t\twddx_stack_top(stack, (void **)&ent);\n\t\tefree(ent);\n\t\tstack->top--;\n\t}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 474,
    "critical_vars": [
      "*ce"
    ],
    "function": "php_wddx_serialize_object",
    "filename": "php-src/CVE-2016-9934/CVE-2016-9934_CWE-476_6045de69c7dedcba3eadf7c4bba424b19c81d00d_wddx.c.diff",
    "function_code": " */\nstatic void php_wddx_serialize_object(wddx_packet *packet, zval *obj)\n{\n/* OBJECTS_FIXME */\n\tzval **ent, *fname, **varname;\n\tzval *retval = NULL;\n\tconst char *key;\n\tulong idx;\n\tchar tmp_buf[WDDX_BUF_LEN];\n\tHashTable *objhash, *sleephash;\n\tzend_class_entry *ce;\n\tPHP_CLASS_ATTRIBUTES;\n\tTSRMLS_FETCH();\n\n\tPHP_SET_CLASS_ATTRIBUTES(obj);\n\tce = Z_OBJCE_P(obj);\n\tif (!ce || ce->serialize || ce->unserialize) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Class %s can not be serialized\", class_name);\n\t\tPHP_CLEANUP_CLASS_ATTRIBUTES();\n\t\treturn;\n\t}\n\n\tMAKE_STD_ZVAL(fname);\n\tZVAL_STRING(fname, \"__sleep\", 1);\n\t/*\n\t * We try to call __sleep() method on object. It's supposed to return an\n\t * array of property names to be serialized.\n\t */\n\tif (call_user_function_ex(CG(function_table), &obj, fname, &retval, 0, 0, 1, NULL TSRMLS_CC) == SUCCESS) {\n\t\tif (retval && (sleephash = HASH_OF(retval))) {\n\t\t\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_S);\n\t\t\tsnprintf(tmp_buf, WDDX_BUF_LEN, WDDX_VAR_S, PHP_CLASS_NAME_VAR);\n\t\t\tphp_wddx_add_chunk(packet, tmp_buf);\n\t\t\tphp_wddx_add_chunk_static(packet, WDDX_STRING_S);\n\t\t\tphp_wddx_add_chunk_ex(packet, class_name, name_len);\n\t\t\tphp_wddx_add_chunk_static(packet, WDDX_STRING_E);\n\t\t\tphp_wddx_add_chunk_static(packet, WDDX_VAR_E);\n\n\t\t\tobjhash = HASH_OF(obj);\n\n\t\t\tfor (zend_hash_internal_pointer_reset(sleephash);\n\t\t\t\t zend_hash_get_current_data(sleephash, (void **)&varname) == SUCCESS;\n\t\t\t\t zend_hash_move_forward(sleephash)) {\n\t\t\t\tif (Z_TYPE_PP(varname) != IS_STRING) {\n\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"__sleep should return an array only containing the names of instance-variables to serialize.\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (zend_hash_find(objhash, Z_STRVAL_PP(varname), Z_STRLEN_PP(varname)+1, (void **)&ent) == SUCCESS) {\n\t\t\t\t\tphp_wddx_serialize_var(packet, *ent, Z_STRVAL_PP(varname), Z_STRLEN_PP(varname) TSRMLS_CC);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_E);\n\t\t}\n\t} else {\n\t\tuint key_len;\n\n\t\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_S);\n\t\tsnprintf(tmp_buf, WDDX_BUF_LEN, WDDX_VAR_S, PHP_CLASS_NAME_VAR);\n\t\tphp_wddx_add_chunk(packet, tmp_buf);\n\t\tphp_wddx_add_chunk_static(packet, WDDX_STRING_S);\n\t\tphp_wddx_add_chunk_ex(packet, class_name, name_len);\n\t\tphp_wddx_add_chunk_static(packet, WDDX_STRING_E);\n\t\tphp_wddx_add_chunk_static(packet, WDDX_VAR_E);\n\n\t\tobjhash = HASH_OF(obj);\n\t\tfor (zend_hash_internal_pointer_reset(objhash);\n\t\t\t zend_hash_get_current_data(objhash, (void**)&ent) == SUCCESS;\n\t\t\t zend_hash_move_forward(objhash)) {\n\t\t\tif (*ent == obj) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (zend_hash_get_current_key_ex(objhash, &key, &key_len, &idx, 0, NULL) == HASH_KEY_IS_STRING) {\n\t\t\t\tconst char *class_name, *prop_name;\n\n\t\t\t\tzend_unmangle_property_name(key, key_len-1, &class_name, &prop_name);\n\t\t\t\tphp_wddx_serialize_var(packet, *ent, prop_name, strlen(prop_name)+1 TSRMLS_CC);\n\t\t\t} else {\n\t\t\t\tkey_len = slprintf(tmp_buf, sizeof(tmp_buf), \"%ld\", idx);\n\t\t\t\tphp_wddx_serialize_var(packet, *ent, tmp_buf, key_len TSRMLS_CC);\n\t\t\t}\n\t\t}\n\t\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_E);\n\t}\n\n\tPHP_CLEANUP_CLASS_ATTRIBUTES();\n\n\tzval_dtor(fname);\n\tFREE_ZVAL(fname);\n\n\tif (retval) {\n\t\tzval_ptr_dtor(&retval);\n\t}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 487,
    "critical_vars": [
      "obj"
    ],
    "function": "php_wddx_serialize_object",
    "filename": "php-src/CVE-2016-9934/CVE-2016-9934_CWE-476_6045de69c7dedcba3eadf7c4bba424b19c81d00d_wddx.c.diff",
    "function_code": " */\nstatic void php_wddx_serialize_object(wddx_packet *packet, zval *obj)\n{\n/* OBJECTS_FIXME */\n\tzval **ent, *fname, **varname;\n\tzval *retval = NULL;\n\tconst char *key;\n\tulong idx;\n\tchar tmp_buf[WDDX_BUF_LEN];\n\tHashTable *objhash, *sleephash;\n\tTSRMLS_FETCH();\n\n\tMAKE_STD_ZVAL(fname);\n\tZVAL_STRING(fname, \"__sleep\", 1);\n\n\t/*\n\t * We try to call __sleep() method on object. It's supposed to return an\n\t * array of property names to be serialized.\n\t */\n\tif (call_user_function_ex(CG(function_table), &obj, fname, &retval, 0, 0, 1, NULL TSRMLS_CC) == SUCCESS) {\n\t\tif (retval && (sleephash = HASH_OF(retval))) {\n\t\t\tPHP_CLASS_ATTRIBUTES;\n\n\t\t\tPHP_SET_CLASS_ATTRIBUTES(obj);\n\n\t\t\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_S);\n\t\t\tsnprintf(tmp_buf, WDDX_BUF_LEN, WDDX_VAR_S, PHP_CLASS_NAME_VAR);\n\t\t\tphp_wddx_add_chunk(packet, tmp_buf);\n\t\t\tphp_wddx_add_chunk_static(packet, WDDX_STRING_S);\n\t\t\tphp_wddx_add_chunk_ex(packet, class_name, name_len);\n\t\t\tphp_wddx_add_chunk_static(packet, WDDX_STRING_E);\n\t\t\tphp_wddx_add_chunk_static(packet, WDDX_VAR_E);\n\n\t\t\tPHP_CLEANUP_CLASS_ATTRIBUTES();\n\n\t\t\tobjhash = HASH_OF(obj);\n\n\t\t\tfor (zend_hash_internal_pointer_reset(sleephash);\n\t\t\t\t zend_hash_get_current_data(sleephash, (void **)&varname) == SUCCESS;\n\t\t\t\t zend_hash_move_forward(sleephash)) {\n\t\t\t\tif (Z_TYPE_PP(varname) != IS_STRING) {\n\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"__sleep should return an array only containing the names of instance-variables to serialize.\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (zend_hash_find(objhash, Z_STRVAL_PP(varname), Z_STRLEN_PP(varname)+1, (void **)&ent) == SUCCESS) {\n\t\t\t\t\tphp_wddx_serialize_var(packet, *ent, Z_STRVAL_PP(varname), Z_STRLEN_PP(varname) TSRMLS_CC);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_E);\n\t\t}\n\t} else {\n\t\tuint key_len;\n\n\t\tPHP_CLASS_ATTRIBUTES;\n\n\t\tPHP_SET_CLASS_ATTRIBUTES(obj);\n\n\t\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_S);\n\t\tsnprintf(tmp_buf, WDDX_BUF_LEN, WDDX_VAR_S, PHP_CLASS_NAME_VAR);\n\t\tphp_wddx_add_chunk(packet, tmp_buf);\n\t\tphp_wddx_add_chunk_static(packet, WDDX_STRING_S);\n\t\tphp_wddx_add_chunk_ex(packet, class_name, name_len);\n\t\tphp_wddx_add_chunk_static(packet, WDDX_STRING_E);\n\t\tphp_wddx_add_chunk_static(packet, WDDX_VAR_E);\n\n\t\tPHP_CLEANUP_CLASS_ATTRIBUTES();\n\n\t\tobjhash = HASH_OF(obj);\n\t\tfor (zend_hash_internal_pointer_reset(objhash);\n\t\t\t zend_hash_get_current_data(objhash, (void**)&ent) == SUCCESS;\n\t\t\t zend_hash_move_forward(objhash)) {\n\t\t\tif (*ent == obj) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (zend_hash_get_current_key_ex(objhash, &key, &key_len, &idx, 0, NULL) == HASH_KEY_IS_STRING) {\n\t\t\t\tconst char *class_name, *prop_name;\n\n\t\t\t\tzend_unmangle_property_name(key, key_len-1, &class_name, &prop_name);\n\t\t\t\tphp_wddx_serialize_var(packet, *ent, prop_name, strlen(prop_name)+1 TSRMLS_CC);\n\t\t\t} else {\n\t\t\t\tkey_len = slprintf(tmp_buf, sizeof(tmp_buf), \"%ld\", idx);\n\t\t\t\tphp_wddx_serialize_var(packet, *ent, tmp_buf, key_len TSRMLS_CC);\n\t\t\t}\n\t\t}\n\t\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_E);\n\t}\n\n\tzval_dtor(fname);\n\tFREE_ZVAL(fname);\n\n\tif (retval) {\n\t\tzval_ptr_dtor(&retval);\n\t}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 2341,
    "critical_vars": [
      "pdo_row_ce->unserialize"
    ],
    "function": "pdo_stmt_init",
    "filename": "php-src/CVE-2016-9934/CVE-2016-9934_CWE-476_6045de69c7dedcba3eadf7c4bba424b19c81d00d_pdo_stmt.c.diff",
    "function_code": "\nvoid pdo_stmt_init(TSRMLS_D)\n{\n\tzend_class_entry ce;\n\n\tINIT_CLASS_ENTRY(ce, \"PDOStatement\", pdo_dbstmt_functions);\n\tpdo_dbstmt_ce = zend_register_internal_class(&ce TSRMLS_CC);\n\tpdo_dbstmt_ce->get_iterator = pdo_stmt_iter_get;\n\tpdo_dbstmt_ce->create_object = pdo_dbstmt_new;\n\tzend_class_implements(pdo_dbstmt_ce TSRMLS_CC, 1, zend_ce_traversable);\n\tzend_declare_property_null(pdo_dbstmt_ce, \"queryString\", sizeof(\"queryString\")-1, ZEND_ACC_PUBLIC TSRMLS_CC);\n\n\tmemcpy(&pdo_dbstmt_object_handlers, &std_object_handlers, sizeof(zend_object_handlers));\n\tpdo_dbstmt_object_handlers.write_property = dbstmt_prop_write;\n\tpdo_dbstmt_object_handlers.unset_property = dbstmt_prop_delete;\n\tpdo_dbstmt_object_handlers.get_method = dbstmt_method_get;\n\tpdo_dbstmt_object_handlers.compare_objects = dbstmt_compare;\n\tpdo_dbstmt_object_handlers.clone_obj = dbstmt_clone_obj;\n\n\tINIT_CLASS_ENTRY(ce, \"PDORow\", pdo_row_functions);\n\tpdo_row_ce = zend_register_internal_class(&ce TSRMLS_CC);\n\tpdo_row_ce->ce_flags |= ZEND_ACC_FINAL_CLASS; /* when removing this a lot of handlers need to be redone */\n\tpdo_row_ce->create_object = pdo_row_new;\n\tpdo_row_ce->serialize = pdo_row_serialize;\n\tpdo_row_ce->unserialize = zend_class_unserialize_deny;",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 606,
    "critical_vars": [
      "fs->io"
    ],
    "function": "filter_session_io",
    "filename": "src/CVE-2020-35680/CVE-2020-35680_CWE-476_6c3220444ed06b5796dedfd53a0f4becd903c0d1_lka_filter.c.diff",
    "function_code": "filter_session_io(struct io *io, int evt, void *arg)\n{\n\tstruct filter_session *fs = arg;\n\tchar *line = NULL;\n\tssize_t len;\n\n\tlog_trace(TRACE_IO, \"filter session: %p: %s %s\", fs, io_strevent(evt),\n\t    io_strio(io));\n\n\tswitch (evt) {\n\tcase IO_DATAIN:\n\tnextline:\n\t\tline = io_getline(fs->io, &len);\n\t\t/* No complete line received */\n\t\tif (line == NULL)\n\t\t\treturn;\n\n\t\tfilter_data(fs->id, line);\n\n\t\tgoto nextline;\n\n\tcase IO_DISCONNECTED:\n\t\tio_free(fs->io);\n\t\tfs->io = NULL;\n\t\tbreak;\n\t}\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 3086,
    "critical_vars": [
      "list"
    ],
    "function": "mailimf_group_parse",
    "filename": "libetpan/CVE-2017-8825/CVE-2017-8825_CWE-476_1fe8fbc032ccda1db9af66d93016b49c16c1f22d_mailimf.c.diff",
    "function_code": "static int mailimf_group_parse(const char * message, size_t length,\n\t\t\t       size_t * indx,\n\t\t\t       struct mailimf_group ** result)\n{\n  size_t cur_token;\n  char * display_name;\n  struct mailimf_mailbox_list * mailbox_list;\n  struct mailimf_group * group;\n  int r;\n  int res;\n  clist * list;\n\n  cur_token = * indx;\n\n  mailbox_list = NULL;\n\n  r = mailimf_display_name_parse(message, length, &cur_token, &display_name);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_display_name;\n  }\n\n  r = mailimf_mailbox_list_parse(message, length, &cur_token, &mailbox_list);\n  switch (r) {\n  case MAILIMF_NO_ERROR:\n    break;\n  case MAILIMF_ERROR_PARSE:\n    r = mailimf_cfws_parse(message, length, &cur_token);\n    if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n      res = r;\n      goto free_display_name;\n    }\n    list = clist_new();\n    if (list == NULL) {\n      res = MAILIMF_ERROR_MEMORY;\n      goto free_display_name;\n    }\n    mailbox_list = mailimf_mailbox_list_new(list);\n    if (mailbox_list == NULL) {\n      res = MAILIMF_ERROR_MEMORY;\n      clist_free(list);\n      goto free_display_name;\n    }\n    break;\n  default:\n    res = r;\n    goto free_display_name;\n  }\n\n  r = mailimf_semi_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_mailbox_list;\n  }\n\n  group = mailimf_group_new(display_name, mailbox_list);\n  if (group == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_mailbox_list;\n  }\n\n  * indx = cur_token;\n  * result = group;\n\n  return MAILIMF_NO_ERROR;\n\n free_mailbox_list:\n  if (mailbox_list != NULL) {\n    mailimf_mailbox_list_free(mailbox_list);\n  }\n free_display_name:\n  mailimf_display_name_free(display_name);\n err:\n  return res;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 338,
    "critical_vars": [
      "str"
    ],
    "function": "get_cmdln_options",
    "filename": "bwm-ng/CVE-2022-1341/CVE-2022-1341_CWE-476_9774f23bf78a6e6d3ae4cfe3d73bad34f2fdcd17_options.c.diff",
    "function_code": "void get_cmdln_options(int argc, char *argv[]) {\n\tint o;\n#if CONFIG_FILE && HAVE_GETPWUID\n    static struct passwd *pwd_entry;\n    char *str;\n#endif\n#ifdef LONG_OPTIONS\n    int option_index = 0;\n    static struct option long_options[] = {\n        {\"timeout\", 1, 0, 't'},\n#ifdef PROC_NET_DEV\n        {\"procfile\",1,0,'f'},\n#endif\n#ifdef PROC_DISKSTATS\n\t\t\t{\"diskstatsfile\",1,0,1000},\n\t\t\t{\"partitionsfile\",1,0,1001},\n#endif\t\t  \n#if NETSTAT && ALLOW_NETSTATPATH\n        {\"netstat\",1,0,'n'},\n#endif\n#if IOSERVICE_IN\n\t\t  {\"longdisknames\",0,0,1002},\n#endif\n        {\"input\",1,0,'i'},\n        {\"dynamic\",1,0,'d'},\n        {\"help\", 0, 0, 'h'},\n        {\"version\",0,0,'V'},\n        {\"allif\",1,0,'a'},\n        {\"unit\",1,0,'u'},\n\t\t  {\"ansiout\",0,0,'N'},\n#if EXTENDED_STATS        \n        {\"type\",1,0,'T'},\n        {\"avglength\",1,0,'A'},\n#endif        \n        {\"interfaces\",1,0,'I'},\n        {\"sumhidden\",1,0,'S'},\n        {\"output\",1,0,'o'},\n#ifdef CSV\n        {\"csvchar\",1,0,'C'},\n        {\"csvfile\",1,0,'F'},\n#endif\n        {\"count\",1,0,'c'},\n        {\"daemon\",1,0,'D'},\n#ifdef HTML\n        {\"htmlrefresh\",1,0,'R'},\n        {\"htmlheader\",1,0,'H'},\n#endif\n        {0,0,0,0}\n    };\n#endif\n#ifdef CONFIG_FILE\n    /* loop till first non option argument */\n    opterr=0;\n    while (1) {\n#ifdef LONG_OPTIONS\n        o=getopt_long (argc,argv,SHORT_OPTIONS,long_options, &option_index);\n#else\n        o=getopt (argc,argv,SHORT_OPTIONS);\n#endif\n        if (o==-1) break;\n    }\n    opterr=1;\n    if (optind < argc) {\n        read_config(argv[optind]);\n    } else {\n        read_config(\"/etc/bwm-ng.conf\");\n#ifdef HAVE_GETPWUID    \n        pwd_entry=getpwuid(getuid());\n        if (pwd_entry!=NULL) {\n            str=(char*)malloc(strlen(pwd_entry->pw_dir)+14);\n            if(!str) {\n              printf(\"Fatal: failed to allocate %zu bytes.\\n\", strlen(pwd_entry->pw_dir)+14);\n              exit(EXIT_FAILURE);\n            }\n            snprintf(str,strlen(pwd_entry->pw_dir)+14,\"%s/.bwm-ng.conf\",pwd_entry->pw_dir);\n            read_config(str);\n            free(str);\n        }\n#endif    \n    }\n    /* reset getopt again  */\n    optind=1;\n#endif\n    /* get command line arguments, kinda ugly, wanna rewrite it? */\n    while (1) {\n#ifdef LONG_OPTIONS\n\t\to=getopt_long (argc,argv,SHORT_OPTIONS,long_options, &option_index);\n#else\n\t\to=getopt (argc,argv,SHORT_OPTIONS);\n#endif\t\t\n        if (o==-1) break;\n        switch (o) {\n            case '?': printf(\"unknown option: %s\\n\",argv[optind-1]);\n                      exit(EXIT_FAILURE);\n                      break;\n            /* ugly workaround to handle optional arguments for all platforms */                      \n            case ':': if (!strcmp(argv[optind-1],\"-a\") || !strcasecmp(argv[optind-1],\"--allif\")) \n                            show_all_if=1;\n                      else if (!strcmp(argv[optind-1],\"-d\") || !strcasecmp(argv[optind-1],\"--dynamic\"))\n                            dynamic=1;\n                      else if (!strcmp(argv[optind-1],\"-D\") || !strcasecmp(argv[optind-1],\"--daemon\"))\n                            daemonize=1;\n#ifdef HTML                      \n                      else if (!strcmp(argv[optind-1],\"-H\") || !strcasecmp(argv[optind-1],\"--htmlheader\"))\n                            html_header=1;\n#endif                      \n                      else if (!strcmp(argv[optind-1],\"-S\") || !strcasecmp(argv[optind-1],\"--sumhidden\"))\n                            sumhidden=1;    \n                          else {\n                              printf(\"%s requires an argument!\\n\",argv[optind-1]);\n                              exit(EXIT_FAILURE);\n                          }\n                      break;\n#ifdef PROC_DISKSTATS\n\t\t\tcase 1000:\n\t\t\t\tif (strlen(optarg)<PATH_MAX) \n\t\t\t\t\tstrcpy(PROC_DISKSTATS_FILE,optarg);\n\t\t\t\tbreak;\n         case 1001:\n            if (strlen(optarg)<PATH_MAX)\n               strcpy(PROC_PARTITIONS_FILE,optarg);\n\t\t\t\tbreak;\n#endif\t\t\t\t\n#if IOSERVICE_IN\n\t\t\tcase 1002:\n\t\t\t\tlong_darwin_disk_names=!long_darwin_disk_names;\n\t\t\t\tbreak;\n#endif\n\t\t\tcase 'D':\n\t\t\t\tif (optarg) daemonize=atoi(optarg);\n\t\t\t\tbreak;\n#ifdef HTML\n\t\t\tcase 'R':\n\t\t\t\tif ((optarg) && atol(optarg)>0) { html_refresh=atol(optarg); }\n\t\t\t\tbreak;\n\t\t\tcase 'H':\n\t\t\t\tif (optarg) html_header=atoi(optarg);\n\t\t\t\tbreak;\n#endif\n\t\t\tcase 'c':\n\t\t\t\tif (optarg) output_count=atol(optarg);\n\t\t\t\tbreak;\n#if CSV || HTML\n            case 'F':\n                if (optarg) { \n                    if (out_file) fclose(out_file);\n                    out_file=fopen(optarg,\"a\"); \n                    if (!out_file) deinit(1, \"failed to open outfile\\n\");\n                    if (out_file_path) free(out_file_path);\n                    out_file_path=(char *)strdup(optarg);\n                }\n                break;\n#endif\n#ifdef CSV\n\t\t\tcase 'C':\n\t\t\t\tif (optarg) csv_char=optarg[0];\n\t\t\t\tbreak;\n#endif\n            case 'h':\n                cmdln_printhelp();\n                break;\n#ifdef PROC_NET_DEV\n\t\t\tcase 'f':\n                if (optarg && (strlen(optarg)<PATH_MAX)) strcpy(PROC_FILE,optarg);\n                break;\n#endif\t\t\t\n\t\t\tcase 'i':\n                if (optarg) {\n                    input_method=str2in_method(optarg);\n                }\n\t\t\t\tbreak;\t\t\t\t\n            case 'I':\n                if (optarg) iface_list=(char *)strdup(optarg);\n                break;\n            case 'S':\n                if (optarg) sumhidden=atoi(optarg);\n                break;\n            case 'o':\n                if (optarg) {\n                    output_method=str2out_method(optarg);\n                }\n                break;\n\t\t\t\tcase 'N':\n\t\t\t\t\t ansi_output=!ansi_output;\n            case 'a':\n                if (optarg) show_all_if=atoi(optarg);\n                break;\n            case 't':\n                if ((optarg) && atol(optarg)>0) { delay=atol(optarg); }\n                break;\n#if EXTENDED_STATS                \n            case 'T':\n                output_type=str2output_type(optarg);\n                break;\n            case 'A':\n                if (optarg) avg_length=atoi(optarg)*1000;\n                break;\n#endif                \n            case 'd':\n                if (optarg) dynamic=atoi(optarg);\n                break;\n            case 'u':\n                output_unit=str2output_unit(optarg);\n                break;\n#if NETSTAT && ALLOW_NETSTATPATH\n            case 'n':\n                if (optarg && (strlen(optarg)<PATH_MAX)) strcpy(NETSTAT_FILE,optarg);\n                break;\n#endif                \n            case 'V':\n                print_version;\n                exit(EXIT_SUCCESS);\n                break;\n        }\n    }\n    if (iface_list==NULL && show_all_if==1) show_all_if=2;\n#if EXTENDED_STATS    \n    /* default init of avg_length */\n    if (avg_length==0) {\n        if (delay<AVG_LENGTH/2) \n            avg_length=AVG_LENGTH; \n        else  \n            avg_length=(delay*2)+1;\n    } else /* avg_length was set via cmdline or config file, better check it */\n        if (delay*2>=avg_length) deinit(1, \"avglength needs to be a least twice the value of timeout\\n\");\n#endif    \n\t if ((output_unit==ERRORS_OUT && !net_input_method(input_method)) || \n\t\t\t (output_unit==PACKETS_OUT && input_method==LIBSTATDISK_IN)) \n\t\toutput_unit=BYTES_OUT;\n    return;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 1145,
    "critical_vars": [
      "pExpr->affExpr"
    ],
    "function": "whereIndexExprTransColumn",
    "filename": "sqlite/CVE-2019-19242/CVE-2019-19242_CWE-476_57f7ece78410a8aae86aa4625fb7556897db384c_wherecode.c.diff",
    "function_code": "static int whereIndexExprTransColumn(Walker *p, Expr *pExpr){\n  if( pExpr->op==TK_COLUMN ){\n    IdxExprTrans *pX = p->u.pIdxTrans;\n    if( pExpr->iTable==pX->iTabCur && pExpr->iColumn==pX->iTabCol ){\n      assert( pExpr->y.pTab!=0 );\n      pExpr->affExpr = sqlite3TableColumnAffinity(pExpr->y.pTab,pExpr->iColumn);\n      pExpr->iTable = pX->iIdxCur;\n      pExpr->iColumn = pX->iIdxCol;\n      pExpr->y.pTab = 0;\n    }\n  }\n  return WRC_Continue;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 3799,
    "critical_vars": [
      "pSubSrc->a[0].pTab",
      "pSubSrc->nSrc",
      "isAgg"
    ],
    "function": "flattenSubquery",
    "filename": "sqlite/CVE-2019-19923/CVE-2019-19923_CWE-476_396afe6f6aa90a31303c183e11b2b2d4b7956b35_select.c.diff",
    "function_code": "static int flattenSubquery(\n  Parse *pParse,       /* Parsing context */\n  Select *p,           /* The parent or outer SELECT statement */\n  int iFrom,           /* Index in p->pSrc->a[] of the inner subquery */\n  int isAgg            /* True if outer SELECT uses aggregate functions */\n){\n  const char *zSavedAuthContext = pParse->zAuthContext;\n  Select *pParent;    /* Current UNION ALL term of the other query */\n  Select *pSub;       /* The inner query or \"subquery\" */\n  Select *pSub1;      /* Pointer to the rightmost select in sub-query */\n  SrcList *pSrc;      /* The FROM clause of the outer query */\n  SrcList *pSubSrc;   /* The FROM clause of the subquery */\n  int iParent;        /* VDBE cursor number of the pSub result set temp table */\n  int iNewParent = -1;/* Replacement table for iParent */\n  int isLeftJoin = 0; /* True if pSub is the right side of a LEFT JOIN */    \n  int i;              /* Loop counter */\n  Expr *pWhere;                    /* The WHERE clause */\n  struct SrcList_item *pSubitem;   /* The subquery */\n  sqlite3 *db = pParse->db;\n\n  /* Check to see if flattening is permitted.  Return 0 if not.\n  */\n  assert( p!=0 );\n  assert( p->pPrior==0 );\n  if( OptimizationDisabled(db, SQLITE_QueryFlattener) ) return 0;\n  pSrc = p->pSrc;\n  assert( pSrc && iFrom>=0 && iFrom<pSrc->nSrc );\n  pSubitem = &pSrc->a[iFrom];\n  iParent = pSubitem->iCursor;\n  pSub = pSubitem->pSelect;\n  assert( pSub!=0 );\n\n#ifndef SQLITE_OMIT_WINDOWFUNC\n  if( p->pWin || pSub->pWin ) return 0;                  /* Restriction (25) */\n#endif\n\n  pSubSrc = pSub->pSrc;\n  assert( pSubSrc );\n  /* Prior to version 3.1.2, when LIMIT and OFFSET had to be simple constants,\n  ** not arbitrary expressions, we allowed some combining of LIMIT and OFFSET\n  ** because they could be computed at compile-time.  But when LIMIT and OFFSET\n  ** became arbitrary expressions, we were forced to add restrictions (13)\n  ** and (14). */\n  if( pSub->pLimit && p->pLimit ) return 0;              /* Restriction (13) */\n  if( pSub->pLimit && pSub->pLimit->pRight ) return 0;   /* Restriction (14) */\n  if( (p->selFlags & SF_Compound)!=0 && pSub->pLimit ){\n    return 0;                                            /* Restriction (15) */\n  }\n  if( pSubSrc->nSrc==0 ) return 0;                       /* Restriction (7)  */\n  if( pSub->selFlags & SF_Distinct ) return 0;           /* Restriction (4)  */\n  if( pSub->pLimit && (pSrc->nSrc>1 || isAgg) ){\n     return 0;         /* Restrictions (8)(9) */\n  }\n  if( p->pOrderBy && pSub->pOrderBy ){\n     return 0;                                           /* Restriction (11) */\n  }\n  if( isAgg && pSub->pOrderBy ) return 0;                /* Restriction (16) */\n  if( pSub->pLimit && p->pWhere ) return 0;              /* Restriction (19) */\n  if( pSub->pLimit && (p->selFlags & SF_Distinct)!=0 ){\n     return 0;         /* Restriction (21) */\n  }\n  if( pSub->selFlags & (SF_Recursive) ){\n    return 0; /* Restrictions (22) */\n  }\n\n  /*\n  ** If the subquery is the right operand of a LEFT JOIN, then the\n  ** subquery may not be a join itself (3a). Example of why this is not\n  ** allowed:\n  **\n  **         t1 LEFT OUTER JOIN (t2 JOIN t3)\n  **\n  ** If we flatten the above, we would get\n  **\n  **         (t1 LEFT OUTER JOIN t2) JOIN t3\n  **\n  ** which is not at all the same thing.\n  **\n  ** If the subquery is the right operand of a LEFT JOIN, then the outer\n  ** query cannot be an aggregate. (3c)  This is an artifact of the way\n  ** aggregates are processed - there is no mechanism to determine if\n  ** the LEFT JOIN table should be all-NULL.\n  **\n  ** See also tickets #306, #350, and #3300.\n  */\n  if( (pSubitem->fg.jointype & JT_OUTER)!=0 ){\n    isLeftJoin = 1;\n    if( pSubSrc->nSrc>1 || isAgg || IsVirtual(pSubSrc->a[0].pTab) ){\n      /*  (3a)             (3c)     (3b) */\n      return 0;\n    }\n  }\n#ifdef SQLITE_EXTRA_IFNULLROW\n  else if( iFrom>0 && !isAgg ){\n    /* Setting isLeftJoin to -1 causes OP_IfNullRow opcodes to be generated for\n    ** every reference to any result column from subquery in a join, even\n    ** though they are not necessary.  This will stress-test the OP_IfNullRow \n    ** opcode. */\n    isLeftJoin = -1;\n  }\n#endif\n\n  /* Restriction (17): If the sub-query is a compound SELECT, then it must\n  ** use only the UNION ALL operator. And none of the simple select queries\n  ** that make up the compound SELECT are allowed to be aggregate or distinct\n  ** queries.\n  */\n  if( pSub->pPrior ){\n    if( pSub->pOrderBy ){\n      return 0;  /* Restriction (20) */\n    }\n    if( isAgg || (p->selFlags & SF_Distinct)!=0 || pSrc->nSrc!=1 ){\n      return 0; /* (17d1), (17d2), or (17d3) */\n    }\n    for(pSub1=pSub; pSub1; pSub1=pSub1->pPrior){\n      testcase( (pSub1->selFlags & (SF_Distinct|SF_Aggregate))==SF_Distinct );\n      testcase( (pSub1->selFlags & (SF_Distinct|SF_Aggregate))==SF_Aggregate );\n      assert( pSub->pSrc!=0 );\n      assert( pSub->pEList->nExpr==pSub1->pEList->nExpr );\n      if( (pSub1->selFlags & (SF_Distinct|SF_Aggregate))!=0    /* (17b) */\n       || (pSub1->pPrior && pSub1->op!=TK_ALL)                 /* (17a) */\n       || pSub1->pSrc->nSrc<1                                  /* (17c) */\n      ){\n        return 0;\n      }\n      testcase( pSub1->pSrc->nSrc>1 );\n    }\n\n    /* Restriction (18). */\n    if( p->pOrderBy ){\n      int ii;\n      for(ii=0; ii<p->pOrderBy->nExpr; ii++){\n        if( p->pOrderBy->a[ii].u.x.iOrderByCol==0 ) return 0;\n      }\n    }\n  }\n\n  /* Ex-restriction (23):\n  ** The only way that the recursive part of a CTE can contain a compound\n  ** subquery is for the subquery to be one term of a join.  But if the\n  ** subquery is a join, then the flattening has already been stopped by\n  ** restriction (17d3)\n  */\n  assert( (p->selFlags & SF_Recursive)==0 || pSub->pPrior==0 );\n\n  /***** If we reach this point, flattening is permitted. *****/\n  SELECTTRACE(1,pParse,p,(\"flatten %u.%p from term %d\\n\",\n                   pSub->selId, pSub, iFrom));\n\n  /* Authorize the subquery */\n  pParse->zAuthContext = pSubitem->zName;\n  TESTONLY(i =) sqlite3AuthCheck(pParse, SQLITE_SELECT, 0, 0, 0);\n  testcase( i==SQLITE_DENY );\n  pParse->zAuthContext = zSavedAuthContext;\n\n  /* If the sub-query is a compound SELECT statement, then (by restrictions\n  ** 17 and 18 above) it must be a UNION ALL and the parent query must \n  ** be of the form:\n  **\n  **     SELECT <expr-list> FROM (<sub-query>) <where-clause> \n  **\n  ** followed by any ORDER BY, LIMIT and/or OFFSET clauses. This block\n  ** creates N-1 copies of the parent query without any ORDER BY, LIMIT or \n  ** OFFSET clauses and joins them to the left-hand-side of the original\n  ** using UNION ALL operators. In this case N is the number of simple\n  ** select statements in the compound sub-query.\n  **\n  ** Example:\n  **\n  **     SELECT a+1 FROM (\n  **        SELECT x FROM tab\n  **        UNION ALL\n  **        SELECT y FROM tab\n  **        UNION ALL\n  **        SELECT abs(z*2) FROM tab2\n  **     ) WHERE a!=5 ORDER BY 1\n  **\n  ** Transformed into:\n  **\n  **     SELECT x+1 FROM tab WHERE x+1!=5\n  **     UNION ALL\n  **     SELECT y+1 FROM tab WHERE y+1!=5\n  **     UNION ALL\n  **     SELECT abs(z*2)+1 FROM tab2 WHERE abs(z*2)+1!=5\n  **     ORDER BY 1\n  **\n  ** We call this the \"compound-subquery flattening\".\n  */\n  for(pSub=pSub->pPrior; pSub; pSub=pSub->pPrior){\n    Select *pNew;\n    ExprList *pOrderBy = p->pOrderBy;\n    Expr *pLimit = p->pLimit;\n    Select *pPrior = p->pPrior;\n    p->pOrderBy = 0;\n    p->pSrc = 0;\n    p->pPrior = 0;\n    p->pLimit = 0;\n    pNew = sqlite3SelectDup(db, p, 0);\n    p->pLimit = pLimit;\n    p->pOrderBy = pOrderBy;\n    p->pSrc = pSrc;\n    p->op = TK_ALL;\n    if( pNew==0 ){\n      p->pPrior = pPrior;\n    }else{\n      pNew->pPrior = pPrior;\n      if( pPrior ) pPrior->pNext = pNew;\n      pNew->pNext = p;\n      p->pPrior = pNew;\n      SELECTTRACE(2,pParse,p,(\"compound-subquery flattener\"\n                              \" creates %u as peer\\n\",pNew->selId));\n    }\n    if( db->mallocFailed ) return 1;\n  }\n\n  /* Begin flattening the iFrom-th entry of the FROM clause \n  ** in the outer query.\n  */\n  pSub = pSub1 = pSubitem->pSelect;\n\n  /* Delete the transient table structure associated with the\n  ** subquery\n  */\n  sqlite3DbFree(db, pSubitem->zDatabase);\n  sqlite3DbFree(db, pSubitem->zName);\n  sqlite3DbFree(db, pSubitem->zAlias);\n  pSubitem->zDatabase = 0;\n  pSubitem->zName = 0;\n  pSubitem->zAlias = 0;\n  pSubitem->pSelect = 0;\n\n  /* Defer deleting the Table object associated with the\n  ** subquery until code generation is\n  ** complete, since there may still exist Expr.pTab entries that\n  ** refer to the subquery even after flattening.  Ticket #3346.\n  **\n  ** pSubitem->pTab is always non-NULL by test restrictions and tests above.\n  */\n  if( ALWAYS(pSubitem->pTab!=0) ){\n    Table *pTabToDel = pSubitem->pTab;\n    if( pTabToDel->nTabRef==1 ){\n      Parse *pToplevel = sqlite3ParseToplevel(pParse);\n      pTabToDel->pNextZombie = pToplevel->pZombieTab;\n      pToplevel->pZombieTab = pTabToDel;\n    }else{\n      pTabToDel->nTabRef--;\n    }\n    pSubitem->pTab = 0;\n  }\n\n  /* The following loop runs once for each term in a compound-subquery\n  ** flattening (as described above).  If we are doing a different kind\n  ** of flattening - a flattening other than a compound-subquery flattening -\n  ** then this loop only runs once.\n  **\n  ** This loop moves all of the FROM elements of the subquery into the\n  ** the FROM clause of the outer query.  Before doing this, remember\n  ** the cursor number for the original outer query FROM element in\n  ** iParent.  The iParent cursor will never be used.  Subsequent code\n  ** will scan expressions looking for iParent references and replace\n  ** those references with expressions that resolve to the subquery FROM\n  ** elements we are now copying in.\n  */\n  for(pParent=p; pParent; pParent=pParent->pPrior, pSub=pSub->pPrior){\n    int nSubSrc;\n    u8 jointype = 0;\n    assert( pSub!=0 );\n    pSubSrc = pSub->pSrc;     /* FROM clause of subquery */\n    nSubSrc = pSubSrc->nSrc;  /* Number of terms in subquery FROM clause */\n    pSrc = pParent->pSrc;     /* FROM clause of the outer query */\n\n    if( pSrc ){\n      assert( pParent==p );  /* First time through the loop */\n      jointype = pSubitem->fg.jointype;\n    }else{\n      assert( pParent!=p );  /* 2nd and subsequent times through the loop */\n      pSrc = sqlite3SrcListAppend(pParse, 0, 0, 0);\n      if( pSrc==0 ) break;\n      pParent->pSrc = pSrc;\n    }\n\n    /* The subquery uses a single slot of the FROM clause of the outer\n    ** query.  If the subquery has more than one element in its FROM clause,\n    ** then expand the outer query to make space for it to hold all elements\n    ** of the subquery.\n    **\n    ** Example:\n    **\n    **    SELECT * FROM tabA, (SELECT * FROM sub1, sub2), tabB;\n    **\n    ** The outer query has 3 slots in its FROM clause.  One slot of the\n    ** outer query (the middle slot) is used by the subquery.  The next\n    ** block of code will expand the outer query FROM clause to 4 slots.\n    ** The middle slot is expanded to two slots in order to make space\n    ** for the two elements in the FROM clause of the subquery.\n    */\n    if( nSubSrc>1 ){\n      pSrc = sqlite3SrcListEnlarge(pParse, pSrc, nSubSrc-1,iFrom+1);\n      if( pSrc==0 ) break;\n      pParent->pSrc = pSrc;\n    }\n\n    /* Transfer the FROM clause terms from the subquery into the\n    ** outer query.\n    */\n    for(i=0; i<nSubSrc; i++){\n      sqlite3IdListDelete(db, pSrc->a[i+iFrom].pUsing);\n      assert( pSrc->a[i+iFrom].fg.isTabFunc==0 );\n      pSrc->a[i+iFrom] = pSubSrc->a[i];\n      iNewParent = pSubSrc->a[i].iCursor;\n      memset(&pSubSrc->a[i], 0, sizeof(pSubSrc->a[i]));\n    }\n    pSrc->a[iFrom].fg.jointype = jointype;\n  \n    /* Now begin substituting subquery result set expressions for \n    ** references to the iParent in the outer query.\n    ** \n    ** Example:\n    **\n    **   SELECT a+5, b*10 FROM (SELECT x*3 AS a, y+10 AS b FROM t1) WHERE a>b;\n    **   \\                     \\_____________ subquery __________/          /\n    **    \\_____________________ outer query ______________________________/\n    **\n    ** We look at every expression in the outer query and every place we see\n    ** \"a\" we substitute \"x*3\" and every place we see \"b\" we substitute \"y+10\".\n    */\n    if( pSub->pOrderBy ){\n      /* At this point, any non-zero iOrderByCol values indicate that the\n      ** ORDER BY column expression is identical to the iOrderByCol'th\n      ** expression returned by SELECT statement pSub. Since these values\n      ** do not necessarily correspond to columns in SELECT statement pParent,\n      ** zero them before transfering the ORDER BY clause.\n      **\n      ** Not doing this may cause an error if a subsequent call to this\n      ** function attempts to flatten a compound sub-query into pParent\n      ** (the only way this can happen is if the compound sub-query is\n      ** currently part of pSub->pSrc). See ticket [d11a6e908f].  */\n      ExprList *pOrderBy = pSub->pOrderBy;\n      for(i=0; i<pOrderBy->nExpr; i++){\n        pOrderBy->a[i].u.x.iOrderByCol = 0;\n      }\n      assert( pParent->pOrderBy==0 );\n      pParent->pOrderBy = pOrderBy;\n      pSub->pOrderBy = 0;\n    }\n    pWhere = pSub->pWhere;\n    pSub->pWhere = 0;\n    if( isLeftJoin>0 ){\n      sqlite3SetJoinExpr(pWhere, iNewParent);\n    }\n    pParent->pWhere = sqlite3ExprAnd(pParse, pWhere, pParent->pWhere);\n    if( db->mallocFailed==0 ){\n      SubstContext x;\n      x.pParse = pParse;\n      x.iTable = iParent;\n      x.iNewTable = iNewParent;\n      x.isLeftJoin = isLeftJoin;\n      x.pEList = pSub->pEList;\n      substSelect(&x, pParent, 0);\n    }\n  \n    /* The flattened query is a compound if either the inner or the\n    ** outer query is a compound. */\n    pParent->selFlags |= pSub->selFlags & SF_Compound;\n    assert( (pSub->selFlags & SF_Distinct)==0 ); /* restriction (17b) */\n  \n    /*\n    ** SELECT ... FROM (SELECT ... LIMIT a OFFSET b) LIMIT x OFFSET y;\n    **\n    ** One is tempted to try to add a and b to combine the limits.  But this\n    ** does not work if either limit is negative.\n    */\n    if( pSub->pLimit ){\n      pParent->pLimit = pSub->pLimit;\n      pSub->pLimit = 0;\n    }\n  }\n\n  /* Finially, delete what is left of the subquery and return\n  ** success.\n  */\n  sqlite3SelectDelete(db, pSub1);\n\n#if SELECTTRACE_ENABLED\n  if( sqlite3SelectTrace & 0x100 ){\n    SELECTTRACE(0x100,pParse,p,(\"After flattening:\\n\"));\n    sqlite3TreeViewSelect(0, p, 0);\n  }\n#endif\n\n  return 1;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 2812,
    "critical_vars": [
      "pParse->nErr"
    ],
    "function": "multiSelect",
    "filename": "sqlite/CVE-2019-19926/CVE-2019-19926_CWE-476_8428b3b437569338a9d1e10c4cd8154acbe33089_select.c.diff",
    "function_code": "static int multiSelect(\n  Parse *pParse,        /* Parsing context */\n  Select *p,            /* The right-most of SELECTs to be coded */\n  SelectDest *pDest     /* What to do with query results */\n){\n  int rc = SQLITE_OK;   /* Success code from a subroutine */\n  Select *pPrior;       /* Another SELECT immediately to our left */\n  Vdbe *v;              /* Generate code to this VDBE */\n  SelectDest dest;      /* Alternative data destination */\n  Select *pDelete = 0;  /* Chain of simple selects to delete */\n  sqlite3 *db;          /* Database connection */\n\n  /* Make sure there is no ORDER BY or LIMIT clause on prior SELECTs.  Only\n  ** the last (right-most) SELECT in the series may have an ORDER BY or LIMIT.\n  */\n  assert( p && p->pPrior );  /* Calling function guarantees this much */\n  assert( (p->selFlags & SF_Recursive)==0 || p->op==TK_ALL || p->op==TK_UNION );\n  assert( p->selFlags & SF_Compound );\n  db = pParse->db;\n  pPrior = p->pPrior;\n  dest = *pDest;\n  if( pPrior->pOrderBy || pPrior->pLimit ){\n    sqlite3ErrorMsg(pParse,\"%s clause should come after %s not before\",\n      pPrior->pOrderBy!=0 ? \"ORDER BY\" : \"LIMIT\", selectOpName(p->op));\n    rc = 1;\n    goto multi_select_end;\n  }\n\n  v = sqlite3GetVdbe(pParse);\n  assert( v!=0 );  /* The VDBE already created by calling function */\n\n  /* Create the destination temporary table if necessary\n  */\n  if( dest.eDest==SRT_EphemTab ){\n    assert( p->pEList );\n    sqlite3VdbeAddOp2(v, OP_OpenEphemeral, dest.iSDParm, p->pEList->nExpr);\n    dest.eDest = SRT_Table;\n  }\n\n  /* Special handling for a compound-select that originates as a VALUES clause.\n  */\n  if( p->selFlags & SF_MultiValue ){\n    rc = multiSelectValues(pParse, p, &dest);\n    if( rc>=0 ) goto multi_select_end;\n    rc = SQLITE_OK;\n  }\n\n  /* Make sure all SELECTs in the statement have the same number of elements\n  ** in their result sets.\n  */\n  assert( p->pEList && pPrior->pEList );\n  assert( p->pEList->nExpr==pPrior->pEList->nExpr );\n\n#ifndef SQLITE_OMIT_CTE\n  if( p->selFlags & SF_Recursive ){\n    generateWithRecursiveQuery(pParse, p, &dest);\n  }else\n#endif\n\n  /* Compound SELECTs that have an ORDER BY clause are handled separately.\n  */\n  if( p->pOrderBy ){\n    return multiSelectOrderBy(pParse, p, pDest);\n  }else{\n\n#ifndef SQLITE_OMIT_EXPLAIN\n    if( pPrior->pPrior==0 ){\n      ExplainQueryPlan((pParse, 1, \"COMPOUND QUERY\"));\n      ExplainQueryPlan((pParse, 1, \"LEFT-MOST SUBQUERY\"));\n    }\n#endif\n\n    /* Generate code for the left and right SELECT statements.\n    */\n    switch( p->op ){\n      case TK_ALL: {\n        int addr = 0;\n        int nLimit;\n        assert( !pPrior->pLimit );\n        pPrior->iLimit = p->iLimit;\n        pPrior->iOffset = p->iOffset;\n        pPrior->pLimit = p->pLimit;\n        rc = sqlite3Select(pParse, pPrior, &dest);\n        p->pLimit = 0;\n        if( rc ){\n          goto multi_select_end;\n        }\n        p->pPrior = 0;\n        p->iLimit = pPrior->iLimit;\n        p->iOffset = pPrior->iOffset;\n        if( p->iLimit ){\n          addr = sqlite3VdbeAddOp1(v, OP_IfNot, p->iLimit); VdbeCoverage(v);\n          VdbeComment((v, \"Jump ahead if LIMIT reached\"));\n          if( p->iOffset ){\n            sqlite3VdbeAddOp3(v, OP_OffsetLimit,\n                              p->iLimit, p->iOffset+1, p->iOffset);\n          }\n        }\n        ExplainQueryPlan((pParse, 1, \"UNION ALL\"));\n        rc = sqlite3Select(pParse, p, &dest);\n        testcase( rc!=SQLITE_OK );\n        pDelete = p->pPrior;\n        p->pPrior = pPrior;\n        p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);\n        if( pPrior->pLimit\n         && sqlite3ExprIsInteger(pPrior->pLimit->pLeft, &nLimit)\n         && nLimit>0 && p->nSelectRow > sqlite3LogEst((u64)nLimit) \n        ){\n          p->nSelectRow = sqlite3LogEst((u64)nLimit);\n        }\n        if( addr ){\n          sqlite3VdbeJumpHere(v, addr);\n        }\n        break;\n      }\n      case TK_EXCEPT:\n      case TK_UNION: {\n        int unionTab;    /* Cursor number of the temp table holding result */\n        u8 op = 0;       /* One of the SRT_ operations to apply to self */\n        int priorOp;     /* The SRT_ operation to apply to prior selects */\n        Expr *pLimit;    /* Saved values of p->nLimit  */\n        int addr;\n        SelectDest uniondest;\n  \n        testcase( p->op==TK_EXCEPT );\n        testcase( p->op==TK_UNION );\n        priorOp = SRT_Union;\n        if( dest.eDest==priorOp ){\n          /* We can reuse a temporary table generated by a SELECT to our\n          ** right.\n          */\n          assert( p->pLimit==0 );      /* Not allowed on leftward elements */\n          unionTab = dest.iSDParm;\n        }else{\n          /* We will need to create our own temporary table to hold the\n          ** intermediate results.\n          */\n          unionTab = pParse->nTab++;\n          assert( p->pOrderBy==0 );\n          addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, unionTab, 0);\n          assert( p->addrOpenEphm[0] == -1 );\n          p->addrOpenEphm[0] = addr;\n          findRightmost(p)->selFlags |= SF_UsesEphemeral;\n          assert( p->pEList );\n        }\n  \n        /* Code the SELECT statements to our left\n        */\n        assert( !pPrior->pOrderBy );\n        sqlite3SelectDestInit(&uniondest, priorOp, unionTab);\n        rc = sqlite3Select(pParse, pPrior, &uniondest);\n        if( rc ){\n          goto multi_select_end;\n        }\n  \n        /* Code the current SELECT statement\n        */\n        if( p->op==TK_EXCEPT ){\n          op = SRT_Except;\n        }else{\n          assert( p->op==TK_UNION );\n          op = SRT_Union;\n        }\n        p->pPrior = 0;\n        pLimit = p->pLimit;\n        p->pLimit = 0;\n        uniondest.eDest = op;\n        ExplainQueryPlan((pParse, 1, \"%s USING TEMP B-TREE\",\n                          selectOpName(p->op)));\n        rc = sqlite3Select(pParse, p, &uniondest);\n        testcase( rc!=SQLITE_OK );\n        /* Query flattening in sqlite3Select() might refill p->pOrderBy.\n        ** Be sure to delete p->pOrderBy, therefore, to avoid a memory leak. */\n        sqlite3ExprListDelete(db, p->pOrderBy);\n        pDelete = p->pPrior;\n        p->pPrior = pPrior;\n        p->pOrderBy = 0;\n        if( p->op==TK_UNION ){\n          p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);\n        }\n        sqlite3ExprDelete(db, p->pLimit);\n        p->pLimit = pLimit;\n        p->iLimit = 0;\n        p->iOffset = 0;\n  \n        /* Convert the data in the temporary table into whatever form\n        ** it is that we currently need.\n        */\n        assert( unionTab==dest.iSDParm || dest.eDest!=priorOp );\n        if( dest.eDest!=priorOp ){\n          int iCont, iBreak, iStart;\n          assert( p->pEList );\n          iBreak = sqlite3VdbeMakeLabel(pParse);\n          iCont = sqlite3VdbeMakeLabel(pParse);\n          computeLimitRegisters(pParse, p, iBreak);\n          sqlite3VdbeAddOp2(v, OP_Rewind, unionTab, iBreak); VdbeCoverage(v);\n          iStart = sqlite3VdbeCurrentAddr(v);\n          selectInnerLoop(pParse, p, unionTab,\n                          0, 0, &dest, iCont, iBreak);\n          sqlite3VdbeResolveLabel(v, iCont);\n          sqlite3VdbeAddOp2(v, OP_Next, unionTab, iStart); VdbeCoverage(v);\n          sqlite3VdbeResolveLabel(v, iBreak);\n          sqlite3VdbeAddOp2(v, OP_Close, unionTab, 0);\n        }\n        break;\n      }\n      default: assert( p->op==TK_INTERSECT ); {\n        int tab1, tab2;\n        int iCont, iBreak, iStart;\n        Expr *pLimit;\n        int addr;\n        SelectDest intersectdest;\n        int r1;\n  \n        /* INTERSECT is different from the others since it requires\n        ** two temporary tables.  Hence it has its own case.  Begin\n        ** by allocating the tables we will need.\n        */\n        tab1 = pParse->nTab++;\n        tab2 = pParse->nTab++;\n        assert( p->pOrderBy==0 );\n  \n        addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, tab1, 0);\n        assert( p->addrOpenEphm[0] == -1 );\n        p->addrOpenEphm[0] = addr;\n        findRightmost(p)->selFlags |= SF_UsesEphemeral;\n        assert( p->pEList );\n  \n        /* Code the SELECTs to our left into temporary table \"tab1\".\n        */\n        sqlite3SelectDestInit(&intersectdest, SRT_Union, tab1);\n        rc = sqlite3Select(pParse, pPrior, &intersectdest);\n        if( rc ){\n          goto multi_select_end;\n        }\n  \n        /* Code the current SELECT into temporary table \"tab2\"\n        */\n        addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, tab2, 0);\n        assert( p->addrOpenEphm[1] == -1 );\n        p->addrOpenEphm[1] = addr;\n        p->pPrior = 0;\n        pLimit = p->pLimit;\n        p->pLimit = 0;\n        intersectdest.iSDParm = tab2;\n        ExplainQueryPlan((pParse, 1, \"%s USING TEMP B-TREE\",\n                          selectOpName(p->op)));\n        rc = sqlite3Select(pParse, p, &intersectdest);\n        testcase( rc!=SQLITE_OK );\n        pDelete = p->pPrior;\n        p->pPrior = pPrior;\n        if( p->nSelectRow>pPrior->nSelectRow ){\n          p->nSelectRow = pPrior->nSelectRow;\n        }\n        sqlite3ExprDelete(db, p->pLimit);\n        p->pLimit = pLimit;\n  \n        /* Generate code to take the intersection of the two temporary\n        ** tables.\n        */\n        assert( p->pEList );\n        iBreak = sqlite3VdbeMakeLabel(pParse);\n        iCont = sqlite3VdbeMakeLabel(pParse);\n        computeLimitRegisters(pParse, p, iBreak);\n        sqlite3VdbeAddOp2(v, OP_Rewind, tab1, iBreak); VdbeCoverage(v);\n        r1 = sqlite3GetTempReg(pParse);\n        iStart = sqlite3VdbeAddOp2(v, OP_RowData, tab1, r1);\n        sqlite3VdbeAddOp4Int(v, OP_NotFound, tab2, iCont, r1, 0);\n        VdbeCoverage(v);\n        sqlite3ReleaseTempReg(pParse, r1);\n        selectInnerLoop(pParse, p, tab1,\n                        0, 0, &dest, iCont, iBreak);\n        sqlite3VdbeResolveLabel(v, iCont);\n        sqlite3VdbeAddOp2(v, OP_Next, tab1, iStart); VdbeCoverage(v);\n        sqlite3VdbeResolveLabel(v, iBreak);\n        sqlite3VdbeAddOp2(v, OP_Close, tab2, 0);\n        sqlite3VdbeAddOp2(v, OP_Close, tab1, 0);\n        break;\n      }\n    }\n  \n  #ifndef SQLITE_OMIT_EXPLAIN\n    if( p->pNext==0 ){\n      ExplainQueryPlanPop(pParse);\n    }\n  #endif\n  }\n  if( pParse->nErr ) goto multi_select_end;\n  \n  /* Compute collating sequences used by \n  ** temporary tables needed to implement the compound select.\n  ** Attach the KeyInfo structure to all temporary tables.\n  **\n  ** This section is run by the right-most SELECT statement only.\n  ** SELECT statements to the left always skip this part.  The right-most\n  ** SELECT might also skip this part if it has no ORDER BY clause and\n  ** no temp tables are required.\n  */\n  if( p->selFlags & SF_UsesEphemeral ){\n    int i;                        /* Loop counter */\n    KeyInfo *pKeyInfo;            /* Collating sequence for the result set */\n    Select *pLoop;                /* For looping through SELECT statements */\n    CollSeq **apColl;             /* For looping through pKeyInfo->aColl[] */\n    int nCol;                     /* Number of columns in result set */\n\n    assert( p->pNext==0 );\n    nCol = p->pEList->nExpr;\n    pKeyInfo = sqlite3KeyInfoAlloc(db, nCol, 1);\n    if( !pKeyInfo ){\n      rc = SQLITE_NOMEM_BKPT;\n      goto multi_select_end;\n    }\n    for(i=0, apColl=pKeyInfo->aColl; i<nCol; i++, apColl++){\n      *apColl = multiSelectCollSeq(pParse, p, i);\n      if( 0==*apColl ){\n        *apColl = db->pDfltColl;\n      }\n    }\n\n    for(pLoop=p; pLoop; pLoop=pLoop->pPrior){\n      for(i=0; i<2; i++){\n        int addr = pLoop->addrOpenEphm[i];\n        if( addr<0 ){\n          /* If [0] is unused then [1] is also unused.  So we can\n          ** always safely abort as soon as the first unused slot is found */\n          assert( pLoop->addrOpenEphm[1]<0 );\n          break;\n        }\n        sqlite3VdbeChangeP2(v, addr, nCol);\n        sqlite3VdbeChangeP4(v, addr, (char*)sqlite3KeyInfoRef(pKeyInfo),\n                            P4_KEYINFO);\n        pLoop->addrOpenEphm[i] = -1;\n      }\n    }\n    sqlite3KeyInfoUnref(pKeyInfo);\n  }\n\nmulti_select_end:\n  pDest->iSdst = dest.iSdst;\n  pDest->nSdst = dest.nSdst;\n  sqlite3SelectDelete(db, pDelete);\n  return rc;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 902,
    "critical_vars": [
      "pDup->u.zToken"
    ],
    "function": "*exprListAppendList",
    "filename": "sqlite/CVE-2019-19880/CVE-2019-19880_CWE-476_75e95e1fcd52d3ec8282edb75ac8cd0814095d54_window.c.diff",
    "function_code": "static ExprList *exprListAppendList(\n  Parse *pParse,          /* Parsing context */\n  ExprList *pList,        /* List to which to append. Might be NULL */\n  ExprList *pAppend,      /* List of values to append. Might be NULL */\n  int bIntToNull\n){\n  if( pAppend ){\n    int i;\n    int nInit = pList ? pList->nExpr : 0;\n    for(i=0; i<pAppend->nExpr; i++){\n      Expr *pDup = sqlite3ExprDup(pParse->db, pAppend->a[i].pExpr, 0);\n      assert( pDup==0 || !ExprHasProperty(pDup, EP_MemToken) );\n      if( bIntToNull && pDup && pDup->op==TK_INTEGER ){\n        pDup->op = TK_NULL;\n        pDup->flags &= ~(EP_IntValue|EP_IsTrue|EP_IsFalse);\n        pDup->u.zToken = 0;\n      }\n      pList = sqlite3ExprListAppend(pParse, pList, pDup);\n      if( pList ) pList->a[nInit+i].sortFlags = pAppend->a[i].sortFlags;\n    }\n  }\n  return pList;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 173,
    "critical_vars": [
      "msr->txcfg->reqbody_buffering"
    ],
    "function": "modsecurity_request_body_store_memory",
    "filename": "ModSecurity/CVE-2013-2765/CVE-2013-2765_CWE-476_0840b13612a0b7ef1ce7441cf811dcfc6b463fba_msc_reqbody.c.diff",
    "function_code": "static apr_status_t modsecurity_request_body_store_memory(modsec_rec *msr,\n    const char *data, apr_size_t length, char **error_msg)\n{\n    *error_msg = NULL;\n\n    /* Would storing this chunk mean going over the limit? */\n    if ((msr->msc_reqbody_spilltodisk)\n        && (msr->txcfg->reqbody_buffering != REQUEST_BODY_FORCEBUF_ON)\n        && (msr->msc_reqbody_length + length > (apr_size_t)msr->txcfg->reqbody_inmemory_limit))\n    {\n        msc_data_chunk **chunks;\n        unsigned int disklen = 0;\n        int i;\n\n        msr_log(msr, 4, \"Input filter: Request too large to store in memory, switching to disk.\");\n\n        /* NOTE Must use modsecurity_request_body_store_disk() here\n         *      to prevent data to be sent to the streaming\n         *      processors again.\n         */\n\n        /* Initialise disk storage */\n        msr->msc_reqbody_storage = MSC_REQBODY_DISK;\n        if (modsecurity_request_body_start_init(msr, error_msg) < 0) return -1;\n\n        /* Write the data we keep in memory */\n        chunks = (msc_data_chunk **)msr->msc_reqbody_chunks->elts;\n        for(i = 0; i < msr->msc_reqbody_chunks->nelts; i++) {\n            disklen += chunks[i]->length;\n\n            if (modsecurity_request_body_store_disk(msr, chunks[i]->data, chunks[i]->length, error_msg) < 0) {\n                return -1;\n            }\n\n            free(chunks[i]->data);\n            chunks[i]->data = NULL;\n        }\n\n        /* Clear the memory pool as we no longer need the bits. */\n\n        /* IMP1 But since we only used apr_pool_clear memory might\n         * not be released back to the OS straight away?\n         */\n        msr->msc_reqbody_chunks = NULL;\n        apr_pool_clear(msr->msc_reqbody_mp);\n\n        msr_log(msr, 4, \"Input filter: Wrote %u bytes from memory to disk.\", disklen);\n\n        /* Continue with disk storage from now on */\n        return modsecurity_request_body_store_disk(msr, data, length, error_msg);\n    }\n\n    /* If we're here that means we are not over the\n     * request body in-memory limit yet.\n     */\n    {\n        unsigned long int bucket_offset, bucket_left;\n\n        bucket_offset = 0;\n        bucket_left = length;\n\n        /* Although we store the request body in chunks we don't\n         * want to use the same chunk sizes as the incoming memory\n         * buffers. They are often of very small sizes and that\n         * would make us waste a lot of memory. That's why we\n         * use our own chunks of CHUNK_CAPACITY sizes.\n         */\n\n        /* Loop until we empty this bucket into our chunks. */\n        while(bucket_left > 0) {\n            /* Allocate a new chunk if we have to. */\n            if (msr->msc_reqbody_chunk_current == NULL) {\n                msr->msc_reqbody_chunk_current = (msc_data_chunk *)\n                    apr_pcalloc(msr->msc_reqbody_mp, sizeof(msc_data_chunk));\n                if (msr->msc_reqbody_chunk_current == NULL) {\n                    *error_msg = apr_psprintf(msr->mp, \"Input filter: Failed to allocate %lu bytes \"\n                        \"for request body chunk.\", (unsigned long)sizeof(msc_data_chunk));\n                    return -1;\n                }\n\n                msr->msc_reqbody_chunk_current->data = malloc(CHUNK_CAPACITY);\n                if (msr->msc_reqbody_chunk_current->data == NULL) {\n                    *error_msg = apr_psprintf(msr->mp, \"Input filter: Failed to allocate %d bytes \"\n                        \"for request body chunk data.\", CHUNK_CAPACITY);\n                    return -1;\n                }\n\n                msr->msc_reqbody_chunk_current->length = 0;\n                msr->msc_reqbody_chunk_current->is_permanent = 1;\n\n                *(const msc_data_chunk **)apr_array_push(msr->msc_reqbody_chunks)\n                    = msr->msc_reqbody_chunk_current;\n            }\n\n            if (bucket_left < (CHUNK_CAPACITY - msr->msc_reqbody_chunk_current->length)) {\n                /* There's enough space in the current chunk. */\n                memcpy(msr->msc_reqbody_chunk_current->data +\n                    msr->msc_reqbody_chunk_current->length, data + bucket_offset, bucket_left);\n                msr->msc_reqbody_chunk_current->length += bucket_left;\n                bucket_left = 0;\n            } else {\n                /* Fill the existing chunk. */\n                unsigned long int copy_length = CHUNK_CAPACITY -\n                    msr->msc_reqbody_chunk_current->length;\n\n                memcpy(msr->msc_reqbody_chunk_current->data +\n                    msr->msc_reqbody_chunk_current->length, data + bucket_offset, copy_length);\n                bucket_offset += copy_length;\n                bucket_left -= copy_length;\n                msr->msc_reqbody_chunk_current->length += copy_length;\n\n                /* We're done with this chunk. Setting the pointer\n                 * to NULL is going to force a new chunk to be allocated\n                 * on the next go.\n                 */\n                msr->msc_reqbody_chunk_current = NULL;\n            }\n        }\n\n        msr->msc_reqbody_length += length;\n    }\n\n    return 1;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 202,
    "critical_vars": [
      "usb_conv_info->class_data_type"
    ],
    "function": "dissect_usb_ms_bulk",
    "filename": "wireshark/CVE-2016-5354/CVE-2016-5354_CWE-476_2cb5985bf47bdc8bea78d28483ed224abdd33dc6_packet-usb-masstorage.c.diff",
    "function_code": "dissect_usb_ms_bulk(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, void* data)\n{\n    usb_conv_info_t *usb_conv_info;\n    usb_ms_conv_info_t *usb_ms_conv_info;\n    proto_tree *tree;\n    proto_item *ti;\n    guint32 signature=0;\n    int offset=0;\n    gboolean is_request;\n    itl_nexus_t *itl;\n    itlq_nexus_t *itlq;\n\n    /* Reject the packet if data is NULL */\n    if (data == NULL)\n        return 0;\n    usb_conv_info = (usb_conv_info_t *)data;\n\n    /* verify that we do have a usb_ms_conv_info */\n    usb_ms_conv_info=(usb_ms_conv_info_t *)usb_conv_info->class_data;\n    if(!usb_ms_conv_info){\n        usb_ms_conv_info=wmem_new(wmem_file_scope(), usb_ms_conv_info_t);\n        usb_ms_conv_info->itl=wmem_tree_new(wmem_file_scope());\n        usb_ms_conv_info->itlq=wmem_tree_new(wmem_file_scope());\n        usb_conv_info->class_data=usb_ms_conv_info;\n        usb_conv_info->class_data_type = USB_CONV_MASS_STORAGE;\n    } else if (usb_conv_info->class_data_type != USB_CONV_MASS_STORAGE) {\n        /* Don't dissect if another USB type is in the conversation */\n        return 0;\n    }\n\n    is_request=(pinfo->srcport==NO_ENDPOINT);\n\n    col_set_str(pinfo->cinfo, COL_PROTOCOL, \"USBMS\");\n\n    col_clear(pinfo->cinfo, COL_INFO);\n\n\n    ti = proto_tree_add_protocol_format(parent_tree, proto_usb_ms, tvb, 0, -1, \"USB Mass Storage\");\n    tree = proto_item_add_subtree(ti, ett_usb_ms);\n\n    signature=tvb_get_letohl(tvb, offset);\n\n\n    /*\n     * SCSI CDB inside CBW\n     */\n    if(is_request&&(signature==0x43425355)&&(tvb_reported_length(tvb)==31)){\n        tvbuff_t *cdb_tvb;\n        int cdbrlen, cdblen;\n        guint8 lun, flags;\n        guint32 datalen;\n\n        /* dCBWSignature */\n        proto_tree_add_item(tree, hf_usb_ms_dCBWSignature, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n        offset+=4;\n\n        /* dCBWTag */\n        proto_tree_add_item(tree, hf_usb_ms_dCBWTag, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n        offset+=4;\n\n        /* dCBWDataTransferLength */\n        proto_tree_add_item(tree, hf_usb_ms_dCBWDataTransferLength, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n        datalen=tvb_get_letohl(tvb, offset);\n        offset+=4;\n\n        /* dCBWFlags */\n        proto_tree_add_item(tree, hf_usb_ms_dCBWFlags, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        flags=tvb_get_guint8(tvb, offset);\n        offset+=1;\n\n        /* dCBWLUN */\n        proto_tree_add_item(tree, hf_usb_ms_dCBWTarget, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        proto_tree_add_item(tree, hf_usb_ms_dCBWLUN, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        lun=tvb_get_guint8(tvb, offset)&0x0f;\n        offset+=1;\n\n        /* make sure we have a ITL structure for this LUN */\n        itl=(itl_nexus_t *)wmem_tree_lookup32(usb_ms_conv_info->itl, lun);\n        if(!itl){\n            itl=wmem_new(wmem_file_scope(), itl_nexus_t);\n            itl->cmdset=0xff;\n            itl->conversation=NULL;\n            wmem_tree_insert32(usb_ms_conv_info->itl, lun, itl);\n        }\n\n        /* make sure we have an ITLQ structure for this LUN/transaction */\n        itlq=(itlq_nexus_t *)wmem_tree_lookup32(usb_ms_conv_info->itlq, pinfo->num);\n        if(!itlq){\n            itlq=wmem_new(wmem_file_scope(), itlq_nexus_t);\n            itlq->lun=lun;\n            itlq->scsi_opcode=0xffff;\n            itlq->task_flags=0;\n            if(datalen){\n                if(flags&0x80){\n                    itlq->task_flags|=SCSI_DATA_READ;\n                } else {\n                    itlq->task_flags|=SCSI_DATA_WRITE;\n                }\n            }\n            itlq->data_length=datalen;\n            itlq->bidir_data_length=0;\n            itlq->fc_time=pinfo->abs_ts;\n            itlq->first_exchange_frame=pinfo->num;\n            itlq->last_exchange_frame=0;\n            itlq->flags=0;\n            itlq->alloc_len=0;\n            itlq->extra_data=NULL;\n            wmem_tree_insert32(usb_ms_conv_info->itlq, pinfo->num, itlq);\n        }\n\n        /* dCBWCBLength */\n        proto_tree_add_item(tree, hf_usb_ms_dCBWCBLength, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        cdbrlen=tvb_get_guint8(tvb, offset)&0x1f;\n        offset+=1;\n\n        cdblen=cdbrlen;\n        if(cdblen>tvb_captured_length_remaining(tvb, offset)){\n            cdblen=tvb_captured_length_remaining(tvb, offset);\n        }\n        if(cdblen){\n            cdb_tvb=tvb_new_subset(tvb, offset, cdblen, cdbrlen);\n            dissect_scsi_cdb(cdb_tvb, pinfo, parent_tree, SCSI_DEV_UNKNOWN, itlq, itl);\n        }\n        return tvb_captured_length(tvb);\n    }\n\n\n    /*\n     * SCSI RESPONSE inside CSW\n     */\n    if((!is_request)&&(signature==0x53425355)&&(tvb_reported_length(tvb)==13)){\n        guint8 status;\n\n        /* dCSWSignature */\n        proto_tree_add_item(tree, hf_usb_ms_dCSWSignature, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n        offset+=4;\n\n        /* dCSWTag */\n        proto_tree_add_item(tree, hf_usb_ms_dCBWTag, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n        offset+=4;\n\n        /* dCSWDataResidue */\n        proto_tree_add_item(tree, hf_usb_ms_dCSWDataResidue, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n        offset+=4;\n\n        /* dCSWStatus */\n        proto_tree_add_item(tree, hf_usb_ms_dCSWStatus, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        status=tvb_get_guint8(tvb, offset);\n        /*offset+=1;*/\n\n        itlq=(itlq_nexus_t *)wmem_tree_lookup32_le(usb_ms_conv_info->itlq, pinfo->num);\n        if(!itlq){\n            return tvb_captured_length(tvb);\n        }\n        itlq->last_exchange_frame=pinfo->num;\n\n        itl=(itl_nexus_t *)wmem_tree_lookup32(usb_ms_conv_info->itl, itlq->lun);\n        if(!itl){\n            return tvb_captured_length(tvb);\n        }\n\n        if(!status){\n            dissect_scsi_rsp(tvb, pinfo, parent_tree, itlq, itl, 0);\n        } else {\n            /* just send \"check condition\" */\n            dissect_scsi_rsp(tvb, pinfo, parent_tree, itlq, itl, 0x02);\n        }\n        return tvb_captured_length(tvb);\n    }\n\n    /*\n     * Ok it was neither CDB not STATUS so just assume it is either data in/out\n     */\n    itlq=(itlq_nexus_t *)wmem_tree_lookup32_le(usb_ms_conv_info->itlq, pinfo->num);\n    if(!itlq){\n        return tvb_captured_length(tvb);\n    }\n\n    itl=(itl_nexus_t *)wmem_tree_lookup32(usb_ms_conv_info->itl, itlq->lun);\n    if(!itl){\n        return tvb_captured_length(tvb);\n    }\n\n    dissect_scsi_payload(tvb, pinfo, parent_tree, is_request, itlq, itl, 0);\n    return tvb_captured_length(tvb);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 1686,
    "critical_vars": [
      "usb_conv_info->class_data_type"
    ],
    "function": "dissect_u3v",
    "filename": "wireshark/CVE-2016-5354/CVE-2016-5354_CWE-476_2cb5985bf47bdc8bea78d28483ed224abdd33dc6_packet-u3v.c.diff",
    "function_code": "dissect_u3v(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\n{\n    gint offset = 0;\n    proto_tree *u3v_tree = NULL, *ccd_tree_flag, *u3v_telegram_tree = NULL, *ccd_tree = NULL;\n    gint data_length = 0;\n    gint req_id = 0;\n    gint command_id = -1;\n    gint status = 0;\n    guint prefix = 0;\n    proto_item *ti = NULL;\n    proto_item *item = NULL;\n    const char *command_string;\n    usb_conv_info_t *usb_conv_info;\n    gint stream_detected = FALSE;\n    gint control_detected = FALSE;\n    u3v_conv_info_t *u3v_conv_info = NULL;\n    gencp_transaction_t *gencp_trans = NULL;\n\n    usb_conv_info = (usb_conv_info_t *)data;\n\n    /* decide if this packet belongs to U3V protocol */\n    u3v_conv_info = (u3v_conv_info_t *)usb_conv_info->class_data;\n\n    if (!u3v_conv_info) {\n        u3v_conv_info = wmem_new0(wmem_file_scope(), u3v_conv_info_t);\n        usb_conv_info->class_data = u3v_conv_info;\n        usb_conv_info->class_data_type = USB_CONV_U3V;\n    } else if (usb_conv_info->class_data_type != USB_CONV_U3V) {\n        /* Don't dissect if another USB type is in the conversation */\n        return 0;\n    }\n\n    prefix = tvb_get_letohl(tvb, 0);\n    if ((tvb_reported_length(tvb) >= 4) && ( ( U3V_CONTROL_PREFIX == prefix ) || ( U3V_EVENT_PREFIX == prefix ) ) ) {\n        control_detected = TRUE;\n    }\n\n    if (((tvb_reported_length(tvb) >= 4) && (( U3V_STREAM_LEADER_PREFIX == prefix ) || ( U3V_STREAM_TRAILER_PREFIX == prefix )))\n         || (usb_conv_info->endpoint == u3v_conv_info->ep_stream)) {\n        stream_detected = TRUE;\n    }\n\n    /* initialize interface class/subclass in case no descriptors have been dissected yet */\n    if ( control_detected || stream_detected){\n        if ( usb_conv_info->interfaceClass  == IF_CLASS_UNKNOWN &&\n             usb_conv_info->interfaceSubclass  == IF_SUBCLASS_UNKNOWN){\n            usb_conv_info->interfaceClass = IF_CLASS_MISCELLANEOUS;\n            usb_conv_info->interfaceSubclass = IF_SUBCLASS_MISC_U3V;\n        }\n    }\n\n    if ( control_detected ) {\n        /* Set the protocol column */\n        col_set_str(pinfo->cinfo, COL_PROTOCOL, \"U3V\");\n\n        /* Clear out stuff in the info column */\n        col_clear(pinfo->cinfo, COL_INFO);\n\n        /* Adds \"USB3Vision\" heading to protocol tree */\n        /* We will add fields to this using the u3v_tree pointer */\n        ti = proto_tree_add_item(tree, proto_u3v, tvb, offset, -1, ENC_NA);\n        u3v_tree = proto_item_add_subtree(ti, ett_u3v);\n\n        prefix = tvb_get_letohl(tvb, offset);\n        command_id = tvb_get_letohs(tvb, offset+6);\n\n        /* decode CCD ( DCI/DCE command data layout) */\n        if ((prefix == U3V_CONTROL_PREFIX || prefix == U3V_EVENT_PREFIX) && ((command_id % 2) == 0)) {\n            command_string = val_to_str(command_id,command_names,\"Unknown Command (0x%x)\");\n            item = proto_tree_add_item(u3v_tree, hf_u3v_ccd_cmd, tvb, offset, 8, ENC_NA);\n            proto_item_append_text(item, \": %s\", command_string);\n            ccd_tree = proto_item_add_subtree(item, ett_u3v_cmd);\n\n            /* Add the prefix code: */\n            proto_tree_add_item(ccd_tree, hf_u3v_gencp_prefix, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            offset += 4;\n\n            /* Add the flags */\n            item = proto_tree_add_item(ccd_tree, hf_u3v_flag, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n            ccd_tree_flag  = proto_item_add_subtree(item, ett_u3v_flags);\n            proto_tree_add_item(ccd_tree_flag, hf_u3v_acknowledge_required_flag, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n\n            offset += 2;\n            col_append_fstr(pinfo->cinfo, COL_INFO, \"> %s \", command_string);\n        } else if (prefix == U3V_CONTROL_PREFIX && ((command_id % 2) == 1)) {\n            command_string = val_to_str(command_id,command_names,\"Unknown Acknowledge (0x%x)\");\n            item = proto_tree_add_item(u3v_tree, hf_u3v_ccd_ack, tvb, offset, 8, ENC_NA);\n            proto_item_append_text(item, \": %s\", command_string);\n            ccd_tree = proto_item_add_subtree(item, ett_u3v_ack);\n\n            /* Add the prefix code: */\n            proto_tree_add_item(ccd_tree, hf_u3v_gencp_prefix, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            offset += 4;\n\n            /* Add the status: */\n            proto_tree_add_item(ccd_tree, hf_u3v_status, tvb, offset, 2,ENC_LITTLE_ENDIAN);\n            status = tvb_get_letohs(tvb, offset);\n            offset += 2;\n            col_append_fstr(pinfo->cinfo, COL_INFO, \"< %s %s\",\n                    command_string,\n                    val_to_str(status, status_names_short, \"Unknown status (0x%04X)\"));\n        } else {\n            return 0;\n        }\n\n        /* Add the command id*/\n        proto_tree_add_item(ccd_tree, hf_u3v_command_id, tvb, offset, 2,ENC_LITTLE_ENDIAN);\n        offset += 2;\n\n        /* Parse the second part of both the command and the acknowledge header:\n        0          15 16         31\n        -------- -------- -------- --------\n        |     status      |   acknowledge   |\n        -------- -------- -------- --------\n        |     length      |      req_id     |\n        -------- -------- -------- --------\n\n        Add the data length\n        Number of valid data bytes in this message, not including this header. This\n        represents the number of bytes of payload appended after this header */\n\n        proto_tree_add_item(ccd_tree, hf_u3v_length, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n        data_length = tvb_get_letohs(tvb, offset);\n        offset += 2;\n\n        /* Add the request ID */\n        proto_tree_add_item(ccd_tree, hf_u3v_request_id, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n        req_id = tvb_get_letohs(tvb, offset);\n        offset += 2;\n\n        /* Add telegram subtree */\n        u3v_telegram_tree = proto_item_add_subtree(u3v_tree, ett_u3v);\n\n        if (!PINFO_FD_VISITED(pinfo)) {\n              if ((command_id % 2) == 0) {\n                    /* This is a command */\n                    gencp_trans = wmem_new(wmem_file_scope(), gencp_transaction_t);\n                    gencp_trans->cmd_frame = pinfo->fd->num;\n                    gencp_trans->ack_frame = 0;\n                    gencp_trans->cmd_time = pinfo->fd->abs_ts;\n                    /* add reference to current packet */\n                    p_add_proto_data(wmem_file_scope(), pinfo, proto_u3v, req_id, gencp_trans);\n                    /* add reference to current */\n                    u3v_conv_info->trans_info = gencp_trans;\n                } else {\n                    gencp_trans = u3v_conv_info->trans_info;\n                    if (gencp_trans) {\n                        gencp_trans->ack_frame = pinfo->fd->num;\n                        /* add reference to current packet */\n                        p_add_proto_data(wmem_file_scope(), pinfo, proto_u3v, req_id, gencp_trans);\n                    }\n                }\n         } else {\n            gencp_trans = (gencp_transaction_t*)p_get_proto_data(wmem_file_scope(),pinfo, proto_u3v, req_id);\n         }\n\n        if (!gencp_trans) {\n            /* create a \"fake\" gencp_trans structure */\n            gencp_trans = wmem_new(wmem_packet_scope(), gencp_transaction_t);\n            gencp_trans->cmd_frame = 0;\n            gencp_trans->ack_frame = 0;\n            gencp_trans->cmd_time = pinfo->fd->abs_ts;\n        }\n\n        /* dissect depending on command? */\n        switch (command_id) {\n        case U3V_READMEM_CMD:\n            dissect_u3v_read_mem_cmd(u3v_telegram_tree, tvb, pinfo, offset, data_length,u3v_conv_info,gencp_trans);\n            break;\n        case U3V_WRITEMEM_CMD:\n            dissect_u3v_write_mem_cmd(u3v_telegram_tree, tvb, pinfo, offset, data_length,u3v_conv_info,gencp_trans);\n            break;\n        case U3V_EVENT_CMD:\n            dissect_u3v_event_cmd(u3v_telegram_tree, tvb, pinfo, offset, data_length);\n            break;\n        case U3V_READMEM_ACK:\n            if ( U3V_STATUS_GENCP_SUCCESS == status ) {\n                dissect_u3v_read_mem_ack(u3v_telegram_tree, tvb, pinfo, offset, data_length,u3v_conv_info,gencp_trans);\n            }\n            break;\n        case U3V_WRITEMEM_ACK:\n            dissect_u3v_write_mem_ack(u3v_telegram_tree, tvb, pinfo, offset, data_length, u3v_conv_info,gencp_trans);\n            break;\n        case U3V_PENDING_ACK:\n            dissect_u3v_pending_ack(u3v_telegram_tree, tvb, pinfo, offset, data_length, u3v_conv_info,gencp_trans);\n            break;\n        default:\n            proto_tree_add_item(u3v_telegram_tree, hf_u3v_payloaddata, tvb, offset, data_length, ENC_NA);\n            break;\n        }\n        return data_length + 12;\n    } else if ( stream_detected ) {\n        /* this is streaming data */\n\n        /* init this stream configuration */\n        u3v_conv_info = (u3v_conv_info_t *)usb_conv_info->class_data;\n        u3v_conv_info->ep_stream = usb_conv_info->endpoint;\n\n        /* Set the protocol column */\n        col_set_str(pinfo->cinfo, COL_PROTOCOL, \"U3V\");\n\n        /* Clear out stuff in the info column */\n        col_clear(pinfo->cinfo, COL_INFO);\n\n        /* Adds \"USB3Vision\" heading to protocol tree */\n        /* We will add fields to this using the u3v_tree pointer */\n        ti = proto_tree_add_item(tree, proto_u3v, tvb, offset, -1, ENC_NA);\n        u3v_tree = proto_item_add_subtree(ti, ett_u3v);\n\n        if(tvb_captured_length(tvb) >=4) {\n            prefix = tvb_get_letohl(tvb, offset);\n            switch (prefix) {\n            case U3V_STREAM_LEADER_PREFIX:\n                dissect_u3v_stream_leader(u3v_tree, tvb, pinfo, usb_conv_info);\n                break;\n            case U3V_STREAM_TRAILER_PREFIX:\n                dissect_u3v_stream_trailer(u3v_tree, tvb, pinfo, usb_conv_info);\n                break;\n            default:\n                dissect_u3v_stream_payload(u3v_tree, tvb, pinfo, usb_conv_info);\n                break;\n            }\n        }\n        return tvb_captured_length(tvb);\n    }\n    return 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 438,
    "critical_vars": [
      "usb_conv_info->class_data_type"
    ],
    "function": "dissect_ac_if_hdr_body",
    "filename": "wireshark/CVE-2016-5354/CVE-2016-5354_CWE-476_2cb5985bf47bdc8bea78d28483ed224abdd33dc6_packet-usb-audio.c.diff",
    "function_code": "dissect_ac_if_hdr_body(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,\n        proto_tree *tree, usb_conv_info_t *usb_conv_info)\n{\n    gint     offset_start;\n    guint16  bcdADC;\n    guint8   ver_major;\n    double   ver;\n    guint8   if_in_collection, i;\n    audio_conv_info_t *audio_conv_info;\n\n\n    offset_start = offset;\n\n    bcdADC = tvb_get_letohs(tvb, offset);\n    ver_major = USB_AUDIO_BCD44_TO_DEC(bcdADC>>8);\n    ver = ver_major + USB_AUDIO_BCD44_TO_DEC(bcdADC&0xFF) / 100.0;\n\n    proto_tree_add_double_format_value(tree, hf_ac_if_hdr_ver,\n            tvb, offset, 2, ver, \"%2.2f\", ver);\n    audio_conv_info = (audio_conv_info_t *)usb_conv_info->class_data;\n    if(!audio_conv_info) {\n        audio_conv_info = wmem_new(wmem_file_scope(), audio_conv_info_t);\n        usb_conv_info->class_data = audio_conv_info;\n        usb_conv_info->class_data_type = USB_CONV_AUDIO;\n        /* XXX - set reasonable default values for all components\n           that are not filled in by this function */\n    } else if (usb_conv_info->class_data_type != USB_CONV_AUDIO) {\n        /* Don't dissect if another USB type is in the conversation */\n        return 0;\n    }\n    audio_conv_info->ver_major = ver_major;\n    offset += 2;\n\n    /* version 1 refers to the Basic Audio Device specification,\n       version 2 is the Audio Device class specification, see above */\n    if (ver_major==1) {\n        proto_tree_add_item(tree, hf_ac_if_hdr_total_len,\n                tvb, offset, 2, ENC_LITTLE_ENDIAN);\n        offset += 2;\n        if_in_collection = tvb_get_guint8(tvb, offset);\n        proto_tree_add_item(tree, hf_ac_if_hdr_bInCollection,\n                tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        offset++;\n\n        for (i=0; i<if_in_collection; i++) {\n            proto_tree_add_item(tree, hf_ac_if_hdr_if_num,\n                    tvb, offset, 1, ENC_LITTLE_ENDIAN);\n            offset++;\n        }\n    }\n\n    return offset-offset_start;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 1038,
    "critical_vars": [
      "usb_conv_info->class_data_type"
    ],
    "function": "dissect_usb_video_control_interface_descriptor",
    "filename": "wireshark/CVE-2016-5354/CVE-2016-5354_CWE-476_2cb5985bf47bdc8bea78d28483ed224abdd33dc6_packet-usb-video.c.diff",
    "function_code": "dissect_usb_video_control_interface_descriptor(proto_tree *parent_tree, tvbuff_t *tvb,\n                                               guint8 descriptor_len, packet_info *pinfo, usb_conv_info_t *usb_conv_info)\n{\n    video_conv_info_t *video_conv_info = NULL;\n    video_entity_t    *entity          = NULL;\n    proto_item *item          = NULL;\n    proto_item *subtype_item  = NULL;\n    proto_tree *tree          = NULL;\n    guint8      entity_id     = 0;\n    guint16     terminal_type = 0;\n    int         offset        = 0;\n    guint8      subtype;\n\n    subtype = tvb_get_guint8(tvb, offset+2);\n\n    if (parent_tree)\n    {\n        const gchar *subtype_str;\n\n        subtype_str = val_to_str_ext(subtype, &vc_if_descriptor_subtypes_ext, \"Unknown (0x%x)\");\n\n        tree = proto_tree_add_subtree_format(parent_tree, tvb, offset, descriptor_len,\n                                   ett_descriptor_video_control, &item, \"VIDEO CONTROL INTERFACE DESCRIPTOR [%s]\",\n                                   subtype_str);\n    }\n\n    /* Common fields */\n    dissect_usb_descriptor_header(tree, tvb, offset, &vid_descriptor_type_vals_ext);\n    subtype_item = proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_subtype, tvb, offset+2, 1, ENC_LITTLE_ENDIAN);\n    offset += 3;\n\n    if (subtype == VC_HEADER)\n    {\n        guint8 num_vs_interfaces;\n\n        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_bcdUVC,            tvb, offset,   2, ENC_LITTLE_ENDIAN);\n        proto_tree_add_item(tree, hf_usb_vid_ifdesc_wTotalLength,              tvb, offset+2, 2, ENC_LITTLE_ENDIAN);\n        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_dwClockFrequency,  tvb, offset+4, 4, ENC_LITTLE_ENDIAN);\n\n        num_vs_interfaces = tvb_get_guint8(tvb, offset+8);\n        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_bInCollection,     tvb, offset+8, 1, ENC_LITTLE_ENDIAN);\n\n        if (num_vs_interfaces > 0)\n        {\n            proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_baInterfaceNr, tvb, offset+9, num_vs_interfaces, ENC_NA);\n        }\n\n        offset += 9 + num_vs_interfaces;\n    }\n    else if ((subtype == VC_INPUT_TERMINAL) || (subtype == VC_OUTPUT_TERMINAL))\n    {\n        /* Fields common to input and output terminals */\n        entity_id     = tvb_get_guint8(tvb, offset);\n        terminal_type = tvb_get_letohs(tvb, offset+1);\n\n        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_terminal_id,    tvb, offset,   1, ENC_LITTLE_ENDIAN);\n        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_terminal_type,  tvb, offset+1, 2, ENC_LITTLE_ENDIAN);\n        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_assoc_terminal, tvb, offset+3, 1, ENC_LITTLE_ENDIAN);\n        offset += 4;\n\n        if (subtype == VC_OUTPUT_TERMINAL)\n        {\n            proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_src_id, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n            ++offset;\n        }\n\n        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_iTerminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        ++offset;\n\n        if (subtype == VC_INPUT_TERMINAL)\n        {\n            if (terminal_type == ITT_CAMERA)\n            {\n                offset = dissect_usb_video_camera_terminal(tree, tvb, offset);\n            }\n            else if (terminal_type == ITT_MEDIA_TRANSPORT_INPUT)\n            {\n                /* @todo */\n            }\n        }\n\n        if (subtype == VC_OUTPUT_TERMINAL)\n        {\n            if (terminal_type == OTT_MEDIA_TRANSPORT_OUTPUT)\n            {\n                /* @todo */\n            }\n        }\n    }\n    else\n    {\n        /* Field common to extension / processing / selector / encoding units */\n        entity_id = tvb_get_guint8(tvb, offset);\n        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_unit_id, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        ++offset;\n\n        if (subtype == VC_PROCESSING_UNIT)\n        {\n            offset = dissect_usb_video_processing_unit(tree, tvb, offset);\n        }\n        else if (subtype == VC_SELECTOR_UNIT)\n        {\n            offset = dissect_usb_video_selector_unit(tree, tvb, offset);\n        }\n        else if (subtype == VC_EXTENSION_UNIT)\n        {\n            offset = dissect_usb_video_extension_unit(tree, tvb, offset);\n        }\n        else if (subtype == VC_ENCODING_UNIT)\n        {\n            /* @todo UVC 1.5 */\n        }\n        else\n        {\n            expert_add_info_format(pinfo, subtype_item, &ei_usb_vid_subtype_unknown,\n                                   \"Unknown VC subtype %u\", subtype);\n        }\n    }\n\n    /* Soak up descriptor bytes beyond those we know how to dissect */\n    if (offset < descriptor_len)\n    {\n        proto_tree_add_item(tree, hf_usb_vid_descriptor_data, tvb, offset, descriptor_len-offset, ENC_NA);\n        /* offset = descriptor_len; */\n    }\n\n    if (entity_id != 0)\n        proto_item_append_text(item, \" (Entity %d)\", entity_id);\n\n    if (subtype != VC_HEADER && usb_conv_info)\n    {\n        /* Switch to the usb_conv_info of the Video Control interface */\n        usb_conv_info = get_usb_iface_conv_info(pinfo, usb_conv_info->interfaceNum);\n        video_conv_info = (video_conv_info_t *)usb_conv_info->class_data;\n\n        if (!video_conv_info)\n        {\n            video_conv_info = wmem_new(wmem_file_scope(), video_conv_info_t);\n            video_conv_info->entities = wmem_tree_new(wmem_file_scope());\n            usb_conv_info->class_data = video_conv_info;\n            usb_conv_info->class_data_type = USB_CONV_VIDEO;\n        } else if (usb_conv_info->class_data_type != USB_CONV_VIDEO) {\n            /* Stop dissection if another USB type is in the conversation */\n            return descriptor_len;\n        }\n\n        entity = (video_entity_t*) wmem_tree_lookup32(video_conv_info->entities, entity_id);\n        if (!entity)\n        {\n            entity = wmem_new(wmem_file_scope(), video_entity_t);\n            entity->entityID     = entity_id;\n            entity->subtype      = subtype;\n            entity->terminalType = terminal_type;\n\n            wmem_tree_insert32(video_conv_info->entities, entity_id, entity);\n        }\n    }\n\n    return descriptor_len;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 204,
    "critical_vars": [
      "stats.gopher_reads"
    ],
    "function": "GetIoStats",
    "filename": "squid/CVE-2023-46728/CVE-2023-46728_CWE-476_6ea12e8fb590ac6959e9356a81aa3370576568c3_stat.cc.diff",
    "function_code": "GetIoStats(Mgr::IoActionData& stats)\n{\n    int i;\n\n    stats.http_reads = IOStats.Http.reads;\n\n    for (i = 0; i < IoStats::histSize; ++i) {\n        stats.http_read_hist[i] = IOStats.Http.read_hist[i];\n    }\n\n    stats.ftp_reads = IOStats.Ftp.reads;\n\n    for (i = 0; i < IoStats::histSize; ++i) {\n        stats.ftp_read_hist[i] = IOStats.Ftp.read_hist[i];\n    }\n\n    stats.gopher_reads = IOStats.Gopher.reads;\n\n    for (i = 0; i < IoStats::histSize; ++i) {\n        stats.gopher_read_hist[i] = IOStats.Gopher.read_hist[i];\n    }\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 241,
    "critical_vars": [
      "sentry"
    ],
    "function": "DumpIoStats",
    "filename": "squid/CVE-2023-46728/CVE-2023-46728_CWE-476_6ea12e8fb590ac6959e9356a81aa3370576568c3_stat.cc.diff",
    "function_code": "DumpIoStats(Mgr::IoActionData& stats, StoreEntry* sentry)\n{\n    int i;\n\n    storeAppendPrintf(sentry, \"HTTP I/O\\n\");\n    storeAppendPrintf(sentry, \"number of reads: %.0f\\n\", stats.http_reads);\n    storeAppendPrintf(sentry, \"Read Histogram:\\n\");\n\n    for (i = 0; i < IoStats::histSize; ++i) {\n        storeAppendPrintf(sentry, \"%5d-%5d: %9.0f %2.0f%%\\n\",\n                          i ? (1 << (i - 1)) + 1 : 1,\n                          1 << i,\n                          stats.http_read_hist[i],\n                          Math::doublePercent(stats.http_read_hist[i], stats.http_reads));\n    }\n\n    storeAppendPrintf(sentry, \"\\n\");\n    storeAppendPrintf(sentry, \"FTP I/O\\n\");\n    storeAppendPrintf(sentry, \"number of reads: %.0f\\n\", stats.ftp_reads);\n    storeAppendPrintf(sentry, \"Read Histogram:\\n\");\n\n    for (i = 0; i < IoStats::histSize; ++i) {\n        storeAppendPrintf(sentry, \"%5d-%5d: %9.0f %2.0f%%\\n\",\n                          i ? (1 << (i - 1)) + 1 : 1,\n                          1 << i,\n                          stats.ftp_read_hist[i],\n                          Math::doublePercent(stats.ftp_read_hist[i], stats.ftp_reads));\n    }\n\n    storeAppendPrintf(sentry, \"\\n\");\n    storeAppendPrintf(sentry, \"Gopher I/O\\n\");\n    storeAppendPrintf(sentry, \"number of reads: %.0f\\n\", stats.gopher_reads);\n    storeAppendPrintf(sentry, \"Read Histogram:\\n\");\n\n    for (i = 0; i < IoStats::histSize; ++i) {\n        storeAppendPrintf(sentry, \"%5d-%5d: %9.0f %2.0f%%\\n\",\n                          i ? (1 << (i - 1)) + 1 : 1,\n                          1 << i,\n                          stats.gopher_read_hist[i],\n                          Math::doublePercent(stats.gopher_read_hist[i], stats.gopher_reads));\n    }\n\n    storeAppendPrintf(sentry, \"\\n\");\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 1077,
    "critical_vars": [
      "*ipv6_hdr"
    ],
    "function": "_iphc_ipv6_encode",
    "filename": "RIOT/CVE-2023-33973/CVE-2023-33973_CWE-476_c9d7863e5664a169035038628029bb07e090c5ff_gnrc_sixlowpan_iphc.c.diff",
    "function_code": "static size_t _iphc_ipv6_encode(gnrc_pktsnip_t *pkt,\n                                const gnrc_netif_hdr_t *netif_hdr,\n                                gnrc_netif_t *iface,\n                                uint8_t *iphc_hdr)\n{\n    gnrc_sixlowpan_ctx_t *src_ctx = NULL, *dst_ctx = NULL;\n    ipv6_hdr_t *ipv6_hdr = pkt->next->data;\n    bool addr_comp = false;\n    uint16_t inline_pos = SIXLOWPAN_IPHC_HDR_LEN;\n\n    assert(iface != NULL);\n\n    /* set initial dispatch value*/\n    iphc_hdr[IPHC1_IDX] = SIXLOWPAN_IPHC1_DISP;\n    iphc_hdr[IPHC2_IDX] = 0;\n\n    /* check for available contexts */\n    if (!ipv6_addr_is_unspecified(&(ipv6_hdr->src))) {\n        src_ctx = gnrc_sixlowpan_ctx_lookup_addr(&(ipv6_hdr->src));\n        /* do not use source context for compression if */\n        /* GNRC_SIXLOWPAN_CTX_FLAGS_COMP is not set */\n        if (src_ctx && !(src_ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_COMP)) {\n            src_ctx = NULL;\n        }\n        /* prefix bits not covered by context information must be zero */\n        if (src_ctx &&\n            ipv6_addr_match_prefix(&src_ctx->prefix, &ipv6_hdr->src) < SIXLOWPAN_IPHC_PREFIX_LEN) {\n            src_ctx = NULL;\n        }\n    }\n\n    if (!ipv6_addr_is_multicast(&ipv6_hdr->dst)) {\n        dst_ctx = gnrc_sixlowpan_ctx_lookup_addr(&(ipv6_hdr->dst));\n        /* do not use destination context for compression if */\n        /* GNRC_SIXLOWPAN_CTX_FLAGS_COMP is not set */\n        if (dst_ctx && !(dst_ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_COMP)) {\n            dst_ctx = NULL;\n        }\n        /* prefix bits not covered by context information must be zero */\n        if (dst_ctx &&\n            ipv6_addr_match_prefix(&dst_ctx->prefix, &ipv6_hdr->dst) < SIXLOWPAN_IPHC_PREFIX_LEN) {\n            dst_ctx = NULL;\n        }\n    }\n\n    /* if contexts available and both != 0 */\n    /* since this moves inline_pos we have to do this ahead*/\n    if (((src_ctx != NULL) &&\n            ((src_ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_CID_MASK) != 0)) ||\n        ((dst_ctx != NULL) &&\n            ((dst_ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_CID_MASK) != 0))) {\n        /* add context identifier extension */\n        iphc_hdr[IPHC2_IDX] |= SIXLOWPAN_IPHC2_CID_EXT;\n        iphc_hdr[CID_EXT_IDX] = 0;\n\n        /* move position to behind CID extension */\n        inline_pos += SIXLOWPAN_IPHC_CID_EXT_LEN;\n    }\n\n    /* compress flow label and traffic class */\n    if (ipv6_hdr_get_fl(ipv6_hdr) == 0) {\n        if (ipv6_hdr_get_tc(ipv6_hdr) == 0) {\n            /* elide both traffic class and flow label */\n            iphc_hdr[IPHC1_IDX] |= IPHC_TF_ECN_ELIDE;\n        }\n        else {\n            /* elide flow label, traffic class (ECN + DSCP) inline (1 byte) */\n            iphc_hdr[IPHC1_IDX] |= IPHC_TF_ECN_DSCP;\n            iphc_hdr[inline_pos++] = ipv6_hdr_get_tc(ipv6_hdr);\n        }\n    }\n    else {\n        if (ipv6_hdr_get_tc_dscp(ipv6_hdr) == 0) {\n            /* elide DSCP, ECN + 2-bit pad + flow label inline (3 byte) */\n            iphc_hdr[IPHC1_IDX] |= IPHC_TF_ECN_FL;\n            iphc_hdr[inline_pos++] = (uint8_t)((ipv6_hdr_get_tc_ecn(ipv6_hdr) << 6) |\n                                               ((ipv6_hdr_get_fl(ipv6_hdr) & 0x000f0000) >> 16));\n        }\n        else {\n            /* ECN + DSCP + 4-bit pad + flow label (4 bytes) */\n            iphc_hdr[IPHC1_IDX] |= IPHC_TF_ECN_DSCP_FL;\n            iphc_hdr[inline_pos++] = ipv6_hdr_get_tc(ipv6_hdr);\n            iphc_hdr[inline_pos++] = (uint8_t)((ipv6_hdr_get_fl(ipv6_hdr) & 0x000f0000) >> 16);\n        }\n\n        /* copy remaining bytes of flow label */\n        iphc_hdr[inline_pos++] = (uint8_t)((ipv6_hdr_get_fl(ipv6_hdr) & 0x0000ff00) >> 8);\n        iphc_hdr[inline_pos++] = (uint8_t)(ipv6_hdr_get_fl(ipv6_hdr) & 0x000000ff);\n    }\n\n    /* check for compressible next header */\n    if (_compressible_nh(ipv6_hdr->nh)) {\n        iphc_hdr[IPHC1_IDX] |= SIXLOWPAN_IPHC1_NH;\n    }\n    else {\n        iphc_hdr[inline_pos++] = ipv6_hdr->nh;\n    }\n\n    /* compress hop limit */\n    switch (ipv6_hdr->hl) {\n        case 1:\n            iphc_hdr[IPHC1_IDX] |= IPHC_HL_1;\n            break;\n\n        case 64:\n            iphc_hdr[IPHC1_IDX] |= IPHC_HL_64;\n            break;\n\n        case 255:\n            iphc_hdr[IPHC1_IDX] |= IPHC_HL_255;\n            break;\n\n        default:\n            iphc_hdr[IPHC1_IDX] |= IPHC_HL_INLINE;\n            iphc_hdr[inline_pos++] = ipv6_hdr->hl;\n            break;\n    }\n\n    if (ipv6_addr_is_unspecified(&(ipv6_hdr->src))) {\n        iphc_hdr[IPHC2_IDX] |= IPHC_SAC_SAM_UNSPEC;\n    }\n    else {\n        if (src_ctx != NULL) {\n            /* stateful source address compression */\n            iphc_hdr[IPHC2_IDX] |= SIXLOWPAN_IPHC2_SAC;\n\n            if (((src_ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_CID_MASK) != 0)) {\n                iphc_hdr[CID_EXT_IDX] |= ((src_ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_CID_MASK) << 4);\n            }\n        }\n\n        if ((src_ctx != NULL) || ipv6_addr_is_link_local(&(ipv6_hdr->src))) {\n            eui64_t iid;\n            iid.uint64.u64 = 0;\n\n            gnrc_netif_acquire(iface);\n            if (gnrc_netif_ipv6_get_iid(iface, &iid) < 0) {\n                DEBUG(\"6lo iphc: could not get interface's IID\\n\");\n                gnrc_netif_release(iface);\n                return 0;\n            }\n            gnrc_netif_release(iface);\n\n            if ((ipv6_hdr->src.u64[1].u64 == iid.uint64.u64) ||\n                _context_overlaps_iid(src_ctx, &ipv6_hdr->src, &iid)) {\n                /* 0 bits. The address is derived from link-layer address */\n                iphc_hdr[IPHC2_IDX] |= IPHC_SAC_SAM_L2;\n                addr_comp = true;\n            }\n            else if ((byteorder_ntohl(ipv6_hdr->src.u32[2]) == 0x000000ff) &&\n                     (byteorder_ntohs(ipv6_hdr->src.u16[6]) == 0xfe00)) {\n                /* 16 bits. The address is derived using 16 bits carried inline */\n                iphc_hdr[IPHC2_IDX] |= IPHC_SAC_SAM_16;\n                memcpy(iphc_hdr + inline_pos, ipv6_hdr->src.u16 + 7, 2);\n                inline_pos += 2;\n                addr_comp = true;\n            }\n            else {\n                /* 64 bits. The address is derived using 64 bits carried inline */\n                iphc_hdr[IPHC2_IDX] |= IPHC_SAC_SAM_64;\n                memcpy(iphc_hdr + inline_pos, ipv6_hdr->src.u64 + 1, 8);\n                inline_pos += 8;\n                addr_comp = true;\n            }\n        }\n\n        if (!addr_comp) {\n            /* full address is carried inline */\n            iphc_hdr[IPHC2_IDX] |= IPHC_SAC_SAM_FULL;\n            memcpy(iphc_hdr + inline_pos, &ipv6_hdr->src, 16);\n            inline_pos += 16;\n        }\n    }\n\n    addr_comp = false;\n\n    /* M: Multicast compression */\n    if (ipv6_addr_is_multicast(&(ipv6_hdr->dst))) {\n        iphc_hdr[IPHC2_IDX] |= SIXLOWPAN_IPHC2_M;\n\n        /* if multicast address is of format ffXX::XXXX:XXXX:XXXX */\n        if ((ipv6_hdr->dst.u16[1].u16 == 0) &&\n            (ipv6_hdr->dst.u32[1].u32 == 0) &&\n            (ipv6_hdr->dst.u16[4].u16 == 0)) {\n            /* if multicast address is of format ff02::XX */\n            if ((ipv6_hdr->dst.u8[1] == 0x02) &&\n                (ipv6_hdr->dst.u32[2].u32 == 0) &&\n                (ipv6_hdr->dst.u16[6].u16 == 0) &&\n                (ipv6_hdr->dst.u8[14] == 0)) {\n                /* 8 bits. The address is derived using 8 bits carried inline */\n                iphc_hdr[IPHC2_IDX] |= IPHC_M_DAC_DAM_M_8;\n                iphc_hdr[inline_pos++] = ipv6_hdr->dst.u8[15];\n                addr_comp = true;\n            }\n            /* if multicast address is of format ffXX::XX:XXXX */\n            else if ((ipv6_hdr->dst.u16[5].u16 == 0) &&\n                     (ipv6_hdr->dst.u8[12] == 0)) {\n                /* 32 bits. The address is derived using 32 bits carried inline */\n                iphc_hdr[IPHC2_IDX] |= IPHC_M_DAC_DAM_M_32;\n                iphc_hdr[inline_pos++] = ipv6_hdr->dst.u8[1];\n                memcpy(iphc_hdr + inline_pos, ipv6_hdr->dst.u8 + 13, 3);\n                inline_pos += 3;\n                addr_comp = true;\n            }\n            /* if multicast address is of format ffXX::XX:XXXX:XXXX */\n            else if (ipv6_hdr->dst.u8[10] == 0) {\n                /* 48 bits. The address is derived using 48 bits carried inline */\n                iphc_hdr[IPHC2_IDX] |= IPHC_M_DAC_DAM_M_48;\n                iphc_hdr[inline_pos++] = ipv6_hdr->dst.u8[1];\n                memcpy(iphc_hdr + inline_pos, ipv6_hdr->dst.u8 + 11, 5);\n                inline_pos += 5;\n                addr_comp = true;\n            }\n        }\n        /* try unicast prefix based compression */\n        else {\n            gnrc_sixlowpan_ctx_t *ctx;\n            ipv6_addr_t unicast_prefix;\n            unicast_prefix.u16[0] = ipv6_hdr->dst.u16[2];\n            unicast_prefix.u16[1] = ipv6_hdr->dst.u16[3];\n            unicast_prefix.u16[2] = ipv6_hdr->dst.u16[4];\n            unicast_prefix.u16[3] = ipv6_hdr->dst.u16[5];\n\n            ctx = gnrc_sixlowpan_ctx_lookup_addr(&unicast_prefix);\n\n            if ((ctx != NULL) && (ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_COMP) &&\n                (ctx->prefix_len == ipv6_hdr->dst.u8[3])) {\n                /* Unicast prefix based IPv6 multicast address\n                 * (https://tools.ietf.org/html/rfc3306) with given context\n                 * for unicast prefix -> context based compression */\n                iphc_hdr[IPHC2_IDX] |= SIXLOWPAN_IPHC2_DAC;\n                if ((ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_CID_MASK) != 0) {\n                    iphc_hdr[CID_EXT_IDX] |= (ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_CID_MASK);\n                }\n                iphc_hdr[inline_pos++] = ipv6_hdr->dst.u8[1];\n                iphc_hdr[inline_pos++] = ipv6_hdr->dst.u8[2];\n                memcpy(iphc_hdr + inline_pos, ipv6_hdr->dst.u16 + 6, 4);\n                inline_pos += 4;\n                addr_comp = true;\n            }\n        }\n    }\n    else if (((dst_ctx != NULL) ||\n              ipv6_addr_is_link_local(&ipv6_hdr->dst)) && (netif_hdr->dst_l2addr_len > 0)) {\n        eui64_t iid;\n\n        if (dst_ctx != NULL) {\n            /* stateful destination address compression */\n            iphc_hdr[IPHC2_IDX] |= SIXLOWPAN_IPHC2_DAC;\n\n            if (((dst_ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_CID_MASK) != 0)) {\n                iphc_hdr[CID_EXT_IDX] |= (dst_ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_CID_MASK);\n            }\n        }\n\n        if (gnrc_netif_hdr_ipv6_iid_from_dst(iface, netif_hdr, &iid) < 0) {\n            DEBUG(\"6lo iphc: could not get destination's IID\\n\");\n            return 0;\n        }\n\n        if ((ipv6_hdr->dst.u64[1].u64 == iid.uint64.u64) ||\n            _context_overlaps_iid(dst_ctx, &(ipv6_hdr->dst), &iid)) {\n            /* 0 bits. The address is derived using the link-layer address */\n            iphc_hdr[IPHC2_IDX] |= IPHC_M_DAC_DAM_U_L2;\n            addr_comp = true;\n        }\n        else if ((byteorder_ntohl(ipv6_hdr->dst.u32[2]) == 0x000000ff) &&\n                 (byteorder_ntohs(ipv6_hdr->dst.u16[6]) == 0xfe00)) {\n            /* 16 bits. The address is derived using 16 bits carried inline */\n            iphc_hdr[IPHC2_IDX] |= IPHC_M_DAC_DAM_U_16;\n            memcpy(&(iphc_hdr[inline_pos]), &(ipv6_hdr->dst.u16[7]), 2);\n            inline_pos += 2;\n            addr_comp = true;\n        }\n        else {\n            /* 64 bits. The address is derived using 64 bits carried inline */\n            iphc_hdr[IPHC2_IDX] |= IPHC_M_DAC_DAM_U_64;\n            memcpy(&(iphc_hdr[inline_pos]), &(ipv6_hdr->dst.u8[8]), 8);\n            inline_pos += 8;\n            addr_comp = true;\n        }\n    }\n\n    if (!addr_comp) {\n        /* full destination address is carried inline */\n        iphc_hdr[IPHC2_IDX] |= IPHC_SAC_SAM_FULL;\n        memcpy(iphc_hdr + inline_pos, &ipv6_hdr->dst, 16);\n        inline_pos += 16;\n    }\n\n    return inline_pos;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 1077,
    "critical_vars": [
      "*ipv6_hdr"
    ],
    "function": "_iphc_ipv6_encode",
    "filename": "RIOT/CVE-2023-33973/CVE-2023-33973_CWE-476_c9d7863e5664a169035038628029bb07e090c5ff_gnrc_sixlowpan_iphc.c.diff",
    "function_code": "static size_t _iphc_ipv6_encode(gnrc_pktsnip_t *pkt,\n                                const gnrc_netif_hdr_t *netif_hdr,\n                                gnrc_netif_t *iface,\n                                uint8_t *iphc_hdr)\n{\n    gnrc_sixlowpan_ctx_t *src_ctx = NULL, *dst_ctx = NULL;\n    ipv6_hdr_t *ipv6_hdr;\n    bool addr_comp = false;\n    uint16_t inline_pos = SIXLOWPAN_IPHC_HDR_LEN;\n\n    assert(iface != NULL);\n\n    if (pkt->next == NULL) {\n        DEBUG(\"6lo iphc: packet missing header\\n\");\n        return 0;\n    }\n    ipv6_hdr = pkt->next->data;\n\n    /* set initial dispatch value*/\n    iphc_hdr[IPHC1_IDX] = SIXLOWPAN_IPHC1_DISP;\n    iphc_hdr[IPHC2_IDX] = 0;\n\n    /* check for available contexts */\n    if (!ipv6_addr_is_unspecified(&(ipv6_hdr->src))) {\n        src_ctx = gnrc_sixlowpan_ctx_lookup_addr(&(ipv6_hdr->src));\n        /* do not use source context for compression if */\n        /* GNRC_SIXLOWPAN_CTX_FLAGS_COMP is not set */\n        if (src_ctx && !(src_ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_COMP)) {\n            src_ctx = NULL;\n        }\n        /* prefix bits not covered by context information must be zero */\n        if (src_ctx &&\n            ipv6_addr_match_prefix(&src_ctx->prefix, &ipv6_hdr->src) < SIXLOWPAN_IPHC_PREFIX_LEN) {\n            src_ctx = NULL;\n        }\n    }\n\n    if (!ipv6_addr_is_multicast(&ipv6_hdr->dst)) {\n        dst_ctx = gnrc_sixlowpan_ctx_lookup_addr(&(ipv6_hdr->dst));\n        /* do not use destination context for compression if */\n        /* GNRC_SIXLOWPAN_CTX_FLAGS_COMP is not set */\n        if (dst_ctx && !(dst_ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_COMP)) {\n            dst_ctx = NULL;\n        }\n        /* prefix bits not covered by context information must be zero */\n        if (dst_ctx &&\n            ipv6_addr_match_prefix(&dst_ctx->prefix, &ipv6_hdr->dst) < SIXLOWPAN_IPHC_PREFIX_LEN) {\n            dst_ctx = NULL;\n        }\n    }\n\n    /* if contexts available and both != 0 */\n    /* since this moves inline_pos we have to do this ahead*/\n    if (((src_ctx != NULL) &&\n            ((src_ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_CID_MASK) != 0)) ||\n        ((dst_ctx != NULL) &&\n            ((dst_ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_CID_MASK) != 0))) {\n        /* add context identifier extension */\n        iphc_hdr[IPHC2_IDX] |= SIXLOWPAN_IPHC2_CID_EXT;\n        iphc_hdr[CID_EXT_IDX] = 0;\n\n        /* move position to behind CID extension */\n        inline_pos += SIXLOWPAN_IPHC_CID_EXT_LEN;\n    }\n\n    /* compress flow label and traffic class */\n    if (ipv6_hdr_get_fl(ipv6_hdr) == 0) {\n        if (ipv6_hdr_get_tc(ipv6_hdr) == 0) {\n            /* elide both traffic class and flow label */\n            iphc_hdr[IPHC1_IDX] |= IPHC_TF_ECN_ELIDE;\n        }\n        else {\n            /* elide flow label, traffic class (ECN + DSCP) inline (1 byte) */\n            iphc_hdr[IPHC1_IDX] |= IPHC_TF_ECN_DSCP;\n            iphc_hdr[inline_pos++] = ipv6_hdr_get_tc(ipv6_hdr);\n        }\n    }\n    else {\n        if (ipv6_hdr_get_tc_dscp(ipv6_hdr) == 0) {\n            /* elide DSCP, ECN + 2-bit pad + flow label inline (3 byte) */\n            iphc_hdr[IPHC1_IDX] |= IPHC_TF_ECN_FL;\n            iphc_hdr[inline_pos++] = (uint8_t)((ipv6_hdr_get_tc_ecn(ipv6_hdr) << 6) |\n                                               ((ipv6_hdr_get_fl(ipv6_hdr) & 0x000f0000) >> 16));\n        }\n        else {\n            /* ECN + DSCP + 4-bit pad + flow label (4 bytes) */\n            iphc_hdr[IPHC1_IDX] |= IPHC_TF_ECN_DSCP_FL;\n            iphc_hdr[inline_pos++] = ipv6_hdr_get_tc(ipv6_hdr);\n            iphc_hdr[inline_pos++] = (uint8_t)((ipv6_hdr_get_fl(ipv6_hdr) & 0x000f0000) >> 16);\n        }\n\n        /* copy remaining bytes of flow label */\n        iphc_hdr[inline_pos++] = (uint8_t)((ipv6_hdr_get_fl(ipv6_hdr) & 0x0000ff00) >> 8);\n        iphc_hdr[inline_pos++] = (uint8_t)(ipv6_hdr_get_fl(ipv6_hdr) & 0x000000ff);\n    }\n\n    /* check for compressible next header */\n    if (_compressible_nh(ipv6_hdr->nh)) {\n        iphc_hdr[IPHC1_IDX] |= SIXLOWPAN_IPHC1_NH;\n    }\n    else {\n        iphc_hdr[inline_pos++] = ipv6_hdr->nh;\n    }\n\n    /* compress hop limit */\n    switch (ipv6_hdr->hl) {\n        case 1:\n            iphc_hdr[IPHC1_IDX] |= IPHC_HL_1;\n            break;\n\n        case 64:\n            iphc_hdr[IPHC1_IDX] |= IPHC_HL_64;\n            break;\n\n        case 255:\n            iphc_hdr[IPHC1_IDX] |= IPHC_HL_255;\n            break;\n\n        default:\n            iphc_hdr[IPHC1_IDX] |= IPHC_HL_INLINE;\n            iphc_hdr[inline_pos++] = ipv6_hdr->hl;\n            break;\n    }\n\n    if (ipv6_addr_is_unspecified(&(ipv6_hdr->src))) {\n        iphc_hdr[IPHC2_IDX] |= IPHC_SAC_SAM_UNSPEC;\n    }\n    else {\n        if (src_ctx != NULL) {\n            /* stateful source address compression */\n            iphc_hdr[IPHC2_IDX] |= SIXLOWPAN_IPHC2_SAC;\n\n            if (((src_ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_CID_MASK) != 0)) {\n                iphc_hdr[CID_EXT_IDX] |= ((src_ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_CID_MASK) << 4);\n            }\n        }\n\n        if ((src_ctx != NULL) || ipv6_addr_is_link_local(&(ipv6_hdr->src))) {\n            eui64_t iid;\n            iid.uint64.u64 = 0;\n\n            gnrc_netif_acquire(iface);\n            if (gnrc_netif_ipv6_get_iid(iface, &iid) < 0) {\n                DEBUG(\"6lo iphc: could not get interface's IID\\n\");\n                gnrc_netif_release(iface);\n                return 0;\n            }\n            gnrc_netif_release(iface);\n\n            if ((ipv6_hdr->src.u64[1].u64 == iid.uint64.u64) ||\n                _context_overlaps_iid(src_ctx, &ipv6_hdr->src, &iid)) {\n                /* 0 bits. The address is derived from link-layer address */\n                iphc_hdr[IPHC2_IDX] |= IPHC_SAC_SAM_L2;\n                addr_comp = true;\n            }\n            else if ((byteorder_ntohl(ipv6_hdr->src.u32[2]) == 0x000000ff) &&\n                     (byteorder_ntohs(ipv6_hdr->src.u16[6]) == 0xfe00)) {\n                /* 16 bits. The address is derived using 16 bits carried inline */\n                iphc_hdr[IPHC2_IDX] |= IPHC_SAC_SAM_16;\n                memcpy(iphc_hdr + inline_pos, ipv6_hdr->src.u16 + 7, 2);\n                inline_pos += 2;\n                addr_comp = true;\n            }\n            else {\n                /* 64 bits. The address is derived using 64 bits carried inline */\n                iphc_hdr[IPHC2_IDX] |= IPHC_SAC_SAM_64;\n                memcpy(iphc_hdr + inline_pos, ipv6_hdr->src.u64 + 1, 8);\n                inline_pos += 8;\n                addr_comp = true;\n            }\n        }\n\n        if (!addr_comp) {\n            /* full address is carried inline */\n            iphc_hdr[IPHC2_IDX] |= IPHC_SAC_SAM_FULL;\n            memcpy(iphc_hdr + inline_pos, &ipv6_hdr->src, 16);\n            inline_pos += 16;\n        }\n    }\n\n    addr_comp = false;\n\n    /* M: Multicast compression */\n    if (ipv6_addr_is_multicast(&(ipv6_hdr->dst))) {\n        iphc_hdr[IPHC2_IDX] |= SIXLOWPAN_IPHC2_M;\n\n        /* if multicast address is of format ffXX::XXXX:XXXX:XXXX */\n        if ((ipv6_hdr->dst.u16[1].u16 == 0) &&\n            (ipv6_hdr->dst.u32[1].u32 == 0) &&\n            (ipv6_hdr->dst.u16[4].u16 == 0)) {\n            /* if multicast address is of format ff02::XX */\n            if ((ipv6_hdr->dst.u8[1] == 0x02) &&\n                (ipv6_hdr->dst.u32[2].u32 == 0) &&\n                (ipv6_hdr->dst.u16[6].u16 == 0) &&\n                (ipv6_hdr->dst.u8[14] == 0)) {\n                /* 8 bits. The address is derived using 8 bits carried inline */\n                iphc_hdr[IPHC2_IDX] |= IPHC_M_DAC_DAM_M_8;\n                iphc_hdr[inline_pos++] = ipv6_hdr->dst.u8[15];\n                addr_comp = true;\n            }\n            /* if multicast address is of format ffXX::XX:XXXX */\n            else if ((ipv6_hdr->dst.u16[5].u16 == 0) &&\n                     (ipv6_hdr->dst.u8[12] == 0)) {\n                /* 32 bits. The address is derived using 32 bits carried inline */\n                iphc_hdr[IPHC2_IDX] |= IPHC_M_DAC_DAM_M_32;\n                iphc_hdr[inline_pos++] = ipv6_hdr->dst.u8[1];\n                memcpy(iphc_hdr + inline_pos, ipv6_hdr->dst.u8 + 13, 3);\n                inline_pos += 3;\n                addr_comp = true;\n            }\n            /* if multicast address is of format ffXX::XX:XXXX:XXXX */\n            else if (ipv6_hdr->dst.u8[10] == 0) {\n                /* 48 bits. The address is derived using 48 bits carried inline */\n                iphc_hdr[IPHC2_IDX] |= IPHC_M_DAC_DAM_M_48;\n                iphc_hdr[inline_pos++] = ipv6_hdr->dst.u8[1];\n                memcpy(iphc_hdr + inline_pos, ipv6_hdr->dst.u8 + 11, 5);\n                inline_pos += 5;\n                addr_comp = true;\n            }\n        }\n        /* try unicast prefix based compression */\n        else {\n            gnrc_sixlowpan_ctx_t *ctx;\n            ipv6_addr_t unicast_prefix;\n            unicast_prefix.u16[0] = ipv6_hdr->dst.u16[2];\n            unicast_prefix.u16[1] = ipv6_hdr->dst.u16[3];\n            unicast_prefix.u16[2] = ipv6_hdr->dst.u16[4];\n            unicast_prefix.u16[3] = ipv6_hdr->dst.u16[5];\n\n            ctx = gnrc_sixlowpan_ctx_lookup_addr(&unicast_prefix);\n\n            if ((ctx != NULL) && (ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_COMP) &&\n                (ctx->prefix_len == ipv6_hdr->dst.u8[3])) {\n                /* Unicast prefix based IPv6 multicast address\n                 * (https://tools.ietf.org/html/rfc3306) with given context\n                 * for unicast prefix -> context based compression */\n                iphc_hdr[IPHC2_IDX] |= SIXLOWPAN_IPHC2_DAC;\n                if ((ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_CID_MASK) != 0) {\n                    iphc_hdr[CID_EXT_IDX] |= (ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_CID_MASK);\n                }\n                iphc_hdr[inline_pos++] = ipv6_hdr->dst.u8[1];\n                iphc_hdr[inline_pos++] = ipv6_hdr->dst.u8[2];\n                memcpy(iphc_hdr + inline_pos, ipv6_hdr->dst.u16 + 6, 4);\n                inline_pos += 4;\n                addr_comp = true;\n            }\n        }\n    }\n    else if (((dst_ctx != NULL) ||\n              ipv6_addr_is_link_local(&ipv6_hdr->dst)) && (netif_hdr->dst_l2addr_len > 0)) {\n        eui64_t iid;\n\n        if (dst_ctx != NULL) {\n            /* stateful destination address compression */\n            iphc_hdr[IPHC2_IDX] |= SIXLOWPAN_IPHC2_DAC;\n\n            if (((dst_ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_CID_MASK) != 0)) {\n                iphc_hdr[CID_EXT_IDX] |= (dst_ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_CID_MASK);\n            }\n        }\n\n        if (gnrc_netif_hdr_ipv6_iid_from_dst(iface, netif_hdr, &iid) < 0) {\n            DEBUG(\"6lo iphc: could not get destination's IID\\n\");\n            return 0;\n        }\n\n        if ((ipv6_hdr->dst.u64[1].u64 == iid.uint64.u64) ||\n            _context_overlaps_iid(dst_ctx, &(ipv6_hdr->dst), &iid)) {\n            /* 0 bits. The address is derived using the link-layer address */\n            iphc_hdr[IPHC2_IDX] |= IPHC_M_DAC_DAM_U_L2;\n            addr_comp = true;\n        }\n        else if ((byteorder_ntohl(ipv6_hdr->dst.u32[2]) == 0x000000ff) &&\n                 (byteorder_ntohs(ipv6_hdr->dst.u16[6]) == 0xfe00)) {\n            /* 16 bits. The address is derived using 16 bits carried inline */\n            iphc_hdr[IPHC2_IDX] |= IPHC_M_DAC_DAM_U_16;\n            memcpy(&(iphc_hdr[inline_pos]), &(ipv6_hdr->dst.u16[7]), 2);\n            inline_pos += 2;\n            addr_comp = true;\n        }\n        else {\n            /* 64 bits. The address is derived using 64 bits carried inline */\n            iphc_hdr[IPHC2_IDX] |= IPHC_M_DAC_DAM_U_64;\n            memcpy(&(iphc_hdr[inline_pos]), &(ipv6_hdr->dst.u8[8]), 8);\n            inline_pos += 8;\n            addr_comp = true;\n        }\n    }\n\n    if (!addr_comp) {\n        /* full destination address is carried inline */\n        iphc_hdr[IPHC2_IDX] |= IPHC_SAC_SAM_FULL;\n        memcpy(iphc_hdr + inline_pos, &ipv6_hdr->dst, 16);\n        inline_pos += 16;\n    }\n\n    return inline_pos;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 1752,
    "critical_vars": [
      "*fb"
    ],
    "function": "gnrc_sixlowpan_iphc_send",
    "filename": "RIOT/CVE-2023-33973/CVE-2023-33973_CWE-476_c9d7863e5664a169035038628029bb07e090c5ff_gnrc_sixlowpan_iphc.c.diff",
    "function_code": "void gnrc_sixlowpan_iphc_send(gnrc_pktsnip_t *pkt, void *ctx, unsigned page)\n{\n    gnrc_netif_hdr_t *netif_hdr = pkt->data;\n    gnrc_netif_t *netif = gnrc_netif_hdr_get_netif(netif_hdr);\n    gnrc_pktsnip_t *tmp;\n    /* datagram size before compression */\n    size_t orig_datagram_size = gnrc_pkt_len(pkt->next);\n    ipv6_hdr_t *ipv6_hdr = pkt->next->data;\n    ipv6_addr_t dst;\n\n    if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD)) {\n        dst = ipv6_hdr->dst;    /* copying original destination address */\n    }\n\n    if ((tmp = _iphc_encode(pkt, pkt->data, netif))) {\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD) && (ctx != NULL) &&\n            (gnrc_sixlowpan_frag_minfwd_frag_iphc(tmp, orig_datagram_size, &dst,\n                                                  ctx) == 0)) {\n            DEBUG(\"6lo iphc minfwd: putting slack in first fragment\\n\");\n            return;\n        }\n        gnrc_sixlowpan_multiplex_by_size(tmp, orig_datagram_size, netif, page);\n    }\n    else {\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD)) {\n            gnrc_sixlowpan_frag_fb_t *fb = ctx;\n\n            if (fb->pkt == pkt) {\n                /* free provided fragmentation buffer */\n                fb->pkt = NULL;\n            }\n        }\n        gnrc_pktbuf_release(pkt);\n    }\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Fun-Call",
    "line_old": 333,
    "line_new": 333,
    "critical_vars": [
      "locale_out",
      "locale_in"
    ],
    "function": "print_summary",
    "filename": "libmobi/CVE-2022-2279/CVE-2022-2279_CWE-476_c0699c8693c47f14a2e57dec7292e862ac7adf9c_common.c.diff",
    "function_code": "void print_summary(const MOBIData *m) {\n    char *title = mobi_meta_get_title(m);\n    if (title) {\n        printf(\"Title: %s\\n\", title);\n        free(title);\n    }\n    char *author = mobi_meta_get_author(m);\n    if (author) {\n        printf(\"Author: %s\\n\", author);\n        free(author);\n    }\n    char *contributor = mobi_meta_get_contributor(m);\n    uint32_t major = 0, minor = 0, build = 0;\n    bool is_calibre = false;\n    if (contributor) {\n        const char *calibre_contributor = \"calibre (\";\n        if (strncmp(contributor, calibre_contributor, strlen(calibre_contributor)) == 0) {\n            is_calibre = true;\n            sscanf(contributor, \"calibre (%u.%u.%u)\", &major, &minor, &build);\n        } else {\n            printf(\"Contributor: %s\\n\", contributor);\n        }\n        free(contributor);\n    }\n    char *subject = mobi_meta_get_subject(m);\n    if (subject) {\n        printf(\"Subject: %s\\n\", subject);\n        free(subject);\n    }\n    char *publisher = mobi_meta_get_publisher(m);\n    if (publisher) {\n        printf(\"Publisher: %s\\n\", publisher);\n        free(publisher);\n    }\n    char *date = mobi_meta_get_publishdate(m);\n    if (date) {\n        printf(\"Publishing date: %s\\n\", date);\n        free(date);\n    }\n    char *description = mobi_meta_get_description(m);\n    if (description) {\n        printf(\"Description: %s\\n\", description);\n        free(description);\n    }\n    char *review = mobi_meta_get_review(m);\n    if (review) {\n        printf(\"Review: %s\\n\", review);\n        free(review);\n    }\n    char *imprint = mobi_meta_get_imprint(m);\n    if (imprint) {\n        printf(\"Imprint: %s\\n\", imprint);\n        free(imprint);\n    }\n    char *copyright = mobi_meta_get_copyright(m);\n    if (copyright) {\n        printf(\"Copyright: %s\\n\", copyright);\n        free(copyright);\n    }\n    char *isbn = mobi_meta_get_isbn(m);\n    if (isbn) {\n        printf(\"ISBN: %s\\n\", isbn);\n        free(isbn);\n    }\n    char *asin = mobi_meta_get_asin(m);\n    if (asin) {\n        printf(\"ASIN: %s\\n\", asin);\n        free(asin);\n    }\n    char *language = mobi_meta_get_language(m);\n    if (language) {\n        printf(\"Language: %s\", language);\n        free(language);\n        if (m->mh && m->mh->text_encoding) {\n            uint32_t encoding = *m->mh->text_encoding;\n            if (encoding == MOBI_CP1252) {\n                printf(\" (cp1252)\");\n            } else if (encoding == MOBI_UTF8) {\n                printf(\" (utf8)\");\n            }\n        }\n        printf(\"\\n\");\n    }\n    if (mobi_is_dictionary(m)) {\n        printf(\"Dictionary\");\n        if (m->mh && m->mh->dict_input_lang && m->mh->dict_output_lang &&\n            *m->mh->dict_input_lang && *m->mh->dict_output_lang) {\n            const char *locale_in = mobi_get_locale_string(*m->mh->dict_input_lang);\n            const char *locale_out = mobi_get_locale_string(*m->mh->dict_output_lang);\n            printf(\": %s => %s\", locale_in ? locale_in : \"unknown\", locale_out ? locale_out : \"unknown\");\n        }\n        printf(\"\\n\");\n    }\n    printf(\"__\\n\");\n    if (strcmp(m->ph->type, \"TEXt\") == 0) {\n        if (strcmp(m->ph->creator, \"TlDc\") == 0) {\n            printf(\"TealDoc\\n\");\n        } else {\n            printf(\"PalmDoc\\n\");\n        }\n    } else {\n        printf(\"Mobi version: %zu\", mobi_get_fileversion(m));\n        if (mobi_is_hybrid(m)) {\n            size_t version = mobi_get_fileversion(m->next);\n            if (version != MOBI_NOTSET) {\n                printf(\" (hybrid with version %zu)\", version);\n            }\n        }\n        printf(\"\\n\");\n    }\n    if (mobi_is_replica(m)) {\n        printf(\"Print Replica\\n\");\n    }\n    if (mobi_is_encrypted(m)) {\n        printf(\"Document is encrypted\\n\");\n    }\n    if (is_calibre) {\n        printf(\"Creator software: calibre %u.%u.%u\\n\", major, minor, build);\n    } else {\n        MOBIExthHeader *exth = mobi_get_exthrecord_by_tag(m, EXTH_CREATORSOFT);\n        if (exth) {\n            printf(\"Creator software: \");\n            uint32_t creator = mobi_decode_exthvalue(exth->data, exth->size);\n            exth = mobi_get_exthrecord_by_tag(m, EXTH_CREATORMAJOR);\n            if (exth) {\n                major = mobi_decode_exthvalue(exth->data, exth->size);\n            }\n            exth = mobi_get_exthrecord_by_tag(m, EXTH_CREATORMINOR);\n            if (exth) {\n                minor = mobi_decode_exthvalue(exth->data, exth->size);\n            }\n            exth = mobi_get_exthrecord_by_tag(m, EXTH_CREATORBUILD);\n            if (exth) {\n                build = mobi_decode_exthvalue(exth->data, exth->size);\n            }\n            exth = mobi_get_exthrecord_by_tag(m, EXTH_CREATORBUILDREV);\n            if (major == 2 && minor == 9 && build == 0 && exth) {\n                char *rev = mobi_decode_exthstring(m, exth->data, exth->size);\n                if (rev) {\n                    if (strcmp(rev, \"0730-890adc2\") == 0) {\n                        is_calibre = true;\n                    }\n                    free(rev);\n                }\n            }\n            switch (creator) {\n                case 0:\n                    printf(\"mobipocket reader %u.%u.%u\", major, minor, build);\n                    break;\n                case 1:\n                case 101:\n                    printf(\"mobigen %u.%u.%u\", major, minor, build);\n                    break;\n                case 2:\n                    printf(\"mobipocket creator %u.%u.%u\", major, minor, build);\n                    break;\n                case 200:\n                    printf(\"kindlegen %u.%u.%u (windows)\", major, minor, build);\n                    if (is_calibre) {\n                        printf(\" or calibre\");\n                    }\n                    break;\n                case 201:\n                    printf(\"kindlegen %u.%u.%u (linux)\", major, minor, build);\n                    if ((major == 1 && minor == 2 && build == 33307) ||\n                        (major == 2 && minor == 0 && build == 101) ||\n                        is_calibre) {\n                        printf(\" or calibre\");\n                    }\n                    break;\n                case 202:\n                    printf(\"kindlegen %u.%u.%u (mac)\", major, minor, build);\n                    if (is_calibre) {\n                        printf(\" or calibre\");\n                    }\n                    break;\n                default:\n                    printf(\"unknown\");\n                    break;\n            }\n            printf(\"\\n\");\n        }\n    }\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 1155,
    "critical_vars": [
      "opf->metadata->x_meta->dictionary_in_lang"
    ],
    "function": "mobi_build_opf_metadata",
    "filename": "libmobi/CVE-2022-2279/CVE-2022-2279_CWE-476_c0699c8693c47f14a2e57dec7292e862ac7adf9c_opf.c.diff",
    "function_code": "MOBI_RET mobi_build_opf_metadata(OPF *opf,  const MOBIData *m, const MOBIRawml *rawml) {\n    if (m == NULL) {\n        debug_print(\"%s\\n\", \"Initialization failed\");\n        return MOBI_INIT_FAILED;\n    }\n    opf->metadata = calloc(1, sizeof(OPFmetadata));\n    if (opf->metadata == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    /* initialize metadata sub-elements */\n    opf->metadata->meta = calloc(OPF_META_MAX_TAGS, sizeof(OPFmeta*));\n    if (opf->metadata->meta == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    opf->metadata->dc_meta = calloc(1, sizeof(OPFdcmeta));\n    if (opf->metadata->dc_meta == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    opf->metadata->x_meta = calloc(1, sizeof(OPFxmeta));\n    if (opf->metadata->x_meta == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    if (m->eh) {\n        MOBI_RET ret = mobi_get_opf_from_exth(opf->metadata, m);\n        if (ret != MOBI_SUCCESS) {\n            return ret;\n        }\n    }\n    /* check for required elements */\n    if (opf->metadata->dc_meta->identifier == NULL) {\n        /* default id will be \"0\" */\n        char uid_string[11] = \"0\";\n        if (m->mh && m->mh->uid) {\n            snprintf(uid_string, 11, \"%u\", *m->mh->uid);\n        }\n        mobi_opf_set_tagtype(OPFidentifier, opf->metadata->dc_meta->identifier, value, uid_string);\n        mobi_opf_set_tagtype(OPFidentifier, opf->metadata->dc_meta->identifier, id, \"uid\");\n    } else {\n        opf->metadata->dc_meta->identifier[0]->id = strdup(\"uid\");\n    }\n    if (opf->metadata->dc_meta->title == NULL) {\n        opf->metadata->dc_meta->title = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n        if (opf->metadata->dc_meta->title == NULL) {\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        char *title = mobi_meta_get_title(m);\n        if (title == NULL) {\n            title = strdup(\"Unknown\");\n        }\n        opf->metadata->dc_meta->title[0] = title;\n    }\n    if (opf->metadata->dc_meta->language == NULL) {\n        opf->metadata->dc_meta->language = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n        if (opf->metadata->dc_meta->language == NULL) {\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        const char *lang_string = NULL;\n        if (m->mh && m->mh->locale) {\n            uint32_t lang_code = *m->mh->locale;\n            lang_string = mobi_get_locale_string(lang_code);\n        }\n        if (lang_string) {\n            opf->metadata->dc_meta->language[0] = strdup(lang_string);\n        } else {\n            opf->metadata->dc_meta->language[0] = strdup(\"en\");\n        }\n    }\n    /* write optional elements */\n    if (mobi_is_dictionary(m)) {\n        if (opf->metadata->x_meta->dictionary_in_lang == NULL) {\n            if (m->mh && m->mh->dict_input_lang) {\n                opf->metadata->x_meta->dictionary_in_lang = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n                if (opf->metadata->x_meta->dictionary_in_lang == NULL) {\n                    debug_print(\"%s\\n\", \"Memory allocation failed\");\n                    return MOBI_MALLOC_FAILED;\n                }\n                uint32_t dict_lang_in = *m->mh->dict_input_lang;\n                opf->metadata->x_meta->dictionary_in_lang[0] = strdup(mobi_get_locale_string(dict_lang_in));\n            }\n        }\n        if (opf->metadata->x_meta->dictionary_out_lang == NULL) {\n            if (m->mh && m->mh->dict_output_lang) {\n                opf->metadata->x_meta->dictionary_out_lang = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n                if (opf->metadata->x_meta->dictionary_out_lang == NULL) {\n                    debug_print(\"%s\\n\", \"Memory allocation failed\");\n                    return MOBI_MALLOC_FAILED;\n                }\n                uint32_t dict_lang_in = *m->mh->dict_output_lang;\n                opf->metadata->x_meta->dictionary_out_lang[0] = strdup(mobi_get_locale_string(dict_lang_in));\n            }\n        }\n        if (rawml->orth->orth_index_name) {\n            opf->metadata->x_meta->default_lookup_index = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n            if (opf->metadata->x_meta->default_lookup_index == NULL) {\n                debug_print(\"%s\\n\", \"Memory allocation failed\");\n                return MOBI_MALLOC_FAILED;\n            }\n            opf->metadata->x_meta->default_lookup_index[0] = strdup(rawml->orth->orth_index_name);\n        }\n    }\n    return MOBI_SUCCESS;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 1156,
    "critical_vars": [
      "*lang"
    ],
    "function": "mobi_build_opf_metadata",
    "filename": "libmobi/CVE-2022-2279/CVE-2022-2279_CWE-476_c0699c8693c47f14a2e57dec7292e862ac7adf9c_opf.c.diff",
    "function_code": "MOBI_RET mobi_build_opf_metadata(OPF *opf,  const MOBIData *m, const MOBIRawml *rawml) {\n    if (m == NULL) {\n        debug_print(\"%s\\n\", \"Initialization failed\");\n        return MOBI_INIT_FAILED;\n    }\n    opf->metadata = calloc(1, sizeof(OPFmetadata));\n    if (opf->metadata == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    /* initialize metadata sub-elements */\n    opf->metadata->meta = calloc(OPF_META_MAX_TAGS, sizeof(OPFmeta*));\n    if (opf->metadata->meta == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    opf->metadata->dc_meta = calloc(1, sizeof(OPFdcmeta));\n    if (opf->metadata->dc_meta == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    opf->metadata->x_meta = calloc(1, sizeof(OPFxmeta));\n    if (opf->metadata->x_meta == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    if (m->eh) {\n        MOBI_RET ret = mobi_get_opf_from_exth(opf->metadata, m);\n        if (ret != MOBI_SUCCESS) {\n            return ret;\n        }\n    }\n    /* check for required elements */\n    if (opf->metadata->dc_meta->identifier == NULL) {\n        /* default id will be \"0\" */\n        char uid_string[11] = \"0\";\n        if (m->mh && m->mh->uid) {\n            snprintf(uid_string, 11, \"%u\", *m->mh->uid);\n        }\n        mobi_opf_set_tagtype(OPFidentifier, opf->metadata->dc_meta->identifier, value, uid_string);\n        mobi_opf_set_tagtype(OPFidentifier, opf->metadata->dc_meta->identifier, id, \"uid\");\n    } else {\n        opf->metadata->dc_meta->identifier[0]->id = strdup(\"uid\");\n    }\n    if (opf->metadata->dc_meta->title == NULL) {\n        opf->metadata->dc_meta->title = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n        if (opf->metadata->dc_meta->title == NULL) {\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        char *title = mobi_meta_get_title(m);\n        if (title == NULL) {\n            title = strdup(\"Unknown\");\n        }\n        opf->metadata->dc_meta->title[0] = title;\n    }\n    if (opf->metadata->dc_meta->language == NULL) {\n        opf->metadata->dc_meta->language = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n        if (opf->metadata->dc_meta->language == NULL) {\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        const char *lang_string = NULL;\n        if (m->mh && m->mh->locale) {\n            uint32_t lang_code = *m->mh->locale;\n            lang_string = mobi_get_locale_string(lang_code);\n        }\n        if (lang_string) {\n            opf->metadata->dc_meta->language[0] = strdup(lang_string);\n        } else {\n            opf->metadata->dc_meta->language[0] = strdup(\"en\");\n        }\n    }\n    /* write optional elements */\n    if (mobi_is_dictionary(m)) {\n        if (opf->metadata->x_meta->dictionary_in_lang == NULL) {\n            if (m->mh && m->mh->dict_input_lang) {\n                uint32_t dict_lang_in = *m->mh->dict_input_lang;\n                const char *lang = mobi_get_locale_string(dict_lang_in);\n                if (lang) {\n                    opf->metadata->x_meta->dictionary_in_lang = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n                    if (opf->metadata->x_meta->dictionary_in_lang == NULL) {\n                        debug_print(\"%s\\n\", \"Memory allocation failed\");\n                        return MOBI_MALLOC_FAILED;\n                    }\n                    opf->metadata->x_meta->dictionary_in_lang[0] = strdup(lang);\n                }\n            }\n        }\n        if (opf->metadata->x_meta->dictionary_out_lang == NULL) {\n            if (m->mh && m->mh->dict_output_lang) {\n                uint32_t dict_lang_out = *m->mh->dict_output_lang;\n                const char *lang = mobi_get_locale_string(dict_lang_out);\n                if (lang) {\n                    opf->metadata->x_meta->dictionary_out_lang = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n                    if (opf->metadata->x_meta->dictionary_out_lang == NULL) {\n                        debug_print(\"%s\\n\", \"Memory allocation failed\");\n                        return MOBI_MALLOC_FAILED;\n                    }\n                    opf->metadata->x_meta->dictionary_out_lang[0] = strdup(lang);\n                }\n            }\n        }\n        if (rawml->orth->orth_index_name) {\n            opf->metadata->x_meta->default_lookup_index = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n            if (opf->metadata->x_meta->default_lookup_index == NULL) {\n                debug_print(\"%s\\n\", \"Memory allocation failed\");\n                return MOBI_MALLOC_FAILED;\n            }\n            opf->metadata->x_meta->default_lookup_index[0] = strdup(rawml->orth->orth_index_name);\n        }\n    }\n    return MOBI_SUCCESS;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "for-Condition",
    "line_old": 1060,
    "line_new": 1060,
    "critical_vars": [
      "k"
    ],
    "function": "mobi_trie_insert_infl",
    "filename": "libmobi/CVE-2022-29788/CVE-2022-29788_CWE-476_ce0ab6586069791b1e8e2a42f44318e581c39939_index.c.diff",
    "function_code": "MOBI_RET mobi_trie_insert_infl(MOBITrie **root, const MOBIIndx *indx, size_t i) {\n    MOBIIndexEntry e = indx->entries[i];\n    char *inflected = e.label;\n    for (size_t j = 0; j < e.tags_count; j++) {\n        MOBIIndexTag t = e.tags[j];\n        if (t.tagid == INDX_TAGARR_INFL_PARTS_V1) {\n            for (size_t k = 0; k + 1 < t.tagvalues_count; k += 2) {\n                uint32_t len = t.tagvalues[k];\n                uint32_t offset = t.tagvalues[k + 1];\n                char *base = mobi_get_cncx_string_flat(indx->cncx_record, offset, len);\n                if (base == NULL) {\n                    return MOBI_MALLOC_FAILED;\n                }\n                MOBI_RET ret = mobi_trie_insert_reversed(root, base, inflected);\n                free(base);\n                if (ret != MOBI_SUCCESS) {\n                    return ret;\n                }\n            }\n        }\n    }\n    return MOBI_SUCCESS;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 456,
    "critical_vars": [
      "name_len",
      "name[0]",
      "name[1]"
    ],
    "function": "chmd_read_headers",
    "filename": "libmspack/CVE-2018-18585/CVE-2018-18585_CWE-476_8759da8db6ec9e866cb8eb143313f397f925bb4f_chmd.c.diff",
    "function_code": "static int chmd_read_headers(struct mspack_system *sys, struct mspack_file *fh,\n\t\t\t     struct mschmd_header *chm, int entire)\n{\n  unsigned int section, name_len, x, errors, num_chunks;\n  unsigned char buf[0x54], *chunk = NULL, *name, *p, *end;\n  struct mschmd_file *fi, *link = NULL;\n  off_t offset, length;\n  int num_entries;\n\n  /* initialise pointers */\n  chm->files         = NULL;\n  chm->sysfiles      = NULL;\n  chm->chunk_cache   = NULL;\n  chm->sec0.base.chm = chm;\n  chm->sec0.base.id  = 0;\n  chm->sec1.base.chm = chm;\n  chm->sec1.base.id  = 1;\n  chm->sec1.content  = NULL;\n  chm->sec1.control  = NULL;\n  chm->sec1.spaninfo = NULL;\n  chm->sec1.rtable   = NULL;\n\n  /* read the first header */\n  if (sys->read(fh, &buf[0], chmhead_SIZEOF) != chmhead_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  /* check ITSF signature */\n  if (EndGetI32(&buf[chmhead_Signature]) != 0x46535449) {\n    return MSPACK_ERR_SIGNATURE;\n  }\n\n  /* check both header GUIDs */\n  if (mspack_memcmp(&buf[chmhead_GUID1], &guids[0], 32L) != 0) {\n    D((\"incorrect GUIDs\"))\n    return MSPACK_ERR_SIGNATURE;\n  }\n\n  chm->version   = EndGetI32(&buf[chmhead_Version]);\n  chm->timestamp = EndGetM32(&buf[chmhead_Timestamp]);\n  chm->language  = EndGetI32(&buf[chmhead_LanguageID]);\n  if (chm->version > 3) {\n    sys->message(fh, \"WARNING; CHM version > 3\");\n  }\n\n  /* read the header section table */\n  if (sys->read(fh, &buf[0], chmhst3_SIZEOF) != chmhst3_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  /* chmhst3_OffsetCS0 does not exist in version 1 or 2 CHM files.\n   * The offset will be corrected later, once HS1 is read.\n   */\n  if (read_off64(&offset,           &buf[chmhst_OffsetHS0],  sys, fh) ||\n      read_off64(&chm->dir_offset,  &buf[chmhst_OffsetHS1],  sys, fh) ||\n      read_off64(&chm->sec0.offset, &buf[chmhst3_OffsetCS0], sys, fh))\n  {\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* seek to header section 0 */\n  if (sys->seek(fh, offset, MSPACK_SYS_SEEK_START)) {\n    return MSPACK_ERR_SEEK;\n  }\n\n  /* read header section 0 */\n  if (sys->read(fh, &buf[0], chmhs0_SIZEOF) != chmhs0_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n  if (read_off64(&chm->length, &buf[chmhs0_FileLen], sys, fh)) {\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* seek to header section 1 */\n  if (sys->seek(fh, chm->dir_offset, MSPACK_SYS_SEEK_START)) {\n    return MSPACK_ERR_SEEK;\n  }\n\n  /* read header section 1 */\n  if (sys->read(fh, &buf[0], chmhs1_SIZEOF) != chmhs1_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  chm->dir_offset = sys->tell(fh);\n  chm->chunk_size = EndGetI32(&buf[chmhs1_ChunkSize]);\n  chm->density    = EndGetI32(&buf[chmhs1_Density]);\n  chm->depth      = EndGetI32(&buf[chmhs1_Depth]);\n  chm->index_root = EndGetI32(&buf[chmhs1_IndexRoot]);\n  chm->num_chunks = EndGetI32(&buf[chmhs1_NumChunks]);\n  chm->first_pmgl = EndGetI32(&buf[chmhs1_FirstPMGL]);\n  chm->last_pmgl  = EndGetI32(&buf[chmhs1_LastPMGL]);\n\n  if (chm->version < 3) {\n    /* versions before 3 don't have chmhst3_OffsetCS0 */\n    chm->sec0.offset = chm->dir_offset + (chm->chunk_size * chm->num_chunks);\n  }\n\n  /* check if content offset or file size is wrong */\n  if (chm->sec0.offset > chm->length) {\n    D((\"content section begins after file has ended\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  \n  /* ensure there are chunks and that chunk size is\n   * large enough for signature and num_entries */\n  if (chm->chunk_size < (pmgl_Entries + 2)) {\n    D((\"chunk size not large enough\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  if (chm->num_chunks == 0) {\n    D((\"no chunks\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* The chunk_cache data structure is not great; large values for num_chunks\n   * or num_chunks*chunk_size can exhaust all memory. Until a better chunk\n   * cache is implemented, put arbitrary limits on num_chunks and chunk size.\n   */\n  if (chm->num_chunks > 100000) {\n    D((\"more than 100,000 chunks\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }   \n  if ((off_t)chm->chunk_size * (off_t)chm->num_chunks > chm->length) {\n    D((\"chunks larger than entire file\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* common sense checks on header section 1 fields */\n  if ((chm->chunk_size & (chm->chunk_size - 1)) != 0) {\n    sys->message(fh, \"WARNING; chunk size is not a power of two\");\n  }\n  if (chm->first_pmgl != 0) {\n    sys->message(fh, \"WARNING; first PMGL chunk is not zero\");\n  }\n  if (chm->first_pmgl > chm->last_pmgl) {\n    D((\"first pmgl chunk is after last pmgl chunk\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  if (chm->index_root != 0xFFFFFFFF && chm->index_root >= chm->num_chunks) {\n    D((\"index_root outside valid range\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* if we are doing a quick read, stop here! */\n  if (!entire) {\n    return MSPACK_ERR_OK;\n  }\n\n  /* seek to the first PMGL chunk, and reduce the number of chunks to read */\n  if ((x = chm->first_pmgl) != 0) {\n    if (sys->seek(fh,(off_t) (x * chm->chunk_size), MSPACK_SYS_SEEK_CUR)) {\n      return MSPACK_ERR_SEEK;\n    }\n  }\n  num_chunks = chm->last_pmgl - x + 1;\n\n  if (!(chunk = (unsigned char *) sys->alloc(sys, (size_t)chm->chunk_size))) {\n    return MSPACK_ERR_NOMEMORY;\n  }\n\n  /* read and process all chunks from FirstPMGL to LastPMGL */\n  errors = 0;\n  while (num_chunks--) {\n    /* read next chunk */\n    if (sys->read(fh, chunk, (int)chm->chunk_size) != (int)chm->chunk_size) {\n      sys->free(chunk);\n      return MSPACK_ERR_READ;\n    }\n\n    /* process only directory (PMGL) chunks */\n    if (EndGetI32(&chunk[pmgl_Signature]) != 0x4C474D50) continue;\n\n    if (EndGetI32(&chunk[pmgl_QuickRefSize]) < 2) {\n      sys->message(fh, \"WARNING; PMGL quickref area is too small\");\n    }\n    if (EndGetI32(&chunk[pmgl_QuickRefSize]) > \n\t((int)chm->chunk_size - pmgl_Entries))\n    {\n      sys->message(fh, \"WARNING; PMGL quickref area is too large\");\n    }\n\n    p = &chunk[pmgl_Entries];\n    end = &chunk[chm->chunk_size - 2];\n    num_entries = EndGetI16(end);\n\n    while (num_entries--) {\n      READ_ENCINT(name_len);\n      if (name_len > (unsigned int) (end - p)) goto chunk_end;\n      name = p; p += name_len;\n      READ_ENCINT(section);\n      READ_ENCINT(offset);\n      READ_ENCINT(length);\n\n      /* ignore blank or one-char (e.g. \"/\") filenames we'd return as blank */\n      if (name_len < 2 || !name[0] || !name[1]) continue;\n\n      /* empty files and directory names are stored as a file entry at\n       * offset 0 with length 0. We want to keep empty files, but not\n       * directory names, which end with a \"/\" */\n      if ((offset == 0) && (length == 0)) {\n\tif ((name_len > 0) && (name[name_len-1] == '/')) continue;\n      }\n\n      if (section > 1) {\n\tsys->message(fh, \"invalid section number '%u'.\", section);\n\tcontinue;\n      }\n\n      if (!(fi = (struct mschmd_file *) sys->alloc(sys, sizeof(struct mschmd_file) + name_len + 1))) {\n\tsys->free(chunk);\n\treturn MSPACK_ERR_NOMEMORY;\n      }\n\n      fi->next     = NULL;\n      fi->filename = (char *) &fi[1];\n      fi->section  = ((section == 0) ? (struct mschmd_section *) (&chm->sec0)\n\t\t                     : (struct mschmd_section *) (&chm->sec1));\n      fi->offset   = offset;\n      fi->length   = length;\n      sys->copy(name, fi->filename, (size_t) name_len);\n      fi->filename[name_len] = '\\0';\n\n      if (name[0] == ':' && name[1] == ':') {\n\t/* system file */\n\tif (mspack_memcmp(&name[2], &content_name[2], 31L) == 0) {\n\t  if (mspack_memcmp(&name[33], &content_name[33], 8L) == 0) {\n\t    chm->sec1.content = fi;\n\t  }\n\t  else if (mspack_memcmp(&name[33], &control_name[33], 11L) == 0) {\n\t    chm->sec1.control = fi;\n\t  }\n\t  else if (mspack_memcmp(&name[33], &spaninfo_name[33], 8L) == 0) {\n\t    chm->sec1.spaninfo = fi;\n\t  }\n\t  else if (mspack_memcmp(&name[33], &rtable_name[33], 72L) == 0) {\n\t    chm->sec1.rtable = fi;\n\t  }\n\t}\n\tfi->next = chm->sysfiles;\n\tchm->sysfiles = fi;\n      }\n      else {\n\t/* normal file */\n\tif (link) link->next = fi; else chm->files = fi;\n\tlink = fi;\n      }\n    }\n\n    /* this is reached either when num_entries runs out, or if\n     * reading data from the chunk reached a premature end of chunk */\n  chunk_end:\n    if (num_entries >= 0) {\n      D((\"chunk ended before all entries could be read\"))\n      errors++;\n    }\n\n  }\n  sys->free(chunk);\n  return (errors > 0) ? MSPACK_ERR_DATAFORMAT : MSPACK_ERR_OK;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 43,
    "critical_vars": [
      "user"
    ],
    "function": "check_client_passwd",
    "filename": "pgbouncer/CVE-2015-4054/CVE-2015-4054_CWE-476_edab5be6665b9e8de66c25ba527509b229468573_client.c.diff",
    "function_code": "static bool check_client_passwd(PgSocket *client, const char *passwd)\n{\n\tchar md5[MD5_PASSWD_LEN + 1];\n\tconst char *correct;\n\tPgUser *user = client->auth_user;\n\n\t/* auth_user may be missing */\n\tif (!user) {\n\t\tslog_error(client, \"Password packet before auth packet?\");\n\t\treturn false;\n\t}\n\n\t/* disallow empty passwords */\n\tif (!*passwd || !*user->passwd)\n\t\treturn false;\n\n\tswitch (cf_auth_type) {\n\tcase AUTH_PLAIN:\n\t\treturn strcmp(user->passwd, passwd) == 0;\n\tcase AUTH_CRYPT:\n\t\tcorrect = crypt(user->passwd, (char *)client->tmp_login_salt);\n\t\treturn correct && strcmp(correct, passwd) == 0;\n\tcase AUTH_MD5:\n\t\tif (strlen(passwd) != MD5_PASSWD_LEN)\n\t\t\treturn false;\n\t\tif (!isMD5(user->passwd))\n\t\t\tpg_md5_encrypt(user->passwd, user->name, strlen(user->name), user->passwd);\n\t\tpg_md5_encrypt(user->passwd + 3, (char *)client->tmp_login_salt, 4, md5);\n\t\treturn strcmp(md5, passwd) == 0;\n\t}\n\treturn false;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 3219,
    "critical_vars": [
      "data"
    ],
    "function": "*ReadDCMImage",
    "filename": "ImageMagick/CVE-2016-5690/CVE-2016-5690_CWE-476_5511ef530576ed18fd636baa3bb4eda3d667665d_dcm.c.diff",
    "function_code": "static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    explicit_vr[MagickPathExtent],\n    implicit_vr[MagickPathExtent],\n    magick[MagickPathExtent],\n    photometric[MagickPathExtent];\n\n  DCMStreamInfo\n    *stream_info;\n\n  Image\n    *image;\n\n  int\n    *bluemap,\n    datum,\n    *greenmap,\n    *graymap,\n    index,\n    *redmap;\n\n  MagickBooleanType\n    explicit_file,\n    explicit_retry,\n    polarity,\n    sequence,\n    use_explicit;\n\n  MagickOffsetType\n    offset;\n\n  Quantum\n    *scale;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bits_allocated,\n    bytes_per_pixel,\n    colors,\n    depth,\n    height,\n    length,\n    mask,\n    max_value,\n    number_scenes,\n    quantum,\n    samples_per_pixel,\n    signed_data,\n    significant_bits,\n    status,\n    width,\n    window_width;\n\n  ssize_t\n    count,\n    rescale_intercept,\n    rescale_slope,\n    scene,\n    window_center,\n    y;\n\n  unsigned char\n    *data;\n\n  unsigned short\n    group,\n    element;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  image->depth=8UL;\n  image->endian=LSBEndian;\n  /*\n    Read DCM preamble.\n  */\n  stream_info=(DCMStreamInfo *) AcquireMagickMemory(sizeof(*stream_info));\n  if (stream_info == (DCMStreamInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(stream_info,0,sizeof(*stream_info));\n  count=ReadBlob(image,128,(unsigned char *) magick);\n  if (count != 128)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  count=ReadBlob(image,4,(unsigned char *) magick);\n  if ((count != 4) || (LocaleNCompare(magick,\"DICM\",4) != 0))\n    {\n      offset=SeekBlob(image,0L,SEEK_SET);\n      if (offset < 0)\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  /*\n    Read DCM Medical image.\n  */\n  (void) CopyMagickString(photometric,\"MONOCHROME1 \",MagickPathExtent);\n  bits_allocated=8;\n  bytes_per_pixel=1;\n  polarity=MagickFalse;\n  data=(unsigned char *) NULL;\n  depth=8;\n  element=0;\n  explicit_vr[2]='\\0';\n  explicit_file=MagickFalse;\n  colors=0;\n  redmap=(int *) NULL;\n  greenmap=(int *) NULL;\n  bluemap=(int *) NULL;\n  graymap=(int *) NULL;\n  height=0;\n  max_value=255UL;\n  mask=0xffff;\n  number_scenes=1;\n  rescale_intercept=0;\n  rescale_slope=1;\n  samples_per_pixel=1;\n  scale=(Quantum *) NULL;\n  sequence=MagickFalse;\n  signed_data=(~0UL);\n  significant_bits=0;\n  use_explicit=MagickFalse;\n  explicit_retry = MagickFalse;\n  width=0;\n  window_center=0;\n  window_width=0;\n  for (group=0; (group != 0x7FE0) || (element != 0x0010) ||\n                (sequence != MagickFalse); )\n  {\n    /*\n      Read a group.\n    */\n    image->offset=(ssize_t) TellBlob(image);\n    group=ReadBlobLSBShort(image);\n    element=ReadBlobLSBShort(image);\n    if ((group != 0x0002) && (image->endian == MSBEndian))\n      {\n        group=(unsigned short) ((group << 8) | ((group >> 8) & 0xFF));\n        element=(unsigned short) ((element << 8) | ((element >> 8) & 0xFF));\n      }\n    quantum=0;\n    /*\n      Find corresponding VR for this group and element.\n    */\n    for (i=0; dicom_info[i].group < 0xffff; i++)\n      if ((group == dicom_info[i].group) && (element == dicom_info[i].element))\n        break;\n    (void) CopyMagickString(implicit_vr,dicom_info[i].vr,MagickPathExtent);\n    count=ReadBlob(image,2,(unsigned char *) explicit_vr);\n    if (count != 2)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    /*\n      Check for \"explicitness\", but meta-file headers always explicit.\n    */\n    if ((explicit_file == MagickFalse) && (group != 0x0002))\n      explicit_file=(isupper((unsigned char) *explicit_vr) != MagickFalse) &&\n        (isupper((unsigned char) *(explicit_vr+1)) != MagickFalse) ?\n        MagickTrue : MagickFalse;\n    use_explicit=((group == 0x0002) && (explicit_retry == MagickFalse)) ||\n      (explicit_file != MagickFalse) ? MagickTrue : MagickFalse;\n    if ((use_explicit != MagickFalse) && (strncmp(implicit_vr,\"xs\",2) == 0))\n      (void) CopyMagickString(implicit_vr,explicit_vr,MagickPathExtent);\n    if ((use_explicit == MagickFalse) || (strncmp(implicit_vr,\"!!\",2) == 0))\n      {\n        offset=SeekBlob(image,(MagickOffsetType) -2,SEEK_CUR);\n        if (offset < 0)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        quantum=4;\n      }\n    else\n      {\n        /*\n          Assume explicit type.\n        */\n        quantum=2;\n        if ((strncmp(explicit_vr,\"OB\",2) == 0) ||\n            (strncmp(explicit_vr,\"UN\",2) == 0) ||\n            (strncmp(explicit_vr,\"OW\",2) == 0) ||\n            (strncmp(explicit_vr,\"SQ\",2) == 0))\n          {\n            (void) ReadBlobLSBShort(image);\n            quantum=4;\n          }\n      }\n    datum=0;\n    if (quantum == 4)\n      {\n        if (group == 0x0002)\n          datum=ReadBlobLSBSignedLong(image);\n        else\n          datum=ReadBlobSignedLong(image);\n      }\n    else\n      if (quantum == 2)\n        {\n          if (group == 0x0002)\n            datum=ReadBlobLSBSignedShort(image);\n          else\n            datum=ReadBlobSignedShort(image);\n        }\n    quantum=0;\n    length=1;\n    if (datum != 0)\n      {\n        if ((strncmp(implicit_vr,\"SS\",2) == 0) ||\n            (strncmp(implicit_vr,\"US\",2) == 0))\n          quantum=2;\n        else\n          if ((strncmp(implicit_vr,\"UL\",2) == 0) ||\n              (strncmp(implicit_vr,\"SL\",2) == 0) ||\n              (strncmp(implicit_vr,\"FL\",2) == 0))\n            quantum=4;\n          else\n            if (strncmp(implicit_vr,\"FD\",2) != 0)\n              quantum=1;\n            else\n              quantum=8;\n        if (datum != ~0)\n          length=(size_t) datum/quantum;\n        else\n          {\n            /*\n              Sequence and item of undefined length.\n            */\n            quantum=0;\n            length=0;\n          }\n      }\n    if (image_info->verbose != MagickFalse)\n      {\n        /*\n          Display Dicom info.\n        */\n        if (use_explicit == MagickFalse)\n          explicit_vr[0]='\\0';\n        for (i=0; dicom_info[i].description != (char *) NULL; i++)\n          if ((group == dicom_info[i].group) &&\n              (element == dicom_info[i].element))\n            break;\n        (void) FormatLocaleFile(stdout,\"0x%04lX %4ld %s-%s (0x%04lx,0x%04lx)\",\n          (unsigned long) image->offset,(long) length,implicit_vr,explicit_vr,\n          (unsigned long) group,(unsigned long) element);\n        if (dicom_info[i].description != (char *) NULL)\n          (void) FormatLocaleFile(stdout,\" %s\",dicom_info[i].description);\n        (void) FormatLocaleFile(stdout,\": \");\n      }\n    if ((sequence == MagickFalse) && (group == 0x7FE0) && (element == 0x0010))\n      {\n        if (image_info->verbose != MagickFalse)\n          (void) FormatLocaleFile(stdout,\"\\n\");\n        break;\n      }\n    /*\n      Allocate space and read an array.\n    */\n    data=(unsigned char *) NULL;\n    if ((length == 1) && (quantum == 1))\n      datum=ReadBlobByte(image);\n    else\n      if ((length == 1) && (quantum == 2))\n        {\n          if (group == 0x0002)\n            datum=ReadBlobLSBSignedShort(image);\n          else\n            datum=ReadBlobSignedShort(image);\n        }\n      else\n        if ((length == 1) && (quantum == 4))\n          {\n            if (group == 0x0002)\n              datum=ReadBlobLSBSignedLong(image);\n            else\n              datum=ReadBlobSignedLong(image);\n          }\n        else\n          if ((quantum != 0) && (length != 0))\n            {\n              if (~length >= 1)\n                data=(unsigned char *) AcquireQuantumMemory(length+1,quantum*\n                  sizeof(*data));\n              if (data == (unsigned char *) NULL)\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              count=ReadBlob(image,(size_t) quantum*length,data);\n              if (count != (ssize_t) (quantum*length))\n                {\n                  if (image_info->verbose != MagickFalse)\n                    (void) FormatLocaleFile(stdout,\"count=%d quantum=%d \"\n                      \"length=%d group=%d\\n\",(int) count,(int) quantum,(int)\n                      length,(int) group);\n                   ThrowReaderException(CorruptImageError,\n                     \"InsufficientImageDataInFile\");\n                }\n              data[length*quantum]='\\0';\n            }\n          else\n            if ((unsigned int) datum == 0xFFFFFFFFU)\n              {\n                sequence=MagickTrue;\n                continue;\n              }\n\n    if ((unsigned int) ((group << 16) | element) == 0xFFFEE0DD)\n      {\n        if (data != (unsigned char *) NULL)\n          data=(unsigned char *) RelinquishMagickMemory(data);\n        sequence=MagickFalse;\n        continue;\n      }\n\n    if (sequence != MagickFalse)\n      {\n        if (data != (unsigned char *) NULL)\n          data=(unsigned char *) RelinquishMagickMemory(data);\n        continue;\n      }\n\n    switch (group)\n    {\n      case 0x0002:\n      {\n        switch (element)\n        {\n          case 0x0010:\n          {\n            char\n              transfer_syntax[MagickPathExtent];\n\n            /*\n              Transfer Syntax.\n            */\n            if ((datum == 0) && (explicit_retry == MagickFalse))\n              {\n                explicit_retry=MagickTrue;\n                (void) SeekBlob(image,(MagickOffsetType) 0,SEEK_SET);\n                group=0;\n                element=0;\n                if (image_info->verbose != MagickFalse)\n                  (void) FormatLocaleFile(stdout,\n                    \"Corrupted image - trying explicit format\\n\");\n                break;\n              }\n            *transfer_syntax='\\0';\n            if (data != (unsigned char *) NULL)\n              (void) CopyMagickString(transfer_syntax,(char *) data,\n                MagickPathExtent);\n            if (image_info->verbose != MagickFalse)\n              (void) FormatLocaleFile(stdout,\"transfer_syntax=%s\\n\",\n                (const char *) transfer_syntax);\n            if (strncmp(transfer_syntax,\"1.2.840.10008.1.2\",17) == 0)\n              {\n                int\n                  count,\n                  subtype,\n                  type;\n\n                type=1;\n                subtype=0;\n                if (strlen(transfer_syntax) > 17)\n                  {\n                    count=sscanf(transfer_syntax+17,\".%d.%d\",&type,&subtype);\n                    if (count < 1)\n                      ThrowReaderException(CorruptImageError,\n                        \"ImproperImageHeader\");\n                  }\n                switch (type)\n                {\n                  case 1:\n                  {\n                    image->endian=LSBEndian;\n                    break;\n                  }\n                  case 2:\n                  {\n                    image->endian=MSBEndian;\n                    break;\n                  }\n                  case 4:\n                  {\n                    if ((subtype >= 80) && (subtype <= 81))\n                      image->compression=JPEGCompression;\n                    else\n                      if ((subtype >= 90) && (subtype <= 93))\n                        image->compression=JPEG2000Compression;\n                      else\n                        image->compression=JPEGCompression;\n                    break;\n                  }\n                  case 5:\n                  {\n                    image->compression=RLECompression;\n                    break;\n                  }\n                }\n              }\n            break;\n          }\n          default:\n            break;\n        }\n        break;\n      }\n      case 0x0028:\n      {\n        switch (element)\n        {\n          case 0x0002:\n          {\n            /*\n              Samples per pixel.\n            */\n            samples_per_pixel=(size_t) datum;\n            break;\n          }\n          case 0x0004:\n          {\n            /*\n              Photometric interpretation.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            for (i=0; i < (ssize_t) MagickMin(length,MagickPathExtent-1); i++)\n              photometric[i]=(char) data[i];\n            photometric[i]='\\0';\n            polarity=LocaleCompare(photometric,\"MONOCHROME1 \") == 0 ?\n              MagickTrue : MagickFalse;\n            break;\n          }\n          case 0x0006:\n          {\n            /*\n              Planar configuration.\n            */\n            if (datum == 1)\n              image->interlace=PlaneInterlace;\n            break;\n          }\n          case 0x0008:\n          {\n            /*\n              Number of frames.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            number_scenes=StringToUnsignedLong((char *) data);\n            break;\n          }\n          case 0x0010:\n          {\n            /*\n              Image rows.\n            */\n            height=(size_t) datum;\n            break;\n          }\n          case 0x0011:\n          {\n            /*\n              Image columns.\n            */\n            width=(size_t) datum;\n            break;\n          }\n          case 0x0100:\n          {\n            /*\n              Bits allocated.\n            */\n            bits_allocated=(size_t) datum;\n            bytes_per_pixel=1;\n            if (datum > 8)\n              bytes_per_pixel=2;\n            depth=bits_allocated;\n            if (depth > 32)\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            max_value=(1UL << bits_allocated)-1;\n            break;\n          }\n          case 0x0101:\n          {\n            /*\n              Bits stored.\n            */\n            significant_bits=(size_t) datum;\n            bytes_per_pixel=1;\n            if (significant_bits > 8)\n              bytes_per_pixel=2;\n            depth=significant_bits;\n            if (depth > 32)\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            max_value=(1UL << significant_bits)-1;\n            mask=(size_t) GetQuantumRange(significant_bits);\n            break;\n          }\n          case 0x0102:\n          {\n            /*\n              High bit.\n            */\n            break;\n          }\n          case 0x0103:\n          {\n            /*\n              Pixel representation.\n            */\n            signed_data=(size_t) datum;\n            break;\n          }\n          case 0x1050:\n          {\n            /*\n              Visible pixel range: center.\n            */\n            if (data != (unsigned char *) NULL)\n              window_center=(ssize_t) StringToLong((char *) data);\n            break;\n          }\n          case 0x1051:\n          {\n            /*\n              Visible pixel range: width.\n            */\n            if (data != (unsigned char *) NULL)\n              window_width=StringToUnsignedLong((char *) data);\n            break;\n          }\n          case 0x1052:\n          {\n            /*\n              Rescale intercept\n            */\n            if (data != (unsigned char *) NULL)\n              rescale_intercept=(ssize_t) StringToLong((char *) data);\n            break;\n          }\n          case 0x1053:\n          {\n            /*\n              Rescale slope\n            */\n            if (data != (unsigned char *) NULL)\n              rescale_slope=(ssize_t) StringToLong((char *) data);\n            break;\n          }\n          case 0x1200:\n          case 0x3006:\n          {\n            /*\n              Populate graymap.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            colors=(size_t) (length/bytes_per_pixel);\n            datum=(int) colors;\n            graymap=(int *) AcquireQuantumMemory((size_t) colors,\n              sizeof(*graymap));\n            if (graymap == (int *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            for (i=0; i < (ssize_t) colors; i++)\n              if (bytes_per_pixel == 1)\n                graymap[i]=(int) data[i];\n              else\n                graymap[i]=(int) ((short *) data)[i];\n            break;\n          }\n          case 0x1201:\n          {\n            unsigned short\n              index;\n\n            /*\n              Populate redmap.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            colors=(size_t) (length/2);\n            datum=(int) colors;\n            redmap=(int *) AcquireQuantumMemory((size_t) colors,\n              sizeof(*redmap));\n            if (redmap == (int *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            p=data;\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              if (image->endian == MSBEndian)\n                index=(unsigned short) ((*p << 8) | *(p+1));\n              else\n                index=(unsigned short) (*p | (*(p+1) << 8));\n              redmap[i]=(int) index;\n              p+=2;\n            }\n            break;\n          }\n          case 0x1202:\n          {\n            unsigned short\n              index;\n\n            /*\n              Populate greenmap.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            colors=(size_t) (length/2);\n            datum=(int) colors;\n            greenmap=(int *) AcquireQuantumMemory((size_t) colors,\n              sizeof(*greenmap));\n            if (greenmap == (int *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            p=data;\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              if (image->endian == MSBEndian)\n                index=(unsigned short) ((*p << 8) | *(p+1));\n              else\n                index=(unsigned short) (*p | (*(p+1) << 8));\n              greenmap[i]=(int) index;\n              p+=2;\n            }\n            break;\n          }\n          case 0x1203:\n          {\n            unsigned short\n              index;\n\n            /*\n              Populate bluemap.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            colors=(size_t) (length/2);\n            datum=(int) colors;\n            bluemap=(int *) AcquireQuantumMemory((size_t) colors,\n              sizeof(*bluemap));\n            if (bluemap == (int *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            p=data;\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              if (image->endian == MSBEndian)\n                index=(unsigned short) ((*p << 8) | *(p+1));\n              else\n                index=(unsigned short) (*p | (*(p+1) << 8));\n              bluemap[i]=(int) index;\n              p+=2;\n            }\n            break;\n          }\n          default:\n            break;\n        }\n        break;\n      }\n      case 0x2050:\n      {\n        switch (element)\n        {\n          case 0x0020:\n          {\n            if ((data != (unsigned char *) NULL) &&\n                (strncmp((char *) data,\"INVERSE\",7) == 0))\n              polarity=MagickTrue;\n            break;\n          }\n          default:\n            break;\n        }\n        break;\n      }\n      default:\n        break;\n    }\n    if (data != (unsigned char *) NULL)\n      {\n        char\n          *attribute;\n\n        for (i=0; dicom_info[i].description != (char *) NULL; i++)\n          if ((group == dicom_info[i].group) &&\n              (element == dicom_info[i].element))\n            break;\n        if (dicom_info[i].description != (char *) NULL)\n          {\n            attribute=AcquireString(\"dcm:\");\n            (void) ConcatenateString(&attribute,dicom_info[i].description);\n            for (i=0; i < (ssize_t) MagickMax(length,4); i++)\n              if (isprint((int) data[i]) == MagickFalse)\n                break;\n            if ((i == (ssize_t) length) || (length > 4))\n              {\n                (void) SubstituteString(&attribute,\" \",\"\");\n                (void) SetImageProperty(image,attribute,(char *) data,exception);\n              }\n            attribute=DestroyString(attribute);\n          }\n      }\n    if (image_info->verbose != MagickFalse)\n      {\n        if (data == (unsigned char *) NULL)\n          (void) FormatLocaleFile(stdout,\"%d\\n\",datum);\n        else\n          {\n            /*\n              Display group data.\n            */\n            for (i=0; i < (ssize_t) MagickMax(length,4); i++)\n              if (isprint((int) data[i]) == MagickFalse)\n                break;\n            if ((i != (ssize_t) length) && (length <= 4))\n              {\n                ssize_t\n                  j;\n\n                datum=0;\n                for (j=(ssize_t) length-1; j >= 0; j--)\n                  datum=(256*datum+data[j]);\n                (void) FormatLocaleFile(stdout,\"%d\",datum);\n              }\n            else\n              for (i=0; i < (ssize_t) length; i++)\n                if (isprint((int) data[i]) != MagickFalse)\n                  (void) FormatLocaleFile(stdout,\"%c\",data[i]);\n                else\n                  (void) FormatLocaleFile(stdout,\"%c\",'.');\n            (void) FormatLocaleFile(stdout,\"\\n\");\n          }\n      }\n    if (data != (unsigned char *) NULL)\n      data=(unsigned char *) RelinquishMagickMemory(data);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n  }\n  if ((width == 0) || (height == 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  image->columns=(size_t) width;\n  image->rows=(size_t) height;\n  if (signed_data == 0xffff)\n    signed_data=(size_t) (significant_bits == 16 ? 1 : 0);\n  if ((image->compression == JPEGCompression) ||\n      (image->compression == JPEG2000Compression))\n    {\n      Image\n        *images;\n\n      ImageInfo\n        *read_info;\n\n      int\n        c;\n\n      size_t\n        length;\n\n      unsigned int\n        tag;\n\n      /*\n        Read offset table.\n      */\n      for (i=0; i < (ssize_t) stream_info->remaining; i++)\n        (void) ReadBlobByte(image);\n      tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);\n      (void) tag;\n      length=(size_t) ReadBlobLSBLong(image);\n      stream_info->offset_count=length >> 2;\n      if (stream_info->offset_count != 0)\n        {\n          MagickOffsetType\n            offset;\n\n          stream_info->offsets=(ssize_t *) AcquireQuantumMemory(\n            stream_info->offset_count,sizeof(*stream_info->offsets));\n          if (stream_info->offsets == (ssize_t *) NULL)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            stream_info->offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n          offset=TellBlob(image);\n          for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            stream_info->offsets[i]+=offset;\n        }\n      /*\n        Handle non-native image formats.\n      */\n      read_info=CloneImageInfo(image_info);\n      SetImageInfoBlob(read_info,(void *) NULL,0);\n      images=NewImageList();\n      for (scene=0; scene < (ssize_t) number_scenes; scene++)\n      {\n        char\n          filename[MagickPathExtent];\n\n        const char\n          *property;\n\n        FILE\n          *file;\n\n        Image\n          *jpeg_image;\n\n        int\n          unique_file;\n\n        unsigned int\n          tag;\n\n        tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);\n        length=(size_t) ReadBlobLSBLong(image);\n        if (tag == 0xFFFEE0DD)\n          break; /* sequence delimiter tag */\n        if (tag != 0xFFFEE000)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        file=(FILE *) NULL;\n        unique_file=AcquireUniqueFileResource(filename);\n        if (unique_file != -1)\n          file=fdopen(unique_file,\"wb\");\n        if (file == (FILE *) NULL)\n          {\n            (void) RelinquishUniqueFileResource(filename);\n            ThrowFileException(exception,FileOpenError,\n              \"UnableToCreateTemporaryFile\",filename);\n            break;\n          }\n        for ( ; length != 0; length--)\n        {\n          c=ReadBlobByte(image);\n          if (c == EOF)\n            {\n              ThrowFileException(exception,CorruptImageError,\n                \"UnexpectedEndOfFile\",image->filename);\n              break;\n            }\n          (void) fputc(c,file);\n        }\n        (void) fclose(file);\n        (void) FormatLocaleString(read_info->filename,MagickPathExtent,\n          \"jpeg:%s\",filename);\n        if (image->compression == JPEG2000Compression)\n          (void) FormatLocaleString(read_info->filename,MagickPathExtent,\n            \"j2k:%s\",filename);\n        jpeg_image=ReadImage(read_info,exception);\n        if (jpeg_image != (Image *) NULL)\n          {\n            ResetImagePropertyIterator(image);\n            property=GetNextImageProperty(image);\n            while (property != (const char *) NULL)\n            {\n              (void) SetImageProperty(jpeg_image,property,\n                GetImageProperty(image,property,exception),exception);\n              property=GetNextImageProperty(image);\n            }\n            AppendImageToList(&images,jpeg_image);\n          }\n        (void) RelinquishUniqueFileResource(filename);\n      }\n      read_info=DestroyImageInfo(read_info);\n      image=DestroyImage(image);\n      return(GetFirstImageInList(images));\n    }\n  if (depth != (1UL*MAGICKCORE_QUANTUM_DEPTH))\n    {\n      QuantumAny\n        range;\n\n      size_t\n        length;\n\n      /*\n        Compute pixel scaling table.\n      */\n      length=(size_t) (GetQuantumRange(depth)+1);\n      scale=(Quantum *) AcquireQuantumMemory(length,sizeof(*scale));\n      if (scale == (Quantum *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      range=GetQuantumRange(depth);\n      for (i=0; i <= (ssize_t) GetQuantumRange(depth); i++)\n        scale[i]=ScaleAnyToQuantum((size_t) i,range);\n    }\n  if (image->compression == RLECompression)\n    {\n      size_t\n        length;\n\n      unsigned int\n        tag;\n\n      /*\n        Read RLE offset table.\n      */\n      for (i=0; i < (ssize_t) stream_info->remaining; i++)\n        (void) ReadBlobByte(image);\n      tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);\n      (void) tag;\n      length=(size_t) ReadBlobLSBLong(image);\n      stream_info->offset_count=length >> 2;\n      if (stream_info->offset_count != 0)\n        {\n          MagickOffsetType\n            offset;\n\n          stream_info->offsets=(ssize_t *) AcquireQuantumMemory(\n            stream_info->offset_count,sizeof(*stream_info->offsets));\n          if (stream_info->offsets == (ssize_t *) NULL)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            stream_info->offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n          offset=TellBlob(image);\n          for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            stream_info->offsets[i]+=offset;\n        }\n    }\n  for (scene=0; scene < (ssize_t) number_scenes; scene++)\n  {\n    if (image_info->ping != MagickFalse)\n      break;\n    image->columns=(size_t) width;\n    image->rows=(size_t) height;\n    image->depth=depth;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      break;\n    image->colorspace=RGBColorspace;\n    if ((image->colormap == (PixelInfo *) NULL) && (samples_per_pixel == 1))\n      {\n        size_t\n          one;\n\n        one=1;\n        if (colors == 0)\n          colors=one << depth;\n        if (AcquireImageColormap(image,one << depth,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        if (redmap != (int *) NULL)\n          for (i=0; i < (ssize_t) colors; i++)\n          {\n            index=redmap[i];\n            if ((scale != (Quantum *) NULL) && (index <= (int) max_value))\n              index=(int) scale[index];\n            image->colormap[i].red=(MagickRealType) index;\n          }\n        if (greenmap != (int *) NULL)\n          for (i=0; i < (ssize_t) colors; i++)\n          {\n            index=greenmap[i];\n            if ((scale != (Quantum *) NULL) && (index <= (int) max_value))\n              index=(int) scale[index];\n            image->colormap[i].green=(MagickRealType) index;\n          }\n        if (bluemap != (int *) NULL)\n          for (i=0; i < (ssize_t) colors; i++)\n          {\n            index=bluemap[i];\n            if ((scale != (Quantum *) NULL) && (index <= (int) max_value))\n              index=(int) scale[index];\n            image->colormap[i].blue=(MagickRealType) index;\n          }\n        if (graymap != (int *) NULL)\n          for (i=0; i < (ssize_t) colors; i++)\n          {\n            index=graymap[i];\n            if ((scale != (Quantum *) NULL) && (index <= (int) max_value))\n              index=(int) scale[index];\n            image->colormap[i].red=(MagickRealType) index;\n            image->colormap[i].green=(MagickRealType) index;\n            image->colormap[i].blue=(MagickRealType) index;\n          }\n      }\n    if (image->compression == RLECompression)\n      {\n        unsigned int\n          tag;\n\n        /*\n          Read RLE segment table.\n        */\n        for (i=0; i < (ssize_t) stream_info->remaining; i++)\n          (void) ReadBlobByte(image);\n        tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);\n        stream_info->remaining=(size_t) ReadBlobLSBLong(image);\n        if ((tag != 0xFFFEE000) || (stream_info->remaining <= 64) ||\n            (EOFBlob(image) != MagickFalse))\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        stream_info->count=0;\n        stream_info->segment_count=ReadBlobLSBLong(image);\n        if (stream_info->segment_count > 1)\n          {\n            bytes_per_pixel=1;\n            depth=8;\n          }\n        for (i=0; i < 15; i++)\n          stream_info->segments[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n        stream_info->remaining-=64;\n      }\n    if ((samples_per_pixel > 1) && (image->interlace == PlaneInterlace))\n      {\n        /*\n          Convert Planar RGB DCM Medical image to pixel packets.\n        */\n        for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              switch ((int) i)\n              {\n                case 0:\n                {\n                  SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n                    ReadDCMByte(stream_info,image)),q);\n                  break;\n                }\n                case 1:\n                {\n                  SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n                    ReadDCMByte(stream_info,image)),q);\n                  break;\n                }\n                case 2:\n                {\n                  SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n                    ReadDCMByte(stream_info,image)),q);\n                  break;\n                }\n                case 3:\n                {\n                  SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)\n                    ReadDCMByte(stream_info,image)),q);\n                  break;\n                }\n                default:\n                  break;\n              }\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                  image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n      }\n    else\n      {\n        const char\n          *option;\n\n        int\n          byte;\n\n        PixelPacket\n          pixel;\n\n        /*\n          Convert DCM Medical image to pixel packets.\n        */\n        byte=0;\n        i=0;\n        if ((window_center != 0) && (window_width == 0))\n          window_width=(size_t) window_center;\n        option=GetImageOption(image_info,\"dcm:display-range\");\n        if (option != (const char *) NULL)\n          {\n            if (LocaleCompare(option,\"reset\") == 0)\n              window_width=0;\n          }\n        (void) ResetMagickMemory(&pixel,0,sizeof(pixel));\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if (samples_per_pixel == 1)\n              {\n                int\n                  pixel_value;\n\n                if (bytes_per_pixel == 1)\n                  pixel_value=polarity != MagickFalse ?\n                    ((int) max_value-ReadDCMByte(stream_info,image)) :\n                    ReadDCMByte(stream_info,image);\n                else\n                  if ((bits_allocated != 12) || (significant_bits != 12))\n                    {\n                      if (signed_data)\n                        pixel_value=ReadDCMSignedShort(stream_info,image);\n                      else\n                        pixel_value=ReadDCMShort(stream_info,image);\n                      if (polarity != MagickFalse)\n                        pixel_value=(int)max_value-pixel_value;\n                    }\n                  else\n                    {\n                      if ((i & 0x01) != 0)\n                        pixel_value=(ReadDCMByte(stream_info,image) << 8) |\n                          byte;\n                      else\n                        {\n                          pixel_value=ReadDCMSignedShort(stream_info,image);\n                          byte=(int) (pixel_value & 0x0f);\n                          pixel_value>>=4;\n                        }\n                      i++;\n                    }\n                index=(pixel_value*rescale_slope)+rescale_intercept;\n                if (window_width == 0)\n                  {\n                    if (signed_data == 1)\n                      index-=32767;\n                  }\n                else\n                  {\n                    ssize_t\n                      window_max,\n                      window_min;\n\n                    window_min=(ssize_t) ceil((double) window_center-\n                      (window_width-1.0)/2.0-0.5);\n                    window_max=(ssize_t) floor((double) window_center+\n                      (window_width-1.0)/2.0+0.5);\n                    if ((ssize_t)index <= window_min)\n                      index=0;\n                    else\n                      if ((ssize_t)index > window_max)\n                        index=(int) max_value;\n                      else\n                        index=(int) (max_value*(((index-window_center-\n                          0.5)/(window_width-1))+0.5));\n                  }\n                index&=mask;\n                index=(int) ConstrainColormapIndex(image,(size_t) index,\n                  exception);\n                SetPixelIndex(image,(Quantum) index,q);\n                pixel.red=(unsigned int) image->colormap[index].red;\n                pixel.green=(unsigned int) image->colormap[index].green;\n                pixel.blue=(unsigned int) image->colormap[index].blue;\n              }\n            else\n              {\n                if (bytes_per_pixel == 1)\n                  {\n                    pixel.red=(unsigned int) ReadDCMByte(stream_info,image);\n                    pixel.green=(unsigned int) ReadDCMByte(stream_info,image);\n                    pixel.blue=(unsigned int) ReadDCMByte(stream_info,image);\n                  }\n                else\n                  {\n                    pixel.red=ReadDCMShort(stream_info,image);\n                    pixel.green=ReadDCMShort(stream_info,image);\n                    pixel.blue=ReadDCMShort(stream_info,image);\n                  }\n                pixel.red&=mask;\n                pixel.green&=mask;\n                pixel.blue&=mask;\n                if (scale != (Quantum *) NULL)\n                  {\n                    if (pixel.red <= GetQuantumRange(depth))\n                      pixel.red=scale[pixel.red];\n                    if (pixel.green <= GetQuantumRange(depth))\n                      pixel.green=scale[pixel.green];\n                    if (pixel.blue <= GetQuantumRange(depth))\n                      pixel.blue=scale[pixel.blue];\n                  }\n              }\n            SetPixelRed(image,(Quantum) pixel.red,q);\n            SetPixelGreen(image,(Quantum) pixel.green,q);\n            SetPixelBlue(image,(Quantum) pixel.blue,q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        if (stream_info->segment_count > 1)\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (samples_per_pixel == 1)\n                {\n                  int\n                    pixel_value;\n\n                  if (bytes_per_pixel == 1)\n                    pixel_value=polarity != MagickFalse ?\n                      ((int) max_value-ReadDCMByte(stream_info,image)) :\n                      ReadDCMByte(stream_info,image);\n                  else\n                    if ((bits_allocated != 12) || (significant_bits != 12))\n                      {\n                        pixel_value=(int) (polarity != MagickFalse ?\n                          (max_value-ReadDCMShort(stream_info,image)) :\n                          ReadDCMShort(stream_info,image));\n                        if (signed_data == 1)\n                          pixel_value=((signed short) pixel_value);\n                      }\n                    else\n                      {\n                        if ((i & 0x01) != 0)\n                          pixel_value=(ReadDCMByte(stream_info,image) << 8) |\n                            byte;\n                        else\n                          {\n                            pixel_value=ReadDCMShort(stream_info,image);\n                            byte=(int) (pixel_value & 0x0f);\n                            pixel_value>>=4;\n                          }\n                        i++;\n                      }\n                  index=(pixel_value*rescale_slope)+rescale_intercept;\n                  if (window_width == 0)\n                    {\n                      if (signed_data == 1)\n                        index-=32767;\n                    }\n                  else\n                    {\n                      ssize_t\n                        window_max,\n                        window_min;\n\n                      window_min=(ssize_t) ceil((double) window_center-\n                        (window_width-1.0)/2.0-0.5);\n                      window_max=(ssize_t) floor((double) window_center+\n                        (window_width-1.0)/2.0+0.5);\n                      if ((ssize_t)index <= window_min)\n                        index=0;\n                      else\n                        if ((ssize_t)index > window_max)\n                          index=(int) max_value;\n                        else\n                          index=(int) (max_value*(((index-window_center-\n                            0.5)/(window_width-1))+0.5));\n                    }\n                  index&=mask;\n                  index=(int) ConstrainColormapIndex(image,(size_t) index,\n                    exception);\n                  SetPixelIndex(image,(Quantum) (((size_t)\n                    GetPixelIndex(image,q)) | (((size_t) index) << 8)),q);\n                  pixel.red=(unsigned int) image->colormap[index].red;\n                  pixel.green=(unsigned int) image->colormap[index].green;\n                  pixel.blue=(unsigned int) image->colormap[index].blue;\n                }\n              else\n                {\n                  if (bytes_per_pixel == 1)\n                    {\n                      pixel.red=(unsigned int) ReadDCMByte(stream_info,image);\n                      pixel.green=(unsigned int) ReadDCMByte(stream_info,image);\n                      pixel.blue=(unsigned int) ReadDCMByte(stream_info,image);\n                    }\n                  else\n                    {\n                      pixel.red=ReadDCMShort(stream_info,image);\n                      pixel.green=ReadDCMShort(stream_info,image);\n                      pixel.blue=ReadDCMShort(stream_info,image);\n                    }\n                  pixel.red&=mask;\n                  pixel.green&=mask;\n                  pixel.blue&=mask;\n                  if (scale != (Quantum *) NULL)\n                    {\n                      pixel.red=scale[pixel.red];\n                      pixel.green=scale[pixel.green];\n                      pixel.blue=scale[pixel.blue];\n                    }\n                }\n              SetPixelRed(image,(Quantum) (((size_t) GetPixelRed(image,q)) |\n                (((size_t) pixel.red) << 8)),q);\n              SetPixelGreen(image,(Quantum) (((size_t) GetPixelGreen(image,q)) |\n                (((size_t) pixel.green) << 8)),q);\n              SetPixelBlue(image,(Quantum) (((size_t) GetPixelBlue(image,q)) |\n                (((size_t) pixel.blue) << 8)),q);\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                  image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n      }\n    if (SetImageGray(image,exception) != MagickFalse)\n      (void) SetImageColorspace(image,GRAYColorspace,exception);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if (scene < (ssize_t) (number_scenes-1))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  /*\n    Free resources.\n  */\n  if (stream_info->offsets != (ssize_t *) NULL)\n    stream_info->offsets=(ssize_t *)\n      RelinquishMagickMemory(stream_info->offsets);\n  stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info);\n  if (scale != (Quantum *) NULL)\n    scale=(Quantum *) RelinquishMagickMemory(scale);\n  if (graymap != (int *) NULL)\n    graymap=(int *) RelinquishMagickMemory(graymap);\n  if (bluemap != (int *) NULL)\n    bluemap=(int *) RelinquishMagickMemory(bluemap);\n  if (greenmap != (int *) NULL)\n    greenmap=(int *) RelinquishMagickMemory(greenmap);\n  if (redmap != (int *) NULL)\n    redmap=(int *) RelinquishMagickMemory(redmap);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 635,
    "critical_vars": [
      "tiff",
      "&text"
    ],
    "function": "TIFFGetProperties",
    "filename": "ImageMagick/CVE-2016-9559/CVE-2016-9559_CWE-476_b61d35eaccc0a7ddeff8a1c3abfcd0a43ccf210b_tiff.c.diff",
    "function_code": "static void TIFFGetProperties(TIFF *tiff,Image *image,ExceptionInfo *exception)\n{\n  char\n    message[MagickPathExtent],\n    *text;\n\n  uint32\n    count,\n    length,\n    type;\n\n  unsigned long\n    *tietz;\n\n\n  if (TIFFGetField(tiff,TIFFTAG_ARTIST,&text) == 1)\n    (void) SetImageProperty(image,\"tiff:artist\",text,exception);\n  if (TIFFGetField(tiff,TIFFTAG_COPYRIGHT,&text) == 1)\n    (void) SetImageProperty(image,\"tiff:copyright\",text,exception);\n  if (TIFFGetField(tiff,TIFFTAG_DATETIME,&text) == 1)\n    (void) SetImageProperty(image,\"tiff:timestamp\",text,exception);\n  if (TIFFGetField(tiff,TIFFTAG_DOCUMENTNAME,&text) == 1)\n    (void) SetImageProperty(image,\"tiff:document\",text,exception);\n  if (TIFFGetField(tiff,TIFFTAG_HOSTCOMPUTER,&text) == 1)\n    (void) SetImageProperty(image,\"tiff:hostcomputer\",text,exception);\n  if (TIFFGetField(tiff,TIFFTAG_IMAGEDESCRIPTION,&text) == 1)\n    (void) SetImageProperty(image,\"comment\",text,exception);\n  if (TIFFGetField(tiff,TIFFTAG_MAKE,&text) == 1)\n    (void) SetImageProperty(image,\"tiff:make\",text,exception);\n  if (TIFFGetField(tiff,TIFFTAG_MODEL,&text) == 1)\n    (void) SetImageProperty(image,\"tiff:model\",text,exception);\n  if (TIFFGetField(tiff,TIFFTAG_OPIIMAGEID,&count,&text) == 1)\n    {\n      if (count >= MagickPathExtent)\n        count=MagickPathExtent-1;\n      (void) CopyMagickString(message,text,count+1);\n      (void) SetImageProperty(image,\"tiff:image-id\",message,exception);\n    }\n  if (TIFFGetField(tiff,TIFFTAG_PAGENAME,&text) == 1)\n    (void) SetImageProperty(image,\"label\",text,exception);\n  if (TIFFGetField(tiff,TIFFTAG_SOFTWARE,&text) == 1)\n    (void) SetImageProperty(image,\"tiff:software\",text,exception);\n  if (TIFFGetField(tiff,33423,&count,&text) == 1)\n    {\n      if (count >= MagickPathExtent)\n        count=MagickPathExtent-1;\n      (void) CopyMagickString(message,text,count+1);\n      (void) SetImageProperty(image,\"tiff:kodak-33423\",message,exception);\n    }\n  if (TIFFGetField(tiff,36867,&count,&text) == 1)\n    {\n      if (count >= MagickPathExtent)\n        count=MagickPathExtent-1;\n      (void) CopyMagickString(message,text,count+1);\n      (void) SetImageProperty(image,\"tiff:kodak-36867\",message,exception);\n    }\n  if (TIFFGetField(tiff,TIFFTAG_SUBFILETYPE,&type) == 1)\n    switch (type)\n    {\n      case 0x01:\n      {\n        (void) SetImageProperty(image,\"tiff:subfiletype\",\"REDUCEDIMAGE\",\n          exception);\n        break;\n      }\n      case 0x02:\n      {\n        (void) SetImageProperty(image,\"tiff:subfiletype\",\"PAGE\",exception);\n        break;\n      }\n      case 0x04:\n      {\n        (void) SetImageProperty(image,\"tiff:subfiletype\",\"MASK\",exception);\n        break;\n      }\n      default:\n        break;\n    }\n  if (TIFFGetField(tiff,37706,&length,&tietz) == 1)\n    {\n      (void) FormatLocaleString(message,MagickPathExtent,\"%lu\",tietz[0]);\n      (void) SetImageProperty(image,\"tiff:tietz_offset\",message,exception);\n    }\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 634,
    "critical_vars": [
      "tiff",
      "text",
      "&text"
    ],
    "function": "TIFFGetProperties",
    "filename": "ImageMagick/CVE-2016-9559/CVE-2016-9559_CWE-476_b61d35eaccc0a7ddeff8a1c3abfcd0a43ccf210b_tiff.c.diff",
    "function_code": "static void TIFFGetProperties(TIFF *tiff,Image *image,ExceptionInfo *exception)\n{\n  char\n    message[MagickPathExtent],\n    *text;\n\n  uint32\n    count,\n    length,\n    type;\n\n  unsigned long\n    *tietz;\n\n  if ((TIFFGetField(tiff,TIFFTAG_ARTIST,&text) == 1) &&\n      (text != (char *) NULL))\n    (void) SetImageProperty(image,\"tiff:artist\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_COPYRIGHT,&text) == 1) &&\n      (text != (char *) NULL))\n    (void) SetImageProperty(image,\"tiff:copyright\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_DATETIME,&text) == 1) &&\n      (text != (char *) NULL))\n    (void) SetImageProperty(image,\"tiff:timestamp\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_DOCUMENTNAME,&text) == 1) &&\n      (text != (char *) NULL))\n    (void) SetImageProperty(image,\"tiff:document\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_HOSTCOMPUTER,&text) == 1) &&\n      (text != (char *) NULL))\n    (void) SetImageProperty(image,\"tiff:hostcomputer\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_IMAGEDESCRIPTION,&text) == 1) &&\n      (text != (char *) NULL))\n    (void) SetImageProperty(image,\"comment\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_MAKE,&text) == 1) &&\n      (text != (char *) NULL))\n    (void) SetImageProperty(image,\"tiff:make\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_MODEL,&text) == 1) &&\n      (text != (char *) NULL))\n    (void) SetImageProperty(image,\"tiff:model\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_OPIIMAGEID,&count,&text) == 1) &&\n      (text != (char *) NULL))\n    {\n      if (count >= MagickPathExtent)\n        count=MagickPathExtent-1;\n      (void) CopyMagickString(message,text,count+1);\n      (void) SetImageProperty(image,\"tiff:image-id\",message,exception);\n    }\n  if ((TIFFGetField(tiff,TIFFTAG_PAGENAME,&text) == 1) &&\n      (text != (char *) NULL))\n    (void) SetImageProperty(image,\"label\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_SOFTWARE,&text) == 1) &&\n      (text != (char *) NULL))\n    (void) SetImageProperty(image,\"tiff:software\",text,exception);\n  if ((TIFFGetField(tiff,33423,&count,&text) == 1) &&\n      (text != (char *) NULL))\n    {\n      if (count >= MagickPathExtent)\n        count=MagickPathExtent-1;\n      (void) CopyMagickString(message,text,count+1);\n      (void) SetImageProperty(image,\"tiff:kodak-33423\",message,exception);\n    }\n  if ((TIFFGetField(tiff,36867,&count,&text) == 1) &&\n      (text != (char *) NULL))\n    {\n      if (count >= MagickPathExtent)\n        count=MagickPathExtent-1;\n      (void) CopyMagickString(message,text,count+1);\n      (void) SetImageProperty(image,\"tiff:kodak-36867\",message,exception);\n    }\n  if (TIFFGetField(tiff,TIFFTAG_SUBFILETYPE,&type) == 1)\n    switch (type)\n    {\n      case 0x01:\n      {\n        (void) SetImageProperty(image,\"tiff:subfiletype\",\"REDUCEDIMAGE\",\n          exception);\n        break;\n      }\n      case 0x02:\n      {\n        (void) SetImageProperty(image,\"tiff:subfiletype\",\"PAGE\",exception);\n        break;\n      }\n      case 0x04:\n      {\n        (void) SetImageProperty(image,\"tiff:subfiletype\",\"MASK\",exception);\n        break;\n      }\n      default:\n        break;\n    }\n  if ((TIFFGetField(tiff,37706,&length,&tietz) == 1) &&\n      (tietz != (unsigned long *) NULL))\n    {\n      (void) FormatLocaleString(message,MagickPathExtent,\"%lu\",tietz[0]);\n      (void) SetImageProperty(image,\"tiff:tietz_offset\",message,exception);\n    }\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 8273,
    "critical_vars": [
      "Image",
      "image"
    ],
    "function": "WriteOnePNGImage",
    "filename": "ImageMagick/CVE-2017-11522/CVE-2017-11522_CWE-476_816ecab6c532ae086ff4186b3eaf4aa7092d536f_png.c.diff",
    "function_code": "static MagickBooleanType WriteOnePNGImage(MngInfo *mng_info,\n  const ImageInfo *IMimage_info,Image *IMimage,ExceptionInfo *exception)\n{\n  char\n    im_vers[32],\n    libpng_runv[32],\n    libpng_vers[32],\n    zlib_runv[32],\n    zlib_vers[32];\n\n  Image\n    *image;\n\n  ImageInfo\n    *image_info;\n\n  char\n    s[2];\n\n  const char\n    *name,\n    *property,\n    *value;\n\n  const StringInfo\n    *profile;\n\n  int\n    num_passes,\n    pass,\n    ping_wrote_caNv;\n\n  png_byte\n     ping_trans_alpha[256];\n\n  png_color\n     palette[257];\n\n  png_color_16\n    ping_background,\n    ping_trans_color;\n\n  png_info\n    *ping_info;\n\n  png_struct\n    *ping;\n\n  png_uint_32\n    ping_height,\n    ping_width;\n\n  ssize_t\n    y;\n\n  MagickBooleanType\n    image_matte,\n    logging,\n    matte,\n\n    ping_have_blob,\n    ping_have_cheap_transparency,\n    ping_have_color,\n    ping_have_non_bw,\n    ping_have_PLTE,\n    ping_have_bKGD,\n    ping_have_eXIf,\n    ping_have_iCCP,\n    ping_have_pHYs,\n    ping_have_sRGB,\n    ping_have_tRNS,\n\n    ping_exclude_bKGD,\n    ping_exclude_cHRM,\n    ping_exclude_date,\n    /* ping_exclude_EXIF, */\n    ping_exclude_eXIf,\n    ping_exclude_gAMA,\n    ping_exclude_iCCP,\n    /* ping_exclude_iTXt, */\n    ping_exclude_oFFs,\n    ping_exclude_pHYs,\n    ping_exclude_sRGB,\n    ping_exclude_tEXt,\n    ping_exclude_tIME,\n    /* ping_exclude_tRNS, */\n    ping_exclude_vpAg,\n    ping_exclude_caNv,\n    ping_exclude_zCCP, /* hex-encoded iCCP */\n    ping_exclude_zTXt,\n\n    ping_preserve_colormap,\n    ping_preserve_iCCP,\n    ping_need_colortype_warning,\n\n    status,\n    tried_332,\n    tried_333,\n    tried_444;\n\n  MemoryInfo\n    *volatile pixel_info;\n\n  QuantumInfo\n    *quantum_info;\n\n  PNGErrorInfo\n    error_info;\n\n  register ssize_t\n    i,\n    x;\n\n  unsigned char\n    *ping_pixels;\n\n  volatile int\n    image_colors,\n    ping_bit_depth,\n    ping_color_type,\n    ping_interlace_method,\n    ping_compression_method,\n    ping_filter_method,\n    ping_num_trans;\n\n  volatile size_t\n    image_depth,\n    old_bit_depth;\n\n  size_t\n    quality,\n    rowbytes,\n    save_image_depth;\n\n  int\n    j,\n    number_colors,\n    number_opaque,\n    number_semitransparent,\n    number_transparent,\n    ping_pHYs_unit_type;\n\n  png_uint_32\n    ping_pHYs_x_resolution,\n    ping_pHYs_y_resolution;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  Enter WriteOnePNGImage()\");\n\n  image = CloneImage(IMimage,0,0,MagickFalse,exception);\n  if (image == (Image *) NULL)\n    return(MagickFalse);\n  image_info=(ImageInfo *) CloneImageInfo(IMimage_info);\n  if (image_info == (ImageInfo *) NULL)\n    ThrowWriterException(ResourceLimitError, \"MemoryAllocationFailed\");\n\n  /* Define these outside of the following \"if logging()\" block so they will\n   * show in debuggers.\n   */\n  *im_vers='\\0';\n  (void) ConcatenateMagickString(im_vers,\n         MagickLibVersionText,MagickPathExtent);\n  (void) ConcatenateMagickString(im_vers,\n         MagickLibAddendum,MagickPathExtent);\n\n  *libpng_vers='\\0';\n  (void) ConcatenateMagickString(libpng_vers,\n         PNG_LIBPNG_VER_STRING,32);\n  *libpng_runv='\\0';\n  (void) ConcatenateMagickString(libpng_runv,\n         png_get_libpng_ver(NULL),32);\n\n  *zlib_vers='\\0';\n  (void) ConcatenateMagickString(zlib_vers,\n         ZLIB_VERSION,32);\n  *zlib_runv='\\0';\n  (void) ConcatenateMagickString(zlib_runv,\n         zlib_version,32);\n\n  if (logging != MagickFalse)\n    {\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"    IM version     = %s\",\n           im_vers);\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"    Libpng version = %s\",\n           libpng_vers);\n       if (LocaleCompare(libpng_vers,libpng_runv) != 0)\n       {\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"      running with   %s\",\n           libpng_runv);\n       }\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"    Zlib version   = %s\",\n           zlib_vers);\n       if (LocaleCompare(zlib_vers,zlib_runv) != 0)\n       {\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"      running with   %s\",\n           zlib_runv);\n       }\n    }\n\n  /* Initialize some stuff */\n  ping_bit_depth=0,\n  ping_color_type=0,\n  ping_interlace_method=0,\n  ping_compression_method=0,\n  ping_filter_method=0,\n  ping_num_trans = 0;\n\n  ping_background.red = 0;\n  ping_background.green = 0;\n  ping_background.blue = 0;\n  ping_background.gray = 0;\n  ping_background.index = 0;\n\n  ping_trans_color.red=0;\n  ping_trans_color.green=0;\n  ping_trans_color.blue=0;\n  ping_trans_color.gray=0;\n\n  ping_pHYs_unit_type = 0;\n  ping_pHYs_x_resolution = 0;\n  ping_pHYs_y_resolution = 0;\n\n  ping_have_blob=MagickFalse;\n  ping_have_cheap_transparency=MagickFalse;\n  ping_have_color=MagickTrue;\n  ping_have_non_bw=MagickTrue;\n  ping_have_PLTE=MagickFalse;\n  ping_have_bKGD=MagickFalse;\n  ping_have_eXIf=MagickTrue;\n  ping_have_iCCP=MagickFalse;\n  ping_have_pHYs=MagickFalse;\n  ping_have_sRGB=MagickFalse;\n  ping_have_tRNS=MagickFalse;\n\n  ping_exclude_bKGD=mng_info->ping_exclude_bKGD;\n  ping_exclude_caNv=mng_info->ping_exclude_caNv;\n  ping_exclude_cHRM=mng_info->ping_exclude_cHRM;\n  ping_exclude_date=mng_info->ping_exclude_date;\n  ping_exclude_eXIf=mng_info->ping_exclude_eXIf;\n  ping_exclude_gAMA=mng_info->ping_exclude_gAMA;\n  ping_exclude_iCCP=mng_info->ping_exclude_iCCP;\n  /* ping_exclude_iTXt=mng_info->ping_exclude_iTXt; */\n  ping_exclude_oFFs=mng_info->ping_exclude_oFFs;\n  ping_exclude_pHYs=mng_info->ping_exclude_pHYs;\n  ping_exclude_sRGB=mng_info->ping_exclude_sRGB;\n  ping_exclude_tEXt=mng_info->ping_exclude_tEXt;\n  ping_exclude_tIME=mng_info->ping_exclude_tIME;\n  /* ping_exclude_tRNS=mng_info->ping_exclude_tRNS; */\n  ping_exclude_vpAg=mng_info->ping_exclude_vpAg;\n  ping_exclude_zCCP=mng_info->ping_exclude_zCCP; /* hex-encoded iCCP in zTXt */\n  ping_exclude_zTXt=mng_info->ping_exclude_zTXt;\n\n  ping_preserve_colormap = mng_info->ping_preserve_colormap;\n  ping_preserve_iCCP = mng_info->ping_preserve_iCCP;\n  ping_need_colortype_warning = MagickFalse;\n\n  /* Recognize the ICC sRGB profile and convert it to the sRGB chunk,\n   * i.e., eliminate the ICC profile and set image->rendering_intent.\n   * Note that this will not involve any changes to the actual pixels\n   * but merely passes information to applications that read the resulting\n   * PNG image.\n   *\n   * To do: recognize other variants of the sRGB profile, using the CRC to\n   * verify all recognized variants including the 7 already known.\n   *\n   * Work around libpng16+ rejecting some \"known invalid sRGB profiles\".\n   *\n   * Use something other than image->rendering_intent to record the fact\n   * that the sRGB profile was found.\n   *\n   * Record the ICC version (currently v2 or v4) of the incoming sRGB ICC\n   * profile.  Record the Blackpoint Compensation, if any.\n   */\n   if (ping_exclude_sRGB == MagickFalse && ping_preserve_iCCP == MagickFalse)\n   {\n      char\n        *name;\n\n      const StringInfo\n        *profile;\n\n      ResetImageProfileIterator(image);\n      for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n      {\n        profile=GetImageProfile(image,name);\n\n        if (profile != (StringInfo *) NULL)\n          {\n            if ((LocaleCompare(name,\"ICC\") == 0) ||\n                (LocaleCompare(name,\"ICM\") == 0))\n\n             {\n                 int\n                   icheck,\n                   got_crc=0;\n\n\n                 png_uint_32\n                   length,\n                   profile_crc=0;\n\n                 unsigned char\n                   *data;\n\n                 length=(png_uint_32) GetStringInfoLength(profile);\n\n                 for (icheck=0; sRGB_info[icheck].len > 0; icheck++)\n                 {\n                   if (length == sRGB_info[icheck].len)\n                   {\n                     if (got_crc == 0)\n                     {\n                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                         \"    Got a %lu-byte ICC profile (potentially sRGB)\",\n                         (unsigned long) length);\n\n                       data=GetStringInfoDatum(profile);\n                       profile_crc=crc32(0,data,length);\n\n                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                           \"      with crc=%8x\",(unsigned int) profile_crc);\n                       got_crc++;\n                     }\n\n                     if (profile_crc == sRGB_info[icheck].crc)\n                     {\n                        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"      It is sRGB with rendering intent = %s\",\n                        Magick_RenderingIntentString_from_PNG_RenderingIntent(\n                             sRGB_info[icheck].intent));\n                        if (image->rendering_intent==UndefinedIntent)\n                        {\n                          image->rendering_intent=\n                          Magick_RenderingIntent_from_PNG_RenderingIntent(\n                             sRGB_info[icheck].intent);\n                        }\n                        ping_exclude_iCCP = MagickTrue;\n                        ping_exclude_zCCP = MagickTrue;\n                        ping_have_sRGB = MagickTrue;\n                        break;\n                     }\n                   }\n                 }\n                 if (sRGB_info[icheck].len == 0)\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"    Got %lu-byte ICC profile not recognized as sRGB\",\n                        (unsigned long) length);\n              }\n          }\n        name=GetNextImageProfile(image);\n      }\n  }\n\n  number_opaque = 0;\n  number_semitransparent = 0;\n  number_transparent = 0;\n\n  if (logging != MagickFalse)\n    {\n      if (image->storage_class == UndefinedClass)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    image->storage_class=UndefinedClass\");\n      if (image->storage_class == DirectClass)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    image->storage_class=DirectClass\");\n      if (image->storage_class == PseudoClass)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    image->storage_class=PseudoClass\");\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(), image->taint ?\n          \"    image->taint=MagickTrue\":\n          \"    image->taint=MagickFalse\");\n    }\n\n  if (image->storage_class == PseudoClass &&\n     (mng_info->write_png8 || mng_info->write_png24 || mng_info->write_png32 ||\n     mng_info->write_png48 || mng_info->write_png64 ||\n     (mng_info->write_png_colortype != 1 &&\n     mng_info->write_png_colortype != 5)))\n    {\n      (void) SyncImage(image,exception);\n      image->storage_class = DirectClass;\n    }\n\n  if (ping_preserve_colormap == MagickFalse)\n    {\n      if (image->storage_class != PseudoClass && image->colormap != NULL)\n        {\n          /* Free the bogus colormap; it can cause trouble later */\n           if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Freeing bogus colormap\");\n           (void) RelinquishMagickMemory(image->colormap);\n           image->colormap=NULL;\n        }\n    }\n\n  if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n\n  /*\n    Sometimes we get PseudoClass images whose RGB values don't match\n    the colors in the colormap.  This code syncs the RGB values.\n  */\n  if (image->depth <= 8 && image->taint && image->storage_class == PseudoClass)\n     (void) SyncImage(image,exception);\n\n#if (MAGICKCORE_QUANTUM_DEPTH == 8)\n  if (image->depth > 8)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Reducing PNG bit depth to 8 since this is a Q8 build.\");\n\n      image->depth=8;\n    }\n#endif\n\n  /* Respect the -depth option */\n  if (image->depth < 4)\n    {\n       register Quantum\n         *r;\n\n       if (image->depth > 2)\n         {\n           /* Scale to 4-bit */\n           LBR04PacketRGBO(image->background_color);\n\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (r == (Quantum *) NULL)\n               break;\n\n             for (x=0; x < (ssize_t) image->columns; x++)\n             {\n                LBR04PixelRGBA(r);\n                r+=GetPixelChannels(image);\n             }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n           }\n\n           if (image->storage_class == PseudoClass && image->colormap != NULL)\n           {\n             for (i=0; i < (ssize_t) image->colors; i++)\n             {\n               LBR04PacketRGBO(image->colormap[i]);\n             }\n           }\n         }\n       else if (image->depth > 1)\n         {\n           /* Scale to 2-bit */\n           LBR02PacketRGBO(image->background_color);\n\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (r == (Quantum *) NULL)\n               break;\n\n             for (x=0; x < (ssize_t) image->columns; x++)\n             {\n                LBR02PixelRGBA(r);\n                r+=GetPixelChannels(image);\n             }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n           }\n\n           if (image->storage_class == PseudoClass && image->colormap != NULL)\n           {\n             for (i=0; i < (ssize_t) image->colors; i++)\n             {\n               LBR02PacketRGBO(image->colormap[i]);\n             }\n           }\n         }\n       else\n         {\n           /* Scale to 1-bit */\n           LBR01PacketRGBO(image->background_color);\n\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (r == (Quantum *) NULL)\n               break;\n\n             for (x=0; x < (ssize_t) image->columns; x++)\n             {\n                LBR01PixelRGBA(r);\n                r+=GetPixelChannels(image);\n             }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n           }\n\n           if (image->storage_class == PseudoClass && image->colormap != NULL)\n           {\n             for (i=0; i < (ssize_t) image->colors; i++)\n             {\n               LBR01PacketRGBO(image->colormap[i]);\n             }\n           }\n         }\n    }\n\n  /* To do: set to next higher multiple of 8 */\n  if (image->depth < 8)\n     image->depth=8;\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n  /* PNG does not handle depths greater than 16 so reduce it even\n   * if lossy\n   */\n  if (image->depth > 8)\n      image->depth=16;\n#endif\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 8)\n  if (image->depth > 8)\n    {\n      /* To do: fill low byte properly */\n      image->depth=16;\n    }\n\n  if (image->depth == 16 && mng_info->write_png_depth != 16)\n    if (mng_info->write_png8 ||\n        LosslessReduceDepthOK(image,exception) != MagickFalse)\n      image->depth = 8;\n#endif\n\n  image_colors = (int) image->colors;\n  number_opaque = (int) image->colors;\n  number_transparent = 0;\n  number_semitransparent = 0;\n\n  if (mng_info->write_png_colortype &&\n     (mng_info->write_png_colortype > 4 || (mng_info->write_png_depth >= 8 &&\n     mng_info->write_png_colortype < 4 &&\n     image->alpha_trait == UndefinedPixelTrait)))\n  {\n     /* Avoid the expensive BUILD_PALETTE operation if we're sure that we\n      * are not going to need the result.\n      */\n     if (mng_info->write_png_colortype == 1 ||\n        mng_info->write_png_colortype == 5)\n       ping_have_color=MagickFalse;\n\n     if (image->alpha_trait != UndefinedPixelTrait)\n       {\n         number_transparent = 2;\n         number_semitransparent = 1;\n       }\n  }\n\n  if (mng_info->write_png_colortype < 7)\n  {\n  /* BUILD_PALETTE\n   *\n   * Normally we run this just once, but in the case of writing PNG8\n   * we reduce the transparency to binary and run again, then if there\n   * are still too many colors we reduce to a simple 4-4-4-1, then 3-3-3-1\n   * RGBA palette and run again, and then to a simple 3-3-2-1 RGBA\n   * palette.  Then (To do) we take care of a final reduction that is only\n   * needed if there are still 256 colors present and one of them has both\n   * transparent and opaque instances.\n   */\n\n  tried_332 = MagickFalse;\n  tried_333 = MagickFalse;\n  tried_444 = MagickFalse;\n\n  for (j=0; j<6; j++)\n  {\n    /*\n     * Sometimes we get DirectClass images that have 256 colors or fewer.\n     * This code will build a colormap.\n     *\n     * Also, sometimes we get PseudoClass images with an out-of-date\n     * colormap.  This code will replace the colormap with a new one.\n     * Sometimes we get PseudoClass images that have more than 256 colors.\n     * This code will delete the colormap and change the image to\n     * DirectClass.\n     *\n     * If image->alpha_trait is MagickFalse, we ignore the alpha channel\n     * even though it sometimes contains left-over non-opaque values.\n     *\n     * Also we gather some information (number of opaque, transparent,\n     * and semitransparent pixels, and whether the image has any non-gray\n     * pixels or only black-and-white pixels) that we might need later.\n     *\n     * Even if the user wants to force GrayAlpha or RGBA (colortype 4 or 6)\n     * we need to check for bogus non-opaque values, at least.\n     */\n\n   int\n     n;\n\n   PixelInfo\n     opaque[260],\n     semitransparent[260],\n     transparent[260];\n\n   register const Quantum\n     *s;\n\n   register Quantum\n     *q,\n     *r;\n\n   if (logging != MagickFalse)\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n         \"    Enter BUILD_PALETTE:\");\n\n   if (logging != MagickFalse)\n     {\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      image->columns=%.20g\",(double) image->columns);\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      image->rows=%.20g\",(double) image->rows);\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      image->alpha_trait=%.20g\",(double) image->alpha_trait);\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      image->depth=%.20g\",(double) image->depth);\n\n       if (image->storage_class == PseudoClass && image->colormap != NULL)\n       {\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      Original colormap:\");\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"        i    (red,green,blue,alpha)\");\n\n         for (i=0; i < 256; i++)\n         {\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"        %d    (%d,%d,%d,%d)\",\n                    (int) i,\n                    (int) image->colormap[i].red,\n                    (int) image->colormap[i].green,\n                    (int) image->colormap[i].blue,\n                    (int) image->colormap[i].alpha);\n         }\n\n         for (i=image->colors - 10; i < (ssize_t) image->colors; i++)\n         {\n           if (i > 255)\n             {\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"        %d    (%d,%d,%d,%d)\",\n                    (int) i,\n                    (int) image->colormap[i].red,\n                    (int) image->colormap[i].green,\n                    (int) image->colormap[i].blue,\n                    (int) image->colormap[i].alpha);\n             }\n         }\n       }\n\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"      image->colors=%d\",(int) image->colors);\n\n       if (image->colors == 0)\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"        (zero means unknown)\");\n\n       if (ping_preserve_colormap == MagickFalse)\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"      Regenerate the colormap\");\n     }\n\n     image_colors=0;\n     number_opaque = 0;\n     number_semitransparent = 0;\n     number_transparent = 0;\n\n     for (y=0; y < (ssize_t) image->rows; y++)\n     {\n       q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n       if (q == (Quantum *) NULL)\n         break;\n\n       for (x=0; x < (ssize_t) image->columns; x++)\n       {\n           if (image->alpha_trait == UndefinedPixelTrait ||\n              GetPixelAlpha(image,q) == OpaqueAlpha)\n             {\n               if (number_opaque < 259)\n                 {\n                   if (number_opaque == 0)\n                     {\n                       GetPixelInfoPixel(image, q, opaque);\n                       opaque[0].alpha=OpaqueAlpha;\n                       number_opaque=1;\n                     }\n\n                   for (i=0; i< (ssize_t) number_opaque; i++)\n                     {\n                       if (Magick_png_color_equal(image,q,opaque+i))\n                         break;\n                     }\n\n                   if (i ==  (ssize_t) number_opaque && number_opaque < 259)\n                     {\n                       number_opaque++;\n                       GetPixelInfoPixel(image, q, opaque+i);\n                       opaque[i].alpha=OpaqueAlpha;\n                     }\n                 }\n             }\n           else if (GetPixelAlpha(image,q) == TransparentAlpha)\n             {\n               if (number_transparent < 259)\n                 {\n                   if (number_transparent == 0)\n                     {\n                       GetPixelInfoPixel(image, q, transparent);\n                       ping_trans_color.red=(unsigned short)\n                         GetPixelRed(image,q);\n                       ping_trans_color.green=(unsigned short)\n                         GetPixelGreen(image,q);\n                       ping_trans_color.blue=(unsigned short)\n                         GetPixelBlue(image,q);\n                       ping_trans_color.gray=(unsigned short)\n                         GetPixelGray(image,q);\n                       number_transparent = 1;\n                     }\n\n                   for (i=0; i< (ssize_t) number_transparent; i++)\n                     {\n                       if (Magick_png_color_equal(image,q,transparent+i))\n                         break;\n                     }\n\n                   if (i ==  (ssize_t) number_transparent &&\n                       number_transparent < 259)\n                     {\n                       number_transparent++;\n                       GetPixelInfoPixel(image,q,transparent+i);\n                     }\n                 }\n             }\n           else\n             {\n               if (number_semitransparent < 259)\n                 {\n                   if (number_semitransparent == 0)\n                     {\n                       GetPixelInfoPixel(image,q,semitransparent);\n                       number_semitransparent = 1;\n                     }\n\n                   for (i=0; i< (ssize_t) number_semitransparent; i++)\n                     {\n                       if (Magick_png_color_equal(image,q,semitransparent+i)\n                           && GetPixelAlpha(image,q) ==\n                           semitransparent[i].alpha)\n                         break;\n                     }\n\n                   if (i ==  (ssize_t) number_semitransparent &&\n                       number_semitransparent < 259)\n                     {\n                       number_semitransparent++;\n                       GetPixelInfoPixel(image, q, semitransparent+i);\n                     }\n                 }\n             }\n           q+=GetPixelChannels(image);\n        }\n     }\n\n     if (mng_info->write_png8 == MagickFalse &&\n         ping_exclude_bKGD == MagickFalse)\n       {\n         /* Add the background color to the palette, if it\n          * isn't already there.\n          */\n          if (logging != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      Check colormap for background (%d,%d,%d)\",\n                  (int) image->background_color.red,\n                  (int) image->background_color.green,\n                  (int) image->background_color.blue);\n            }\n          for (i=0; i<number_opaque; i++)\n          {\n             if (opaque[i].red == image->background_color.red &&\n                 opaque[i].green == image->background_color.green &&\n                 opaque[i].blue == image->background_color.blue)\n               break;\n          }\n          if (number_opaque < 259 && i == number_opaque)\n            {\n               opaque[i] = image->background_color;\n               ping_background.index = i;\n               number_opaque++;\n               if (logging != MagickFalse)\n                 {\n                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                       \"      background_color index is %d\",(int) i);\n                 }\n\n            }\n          else if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      No room in the colormap to add background color\");\n       }\n\n     image_colors=number_opaque+number_transparent+number_semitransparent;\n\n     if (logging != MagickFalse)\n       {\n         if (image_colors > 256)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      image has more than 256 colors\");\n\n         else\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      image has %d colors\",image_colors);\n       }\n\n     if (ping_preserve_colormap != MagickFalse)\n       break;\n\n     if (mng_info->write_png_colortype != 7) /* We won't need this info */\n       {\n         ping_have_color=MagickFalse;\n         ping_have_non_bw=MagickFalse;\n\n         if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n         {\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"incompatible colorspace\");\n           ping_have_color=MagickTrue;\n           ping_have_non_bw=MagickTrue;\n         }\n\n         if(image_colors > 256)\n           {\n             for (y=0; y < (ssize_t) image->rows; y++)\n             {\n               q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n               if (q == (Quantum *) NULL)\n                 break;\n\n               s=q;\n               for (x=0; x < (ssize_t) image->columns; x++)\n               {\n                 if (GetPixelRed(image,s) != GetPixelGreen(image,s) ||\n                     GetPixelRed(image,s) != GetPixelBlue(image,s))\n                   {\n                      ping_have_color=MagickTrue;\n                      ping_have_non_bw=MagickTrue;\n                      break;\n                   }\n                 s+=GetPixelChannels(image);\n               }\n\n               if (ping_have_color != MagickFalse)\n                 break;\n\n               /* Worst case is black-and-white; we are looking at every\n                * pixel twice.\n                */\n\n               if (ping_have_non_bw == MagickFalse)\n                 {\n                   s=q;\n                   for (x=0; x < (ssize_t) image->columns; x++)\n                   {\n                     if (GetPixelRed(image,s) != 0 &&\n                         GetPixelRed(image,s) != QuantumRange)\n                       {\n                         ping_have_non_bw=MagickTrue;\n                         break;\n                       }\n                     s+=GetPixelChannels(image);\n                   }\n               }\n             }\n           }\n       }\n\n     if (image_colors < 257)\n       {\n         PixelInfo\n           colormap[260];\n\n         /*\n          * Initialize image colormap.\n          */\n\n         if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      Sort the new colormap\");\n\n        /* Sort palette, transparent first */;\n\n         n = 0;\n\n         for (i=0; i<number_transparent; i++)\n            colormap[n++] = transparent[i];\n\n         for (i=0; i<number_semitransparent; i++)\n            colormap[n++] = semitransparent[i];\n\n         for (i=0; i<number_opaque; i++)\n            colormap[n++] = opaque[i];\n\n         ping_background.index +=\n           (number_transparent + number_semitransparent);\n\n         /* image_colors < 257; search the colormap instead of the pixels\n          * to get ping_have_color and ping_have_non_bw\n          */\n         for (i=0; i<n; i++)\n         {\n           if (ping_have_color == MagickFalse)\n             {\n                if (colormap[i].red != colormap[i].green ||\n                    colormap[i].red != colormap[i].blue)\n                  {\n                     ping_have_color=MagickTrue;\n                     ping_have_non_bw=MagickTrue;\n                     break;\n                  }\n              }\n\n           if (ping_have_non_bw == MagickFalse)\n             {\n               if (colormap[i].red != 0 && colormap[i].red != QuantumRange)\n                   ping_have_non_bw=MagickTrue;\n             }\n          }\n\n        if ((mng_info->ping_exclude_tRNS == MagickFalse ||\n            (number_transparent == 0 && number_semitransparent == 0)) &&\n            (((mng_info->write_png_colortype-1) ==\n            PNG_COLOR_TYPE_PALETTE) ||\n            (mng_info->write_png_colortype == 0)))\n          {\n            if (logging != MagickFalse)\n              {\n                if (n !=  (ssize_t) image_colors)\n                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"   image_colors (%d) and n (%d)  don't match\",\n                   image_colors, n);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      AcquireImageColormap\");\n              }\n\n            image->colors = image_colors;\n\n            if (AcquireImageColormap(image,image_colors,exception) ==\n                MagickFalse)\n               ThrowWriterException(ResourceLimitError,\n                   \"MemoryAllocationFailed\");\n\n            for (i=0; i< (ssize_t) image_colors; i++)\n               image->colormap[i] = colormap[i];\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"      image->colors=%d (%d)\",\n                      (int) image->colors, image_colors);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"      Update the pixel indexes\");\n              }\n\n            /* Sync the pixel indices with the new colormap */\n\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n              if (q == (Quantum *) NULL)\n                break;\n\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                for (i=0; i< (ssize_t) image_colors; i++)\n                {\n                  if ((image->alpha_trait == UndefinedPixelTrait ||\n                      image->colormap[i].alpha == GetPixelAlpha(image,q)) &&\n                      image->colormap[i].red == GetPixelRed(image,q) &&\n                      image->colormap[i].green == GetPixelGreen(image,q) &&\n                      image->colormap[i].blue == GetPixelBlue(image,q))\n                  {\n                    SetPixelIndex(image,i,q);\n                    break;\n                  }\n                }\n                q+=GetPixelChannels(image);\n              }\n\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                 break;\n            }\n          }\n       }\n\n     if (logging != MagickFalse)\n       {\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"      image->colors=%d\", (int) image->colors);\n\n         if (image->colormap != NULL)\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"       i     (red,green,blue,alpha)\");\n\n             for (i=0; i < (ssize_t) image->colors; i++)\n             {\n               if (i < 300 || i >= (ssize_t) image->colors - 10)\n                 {\n                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                       \"       %d     (%d,%d,%d,%d)\",\n                        (int) i,\n                        (int) image->colormap[i].red,\n                        (int) image->colormap[i].green,\n                        (int) image->colormap[i].blue,\n                        (int) image->colormap[i].alpha);\n                 }\n             }\n           }\n\n           if (number_transparent < 257)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_transparent     = %d\",\n                   number_transparent);\n           else\n\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_transparent     > 256\");\n\n           if (number_opaque < 257)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_opaque          = %d\",\n                   number_opaque);\n\n           else\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_opaque          > 256\");\n\n           if (number_semitransparent < 257)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_semitransparent = %d\",\n                   number_semitransparent);\n\n           else\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_semitransparent > 256\");\n\n           if (ping_have_non_bw == MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      All pixels and the background are black or white\");\n\n           else if (ping_have_color == MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      All pixels and the background are gray\");\n\n           else\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      At least one pixel or the background is non-gray\");\n\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"    Exit BUILD_PALETTE:\");\n       }\n\n   if (mng_info->write_png8 == MagickFalse)\n      break;\n\n   /* Make any reductions necessary for the PNG8 format */\n    if (image_colors <= 256 &&\n        image_colors != 0 && image->colormap != NULL &&\n        number_semitransparent == 0 &&\n        number_transparent <= 1)\n      break;\n\n    /* PNG8 can't have semitransparent colors so we threshold the\n     * opacity to 0 or OpaqueOpacity, and PNG8 can only have one\n     * transparent color so if more than one is transparent we merge\n     * them into image->background_color.\n     */\n    if (number_semitransparent != 0 || number_transparent > 1)\n      {\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Thresholding the alpha channel to binary\");\n\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n          if (r == (Quantum *) NULL)\n            break;\n\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n              if (GetPixelAlpha(image,r) < OpaqueAlpha/2)\n                {\n                  SetPixelViaPixelInfo(image,&image->background_color,r);\n                  SetPixelAlpha(image,TransparentAlpha,r);\n                }\n              else\n                  SetPixelAlpha(image,OpaqueAlpha,r);\n              r+=GetPixelChannels(image);\n          }\n\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n             break;\n\n          if (image_colors != 0 && image_colors <= 256 &&\n             image->colormap != NULL)\n            for (i=0; i<image_colors; i++)\n                image->colormap[i].alpha =\n                    (image->colormap[i].alpha > TransparentAlpha/2 ?\n                    TransparentAlpha : OpaqueAlpha);\n        }\n      continue;\n    }\n\n    /* PNG8 can't have more than 256 colors so we quantize the pixels and\n     * background color to the 4-4-4-1, 3-3-3-1 or 3-3-2-1 palette.  If the\n     * image is mostly gray, the 4-4-4-1 palette is likely to end up with 256\n     * colors or less.\n     */\n    if (tried_444 == MagickFalse && (image_colors == 0 || image_colors > 256))\n      {\n        if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"    Quantizing the background color to 4-4-4\");\n\n        tried_444 = MagickTrue;\n\n        LBR04PacketRGB(image->background_color);\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the pixel colors to 4-4-4\");\n\n        if (image->colormap == NULL)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n            if (r == (Quantum *) NULL)\n              break;\n\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (GetPixelAlpha(image,r) == OpaqueAlpha)\n                  LBR04PixelRGB(r);\n              r+=GetPixelChannels(image);\n            }\n\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n          }\n        }\n\n        else /* Should not reach this; colormap already exists and\n                must be <= 256 */\n        {\n          if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the colormap to 4-4-4\");\n\n          for (i=0; i<image_colors; i++)\n          {\n            LBR04PacketRGB(image->colormap[i]);\n          }\n        }\n        continue;\n      }\n\n    if (tried_333 == MagickFalse && (image_colors == 0 || image_colors > 256))\n      {\n        if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"    Quantizing the background color to 3-3-3\");\n\n        tried_333 = MagickTrue;\n\n        LBR03PacketRGB(image->background_color);\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the pixel colors to 3-3-3-1\");\n\n        if (image->colormap == NULL)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n            if (r == (Quantum *) NULL)\n              break;\n\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (GetPixelAlpha(image,r) == OpaqueAlpha)\n                  LBR03RGB(r);\n              r+=GetPixelChannels(image);\n            }\n\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n          }\n        }\n\n        else /* Should not reach this; colormap already exists and\n                must be <= 256 */\n        {\n          if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the colormap to 3-3-3-1\");\n          for (i=0; i<image_colors; i++)\n          {\n              LBR03PacketRGB(image->colormap[i]);\n          }\n        }\n        continue;\n      }\n\n    if (tried_332 == MagickFalse && (image_colors == 0 || image_colors > 256))\n      {\n        if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"    Quantizing the background color to 3-3-2\");\n\n        tried_332 = MagickTrue;\n\n        /* Red and green were already done so we only quantize the blue\n         * channel\n         */\n\n        LBR02PacketBlue(image->background_color);\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the pixel colors to 3-3-2-1\");\n\n        if (image->colormap == NULL)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n            if (r == (Quantum *) NULL)\n              break;\n\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (GetPixelAlpha(image,r) == OpaqueAlpha)\n                  LBR02PixelBlue(r);\n              r+=GetPixelChannels(image);\n            }\n\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n          }\n        }\n\n        else /* Should not reach this; colormap already exists and\n                must be <= 256 */\n        {\n          if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the colormap to 3-3-2-1\");\n          for (i=0; i<image_colors; i++)\n          {\n              LBR02PacketBlue(image->colormap[i]);\n          }\n      }\n      continue;\n    }\n\n    if (image_colors == 0 || image_colors > 256)\n    {\n      /* Take care of special case with 256 opaque colors + 1 transparent\n       * color.  We don't need to quantize to 2-3-2-1; we only need to\n       * eliminate one color, so we'll merge the two darkest red\n       * colors (0x49, 0, 0) -> (0x24, 0, 0).\n       */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Merging two dark red background colors to 3-3-2-1\");\n\n      if (ScaleQuantumToChar(image->background_color.red) == 0x49 &&\n          ScaleQuantumToChar(image->background_color.green) == 0x00 &&\n          ScaleQuantumToChar(image->background_color.blue) == 0x00)\n      {\n         image->background_color.red=ScaleCharToQuantum(0x24);\n      }\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Merging two dark red pixel colors to 3-3-2-1\");\n\n      if (image->colormap == NULL)\n      {\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n          if (r == (Quantum *) NULL)\n            break;\n\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if (ScaleQuantumToChar(GetPixelRed(image,r)) == 0x49 &&\n                ScaleQuantumToChar(GetPixelGreen(image,r)) == 0x00 &&\n                ScaleQuantumToChar(GetPixelBlue(image,r)) == 0x00 &&\n                GetPixelAlpha(image,r) == OpaqueAlpha)\n              {\n                SetPixelRed(image,ScaleCharToQuantum(0x24),r);\n              }\n            r+=GetPixelChannels(image);\n          }\n\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n             break;\n\n        }\n      }\n\n      else\n      {\n         for (i=0; i<image_colors; i++)\n         {\n            if (ScaleQuantumToChar(image->colormap[i].red) == 0x49 &&\n                ScaleQuantumToChar(image->colormap[i].green) == 0x00 &&\n                ScaleQuantumToChar(image->colormap[i].blue) == 0x00)\n            {\n               image->colormap[i].red=ScaleCharToQuantum(0x24);\n            }\n         }\n      }\n    }\n  }\n  }\n  /* END OF BUILD_PALETTE */\n\n  /* If we are excluding the tRNS chunk and there is transparency,\n   * then we must write a Gray-Alpha (color-type 4) or RGBA (color-type 6)\n   * PNG.\n   */\n  if (mng_info->ping_exclude_tRNS != MagickFalse &&\n     (number_transparent != 0 || number_semitransparent != 0))\n    {\n      unsigned int colortype=mng_info->write_png_colortype;\n\n      if (ping_have_color == MagickFalse)\n        mng_info->write_png_colortype = 5;\n\n      else\n        mng_info->write_png_colortype = 7;\n\n      if (colortype != 0 &&\n         mng_info->write_png_colortype != colortype)\n        ping_need_colortype_warning=MagickTrue;\n\n    }\n\n  /* See if cheap transparency is possible.  It is only possible\n   * when there is a single transparent color, no semitransparent\n   * color, and no opaque color that has the same RGB components\n   * as the transparent color.  We only need this information if\n   * we are writing a PNG with colortype 0 or 2, and we have not\n   * excluded the tRNS chunk.\n   */\n  if (number_transparent == 1 &&\n      mng_info->write_png_colortype < 4)\n    {\n       ping_have_cheap_transparency = MagickTrue;\n\n       if (number_semitransparent != 0)\n         ping_have_cheap_transparency = MagickFalse;\n\n       else if (image_colors == 0 || image_colors > 256 ||\n           image->colormap == NULL)\n         {\n           register const Quantum\n             *q;\n\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             q=GetVirtualPixels(image,0,y,image->columns,1, exception);\n\n             if (q == (Quantum *) NULL)\n               break;\n\n             for (x=0; x < (ssize_t) image->columns; x++)\n             {\n                 if (GetPixelAlpha(image,q) != TransparentAlpha &&\n                     (unsigned short) GetPixelRed(image,q) ==\n                                     ping_trans_color.red &&\n                     (unsigned short) GetPixelGreen(image,q) ==\n                                     ping_trans_color.green &&\n                     (unsigned short) GetPixelBlue(image,q) ==\n                                     ping_trans_color.blue)\n                   {\n                     ping_have_cheap_transparency = MagickFalse;\n                     break;\n                   }\n\n                 q+=GetPixelChannels(image);\n             }\n\n             if (ping_have_cheap_transparency == MagickFalse)\n                break;\n           }\n         }\n       else\n         {\n            /* Assuming that image->colormap[0] is the one transparent color\n             * and that all others are opaque.\n             */\n            if (image_colors > 1)\n              for (i=1; i<image_colors; i++)\n                if (image->colormap[i].red == image->colormap[0].red &&\n                    image->colormap[i].green == image->colormap[0].green &&\n                    image->colormap[i].blue == image->colormap[0].blue)\n                  {\n                     ping_have_cheap_transparency = MagickFalse;\n                     break;\n                  }\n         }\n\n       if (logging != MagickFalse)\n         {\n           if (ping_have_cheap_transparency == MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"   Cheap transparency is not possible.\");\n\n           else\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"   Cheap transparency is possible.\");\n         }\n     }\n  else\n    ping_have_cheap_transparency = MagickFalse;\n\n  image_depth=image->depth;\n\n  quantum_info = (QuantumInfo *) NULL;\n  number_colors=0;\n  image_colors=(int) image->colors;\n  image_matte=image->alpha_trait !=\n        UndefinedPixelTrait ? MagickTrue : MagickFalse;\n\n  if (mng_info->write_png_colortype < 5)\n    mng_info->IsPalette=image->storage_class == PseudoClass &&\n      image_colors <= 256 && image->colormap != NULL;\n  else\n    mng_info->IsPalette = MagickFalse;\n\n  if ((mng_info->write_png_colortype == 4 || mng_info->write_png8) &&\n     (image->colors == 0 || image->colormap == NULL))\n    {\n      image_info=DestroyImageInfo(image_info);\n      image=DestroyImage(image);\n      (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n          \"Cannot write PNG8 or color-type 3; colormap is NULL\",\n          \"`%s'\",IMimage->filename);\n      return(MagickFalse);\n    }\n\n  /*\n    Allocate the PNG structures\n  */\n#ifdef PNG_USER_MEM_SUPPORTED\n error_info.image=image;\n error_info.exception=exception;\n  ping=png_create_write_struct_2(PNG_LIBPNG_VER_STRING,&error_info,\n    MagickPNGErrorHandler,MagickPNGWarningHandler,(void *) NULL,\n    (png_malloc_ptr) Magick_png_malloc,(png_free_ptr) Magick_png_free);\n\n#else\n  ping=png_create_write_struct(PNG_LIBPNG_VER_STRING,&error_info,\n    MagickPNGErrorHandler,MagickPNGWarningHandler);\n\n#endif\n  if (ping == (png_struct *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  ping_info=png_create_info_struct(ping);\n\n  if (ping_info == (png_info *) NULL)\n    {\n      png_destroy_write_struct(&ping,(png_info **) NULL);\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n\n  png_set_write_fn(ping,image,png_put_data,png_flush_data);\n  pixel_info=(MemoryInfo *) NULL;\n\n  if (setjmp(png_jmpbuf(ping)))\n    {\n      /*\n        PNG write failed.\n      */\n#ifdef PNG_DEBUG\n     if (image_info->verbose)\n        (void) printf(\"PNG write has failed.\\n\");\n#endif\n      png_destroy_write_struct(&ping,&ping_info);\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n      UnlockSemaphoreInfo(ping_semaphore);\n#endif\n\n      if (pixel_info != (MemoryInfo *) NULL)\n        pixel_info=RelinquishVirtualMemory(pixel_info);\n\n      if (quantum_info != (QuantumInfo *) NULL)\n        quantum_info=DestroyQuantumInfo(quantum_info);\n\n      if (ping_have_blob != MagickFalse)\n          (void) CloseBlob(image);\n      image_info=DestroyImageInfo(image_info);\n      image=DestroyImage(image);\n      return(MagickFalse);\n    }\n\n  /* {  For navigation to end of SETJMP-protected block.  Within this\n   *    block, use png_error() instead of Throwing an Exception, to ensure\n   *    that libpng is able to clean up, and that the semaphore is unlocked.\n   */\n\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n  LockSemaphoreInfo(ping_semaphore);\n#endif\n\n#ifdef PNG_BENIGN_ERRORS_SUPPORTED\n  /* Allow benign errors */\n  png_set_benign_errors(ping, 1);\n#endif\n\n#ifdef PNG_SET_USER_LIMITS_SUPPORTED\n  /* Reject images with too many rows or columns */\n  png_set_user_limits(ping,\n    (png_uint_32) MagickMin(0x7fffffffL,\n        GetMagickResourceLimit(WidthResource)),\n    (png_uint_32) MagickMin(0x7fffffffL,\n        GetMagickResourceLimit(HeightResource)));\n#endif /* PNG_SET_USER_LIMITS_SUPPORTED */\n\n  /*\n    Prepare PNG for writing.\n  */\n\n#if defined(PNG_MNG_FEATURES_SUPPORTED)\n  if (mng_info->write_mng)\n  {\n     (void) png_permit_mng_features(ping,PNG_ALL_MNG_FEATURES);\n# ifdef PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED\n     /* Disable new libpng-1.5.10 feature when writing a MNG because\n      * zero-length PLTE is OK\n      */\n     png_set_check_for_invalid_index (ping, 0);\n# endif\n  }\n\n#else\n# ifdef PNG_WRITE_EMPTY_PLTE_SUPPORTED\n  if (mng_info->write_mng)\n     png_permit_empty_plte(ping,MagickTrue);\n\n# endif\n#endif\n\n  x=0;\n\n  ping_width=(png_uint_32) image->columns;\n  ping_height=(png_uint_32) image->rows;\n\n  if (mng_info->write_png8 || mng_info->write_png24 || mng_info->write_png32)\n     image_depth=8;\n\n  if (mng_info->write_png48 || mng_info->write_png64)\n     image_depth=16;\n\n  if (mng_info->write_png_depth != 0)\n     image_depth=mng_info->write_png_depth;\n\n  /* Adjust requested depth to next higher valid depth if necessary */\n  if (image_depth > 8)\n     image_depth=16;\n\n  if ((image_depth > 4) && (image_depth < 8))\n     image_depth=8;\n\n  if (image_depth == 3)\n     image_depth=4;\n\n  if (logging != MagickFalse)\n    {\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    width=%.20g\",(double) ping_width);\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    height=%.20g\",(double) ping_height);\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    image_matte=%.20g\",(double) image->alpha_trait);\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    image->depth=%.20g\",(double) image->depth);\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Tentative ping_bit_depth=%.20g\",(double) image_depth);\n    }\n\n  save_image_depth=image_depth;\n  ping_bit_depth=(png_byte) save_image_depth;\n\n\n#if defined(PNG_pHYs_SUPPORTED)\n  if (ping_exclude_pHYs == MagickFalse)\n  {\n  if ((image->resolution.x != 0) && (image->resolution.y != 0) &&\n      (!mng_info->write_mng || !mng_info->equal_physs))\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Setting up pHYs chunk\");\n\n      if (image->units == PixelsPerInchResolution)\n        {\n          ping_pHYs_unit_type=PNG_RESOLUTION_METER;\n          ping_pHYs_x_resolution=\n             (png_uint_32) ((100.0*image->resolution.x+0.5)/2.54);\n          ping_pHYs_y_resolution=\n             (png_uint_32) ((100.0*image->resolution.y+0.5)/2.54);\n        }\n\n      else if (image->units == PixelsPerCentimeterResolution)\n        {\n          ping_pHYs_unit_type=PNG_RESOLUTION_METER;\n          ping_pHYs_x_resolution=(png_uint_32) (100.0*image->resolution.x+0.5);\n          ping_pHYs_y_resolution=(png_uint_32) (100.0*image->resolution.y+0.5);\n        }\n\n      else\n        {\n          ping_pHYs_unit_type=PNG_RESOLUTION_UNKNOWN;\n          ping_pHYs_x_resolution=(png_uint_32) image->resolution.x;\n          ping_pHYs_y_resolution=(png_uint_32) image->resolution.y;\n        }\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Set up PNG pHYs chunk: xres: %.20g, yres: %.20g, units: %d.\",\n          (double) ping_pHYs_x_resolution,(double) ping_pHYs_y_resolution,\n          (int) ping_pHYs_unit_type);\n       ping_have_pHYs = MagickTrue;\n    }\n  }\n#endif\n\n  if (ping_exclude_bKGD == MagickFalse)\n  {\n  if ((!mng_info->adjoin || !mng_info->equal_backgrounds))\n    {\n       unsigned int\n         mask;\n\n       mask=0xffff;\n       if (ping_bit_depth == 8)\n          mask=0x00ff;\n\n       if (ping_bit_depth == 4)\n          mask=0x000f;\n\n       if (ping_bit_depth == 2)\n          mask=0x0003;\n\n       if (ping_bit_depth == 1)\n          mask=0x0001;\n\n       ping_background.red=(png_uint_16)\n         (ScaleQuantumToShort(image->background_color.red) & mask);\n\n       ping_background.green=(png_uint_16)\n         (ScaleQuantumToShort(image->background_color.green) & mask);\n\n       ping_background.blue=(png_uint_16)\n         (ScaleQuantumToShort(image->background_color.blue) & mask);\n\n       ping_background.gray=(png_uint_16) ping_background.green;\n    }\n\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Setting up bKGD chunk (1)\");\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"      background_color index is %d\",\n          (int) ping_background.index);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    ping_bit_depth=%d\",ping_bit_depth);\n    }\n\n  ping_have_bKGD = MagickTrue;\n  }\n\n  /*\n    Select the color type.\n  */\n  matte=image_matte;\n  old_bit_depth=0;\n\n  if (mng_info->IsPalette && mng_info->write_png8)\n    {\n      /* To do: make this a function cause it's used twice, except\n         for reducing the sample depth from 8. */\n\n      number_colors=image_colors;\n\n      ping_have_tRNS=MagickFalse;\n\n      /*\n        Set image palette.\n      */\n      ping_color_type=(png_byte) PNG_COLOR_TYPE_PALETTE;\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Setting up PLTE chunk with %d colors (%d)\",\n            number_colors, image_colors);\n\n      for (i=0; i < (ssize_t) number_colors; i++)\n      {\n        palette[i].red=ScaleQuantumToChar(image->colormap[i].red);\n        palette[i].green=ScaleQuantumToChar(image->colormap[i].green);\n        palette[i].blue=ScaleQuantumToChar(image->colormap[i].blue);\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n#if MAGICKCORE_QUANTUM_DEPTH == 8\n            \"    %3ld (%3d,%3d,%3d)\",\n#else\n            \"    %5ld (%5d,%5d,%5d)\",\n#endif\n            (long) i,palette[i].red,palette[i].green,palette[i].blue);\n\n      }\n\n      ping_have_PLTE=MagickTrue;\n      image_depth=ping_bit_depth;\n      ping_num_trans=0;\n\n      if (matte != MagickFalse)\n      {\n          /*\n            Identify which colormap entry is transparent.\n          */\n          assert(number_colors <= 256);\n          assert(image->colormap != NULL);\n\n          for (i=0; i < (ssize_t) number_transparent; i++)\n             ping_trans_alpha[i]=0;\n\n\n          ping_num_trans=(unsigned short) (number_transparent +\n             number_semitransparent);\n\n          if (ping_num_trans == 0)\n             ping_have_tRNS=MagickFalse;\n\n          else\n             ping_have_tRNS=MagickTrue;\n      }\n\n      if (ping_exclude_bKGD == MagickFalse)\n      {\n       /*\n        * Identify which colormap entry is the background color.\n        */\n\n        for (i=0; i < (ssize_t) MagickMax(1L*number_colors-1L,1L); i++)\n          if (IsPNGColorEqual(ping_background,image->colormap[i]))\n            break;\n\n        ping_background.index=(png_byte) i;\n\n        if (logging != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"      background_color index is %d\",\n                 (int) ping_background.index);\n          }\n      }\n    } /* end of write_png8 */\n\n  else if (mng_info->write_png_colortype == 1)\n    {\n      image_matte=MagickFalse;\n      ping_color_type=(png_byte) PNG_COLOR_TYPE_GRAY;\n    }\n\n  else if (mng_info->write_png24 || mng_info->write_png48 ||\n      mng_info->write_png_colortype == 3)\n    {\n      image_matte=MagickFalse;\n      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB;\n    }\n\n  else if (mng_info->write_png32 || mng_info->write_png64 ||\n      mng_info->write_png_colortype == 7)\n    {\n      image_matte=MagickTrue;\n      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB_ALPHA;\n    }\n\n  else /* mng_info->write_pngNN not specified */\n    {\n      image_depth=ping_bit_depth;\n\n      if (mng_info->write_png_colortype != 0)\n        {\n          ping_color_type=(png_byte) mng_info->write_png_colortype-1;\n\n          if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||\n              ping_color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n            image_matte=MagickTrue;\n\n          else\n            image_matte=MagickFalse;\n\n          if (logging != MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"   PNG colortype %d was specified:\",(int) ping_color_type);\n        }\n\n      else /* write_png_colortype not specified */\n        {\n          if (logging != MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  Selecting PNG colortype:\");\n\n          ping_color_type=(png_byte) ((matte != MagickFalse)?\n            PNG_COLOR_TYPE_RGB_ALPHA:PNG_COLOR_TYPE_RGB);\n\n          if (image_info->type == TrueColorType)\n            {\n              ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB;\n              image_matte=MagickFalse;\n            }\n\n          if (image_info->type == TrueColorAlphaType)\n            {\n              ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB_ALPHA;\n              image_matte=MagickTrue;\n            }\n\n          if (image_info->type == PaletteType ||\n              image_info->type == PaletteAlphaType)\n            ping_color_type=(png_byte) PNG_COLOR_TYPE_PALETTE;\n\n          if (mng_info->write_png_colortype == 0 &&\n             image_info->type == UndefinedType)\n            {\n              if (ping_have_color == MagickFalse)\n                {\n                  if (image_matte == MagickFalse)\n                    {\n                      ping_color_type=(png_byte) PNG_COLOR_TYPE_GRAY;\n                      image_matte=MagickFalse;\n                    }\n\n                  else\n                    {\n                      ping_color_type=(png_byte) PNG_COLOR_TYPE_GRAY_ALPHA;\n                      image_matte=MagickTrue;\n                    }\n                }\n              else\n                {\n                  if (image_matte == MagickFalse)\n                    {\n                      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB;\n                      image_matte=MagickFalse;\n                    }\n\n                  else\n                    {\n                      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGBA;\n                      image_matte=MagickTrue;\n                    }\n                 }\n            }\n\n        }\n\n      if (logging != MagickFalse)\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n         \"    Selected PNG colortype=%d\",ping_color_type);\n\n      if (ping_bit_depth < 8)\n        {\n          if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||\n              ping_color_type == PNG_COLOR_TYPE_RGB ||\n              ping_color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n            ping_bit_depth=8;\n        }\n\n      old_bit_depth=ping_bit_depth;\n\n      if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n        {\n          if (image->alpha_trait == UndefinedPixelTrait &&\n               ping_have_non_bw == MagickFalse)\n             ping_bit_depth=1;\n        }\n\n      if (ping_color_type == PNG_COLOR_TYPE_PALETTE)\n        {\n           size_t one = 1;\n           ping_bit_depth=1;\n\n           if (image->colors == 0)\n           {\n              /* DO SOMETHING */\n                png_error(ping,\"image has 0 colors\");\n           }\n\n           while ((int) (one << ping_bit_depth) < (ssize_t) image_colors)\n             ping_bit_depth <<= 1;\n        }\n\n      if (logging != MagickFalse)\n         {\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Number of colors: %.20g\",(double) image_colors);\n\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Tentative PNG bit depth: %d\",ping_bit_depth);\n         }\n\n      if (ping_bit_depth < (int) mng_info->write_png_depth)\n         ping_bit_depth = mng_info->write_png_depth;\n    }\n\n  image_depth=ping_bit_depth;\n\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Tentative PNG color type: %s (%.20g)\",\n        PngColorTypeToString(ping_color_type),\n        (double) ping_color_type);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    image_info->type: %.20g\",(double) image_info->type);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    image_depth: %.20g\",(double) image_depth);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\n        \"    image->depth: %.20g\",(double) image->depth);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    ping_bit_depth: %.20g\",(double) ping_bit_depth);\n    }\n\n  if (matte != MagickFalse)\n    {\n      if (mng_info->IsPalette)\n        {\n          if (mng_info->write_png_colortype == 0)\n            {\n              ping_color_type=PNG_COLOR_TYPE_GRAY_ALPHA;\n\n              if (ping_have_color != MagickFalse)\n                 ping_color_type=PNG_COLOR_TYPE_RGBA;\n            }\n\n          /*\n           * Determine if there is any transparent color.\n          */\n          if (number_transparent + number_semitransparent == 0)\n            {\n              /*\n                No transparent pixels are present.  Change 4 or 6 to 0 or 2.\n              */\n\n              image_matte=MagickFalse;\n\n              if (mng_info->write_png_colortype == 0)\n                ping_color_type&=0x03;\n            }\n\n          else\n            {\n              unsigned int\n                mask;\n\n              mask=0xffff;\n\n              if (ping_bit_depth == 8)\n                 mask=0x00ff;\n\n              if (ping_bit_depth == 4)\n                 mask=0x000f;\n\n              if (ping_bit_depth == 2)\n                 mask=0x0003;\n\n              if (ping_bit_depth == 1)\n                 mask=0x0001;\n\n              ping_trans_color.red=(png_uint_16)\n                (ScaleQuantumToShort(image->colormap[0].red) & mask);\n\n              ping_trans_color.green=(png_uint_16)\n                (ScaleQuantumToShort(image->colormap[0].green) & mask);\n\n              ping_trans_color.blue=(png_uint_16)\n                (ScaleQuantumToShort(image->colormap[0].blue) & mask);\n\n              ping_trans_color.gray=(png_uint_16)\n                (ScaleQuantumToShort(GetPixelInfoIntensity(image,\n                   image->colormap)) & mask);\n\n              ping_trans_color.index=(png_byte) 0;\n\n              ping_have_tRNS=MagickTrue;\n            }\n\n          if (ping_have_tRNS != MagickFalse)\n            {\n              /*\n               * Determine if there is one and only one transparent color\n               * and if so if it is fully transparent.\n               */\n              if (ping_have_cheap_transparency == MagickFalse)\n                ping_have_tRNS=MagickFalse;\n            }\n\n          if (ping_have_tRNS != MagickFalse)\n            {\n              if (mng_info->write_png_colortype == 0)\n                ping_color_type &= 0x03;  /* changes 4 or 6 to 0 or 2 */\n\n              if (image_depth == 8)\n                {\n                  ping_trans_color.red&=0xff;\n                  ping_trans_color.green&=0xff;\n                  ping_trans_color.blue&=0xff;\n                  ping_trans_color.gray&=0xff;\n                }\n            }\n        }\n      else\n        {\n          if (image_depth == 8)\n            {\n              ping_trans_color.red&=0xff;\n              ping_trans_color.green&=0xff;\n              ping_trans_color.blue&=0xff;\n              ping_trans_color.gray&=0xff;\n            }\n        }\n    }\n\n    matte=image_matte;\n\n    if (ping_have_tRNS != MagickFalse)\n      image_matte=MagickFalse;\n\n    if ((mng_info->IsPalette) &&\n        mng_info->write_png_colortype-1 != PNG_COLOR_TYPE_PALETTE &&\n        ping_have_color == MagickFalse &&\n        (image_matte == MagickFalse || image_depth >= 8))\n      {\n        size_t one=1;\n\n        if (image_matte != MagickFalse)\n          ping_color_type=PNG_COLOR_TYPE_GRAY_ALPHA;\n\n        else if (mng_info->write_png_colortype-1 != PNG_COLOR_TYPE_GRAY_ALPHA)\n          {\n            ping_color_type=PNG_COLOR_TYPE_GRAY;\n\n            if (save_image_depth == 16 && image_depth == 8)\n              {\n                if (logging != MagickFalse)\n                  {\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"  Scaling ping_trans_color (0)\");\n                  }\n                    ping_trans_color.gray*=0x0101;\n              }\n          }\n\n        if (image_depth > MAGICKCORE_QUANTUM_DEPTH)\n          image_depth=MAGICKCORE_QUANTUM_DEPTH;\n\n        if ((image_colors == 0) ||\n             ((ssize_t) (image_colors-1) > (ssize_t) MaxColormapSize))\n          image_colors=(int) (one << image_depth);\n\n        if (image_depth > 8)\n          ping_bit_depth=16;\n\n        else\n          {\n            ping_bit_depth=8;\n            if ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE)\n              {\n                if(!mng_info->write_png_depth)\n                  {\n                    ping_bit_depth=1;\n\n                    while ((int) (one << ping_bit_depth)\n                        < (ssize_t) image_colors)\n                      ping_bit_depth <<= 1;\n                  }\n              }\n\n            else if (ping_color_type ==\n                PNG_COLOR_TYPE_GRAY && image_colors < 17 &&\n                mng_info->IsPalette)\n              {\n              /* Check if grayscale is reducible */\n\n                int\n                  depth_4_ok=MagickTrue,\n                  depth_2_ok=MagickTrue,\n                  depth_1_ok=MagickTrue;\n\n                for (i=0; i < (ssize_t) image_colors; i++)\n                {\n                   unsigned char\n                     intensity;\n\n                   intensity=ScaleQuantumToChar(image->colormap[i].red);\n\n                   if ((intensity & 0x0f) != ((intensity & 0xf0) >> 4))\n                     depth_4_ok=depth_2_ok=depth_1_ok=MagickFalse;\n                   else if ((intensity & 0x03) != ((intensity & 0x0c) >> 2))\n                     depth_2_ok=depth_1_ok=MagickFalse;\n                   else if ((intensity & 0x01) != ((intensity & 0x02) >> 1))\n                     depth_1_ok=MagickFalse;\n                }\n\n                if (depth_1_ok && mng_info->write_png_depth <= 1)\n                  ping_bit_depth=1;\n\n                else if (depth_2_ok && mng_info->write_png_depth <= 2)\n                  ping_bit_depth=2;\n\n                else if (depth_4_ok && mng_info->write_png_depth <= 4)\n                  ping_bit_depth=4;\n              }\n          }\n\n          image_depth=ping_bit_depth;\n      }\n\n    else\n\n      if (mng_info->IsPalette)\n      {\n        number_colors=image_colors;\n\n        if (image_depth <= 8)\n          {\n            /*\n              Set image palette.\n            */\n            ping_color_type=(png_byte) PNG_COLOR_TYPE_PALETTE;\n\n            if (!(mng_info->have_write_global_plte && matte == MagickFalse))\n              {\n                for (i=0; i < (ssize_t) number_colors; i++)\n                {\n                  palette[i].red=ScaleQuantumToChar(image->colormap[i].red);\n                  palette[i].green=\n                    ScaleQuantumToChar(image->colormap[i].green);\n                  palette[i].blue=ScaleQuantumToChar(image->colormap[i].blue);\n                }\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Setting up PLTE chunk with %d colors\",\n                    number_colors);\n\n                ping_have_PLTE=MagickTrue;\n              }\n\n            /* color_type is PNG_COLOR_TYPE_PALETTE */\n            if (mng_info->write_png_depth == 0)\n              {\n                size_t\n                  one;\n\n                ping_bit_depth=1;\n                one=1;\n\n                while ((one << ping_bit_depth) < (size_t) number_colors)\n                  ping_bit_depth <<= 1;\n              }\n\n            ping_num_trans=0;\n\n            if (matte != MagickFalse)\n              {\n                /*\n                 * Set up trans_colors array.\n                 */\n                assert(number_colors <= 256);\n\n                ping_num_trans=(unsigned short) (number_transparent +\n                  number_semitransparent);\n\n                if (ping_num_trans == 0)\n                  ping_have_tRNS=MagickFalse;\n\n                else\n                  {\n                    if (logging != MagickFalse)\n                      {\n                        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  Scaling ping_trans_color (1)\");\n                      }\n                    ping_have_tRNS=MagickTrue;\n\n                    for (i=0; i < ping_num_trans; i++)\n                    {\n                       ping_trans_alpha[i]= (png_byte)\n                         ScaleQuantumToChar(image->colormap[i].alpha);\n                    }\n                  }\n              }\n          }\n      }\n\n    else\n      {\n\n        if (image_depth < 8)\n          image_depth=8;\n\n        if ((save_image_depth == 16) && (image_depth == 8))\n          {\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    Scaling ping_trans_color from (%d,%d,%d)\",\n                  (int) ping_trans_color.red,\n                  (int) ping_trans_color.green,\n                  (int) ping_trans_color.blue);\n              }\n\n            ping_trans_color.red*=0x0101;\n            ping_trans_color.green*=0x0101;\n            ping_trans_color.blue*=0x0101;\n            ping_trans_color.gray*=0x0101;\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    to (%d,%d,%d)\",\n                  (int) ping_trans_color.red,\n                  (int) ping_trans_color.green,\n                  (int) ping_trans_color.blue);\n              }\n          }\n      }\n\n    if (ping_bit_depth <  (ssize_t) mng_info->write_png_depth)\n         ping_bit_depth =  (ssize_t) mng_info->write_png_depth;\n\n    /*\n      Adjust background and transparency samples in sub-8-bit grayscale files.\n    */\n    if (ping_bit_depth < 8 && ping_color_type ==\n        PNG_COLOR_TYPE_GRAY)\n      {\n         png_uint_16\n           maxval;\n\n         size_t\n           one=1;\n\n         maxval=(png_uint_16) ((one << ping_bit_depth)-1);\n\n         if (ping_exclude_bKGD == MagickFalse)\n         {\n\n         ping_background.gray=(png_uint_16) ((maxval/65535.)*\n           (ScaleQuantumToShort(((GetPixelInfoIntensity(image,\n           &image->background_color))) +.5)));\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  Setting up bKGD chunk (2)\");\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      background_color index is %d\",\n             (int) ping_background.index);\n\n         ping_have_bKGD = MagickTrue;\n         }\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  Scaling ping_trans_color.gray from %d\",\n             (int)ping_trans_color.gray);\n\n         ping_trans_color.gray=(png_uint_16) ((maxval/255.)*(\n           ping_trans_color.gray)+.5);\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      to %d\", (int)ping_trans_color.gray);\n      }\n\n  if (ping_exclude_bKGD == MagickFalse)\n  {\n    if (mng_info->IsPalette && (int) ping_color_type == PNG_COLOR_TYPE_PALETTE)\n      {\n        /*\n           Identify which colormap entry is the background color.\n        */\n\n        number_colors=image_colors;\n\n        for (i=0; i < (ssize_t) MagickMax(1L*number_colors,1L); i++)\n          if (IsPNGColorEqual(image->background_color,image->colormap[i]))\n            break;\n\n        ping_background.index=(png_byte) i;\n\n        if (logging != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Setting up bKGD chunk with index=%d\",(int) i);\n          }\n\n        if (i < (ssize_t) number_colors)\n          {\n            ping_have_bKGD = MagickTrue;\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"     background   =(%d,%d,%d)\",\n                        (int) ping_background.red,\n                        (int) ping_background.green,\n                        (int) ping_background.blue);\n              }\n          }\n\n        else  /* Can't happen */\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      No room in PLTE to add bKGD color\");\n            ping_have_bKGD = MagickFalse;\n          }\n      }\n  }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    PNG color type: %s (%d)\", PngColorTypeToString(ping_color_type),\n      ping_color_type);\n  /*\n    Initialize compression level and filtering.\n  */\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Setting up deflate compression\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Compression buffer size: 32768\");\n    }\n\n  png_set_compression_buffer_size(ping,32768L);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Compression mem level: 9\");\n\n  png_set_compression_mem_level(ping, 9);\n\n  /* Untangle the \"-quality\" setting:\n\n     Undefined is 0; the default is used.\n     Default is 75\n\n     10's digit:\n\n        0 or omitted: Use Z_HUFFMAN_ONLY strategy with the\n           zlib default compression level\n\n        1-9: the zlib compression level\n\n     1's digit:\n\n        0-4: the PNG filter method\n\n        5:   libpng adaptive filtering if compression level > 5\n             libpng filter type \"none\" if compression level <= 5\n                or if image is grayscale or palette\n\n        6:   libpng adaptive filtering\n\n        7:   \"LOCO\" filtering (intrapixel differing) if writing\n             a MNG, otherwise \"none\".  Did not work in IM-6.7.0-9\n             and earlier because of a missing \"else\".\n\n        8:   Z_RLE strategy (or Z_HUFFMAN_ONLY if quality < 10), adaptive\n             filtering. Unused prior to IM-6.7.0-10, was same as 6\n\n        9:   Z_RLE strategy (or Z_HUFFMAN_ONLY if quality < 10), no PNG filters\n             Unused prior to IM-6.7.0-10, was same as 6\n\n    Note that using the -quality option, not all combinations of\n    PNG filter type, zlib compression level, and zlib compression\n    strategy are possible.  This will be addressed soon in a\n    release that accomodates \"-define png:compression-strategy\", etc.\n\n   */\n\n  quality=image_info->quality == UndefinedCompressionQuality ? 75UL :\n     image_info->quality;\n\n  if (quality <= 9)\n    {\n      if (mng_info->write_png_compression_strategy == 0)\n        mng_info->write_png_compression_strategy = Z_HUFFMAN_ONLY+1;\n    }\n\n  else if (mng_info->write_png_compression_level == 0)\n    {\n      int\n        level;\n\n      level=(int) MagickMin((ssize_t) quality/10,9);\n\n      mng_info->write_png_compression_level = level+1;\n    }\n\n  if (mng_info->write_png_compression_strategy == 0)\n    {\n        if ((quality %10) == 8 || (quality %10) == 9)\n#ifdef Z_RLE  /* Z_RLE was added to zlib-1.2.0 */\n          mng_info->write_png_compression_strategy=Z_RLE+1;\n#else\n          mng_info->write_png_compression_strategy = Z_DEFAULT_STRATEGY+1;\n#endif\n    }\n\n  if (mng_info->write_png_compression_filter == 0)\n        mng_info->write_png_compression_filter=((int) quality % 10) + 1;\n\n  if (logging != MagickFalse)\n    {\n        if (mng_info->write_png_compression_level)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Compression level:    %d\",\n            (int) mng_info->write_png_compression_level-1);\n\n        if (mng_info->write_png_compression_strategy)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Compression strategy: %d\",\n            (int) mng_info->write_png_compression_strategy-1);\n\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Setting up filtering\");\n\n        if (mng_info->write_png_compression_filter == 6)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Base filter method: ADAPTIVE\");\n        else if (mng_info->write_png_compression_filter == 0 ||\n                 mng_info->write_png_compression_filter == 1)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Base filter method: NONE\");\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Base filter method: %d\",\n            (int) mng_info->write_png_compression_filter-1);\n    }\n\n  if (mng_info->write_png_compression_level != 0)\n    png_set_compression_level(ping,mng_info->write_png_compression_level-1);\n\n  if (mng_info->write_png_compression_filter == 6)\n    {\n      if (((int) ping_color_type == PNG_COLOR_TYPE_GRAY) ||\n         ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE) ||\n         (quality < 50))\n        png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_NO_FILTERS);\n      else\n        png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_ALL_FILTERS);\n     }\n  else if (mng_info->write_png_compression_filter == 7 ||\n      mng_info->write_png_compression_filter == 10)\n    png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_ALL_FILTERS);\n\n  else if (mng_info->write_png_compression_filter == 8)\n    {\n#if defined(PNG_MNG_FEATURES_SUPPORTED) && defined(PNG_INTRAPIXEL_DIFFERENCING)\n      if (mng_info->write_mng)\n      {\n         if (((int) ping_color_type == PNG_COLOR_TYPE_RGB) ||\n             ((int) ping_color_type == PNG_COLOR_TYPE_RGBA))\n        ping_filter_method=PNG_INTRAPIXEL_DIFFERENCING;\n      }\n#endif\n      png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_NO_FILTERS);\n    }\n\n  else if (mng_info->write_png_compression_filter == 9)\n    png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_NO_FILTERS);\n\n  else if (mng_info->write_png_compression_filter != 0)\n    png_set_filter(ping,PNG_FILTER_TYPE_BASE,\n       mng_info->write_png_compression_filter-1);\n\n  if (mng_info->write_png_compression_strategy != 0)\n    png_set_compression_strategy(ping,\n       mng_info->write_png_compression_strategy-1);\n\n  ping_interlace_method=image_info->interlace != NoInterlace;\n\n  if (mng_info->write_mng)\n    png_set_sig_bytes(ping,8);\n\n  /* Bail out if cannot meet defined png:bit-depth or png:color-type */\n\n  if (mng_info->write_png_colortype != 0)\n    {\n     if (mng_info->write_png_colortype-1 == PNG_COLOR_TYPE_GRAY)\n       if (ping_have_color != MagickFalse)\n         {\n           ping_color_type = PNG_COLOR_TYPE_RGB;\n\n           if (ping_bit_depth < 8)\n             ping_bit_depth=8;\n         }\n\n     if (mng_info->write_png_colortype-1 == PNG_COLOR_TYPE_GRAY_ALPHA)\n       if (ping_have_color != MagickFalse)\n         ping_color_type = PNG_COLOR_TYPE_RGB_ALPHA;\n    }\n\n  if (ping_need_colortype_warning != MagickFalse ||\n     ((mng_info->write_png_depth &&\n     (int) mng_info->write_png_depth != ping_bit_depth) ||\n     (mng_info->write_png_colortype &&\n     ((int) mng_info->write_png_colortype-1 != ping_color_type &&\n      mng_info->write_png_colortype != 7 &&\n      !(mng_info->write_png_colortype == 5 && ping_color_type == 0)))))\n    {\n      if (logging != MagickFalse)\n        {\n          if (ping_need_colortype_warning != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"  Image has transparency but tRNS chunk was excluded\");\n            }\n\n          if (mng_info->write_png_depth)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Defined png:bit-depth=%u, Computed depth=%u\",\n                  mng_info->write_png_depth,\n                  ping_bit_depth);\n            }\n\n          if (mng_info->write_png_colortype)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Defined png:color-type=%u, Computed color type=%u\",\n                  mng_info->write_png_colortype-1,\n                  ping_color_type);\n            }\n        }\n\n      png_warning(ping,\n        \"Cannot write image with defined png:bit-depth or png:color-type.\");\n    }\n\n  if (image_matte != MagickFalse && image->alpha_trait == UndefinedPixelTrait)\n    {\n      /* Add an opaque matte channel */\n      image->alpha_trait = BlendPixelTrait;\n      (void) SetImageAlpha(image,OpaqueAlpha,exception);\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Added an opaque matte channel\");\n    }\n\n  if (number_transparent != 0 || number_semitransparent != 0)\n    {\n      if (ping_color_type < 4)\n        {\n           ping_have_tRNS=MagickTrue;\n           if (logging != MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"  Setting ping_have_tRNS=MagickTrue.\");\n        }\n    }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Writing PNG header chunks\");\n\n  png_set_IHDR(ping,ping_info,ping_width,ping_height,\n               ping_bit_depth,ping_color_type,\n               ping_interlace_method,ping_compression_method,\n               ping_filter_method);\n\n  if (ping_color_type == 3 && ping_have_PLTE != MagickFalse)\n    {\n      png_set_PLTE(ping,ping_info,palette,number_colors);\n\n      if (logging != MagickFalse)\n        {\n          for (i=0; i< (ssize_t) number_colors; i++)\n          {\n            if (i < ping_num_trans)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"     PLTE[%d] = (%d,%d,%d), tRNS[%d] = (%d)\",\n                      (int) i,\n                      (int) palette[i].red,\n                      (int) palette[i].green,\n                      (int) palette[i].blue,\n                      (int) i,\n                      (int) ping_trans_alpha[i]);\n             else\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"     PLTE[%d] = (%d,%d,%d)\",\n                      (int) i,\n                      (int) palette[i].red,\n                      (int) palette[i].green,\n                      (int) palette[i].blue);\n           }\n         }\n    }\n\n  /* Only write the iCCP chunk if we are not writing the sRGB chunk. */\n  if (ping_exclude_sRGB != MagickFalse ||\n     (!png_get_valid(ping,ping_info,PNG_INFO_sRGB)))\n  {\n    if ((ping_exclude_tEXt == MagickFalse ||\n       ping_exclude_zTXt == MagickFalse) &&\n       (ping_exclude_iCCP == MagickFalse || ping_exclude_zCCP == MagickFalse))\n    {\n      ResetImageProfileIterator(image);\n      for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n      {\n        profile=GetImageProfile(image,name);\n\n        if (profile != (StringInfo *) NULL)\n          {\n#ifdef PNG_WRITE_iCCP_SUPPORTED\n            if ((LocaleCompare(name,\"ICC\") == 0) ||\n                (LocaleCompare(name,\"ICM\") == 0))\n              {\n                ping_have_iCCP = MagickTrue;\n                if (ping_exclude_iCCP == MagickFalse)\n                  {\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"  Setting up iCCP chunk\");\n\n                    png_set_iCCP(ping,ping_info,(png_charp) name,0,\n#if (PNG_LIBPNG_VER < 10500)\n                    (png_charp) GetStringInfoDatum(profile),\n#else\n                    (const png_byte *) GetStringInfoDatum(profile),\n#endif\n                    (png_uint_32) GetStringInfoLength(profile));\n                  }\n                else\n                  {\n                    /* Do not write hex-encoded ICC chunk */\n                       name=GetNextImageProfile(image);\n                       continue;\n                  }\n              }\n#endif /* WRITE_iCCP */\n\n            if (LocaleCompare(name,\"exif\") == 0)\n              {\n                   /* Do not write hex-encoded ICC chunk; we will\n                      write it later as an eXIf chunk */\n                   name=GetNextImageProfile(image);\n                   continue;\n              }\n\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"  Setting up zTXt chunk with uuencoded %s profile\",\n                 name);\n              Magick_png_write_raw_profile(image_info,ping,ping_info,\n                (unsigned char *) name,(unsigned char *) name,\n                GetStringInfoDatum(profile),\n                (png_uint_32) GetStringInfoLength(profile));\n          }\n        name=GetNextImageProfile(image);\n      }\n    }\n  }\n\n#if defined(PNG_WRITE_sRGB_SUPPORTED)\n  if ((mng_info->have_write_global_srgb == 0) &&\n      ping_have_iCCP != MagickTrue &&\n      (ping_have_sRGB != MagickFalse ||\n      png_get_valid(ping,ping_info,PNG_INFO_sRGB)))\n    {\n      if (ping_exclude_sRGB == MagickFalse)\n        {\n          /*\n            Note image rendering intent.\n          */\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Setting up sRGB chunk\");\n\n          (void) png_set_sRGB(ping,ping_info,(\n            Magick_RenderingIntent_to_PNG_RenderingIntent(\n              image->rendering_intent)));\n\n          ping_have_sRGB = MagickTrue;\n        }\n    }\n\n  if ((!mng_info->write_mng) || (!png_get_valid(ping,ping_info,PNG_INFO_sRGB)))\n#endif\n    {\n      if (ping_exclude_gAMA == MagickFalse &&\n          ping_have_iCCP == MagickFalse &&\n          ping_have_sRGB == MagickFalse &&\n          (ping_exclude_sRGB == MagickFalse ||\n          (image->gamma < .45 || image->gamma > .46)))\n      {\n      if ((mng_info->have_write_global_gama == 0) && (image->gamma != 0.0))\n        {\n          /*\n            Note image gamma.\n            To do: check for cHRM+gAMA == sRGB, and write sRGB instead.\n          */\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Setting up gAMA chunk\");\n\n          png_set_gAMA(ping,ping_info,image->gamma);\n        }\n      }\n\n      if (ping_exclude_cHRM == MagickFalse && ping_have_sRGB == MagickFalse)\n        {\n          if ((mng_info->have_write_global_chrm == 0) &&\n              (image->chromaticity.red_primary.x != 0.0))\n            {\n              /*\n                Note image chromaticity.\n                Note: if cHRM+gAMA == sRGB write sRGB instead.\n              */\n               PrimaryInfo\n                 bp,\n                 gp,\n                 rp,\n                 wp;\n\n               wp=image->chromaticity.white_point;\n               rp=image->chromaticity.red_primary;\n               gp=image->chromaticity.green_primary;\n               bp=image->chromaticity.blue_primary;\n\n               if (logging != MagickFalse)\n                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"  Setting up cHRM chunk\");\n\n               png_set_cHRM(ping,ping_info,wp.x,wp.y,rp.x,rp.y,gp.x,gp.y,\n                   bp.x,bp.y);\n           }\n        }\n    }\n\n  if (ping_exclude_bKGD == MagickFalse)\n    {\n      if (ping_have_bKGD != MagickFalse)\n        {\n          png_set_bKGD(ping,ping_info,&ping_background);\n          if (logging != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"    Setting up bKGD chunk\");\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      background color = (%d,%d,%d)\",\n                        (int) ping_background.red,\n                        (int) ping_background.green,\n                        (int) ping_background.blue);\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      index = %d, gray=%d\",\n                        (int) ping_background.index,\n                        (int) ping_background.gray);\n            }\n         }\n    }\n\n  if (ping_exclude_pHYs == MagickFalse)\n    {\n      if (ping_have_pHYs != MagickFalse)\n        {\n          png_set_pHYs(ping,ping_info,\n             ping_pHYs_x_resolution,\n             ping_pHYs_y_resolution,\n             ping_pHYs_unit_type);\n\n          if (logging != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"    Setting up pHYs chunk\");\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      x_resolution=%lu\",\n                   (unsigned long) ping_pHYs_x_resolution);\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      y_resolution=%lu\",\n                   (unsigned long) ping_pHYs_y_resolution);\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      unit_type=%lu\",\n                   (unsigned long) ping_pHYs_unit_type);\n            }\n        }\n    }\n\n#if defined(PNG_tIME_SUPPORTED)\n  if (ping_exclude_tIME == MagickFalse)\n    {\n      const char\n        *timestamp;\n\n      if (image->taint == MagickFalse)\n        {\n          timestamp=GetImageOption(image_info,\"png:tIME\");\n\n          if (timestamp == (const char *) NULL)\n            timestamp=GetImageProperty(image,\"png:tIME\",exception);\n        }\n\n      else\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  Reset tIME in tainted image\");\n\n          timestamp=GetImageProperty(image,\"date:modify\",exception);\n        }\n\n      if (timestamp != (const char *) NULL)\n          write_tIME_chunk(image,ping,ping_info,timestamp,exception);\n    }\n#endif\n\n  if (mng_info->need_blob != MagickFalse)\n  {\n    if (OpenBlob(image_info,image,WriteBinaryBlobMode,exception) ==\n       MagickFalse)\n       png_error(ping,\"WriteBlob Failed\");\n\n     ping_have_blob=MagickTrue;\n  }\n\n  png_write_info_before_PLTE(ping, ping_info);\n\n  if (ping_have_tRNS != MagickFalse && ping_color_type < 4)\n    {\n      if (logging != MagickFalse)\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Calling png_set_tRNS with num_trans=%d\",ping_num_trans);\n        }\n\n      if (ping_color_type == 3)\n         (void) png_set_tRNS(ping, ping_info,\n                ping_trans_alpha,\n                ping_num_trans,\n                NULL);\n\n      else\n        {\n           (void) png_set_tRNS(ping, ping_info,\n                  NULL,\n                  0,\n                  &ping_trans_color);\n\n           if (logging != MagickFalse)\n             {\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"     tRNS color   =(%d,%d,%d)\",\n                       (int) ping_trans_color.red,\n                       (int) ping_trans_color.green,\n                       (int) ping_trans_color.blue);\n             }\n         }\n    }\n\n  /* write any png-chunk-b profiles */\n  (void) Magick_png_write_chunk_from_profile(image,\"PNG-chunk-b\",logging);\n\n  png_write_info(ping,ping_info);\n\n  /* write any PNG-chunk-m profiles */\n  (void) Magick_png_write_chunk_from_profile(image,\"PNG-chunk-m\",logging);\n\n  ping_wrote_caNv = MagickFalse;\n\n  /* write caNv chunk */\n  if (ping_exclude_caNv == MagickFalse)\n    {\n      if ((image->page.width != 0 && image->page.width != image->columns) ||\n          (image->page.height != 0 && image->page.height != image->rows) ||\n          image->page.x != 0 || image->page.y != 0)\n        {\n          unsigned char\n            chunk[20];\n\n          (void) WriteBlobMSBULong(image,16L);  /* data length=8 */\n          PNGType(chunk,mng_caNv);\n          LogPNGChunk(logging,mng_caNv,16L);\n          PNGLong(chunk+4,(png_uint_32) image->page.width);\n          PNGLong(chunk+8,(png_uint_32) image->page.height);\n          PNGsLong(chunk+12,(png_int_32) image->page.x);\n          PNGsLong(chunk+16,(png_int_32) image->page.y);\n          (void) WriteBlob(image,20,chunk);\n          (void) WriteBlobMSBULong(image,crc32(0,chunk,20));\n          ping_wrote_caNv = MagickTrue;\n        }\n    }\n\n#if defined(PNG_oFFs_SUPPORTED)\n  if (ping_exclude_oFFs == MagickFalse && ping_wrote_caNv == MagickFalse)\n    {\n      if (image->page.x || image->page.y)\n        {\n           png_set_oFFs(ping,ping_info,(png_int_32) image->page.x,\n              (png_int_32) image->page.y, 0);\n\n           if (logging != MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"    Setting up oFFs chunk with x=%d, y=%d, units=0\",\n                 (int) image->page.x, (int) image->page.y);\n        }\n    }\n#endif\n\n  /* write vpAg chunk (deprecated, replaced by caNv) */\n  if (ping_exclude_vpAg == MagickFalse && ping_wrote_caNv == MagickFalse)\n    {\n      if ((image->page.width != 0 && image->page.width != image->columns) ||\n          (image->page.height != 0 && image->page.height != image->rows))\n        {\n          unsigned char\n            chunk[14];\n\n          (void) WriteBlobMSBULong(image,9L);  /* data length=8 */\n          PNGType(chunk,mng_vpAg);\n          LogPNGChunk(logging,mng_vpAg,9L);\n          PNGLong(chunk+4,(png_uint_32) image->page.width);\n          PNGLong(chunk+8,(png_uint_32) image->page.height);\n          chunk[12]=0;   /* unit = pixels */\n          (void) WriteBlob(image,13,chunk);\n          (void) WriteBlobMSBULong(image,crc32(0,chunk,13));\n        }\n    }\n\n#if (PNG_LIBPNG_VER == 10206)\n    /* avoid libpng-1.2.6 bug by setting PNG_HAVE_IDAT flag */\n#define PNG_HAVE_IDAT               0x04\n    ping->mode |= PNG_HAVE_IDAT;\n#undef PNG_HAVE_IDAT\n#endif\n\n  png_set_packing(ping);\n  /*\n    Allocate memory.\n  */\n  rowbytes=image->columns;\n  if (image_depth > 8)\n    rowbytes*=2;\n  switch (ping_color_type)\n    {\n      case PNG_COLOR_TYPE_RGB:\n        rowbytes*=3;\n        break;\n\n      case PNG_COLOR_TYPE_GRAY_ALPHA:\n        rowbytes*=2;\n        break;\n\n      case PNG_COLOR_TYPE_RGBA:\n        rowbytes*=4;\n        break;\n\n      default:\n        break;\n    }\n\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Writing PNG image data\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Allocating %.20g bytes of memory for pixels\",(double) rowbytes);\n    }\n  pixel_info=AcquireVirtualMemory(rowbytes,sizeof(*ping_pixels));\n  if (pixel_info == (MemoryInfo *) NULL)\n    png_error(ping,\"Allocation of memory for pixels failed\");\n  ping_pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n\n  /*\n    Initialize image scanlines.\n  */\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    png_error(ping,\"Memory allocation for quantum_info failed\");\n  quantum_info->format=UndefinedQuantumFormat;\n  SetQuantumDepth(image,quantum_info,image_depth);\n  (void) SetQuantumEndian(image,quantum_info,MSBEndian);\n  num_passes=png_set_interlace_handling(ping);\n\n  if ((!mng_info->write_png8 && !mng_info->write_png24 &&\n       !mng_info->write_png48 && !mng_info->write_png64 &&\n       !mng_info->write_png32) &&\n       (mng_info->IsPalette ||\n       (image_info->type == BilevelType)) &&\n       image_matte == MagickFalse &&\n       ping_have_non_bw == MagickFalse)\n    {\n      /* Palette, Bilevel, or Opaque Monochrome */\n      register const Quantum\n        *p;\n\n      SetQuantumDepth(image,quantum_info,8);\n      for (pass=0; pass < num_passes; pass++)\n      {\n        /*\n          Convert PseudoClass image to a PNG monochrome image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          if (logging != MagickFalse && y == 0)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"    Writing row of pixels (0)\");\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n\n          if (p == (const Quantum *) NULL)\n            break;\n\n          if (mng_info->IsPalette)\n            {\n              (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                quantum_info,GrayQuantum,ping_pixels,exception);\n              if (mng_info->write_png_colortype-1 == PNG_COLOR_TYPE_PALETTE &&\n                  mng_info->write_png_depth &&\n                  mng_info->write_png_depth != old_bit_depth)\n                {\n                  /* Undo pixel scaling */\n                  for (i=0; i < (ssize_t) image->columns; i++)\n                     *(ping_pixels+i)=(unsigned char) (*(ping_pixels+i)\n                     >> (8-old_bit_depth));\n                }\n            }\n\n          else\n            {\n              (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                quantum_info,RedQuantum,ping_pixels,exception);\n            }\n\n          if (mng_info->write_png_colortype-1 != PNG_COLOR_TYPE_PALETTE)\n            for (i=0; i < (ssize_t) image->columns; i++)\n               *(ping_pixels+i)=(unsigned char) ((*(ping_pixels+i) > 127) ?\n                      255 : 0);\n\n          if (logging != MagickFalse && y == 0)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Writing row of pixels (1)\");\n\n          png_write_row(ping,ping_pixels);\n\n          status=SetImageProgress(image,SaveImageTag,\n              (MagickOffsetType) (pass * image->rows + y),\n              num_passes * image->rows);\n\n          if (status == MagickFalse)\n            break;\n        }\n      }\n    }\n\n  else   /* Not Palette, Bilevel, or Opaque Monochrome */\n    {\n      if ((!mng_info->write_png8 && !mng_info->write_png24 &&\n          !mng_info->write_png48 && !mng_info->write_png64 &&\n          !mng_info->write_png32) && (image_matte != MagickFalse ||\n          (ping_bit_depth >= MAGICKCORE_QUANTUM_DEPTH)) &&\n          (mng_info->IsPalette) && ping_have_color == MagickFalse)\n        {\n          register const Quantum\n            *p;\n\n          for (pass=0; pass < num_passes; pass++)\n          {\n\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n\n            if (p == (const Quantum *) NULL)\n              break;\n\n            if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n              {\n                if (mng_info->IsPalette)\n                  (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                    quantum_info,GrayQuantum,ping_pixels,exception);\n\n                else\n                  (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                    quantum_info,RedQuantum,ping_pixels,exception);\n\n                if (logging != MagickFalse && y == 0)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                       \"    Writing GRAY PNG pixels (2)\");\n              }\n\n            else /* PNG_COLOR_TYPE_GRAY_ALPHA */\n              {\n                if (logging != MagickFalse && y == 0)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                         \"    Writing GRAY_ALPHA PNG pixels (2)\");\n\n                (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                  quantum_info,GrayAlphaQuantum,ping_pixels,exception);\n              }\n\n            if (logging != MagickFalse && y == 0)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    Writing row of pixels (2)\");\n\n            png_write_row(ping,ping_pixels);\n\n            status=SetImageProgress(image,SaveImageTag,\n              (MagickOffsetType) (pass * image->rows + y),\n              num_passes * image->rows);\n\n            if (status == MagickFalse)\n              break;\n            }\n          }\n        }\n\n      else\n        {\n          register const Quantum\n            *p;\n\n          for (pass=0; pass < num_passes; pass++)\n          {\n            if ((image_depth > 8) ||\n                mng_info->write_png24 ||\n                mng_info->write_png32 ||\n                mng_info->write_png48 ||\n                mng_info->write_png64 ||\n                (!mng_info->write_png8 && !mng_info->IsPalette))\n            {\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                p=GetVirtualPixels(image,0,y,image->columns,1, exception);\n\n                if (p == (const Quantum *) NULL)\n                  break;\n\n                if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n                  {\n                    if (image->storage_class == DirectClass)\n                      (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                        quantum_info,RedQuantum,ping_pixels,exception);\n\n                    else\n                      (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                        quantum_info,GrayQuantum,ping_pixels,exception);\n                  }\n\n                else if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n                  {\n                    (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                      quantum_info,GrayAlphaQuantum,ping_pixels,\n                      exception);\n\n                    if (logging != MagickFalse && y == 0)\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                           \"    Writing GRAY_ALPHA PNG pixels (3)\");\n                  }\n\n                else if (image_matte != MagickFalse)\n                  (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                    quantum_info,RGBAQuantum,ping_pixels,exception);\n\n                else\n                  (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                    quantum_info,RGBQuantum,ping_pixels,exception);\n\n                if (logging != MagickFalse && y == 0)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"    Writing row of pixels (3)\");\n\n                png_write_row(ping,ping_pixels);\n\n                status=SetImageProgress(image,SaveImageTag,\n                  (MagickOffsetType) (pass * image->rows + y),\n                  num_passes * image->rows);\n\n                if (status == MagickFalse)\n                  break;\n              }\n            }\n\n          else\n            /* not ((image_depth > 8) ||\n                mng_info->write_png24 || mng_info->write_png32 ||\n                mng_info->write_png48 || mng_info->write_png64 ||\n                (!mng_info->write_png8 && !mng_info->IsPalette))\n             */\n            {\n              if ((ping_color_type != PNG_COLOR_TYPE_GRAY) &&\n                  (ping_color_type != PNG_COLOR_TYPE_GRAY_ALPHA))\n                {\n                  if (logging != MagickFalse)\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"  pass %d, Image Is not GRAY or GRAY_ALPHA\",pass);\n\n                  SetQuantumDepth(image,quantum_info,8);\n                  image_depth=8;\n                }\n\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                if (logging != MagickFalse && y == 0)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  pass %d, Image Is RGB, 16-bit GRAY, or GRAY_ALPHA\",\n                    pass);\n\n                p=GetVirtualPixels(image,0,y,image->columns,1, exception);\n\n                if (p == (const Quantum *) NULL)\n                  break;\n\n                if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n                  {\n                    SetQuantumDepth(image,quantum_info,image->depth);\n\n                    (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                       quantum_info,GrayQuantum,ping_pixels,exception);\n                  }\n\n                else if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n                  {\n                    if (logging != MagickFalse && y == 0)\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                           \"  Writing GRAY_ALPHA PNG pixels (4)\");\n\n                    (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                         quantum_info,GrayAlphaQuantum,ping_pixels,\n                         exception);\n                  }\n\n                else\n                  {\n                    (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                      quantum_info,IndexQuantum,ping_pixels,exception);\n\n                    if (logging != MagickFalse && y <= 2)\n                    {\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  Writing row of non-gray pixels (4)\");\n\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  ping_pixels[0]=%d,ping_pixels[1]=%d\",\n                          (int)ping_pixels[0],(int)ping_pixels[1]);\n                    }\n                  }\n                png_write_row(ping,ping_pixels);\n\n                status=SetImageProgress(image,SaveImageTag,\n                  (MagickOffsetType) (pass * image->rows + y),\n                  num_passes * image->rows);\n\n                if (status == MagickFalse)\n                  break;\n              }\n            }\n          }\n        }\n    }\n\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\n\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Wrote PNG image data\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Width: %.20g\",(double) ping_width);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Height: %.20g\",(double) ping_height);\n\n      if (mng_info->write_png_depth)\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Defined png:bit-depth: %d\",mng_info->write_png_depth);\n        }\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    PNG bit-depth written: %d\",ping_bit_depth);\n\n      if (mng_info->write_png_colortype)\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Defined png:color-type: %d\",mng_info->write_png_colortype-1);\n        }\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    PNG color-type written: %d\",ping_color_type);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    PNG Interlace method: %d\",ping_interlace_method);\n    }\n  /*\n    Generate text chunks after IDAT.\n  */\n  if (ping_exclude_tEXt == MagickFalse || ping_exclude_zTXt == MagickFalse)\n  {\n    ResetImagePropertyIterator(image);\n    property=GetNextImageProperty(image);\n    while (property != (const char *) NULL)\n    {\n      png_textp\n        text;\n\n      value=GetImageProperty(image,property,exception);\n\n      /* Don't write any \"png:\" or \"jpeg:\" properties; those are just for\n       * \"identify\" or for passing through to another JPEG\n       */\n      if ((LocaleNCompare(property,\"png:\",4) != 0 &&\n           LocaleNCompare(property,\"jpeg:\",5) != 0) &&\n\n\n          /* Suppress density and units if we wrote a pHYs chunk */\n          (ping_exclude_pHYs != MagickFalse      ||\n          LocaleCompare(property,\"density\") != 0 ||\n          LocaleCompare(property,\"units\") != 0) &&\n\n          /* Suppress the IM-generated Date:create and Date:modify */\n          (ping_exclude_date == MagickFalse      ||\n          LocaleNCompare(property, \"Date:\",5) != 0))\n        {\n        if (value != (const char *) NULL)\n          {\n\n#if PNG_LIBPNG_VER >= 10400\n            text=(png_textp) png_malloc(ping,\n                 (png_alloc_size_t) sizeof(png_text));\n#else\n            text=(png_textp) png_malloc(ping,(png_size_t) sizeof(png_text));\n#endif\n            text[0].key=(char *) property;\n            text[0].text=(char *) value;\n            text[0].text_length=strlen(value);\n\n            if (ping_exclude_tEXt != MagickFalse)\n               text[0].compression=PNG_TEXT_COMPRESSION_zTXt;\n\n            else if (ping_exclude_zTXt != MagickFalse)\n               text[0].compression=PNG_TEXT_COMPRESSION_NONE;\n\n            else\n            {\n               text[0].compression=image_info->compression == NoCompression ||\n                 (image_info->compression == UndefinedCompression &&\n                 text[0].text_length < 128) ? PNG_TEXT_COMPRESSION_NONE :\n                 PNG_TEXT_COMPRESSION_zTXt ;\n            }\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Setting up text chunk\");\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    keyword: '%s'\",text[0].key);\n              }\n\n            png_set_text(ping,ping_info,text,1);\n            png_free(ping,text);\n          }\n        }\n      property=GetNextImageProperty(image);\n    }\n  }\n\n  /* write any PNG-chunk-e profiles */\n  (void) Magick_png_write_chunk_from_profile(image,\"PNG-chunk-e\",logging);\n\n  /* write exIf profile */\n  if (ping_have_eXIf != MagickFalse && ping_exclude_eXIf == MagickFalse)\n    {\n      char\n        *name;\n\n      ResetImageProfileIterator(image);\n\n      for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n      {\n        if (LocaleCompare(name,\"exif\") == 0)\n          {\n            const StringInfo\n              *profile;\n\n            profile=GetImageProfile(image,name);\n\n            if (profile != (StringInfo *) NULL)\n              {\n                png_uint_32\n                  length;\n\n                unsigned char\n                  chunk[4],\n                  *data;\n\n               StringInfo\n                 *ping_profile;\n\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Have eXIf profile\");\n\n               ping_profile=CloneStringInfo(profile);\n               data=GetStringInfoDatum(ping_profile),\n               length=(png_uint_32) GetStringInfoLength(ping_profile);\n\n               PNGType(chunk,mng_eXIf);\n               if (length < 7)\n                 {\n                   ping_profile=DestroyStringInfo(ping_profile);\n                   break;  /* otherwise crashes */\n                 }\n\n               /* skip the \"Exif\\0\\0\" JFIF Exif Header ID */\n               length -= 6;\n\n               LogPNGChunk(logging,chunk,length);\n               (void) WriteBlobMSBULong(image,length);\n               (void) WriteBlob(image,4,chunk);\n               (void) WriteBlob(image,length,data+6);\n               (void) WriteBlobMSBULong(image,crc32(crc32(0,chunk,4),\n                 data+6, (uInt) length));\n               ping_profile=DestroyStringInfo(ping_profile);\n               break;\n             }\n         }\n       name=GetNextImageProfile(image);\n     }\n  }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Writing PNG end info\");\n\n  png_write_end(ping,ping_info);\n\n  if (mng_info->need_fram && (int) image->dispose == BackgroundDispose)\n    {\n      if (mng_info->page.x || mng_info->page.y ||\n          (ping_width != mng_info->page.width) ||\n          (ping_height != mng_info->page.height))\n        {\n          unsigned char\n            chunk[32];\n\n          /*\n            Write FRAM 4 with clipping boundaries followed by FRAM 1.\n          */\n          (void) WriteBlobMSBULong(image,27L);  /* data length=27 */\n          PNGType(chunk,mng_FRAM);\n          LogPNGChunk(logging,mng_FRAM,27L);\n          chunk[4]=4;\n          chunk[5]=0;  /* frame name separator (no name) */\n          chunk[6]=1;  /* flag for changing delay, for next frame only */\n          chunk[7]=0;  /* flag for changing frame timeout */\n          chunk[8]=1;  /* flag for changing frame clipping for next frame */\n          chunk[9]=0;  /* flag for changing frame sync_id */\n          PNGLong(chunk+10,(png_uint_32) (0L)); /* temporary 0 delay */\n          chunk[14]=0; /* clipping boundaries delta type */\n          PNGLong(chunk+15,(png_uint_32) (mng_info->page.x)); /* left cb */\n          PNGLong(chunk+19,\n             (png_uint_32) (mng_info->page.x + ping_width));\n          PNGLong(chunk+23,(png_uint_32) (mng_info->page.y)); /* top cb */\n          PNGLong(chunk+27,\n             (png_uint_32) (mng_info->page.y + ping_height));\n          (void) WriteBlob(image,31,chunk);\n          (void) WriteBlobMSBULong(image,crc32(0,chunk,31));\n          mng_info->old_framing_mode=4;\n          mng_info->framing_mode=1;\n        }\n\n      else\n        mng_info->framing_mode=3;\n    }\n  if (mng_info->write_mng && !mng_info->need_fram &&\n      ((int) image->dispose == 3))\n     png_error(ping, \"Cannot convert GIF with disposal method 3 to MNG-LC\");\n\n  /*\n    Free PNG resources.\n  */\n\n  png_destroy_write_struct(&ping,&ping_info);\n\n  pixel_info=RelinquishVirtualMemory(pixel_info);\n\n  if (ping_have_blob != MagickFalse)\n     (void) CloseBlob(image);\n\n  image_info=DestroyImageInfo(image_info);\n  image=DestroyImage(image);\n\n  /* Store bit depth actually written */\n  s[0]=(char) ping_bit_depth;\n  s[1]='\\0';\n\n  (void) SetImageProperty(IMimage,\"png:bit-depth-written\",s,exception);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit WriteOnePNGImage()\");\n\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n  UnlockSemaphoreInfo(ping_semaphore);\n#endif\n\n   /* }  for navigation to beginning of SETJMP-protected block. Revert to\n    *    Throwing an Exception when an error occurs.\n    */\n\n  return(MagickTrue);\n/*  End write one PNG image */\n\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 403,
    "critical_vars": [
      "py_value",
      "nullptr"
    ],
    "function": "SetOpAttrList",
    "filename": "tensorflow/CVE-2022-41889/CVE-2022-41889_CWE-476_e9e95553e5411834d215e6770c81a83a3d0866ce_pywrap_tfe_src.cc.diff",
    "function_code": "bool SetOpAttrList(TFE_Context* ctx, TFE_Op* op, const char* key,\n                   PyObject* py_list, TF_AttrType type,\n                   tensorflow::gtl::FlatMap<string, int64_t>* attr_list_sizes,\n                   TF_Status* status) {\n  if (!PySequence_Check(py_list)) {\n    TF_SetStatus(\n        status, TF_INVALID_ARGUMENT,\n        tensorflow::strings::StrCat(\"Expecting sequence value for attr \", key,\n                                    \", got \", py_list->ob_type->tp_name)\n            .c_str());\n    return false;\n  }\n  const int num_values = PySequence_Size(py_list);\n  if (attr_list_sizes != nullptr) (*attr_list_sizes)[key] = num_values;\n\n#define PARSE_LIST(c_type, parse_fn)                                       \\\n  std::unique_ptr<c_type[]> values(new c_type[num_values]);                \\\n  for (int i = 0; i < num_values; ++i) {                                   \\\n    tensorflow::Safe_PyObjectPtr py_value(PySequence_ITEM(py_list, i));    \\\n    if (py_value == nullptr) {                                             \\\n      TF_SetStatus(status, TF_INVALID_ARGUMENT,                            \\\n                   tensorflow::strings::StrCat(                            \\\n                       \"Expecting sequence of \" #c_type \" for attr \", key, \\\n                       \", got \", py_list->ob_type->tp_name)                \\\n                       .c_str());                                          \\\n      return false;                                                        \\\n    } else if (!parse_fn(key, py_value.get(), status, &values[i])) {       \\\n      return false;                                                        \\\n    }                                                                      \\\n  }\n\n  if (type == TF_ATTR_STRING) {\n    std::unique_ptr<const void*[]> values(new const void*[num_values]);\n    std::unique_ptr<size_t[]> lengths(new size_t[num_values]);\n    for (int i = 0; i < num_values; ++i) {\n      tensorflow::StringPiece value;\n      tensorflow::Safe_PyObjectPtr py_value(PySequence_ITEM(py_list, i));\n      if (!ParseStringValue(key, py_value.get(), status, &value)) return false;\n      values[i] = value.data();\n      lengths[i] = value.size();\n    }\n    TFE_OpSetAttrStringList(op, key, values.get(), lengths.get(), num_values);\n  } else if (type == TF_ATTR_INT) {\n    PARSE_LIST(int64_t, ParseInt64Value);\n    TFE_OpSetAttrIntList(op, key, values.get(), num_values);\n  } else if (type == TF_ATTR_FLOAT) {\n    PARSE_LIST(float, ParseFloatValue);\n    TFE_OpSetAttrFloatList(op, key, values.get(), num_values);\n  } else if (type == TF_ATTR_BOOL) {\n    PARSE_LIST(unsigned char, ParseBoolValue);\n    TFE_OpSetAttrBoolList(op, key, values.get(), num_values);\n  } else if (type == TF_ATTR_TYPE) {\n    PARSE_LIST(int, ParseTypeValue);\n    TFE_OpSetAttrTypeList(op, key,\n                          reinterpret_cast<const TF_DataType*>(values.get()),\n                          num_values);\n  } else if (type == TF_ATTR_SHAPE) {\n    // Make one pass through the input counting the total number of\n    // dims across all the input lists.\n    int total_dims = 0;\n    for (int i = 0; i < num_values; ++i) {\n      tensorflow::Safe_PyObjectPtr py_value(PySequence_ITEM(py_list, i));\n      if (py_value.get() != Py_None) {\n        if (!PySequence_Check(py_value.get())) {\n          TF_SetStatus(\n              status, TF_INVALID_ARGUMENT,\n              tensorflow::strings::StrCat(\n                  \"Expecting None or sequence value for element\", i,\n                  \" of attr \", key, \", got \", py_value->ob_type->tp_name)\n                  .c_str());\n          return false;\n        }\n        const auto size = TensorShapeNumDims(py_value.get());\n        if (size >= 0) {\n          total_dims += size;\n        }\n      }\n    }\n    // Allocate a buffer that can fit all of the dims together.\n    std::unique_ptr<int64_t[]> buffer(new int64_t[total_dims]);\n    // Copy the input dims into the buffer and set dims to point to\n    // the start of each list's dims.\n    std::unique_ptr<const int64_t*[]> dims(new const int64_t*[num_values]);\n    std::unique_ptr<int[]> num_dims(new int[num_values]);\n    int64_t* offset = buffer.get();\n    for (int i = 0; i < num_values; ++i) {\n      tensorflow::Safe_PyObjectPtr py_value(PySequence_ITEM(py_list, i));\n      if (py_value.get() == Py_None) {\n        dims[i] = nullptr;\n        num_dims[i] = -1;\n      } else {\n        const auto size = TensorShapeNumDims(py_value.get());\n        if (size == -1) {\n          dims[i] = nullptr;\n          num_dims[i] = -1;\n          continue;\n        }\n        dims[i] = offset;\n        num_dims[i] = size;\n        for (int j = 0; j < size; ++j) {\n          tensorflow::Safe_PyObjectPtr inner_py_value(\n              PySequence_ITEM(py_value.get(), j));\n          if (inner_py_value.get() == Py_None) {\n            *offset = -1;\n          } else if (!ParseDimensionValue(key, inner_py_value.get(), status,\n                                          offset)) {\n            return false;\n          }\n          ++offset;\n        }\n      }\n    }\n    TFE_OpSetAttrShapeList(op, key, dims.get(), num_dims.get(), num_values,\n                           status);\n    if (!status->status.ok()) return false;\n  } else if (type == TF_ATTR_FUNC) {\n    std::unique_ptr<const TFE_Op*[]> funcs(new const TFE_Op*[num_values]);\n    for (int i = 0; i < num_values; ++i) {\n      tensorflow::Safe_PyObjectPtr py_value(PySequence_ITEM(py_list, i));\n      // Allow:\n      // (1) String function name, OR\n      // (2) A Python object with a .name attribute\n      //     (A crude test for being a\n      //     tensorflow.python.framework.function._DefinedFunction)\n      //     (which is what the various \"defun\" or \"Defun\" decorators do).\n      // And in the future also allow an object that can encapsulate\n      // the function name and its attribute values.\n      tensorflow::StringPiece func_name;\n      if (!ParseStringValue(key, py_value.get(), status, &func_name)) {\n        PyObject* name_attr = PyObject_GetAttrString(py_value.get(), \"name\");\n        if (name_attr == nullptr ||\n            !ParseStringValue(key, name_attr, status, &func_name)) {\n          TF_SetStatus(\n              status, TF_INVALID_ARGUMENT,\n              tensorflow::strings::StrCat(\n                  \"unable to set function value attribute from a \",\n                  py_value.get()->ob_type->tp_name,\n                  \" object. If you think this is an error, please file an \"\n                  \"issue at \"\n                  \"https://github.com/tensorflow/tensorflow/issues/new\")\n                  .c_str());\n          return false;\n        }\n      }\n      funcs[i] = TFE_NewOp(ctx, func_name.data(), status);\n      if (!status->status.ok()) return false;\n    }\n    TFE_OpSetAttrFunctionList(op, key, funcs.get(), num_values);\n    if (!status->status.ok()) return false;\n  } else {\n    TF_SetStatus(status, TF_UNIMPLEMENTED,\n                 tensorflow::strings::StrCat(\"Attr \", key,\n                                             \" has unhandled list type \", type)\n                     .c_str());\n    return false;\n  }\n#undef PARSE_LIST\n  return true;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 693,
    "critical_vars": [
      "key",
      "status"
    ],
    "function": "SetOpAttrScalar",
    "filename": "tensorflow/CVE-2022-29205/CVE-2022-29205_CWE-476_237822b59fc504dda2c564787f5d3ad9c4aa62d9_pywrap_tfe_src.cc.diff",
    "function_code": "bool SetOpAttrScalar(TFE_Context* ctx, TFE_Op* op, const char* key,\n                     PyObject* py_value, TF_AttrType type,\n                     tensorflow::gtl::FlatMap<string, int64_t>* attr_list_sizes,\n                     TF_Status* status) {\n  if (type == TF_ATTR_STRING) {\n    tensorflow::StringPiece value;\n    if (!ParseStringValue(key, py_value, status, &value)) return false;\n    TFE_OpSetAttrString(op, key, value.data(), value.size());\n  } else if (type == TF_ATTR_INT) {\n    int64_t value;\n    if (!ParseInt64Value(key, py_value, status, &value)) return false;\n    TFE_OpSetAttrInt(op, key, value);\n    // attr_list_sizes is set for all int attributes (since at this point we are\n    // not aware if that attribute might be used to calculate the size of an\n    // output list or not).\n    if (attr_list_sizes != nullptr) (*attr_list_sizes)[key] = value;\n  } else if (type == TF_ATTR_FLOAT) {\n    float value;\n    if (!ParseFloatValue(key, py_value, status, &value)) return false;\n    TFE_OpSetAttrFloat(op, key, value);\n  } else if (type == TF_ATTR_BOOL) {\n    unsigned char value;\n    if (!ParseBoolValue(key, py_value, status, &value)) return false;\n    TFE_OpSetAttrBool(op, key, value);\n  } else if (type == TF_ATTR_TYPE) {\n    int value;\n    if (!ParseTypeValue(key, py_value, status, &value)) return false;\n    TFE_OpSetAttrType(op, key, static_cast<TF_DataType>(value));\n  } else if (type == TF_ATTR_SHAPE) {\n    if (py_value == Py_None) {\n      TFE_OpSetAttrShape(op, key, nullptr, -1, status);\n    } else {\n      if (!PySequence_Check(py_value)) {\n        TF_SetStatus(status, TF_INVALID_ARGUMENT,\n                     tensorflow::strings::StrCat(\n                         \"Expecting None or sequence value for attr\", key,\n                         \", got \", py_value->ob_type->tp_name)\n                         .c_str());\n        return false;\n      }\n      const auto num_dims = TensorShapeNumDims(py_value);\n      if (num_dims == -1) {\n        TFE_OpSetAttrShape(op, key, nullptr, -1, status);\n        return true;\n      }\n      std::unique_ptr<int64_t[]> dims(new int64_t[num_dims]);\n      for (int i = 0; i < num_dims; ++i) {\n        tensorflow::Safe_PyObjectPtr inner_py_value(\n            PySequence_ITEM(py_value, i));\n        if (inner_py_value.get() == Py_None) {\n          dims[i] = -1;\n        } else if (!ParseDimensionValue(key, inner_py_value.get(), status,\n                                        &dims[i])) {\n          return false;\n        }\n      }\n      TFE_OpSetAttrShape(op, key, dims.get(), num_dims, status);\n    }\n    if (!status->status.ok()) return false;\n  } else if (type == TF_ATTR_FUNC) {\n    // Allow:\n    // (1) String function name, OR\n    // (2) A Python object with a .name attribute\n    //     (A crude test for being a\n    //     tensorflow.python.framework.function._DefinedFunction)\n    //     (which is what the various \"defun\" or \"Defun\" decorators do).\n    // And in the future also allow an object that can encapsulate\n    // the function name and its attribute values.\n    tensorflow::StringPiece func_name;\n    if (!ParseStringValue(key, py_value, status, &func_name)) {\n      PyObject* name_attr = PyObject_GetAttrString(py_value, \"name\");\n      if (name_attr == nullptr ||\n          !ParseStringValue(key, name_attr, status, &func_name)) {\n        TF_SetStatus(\n            status, TF_INVALID_ARGUMENT,\n            tensorflow::strings::StrCat(\n                \"unable to set function value attribute from a \",\n                py_value->ob_type->tp_name,\n                \" object. If you think this is an error, please file an issue \"\n                \"at https://github.com/tensorflow/tensorflow/issues/new\")\n                .c_str());\n        return false;\n      }\n    }\n    TF_SetStatus(status, TF_OK, \"\");\n    TFE_OpSetAttrFunctionName(op, key, func_name.data(), func_name.size());\n  } else {\n    TF_SetStatus(\n        status, TF_UNIMPLEMENTED,\n        tensorflow::strings::StrCat(\"Attr \", key, \" has unhandled type \", type)\n            .c_str());\n    return false;\n  }\n  return true;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 695,
    "critical_vars": [
      "key",
      "status",
      "nullptr"
    ],
    "function": "SetOpAttrScalar",
    "filename": "tensorflow/CVE-2022-29205/CVE-2022-29205_CWE-476_237822b59fc504dda2c564787f5d3ad9c4aa62d9_pywrap_tfe_src.cc.diff",
    "function_code": "bool SetOpAttrScalar(TFE_Context* ctx, TFE_Op* op, const char* key,\n                     PyObject* py_value, TF_AttrType type,\n                     tensorflow::gtl::FlatMap<string, int64_t>* attr_list_sizes,\n                     TF_Status* status) {\n  if (type == TF_ATTR_STRING) {\n    tensorflow::StringPiece value;\n    if (!ParseStringValue(key, py_value, status, &value)) return false;\n    TFE_OpSetAttrString(op, key, value.data(), value.size());\n  } else if (type == TF_ATTR_INT) {\n    int64_t value;\n    if (!ParseInt64Value(key, py_value, status, &value)) return false;\n    TFE_OpSetAttrInt(op, key, value);\n    // attr_list_sizes is set for all int attributes (since at this point we are\n    // not aware if that attribute might be used to calculate the size of an\n    // output list or not).\n    if (attr_list_sizes != nullptr) (*attr_list_sizes)[key] = value;\n  } else if (type == TF_ATTR_FLOAT) {\n    float value;\n    if (!ParseFloatValue(key, py_value, status, &value)) return false;\n    TFE_OpSetAttrFloat(op, key, value);\n  } else if (type == TF_ATTR_BOOL) {\n    unsigned char value;\n    if (!ParseBoolValue(key, py_value, status, &value)) return false;\n    TFE_OpSetAttrBool(op, key, value);\n  } else if (type == TF_ATTR_TYPE) {\n    int value;\n    if (!ParseTypeValue(key, py_value, status, &value)) return false;\n    TFE_OpSetAttrType(op, key, static_cast<TF_DataType>(value));\n  } else if (type == TF_ATTR_SHAPE) {\n    if (py_value == Py_None) {\n      TFE_OpSetAttrShape(op, key, nullptr, -1, status);\n    } else {\n      if (!PySequence_Check(py_value)) {\n        TF_SetStatus(status, TF_INVALID_ARGUMENT,\n                     tensorflow::strings::StrCat(\n                         \"Expecting None or sequence value for attr\", key,\n                         \", got \", py_value->ob_type->tp_name)\n                         .c_str());\n        return false;\n      }\n      const auto num_dims = TensorShapeNumDims(py_value);\n      if (num_dims == -1) {\n        TFE_OpSetAttrShape(op, key, nullptr, -1, status);\n        return true;\n      }\n      std::unique_ptr<int64_t[]> dims(new int64_t[num_dims]);\n      for (int i = 0; i < num_dims; ++i) {\n        tensorflow::Safe_PyObjectPtr inner_py_value(\n            PySequence_ITEM(py_value, i));\n        // If an error is generated when iterating through object, we can\n        // sometimes get a nullptr.\n        if (inner_py_value.get() == Py_None) {\n          dims[i] = -1;\n        } else if (inner_py_value.get() == nullptr ||\n                   !ParseDimensionValue(key, inner_py_value.get(), status,\n                                        &dims[i])) {\n          return false;\n        }\n      }\n      TFE_OpSetAttrShape(op, key, dims.get(), num_dims, status);\n    }\n    if (!status->status.ok()) return false;\n  } else if (type == TF_ATTR_FUNC) {\n    // Allow:\n    // (1) String function name, OR\n    // (2) A Python object with a .name attribute\n    //     (A crude test for being a\n    //     tensorflow.python.framework.function._DefinedFunction)\n    //     (which is what the various \"defun\" or \"Defun\" decorators do).\n    // And in the future also allow an object that can encapsulate\n    // the function name and its attribute values.\n    tensorflow::StringPiece func_name;\n    if (!ParseStringValue(key, py_value, status, &func_name)) {\n      PyObject* name_attr = PyObject_GetAttrString(py_value, \"name\");\n      if (name_attr == nullptr ||\n          !ParseStringValue(key, name_attr, status, &func_name)) {\n        TF_SetStatus(\n            status, TF_INVALID_ARGUMENT,\n            tensorflow::strings::StrCat(\n                \"unable to set function value attribute from a \",\n                py_value->ob_type->tp_name,\n                \" object. If you think this is an error, please file an issue \"\n                \"at https://github.com/tensorflow/tensorflow/issues/new\")\n                .c_str());\n        return false;\n      }\n    }\n    TF_SetStatus(status, TF_OK, \"\");\n    TFE_OpSetAttrFunctionName(op, key, func_name.data(), func_name.size());\n  } else {\n    TF_SetStatus(\n        status, TF_UNIMPLEMENTED,\n        tensorflow::strings::StrCat(\"Attr \", key, \" has unhandled type \", type)\n            .c_str());\n    return false;\n  }\n  return true;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 518,
    "critical_vars": [
      "input"
    ],
    "function": "ndlz4_decompress",
    "filename": "c-blosc2/CVE-2023-37186/CVE-2023-37186_CWE-476_d55bfcd6804699e1435dc3e233fd76c8a5d3f9e3_ndlz4x4.c.diff",
    "function_code": "int ndlz4_decompress(const uint8_t *input, int32_t input_len, uint8_t *output, int32_t output_len,\n                     uint8_t meta, blosc2_dparams *dparams) {\n  BLOSC_UNUSED_PARAM(meta);\n  BLOSC_UNUSED_PARAM(dparams);\n  BLOSC_ERROR_NULL(input, BLOSC2_ERROR_NULL_POINTER);\n  BLOSC_ERROR_NULL(output, BLOSC2_ERROR_NULL_POINTER);\n\n  uint8_t *ip = (uint8_t *) input;\n  uint8_t *ip_limit = ip + input_len;\n  uint8_t *op = (uint8_t *) output;\n  uint8_t ndim;\n  uint32_t blockshape[2];\n  uint32_t eshape[2];\n  uint8_t *buffercpy;\n  uint8_t local_buffer[16];\n  uint8_t token;\n  if (NDLZ_UNEXPECT_CONDITIONAL(input_len < 8)) {\n    return 0;\n  }\n\n  /* we start with literal copy */\n  ndim = *ip;\n  ip++;\n  if (ndim != 2) {\n    BLOSC_TRACE_ERROR(\"This codec only works for ndim = 2\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n  memcpy(&blockshape[0], ip, 4);\n  ip += 4;\n  memcpy(&blockshape[1], ip, 4);\n  ip += 4;\n  eshape[0] = ((blockshape[0] + 3) / 4) * 4;\n  eshape[1] = ((blockshape[1] + 3) / 4) * 4;\n\n  if (NDLZ_UNEXPECT_CONDITIONAL((int64_t)output_len < (int64_t)blockshape[0] * (int64_t)blockshape[1])) {\n    return 0;\n  }\n  memset(op, 0, blockshape[0] * blockshape[1]);\n\n  uint32_t i_stop[2];\n  for (int i = 0; i < 2; ++i) {\n    i_stop[i] = eshape[i] / 4;\n  }\n\n  /* main loop */\n  uint32_t ii[2];\n  uint32_t padding[2] = {0};\n  uint32_t ind = 0;\n  uint8_t cell_aux[16];\n  for (ii[0] = 0; ii[0] < i_stop[0]; ++ii[0]) {\n    for (ii[1] = 0; ii[1] < i_stop[1]; ++ii[1]) {      // for each cell\n      if (NDLZ_UNEXPECT_CONDITIONAL(ip > ip_limit)) {\n        BLOSC_TRACE_ERROR(\"Exceeding input length\");\n        return BLOSC2_ERROR_FAILURE;\n      }\n      if (ii[0] == i_stop[0] - 1) {\n        padding[0] = (blockshape[0] % 4 == 0) ? 4 : blockshape[0] % 4;\n      } else {\n        padding[0] = 4;\n      }\n      if (ii[1] == i_stop[1] - 1) {\n        padding[1] = (blockshape[1] % 4 == 0) ? 4 : blockshape[1] % 4;\n      } else {\n        padding[1] = 4;\n      }\n      token = *ip++;\n      if (token == 0) {    // no match\n        buffercpy = ip;\n        ip += padding[0] * padding[1];\n      } else if (token == (uint8_t) ((1U << 7U) | (1U << 6U))) {  // cell match\n        uint16_t offset = *((uint16_t *) ip);\n        buffercpy = ip - offset - 1;\n        ip += 2;\n      } else if (token == (uint8_t) (1U << 6U)) { // whole cell of same element\n        buffercpy = cell_aux;\n        memset(buffercpy, *ip, 16);\n        ip++;\n      } else if (token >= 224) { // three rows match\n        buffercpy = local_buffer;\n        uint16_t offset = *((uint16_t *) ip);\n        offset += 3;\n        ip += 2;\n        int i, j, k;\n        if ((token >> 3U) == 28) {\n          i = 1;\n          j = 2;\n          k = 3;\n        } else {\n          i = 0;\n          if ((token >> 3U) < 30) {\n            j = 1;\n            k = 2;\n          } else {\n            k = 3;\n            if ((token >> 3U) == 30) {\n              j = 1;\n            } else {\n              j = 2;\n            }\n          }\n        }\n        memcpy(&buffercpy[i * 4], ip - offset, 4);\n        memcpy(&buffercpy[j * 4], ip - offset + 4, 4);\n        memcpy(&buffercpy[k * 4], ip - offset + 8, 4);\n        for (int l = 0; l < 4; l++) {\n          if ((l != i) && (l != j) && (l != k)) {\n            memcpy(&buffercpy[l * 4], ip, 4);\n            ip += 4;\n            break;\n          }\n        }\n\n      } else if ((token >= 128) && (token <= 191)) { // rows pair match\n        buffercpy = local_buffer;\n        uint16_t offset = *((uint16_t *) ip);\n        offset += 3;\n        ip += 2;\n        int i, j;\n        if (token == 128) {\n          i = 2;\n          j = 3;\n        } else {\n          i = (token - 128) >> 5U;\n          j = ((token - 128) >> 3U) - (i << 2U);\n        }\n        memcpy(&buffercpy[i * 4], ip - offset, 4);\n        memcpy(&buffercpy[j * 4], ip - offset + 4, 4);\n        for (int k = 0; k < 4; k++) {\n          if ((k != i) && (k != j)) {\n            memcpy(&buffercpy[k * 4], ip, 4);\n            ip += 4;\n          }\n        }\n      } else if ((token >= 40) && (token <= 63)) {  // 2 rows pair matches\n        buffercpy = local_buffer;\n        uint16_t offset_1 = *((uint16_t *) ip);\n        offset_1 += 5;\n        ip += 2;\n        uint16_t offset_2 = *((uint16_t *) ip);\n        offset_2 += 5;\n        ip += 2;\n        int i, j, k, l, m;\n        i = 0;\n        j = ((token - 32) >> 3U);\n        l = -1;\n        for (k = 1; k < 4; k++) {\n          if ((k != i) && (k != j)) {\n            if (l == -1) {\n              l = k;\n            } else {\n              m = k;\n            }\n          }\n        }\n        memcpy(&buffercpy[i * 4], ip - offset_1, 4);\n        memcpy(&buffercpy[j * 4], ip - offset_1 + 4, 4);\n        memcpy(&buffercpy[l * 4], ip - offset_2, 4);\n        memcpy(&buffercpy[m * 4], ip - offset_2 + 4, 4);\n\n      } else {\n        BLOSC_TRACE_ERROR(\"Invalid token: %u at cell [%d, %d]\\n\", token, ii[0], ii[1]);\n        return BLOSC2_ERROR_FAILURE;\n      }\n      // fill op with buffercpy\n      uint32_t orig = ii[0] * 4 * blockshape[1] + ii[1] * 4;\n      for (uint32_t i = 0; i < 4; i++) {\n        if (i < padding[0]) {\n          ind = orig + i * blockshape[1];\n          memcpy(&op[ind], buffercpy, padding[1]);\n        }\n        buffercpy += padding[1];\n      }\n      if (ind > (uint32_t) output_len) {\n        BLOSC_TRACE_ERROR(\"Exceeding output size\");\n        return BLOSC2_ERROR_FAILURE;\n      }\n    }\n  }\n  ind += padding[1];\n\n  if (ind != (blockshape[0] * blockshape[1])) {\n    BLOSC_TRACE_ERROR(\"Output size is not compatible with embedded blockshape\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n  if (ind > (uint32_t) output_len) {\n    BLOSC_TRACE_ERROR(\"Exceeding output size\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n\n  return (int) ind;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 544,
    "critical_vars": [
      "output_len"
    ],
    "function": "ndlz4_decompress",
    "filename": "c-blosc2/CVE-2023-37186/CVE-2023-37186_CWE-476_d55bfcd6804699e1435dc3e233fd76c8a5d3f9e3_ndlz4x4.c.diff",
    "function_code": "int ndlz4_decompress(const uint8_t *input, int32_t input_len, uint8_t *output, int32_t output_len,\n                     uint8_t meta, blosc2_dparams *dparams) {\n  BLOSC_UNUSED_PARAM(meta);\n  BLOSC_UNUSED_PARAM(dparams);\n\n  uint8_t *ip = (uint8_t *) input;\n  uint8_t *ip_limit = ip + input_len;\n  uint8_t *op = (uint8_t *) output;\n  uint8_t ndim;\n  uint32_t blockshape[2];\n  uint32_t eshape[2];\n  uint8_t *buffercpy;\n  uint8_t local_buffer[16];\n  uint8_t token;\n  if (NDLZ_UNEXPECT_CONDITIONAL(input_len < 8)) {\n    return 0;\n  }\n\n  /* we start with literal copy */\n  ndim = *ip;\n  ip++;\n  if (ndim != 2) {\n    BLOSC_TRACE_ERROR(\"This codec only works for ndim = 2\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n  memcpy(&blockshape[0], ip, 4);\n  ip += 4;\n  memcpy(&blockshape[1], ip, 4);\n  ip += 4;\n  eshape[0] = ((blockshape[0] + 3) / 4) * 4;\n  eshape[1] = ((blockshape[1] + 3) / 4) * 4;\n\n  if (NDLZ_UNEXPECT_CONDITIONAL(output_len < (int32_t) (blockshape[0] * blockshape[1]))) {\n    return 0;\n  }\n  memset(op, 0, blockshape[0] * blockshape[1]);\n\n  uint32_t i_stop[2];\n  for (int i = 0; i < 2; ++i) {\n    i_stop[i] = eshape[i] / 4;\n  }\n\n  /* main loop */\n  uint32_t ii[2];\n  uint32_t padding[2] = {0};\n  uint32_t ind = 0;\n  uint8_t cell_aux[16];\n  for (ii[0] = 0; ii[0] < i_stop[0]; ++ii[0]) {\n    for (ii[1] = 0; ii[1] < i_stop[1]; ++ii[1]) {      // for each cell\n      if (NDLZ_UNEXPECT_CONDITIONAL(ip > ip_limit)) {\n        BLOSC_TRACE_ERROR(\"Exceeding input length\");\n        return BLOSC2_ERROR_FAILURE;\n      }\n      if (ii[0] == i_stop[0] - 1) {\n        padding[0] = (blockshape[0] % 4 == 0) ? 4 : blockshape[0] % 4;\n      } else {\n        padding[0] = 4;\n      }\n      if (ii[1] == i_stop[1] - 1) {\n        padding[1] = (blockshape[1] % 4 == 0) ? 4 : blockshape[1] % 4;\n      } else {\n        padding[1] = 4;\n      }\n      token = *ip++;\n      if (token == 0) {    // no match\n        buffercpy = ip;\n        ip += padding[0] * padding[1];\n      } else if (token == (uint8_t) ((1U << 7U) | (1U << 6U))) {  // cell match\n        uint16_t offset = *((uint16_t *) ip);\n        buffercpy = ip - offset - 1;\n        ip += 2;\n      } else if (token == (uint8_t) (1U << 6U)) { // whole cell of same element\n        buffercpy = cell_aux;\n        memset(buffercpy, *ip, 16);\n        ip++;\n      } else if (token >= 224) { // three rows match\n        buffercpy = local_buffer;\n        uint16_t offset = *((uint16_t *) ip);\n        offset += 3;\n        ip += 2;\n        int i, j, k;\n        if ((token >> 3U) == 28) {\n          i = 1;\n          j = 2;\n          k = 3;\n        } else {\n          i = 0;\n          if ((token >> 3U) < 30) {\n            j = 1;\n            k = 2;\n          } else {\n            k = 3;\n            if ((token >> 3U) == 30) {\n              j = 1;\n            } else {\n              j = 2;\n            }\n          }\n        }\n        memcpy(&buffercpy[i * 4], ip - offset, 4);\n        memcpy(&buffercpy[j * 4], ip - offset + 4, 4);\n        memcpy(&buffercpy[k * 4], ip - offset + 8, 4);\n        for (int l = 0; l < 4; l++) {\n          if ((l != i) && (l != j) && (l != k)) {\n            memcpy(&buffercpy[l * 4], ip, 4);\n            ip += 4;\n            break;\n          }\n        }\n\n      } else if ((token >= 128) && (token <= 191)) { // rows pair match\n        buffercpy = local_buffer;\n        uint16_t offset = *((uint16_t *) ip);\n        offset += 3;\n        ip += 2;\n        int i, j;\n        if (token == 128) {\n          i = 2;\n          j = 3;\n        } else {\n          i = (token - 128) >> 5U;\n          j = ((token - 128) >> 3U) - (i << 2U);\n        }\n        memcpy(&buffercpy[i * 4], ip - offset, 4);\n        memcpy(&buffercpy[j * 4], ip - offset + 4, 4);\n        for (int k = 0; k < 4; k++) {\n          if ((k != i) && (k != j)) {\n            memcpy(&buffercpy[k * 4], ip, 4);\n            ip += 4;\n          }\n        }\n      } else if ((token >= 40) && (token <= 63)) {  // 2 rows pair matches\n        buffercpy = local_buffer;\n        uint16_t offset_1 = *((uint16_t *) ip);\n        offset_1 += 5;\n        ip += 2;\n        uint16_t offset_2 = *((uint16_t *) ip);\n        offset_2 += 5;\n        ip += 2;\n        int i, j, k, l, m;\n        i = 0;\n        j = ((token - 32) >> 3U);\n        l = -1;\n        for (k = 1; k < 4; k++) {\n          if ((k != i) && (k != j)) {\n            if (l == -1) {\n              l = k;\n            } else {\n              m = k;\n            }\n          }\n        }\n        memcpy(&buffercpy[i * 4], ip - offset_1, 4);\n        memcpy(&buffercpy[j * 4], ip - offset_1 + 4, 4);\n        memcpy(&buffercpy[l * 4], ip - offset_2, 4);\n        memcpy(&buffercpy[m * 4], ip - offset_2 + 4, 4);\n\n      } else {\n        BLOSC_TRACE_ERROR(\"Invalid token: %u at cell [%d, %d]\\n\", token, ii[0], ii[1]);\n        return BLOSC2_ERROR_FAILURE;\n      }\n      // fill op with buffercpy\n      uint32_t orig = ii[0] * 4 * blockshape[1] + ii[1] * 4;\n      for (uint32_t i = 0; i < 4; i++) {\n        if (i < padding[0]) {\n          ind = orig + i * blockshape[1];\n          memcpy(&op[ind], buffercpy, padding[1]);\n        }\n        buffercpy += padding[1];\n      }\n      if (ind > (uint32_t) output_len) {\n        BLOSC_TRACE_ERROR(\"Exceeding output size\");\n        return BLOSC2_ERROR_FAILURE;\n      }\n    }\n  }\n  ind += padding[1];\n\n  if (ind != (blockshape[0] * blockshape[1])) {\n    BLOSC_TRACE_ERROR(\"Output size is not compatible with embedded blockshape\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n  if (ind > (uint32_t) output_len) {\n    BLOSC_TRACE_ERROR(\"Exceeding output size\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n\n  return (int) ind;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 435,
    "critical_vars": [
      "input"
    ],
    "function": "ndlz8_decompress",
    "filename": "c-blosc2/CVE-2023-37186/CVE-2023-37186_CWE-476_d55bfcd6804699e1435dc3e233fd76c8a5d3f9e3_ndlz8x8.c.diff",
    "function_code": "int ndlz8_decompress(const uint8_t *input, int32_t input_len, uint8_t *output, int32_t output_len,\n                     uint8_t meta, blosc2_dparams *dparams) {\n  BLOSC_UNUSED_PARAM(meta);\n  BLOSC_UNUSED_PARAM(dparams);\n  BLOSC_ERROR_NULL(input, BLOSC2_ERROR_NULL_POINTER);\n  BLOSC_ERROR_NULL(output, BLOSC2_ERROR_NULL_POINTER);\n\n  const int cell_shape = 8;\n  const int cell_size = 64;\n  uint8_t *ip = (uint8_t *) input;\n  uint8_t *ip_limit = ip + input_len;\n  uint8_t *op = (uint8_t *) output;\n  uint8_t ndim;\n  int32_t blockshape[2];\n  int32_t eshape[2];\n  uint8_t *buffercpy;\n  uint8_t token;\n  if (NDLZ_UNEXPECT_CONDITIONAL(input_len < 8)) {\n    return 0;\n  }\n\n  /* we start with literal copy */\n  ndim = *ip;\n  ip++;\n  if (ndim != 2) {\n    BLOSC_TRACE_ERROR(\"This codec only works for ndim = 2\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n  memcpy(&blockshape[0], ip, 4);\n  ip += 4;\n  memcpy(&blockshape[1], ip, 4);\n  ip += 4;\n  eshape[0] = ((blockshape[0] + 7) / cell_shape) * cell_shape;\n  eshape[1] = ((blockshape[1] + 7) / cell_shape) * cell_shape;\n  if (NDLZ_UNEXPECT_CONDITIONAL((int64_t)output_len < (int64_t)blockshape[0] * (int64_t)blockshape[1])) {\n    return 0;\n  }\n  memset(op, 0, blockshape[0] * blockshape[1]);\n\n  int32_t i_stop[2];\n  for (int i = 0; i < 2; ++i) {\n    i_stop[i] = eshape[i] / cell_shape;\n  }\n\n  /* main loop */\n  int32_t ii[2];\n  int32_t padding[2] = {0};\n  int32_t ind = 0;\n  uint8_t *local_buffer = malloc(cell_size);\n  uint8_t *cell_aux = malloc(cell_size);\n  for (ii[0] = 0; ii[0] < i_stop[0]; ++ii[0]) {\n    for (ii[1] = 0; ii[1] < i_stop[1]; ++ii[1]) {      // for each cell\n      if (NDLZ_UNEXPECT_CONDITIONAL(ip > ip_limit)) {\n        free(local_buffer);\n        free(cell_aux);\n        BLOSC_TRACE_ERROR(\"Exceeding input length\");\n        return BLOSC2_ERROR_FAILURE;\n      }\n      if (ii[0] == i_stop[0] - 1) {\n        padding[0] = (blockshape[0] % cell_shape == 0) ? cell_shape : blockshape[0] % cell_shape;\n      } else {\n        padding[0] = cell_shape;\n      }\n      if (ii[1] == i_stop[1] - 1) {\n        padding[1] = (blockshape[1] % cell_shape == 0) ? cell_shape : blockshape[1] % cell_shape;\n      } else {\n        padding[1] = cell_shape;\n      }\n      token = *ip++;\n      uint8_t match_type = (token >> 3U);\n      if (token == 0) {    // no match\n        buffercpy = ip;\n        ip += padding[0] * padding[1];\n      } else if (token == (uint8_t) ((1U << 7U) | (1U << 6U))) {  // cell match\n        uint16_t offset = *((uint16_t *) ip);\n        buffercpy = ip - offset - 1;\n        ip += 2;\n      } else if (token == (uint8_t) (1U << 6U)) { // whole cell of same element\n        buffercpy = cell_aux;\n        memset(buffercpy, *ip, cell_size);\n        ip++;\n      } else if (match_type == 21) {    // triple match\n        buffercpy = local_buffer;\n        int row = (int) (token & 7);\n        uint16_t offset = *((uint16_t *) ip);\n        ip += 2;\n        for (int l = 0; l < 3; l++) {\n          memcpy(&buffercpy[(row + l) * cell_shape],\n                 ip - sizeof(token) - sizeof(offset) - offset + l * cell_shape, cell_shape);\n        }\n        for (int l = 0; l < cell_shape; l++) {\n          if ((l < row) || (l > row + 2)) {\n            memcpy(&buffercpy[l * cell_shape], ip, cell_shape);\n            ip += cell_shape;\n          }\n        }\n      } else if (match_type == 17) {    // pair match\n        buffercpy = local_buffer;\n        int row = (int) (token & 7);\n        uint16_t offset = *((uint16_t *) ip);\n        ip += 2;\n        for (int l = 0; l < 2; l++) {\n          memcpy(&buffercpy[(row + l) * cell_shape],\n                 ip - sizeof(token) - sizeof(offset) - offset + l * cell_shape, cell_shape);\n        }\n        for (int l = 0; l < cell_shape; l++) {\n          if ((l < row) || (l > row + 1)) {\n            memcpy(&buffercpy[l * cell_shape], ip, cell_shape);\n            ip += cell_shape;\n          }\n        }\n      } else {\n        free(local_buffer);\n        free(cell_aux);\n        BLOSC_TRACE_ERROR(\"Invalid token: %u at cell [%d, %d]\\n\", token, ii[0], ii[1]);\n        return BLOSC2_ERROR_FAILURE;\n      }\n\n      int32_t orig = ii[0] * cell_shape * blockshape[1] + ii[1] * cell_shape;\n      for (int32_t i = 0; i < (int32_t) cell_shape; i++) {\n        if (i < padding[0]) {\n          ind = orig + i * blockshape[1];\n          memcpy(&op[ind], buffercpy, padding[1]);\n        }\n        buffercpy += padding[1];\n      }\n      if (ind > output_len) {\n        free(local_buffer);\n        free(cell_aux);\n        BLOSC_TRACE_ERROR(\"Exceeding output size\");\n        return BLOSC2_ERROR_FAILURE;\n      }\n    }\n  }\n  ind += padding[1];\n\n  free(cell_aux);\n  free(local_buffer);\n\n  if (ind != (blockshape[0] * blockshape[1])) {\n    BLOSC_TRACE_ERROR(\"Output size is not compatible with embedded blockshape\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n  if (ind > output_len) {\n    BLOSC_TRACE_ERROR(\"Exceeding output size\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n\n  return (int) ind;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 462,
    "critical_vars": [
      "output_len"
    ],
    "function": "ndlz8_decompress",
    "filename": "c-blosc2/CVE-2023-37186/CVE-2023-37186_CWE-476_d55bfcd6804699e1435dc3e233fd76c8a5d3f9e3_ndlz8x8.c.diff",
    "function_code": "int ndlz8_decompress(const uint8_t *input, int32_t input_len, uint8_t *output, int32_t output_len,\n                     uint8_t meta, blosc2_dparams *dparams) {\n  BLOSC_UNUSED_PARAM(meta);\n  BLOSC_UNUSED_PARAM(dparams);\n\n  const int cell_shape = 8;\n  const int cell_size = 64;\n  uint8_t *ip = (uint8_t *) input;\n  uint8_t *ip_limit = ip + input_len;\n  uint8_t *op = (uint8_t *) output;\n  uint8_t ndim;\n  int32_t blockshape[2];\n  int32_t eshape[2];\n  uint8_t *buffercpy;\n  uint8_t token;\n  if (NDLZ_UNEXPECT_CONDITIONAL(input_len < 8)) {\n    return 0;\n  }\n\n  /* we start with literal copy */\n  ndim = *ip;\n  ip++;\n  if (ndim != 2) {\n    BLOSC_TRACE_ERROR(\"This codec only works for ndim = 2\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n  memcpy(&blockshape[0], ip, 4);\n  ip += 4;\n  memcpy(&blockshape[1], ip, 4);\n  ip += 4;\n  eshape[0] = ((blockshape[0] + 7) / cell_shape) * cell_shape;\n  eshape[1] = ((blockshape[1] + 7) / cell_shape) * cell_shape;\n\n  if (NDLZ_UNEXPECT_CONDITIONAL(output_len < blockshape[0] * blockshape[1])) {\n    return 0;\n  }\n  memset(op, 0, blockshape[0] * blockshape[1]);\n\n  int32_t i_stop[2];\n  for (int i = 0; i < 2; ++i) {\n    i_stop[i] = eshape[i] / cell_shape;\n  }\n\n  /* main loop */\n  int32_t ii[2];\n  int32_t padding[2] = {0};\n  int32_t ind = 0;\n  uint8_t *local_buffer = malloc(cell_size);\n  uint8_t *cell_aux = malloc(cell_size);\n  for (ii[0] = 0; ii[0] < i_stop[0]; ++ii[0]) {\n    for (ii[1] = 0; ii[1] < i_stop[1]; ++ii[1]) {      // for each cell\n      if (NDLZ_UNEXPECT_CONDITIONAL(ip > ip_limit)) {\n        free(local_buffer);\n        free(cell_aux);\n        BLOSC_TRACE_ERROR(\"Exceeding input length\");\n        return BLOSC2_ERROR_FAILURE;\n      }\n      if (ii[0] == i_stop[0] - 1) {\n        padding[0] = (blockshape[0] % cell_shape == 0) ? cell_shape : blockshape[0] % cell_shape;\n      } else {\n        padding[0] = cell_shape;\n      }\n      if (ii[1] == i_stop[1] - 1) {\n        padding[1] = (blockshape[1] % cell_shape == 0) ? cell_shape : blockshape[1] % cell_shape;\n      } else {\n        padding[1] = cell_shape;\n      }\n      token = *ip++;\n      uint8_t match_type = (token >> 3U);\n      if (token == 0) {    // no match\n        buffercpy = ip;\n        ip += padding[0] * padding[1];\n      } else if (token == (uint8_t) ((1U << 7U) | (1U << 6U))) {  // cell match\n        uint16_t offset = *((uint16_t *) ip);\n        buffercpy = ip - offset - 1;\n        ip += 2;\n      } else if (token == (uint8_t) (1U << 6U)) { // whole cell of same element\n        buffercpy = cell_aux;\n        memset(buffercpy, *ip, cell_size);\n        ip++;\n      } else if (match_type == 21) {    // triple match\n        buffercpy = local_buffer;\n        int row = (int) (token & 7);\n        uint16_t offset = *((uint16_t *) ip);\n        ip += 2;\n        for (int l = 0; l < 3; l++) {\n          memcpy(&buffercpy[(row + l) * cell_shape],\n                 ip - sizeof(token) - sizeof(offset) - offset + l * cell_shape, cell_shape);\n        }\n        for (int l = 0; l < cell_shape; l++) {\n          if ((l < row) || (l > row + 2)) {\n            memcpy(&buffercpy[l * cell_shape], ip, cell_shape);\n            ip += cell_shape;\n          }\n        }\n      } else if (match_type == 17) {    // pair match\n        buffercpy = local_buffer;\n        int row = (int) (token & 7);\n        uint16_t offset = *((uint16_t *) ip);\n        ip += 2;\n        for (int l = 0; l < 2; l++) {\n          memcpy(&buffercpy[(row + l) * cell_shape],\n                 ip - sizeof(token) - sizeof(offset) - offset + l * cell_shape, cell_shape);\n        }\n        for (int l = 0; l < cell_shape; l++) {\n          if ((l < row) || (l > row + 1)) {\n            memcpy(&buffercpy[l * cell_shape], ip, cell_shape);\n            ip += cell_shape;\n          }\n        }\n      } else {\n        free(local_buffer);\n        free(cell_aux);\n        BLOSC_TRACE_ERROR(\"Invalid token: %u at cell [%d, %d]\\n\", token, ii[0], ii[1]);\n        return BLOSC2_ERROR_FAILURE;\n      }\n\n      int32_t orig = ii[0] * cell_shape * blockshape[1] + ii[1] * cell_shape;\n      for (int32_t i = 0; i < (int32_t) cell_shape; i++) {\n        if (i < padding[0]) {\n          ind = orig + i * blockshape[1];\n          memcpy(&op[ind], buffercpy, padding[1]);\n        }\n        buffercpy += padding[1];\n      }\n      if (ind > output_len) {\n        free(local_buffer);\n        free(cell_aux);\n        BLOSC_TRACE_ERROR(\"Exceeding output size\");\n        return BLOSC2_ERROR_FAILURE;\n      }\n    }\n  }\n  ind += padding[1];\n\n  free(cell_aux);\n  free(local_buffer);\n\n  if (ind != (blockshape[0] * blockshape[1])) {\n    BLOSC_TRACE_ERROR(\"Output size is not compatible with embedded blockshape\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n  if (ind > output_len) {\n    BLOSC_TRACE_ERROR(\"Exceeding output size\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n\n  return (int) ind;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 29,
    "critical_vars": [
      "cparams->schunk"
    ],
    "function": "zfp_acc_compress",
    "filename": "c-blosc2/CVE-2023-37187/CVE-2023-37187_CWE-476_425e8a9a59d49378d57e2116b6c9b0190a5986f5_blosc2-zfp.c.diff",
    "function_code": "int zfp_acc_compress(const uint8_t *input, int32_t input_len, uint8_t *output,\n                     int32_t output_len, uint8_t meta, blosc2_cparams *cparams, const void *chunk) {\n  BLOSC_UNUSED_PARAM(chunk);\n  ZFP_ERROR_NULL(input);\n  ZFP_ERROR_NULL(output);\n  ZFP_ERROR_NULL(cparams);\n  ZFP_ERROR_NULL(cparams->schunk);\n\n  double tol = (int8_t) meta;\n  int8_t ndim;\n  int64_t *shape = malloc(8 * sizeof(int64_t));\n  int32_t *chunkshape = malloc(8 * sizeof(int32_t));\n  int32_t *blockshape = malloc(8 * sizeof(int32_t));\n  uint8_t *smeta;\n  int32_t smeta_len;\n  if (blosc2_meta_get(cparams->schunk, \"b2nd\", &smeta, &smeta_len) < 0) {\n    free(shape);\n    free(chunkshape);\n    free(blockshape);\n    BLOSC_TRACE_ERROR(\"b2nd layer not found!\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n  deserialize_meta(smeta, smeta_len, &ndim, shape, chunkshape, blockshape);\n  free(smeta);\n\n  for(int i = 0; i < ndim; i++) {\n    if (blockshape[i] < 4) {\n      BLOSC_TRACE_ERROR(\"ZFP does not support blocks smaller than cells (4x...x4\");\n      return BLOSC2_ERROR_FAILURE;\n    }\n  }\n\n  zfp_type type;     /* array scalar type */\n  zfp_field *field;  /* array meta data */\n  zfp_stream *zfp;   /* stream containing the real output buffer */\n  zfp_stream *zfp_aux;   /* auxiliary compressed stream */\n  bitstream *stream; /* bit stream to write to or read from */\n  bitstream *stream_aux; /* auxiliary bit stream to write to or read from */\n  size_t zfpsize;    /* byte size of compressed stream */\n  double tolerance = pow(10, tol);\n\n  int32_t typesize = cparams->typesize;\n\n  switch (typesize) {\n    case sizeof(float):\n      type = zfp_type_float;\n      break;\n    case sizeof(double):\n      type = zfp_type_double;\n      break;\n    default:\n      free(shape);\n      free(chunkshape);\n      free(blockshape);\n      BLOSC_TRACE_ERROR(\"ZFP is not available for typesize: %d\", typesize);\n      return BLOSC2_ERROR_FAILURE;\n  }\n\n  zfp = zfp_stream_open(NULL);\n  zfp_stream_set_accuracy(zfp, tolerance);\n  stream = stream_open(output, output_len);\n  zfp_stream_set_bit_stream(zfp, stream);\n  zfp_stream_rewind(zfp);\n\n  switch (ndim) {\n    case 1:\n      field = zfp_field_1d((void *) input, type, blockshape[0]);\n      break;\n    case 2:\n      field = zfp_field_2d((void *) input, type, blockshape[1], blockshape[0]);\n      break;\n    case 3:\n      field = zfp_field_3d((void *) input, type, blockshape[2], blockshape[1], blockshape[0]);\n      break;\n    case 4:\n      field = zfp_field_4d((void *) input, type, blockshape[3], blockshape[2], blockshape[1], blockshape[0]);\n      break;\n    default:\n      free(shape);\n      free(chunkshape);\n      free(blockshape);\n      BLOSC_TRACE_ERROR(\"ZFP is not available for ndims: %d\", ndim);\n      return BLOSC2_ERROR_FAILURE;\n  }\n\n  int zfp_maxout = (int) zfp_stream_maximum_size(zfp, field);\n  zfp_stream_close(zfp);\n  stream_close(stream);\n  uint8_t *aux_out = malloc(zfp_maxout);\n  zfp_aux = zfp_stream_open(NULL);\n  zfp_stream_set_accuracy(zfp_aux, tolerance);\n  stream_aux = stream_open(aux_out, zfp_maxout);\n  zfp_stream_set_bit_stream(zfp_aux, stream_aux);\n  zfp_stream_rewind(zfp_aux);\n\n  zfpsize = zfp_compress(zfp_aux, field);\n\n  /* clean up */\n  zfp_field_free(field);\n  zfp_stream_close(zfp_aux);\n  stream_close(stream_aux);\n  free(shape);\n  free(chunkshape);\n  free(blockshape);\n\n  if (zfpsize == 0) {\n    BLOSC_TRACE_ERROR(\"\\n ZFP: Compression failed\\n\");\n    free(aux_out);\n    return (int) zfpsize;\n  }\n  if ((int32_t) zfpsize >= input_len) {\n    BLOSC_TRACE_ERROR(\"\\n ZFP: Compressed data is bigger than input! \\n\");\n    free(aux_out);\n    return 0;\n  }\n\n  memcpy(output, aux_out, zfpsize);\n  free(aux_out);\n\n  return (int) zfpsize;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 150,
    "critical_vars": [
      "dparams->schunk"
    ],
    "function": "zfp_acc_decompress",
    "filename": "c-blosc2/CVE-2023-37187/CVE-2023-37187_CWE-476_425e8a9a59d49378d57e2116b6c9b0190a5986f5_blosc2-zfp.c.diff",
    "function_code": "int zfp_acc_decompress(const uint8_t *input, int32_t input_len, uint8_t *output,\n                       int32_t output_len, uint8_t meta, blosc2_dparams *dparams, const void *chunk) {\n  ZFP_ERROR_NULL(input);\n  ZFP_ERROR_NULL(output);\n  ZFP_ERROR_NULL(dparams);\n  ZFP_ERROR_NULL(dparams->schunk);\n  BLOSC_UNUSED_PARAM(chunk);\n\n  blosc2_schunk *sc = dparams->schunk;\n  int32_t typesize = sc->typesize;\n\n  double tol = (int8_t) meta;\n  int8_t ndim;\n  int64_t *shape = malloc(8 * sizeof(int64_t));\n  int32_t *chunkshape = malloc(8 * sizeof(int32_t));\n  int32_t *blockshape = malloc(8 * sizeof(int32_t));\n  uint8_t *smeta;\n  int32_t smeta_len;\n  if (blosc2_meta_get(sc, \"b2nd\", &smeta, &smeta_len) < 0) {\n    BLOSC_TRACE_ERROR(\"Cannot access b2nd meta info\");\n    free(shape);\n    free(chunkshape);\n    free(blockshape);\n    return BLOSC2_ERROR_FAILURE;\n  }\n  deserialize_meta(smeta, smeta_len, &ndim, shape, chunkshape, blockshape);\n  free(smeta);\n\n  zfp_type type;     /* array scalar type */\n  zfp_field *field;  /* array meta data */\n  zfp_stream *zfp;   /* compressed stream */\n  bitstream *stream; /* bit stream to write to or read from */\n  size_t zfpsize;    /* byte size of compressed stream */\n  double tolerance = pow(10, tol);\n\n  switch (typesize) {\n    case sizeof(float):\n      type = zfp_type_float;\n      break;\n    case sizeof(double):\n      type = zfp_type_double;\n      break;\n    default:\n      free(shape);\n      free(chunkshape);\n      free(blockshape);\n      BLOSC_TRACE_ERROR(\"ZFP is not available for typesize: %d\", typesize);\n      return BLOSC2_ERROR_FAILURE;\n  }\n\n  zfp = zfp_stream_open(NULL);\n  zfp_stream_set_accuracy(zfp, tolerance);\n  stream = stream_open((void *) input, input_len);\n  zfp_stream_set_bit_stream(zfp, stream);\n  zfp_stream_rewind(zfp);\n\n  switch (ndim) {\n    case 1:\n      field = zfp_field_1d((void *) output, type, blockshape[0]);\n      break;\n    case 2:\n      field = zfp_field_2d((void *) output, type, blockshape[1], blockshape[0]);\n      break;\n    case 3:\n      field = zfp_field_3d((void *) output, type, blockshape[2], blockshape[1], blockshape[0]);\n      break;\n    case 4:\n      field = zfp_field_4d((void *) output, type, blockshape[3], blockshape[2], blockshape[1], blockshape[0]);\n      break;\n    default:\n      free(shape);\n      free(chunkshape);\n      free(blockshape);\n      BLOSC_TRACE_ERROR(\"ZFP is not available for ndims: %d\", ndim);\n      return BLOSC2_ERROR_FAILURE;\n  }\n\n  zfpsize = zfp_decompress(zfp, field);\n\n  /* clean up */\n  zfp_field_free(field);\n  zfp_stream_close(zfp);\n  stream_close(stream);\n  free(shape);\n  free(chunkshape);\n  free(blockshape);\n\n  if (zfpsize == 0) {\n    BLOSC_TRACE_ERROR(\"\\n ZFP: Decompression failed\\n\");\n    return (int) zfpsize;\n  }\n\n  return (int) output_len;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 246,
    "critical_vars": [
      "cparams->schunk"
    ],
    "function": "zfp_prec_compress",
    "filename": "c-blosc2/CVE-2023-37187/CVE-2023-37187_CWE-476_425e8a9a59d49378d57e2116b6c9b0190a5986f5_blosc2-zfp.c.diff",
    "function_code": "int zfp_prec_compress(const uint8_t *input, int32_t input_len, uint8_t *output,\n                      int32_t output_len, uint8_t meta, blosc2_cparams *cparams, const void *chunk) {\n  BLOSC_UNUSED_PARAM(chunk);\n  ZFP_ERROR_NULL(input);\n  ZFP_ERROR_NULL(output);\n  ZFP_ERROR_NULL(cparams);\n  ZFP_ERROR_NULL(cparams->schunk);\n\n  int8_t ndim;\n  int64_t *shape = malloc(8 * sizeof(int64_t));\n  int32_t *chunkshape = malloc(8 * sizeof(int32_t));\n  int32_t *blockshape = malloc(8 * sizeof(int32_t));\n  uint8_t *smeta;\n  int32_t smeta_len;\n  if (blosc2_meta_get(cparams->schunk, \"b2nd\", &smeta, &smeta_len) < 0) {\n    free(shape);\n    free(chunkshape);\n    free(blockshape);\n    BLOSC_TRACE_ERROR(\"b2nd layer not found!\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n  deserialize_meta(smeta, smeta_len, &ndim, shape, chunkshape, blockshape);\n  free(smeta);\n\n  for(int i = 0; i < ndim; i++) {\n    if (blockshape[i] < 4) {\n      BLOSC_TRACE_ERROR(\"ZFP does not support blocks smaller than cells (4x...x4\");\n      return BLOSC2_ERROR_FAILURE;\n    }\n  }\n\n  zfp_type type;     /* array scalar type */\n  zfp_field *field;  /* array meta data */\n  zfp_stream *zfp;   /* stream containing the real output buffer */\n  zfp_stream *zfp_aux;   /* auxiliary compressed stream */\n  bitstream *stream; /* bit stream to write to or read from */\n  bitstream *stream_aux; /* auxiliary bit stream to write to or read from */\n  size_t zfpsize;    /* byte size of compressed stream */\n\n  uint prec;\n  switch (ndim) {\n    case 1:\n      prec = meta + 5;\n      break;\n    case 2:\n      prec = meta + 7;\n      break;\n    case 3:\n      prec = meta + 9;\n      break;\n    case 4:\n      prec = meta + 11;\n      break;\n    default:\n      free(shape);\n      free(chunkshape);\n      free(blockshape);\n      BLOSC_TRACE_ERROR(\"ZFP is not available for ndims: %d\", ndim);\n      return BLOSC2_ERROR_FAILURE;\n  }\n\n  if (prec > ZFP_MAX_PREC) {\n    BLOSC_TRACE_ERROR(\"Max precision for this codecs is %d\", ZFP_MAX_PREC);\n    prec = ZFP_MAX_PREC;\n  }\n\n  int32_t typesize = cparams->typesize;\n  switch (typesize) {\n    case sizeof(float):\n      type = zfp_type_float;\n      break;\n    case sizeof(double):\n      type = zfp_type_double;\n      break;\n    default:\n      free(shape);\n      free(chunkshape);\n      free(blockshape);\n      BLOSC_TRACE_ERROR(\"ZFP is not available for typesize: %d\", typesize);\n      return BLOSC2_ERROR_FAILURE;\n  }\n\n  zfp = zfp_stream_open(NULL);\n  zfp_stream_set_precision(zfp, prec);\n  stream = stream_open(output, output_len);\n  zfp_stream_set_bit_stream(zfp, stream);\n  zfp_stream_rewind(zfp);\n\n  switch (ndim) {\n    case 1:\n      field = zfp_field_1d((void *) input, type, blockshape[0]);\n      break;\n    case 2:\n      field = zfp_field_2d((void *) input, type, blockshape[1], blockshape[0]);\n      break;\n    case 3:\n      field = zfp_field_3d((void *) input, type, blockshape[2], blockshape[1], blockshape[0]);\n      break;\n    case 4:\n      field = zfp_field_4d((void *) input, type, blockshape[3], blockshape[2], blockshape[1], blockshape[0]);\n      break;\n    default:\n      free(shape);\n      free(chunkshape);\n      free(blockshape);\n      BLOSC_TRACE_ERROR(\"ZFP is not available for ndims: %d\", ndim);\n      return BLOSC2_ERROR_FAILURE;\n  }\n\n  int zfp_maxout = (int) zfp_stream_maximum_size(zfp, field);\n  zfp_stream_close(zfp);\n  stream_close(stream);\n  uint8_t *aux_out = malloc(zfp_maxout);\n  zfp_aux = zfp_stream_open(NULL);\n  zfp_stream_set_precision(zfp_aux, prec);\n  stream_aux = stream_open(aux_out, zfp_maxout);\n  zfp_stream_set_bit_stream(zfp_aux, stream_aux);\n  zfp_stream_rewind(zfp_aux);\n\n  zfpsize = zfp_compress(zfp_aux, field);\n\n  /* clean up */\n  zfp_field_free(field);\n  zfp_stream_close(zfp_aux);\n  stream_close(stream_aux);\n  free(shape);\n  free(chunkshape);\n  free(blockshape);\n\n  if (zfpsize == 0) {\n    BLOSC_TRACE_ERROR(\"\\n ZFP: Compression failed\\n\");\n    free(aux_out);\n    return (int) zfpsize;\n  }\n  if ((int32_t) zfpsize >= input_len) {\n    BLOSC_TRACE_ERROR(\"\\n ZFP: Compressed data is bigger than input! \\n\");\n    free(aux_out);\n    return 0;\n  }\n\n  memcpy(output, aux_out, zfpsize);\n  free(aux_out);\n\n  return (int) zfpsize;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 391,
    "critical_vars": [
      "dparams->schunk"
    ],
    "function": "zfp_prec_decompress",
    "filename": "c-blosc2/CVE-2023-37187/CVE-2023-37187_CWE-476_425e8a9a59d49378d57e2116b6c9b0190a5986f5_blosc2-zfp.c.diff",
    "function_code": "int zfp_prec_decompress(const uint8_t *input, int32_t input_len, uint8_t *output,\n                        int32_t output_len, uint8_t meta, blosc2_dparams *dparams, const void *chunk) {\n  ZFP_ERROR_NULL(input);\n  ZFP_ERROR_NULL(output);\n  ZFP_ERROR_NULL(dparams);\n  ZFP_ERROR_NULL(dparams->schunk);\n  BLOSC_UNUSED_PARAM(chunk);\n\n  blosc2_schunk *sc = dparams->schunk;\n  int32_t typesize = sc->typesize;\n  int8_t ndim;\n  int64_t *shape = malloc(8 * sizeof(int64_t));\n  int32_t *chunkshape = malloc(8 * sizeof(int32_t));\n  int32_t *blockshape = malloc(8 * sizeof(int32_t));\n  uint8_t *smeta;\n  int32_t smeta_len;\n  if (blosc2_meta_get(sc, \"b2nd\", &smeta, &smeta_len) < 0) {\n    BLOSC_TRACE_ERROR(\"Cannot access b2nd meta info\");\n    free(shape);\n    free(chunkshape);\n    free(blockshape);\n    return BLOSC2_ERROR_FAILURE;\n  }\n  deserialize_meta(smeta, smeta_len, &ndim, shape, chunkshape, blockshape);\n  free(smeta);\n\n  zfp_type type;     /* array scalar type */\n  zfp_field *field;  /* array meta data */\n  zfp_stream *zfp;   /* compressed stream */\n  bitstream *stream; /* bit stream to write to or read from */\n  size_t zfpsize;    /* byte size of compressed stream */\n\n  uint prec;\n  switch (ndim) {\n    case 1:\n      prec = meta + 5;\n      break;\n    case 2:\n      prec = meta + 7;\n      break;\n    case 3:\n      prec = meta + 9;\n      break;\n    case 4:\n      prec = meta + 11;\n      break;\n    default:\n      free(shape);\n      free(chunkshape);\n      free(blockshape);\n      BLOSC_TRACE_ERROR(\"ZFP is not available for ndims: %d\", ndim);\n      return BLOSC2_ERROR_FAILURE;\n  }\n\n  if (prec > ZFP_MAX_PREC) {\n    BLOSC_TRACE_ERROR(\"Max precision for this codecs is %d\", ZFP_MAX_PREC);\n    prec = ZFP_MAX_PREC;\n  }\n\n  switch (typesize) {\n    case sizeof(float):\n      type = zfp_type_float;\n      break;\n    case sizeof(double):\n      type = zfp_type_double;\n      break;\n    default:\n      free(shape);\n      free(chunkshape);\n      free(blockshape);\n      BLOSC_TRACE_ERROR(\"ZFP is not available for typesize: %d\", typesize);\n      return BLOSC2_ERROR_FAILURE;\n  }\n\n  zfp = zfp_stream_open(NULL);\n  zfp_stream_set_precision(zfp, prec);\n  stream = stream_open((void *) input, input_len);\n  zfp_stream_set_bit_stream(zfp, stream);\n  zfp_stream_rewind(zfp);\n\n  switch (ndim) {\n    case 1:\n      field = zfp_field_1d((void *) output, type, blockshape[0]);\n      break;\n    case 2:\n      field = zfp_field_2d((void *) output, type, blockshape[1], blockshape[0]);\n      break;\n    case 3:\n      field = zfp_field_3d((void *) output, type, blockshape[2], blockshape[1], blockshape[0]);\n      break;\n    case 4:\n      field = zfp_field_4d((void *) output, type, blockshape[3], blockshape[2], blockshape[1], blockshape[0]);\n      break;\n    default:\n      free(shape);\n      free(chunkshape);\n      free(blockshape);\n      BLOSC_TRACE_ERROR(\"ZFP is not available for ndims: %d\", ndim);\n      return BLOSC2_ERROR_FAILURE;\n  }\n\n  zfpsize = zfp_decompress(zfp, field);\n\n  /* clean up */\n  zfp_field_free(field);\n  zfp_stream_close(zfp);\n  stream_close(stream);\n  free(shape);\n  free(chunkshape);\n  free(blockshape);\n\n  if (zfpsize == 0) {\n    BLOSC_TRACE_ERROR(\"\\n ZFP: Decompression failed\\n\");\n    return (int) zfpsize;\n  }\n\n  return (int) output_len;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 511,
    "critical_vars": [
      "cparams->schunk"
    ],
    "function": "zfp_rate_compress",
    "filename": "c-blosc2/CVE-2023-37187/CVE-2023-37187_CWE-476_425e8a9a59d49378d57e2116b6c9b0190a5986f5_blosc2-zfp.c.diff",
    "function_code": "int zfp_rate_compress(const uint8_t *input, int32_t input_len, uint8_t *output,\n                      int32_t output_len, uint8_t meta, blosc2_cparams *cparams, const void *chunk) {\n  BLOSC_UNUSED_PARAM(chunk);\n  ZFP_ERROR_NULL(input);\n  ZFP_ERROR_NULL(output);\n  ZFP_ERROR_NULL(cparams);\n  ZFP_ERROR_NULL(cparams->schunk);\n\n  double ratio = (double) meta / 100.0;\n  int8_t ndim;\n  int64_t *shape = malloc(8 * sizeof(int64_t));\n  int32_t *chunkshape = malloc(8 * sizeof(int32_t));\n  int32_t *blockshape = malloc(8 * sizeof(int32_t));\n  uint8_t *smeta;\n  int32_t smeta_len;\n  if (blosc2_meta_get(cparams->schunk, \"b2nd\", &smeta, &smeta_len) < 0) {\n    free(shape);\n    free(chunkshape);\n    free(blockshape);\n    BLOSC_TRACE_ERROR(\"b2nd layer not found!\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n  deserialize_meta(smeta, smeta_len, &ndim, shape, chunkshape, blockshape);\n  free(smeta);\n\n  for(int i = 0; i < ndim; i++) {\n    if (blockshape[i] < 4) {\n      BLOSC_TRACE_ERROR(\"ZFP does not support blocks smaller than cells (4x...x4\");\n      return BLOSC2_ERROR_FAILURE;\n    }\n  }\n\n  zfp_type type;     /* array scalar type */\n  zfp_field *field;  /* array meta data */\n  zfp_stream *zfp;   /* stream containing the real output buffer */\n  zfp_stream *zfp_aux;   /* auxiliary compressed stream */\n  bitstream *stream; /* bit stream to write to or read from */\n  bitstream *stream_aux; /* auxiliary bit stream to write to or read from */\n  size_t zfpsize;    /* byte size of compressed stream */\n\n  int32_t typesize = cparams->typesize;\n\n  switch (typesize) {\n    case sizeof(float):\n      type = zfp_type_float;\n      break;\n    case sizeof(double):\n      type = zfp_type_double;\n      break;\n    default:\n      BLOSC_TRACE_ERROR(\"ZFP is not available for typesize: %d\", typesize);\n      return BLOSC2_ERROR_FAILURE;\n  }\n  double rate = ratio * typesize * 8;     // convert from output size / input size to output bits per input value\n  uint cellsize = 1u << (2 * ndim);\n  double min_rate;\n  if (type == zfp_type_float) {\n    min_rate = (double) (1 + 8u) / cellsize;\n    if (rate < min_rate) {\n      BLOSC_TRACE_ERROR(\"ZFP minimum rate for this item type is %f. Compression will be done using this one.\\n\",\n                        min_rate);\n    }\n  }\n  else {\n    min_rate = (double) (1 + 11u) / cellsize;\n    if (rate < min_rate) {\n      BLOSC_TRACE_ERROR(\"ZFP minimum rate for this item type is %f. Compression will be done using this one.\\n\",\n                        min_rate);\n    }\n  }\n  zfp = zfp_stream_open(NULL);\n  stream = stream_open(output, output_len);\n  zfp_stream_set_bit_stream(zfp, stream);\n  zfp_stream_rewind(zfp);\n\n  switch (ndim) {\n    case 1:\n      field = zfp_field_1d((void *) input, type, blockshape[0]);\n      break;\n    case 2:\n      field = zfp_field_2d((void *) input, type, blockshape[1], blockshape[0]);\n      break;\n    case 3:\n      field = zfp_field_3d((void *) input, type, blockshape[2], blockshape[1], blockshape[0]);\n      break;\n    case 4:\n      field = zfp_field_4d((void *) input, type, blockshape[3], blockshape[2], blockshape[1], blockshape[0]);\n      break;\n    default:\n      free(shape);\n      free(chunkshape);\n      free(blockshape);\n      BLOSC_TRACE_ERROR(\"ZFP is not available for ndims: %d\", ndim);\n      return BLOSC2_ERROR_FAILURE;\n  }\n\n  int zfp_maxout = (int) zfp_stream_maximum_size(zfp, field);\n  zfp_stream_close(zfp);\n  stream_close(stream);\n  uint8_t *aux_out = malloc(zfp_maxout);\n  zfp_aux = zfp_stream_open(NULL);\n  stream_aux = stream_open(aux_out, zfp_maxout);\n  zfp_stream_set_bit_stream(zfp_aux, stream_aux);\n  zfp_stream_rewind(zfp_aux);\n  zfp_stream_set_rate(zfp_aux, rate, type, ndim, zfp_false);\n\n  zfpsize = zfp_compress(zfp_aux, field);\n\n  /* clean up */\n  zfp_field_free(field);\n  zfp_stream_close(zfp_aux);\n  stream_close(stream_aux);\n  free(shape);\n  free(chunkshape);\n  free(blockshape);\n\n  if (zfpsize == 0) {\n    BLOSC_TRACE_ERROR(\"\\n ZFP: Compression failed\\n\");\n    free(aux_out);\n    return (int) zfpsize;\n  }\n  if ((int32_t) zfpsize >= input_len) {\n    BLOSC_TRACE_ERROR(\"\\n ZFP: Compressed data is bigger than input! \\n\");\n    free(aux_out);\n    return 0;\n  }\n\n  memcpy(output, aux_out, zfpsize);\n  free(aux_out);\n\n  return (int) zfpsize;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 643,
    "critical_vars": [
      "dparams->schunk"
    ],
    "function": "zfp_rate_decompress",
    "filename": "c-blosc2/CVE-2023-37187/CVE-2023-37187_CWE-476_425e8a9a59d49378d57e2116b6c9b0190a5986f5_blosc2-zfp.c.diff",
    "function_code": "int zfp_rate_decompress(const uint8_t *input, int32_t input_len, uint8_t *output,\n                        int32_t output_len, uint8_t meta, blosc2_dparams *dparams, const void *chunk) {\n  ZFP_ERROR_NULL(input);\n  ZFP_ERROR_NULL(output);\n  ZFP_ERROR_NULL(dparams);\n  ZFP_ERROR_NULL(dparams->schunk);\n  BLOSC_UNUSED_PARAM(chunk);\n\n  blosc2_schunk *sc = dparams->schunk;\n  int32_t typesize = sc->typesize;\n\n  double ratio = (double) meta / 100.0;\n  int8_t ndim;\n  int64_t *shape = malloc(8 * sizeof(int64_t));\n  int32_t *chunkshape = malloc(8 * sizeof(int32_t));\n  int32_t *blockshape = malloc(8 * sizeof(int32_t));\n  uint8_t *smeta;\n  int32_t smeta_len;\n  if (blosc2_meta_get(sc, \"b2nd\", &smeta, &smeta_len) < 0) {\n    BLOSC_TRACE_ERROR(\"Cannot access b2nd meta info\");\n    free(shape);\n    free(chunkshape);\n    free(blockshape);\n    return BLOSC2_ERROR_FAILURE;\n  }\n  deserialize_meta(smeta, smeta_len, &ndim, shape, chunkshape, blockshape);\n  free(smeta);\n\n  zfp_type type;     /* array scalar type */\n  zfp_field *field;  /* array meta data */\n  zfp_stream *zfp;   /* compressed stream */\n  bitstream *stream; /* bit stream to write to or read from */\n  size_t zfpsize;    /* byte size of compressed stream */\n\n  switch (typesize) {\n    case sizeof(float):\n      type = zfp_type_float;\n      break;\n    case sizeof(double):\n      type = zfp_type_double;\n      break;\n    default:\n      free(shape);\n      free(chunkshape);\n      free(blockshape);\n      BLOSC_TRACE_ERROR(\"ZFP is not available for typesize: %d\", typesize);\n      return BLOSC2_ERROR_FAILURE;\n  }\n  double rate =\n      ratio * (double) typesize * 8;     // convert from output size / input size to output bits per input value\n  zfp = zfp_stream_open(NULL);\n  zfp_stream_set_rate(zfp, rate, type, ndim, zfp_false);\n\n  stream = stream_open((void *) input, input_len);\n  zfp_stream_set_bit_stream(zfp, stream);\n  zfp_stream_rewind(zfp);\n\n  switch (ndim) {\n    case 1:\n      field = zfp_field_1d((void *) output, type, blockshape[0]);\n      break;\n    case 2:\n      field = zfp_field_2d((void *) output, type, blockshape[1], blockshape[0]);\n      break;\n    case 3:\n      field = zfp_field_3d((void *) output, type, blockshape[2], blockshape[1], blockshape[0]);\n      break;\n    case 4:\n      field = zfp_field_4d((void *) output, type, blockshape[3], blockshape[2], blockshape[1], blockshape[0]);\n      break;\n    default:\n      free(shape);\n      free(chunkshape);\n      free(blockshape);\n      BLOSC_TRACE_ERROR(\"ZFP is not available for ndims: %d\", ndim);\n      return BLOSC2_ERROR_FAILURE;\n  }\n\n  zfpsize = zfp_decompress(zfp, field);\n\n  /* clean up */\n  zfp_field_free(field);\n  zfp_stream_close(zfp);\n  stream_close(stream);\n  free(shape);\n  free(chunkshape);\n  free(blockshape);\n\n  if (zfpsize == 0) {\n    BLOSC_TRACE_ERROR(\"\\n ZFP: Decompression failed\\n\");\n    return (int) zfpsize;\n  }\n\n  return (int) output_len;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Fun-Call",
    "line_old": 158,
    "line_new": 158,
    "critical_vars": [
      "box->info->name"
    ],
    "function": "*jp2_decode",
    "filename": "jasper/CVE-2016-8887/CVE-2016-8887_CWE-476_e24bdc716c3327b067c551bc6cfb97fd2370358d_jp2_dec.c.diff",
    "function_code": "jas_image_t *jp2_decode(jas_stream_t *in, char *optstr)\n{\n\tjp2_box_t *box;\n\tint found;\n\tjas_image_t *image;\n\tjp2_dec_t *dec;\n\tbool samedtype;\n\tint dtype;\n\tunsigned int i;\n\tjp2_cmap_t *cmapd;\n\tjp2_pclr_t *pclrd;\n\tjp2_cdef_t *cdefd;\n\tunsigned int channo;\n\tint newcmptno;\n\tint_fast32_t *lutents;\n#if 0\n\tjp2_cdefchan_t *cdefent;\n\tint cmptno;\n#endif\n\tjp2_cmapent_t *cmapent;\n\tjas_icchdr_t icchdr;\n\tjas_iccprof_t *iccprof;\n\n\tdec = 0;\n\tbox = 0;\n\timage = 0;\n\n\tif (!(dec = jp2_dec_create())) {\n\t\tgoto error;\n\t}\n\n\t/* Get the first box.  This should be a JP box. */\n\tif (!(box = jp2_box_get(in))) {\n\t\tjas_eprintf(\"error: cannot get box\\n\");\n\t\tgoto error;\n\t}\n\tif (box->type != JP2_BOX_JP) {\n\t\tjas_eprintf(\"error: expecting signature box\\n\");\n\t\tgoto error;\n\t}\n\tif (box->data.jp.magic != JP2_JP_MAGIC) {\n\t\tjas_eprintf(\"incorrect magic number\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Get the second box.  This should be a FTYP box. */\n\tif (!(box = jp2_box_get(in))) {\n\t\tgoto error;\n\t}\n\tif (box->type != JP2_BOX_FTYP) {\n\t\tjas_eprintf(\"expecting file type box\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Get more boxes... */\n\tfound = 0;\n\twhile ((box = jp2_box_get(in))) {\n\t\tif (jas_getdbglevel() >= 1) {\n\t\t\tjas_eprintf(\"got box type %s\\n\", box->info->name);\n\t\t}\n\t\tswitch (box->type) {\n\t\tcase JP2_BOX_JP2C:\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\tcase JP2_BOX_IHDR:\n\t\t\tif (!dec->ihdr) {\n\t\t\t\tdec->ihdr = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_BPCC:\n\t\t\tif (!dec->bpcc) {\n\t\t\t\tdec->bpcc = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_CDEF:\n\t\t\tif (!dec->cdef) {\n\t\t\t\tdec->cdef = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_PCLR:\n\t\t\tif (!dec->pclr) {\n\t\t\t\tdec->pclr = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_CMAP:\n\t\t\tif (!dec->cmap) {\n\t\t\t\tdec->cmap = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_COLR:\n\t\t\tif (!dec->colr) {\n\t\t\t\tdec->colr = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (box) {\n\t\t\tjp2_box_destroy(box);\n\t\t\tbox = 0;\n\t\t}\n\t\tif (found) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tjas_eprintf(\"error: no code stream found\\n\");\n\t\tgoto error;\n\t}\n\n\tif (!(dec->image = jpc_decode(in, optstr))) {\n\t\tjas_eprintf(\"error: cannot decode code stream\\n\");\n\t\tgoto error;\n\t}\n\n\t/* An IHDR box must be present. */\n\tif (!dec->ihdr) {\n\t\tjas_eprintf(\"error: missing IHDR box\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Does the number of components indicated in the IHDR box match\n\t  the value specified in the code stream? */\n\tif (dec->ihdr->data.ihdr.numcmpts != JAS_CAST(uint,\n\t  jas_image_numcmpts(dec->image))) {\n\t\tjas_eprintf(\"warning: number of components mismatch\\n\");\n\t}\n\n\t/* At least one component must be present. */\n\tif (!jas_image_numcmpts(dec->image)) {\n\t\tjas_eprintf(\"error: no components\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Determine if all components have the same data type. */\n\tsamedtype = true;\n\tdtype = jas_image_cmptdtype(dec->image, 0);\n\tfor (i = 1; i < JAS_CAST(uint, jas_image_numcmpts(dec->image)); ++i) {\n\t\tif (jas_image_cmptdtype(dec->image, i) != dtype) {\n\t\t\tsamedtype = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Is the component data type indicated in the IHDR box consistent\n\t  with the data in the code stream? */\n\tif ((samedtype && dec->ihdr->data.ihdr.bpc != JP2_DTYPETOBPC(dtype)) ||\n\t  (!samedtype && dec->ihdr->data.ihdr.bpc != JP2_IHDR_BPCNULL)) {\n\t\tjas_eprintf(\"warning: component data type mismatch\\n\");\n\t}\n\n\t/* Is the compression type supported? */\n\tif (dec->ihdr->data.ihdr.comptype != JP2_IHDR_COMPTYPE) {\n\t\tjas_eprintf(\"error: unsupported compression type\\n\");\n\t\tgoto error;\n\t}\n\n\tif (dec->bpcc) {\n\t\t/* Is the number of components indicated in the BPCC box\n\t\t  consistent with the code stream data? */\n\t\tif (dec->bpcc->data.bpcc.numcmpts != JAS_CAST(uint, jas_image_numcmpts(\n\t\t  dec->image))) {\n\t\t\tjas_eprintf(\"warning: number of components mismatch\\n\");\n\t\t}\n\t\t/* Is the component data type information indicated in the BPCC\n\t\t  box consistent with the code stream data? */\n\t\tif (!samedtype) {\n\t\t\tfor (i = 0; i < JAS_CAST(uint, jas_image_numcmpts(dec->image));\n\t\t\t  ++i) {\n\t\t\t\tif (jas_image_cmptdtype(dec->image, i) !=\n\t\t\t\t  JP2_BPCTODTYPE(dec->bpcc->data.bpcc.bpcs[i])) {\n\t\t\t\t\tjas_eprintf(\"warning: component data type mismatch\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tjas_eprintf(\"warning: superfluous BPCC box\\n\");\n\t\t}\n\t}\n\n\t/* A COLR box must be present. */\n\tif (!dec->colr) {\n\t\tjas_eprintf(\"error: no COLR box\\n\");\n\t\tgoto error;\n\t}\n\n\tswitch (dec->colr->data.colr.method) {\n\tcase JP2_COLR_ENUM:\n\t\tjas_image_setclrspc(dec->image, jp2_getcs(&dec->colr->data.colr));\n\t\tbreak;\n\tcase JP2_COLR_ICC:\n\t\ticcprof = jas_iccprof_createfrombuf(dec->colr->data.colr.iccp,\n\t\t  dec->colr->data.colr.iccplen);\n\t\tif (!iccprof) {\n\t\t\tjas_eprintf(\"error: failed to parse ICC profile\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_iccprof_gethdr(iccprof, &icchdr);\n\t\tjas_eprintf(\"ICC Profile CS %08x\\n\", icchdr.colorspc);\n\t\tjas_image_setclrspc(dec->image, fromiccpcs(icchdr.colorspc));\n\t\tdec->image->cmprof_ = jas_cmprof_createfromiccprof(iccprof);\n\t\tassert(dec->image->cmprof_);\n\t\tjas_iccprof_destroy(iccprof);\n\t\tbreak;\n\t}\n\n\t/* If a CMAP box is present, a PCLR box must also be present. */\n\tif (dec->cmap && !dec->pclr) {\n\t\tjas_eprintf(\"warning: missing PCLR box or superfluous CMAP box\\n\");\n\t\tjp2_box_destroy(dec->cmap);\n\t\tdec->cmap = 0;\n\t}\n\n\t/* If a CMAP box is not present, a PCLR box must not be present. */\n\tif (!dec->cmap && dec->pclr) {\n\t\tjas_eprintf(\"warning: missing CMAP box or superfluous PCLR box\\n\");\n\t\tjp2_box_destroy(dec->pclr);\n\t\tdec->pclr = 0;\n\t}\n\n\t/* Determine the number of channels (which is essentially the number\n\t  of components after any palette mappings have been applied). */\n\tdec->numchans = dec->cmap ? dec->cmap->data.cmap.numchans :\n\t  JAS_CAST(uint, jas_image_numcmpts(dec->image));\n\n\t/* Perform a basic sanity check on the CMAP box if present. */\n\tif (dec->cmap) {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\t/* Is the component number reasonable? */\n\t\t\tif (dec->cmap->data.cmap.ents[i].cmptno >= JAS_CAST(uint,\n\t\t\t  jas_image_numcmpts(dec->image))) {\n\t\t\t\tjas_eprintf(\"error: invalid component number in CMAP box\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\t/* Is the LUT index reasonable? */\n\t\t\tif (dec->cmap->data.cmap.ents[i].pcol >=\n\t\t\t  dec->pclr->data.pclr.numchans) {\n\t\t\t\tjas_eprintf(\"error: invalid CMAP LUT index\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Allocate space for the channel-number to component-number LUT. */\n\tif (!(dec->chantocmptlut = jas_alloc2(dec->numchans,\n\t  sizeof(uint_fast16_t)))) {\n\t\tjas_eprintf(\"error: no memory\\n\");\n\t\tgoto error;\n\t}\n\n\tif (!dec->cmap) {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\tdec->chantocmptlut[i] = i;\n\t\t}\n\t} else {\n\t\tcmapd = &dec->cmap->data.cmap;\n\t\tpclrd = &dec->pclr->data.pclr;\n\t\tcdefd = &dec->cdef->data.cdef;\n\t\tfor (channo = 0; channo < cmapd->numchans; ++channo) {\n\t\t\tcmapent = &cmapd->ents[channo];\n\t\t\tif (cmapent->map == JP2_CMAP_DIRECT) {\n\t\t\t\tdec->chantocmptlut[channo] = channo;\n\t\t\t} else if (cmapent->map == JP2_CMAP_PALETTE) {\n\t\t\t\tlutents = jas_alloc2(pclrd->numlutents, sizeof(int_fast32_t));\n\t\t\t\tfor (i = 0; i < pclrd->numlutents; ++i) {\n\t\t\t\t\tlutents[i] = pclrd->lutdata[cmapent->pcol + i * pclrd->numchans];\n\t\t\t\t}\n\t\t\t\tnewcmptno = jas_image_numcmpts(dec->image);\n\t\t\t\tjas_image_depalettize(dec->image, cmapent->cmptno,\n\t\t\t\t  pclrd->numlutents, lutents,\n\t\t\t\t  JP2_BPCTODTYPE(pclrd->bpc[cmapent->pcol]), newcmptno);\n\t\t\t\tdec->chantocmptlut[channo] = newcmptno;\n\t\t\t\tjas_free(lutents);\n#if 0\n\t\t\t\tif (dec->cdef) {\n\t\t\t\t\tcdefent = jp2_cdef_lookup(cdefd, channo);\n\t\t\t\t\tif (!cdefent) {\n\t\t\t\t\t\tabort();\n\t\t\t\t\t}\n\t\t\t\tjas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), cdefent->type, cdefent->assoc));\n\t\t\t\t} else {\n\t\t\t\tjas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), 0, channo + 1));\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Mark all components as being of unknown type. */\n\n\tfor (i = 0; i < JAS_CAST(uint, jas_image_numcmpts(dec->image)); ++i) {\n\t\tjas_image_setcmpttype(dec->image, i, JAS_IMAGE_CT_UNKNOWN);\n\t}\n\n\t/* Determine the type of each component. */\n\tif (dec->cdef) {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\t/* Is the channel number reasonable? */\n\t\t\tif (dec->cdef->data.cdef.ents[i].channo >= dec->numchans) {\n\t\t\t\tjas_eprintf(\"error: invalid channel number in CDEF box\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tjas_image_setcmpttype(dec->image,\n\t\t\t  dec->chantocmptlut[dec->cdef->data.cdef.ents[i].channo],\n\t\t\t  jp2_getct(jas_image_clrspc(dec->image),\n\t\t\t  dec->cdef->data.cdef.ents[i].type,\n\t\t\t  dec->cdef->data.cdef.ents[i].assoc));\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\tjas_image_setcmpttype(dec->image, dec->chantocmptlut[i],\n\t\t\t  jp2_getct(jas_image_clrspc(dec->image), 0, i + 1));\n\t\t}\n\t}\n\n\t/* Delete any components that are not of interest. */\n\tfor (i = jas_image_numcmpts(dec->image); i > 0; --i) {\n\t\tif (jas_image_cmpttype(dec->image, i - 1) == JAS_IMAGE_CT_UNKNOWN) {\n\t\t\tjas_image_delcmpt(dec->image, i - 1);\n\t\t}\n\t}\n\n\t/* Ensure that some components survived. */\n\tif (!jas_image_numcmpts(dec->image)) {\n\t\tjas_eprintf(\"error: no components\\n\");\n\t\tgoto error;\n\t}\n#if 0\njas_eprintf(\"no of components is %d\\n\", jas_image_numcmpts(dec->image));\n#endif\n\n\t/* Prevent the image from being destroyed later. */\n\timage = dec->image;\n\tdec->image = 0;\n\n\tjp2_dec_destroy(dec);\n\n\treturn image;\n\nerror:\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (dec) {\n\t\tjp2_dec_destroy(dec);\n\t}\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 261,
    "critical_vars": [
      "boxinfo->name",
      "box->len",
      "box->type"
    ],
    "function": "*jp2_box_get",
    "filename": "jasper/CVE-2016-8887/CVE-2016-8887_CWE-476_e24bdc716c3327b067c551bc6cfb97fd2370358d_jp2_cod.c.diff",
    "function_code": "jp2_box_t *jp2_box_get(jas_stream_t *in)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\tjas_stream_t *tmpstream;\n\tuint_fast32_t len;\n\tuint_fast64_t extlen;\n\tbool dataflag;\n\n\tbox = 0;\n\ttmpstream = 0;\n\n\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n\t\tgoto error;\n\t}\n\n\t// Mark the box data as never having been constructed\n\t// so that we will not errantly attempt to destroy it later.\n\tbox->ops = &jp2_boxinfo_unk.ops;\n\n\tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n\t\tgoto error;\n\t}\n\tboxinfo = jp2_boxinfolookup(box->type);\n\tbox->info = boxinfo;\n\tbox->len = len;\n\tJAS_DBGLOG(10, (\n\t  \"preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\\n\",\n\t  '\"', boxinfo->name, '\"', box->type, box->len\n\t  ));\n\tif (box->len == 1) {\n\t\tif (jp2_getuint64(in, &extlen)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (extlen > 0xffffffffUL) {\n\t\t\tjas_eprintf(\"warning: cannot handle large 64-bit box length\\n\");\n\t\t\textlen = 0xffffffffUL;\n\t\t}\n\t\tbox->len = extlen;\n\t\tbox->datalen = extlen - JP2_BOX_HDRLEN(true);\n\t} else {\n\t\tbox->datalen = box->len - JP2_BOX_HDRLEN(false);\n\t}\n\tif (box->len != 0 && box->len < 8) {\n\t\tgoto error;\n\t}\n\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (jas_stream_copy(tmpstream, in, box->datalen)) {\n\t\t\tjas_eprintf(\"cannot copy box data\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_rewind(tmpstream);\n\n\t\t// From here onwards, the box data will need to be destroyed.\n\t\t// So, initialize the box operations.\n\t\tbox->ops = &boxinfo->ops;\n\n\t\tif (box->ops->getdata) {\n\t\t\tif ((*box->ops->getdata)(box, tmpstream)) {\n\t\t\t\tjas_eprintf(\"cannot parse box data\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\tif (jas_getdbglevel() >= 1) {\n\t\tjp2_box_dump(box, stderr);\n\t}\n\n\treturn box;\n\nerror:\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1841,
    "critical_vars": [
      "roishift"
    ],
    "function": "jpc_undo_roi",
    "filename": "jasper/CVE-2016-10248/CVE-2016-10248_CWE-476_2e82fa00466ae525339754bb3ab0a0474a31d4bd_jpc_dec.c.diff",
    "function_code": "static void jpc_undo_roi(jas_matrix_t *x, int roishift, int bgshift, int numbps)\n{\n\tint i;\n\tint j;\n\tint thresh;\n\tjpc_fix_t val;\n\tjpc_fix_t mag;\n\tbool warn;\n\tuint_fast32_t mask;\n\n\tif (roishift < 0) {\n\t\t/* We could instead return an error here. */\n\t\t/* I do not think it matters much. */\n\t\tjas_eprintf(\"warning: forcing negative ROI shift to zero \"\n\t\t  \"(bitstream is probably corrupt)\\n\");\n\t\troishift = 0;\n\t}\n\tif (roishift == 0 && bgshift == 0) {\n\t\treturn;\n\t}\n\tthresh = 1 << roishift;\n\n\twarn = false;\n\tfor (i = 0; i < jas_matrix_numrows(x); ++i) {\n\t\tfor (j = 0; j < jas_matrix_numcols(x); ++j) {\n\t\t\tval = jas_matrix_get(x, i, j);\n\t\t\tmag = JAS_ABS(val);\n\t\t\tif (mag >= thresh) {\n\t\t\t\t/* We are dealing with ROI data. */\n\t\t\t\tmag >>= roishift;\n\t\t\t\tval = (val < 0) ? (-mag) : mag;\n\t\t\t\tjas_matrix_set(x, i, j, val);\n\t\t\t} else {\n\t\t\t\t/* We are dealing with non-ROI (i.e., background) data. */\n\t\t\t\tmag <<= bgshift;\n\t\t\t\tmask = (JAS_CAST(uint_fast32_t, 1) << numbps) - 1;\n\t\t\t\t/* Perform a basic sanity check on the sample value. */\n\t\t\t\t/* Some implementations write garbage in the unused\n\t\t\t\t  most-significant bit planes introduced by ROI shifting.\n\t\t\t\t  Here we ensure that any such bits are masked off. */\n\t\t\t\tif (mag & (~mask)) {\n\t\t\t\t\tif (!warn) {\n\t\t\t\t\t\tjas_eprintf(\"warning: possibly corrupt code stream\\n\");\n\t\t\t\t\t\twarn = true;\n\t\t\t\t\t}\n\t\t\t\t\tmag &= mask;\n\t\t\t\t}\n\t\t\t\tval = (val < 0) ? (-mag) : mag;\n\t\t\t\tjas_matrix_set(x, i, j, val);\n\t\t\t}\n\t\t}\n\t}\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 260,
    "critical_vars": [
      "box->ops"
    ],
    "function": "*jp2_box_get",
    "filename": "jasper/CVE-2016-10250/CVE-2016-10250_CWE-476_bdfe95a6e81ffb4b2fad31a76b57943695beed20_jp2_cod.c.diff",
    "function_code": "jp2_box_t *jp2_box_get(jas_stream_t *in)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\tjas_stream_t *tmpstream;\n\tuint_fast32_t len;\n\tuint_fast64_t extlen;\n\tbool dataflag;\n\n\tbox = 0;\n\ttmpstream = 0;\n\n\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n\t\tgoto error;\n\t}\n\tbox->ops = &jp2_boxinfo_unk.ops;\n\tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n\t\tgoto error;\n\t}\n\tboxinfo = jp2_boxinfolookup(box->type);\n\tbox->info = boxinfo;\n\tbox->ops = &boxinfo->ops;\n\tbox->len = len;\n\tJAS_DBGLOG(10, (\n\t  \"preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\\n\",\n\t  '\"', boxinfo->name, '\"', box->type, box->len\n\t  ));\n\tif (box->len == 1) {\n\t\tif (jp2_getuint64(in, &extlen)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (extlen > 0xffffffffUL) {\n\t\t\tjas_eprintf(\"warning: cannot handle large 64-bit box length\\n\");\n\t\t\textlen = 0xffffffffUL;\n\t\t}\n\t\tbox->len = extlen;\n\t\tbox->datalen = extlen - JP2_BOX_HDRLEN(true);\n\t} else {\n\t\tbox->datalen = box->len - JP2_BOX_HDRLEN(false);\n\t}\n\tif (box->len != 0 && box->len < 8) {\n\t\tgoto error;\n\t}\n\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (jas_stream_copy(tmpstream, in, box->datalen)) {\n\t\t\t// Mark the box data as never having been constructed\n\t\t\t// so that we will not errantly attempt to destroy it later.\n\t\t\tbox->ops = &jp2_boxinfo_unk.ops;\n\t\t\tjas_eprintf(\"cannot copy box data\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_rewind(tmpstream);\n\n\t\tif (box->ops->getdata) {\n\t\t\tif ((*box->ops->getdata)(box, tmpstream)) {\n\t\t\t\tjas_eprintf(\"cannot parse box data\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\tif (jas_getdbglevel() >= 1) {\n\t\tjp2_box_dump(box, stderr);\n\t}\n\n\treturn box;\n\nerror:\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn 0;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 105,
    "critical_vars": [
      "numrows",
      "numcols"
    ],
    "function": "*jas_matrix_create",
    "filename": "jasper/CVE-2016-8884/CVE-2016-8884_CWE-476_5d66894d2313e3f3469f19066e149e08ff076698_jas_seq.c.diff",
    "function_code": "jas_matrix_t *jas_matrix_create(int numrows, int numcols)\n{\n\tjas_matrix_t *matrix;\n\tint i;\n\n\tif (numrows < 0 || numcols < 0) {\n\t\treturn 0;\n\t}\n\n\tif (!(matrix = jas_malloc(sizeof(jas_matrix_t)))) {\n\t\treturn 0;\n\t}\n\tmatrix->flags_ = 0;\n\tmatrix->numrows_ = numrows;\n\tmatrix->numcols_ = numcols;\n\tmatrix->rows_ = 0;\n\tmatrix->maxrows_ = numrows;\n\tmatrix->data_ = 0;\n\tmatrix->datasize_ = numrows * numcols;\n\n\tif (matrix->maxrows_ > 0) {\n\t\tif (!(matrix->rows_ = jas_alloc2(matrix->maxrows_,\n\t\t  sizeof(jas_seqent_t *)))) {\n\t\t\tjas_matrix_destroy(matrix);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (matrix->datasize_ > 0) {\n\t\tif (!(matrix->data_ = jas_alloc2(matrix->datasize_,\n\t\t  sizeof(jas_seqent_t)))) {\n\t\t\tjas_matrix_destroy(matrix);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tfor (i = 0; i < numrows; ++i) {\n\t\tmatrix->rows_[i] = &matrix->data_[i * matrix->numcols_];\n\t}\n\n\tfor (i = 0; i < matrix->datasize_; ++i) {\n\t\tmatrix->data_[i] = 0;\n\t}\n\n\tmatrix->xstart_ = 0;\n\tmatrix->ystart_ = 0;\n\tmatrix->xend_ = matrix->numcols_;\n\tmatrix->yend_ = matrix->numrows_;\n\n\treturn matrix;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 110,
    "critical_vars": [
      "image"
    ],
    "function": "*bmp_decode",
    "filename": "jasper/CVE-2016-8884/CVE-2016-8884_CWE-476_5d66894d2313e3f3469f19066e149e08ff076698_bmp_dec.c.diff",
    "function_code": "jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)\n{\n\tjas_image_t *image;\n\tbmp_hdr_t hdr;\n\tbmp_info_t *info;\n\tuint_fast16_t cmptno;\n\tjas_image_cmptparm_t cmptparms[3];\n\tjas_image_cmptparm_t *cmptparm;\n\tuint_fast16_t numcmpts;\n\tlong n;\n\n\tif (optstr) {\n\t\tjas_eprintf(\"warning: ignoring BMP decoder options\\n\");\n\t}\n\n\tjas_eprintf(\n\t  \"THE BMP FORMAT IS NOT FULLY SUPPORTED!\\n\"\n\t  \"THAT IS, THE JASPER SOFTWARE CANNOT DECODE ALL TYPES OF BMP DATA.\\n\"\n\t  \"IF YOU HAVE ANY PROBLEMS, PLEASE TRY CONVERTING YOUR IMAGE DATA\\n\"\n\t  \"TO THE PNM FORMAT, AND USING THIS FORMAT INSTEAD.\\n\"\n\t  );\n\n\t/* Read the bitmap header. */\n\tif (bmp_gethdr(in, &hdr)) {\n\t\tjas_eprintf(\"cannot get header\\n\");\n\t\treturn 0;\n\t}\n\tJAS_DBGLOG(1, (\n\t  \"BMP header: magic 0x%x; siz %d; res1 %d; res2 %d; off %d\\n\",\n\t  hdr.magic, hdr.siz, hdr.reserved1, hdr.reserved2, hdr.off\n\t  ));\n\n\t/* Read the bitmap information. */\n\tif (!(info = bmp_getinfo(in))) {\n\t\tjas_eprintf(\"cannot get info\\n\");\n\t\treturn 0;\n\t}\n\tJAS_DBGLOG(1,\n\t  (\"BMP information: len %d; width %d; height %d; numplanes %d; \"\n\t  \"depth %d; enctype %d; siz %d; hres %d; vres %d; numcolors %d; \"\n\t  \"mincolors %d\\n\", info->len, info->width, info->height, info->numplanes,\n\t  info->depth, info->enctype, info->siz, info->hres, info->vres,\n\t  info->numcolors, info->mincolors));\n\n\t/* Ensure that we support this type of BMP file. */\n\tif (!bmp_issupported(&hdr, info)) {\n\t\tjas_eprintf(\"error: unsupported BMP encoding\\n\");\n\t\tbmp_info_destroy(info);\n\t\treturn 0;\n\t}\n\n\t/* Skip over any useless data between the end of the palette\n\t  and start of the bitmap data. */\n\tif ((n = hdr.off - (BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN(info))) < 0) {\n\t\tjas_eprintf(\"error: possibly bad bitmap offset?\\n\");\n\t\treturn 0;\n\t}\n\tif (n > 0) {\n\t\tjas_eprintf(\"skipping unknown data in BMP file\\n\");\n\t\tif (bmp_gobble(in, n)) {\n\t\t\tbmp_info_destroy(info);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Get the number of components. */\n\tnumcmpts = bmp_numcmpts(info);\n\n\tfor (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,\n\t  ++cmptparm) {\n\t\tcmptparm->tlx = 0;\n\t\tcmptparm->tly = 0;\n\t\tcmptparm->hstep = 1;\n\t\tcmptparm->vstep = 1;\n\t\tcmptparm->width = info->width;\n\t\tcmptparm->height = info->height;\n\t\tcmptparm->prec = 8;\n\t\tcmptparm->sgnd = false;\n\t}\n\n\t/* Create image object. */\n\tif (!(image = jas_image_create(numcmpts, cmptparms,\n\t  JAS_CLRSPC_UNKNOWN))) {\n\t\tbmp_info_destroy(info);\n\t\treturn 0;\n\t}\n\n\tif (numcmpts == 3) {\n\t\tjas_image_setclrspc(image, JAS_CLRSPC_SRGB);\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));\n\t\tjas_image_setcmpttype(image, 1,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));\n\t\tjas_image_setcmpttype(image, 2,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));\n\t} else {\n\t\tjas_image_setclrspc(image, JAS_CLRSPC_SGRAY);\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));\n\t}\n\n\t/* Read the bitmap data. */\n\tif (bmp_getdata(in, info, image)) {\n\t\tbmp_info_destroy(info);\n\t\tjas_image_destroy(image);\n\t\treturn 0;\n\t}\n\n\tbmp_info_destroy(info);\n\n\treturn image;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 146,
    "critical_vars": [
      "info"
    ],
    "function": "*bmp_decode",
    "filename": "jasper/CVE-2016-8884/CVE-2016-8884_CWE-476_5d66894d2313e3f3469f19066e149e08ff076698_bmp_dec.c.diff",
    "function_code": "jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)\n{\n\tjas_image_t *image;\n\tbmp_hdr_t hdr;\n\tbmp_info_t *info;\n\tuint_fast16_t cmptno;\n\tjas_image_cmptparm_t cmptparms[3];\n\tjas_image_cmptparm_t *cmptparm;\n\tuint_fast16_t numcmpts;\n\tlong n;\n\n\tif (optstr) {\n\t\tjas_eprintf(\"warning: ignoring BMP decoder options\\n\");\n\t}\n\n\tjas_eprintf(\n\t  \"THE BMP FORMAT IS NOT FULLY SUPPORTED!\\n\"\n\t  \"THAT IS, THE JASPER SOFTWARE CANNOT DECODE ALL TYPES OF BMP DATA.\\n\"\n\t  \"IF YOU HAVE ANY PROBLEMS, PLEASE TRY CONVERTING YOUR IMAGE DATA\\n\"\n\t  \"TO THE PNM FORMAT, AND USING THIS FORMAT INSTEAD.\\n\"\n\t  );\n\n\t/* Read the bitmap header. */\n\tif (bmp_gethdr(in, &hdr)) {\n\t\tjas_eprintf(\"cannot get header\\n\");\n\t\treturn 0;\n\t}\n\tJAS_DBGLOG(1, (\n\t  \"BMP header: magic 0x%x; siz %d; res1 %d; res2 %d; off %d\\n\",\n\t  hdr.magic, hdr.siz, hdr.reserved1, hdr.reserved2, hdr.off\n\t  ));\n\n\t/* Read the bitmap information. */\n\tif (!(info = bmp_getinfo(in))) {\n\t\tjas_eprintf(\"cannot get info\\n\");\n\t\treturn 0;\n\t}\n\tJAS_DBGLOG(1,\n\t  (\"BMP information: len %d; width %d; height %d; numplanes %d; \"\n\t  \"depth %d; enctype %d; siz %d; hres %d; vres %d; numcolors %d; \"\n\t  \"mincolors %d\\n\", info->len, info->width, info->height, info->numplanes,\n\t  info->depth, info->enctype, info->siz, info->hres, info->vres,\n\t  info->numcolors, info->mincolors));\n\n\t/* Ensure that we support this type of BMP file. */\n\tif (!bmp_issupported(&hdr, info)) {\n\t\tjas_eprintf(\"error: unsupported BMP encoding\\n\");\n\t\tbmp_info_destroy(info);\n\t\treturn 0;\n\t}\n\n\t/* Skip over any useless data between the end of the palette\n\t  and start of the bitmap data. */\n\tif ((n = hdr.off - (BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN(info))) < 0) {\n\t\tjas_eprintf(\"error: possibly bad bitmap offset?\\n\");\n\t\treturn 0;\n\t}\n\tif (n > 0) {\n\t\tjas_eprintf(\"skipping unknown data in BMP file\\n\");\n\t\tif (bmp_gobble(in, n)) {\n\t\t\tbmp_info_destroy(info);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Get the number of components. */\n\tnumcmpts = bmp_numcmpts(info);\n\n\tfor (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,\n\t  ++cmptparm) {\n\t\tcmptparm->tlx = 0;\n\t\tcmptparm->tly = 0;\n\t\tcmptparm->hstep = 1;\n\t\tcmptparm->vstep = 1;\n\t\tcmptparm->width = info->width;\n\t\tcmptparm->height = info->height;\n\t\tcmptparm->prec = 8;\n\t\tcmptparm->sgnd = false;\n\t}\n\n\t/* Create image object. */\n\tif (!(image = jas_image_create(numcmpts, cmptparms,\n\t  JAS_CLRSPC_UNKNOWN))) {\n\t\tbmp_info_destroy(info);\n\t\treturn 0;\n\t}\n\n\tif (numcmpts == 3) {\n\t\tjas_image_setclrspc(image, JAS_CLRSPC_SRGB);\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));\n\t\tjas_image_setcmpttype(image, 1,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));\n\t\tjas_image_setcmpttype(image, 2,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));\n\t} else {\n\t\tjas_image_setclrspc(image, JAS_CLRSPC_SGRAY);\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));\n\t}\n\n\t/* Read the bitmap data. */\n\tif (bmp_getdata(in, info, image)) {\n\t\tbmp_info_destroy(info);\n\t\tjas_image_destroy(image);\n\t\treturn 0;\n\t}\n\n\tbmp_info_destroy(info);\n\n\treturn image;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 131,
    "critical_vars": [
      "debug"
    ],
    "function": "main",
    "filename": "jasper/CVE-2016-8690/CVE-2016-8690_CWE-476_8f62b4761711d036fd8964df256b938c809b7fca_imginfo.c.diff",
    "function_code": "int main(int argc, char * argv[])\n{\n    gr_face * face = 0;\n    try\n\t{\n\t\tif (argc != 2)\tthrow std::length_error(\"not enough arguments: need a backing font\");\n\n\t\tdummyFace = face_handle(argv[1]);\n\t\ttestFeatTable<FeatTableTestA>(testDataA, \"A\\n\");\n\t\ttestFeatTable<FeatTableTestB>(testDataB, \"B\\n\");\n\t\ttestFeatTable<FeatTableTestB>(testDataBunsorted, \"Bu\\n\");\n\t\ttestFeatTable<FeatTableTestC>(testDataCunsorted, \"C\\n\");\n\t\ttestFeatTable<FeatTableTestD>(testDataDunsorted, \"D\\n\");\n\t\ttestFeatTable<FeatTableTestE>(testDataE, \"E\\n\");\n\n\t\t// test a bad settings offset stradling the end of the table\n\t\tFeatureMap testFeatureMap;\n\t\tdummyFace.replace_table(TtfUtil::Tag::Feat, &testBadOffset, sizeof testBadOffset);\n\t\tface = gr_make_face_with_ops(&dummyFace, &face_handle::ops, 0);\n\t\ttestAssert(\"fail gracefully on bad table\", !face);\n\t}\n\tcatch (std::exception & e)\n\t{\n\t\tfprintf(stderr, \"%s: %s\\n\", argv[0], e.what());\n\t\tgr_face_destroy(face);\n\t\treturn 1;\n\t}\n\n    gr_face_destroy(face);\n    return 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 443,
    "line_new": 454,
    "critical_vars": [
      "v"
    ],
    "function": "bmp_getint32",
    "filename": "jasper/CVE-2016-8690/CVE-2016-8690_CWE-476_8f62b4761711d036fd8964df256b938c809b7fca_bmp_dec.c.diff",
    "function_code": "static int bmp_getint32(jas_stream_t *in, int_fast32_t *val)\n{\n\tint n;\n\tuint_fast32_t v;\n\tint c;\n\tfor (n = 4, v = 0;;) {\n\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\tv |= (JAS_CAST(uint_fast32_t, c) << 24);\n\t\tif (--n <= 0) {\n\t\t\tbreak;\n\t\t}\n\t\tv >>= 8;\n\t}\n\tif (val) {\n\t\t*val = v;\n\t}\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 395,
    "critical_vars": [
      "bpcc->bpcs"
    ],
    "function": "jp2_bpcc_getdata",
    "filename": "jasper/CVE-2017-6850/CVE-2017-6850_CWE-476_e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d_jp2_cod.c.diff",
    "function_code": "static int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_bpcc_t *bpcc = &box->data.bpcc;\n\tunsigned int i;\n\tbpcc->bpcs = 0;\n\tbpcc->numcmpts = box->datalen;\n\tif (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts, sizeof(uint_fast8_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < bpcc->numcmpts; ++i) {\n\t\tif (jp2_getuint8(in, &bpcc->bpcs[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 476,
    "critical_vars": [
      "cdef->ents"
    ],
    "function": "jp2_cdef_getdata",
    "filename": "jasper/CVE-2017-6850/CVE-2017-6850_CWE-476_e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d_jp2_cod.c.diff",
    "function_code": "static int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_cdef_t *cdef = &box->data.cdef;\n\tjp2_cdefchan_t *chan;\n\tunsigned int channo;\n\tcdef->ents = 0;\n\tif (jp2_getuint16(in, &cdef->numchans)) {\n\t\treturn -1;\n\t}\n\tif (!(cdef->ents = jas_alloc2(cdef->numchans, sizeof(jp2_cdefchan_t)))) {\n\t\treturn -1;\n\t}\n\tfor (channo = 0; channo < cdef->numchans; ++channo) {\n\t\tchan = &cdef->ents[channo];\n\t\tif (jp2_getuint16(in, &chan->channo) || jp2_getuint16(in, &chan->type) ||\n\t\t  jp2_getuint16(in, &chan->assoc)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 794,
    "critical_vars": [
      "cmap->ents"
    ],
    "function": "jp2_cmap_getdata",
    "filename": "jasper/CVE-2017-6850/CVE-2017-6850_CWE-476_e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d_jp2_cod.c.diff",
    "function_code": "static int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_cmap_t *cmap = &box->data.cmap;\n\tjp2_cmapent_t *ent;\n\tunsigned int i;\n\tcmap->ents = 0;\n\n\tcmap->numchans = (box->datalen) / 4;\n\tif (!(cmap->ents = jas_alloc2(cmap->numchans, sizeof(jp2_cmapent_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < cmap->numchans; ++i) {\n\t\tent = &cmap->ents[i];\n\t\tif (jp2_getuint16(in, &ent->cmptno) ||\n\t\t  jp2_getuint8(in, &ent->map) ||\n\t\t  jp2_getuint8(in, &ent->pcol)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\t\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 853,
    "critical_vars": [
      "pclr->bpc"
    ],
    "function": "jp2_pclr_getdata",
    "filename": "jasper/CVE-2017-6850/CVE-2017-6850_CWE-476_e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d_jp2_cod.c.diff",
    "function_code": "static int jp2_pclr_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_pclr_t *pclr = &box->data.pclr;\n\tint lutsize;\n\tunsigned int i;\n\tunsigned int j;\n\tint_fast32_t x;\n\n\tpclr->lutdata = 0;\n\tpclr->bpc = 0;\n\n\tif (jp2_getuint16(in, &pclr->numlutents) ||\n\t  jp2_getuint8(in, &pclr->numchans)) {\n\t\treturn -1;\n\t}\n\tlutsize = pclr->numlutents * pclr->numchans;\n\tif (!(pclr->lutdata = jas_alloc2(lutsize, sizeof(int_fast32_t)))) {\n\t\treturn -1;\n\t}\n\tif (!(pclr->bpc = jas_alloc2(pclr->numchans, sizeof(uint_fast8_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < pclr->numchans; ++i) {\n\t\tif (jp2_getuint8(in, &pclr->bpc[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tfor (i = 0; i < pclr->numlutents; ++i) {\n\t\tfor (j = 0; j < pclr->numchans; ++j) {\n\t\t\tif (jp2_getint(in, (pclr->bpc[j] & 0x80) != 0,\n\t\t\t  (pclr->bpc[j] & 0x7f) + 1, &x)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tpclr->lutdata[i * pclr->numchans + j] = x;\n\t\t}\n\t}\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 246,
    "line_new": 246,
    "critical_vars": [
      "face"
    ],
    "function": "testFeatTable",
    "filename": "graphite/CVE-2018-7999/CVE-2018-7999_CWE-476_db132b4731a9b4c9534144ba3a18e65b390e9ff6_featuremaptest.cpp.diff",
    "function_code": "template <class T> void testFeatTable(const T & table, const char * testName)\n{\n    FeatureMap testFeatureMap;\n    dummyFace.replace_table(TtfUtil::Tag::Feat, &table, sizeof(T));\n    gr_face * face = gr_make_face_with_ops(&dummyFace, &face_handle::ops, 0);\n    if (!face) throw std::runtime_error(\"failed to load font\");\n    bool readStatus = testFeatureMap.readFeats(*face);\n    testAssert(\"readFeats\", readStatus);\n    fprintf(stderr, testName, NULL);\n    testAssertEqual(\"test num features %hu,%hu\\n\", testFeatureMap.numFeats(), table.m_header.m_numFeat);\n\n    for (size_t i = 0; i < sizeof(table.m_defs) / sizeof(FeatDefn); i++)\n    {\n        const FeatureRef * ref = testFeatureMap.findFeatureRef(table.m_defs[i].m_featId);\n        testAssert(\"test feat\\n\", ref);\n        testAssertEqual(\"test feat settings %hu %hu\\n\", ref->getNumSettings(), table.m_defs[i].m_numFeatSettings);\n        testAssertEqual(\"test feat label %hu %hu\\n\", ref->getNameId(), table.m_defs[i].m_label);\n        size_t settingsIndex = (table.m_defs[i].m_settingsOffset - sizeof(FeatHeader)\n            - (sizeof(FeatDefn) * table.m_header.m_numFeat)) / sizeof(FeatSetting);\n        for (size_t j = 0; j < table.m_defs[i].m_numFeatSettings; j++)\n        {\n            testAssertEqual(\"setting label %hu %hu\\n\", ref->getSettingName(j),\n                       table.m_settings[settingsIndex+j].m_label);\n        }\n    }\n    gr_face_destroy(face);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 289,
    "critical_vars": [
      "readStatus"
    ],
    "function": "main",
    "filename": "graphite/CVE-2018-7999/CVE-2018-7999_CWE-476_db132b4731a9b4c9534144ba3a18e65b390e9ff6_featuremaptest.cpp.diff",
    "function_code": "int main(int argc, char * argv[])\n{\n    gr_face * face = 0;\n    try\n\t{\n\t\tif (argc != 2)\tthrow std::length_error(\"not enough arguments: need a backing font\");\n\n\t\tdummyFace = face_handle(argv[1]);\n\t\ttestFeatTable<FeatTableTestA>(testDataA, \"A\\n\");\n\t\ttestFeatTable<FeatTableTestB>(testDataB, \"B\\n\");\n\t\ttestFeatTable<FeatTableTestB>(testDataBunsorted, \"Bu\\n\");\n\t\ttestFeatTable<FeatTableTestC>(testDataCunsorted, \"C\\n\");\n\t\ttestFeatTable<FeatTableTestD>(testDataDunsorted, \"D\\n\");\n\t\ttestFeatTable<FeatTableTestE>(testDataE, \"E\\n\");\n\n\t\t// test a bad settings offset stradling the end of the table\n\t\tFeatureMap testFeatureMap;\n\t\tdummyFace.replace_table(TtfUtil::Tag::Feat, &testBadOffset, sizeof testBadOffset);\n\t\tface = gr_make_face_with_ops(&dummyFace, &face_handle::ops, gr_face_dumbRendering);\n\t\tbool readStatus = testFeatureMap.readFeats(*face);\n\t\ttestAssert(\"fail gracefully on bad table\", !readStatus);\n\t}\n\tcatch (std::exception & e)\n\t{\n\t\tfprintf(stderr, \"%s: %s\\n\", argv[0], e.what());\n\t\tgr_face_destroy(face);\n\t\treturn 1;\n\t}\n\n    gr_face_destroy(face);\n    return 0;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 268,
    "critical_vars": [
      "dumb_font"
    ],
    "function": "GlyphCache::Loader::Loader",
    "filename": "graphite/CVE-2018-7999/CVE-2018-7999_CWE-476_db132b4731a9b4c9534144ba3a18e65b390e9ff6_GlyphCache.cpp.diff",
    "function_code": "GlyphCache::Loader::Loader(const Face & face, const bool dumb_font)\n: _head(face, Tag::head),\n  _hhea(face, Tag::hhea),\n  _hmtx(face, Tag::hmtx),\n  _glyf(face, Tag::glyf),\n  _loca(face, Tag::loca),\n  _long_fmt(false),\n  _has_boxes(false),\n  _num_glyphs_graphics(0),\n  _num_glyphs_attributes(0),\n  _num_attrs(0)\n{\n    if (!operator bool())\n        return;\n\n    const Face::Table maxp = Face::Table(face, Tag::maxp);\n    if (!maxp) { _head = Face::Table(); return; }\n\n    _num_glyphs_graphics = TtfUtil::GlyphCount(maxp);\n    // This will fail if the number of glyphs is wildly out of range.\n    if (_glyf && TtfUtil::LocaLookup(_num_glyphs_graphics-1, _loca, _loca.size(), _head) == size_t(-2))\n    {\n        _head = Face::Table();\n        return;\n    }\n\n    if (!dumb_font)\n    {\n        if ((m_pGlat = Face::Table(face, Tag::Glat, 0x00030000)) == NULL\n            || (m_pGloc = Face::Table(face, Tag::Gloc)) == NULL\n            || m_pGloc.size() < 8)\n        {\n            _head = Face::Table();\n            return;\n        }\n        const byte    * p = m_pGloc;\n        int       version = be::read<uint32>(p);\n        const uint16    flags = be::read<uint16>(p);\n        _num_attrs = be::read<uint16>(p);\n        // We can accurately calculate the number of attributed glyphs by\n        //  subtracting the length of the attribids array (numAttribs long if present)\n        //  and dividing by either 2 or 4 depending on shor or lonf format\n        _long_fmt              = flags & 1;\n        int tmpnumgattrs       = (m_pGloc.size()\n                                   - (p - m_pGloc)\n                                   - sizeof(uint16)*(flags & 0x2 ? _num_attrs : 0))\n                                       / (_long_fmt ? sizeof(uint32) : sizeof(uint16)) - 1;\n\n        if (version >= 0x00020000 || tmpnumgattrs < 0 || tmpnumgattrs > 65535\n            || _num_attrs == 0 || _num_attrs > 0x3000  // is this hard limit appropriate?\n            || _num_glyphs_graphics > tmpnumgattrs\n            || m_pGlat.size() < 4)\n        {\n            _head = Face::Table();\n            return;\n        }\n\n        _num_glyphs_attributes = static_cast<unsigned short>(tmpnumgattrs);\n        p = m_pGlat;\n        version = be::read<uint32>(p);\n        if (version >= 0x00040000 || (version >= 0x00030000 && m_pGlat.size() < 8))       // reject Glat tables that are too new\n        {\n            _head = Face::Table();\n            return;\n        }\n        else if (version >= 0x00030000)\n        {\n            unsigned int glatflags = be::read<uint32>(p);\n            _has_boxes = glatflags & 1;\n            // delete this once the compiler is fixed\n            _has_boxes = true;\n        }\n    }\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 268,
    "critical_vars": [
      "Glat",
      "Gloc",
      "m_pGlat",
      "m_pGloc",
      "face"
    ],
    "function": "GlyphCache::Loader::Loader",
    "filename": "graphite/CVE-2018-7999/CVE-2018-7999_CWE-476_db132b4731a9b4c9534144ba3a18e65b390e9ff6_GlyphCache.cpp.diff",
    "function_code": "GlyphCache::Loader::Loader(const Face & face)\n: _head(face, Tag::head),\n  _hhea(face, Tag::hhea),\n  _hmtx(face, Tag::hmtx),\n  _glyf(face, Tag::glyf),\n  _loca(face, Tag::loca),\n  _long_fmt(false),\n  _has_boxes(false),\n  _num_glyphs_graphics(0),\n  _num_glyphs_attributes(0),\n  _num_attrs(0)\n{\n    if (!operator bool())\n        return;\n\n    const Face::Table maxp = Face::Table(face, Tag::maxp);\n    if (!maxp) { _head = Face::Table(); return; }\n\n    _num_glyphs_graphics = TtfUtil::GlyphCount(maxp);\n    // This will fail if the number of glyphs is wildly out of range.\n    if (_glyf && TtfUtil::LocaLookup(_num_glyphs_graphics-1, _loca, _loca.size(), _head) == size_t(-2))\n    {\n        _head = Face::Table();\n        return;\n    }\n\n    if ((m_pGlat = Face::Table(face, Tag::Glat, 0x00030000)) == NULL\n        || (m_pGloc = Face::Table(face, Tag::Gloc)) == NULL\n        || m_pGloc.size() < 8)\n    {\n        _head = Face::Table();\n        return;\n    }\n    const byte    * p = m_pGloc;\n    int       version = be::read<uint32>(p);\n    const uint16    flags = be::read<uint16>(p);\n    _num_attrs = be::read<uint16>(p);\n    // We can accurately calculate the number of attributed glyphs by\n    //  subtracting the length of the attribids array (numAttribs long if present)\n    //  and dividing by either 2 or 4 depending on shor or lonf format\n    _long_fmt              = flags & 1;\n    int tmpnumgattrs       = (m_pGloc.size()\n                               - (p - m_pGloc)\n                               - sizeof(uint16)*(flags & 0x2 ? _num_attrs : 0))\n                                   / (_long_fmt ? sizeof(uint32) : sizeof(uint16)) - 1;\n\n    if (version >= 0x00020000 || tmpnumgattrs < 0 || tmpnumgattrs > 65535\n        || _num_attrs == 0 || _num_attrs > 0x3000  // is this hard limit appropriate?\n        || _num_glyphs_graphics > tmpnumgattrs\n        || m_pGlat.size() < 4)\n    {\n        _head = Face::Table();\n        return;\n    }\n\n    _num_glyphs_attributes = static_cast<unsigned short>(tmpnumgattrs);\n    p = m_pGlat;\n    version = be::read<uint32>(p);\n    if (version >= 0x00040000 || (version >= 0x00030000 && m_pGlat.size() < 8))       // reject Glat tables that are too new\n    {\n        _head = Face::Table();\n        return;\n    }\n    else if (version >= 0x00030000)\n    {\n        unsigned int glatflags = be::read<uint32>(p);\n        _has_boxes = glatflags & 1;\n        // delete this once the compiler is fixed\n        _has_boxes = true;\n    }\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 684,
    "critical_vars": [
      "error"
    ],
    "function": "vi_pci_write",
    "filename": "hyperkit/CVE-2021-32844/CVE-2021-32844_CWE-476_451558fe8aaa8b24e02e34106e3bb9fe41d7ad13_virtio.c.diff",
    "function_code": "vi_pci_write(UNUSED int vcpu, struct pci_devinst *pi, int baridx,\n\tuint64_t offset, int size, uint64_t value)\n{\n\tstruct virtio_softc *vs = pi->pi_arg;\n\tstruct vqueue_info *vq;\n\tstruct virtio_consts *vc;\n\tstruct config_reg *cr;\n\tuint64_t virtio_config_size, max;\n\tconst char *name;\n\tuint32_t newoff;\n\tint error;\n\n\tif (vs->vs_flags & VIRTIO_USE_MSIX) {\n\t\tif (baridx == pci_msix_table_bar(pi) ||\n\t\t    baridx == pci_msix_pba_bar(pi)) {\n\t\t\tpci_emul_msix_twrite(pi, offset, size, value);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* XXX probably should do something better than just assert() */\n\tassert(baridx == 0);\n\n\tif (vs->vs_mtx)\n\t\tpthread_mutex_lock(vs->vs_mtx);\n\n\tvc = vs->vs_vc;\n\tname = vc->vc_name;\n\n\tif (size != 1 && size != 2 && size != 4)\n\t\tgoto bad;\n\n\tif (pci_msix_enabled(pi))\n\t\tvirtio_config_size = VTCFG_R_CFG1;\n\telse\n\t\tvirtio_config_size = VTCFG_R_CFG0;\n\n\tif (offset >= virtio_config_size) {\n\t\t/*\n\t\t * Subtract off the standard size (including MSI-X\n\t\t * registers if enabled) and dispatch to underlying driver.\n\t\t */\n\t\tnewoff = (uint32_t) (offset - virtio_config_size);\n\t\tmax = vc->vc_cfgsize ? vc->vc_cfgsize : 0x100000000;\n\t\tif ((newoff + ((unsigned) size)) > max)\n\t\t\tgoto bad;\n\t\terror = (*vc->vc_cfgwrite)(DEV_SOFTC(vs), ((int) newoff), size,\n\t\t\t((uint32_t) value));\n\t\tif (!error)\n\t\t\tgoto done;\n\t}\n\nbad:\n\tcr = vi_find_cr((int) offset);\n\tif (cr == NULL || cr->cr_size != size || cr->cr_ro) {\n\t\tif (cr != NULL) {\n\t\t\t/* offset must be OK, wrong size and/or reg is R/O */\n\t\t\tif (cr->cr_size != size)\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"%s: write to %s: bad size %d\\r\\n\",\n\t\t\t\t    name, cr->cr_name, size);\n\t\t\tif (cr->cr_ro)\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"%s: write to read-only reg %s\\r\\n\",\n\t\t\t\t    name, cr->cr_name);\n\t\t} else {\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s: write to bad offset/size %jd/%d\\r\\n\",\n\t\t\t    name, (uintmax_t)offset, size);\n\t\t}\n\t\tgoto done;\n\t}\n\n\tswitch (offset) {\n\tcase VTCFG_R_GUESTCAP:\n\t\tvs->vs_negotiated_caps = (uint32_t) (value & vc->vc_hv_caps);\n\t\tif (vc->vc_apply_features)\n\t\t\t(*vc->vc_apply_features)(DEV_SOFTC(vs),\n\t\t\t    vs->vs_negotiated_caps);\n\t\tbreak;\n\tcase VTCFG_R_PFN:\n\t\tif (vs->vs_curq >= vc->vc_nvq)\n\t\t\tgoto bad_qindex;\n\t\tvi_vq_init(vs, ((uint32_t) value));\n\t\tbreak;\n\tcase VTCFG_R_QSEL:\n\t\t/*\n\t\t * Note that the guest is allowed to select an\n\t\t * invalid queue; we just need to return a QNUM\n\t\t * of 0 while the bad queue is selected.\n\t\t */\n\t\tvs->vs_curq = (int) value;\n\t\tbreak;\n\tcase VTCFG_R_QNOTIFY:\n\t\tif (value >= ((uint64_t) vc->vc_nvq)) {\n\t\t\tfprintf(stderr, \"%s: queue %d notify out of range\\r\\n\",\n\t\t\t\tname, (int)value);\n\t\t\tgoto done;\n\t\t}\n\t\tvq = &vs->vs_queues[value];\n\t\tif (vq->vq_notify)\n\t\t\t(*vq->vq_notify)(DEV_SOFTC(vs), vq);\n\t\telse if (vc->vc_qnotify)\n\t\t\t(*vc->vc_qnotify)(DEV_SOFTC(vs), vq);\n\t\telse\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s: qnotify queue %d: missing vq/vc notify\\r\\n\",\n\t\t\t\tname, (int)value);\n\t\tbreak;\n\tcase VTCFG_R_STATUS:\n\t\tvs->vs_status = (uint8_t) value;\n\t\tif (value == 0)\n\t\t\t(*vc->vc_reset)(DEV_SOFTC(vs));\n\t\tbreak;\n\tcase VTCFG_R_CFGVEC:\n\t\tvs->vs_msix_cfg_idx = (uint16_t) value;\n\t\tbreak;\n\tcase VTCFG_R_QVEC:\n\t\tif (vs->vs_curq >= vc->vc_nvq)\n\t\t\tgoto bad_qindex;\n\t\tvq = &vs->vs_queues[vs->vs_curq];\n\t\tvq->vq_msix_idx = (uint16_t) value;\n\t\tbreak;\n\t}\n\tgoto done;\n\nbad_qindex:\n\tfprintf(stderr,\n\t    \"%s: write config reg %s: curq %d >= max %d\\r\\n\",\n\t    name, cr->cr_name, vs->vs_curq, vc->vc_nvq);\ndone:\n\tif (vs->vs_mtx)\n\t\tpthread_mutex_unlock(vs->vs_mtx);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 684,
    "critical_vars": [
      "vc->vc_cfgwrite"
    ],
    "function": "vi_pci_write",
    "filename": "hyperkit/CVE-2021-32844/CVE-2021-32844_CWE-476_451558fe8aaa8b24e02e34106e3bb9fe41d7ad13_virtio.c.diff",
    "function_code": "vi_pci_write(UNUSED int vcpu, struct pci_devinst *pi, int baridx,\n\tuint64_t offset, int size, uint64_t value)\n{\n\tstruct virtio_softc *vs = pi->pi_arg;\n\tstruct vqueue_info *vq;\n\tstruct virtio_consts *vc;\n\tstruct config_reg *cr;\n\tuint64_t virtio_config_size, max;\n\tconst char *name;\n\tuint32_t newoff;\n\tint error;\n\n\tif (vs->vs_flags & VIRTIO_USE_MSIX) {\n\t\tif (baridx == pci_msix_table_bar(pi) ||\n\t\t    baridx == pci_msix_pba_bar(pi)) {\n\t\t\tpci_emul_msix_twrite(pi, offset, size, value);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* XXX probably should do something better than just assert() */\n\tassert(baridx == 0);\n\n\tif (vs->vs_mtx)\n\t\tpthread_mutex_lock(vs->vs_mtx);\n\n\tvc = vs->vs_vc;\n\tname = vc->vc_name;\n\n\tif (size != 1 && size != 2 && size != 4)\n\t\tgoto bad;\n\n\tif (pci_msix_enabled(pi))\n\t\tvirtio_config_size = VTCFG_R_CFG1;\n\telse\n\t\tvirtio_config_size = VTCFG_R_CFG0;\n\n\tif (offset >= virtio_config_size) {\n\t\t/*\n\t\t * Subtract off the standard size (including MSI-X\n\t\t * registers if enabled) and dispatch to underlying driver.\n\t\t */\n\t\tnewoff = (uint32_t) (offset - virtio_config_size);\n\t\tmax = vc->vc_cfgsize ? vc->vc_cfgsize : 0x100000000;\n\t\tif ((newoff + ((unsigned) size)) > max)\n\t\t\tgoto bad;\n\t\tif (vc->vc_cfgwrite != NULL)\n\t\t\terror = (*vc->vc_cfgwrite)(DEV_SOFTC(vs), ((int) newoff), size,\n\t\t\t\t((uint32_t) value));\n\t\telse\n\t\t\terror = 0;\n\t\tif (!error)\n\t\t\tgoto done;\n\t}\n\nbad:\n\tcr = vi_find_cr((int) offset);\n\tif (cr == NULL || cr->cr_size != size || cr->cr_ro) {\n\t\tif (cr != NULL) {\n\t\t\t/* offset must be OK, wrong size and/or reg is R/O */\n\t\t\tif (cr->cr_size != size)\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"%s: write to %s: bad size %d\\r\\n\",\n\t\t\t\t    name, cr->cr_name, size);\n\t\t\tif (cr->cr_ro)\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"%s: write to read-only reg %s\\r\\n\",\n\t\t\t\t    name, cr->cr_name);\n\t\t} else {\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s: write to bad offset/size %jd/%d\\r\\n\",\n\t\t\t    name, (uintmax_t)offset, size);\n\t\t}\n\t\tgoto done;\n\t}\n\n\tswitch (offset) {\n\tcase VTCFG_R_GUESTCAP:\n\t\tvs->vs_negotiated_caps = (uint32_t) (value & vc->vc_hv_caps);\n\t\tif (vc->vc_apply_features)\n\t\t\t(*vc->vc_apply_features)(DEV_SOFTC(vs),\n\t\t\t    vs->vs_negotiated_caps);\n\t\tbreak;\n\tcase VTCFG_R_PFN:\n\t\tif (vs->vs_curq >= vc->vc_nvq)\n\t\t\tgoto bad_qindex;\n\t\tvi_vq_init(vs, ((uint32_t) value));\n\t\tbreak;\n\tcase VTCFG_R_QSEL:\n\t\t/*\n\t\t * Note that the guest is allowed to select an\n\t\t * invalid queue; we just need to return a QNUM\n\t\t * of 0 while the bad queue is selected.\n\t\t */\n\t\tvs->vs_curq = (int) value;\n\t\tbreak;\n\tcase VTCFG_R_QNOTIFY:\n\t\tif (value >= ((uint64_t) vc->vc_nvq)) {\n\t\t\tfprintf(stderr, \"%s: queue %d notify out of range\\r\\n\",\n\t\t\t\tname, (int)value);\n\t\t\tgoto done;\n\t\t}\n\t\tvq = &vs->vs_queues[value];\n\t\tif (vq->vq_notify)\n\t\t\t(*vq->vq_notify)(DEV_SOFTC(vs), vq);\n\t\telse if (vc->vc_qnotify)\n\t\t\t(*vc->vc_qnotify)(DEV_SOFTC(vs), vq);\n\t\telse\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s: qnotify queue %d: missing vq/vc notify\\r\\n\",\n\t\t\t\tname, (int)value);\n\t\tbreak;\n\tcase VTCFG_R_STATUS:\n\t\tvs->vs_status = (uint8_t) value;\n\t\tif (value == 0)\n\t\t\t(*vc->vc_reset)(DEV_SOFTC(vs));\n\t\tbreak;\n\tcase VTCFG_R_CFGVEC:\n\t\tvs->vs_msix_cfg_idx = (uint16_t) value;\n\t\tbreak;\n\tcase VTCFG_R_QVEC:\n\t\tif (vs->vs_curq >= vc->vc_nvq)\n\t\t\tgoto bad_qindex;\n\t\tvq = &vs->vs_queues[vs->vs_curq];\n\t\tvq->vq_msix_idx = (uint16_t) value;\n\t\tbreak;\n\t}\n\tgoto done;\n\nbad_qindex:\n\tfprintf(stderr,\n\t    \"%s: write config reg %s: curq %d >= max %d\\r\\n\",\n\t    name, cr->cr_name, vs->vs_curq, vc->vc_nvq);\ndone:\n\tif (vs->vs_mtx)\n\t\tpthread_mutex_unlock(vs->vs_mtx);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 562,
    "critical_vars": [
      "error"
    ],
    "function": "vi_pci_read",
    "filename": "hyperkit/CVE-2021-32843/CVE-2021-32843_CWE-476_df0e46c7dbfd81a957d85e449ba41b52f6f7beb4_virtio.c.diff",
    "function_code": "vi_pci_read(UNUSED int vcpu, struct pci_devinst *pi, int baridx,\n\tuint64_t offset, int size)\n{\n\tstruct virtio_softc *vs = pi->pi_arg;\n\tstruct virtio_consts *vc;\n\tstruct config_reg *cr;\n\tuint64_t virtio_config_size, max;\n\tconst char *name;\n\tuint32_t newoff;\n\tuint32_t value;\n\tint error;\n\n\tif (vs->vs_flags & VIRTIO_USE_MSIX) {\n\t\tif (baridx == pci_msix_table_bar(pi) ||\n\t\t    baridx == pci_msix_pba_bar(pi)) {\n\t\t\treturn (pci_emul_msix_tread(pi, offset, size));\n\t\t}\n\t}\n\n\t/* XXX probably should do something better than just assert() */\n\tassert(baridx == 0);\n\n\tif (vs->vs_mtx)\n\t\tpthread_mutex_lock(vs->vs_mtx);\n\n\tvc = vs->vs_vc;\n\tname = vc->vc_name;\n\tvalue = size == 1 ? 0xff : size == 2 ? 0xffff : 0xffffffff;\n\n\tif (size != 1 && size != 2 && size != 4)\n\t\tgoto bad;\n\n\tif (pci_msix_enabled(pi))\n\t\tvirtio_config_size = VTCFG_R_CFG1;\n\telse\n\t\tvirtio_config_size = VTCFG_R_CFG0;\n\n\tif (offset >= virtio_config_size) {\n\t\t/*\n\t\t * Subtract off the standard size (including MSI-X\n\t\t * registers if enabled) and dispatch to underlying driver.\n\t\t * If that fails, fall into general code.\n\t\t */\n\t\tnewoff = (uint32_t) (offset - virtio_config_size);\n\t\tmax = vc->vc_cfgsize ? vc->vc_cfgsize : 0x100000000;\n\t\tif ((newoff + ((unsigned) size)) > max)\n\t\t\tgoto bad;\n\t\terror = (*vc->vc_cfgread)(DEV_SOFTC(vs), ((int) newoff), size, &value);\n\t\tif (!error)\n\t\t\tgoto done;\n\t}\n\nbad:\n\tcr = vi_find_cr((int) offset);\n\tif (cr == NULL || cr->cr_size != size) {\n\t\tif (cr != NULL) {\n\t\t\t/* offset must be OK, so size must be bad */\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s: read from %s: bad size %d\\r\\n\",\n\t\t\t    name, cr->cr_name, size);\n\t\t} else {\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s: read from bad offset/size %jd/%d\\r\\n\",\n\t\t\t    name, (uintmax_t)offset, size);\n\t\t}\n\t\tgoto done;\n\t}\n\n\tswitch (offset) {\n\tcase VTCFG_R_HOSTCAP:\n\t\tvalue = (uint32_t) vc->vc_hv_caps;\n\t\tbreak;\n\tcase VTCFG_R_GUESTCAP:\n\t\tvalue = vs->vs_negotiated_caps;\n\t\tbreak;\n\tcase VTCFG_R_PFN:\n\t\tif (vs->vs_curq < vc->vc_nvq)\n\t\t\tvalue = vs->vs_queues[vs->vs_curq].vq_pfn;\n\t\tbreak;\n\tcase VTCFG_R_QNUM:\n\t\tvalue = vs->vs_curq < vc->vc_nvq ?\n\t\t    vs->vs_queues[vs->vs_curq].vq_qsize : 0;\n\t\tbreak;\n\tcase VTCFG_R_QSEL:\n\t\tvalue = (uint32_t) (vs->vs_curq);\n\t\tbreak;\n\tcase VTCFG_R_QNOTIFY:\n\t\tvalue = 0;\t/* XXX */\n\t\tbreak;\n\tcase VTCFG_R_STATUS:\n\t\tvalue = vs->vs_status;\n\t\tbreak;\n\tcase VTCFG_R_ISR:\n\t\tvalue = vs->vs_isr;\n\t\tvs->vs_isr = 0;\t\t/* a read clears this flag */\n\t\tif (value)\n\t\t\tpci_lintr_deassert(pi);\n\t\tbreak;\n\tcase VTCFG_R_CFGVEC:\n\t\tvalue = vs->vs_msix_cfg_idx;\n\t\tbreak;\n\tcase VTCFG_R_QVEC:\n\t\tvalue = vs->vs_curq < vc->vc_nvq ?\n\t\t    vs->vs_queues[vs->vs_curq].vq_msix_idx :\n\t\t    VIRTIO_MSI_NO_VECTOR;\n\t\tbreak;\n\t}\ndone:\n\tif (vs->vs_mtx)\n\t\tpthread_mutex_unlock(vs->vs_mtx);\n\treturn (value);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 562,
    "critical_vars": [
      "vc->vc_cfgread"
    ],
    "function": "vi_pci_read",
    "filename": "hyperkit/CVE-2021-32843/CVE-2021-32843_CWE-476_df0e46c7dbfd81a957d85e449ba41b52f6f7beb4_virtio.c.diff",
    "function_code": "vi_pci_read(UNUSED int vcpu, struct pci_devinst *pi, int baridx,\n\tuint64_t offset, int size)\n{\n\tstruct virtio_softc *vs = pi->pi_arg;\n\tstruct virtio_consts *vc;\n\tstruct config_reg *cr;\n\tuint64_t virtio_config_size, max;\n\tconst char *name;\n\tuint32_t newoff;\n\tuint32_t value;\n\tint error;\n\n\tif (vs->vs_flags & VIRTIO_USE_MSIX) {\n\t\tif (baridx == pci_msix_table_bar(pi) ||\n\t\t    baridx == pci_msix_pba_bar(pi)) {\n\t\t\treturn (pci_emul_msix_tread(pi, offset, size));\n\t\t}\n\t}\n\n\t/* XXX probably should do something better than just assert() */\n\tassert(baridx == 0);\n\n\tif (vs->vs_mtx)\n\t\tpthread_mutex_lock(vs->vs_mtx);\n\n\tvc = vs->vs_vc;\n\tname = vc->vc_name;\n\tvalue = size == 1 ? 0xff : size == 2 ? 0xffff : 0xffffffff;\n\n\tif (size != 1 && size != 2 && size != 4)\n\t\tgoto bad;\n\n\tif (pci_msix_enabled(pi))\n\t\tvirtio_config_size = VTCFG_R_CFG1;\n\telse\n\t\tvirtio_config_size = VTCFG_R_CFG0;\n\n\tif (offset >= virtio_config_size) {\n\t\t/*\n\t\t * Subtract off the standard size (including MSI-X\n\t\t * registers if enabled) and dispatch to underlying driver.\n\t\t * If that fails, fall into general code.\n\t\t */\n\t\tnewoff = (uint32_t) (offset - virtio_config_size);\n\t\tmax = vc->vc_cfgsize ? vc->vc_cfgsize : 0x100000000;\n\t\tif ((newoff + ((unsigned) size)) > max)\n\t\t\tgoto bad;\n\t\tif (vc->vc_cfgread != NULL)\n\t\t\terror = (*vc->vc_cfgread)(DEV_SOFTC(vs), ((int) newoff), size, &value);\n\t\telse\n\t\t\terror = 0;\n\t\tif (!error)\n\t\t\tgoto done;\n\t}\n\nbad:\n\tcr = vi_find_cr((int) offset);\n\tif (cr == NULL || cr->cr_size != size) {\n\t\tif (cr != NULL) {\n\t\t\t/* offset must be OK, so size must be bad */\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s: read from %s: bad size %d\\r\\n\",\n\t\t\t    name, cr->cr_name, size);\n\t\t} else {\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s: read from bad offset/size %jd/%d\\r\\n\",\n\t\t\t    name, (uintmax_t)offset, size);\n\t\t}\n\t\tgoto done;\n\t}\n\n\tswitch (offset) {\n\tcase VTCFG_R_HOSTCAP:\n\t\tvalue = (uint32_t) vc->vc_hv_caps;\n\t\tbreak;\n\tcase VTCFG_R_GUESTCAP:\n\t\tvalue = vs->vs_negotiated_caps;\n\t\tbreak;\n\tcase VTCFG_R_PFN:\n\t\tif (vs->vs_curq < vc->vc_nvq)\n\t\t\tvalue = vs->vs_queues[vs->vs_curq].vq_pfn;\n\t\tbreak;\n\tcase VTCFG_R_QNUM:\n\t\tvalue = vs->vs_curq < vc->vc_nvq ?\n\t\t    vs->vs_queues[vs->vs_curq].vq_qsize : 0;\n\t\tbreak;\n\tcase VTCFG_R_QSEL:\n\t\tvalue = (uint32_t) (vs->vs_curq);\n\t\tbreak;\n\tcase VTCFG_R_QNOTIFY:\n\t\tvalue = 0;\t/* XXX */\n\t\tbreak;\n\tcase VTCFG_R_STATUS:\n\t\tvalue = vs->vs_status;\n\t\tbreak;\n\tcase VTCFG_R_ISR:\n\t\tvalue = vs->vs_isr;\n\t\tvs->vs_isr = 0;\t\t/* a read clears this flag */\n\t\tif (value)\n\t\t\tpci_lintr_deassert(pi);\n\t\tbreak;\n\tcase VTCFG_R_CFGVEC:\n\t\tvalue = vs->vs_msix_cfg_idx;\n\t\tbreak;\n\tcase VTCFG_R_QVEC:\n\t\tvalue = vs->vs_curq < vc->vc_nvq ?\n\t\t    vs->vs_queues[vs->vs_curq].vq_msix_idx :\n\t\t    VIRTIO_MSI_NO_VECTOR;\n\t\tbreak;\n\t}\ndone:\n\tif (vs->vs_mtx)\n\t\tpthread_mutex_unlock(vs->vs_mtx);\n\treturn (value);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 236,
    "critical_vars": [
      "iterator"
    ],
    "function": "rfbClientIteratorNext",
    "filename": "libvncserver/CVE-2020-14397/CVE-2020-14397_CWE-476_38e98ee61d74f5f5ab4aa4c77146faad1962d6d0_rfbserver.c.diff",
    "function_code": "rfbClientIteratorNext(rfbClientIteratorPtr i)\n{\n  if (!i)\n    return NULL;\n  if(i->next == 0) {\n    LOCK(rfbClientListMutex);\n    i->next = i->screen->clientHead;\n    UNLOCK(rfbClientListMutex);\n  } else {\n    rfbClientPtr cl = i->next;\n    i->next = i->next->next;\n    rfbDecrClientRef(cl);\n  }\n\n#if defined(LIBVNCSERVER_HAVE_LIBPTHREAD) || defined(LIBVNCSERVER_HAVE_WIN32THREADS)\n    if(!i->closedToo)\n      while(i->next && i->next->sock<0)\n        i->next = i->next->next;\n    if(i->next)\n      rfbIncrClientRef(i->next);\n#endif\n\n    return i->next;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 151,
    "critical_vars": [
      "buffer"
    ],
    "function": "op_get_data",
    "filename": "opusfile/CVE-2022-47021/CVE-2022-47021_CWE-476_0a4cd796df5b030cb866f3f4a5e41a4b92caddf5_opusfile.c.diff",
    "function_code": "static int op_get_data(OggOpusFile *_of,int _nbytes){\n  unsigned char *buffer;\n  int            nbytes;\n  OP_ASSERT(_nbytes>0);\n  buffer=(unsigned char *)ogg_sync_buffer(&_of->oy,_nbytes);\n  if(OP_UNLIKELY(buffer==NULL))return OP_EFAULT;\n  nbytes=(int)(*_of->callbacks.read)(_of->stream,buffer,_nbytes);\n  OP_ASSERT(nbytes<=_nbytes);\n  if(OP_LIKELY(nbytes>0))ogg_sync_wrote(&_of->oy,nbytes);\n  return nbytes;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1531,
    "critical_vars": [
      "buffer"
    ],
    "function": "op_open1",
    "filename": "opusfile/CVE-2022-47021/CVE-2022-47021_CWE-476_0a4cd796df5b030cb866f3f4a5e41a4b92caddf5_opusfile.c.diff",
    "function_code": "static int op_open1(OggOpusFile *_of,\n void *_stream,const OpusFileCallbacks *_cb,\n const unsigned char *_initial_data,size_t _initial_bytes){\n  ogg_page  og;\n  ogg_page *pog;\n  int       seekable;\n  int       ret;\n  memset(_of,0,sizeof(*_of));\n  if(OP_UNLIKELY(_initial_bytes>(size_t)LONG_MAX))return OP_EFAULT;\n  _of->end=-1;\n  _of->stream=_stream;\n  *&_of->callbacks=*_cb;\n  /*At a minimum, we need to be able to read data.*/\n  if(OP_UNLIKELY(_of->callbacks.read==NULL))return OP_EREAD;\n  /*Initialize the framing state.*/\n  ogg_sync_init(&_of->oy);\n  /*Perhaps some data was previously read into a buffer for testing against\n     other stream types.\n    Allow initialization from this previously read data (especially as we may\n     be reading from a non-seekable stream).\n    This requires copying it into a buffer allocated by ogg_sync_buffer() and\n     doesn't support seeking, so this is not a good mechanism to use for\n     decoding entire files from RAM.*/\n  if(_initial_bytes>0){\n    char *buffer;\n    buffer=ogg_sync_buffer(&_of->oy,(long)_initial_bytes);\n    if(OP_UNLIKELY(buffer==NULL))return OP_EFAULT;\n    memcpy(buffer,_initial_data,_initial_bytes*sizeof(*buffer));\n    ogg_sync_wrote(&_of->oy,(long)_initial_bytes);\n  }\n  /*Can we seek?\n    Stevens suggests the seek test is portable.\n    It's actually not for files on win32, but we address that by fixing it in\n     our callback implementation (see stream.c).*/\n  seekable=_cb->seek!=NULL&&(*_cb->seek)(_stream,0,SEEK_CUR)!=-1;\n  /*If seek is implemented, tell must also be implemented.*/\n  if(seekable){\n    opus_int64 pos;\n    if(OP_UNLIKELY(_of->callbacks.tell==NULL))return OP_EINVAL;\n    pos=(*_of->callbacks.tell)(_of->stream);\n    /*If the current position is not equal to the initial bytes consumed,\n       absolute seeking will not work.*/\n    if(OP_UNLIKELY(pos!=(opus_int64)_initial_bytes))return OP_EINVAL;\n  }\n  _of->seekable=seekable;\n  /*Don't seek yet.\n    Set up a 'single' (current) logical bitstream entry for partial open.*/\n  _of->links=(OggOpusLink *)_ogg_malloc(sizeof(*_of->links));\n  /*The serialno gets filled in later by op_fetch_headers().*/\n  ogg_stream_init(&_of->os,-1);\n  pog=NULL;\n  for(;;){\n    /*Fetch all BOS pages, store the Opus header and all seen serial numbers,\n      and load subsequent Opus setup headers.*/\n    ret=op_fetch_headers(_of,&_of->links[0].head,&_of->links[0].tags,\n     &_of->serialnos,&_of->nserialnos,&_of->cserialnos,pog);\n    if(OP_UNLIKELY(ret<0))break;\n    _of->nlinks=1;\n    _of->links[0].offset=0;\n    _of->links[0].data_offset=_of->offset;\n    _of->links[0].pcm_end=-1;\n    _of->links[0].serialno=_of->os.serialno;\n    /*Fetch the initial PCM offset.*/\n    ret=op_find_initial_pcm_offset(_of,_of->links,&og);\n    if(seekable||OP_LIKELY(ret<=0))break;\n    /*This link was empty, but we already have the BOS page for the next one in\n       og.\n      We can't seek, so start processing the next link right now.*/\n    opus_tags_clear(&_of->links[0].tags);\n    _of->nlinks=0;\n    if(!seekable)_of->cur_link++;\n    pog=&og;\n  }\n  if(OP_LIKELY(ret>=0))_of->ready_state=OP_PARTOPEN;\n  return ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1853,
    "critical_vars": [
      "protocol",
      "ext_port",
      "int_port"
    ],
    "function": "GetOutboundPinholeTimeout",
    "filename": "miniupnp/CVE-2019-12108/CVE-2019-12108_CWE-476_13585f15c7f7dc28bbbba1661efb280d530d114c_upnpsoap.c.diff",
    "function_code": "GetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<OutboundPinholeTimeout>%d</OutboundPinholeTimeout>\"\n\t\t\"</u:%sResponse>\";\n\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tchar * int_ip, * int_port, * rem_host, * rem_port, * protocol;\n\tint opt=0;\n\t/*int proto=0;*/\n\tunsigned short iport, rport;\n\n\tif (GETFLAG(IPV6FCFWDISABLEDMASK))\n\t{\n\t\tSoapError(h, 702, \"FirewallDisabled\");\n\t\treturn;\n\t}\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tint_ip = GetValueFromNameValueList(&data, \"InternalClient\");\n\tint_port = GetValueFromNameValueList(&data, \"InternalPort\");\n\trem_host = GetValueFromNameValueList(&data, \"RemoteHost\");\n\trem_port = GetValueFromNameValueList(&data, \"RemotePort\");\n\tprotocol = GetValueFromNameValueList(&data, \"Protocol\");\n\n\tif (!int_port || !ext_port || !protocol)\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n\n\trport = (unsigned short)atoi(rem_port);\n\tiport = (unsigned short)atoi(int_port);\n\t/*proto = atoi(protocol);*/\n\n\tsyslog(LOG_INFO, \"%s: retrieving timeout for outbound pinhole from [%s]:%hu to [%s]:%hu protocol %s\", action, int_ip, iport,rem_host, rport, protocol);\n\n\t/* TODO */\n\tr = -1;/*upnp_check_outbound_pinhole(proto, &opt);*/\n\n\tswitch(r)\n\t{\n\t\tcase 1:\t/* success */\n\t\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t\t                   action, ns/*\"urn:schemas-upnp-org:service:WANIPv6FirewallControl:1\"*/,\n\t\t\t                   opt, action);\n\t\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t\t\tbreak;\n\t\tcase -5:\t/* Protocol not supported */\n\t\t\tSoapError(h, 705, \"ProtocolNotSupported\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tSoapError(h, 501, \"ActionFailed\");\n\t}\n\tClearNameValueList(&data);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 1853,
    "critical_vars": [
      "ext_port"
    ],
    "function": "GetOutboundPinholeTimeout",
    "filename": "miniupnp/CVE-2019-12108/CVE-2019-12108_CWE-476_86030db849260dd8fb2ed975b9890aef1b62b692_upnpsoap.c.diff",
    "function_code": "GetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<OutboundPinholeTimeout>%d</OutboundPinholeTimeout>\"\n\t\t\"</u:%sResponse>\";\n\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tchar * int_ip, * int_port, * rem_host, * rem_port, * protocol;\n\tint opt=0;\n\t/*int proto=0;*/\n\tunsigned short iport, rport;\n\n\tif (GETFLAG(IPV6FCFWDISABLEDMASK))\n\t{\n\t\tSoapError(h, 702, \"FirewallDisabled\");\n\t\treturn;\n\t}\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tint_ip = GetValueFromNameValueList(&data, \"InternalClient\");\n\tint_port = GetValueFromNameValueList(&data, \"InternalPort\");\n\trem_host = GetValueFromNameValueList(&data, \"RemoteHost\");\n\trem_port = GetValueFromNameValueList(&data, \"RemotePort\");\n\tprotocol = GetValueFromNameValueList(&data, \"Protocol\");\n\n\tif (!int_port || !ext_port || !protocol)\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n\n\trport = (unsigned short)atoi(rem_port);\n\tiport = (unsigned short)atoi(int_port);\n\t/*proto = atoi(protocol);*/\n\n\tsyslog(LOG_INFO, \"%s: retrieving timeout for outbound pinhole from [%s]:%hu to [%s]:%hu protocol %s\", action, int_ip, iport,rem_host, rport, protocol);\n\n\t/* TODO */\n\tr = -1;/*upnp_check_outbound_pinhole(proto, &opt);*/\n\n\tswitch(r)\n\t{\n\t\tcase 1:\t/* success */\n\t\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t\t                   action, ns/*\"urn:schemas-upnp-org:service:WANIPv6FirewallControl:1\"*/,\n\t\t\t                   opt, action);\n\t\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t\t\tbreak;\n\t\tcase -5:\t/* Protocol not supported */\n\t\t\tSoapError(h, 705, \"ProtocolNotSupported\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tSoapError(h, 501, \"ActionFailed\");\n\t}\n\tClearNameValueList(&data);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 360,
    "critical_vars": [
      "desc"
    ],
    "function": "upnp_redirect",
    "filename": "miniupnp/CVE-2019-12110/CVE-2019-12110_CWE-476_f321c2066b96d18afa5158dfa2d2873a2957ef38_upnpredirect.c.diff",
    "function_code": "upnp_redirect(const char * rhost, unsigned short eport,\n              const char * iaddr, unsigned short iport,\n              const char * protocol, const char * desc,\n              unsigned int leaseduration)\n{\n\tint proto, r;\n\tchar iaddr_old[32];\n\tchar rhost_old[32];\n\tunsigned short iport_old;\n\tstruct in_addr address;\n\tunsigned int timestamp;\n\n\tproto = proto_atoi(protocol);\n\tif(inet_aton(iaddr, &address) <= 0) {\n\t\tsyslog(LOG_ERR, \"inet_aton(%s) FAILED\", iaddr);\n\t\treturn -1;\n\t}\n\n\tif(!check_upnp_rule_against_permissions(upnppermlist, num_upnpperm,\n\t                                        eport, address, iport)) {\n\t\tsyslog(LOG_INFO, \"redirection permission check failed for \"\n\t\t                 \"%hu->%s:%hu %s\", eport, iaddr, iport, protocol);\n\t\treturn -3;\n\t}\n\n\tif (desc == NULL)\n\t\tdesc = \"\";\t/* assume empty description */\n\n\t/* IGDv1 (WANIPConnection:1 Service Template Version 1.01 / Nov 12, 2001)\n\t * - 2.2.20.PortMappingDescription :\n\t *  Overwriting Previous / Existing Port Mappings:\n\t * If the RemoteHost, ExternalPort, PortMappingProtocol and InternalClient\n\t * are exactly the same as an existing mapping, the existing mapping values\n\t * for InternalPort, PortMappingDescription, PortMappingEnabled and\n\t * PortMappingLeaseDuration are overwritten.\n\t *  Rejecting a New Port Mapping:\n\t * In cases where the RemoteHost, ExternalPort and PortMappingProtocol\n\t * are the same as an existing mapping, but the InternalClient is\n\t * different, the action is rejected with an appropriate error.\n\t *  Add or Reject New Port Mapping behavior based on vendor implementation:\n\t * In cases where the ExternalPort, PortMappingProtocol and InternalClient\n\t * are the same, but RemoteHost is different, the vendor can choose to\n\t * support both mappings simultaneously, or reject the second mapping\n\t * with an appropriate error.\n\t *\n\t * - 2.4.16.AddPortMapping\n\t * This action creates a new port mapping or overwrites an existing\n\t * mapping with the same internal client. If the ExternalPort and\n\t * PortMappingProtocol pair is already mapped to another internal client,\n\t * an error is returned.\n\t *\n\t * IGDv2 (WANIPConnection:2 Service Standardized DCP (SDCP) Sep 10, 2010)\n\t * Protocol ExternalPort RemoteHost InternalClient Result\n\t *     =         =                               Failure\n\t *     =         =                      =         Failure or success\n\t *                                                 (vendor specific)\n\t *     =         =           =                    Failure\n\t *     =         =           =           =         Success (overwrite)\n\t */\n\trhost_old[0] = '\\0';\n\tr = get_redirect_rule(ext_if_name, eport, proto,\n\t                      iaddr_old, sizeof(iaddr_old), &iport_old, 0, 0,\n\t                      rhost_old, sizeof(rhost_old),\n\t                      &timestamp, 0, 0);\n\tif(r == 0) {\n\t\tif(strcmp(iaddr, iaddr_old)==0 &&\n\t\t   ((rhost == NULL && rhost_old[0]=='\\0') ||\n\t\t    (rhost && (strcmp(rhost, \"*\") == 0) && rhost_old[0]=='\\0') ||\n\t\t    (rhost && (strcmp(rhost, rhost_old) == 0)))) {\n\t\t\tsyslog(LOG_INFO, \"updating existing port mapping %hu %s (rhost '%s') => %s:%hu\",\n\t\t\t\teport, protocol, rhost_old, iaddr_old, iport_old);\n\t\t\ttimestamp = (leaseduration > 0) ? upnp_time() + leaseduration : 0;\n\t\t\tif(iport != iport_old) {\n\t\t\t\tr = update_portmapping(ext_if_name, eport, proto, iport, desc, timestamp);\n\t\t\t} else {\n\t\t\t\tr = update_portmapping_desc_timestamp(ext_if_name, eport, proto, desc, timestamp);\n\t\t\t}\n#ifdef ENABLE_LEASEFILE\n\t\t\tif(r == 0) {\n\t\t\t\tlease_file_remove(eport, proto);\n\t\t\t\tlease_file_add(eport, iaddr, iport, proto, desc, timestamp);\n\t\t\t}\n#endif /* ENABLE_LEASEFILE */\n\t\t\treturn r;\n\t\t} else {\n\t\t\tsyslog(LOG_INFO, \"port %hu %s (rhost '%s') already redirected to %s:%hu\",\n\t\t\t\teport, protocol, rhost_old, iaddr_old, iport_old);\n\t\t\treturn -2;\n\t\t}\n#ifdef CHECK_PORTINUSE\n\t} else if (port_in_use(ext_if_name, eport, proto, iaddr, iport) > 0) {\n\t\tsyslog(LOG_INFO, \"port %hu protocol %s already in use\",\n\t\t       eport, protocol);\n\t\treturn -4;\n#endif /* CHECK_PORTINUSE */\n\t} else {\n\t\ttimestamp = (leaseduration > 0) ? upnp_time() + leaseduration : 0;\n\t\tsyslog(LOG_INFO, \"redirecting port %hu to %s:%hu protocol %s for: %s\",\n\t\t\teport, iaddr, iport, protocol, desc);\n\t\treturn upnp_redirect_internal(rhost, eport, iaddr, iport, proto,\n\t\t                              desc, timestamp);\n\t}\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 244,
    "critical_vars": [
      "file->file_type",
      "ctx"
    ],
    "function": "CompileKeymap",
    "filename": "libxkbcommon/CVE-2018-15855/CVE-2018-15855_CWE-476_917636b1d0d70205a13f89062b95e3a0fc31d4ff_keymap.c.diff",
    "function_code": "CompileKeymap(XkbFile *file, struct xkb_keymap *keymap, enum merge_mode merge)\n{\n    bool ok;\n    XkbFile *files[LAST_KEYMAP_FILE_TYPE + 1] = { NULL };\n    enum xkb_file_type type;\n    struct xkb_context *ctx = keymap->ctx;\n\n    /* Collect section files and check for duplicates. */\n    for (file = (XkbFile *) file->defs; file;\n         file = (XkbFile *) file->common.next) {\n        if (file->file_type < FIRST_KEYMAP_FILE_TYPE ||\n            file->file_type > LAST_KEYMAP_FILE_TYPE) {\n            log_err(ctx, \"Cannot define %s in a keymap file\\n\",\n                    xkb_file_type_to_string(file->file_type));\n            continue;\n        }\n\n        if (files[file->file_type]) {\n            log_err(ctx,\n                    \"More than one %s section in keymap file; \"\n                    \"All sections after the first ignored\\n\",\n                    xkb_file_type_to_string(file->file_type));\n            continue;\n        }\n\n        files[file->file_type] = file;\n    }\n\n    /*\n     * Check that all required section were provided.\n     * Report everything before failing.\n     */\n    ok = true;\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        if (files[type] == NULL) {\n            log_err(ctx, \"Required section %s missing from keymap\\n\",\n                    xkb_file_type_to_string(type));\n            ok = false;\n        }\n    }\n    if (!ok)\n        return false;\n\n    /* Compile sections. */\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        log_dbg(ctx, \"Compiling %s \\\"%s\\\"\\n\",\n                xkb_file_type_to_string(type), files[type]->name);\n\n        ok = compile_file_fns[type](files[type], keymap, merge);\n        if (!ok) {\n            log_err(ctx, \"Failed to compile %s\\n\",\n                    xkb_file_type_to_string(type));\n            return false;\n        }\n    }\n\n    return UpdateDerivedKeymapFields(keymap);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 244,
    "critical_vars": [
      "file->file_type"
    ],
    "function": "CompileKeymap",
    "filename": "libxkbcommon/CVE-2018-15855/CVE-2018-15855_CWE-476_917636b1d0d70205a13f89062b95e3a0fc31d4ff_keymap.c.diff",
    "function_code": "CompileKeymap(XkbFile *file, struct xkb_keymap *keymap, enum merge_mode merge)\n{\n    bool ok;\n    XkbFile *files[LAST_KEYMAP_FILE_TYPE + 1] = { NULL };\n    enum xkb_file_type type;\n    struct xkb_context *ctx = keymap->ctx;\n\n    /* Collect section files and check for duplicates. */\n    for (file = (XkbFile *) file->defs; file;\n         file = (XkbFile *) file->common.next) {\n        if (file->file_type < FIRST_KEYMAP_FILE_TYPE ||\n            file->file_type > LAST_KEYMAP_FILE_TYPE) {\n            if (file->file_type == FILE_TYPE_GEOMETRY) {\n                log_vrb(ctx, 1,\n                        \"Geometry sections are not supported; ignoring\\n\");\n            } else {\n                log_err(ctx, \"Cannot define %s in a keymap file\\n\",\n                        xkb_file_type_to_string(file->file_type));\n            }\n            continue;\n        }\n\n        if (files[file->file_type]) {\n            log_err(ctx,\n                    \"More than one %s section in keymap file; \"\n                    \"All sections after the first ignored\\n\",\n                    xkb_file_type_to_string(file->file_type));\n            continue;\n        }\n\n        files[file->file_type] = file;\n    }\n\n    /*\n     * Check that all required section were provided.\n     * Report everything before failing.\n     */\n    ok = true;\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        if (files[type] == NULL) {\n            log_err(ctx, \"Required section %s missing from keymap\\n\",\n                    xkb_file_type_to_string(type));\n            ok = false;\n        }\n    }\n    if (!ok)\n        return false;\n\n    /* Compile sections. */\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        log_dbg(ctx, \"Compiling %s \\\"%s\\\"\\n\",\n                xkb_file_type_to_string(type), files[type]->name);\n\n        ok = compile_file_fns[type](files[type], keymap, merge);\n        if (!ok) {\n            log_err(ctx, \"Failed to compile %s\\n\",\n                    xkb_file_type_to_string(type));\n            return false;\n        }\n    }\n\n    return UpdateDerivedKeymapFields(keymap);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 104,
    "critical_vars": [
      "str"
    ],
    "function": "LookupModMask",
    "filename": "libxkbcommon/CVE-2018-15862/CVE-2018-15862_CWE-476_4e2ee9c3f6050d773f8bbe05bc0edb17f1ff8371_expr.c.diff",
    "function_code": "LookupModMask(struct xkb_context *ctx, const void *priv, xkb_atom_t field,\n              enum expr_value_type type, xkb_mod_mask_t *val_rtrn)\n{\n    const char *str;\n    xkb_mod_index_t ndx;\n    const LookupModMaskPriv *arg = priv;\n    const struct xkb_mod_set *mods = arg->mods;\n    enum mod_type mod_type = arg->mod_type;\n\n    if (type != EXPR_TYPE_INT)\n        return false;\n\n    str = xkb_atom_text(ctx, field);\n    if (!str)\n        return false;\n\n    if (istreq(str, \"all\")) {\n        *val_rtrn  = MOD_REAL_MASK_ALL;\n        return true;\n    }\n\n    if (istreq(str, \"none\")) {\n        *val_rtrn = 0;\n        return true;\n    }\n\n    ndx = XkbModNameToIndex(mods, field, mod_type);\n    if (ndx == XKB_MOD_INVALID)\n        return false;\n\n    *val_rtrn = (1u << ndx);\n    return true;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 55,
    "critical_vars": [
      "elem_rtrn",
      "expr->array_ref.element"
    ],
    "function": "ExprResolveLhs",
    "filename": "libxkbcommon/CVE-2018-15859/CVE-2018-15859_CWE-476_bb4909d2d8fa6b08155e449986a478101e2b2634_expr.c.diff",
    "function_code": "ExprResolveLhs(struct xkb_context *ctx, const ExprDef *expr,\n               const char **elem_rtrn, const char **field_rtrn,\n               ExprDef **index_rtrn)\n{\n    switch (expr->expr.op) {\n    case EXPR_IDENT:\n        *elem_rtrn = NULL;\n        *field_rtrn = xkb_atom_text(ctx, expr->ident.ident);\n        *index_rtrn = NULL;\n        return (*field_rtrn != NULL);\n    case EXPR_FIELD_REF:\n        *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element);\n        *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field);\n        *index_rtrn = NULL;\n        return (*elem_rtrn != NULL && *field_rtrn != NULL);\n    case EXPR_ARRAY_REF:\n        *elem_rtrn = xkb_atom_text(ctx, expr->array_ref.element);\n        *field_rtrn = xkb_atom_text(ctx, expr->array_ref.field);\n        *index_rtrn = expr->array_ref.entry;\n\tif (expr->array_ref.element != XKB_ATOM_NONE && *elem_rtrn == NULL)\n\t\treturn false;\n\tif (*field_rtrn == NULL)\n\t\treturn false;\n        return true;\n    default:\n        break;\n    }\n    log_wsgo(ctx, \"Unexpected operator %d in ResolveLhs\\n\", expr->expr.op);\n    return false;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 267,
    "critical_vars": [
      "pred_txt",
      "symInterpretMatchMaskNames",
      "pred_rtrn"
    ],
    "function": "ResolveStateAndPredicate",
    "filename": "libxkbcommon/CVE-2018-15863/CVE-2018-15863_CWE-476_96df3106d49438e442510c59acad306e94f3db4d_compat.c.diff",
    "function_code": "ResolveStateAndPredicate(ExprDef *expr, enum xkb_match_operation *pred_rtrn,\n                         xkb_mod_mask_t *mods_rtrn, CompatInfo *info)\n{\n    if (expr == NULL) {\n        *pred_rtrn = MATCH_ANY_OR_NONE;\n        *mods_rtrn = MOD_REAL_MASK_ALL;\n        return true;\n    }\n\n    *pred_rtrn = MATCH_EXACTLY;\n    if (expr->expr.op == EXPR_ACTION_DECL) {\n        const char *pred_txt = xkb_atom_text(info->ctx, expr->action.name);\n        if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn)) {\n            log_err(info->ctx,\n                    \"Illegal modifier predicate \\\"%s\\\"; Ignored\\n\", pred_txt);\n            return false;\n        }\n        expr = expr->action.args;\n    }\n    else if (expr->expr.op == EXPR_IDENT) {\n        const char *pred_txt = xkb_atom_text(info->ctx, expr->ident.ident);\n        if (pred_txt && istreq(pred_txt, \"any\")) {\n            *pred_rtrn = MATCH_ANY;\n            *mods_rtrn = MOD_REAL_MASK_ALL;\n            return true;\n        }\n    }\n\n    return ExprResolveModMask(info->ctx, expr, MOD_REAL, &info->mods,\n                              mods_rtrn);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 267,
    "critical_vars": [
      "expr->action.args",
      "pred_txt",
      "symInterpretMatchMaskNames",
      "pred_rtrn"
    ],
    "function": "ResolveStateAndPredicate",
    "filename": "libxkbcommon/CVE-2018-15863/CVE-2018-15863_CWE-476_96df3106d49438e442510c59acad306e94f3db4d_compat.c.diff",
    "function_code": "ResolveStateAndPredicate(ExprDef *expr, enum xkb_match_operation *pred_rtrn,\n                         xkb_mod_mask_t *mods_rtrn, CompatInfo *info)\n{\n    if (expr == NULL) {\n        *pred_rtrn = MATCH_ANY_OR_NONE;\n        *mods_rtrn = MOD_REAL_MASK_ALL;\n        return true;\n    }\n\n    *pred_rtrn = MATCH_EXACTLY;\n    if (expr->expr.op == EXPR_ACTION_DECL) {\n        const char *pred_txt = xkb_atom_text(info->ctx, expr->action.name);\n        if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn) ||\n            !expr->action.args) {\n            log_err(info->ctx,\n                    \"Illegal modifier predicate \\\"%s\\\"; Ignored\\n\", pred_txt);\n            return false;\n        }\n        expr = expr->action.args;\n    }\n    else if (expr->expr.op == EXPR_IDENT) {\n        const char *pred_txt = xkb_atom_text(info->ctx, expr->ident.ident);\n        if (pred_txt && istreq(pred_txt, \"any\")) {\n            *pred_rtrn = MATCH_ANY;\n            *mods_rtrn = MOD_REAL_MASK_ALL;\n            return true;\n        }\n    }\n\n    return ExprResolveModMask(info->ctx, expr, MOD_REAL, &info->mods,\n                              mods_rtrn);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "while-Condition",
    "line_new": 1784,
    "critical_vars": [
      "current_element->string"
    ],
    "function": "*get_object_item",
    "filename": "cJSON/CVE-2019-1010239/CVE-2019-1010239_CWE-476_be749d7efa7c9021da746e685bd6dec79f9dd99b_cJSON.c.diff",
    "function_code": "static cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)\n{\n    cJSON *current_element = NULL;\n\n    if ((object == NULL) || (name == NULL))\n    {\n        return NULL;\n    }\n\n    current_element = object->child;\n    if (case_sensitive)\n    {\n        while ((current_element != NULL) && (current_element->string != NULL) && (strcmp(name, current_element->string) != 0))\n        {\n            current_element = current_element->next;\n        }\n    }\n    else\n    {\n        while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))\n        {\n            current_element = current_element->next;\n        }\n    }\n\n    if ((current_element == NULL) || (current_element->string == NULL)) {\n        return NULL;\n    }\n\n    return current_element;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 1168,
    "critical_vars": [
      "lvar->lv_from_outer"
    ],
    "function": "generate_loadvar",
    "filename": "vim/CVE-2022-2874/CVE-2022-2874_CWE-476_4875d6ab068f09df88d24d81de40dcd8d56e243d_vim9compile.c.diff",
    "function_code": "generate_loadvar(\n\tcctx_T\t\t*cctx,\n\tassign_dest_T\tdest,\n\tchar_u\t\t*name,\n\tlvar_T\t\t*lvar,\n\ttype_T\t\t*type)\n{\n    switch (dest)\n    {\n\tcase dest_option:\n\tcase dest_func_option:\n\t    generate_LOAD(cctx, ISN_LOADOPT, 0, name, type);\n\t    break;\n\tcase dest_global:\n\t    if (vim_strchr(name, AUTOLOAD_CHAR) == NULL)\n\t    {\n\t\tif (name[2] == NUL)\n\t\t    generate_instr_type(cctx, ISN_LOADGDICT, &t_dict_any);\n\t\telse\n\t\t    generate_LOAD(cctx, ISN_LOADG, 0, name + 2, type);\n\t    }\n\t    else\n\t\tgenerate_LOAD(cctx, ISN_LOADAUTO, 0, name, type);\n\t    break;\n\tcase dest_buffer:\n\t    generate_LOAD(cctx, ISN_LOADB, 0, name + 2, type);\n\t    break;\n\tcase dest_window:\n\t    generate_LOAD(cctx, ISN_LOADW, 0, name + 2, type);\n\t    break;\n\tcase dest_tab:\n\t    generate_LOAD(cctx, ISN_LOADT, 0, name + 2, type);\n\t    break;\n\tcase dest_script:\n\t    compile_load_scriptvar(cctx,\n\t\t\t\t  name + (name[1] == ':' ? 2 : 0), NULL, NULL);\n\t    break;\n\tcase dest_env:\n\t    // Include $ in the name here\n\t    generate_LOAD(cctx, ISN_LOADENV, 0, name, type);\n\t    break;\n\tcase dest_reg:\n\t    generate_LOAD(cctx, ISN_LOADREG, name[1], NULL, &t_string);\n\t    break;\n\tcase dest_vimvar:\n\t    generate_LOADV(cctx, name + 2);\n\t    break;\n\tcase dest_local:\n\t    if (lvar->lv_from_outer > 0)\n\t\tgenerate_LOADOUTER(cctx, lvar->lv_idx, lvar->lv_from_outer,\n\t\t\t\t\t\t\t\t\t type);\n\t    else\n\t\tgenerate_LOAD(cctx, ISN_LOAD, lvar->lv_idx, NULL, type);\n\t    break;\n\tcase dest_expr:\n\t    // list or dict value should already be on the stack.\n\t    break;\n    }\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1168,
    "critical_vars": [
      "cctx->ctx_skip"
    ],
    "function": "generate_loadvar",
    "filename": "vim/CVE-2022-2874/CVE-2022-2874_CWE-476_4875d6ab068f09df88d24d81de40dcd8d56e243d_vim9compile.c.diff",
    "function_code": "generate_loadvar(\n\tcctx_T\t\t*cctx,\n\tassign_dest_T\tdest,\n\tchar_u\t\t*name,\n\tlvar_T\t\t*lvar,\n\ttype_T\t\t*type)\n{\n    switch (dest)\n    {\n\tcase dest_option:\n\tcase dest_func_option:\n\t    generate_LOAD(cctx, ISN_LOADOPT, 0, name, type);\n\t    break;\n\tcase dest_global:\n\t    if (vim_strchr(name, AUTOLOAD_CHAR) == NULL)\n\t    {\n\t\tif (name[2] == NUL)\n\t\t    generate_instr_type(cctx, ISN_LOADGDICT, &t_dict_any);\n\t\telse\n\t\t    generate_LOAD(cctx, ISN_LOADG, 0, name + 2, type);\n\t    }\n\t    else\n\t\tgenerate_LOAD(cctx, ISN_LOADAUTO, 0, name, type);\n\t    break;\n\tcase dest_buffer:\n\t    generate_LOAD(cctx, ISN_LOADB, 0, name + 2, type);\n\t    break;\n\tcase dest_window:\n\t    generate_LOAD(cctx, ISN_LOADW, 0, name + 2, type);\n\t    break;\n\tcase dest_tab:\n\t    generate_LOAD(cctx, ISN_LOADT, 0, name + 2, type);\n\t    break;\n\tcase dest_script:\n\t    compile_load_scriptvar(cctx,\n\t\t\t\t  name + (name[1] == ':' ? 2 : 0), NULL, NULL);\n\t    break;\n\tcase dest_env:\n\t    // Include $ in the name here\n\t    generate_LOAD(cctx, ISN_LOADENV, 0, name, type);\n\t    break;\n\tcase dest_reg:\n\t    generate_LOAD(cctx, ISN_LOADREG, name[1], NULL, &t_string);\n\t    break;\n\tcase dest_vimvar:\n\t    generate_LOADV(cctx, name + 2);\n\t    break;\n\tcase dest_local:\n\t    if (cctx->ctx_skip != SKIP_YES)\n\t    {\n\t\tif (lvar->lv_from_outer > 0)\n\t\t    generate_LOADOUTER(cctx, lvar->lv_idx, lvar->lv_from_outer,\n\t\t\t\t\t\t\t\t\t type);\n\t\telse\n\t\t    generate_LOAD(cctx, ISN_LOAD, lvar->lv_idx, NULL, type);\n\t    }\n\t    break;\n\tcase dest_expr:\n\t    // list or dict value should already be on the stack.\n\t    break;\n    }\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1958,
    "critical_vars": [
      "cctx->ctx_skip"
    ],
    "function": "compile_assign_unlet",
    "filename": "vim/CVE-2022-2874/CVE-2022-2874_CWE-476_4875d6ab068f09df88d24d81de40dcd8d56e243d_vim9compile.c.diff",
    "function_code": "compile_assign_unlet(\n\tchar_u\t*var_start,\n\tlhs_T\t*lhs,\n\tint\tis_assign,\n\ttype_T\t*rhs_type,\n\tcctx_T\t*cctx)\n{\n    vartype_T\tdest_type;\n    int\t\trange = FALSE;\n\n    if (compile_assign_index(var_start, lhs, &range, cctx) == FAIL)\n\treturn FAIL;\n    if (is_assign && range\n\t    && lhs->lhs_type->tt_type != VAR_LIST\n\t    && lhs->lhs_type != &t_blob\n\t    && lhs->lhs_type != &t_any)\n    {\n\tsemsg(_(e_cannot_use_range_with_assignment_str), var_start);\n\treturn FAIL;\n    }\n\n    if (lhs->lhs_type == &t_any)\n    {\n\t// Index on variable of unknown type: check at runtime.\n\tdest_type = VAR_ANY;\n    }\n    else\n    {\n\tdest_type = lhs->lhs_type->tt_type;\n\tif (dest_type == VAR_DICT && range)\n\t{\n\t    emsg(e_cannot_use_range_with_dictionary);\n\t    return FAIL;\n\t}\n\tif (dest_type == VAR_DICT\n\t\t\t      && may_generate_2STRING(-1, FALSE, cctx) == FAIL)\n\t    return FAIL;\n\tif (dest_type == VAR_LIST || dest_type == VAR_BLOB)\n\t{\n\t    type_T *type;\n\n\t    if (range)\n\t    {\n\t\ttype = get_type_on_stack(cctx, 1);\n\t\tif (need_type(type, &t_number,\n\t\t\t\t\t    -2, 0, cctx, FALSE, FALSE) == FAIL)\n\t\treturn FAIL;\n\t    }\n\t    type = get_type_on_stack(cctx, 0);\n\t    if ((dest_type != VAR_BLOB && type->tt_type != VAR_SPECIAL)\n\t\t    && need_type(type, &t_number,\n\t\t\t\t\t    -1, 0, cctx, FALSE, FALSE) == FAIL)\n\t\treturn FAIL;\n\t}\n    }\n\n    if (cctx->ctx_skip == SKIP_YES)\n\treturn OK;\n\n    // Load the dict or list.  On the stack we then have:\n    // - value (for assignment, not for :unlet)\n    // - index\n    // - for [a : b] second index\n    // - variable\n    if (compile_load_lhs(lhs, var_start, rhs_type, cctx) == FAIL)\n\treturn FAIL;\n\n    if (dest_type == VAR_LIST || dest_type == VAR_DICT\n\t\t\t      || dest_type == VAR_BLOB || dest_type == VAR_ANY)\n    {\n\tif (is_assign)\n\t{\n\t    if (range)\n\t    {\n\t\tif (generate_instr_drop(cctx, ISN_STORERANGE, 4) == NULL)\n\t\t    return FAIL;\n\t    }\n\t    else\n\t    {\n\t\tisn_T\t*isn = generate_instr_drop(cctx, ISN_STOREINDEX, 3);\n\n\t\tif (isn == NULL)\n\t\t    return FAIL;\n\t\tisn->isn_arg.vartype = dest_type;\n\t    }\n\t}\n\telse if (range)\n\t{\n\t    if (generate_instr_drop(cctx, ISN_UNLETRANGE, 3) == NULL)\n\t\treturn FAIL;\n\t}\n\telse\n\t{\n\t    if (generate_instr_drop(cctx, ISN_UNLETINDEX, 2) == NULL)\n\t\treturn FAIL;\n\t}\n    }\n    else\n    {\n\temsg(_(e_indexable_type_required));\n\treturn FAIL;\n    }\n\n    return OK;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1265,
    "critical_vars": [
      "cl"
    ],
    "function": "class_object_index",
    "filename": "vim/CVE-2023-1355/CVE-2023-1355_CWE-476_d13dd30240e32071210f55b587182ff48757ea46_vim9class.c.diff",
    "function_code": "class_object_index(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\tverbose UNUSED)\t// give error messages\n{\n    if (VIM_ISWHITE((*arg)[1]))\n    {\n\tsemsg(_(e_no_white_space_allowed_after_str_str), \".\", *arg);\n\treturn FAIL;\n    }\n\n    ++*arg;\n    char_u *name = *arg;\n    char_u *name_end = find_name_end(name, NULL, NULL, FNE_CHECK_START);\n    if (name_end == name)\n\treturn FAIL;\n    size_t len = name_end - name;\n\n    class_T *cl;\n    if (rettv->v_type == VAR_CLASS)\n\tcl = rettv->vval.v_class;\n    else // VAR_OBJECT\n    {\n\tif (rettv->vval.v_object == NULL)\n\t{\n\t    emsg(_(e_using_null_object));\n\t    return FAIL;\n\t}\n\tcl = rettv->vval.v_object->obj_class;\n    }\n\n    if (cl == NULL)\n    {\n\temsg(_(e_incomplete_type));\n\treturn FAIL;\n    }\n\n    if (*name_end == '(')\n    {\n\tint on_class = rettv->v_type == VAR_CLASS;\n\tint count = on_class ? cl->class_class_function_count\n\t\t\t     : cl->class_obj_method_count;\n\tfor (int i = 0; i < count; ++i)\n\t{\n\t    ufunc_T *fp = on_class ? cl->class_class_functions[i]\n\t\t\t\t   : cl->class_obj_methods[i];\n\t    // Use a separate pointer to avoid that ASAN complains about\n\t    // uf_name[] only being 4 characters.\n\t    char_u *ufname = (char_u *)fp->uf_name;\n\t    if (STRNCMP(name, ufname, len) == 0 && ufname[len] == NUL)\n\t    {\n\t\ttypval_T    argvars[MAX_FUNC_ARGS + 1];\n\t\tint\t    argcount = 0;\n\n\t\tchar_u *argp = name_end;\n\t\tint ret = get_func_arguments(&argp, evalarg, 0,\n\t\t\t\t\t\t\t   argvars, &argcount);\n\t\tif (ret == FAIL)\n\t\t    return FAIL;\n\n\t\tfuncexe_T   funcexe;\n\t\tCLEAR_FIELD(funcexe);\n\t\tfuncexe.fe_evaluate = TRUE;\n\t\tif (rettv->v_type == VAR_OBJECT)\n\t\t{\n\t\t    funcexe.fe_object = rettv->vval.v_object;\n\t\t    ++funcexe.fe_object->obj_refcount;\n\t\t}\n\n\t\t// Clear the class or object after calling the function, in\n\t\t// case the refcount is one.\n\t\ttypval_T tv_tofree = *rettv;\n\t\trettv->v_type = VAR_UNKNOWN;\n\n\t\t// Call the user function.  Result goes into rettv;\n\t\tint error = call_user_func_check(fp, argcount, argvars,\n\t\t\t\t\t\t\trettv, &funcexe, NULL);\n\n\t\t// Clear the previous rettv and the arguments.\n\t\tclear_tv(&tv_tofree);\n\t\tfor (int idx = 0; idx < argcount; ++idx)\n\t\t    clear_tv(&argvars[idx]);\n\n\t\tif (error != FCERR_NONE)\n\t\t{\n\t\t    user_func_error(error, printable_func_name(fp),\n\t\t\t\t\t\t\t funcexe.fe_found_var);\n\t\t    return FAIL;\n\t\t}\n\t\t*arg = argp;\n\t\treturn OK;\n\t    }\n\t}\n\n\tsemsg(_(e_method_not_found_on_class_str_str), cl->class_name, name);\n    }\n\n    else if (rettv->v_type == VAR_OBJECT)\n    {\n\tfor (int i = 0; i < cl->class_obj_member_count; ++i)\n\t{\n\t    ocmember_T *m = &cl->class_obj_members[i];\n\t    if (STRNCMP(name, m->ocm_name, len) == 0 && m->ocm_name[len] == NUL)\n\t    {\n\t\tif (*name == '_')\n\t\t{\n\t\t    semsg(_(e_cannot_access_private_member_str), m->ocm_name);\n\t\t    return FAIL;\n\t\t}\n\n\t\t// The object only contains a pointer to the class, the member\n\t\t// values array follows right after that.\n\t\tobject_T *obj = rettv->vval.v_object;\n\t\ttypval_T *tv = (typval_T *)(obj + 1) + i;\n\t\tcopy_tv(tv, rettv);\n\t\tobject_unref(obj);\n\n\t\t*arg = name_end;\n\t\treturn OK;\n\t    }\n\t}\n\n\tsemsg(_(e_member_not_found_on_object_str_str), cl->class_name, name);\n    }\n\n    else if (rettv->v_type == VAR_CLASS)\n    {\n\t// class member\n\tfor (int i = 0; i < cl->class_class_member_count; ++i)\n\t{\n\t    ocmember_T *m = &cl->class_class_members[i];\n\t    if (STRNCMP(name, m->ocm_name, len) == 0 && m->ocm_name[len] == NUL)\n\t    {\n\t\tif (*name == '_')\n\t\t{\n\t\t    semsg(_(e_cannot_access_private_member_str), m->ocm_name);\n\t\t    return FAIL;\n\t\t}\n\n\t\ttypval_T *tv = &cl->class_members_tv[i];\n\t\tcopy_tv(tv, rettv);\n\t\tclass_unref(cl);\n\n\t\t*arg = name_end;\n\t\treturn OK;\n\t    }\n\t}\n\n\tsemsg(_(e_member_not_found_on_class_str_str), cl->class_name, name);\n    }\n\n    return FAIL;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 2390,
    "critical_vars": [
      "expr_end"
    ],
    "function": "eval0_retarg",
    "filename": "vim/CVE-2022-2231/CVE-2022-2231_CWE-476_79481367a457951aabd9501b510fd7e3eb29c3d8_eval.c.diff",
    "function_code": "eval0_retarg(\n    char_u\t*arg,\n    typval_T\t*rettv,\n    exarg_T\t*eap,\n    evalarg_T\t*evalarg,\n    char_u\t**retarg)\n{\n    int\t\tret;\n    char_u\t*p;\n    char_u\t*expr_end;\n    int\t\tdid_emsg_before = did_emsg;\n    int\t\tcalled_emsg_before = called_emsg;\n    int\t\tflags = evalarg == NULL ? 0 : evalarg->eval_flags;\n    int\t\tcheck_for_end = retarg == NULL;\n    int\t\tend_error = FALSE;\n\n    p = skipwhite(arg);\n    ret = eval1(&p, rettv, evalarg);\n    expr_end = p;\n    p = skipwhite(p);\n\n    // In Vim9 script a command block is not split at NL characters for\n    // commands using an expression argument.  Skip over a '#' comment to check\n    // for a following NL.  Require white space before the '#'.\n    if (in_vim9script() && p > expr_end && retarg == NULL)\n\twhile (*p == '#')\n\t{\n\t    char_u *nl = vim_strchr(p, NL);\n\n\t    if (nl == NULL)\n\t\tbreak;\n\t    p = skipwhite(nl + 1);\n\t    if (eap != NULL && *p != NUL)\n\t\teap->nextcmd = p;\n\t    check_for_end = FALSE;\n\t}\n\n    if (ret != FAIL && check_for_end)\n\tend_error = !ends_excmd2(arg, p);\n    if (ret == FAIL || end_error)\n    {\n\tif (ret != FAIL)\n\t    clear_tv(rettv);\n\t/*\n\t * Report the invalid expression unless the expression evaluation has\n\t * been cancelled due to an aborting error, an interrupt, or an\n\t * exception, or we already gave a more specific error.\n\t * Also check called_emsg for when using assert_fails().\n\t */\n\tif (!aborting()\n\t\t&& did_emsg == did_emsg_before\n\t\t&& called_emsg == called_emsg_before\n\t\t&& (flags & EVAL_CONSTANT) == 0\n\t\t&& (!in_vim9script() || !vim9_bad_comment(p)))\n\t{\n\t    if (end_error)\n\t\tsemsg(_(e_trailing_characters_str), p);\n\t    else\n\t\tsemsg(_(e_invalid_expression_str), arg);\n\t}\n\n\t// Some of the expression may not have been consumed.  Do not check for\n\t// a next command to avoid more errors, unless \"|\" is following, which\n\t// could only be a command separator.\n\tif (eap != NULL && skipwhite(p)[0] == '|' && skipwhite(p)[1] != '|')\n\t    eap->nextcmd = check_nextcmd(p);\n\treturn FAIL;\n    }\n\n    if (retarg != NULL)\n\t*retarg = p;\n    else if (check_for_end && eap != NULL)\n\tset_nextcmd(eap, p);\n\n    return ret;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 2391,
    "critical_vars": [
      "ret"
    ],
    "function": "eval0_retarg",
    "filename": "vim/CVE-2022-2231/CVE-2022-2231_CWE-476_79481367a457951aabd9501b510fd7e3eb29c3d8_eval.c.diff",
    "function_code": "eval0_retarg(\n    char_u\t*arg,\n    typval_T\t*rettv,\n    exarg_T\t*eap,\n    evalarg_T\t*evalarg,\n    char_u\t**retarg)\n{\n    int\t\tret;\n    char_u\t*p;\n    char_u\t*expr_end;\n    int\t\tdid_emsg_before = did_emsg;\n    int\t\tcalled_emsg_before = called_emsg;\n    int\t\tflags = evalarg == NULL ? 0 : evalarg->eval_flags;\n    int\t\tcheck_for_end = retarg == NULL;\n    int\t\tend_error = FALSE;\n\n    p = skipwhite(arg);\n    ret = eval1(&p, rettv, evalarg);\n\n    if (ret != FAIL)\n    {\n\texpr_end = p;\n\tp = skipwhite(p);\n\n\t// In Vim9 script a command block is not split at NL characters for\n\t// commands using an expression argument.  Skip over a '#' comment to\n\t// check for a following NL.  Require white space before the '#'.\n\tif (in_vim9script() && p > expr_end && retarg == NULL)\n\t    while (*p == '#')\n\t    {\n\t\tchar_u *nl = vim_strchr(p, NL);\n\n\t\tif (nl == NULL)\n\t\t    break;\n\t\tp = skipwhite(nl + 1);\n\t\tif (eap != NULL && *p != NUL)\n\t\t    eap->nextcmd = p;\n\t\tcheck_for_end = FALSE;\n\t    }\n\n\tif (check_for_end)\n\t    end_error = !ends_excmd2(arg, p);\n    }\n\n    if (ret == FAIL || end_error)\n    {\n\tif (ret != FAIL)\n\t    clear_tv(rettv);\n\t/*\n\t * Report the invalid expression unless the expression evaluation has\n\t * been cancelled due to an aborting error, an interrupt, or an\n\t * exception, or we already gave a more specific error.\n\t * Also check called_emsg for when using assert_fails().\n\t */\n\tif (!aborting()\n\t\t&& did_emsg == did_emsg_before\n\t\t&& called_emsg == called_emsg_before\n\t\t&& (flags & EVAL_CONSTANT) == 0\n\t\t&& (!in_vim9script() || !vim9_bad_comment(p)))\n\t{\n\t    if (end_error)\n\t\tsemsg(_(e_trailing_characters_str), p);\n\t    else\n\t\tsemsg(_(e_invalid_expression_str), arg);\n\t}\n\n\t// Some of the expression may not have been consumed.  Do not check for\n\t// a next command to avoid more errors, unless \"|\" is following, which\n\t// could only be a command separator.\n\tif (eap != NULL && p != NULL\n\t\t\t  &&  skipwhite(p)[0] == '|' && skipwhite(p)[1] != '|')\n\t    eap->nextcmd = check_nextcmd(p);\n\treturn FAIL;\n    }\n\n    if (retarg != NULL)\n\t*retarg = p;\n    else if (check_for_end && eap != NULL)\n\tset_nextcmd(eap, p);\n\n    return ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 3946,
    "critical_vars": [
      "cmdwin_type"
    ],
    "function": "win_new_tabpage",
    "filename": "vim/CVE-2022-0696/CVE-2022-0696_CWE-476_0f6e28f686dbb59ab3b562408ab9b2234797b9b1_window.c.diff",
    "function_code": "win_new_tabpage(int after)\n{\n    tabpage_T\t*tp = curtab;\n    tabpage_T\t*prev_tp = curtab;\n    tabpage_T\t*newtp;\n    int\t\tn;\n\n#ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0)\n    {\n\temsg(_(e_invalid_in_cmdline_window));\n\treturn FAIL;\n    }\n#endif\n\n    newtp = alloc_tabpage();\n    if (newtp == NULL)\n\treturn FAIL;\n\n    // Remember the current windows in this Tab page.\n    if (leave_tabpage(curbuf, TRUE) == FAIL)\n    {\n\tvim_free(newtp);\n\treturn FAIL;\n    }\n    curtab = newtp;\n\n    newtp->tp_localdir = (tp->tp_localdir == NULL)\n\t\t\t\t    ? NULL : vim_strsave(tp->tp_localdir);\n    // Create a new empty window.\n    if (win_alloc_firstwin(tp->tp_curwin) == OK)\n    {\n\t// Make the new Tab page the new topframe.\n\tif (after == 1)\n\t{\n\t    // New tab page becomes the first one.\n\t    newtp->tp_next = first_tabpage;\n\t    first_tabpage = newtp;\n\t}\n\telse\n\t{\n\t    if (after > 0)\n\t    {\n\t\t// Put new tab page before tab page \"after\".\n\t\tn = 2;\n\t\tfor (tp = first_tabpage; tp->tp_next != NULL\n\t\t\t\t\t       && n < after; tp = tp->tp_next)\n\t\t    ++n;\n\t    }\n\t    newtp->tp_next = tp->tp_next;\n\t    tp->tp_next = newtp;\n\t}\n\tnewtp->tp_firstwin = newtp->tp_lastwin = newtp->tp_curwin = curwin;\n\n\twin_init_size();\n\tfirstwin->w_winrow = tabline_height();\n\twin_comp_scroll(curwin);\n\n\tnewtp->tp_topframe = topframe;\n\tlast_status(FALSE);\n\n\tlastused_tabpage = prev_tp;\n\n#if defined(FEAT_GUI)\n\t// When 'guioptions' includes 'L' or 'R' may have to remove or add\n\t// scrollbars.  Have to update them anyway.\n\tgui_may_update_scrollbars();\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\tentering_window(curwin);\n#endif\n\n\tredraw_all_later(NOT_VALID);\n\tapply_autocmds(EVENT_WINNEW, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_TABNEW, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);\n\treturn OK;\n    }\n\n    // Failed, get back the previous Tab page\n    enter_tabpage(curtab, curbuf, TRUE, TRUE);\n    return FAIL;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 2202,
    "line_new": 2202,
    "critical_vars": [
      "ht"
    ],
    "function": "get_user_var_name",
    "filename": "vim/CVE-2022-0696/CVE-2022-0696_CWE-476_0f6e28f686dbb59ab3b562408ab9b2234797b9b1_evalvars.c.diff",
    "function_code": "get_user_var_name(expand_T *xp, int idx)\n{\n    static long_u\tgdone;\n    static long_u\tbdone;\n    static long_u\twdone;\n    static long_u\ttdone;\n    static int\t\tvidx;\n    static hashitem_T\t*hi;\n    hashtab_T\t\t*ht;\n\n    if (idx == 0)\n    {\n\tgdone = bdone = wdone = vidx = 0;\n\ttdone = 0;\n    }\n\n    // Global variables\n    if (gdone < globvarht.ht_used)\n    {\n\tif (gdone++ == 0)\n\t    hi = globvarht.ht_array;\n\telse\n\t    ++hi;\n\twhile (HASHITEM_EMPTY(hi))\n\t    ++hi;\n\tif (STRNCMP(\"g:\", xp->xp_pattern, 2) == 0)\n\t    return cat_prefix_varname('g', hi->hi_key);\n\treturn hi->hi_key;\n    }\n\n    // b: variables\n    ht = &prevwin_curwin()->w_buffer->b_vars->dv_hashtab;\n    if (bdone < ht->ht_used)\n    {\n\tif (bdone++ == 0)\n\t    hi = ht->ht_array;\n\telse\n\t    ++hi;\n\twhile (HASHITEM_EMPTY(hi))\n\t    ++hi;\n\treturn cat_prefix_varname('b', hi->hi_key);\n    }\n\n    // w: variables\n    ht = &prevwin_curwin()->w_vars->dv_hashtab;\n    if (wdone < ht->ht_used)\n    {\n\tif (wdone++ == 0)\n\t    hi = ht->ht_array;\n\telse\n\t    ++hi;\n\twhile (HASHITEM_EMPTY(hi))\n\t    ++hi;\n\treturn cat_prefix_varname('w', hi->hi_key);\n    }\n\n    // t: variables\n    ht = &curtab->tp_vars->dv_hashtab;\n    if (tdone < ht->ht_used)\n    {\n\tif (tdone++ == 0)\n\t    hi = ht->ht_array;\n\telse\n\t    ++hi;\n\twhile (HASHITEM_EMPTY(hi))\n\t    ++hi;\n\treturn cat_prefix_varname('t', hi->hi_key);\n    }\n\n    // v: variables\n    if (vidx < VV_LEN)\n\treturn cat_prefix_varname('v', (char_u *)vimvars[vidx++].vv_name);\n\n    VIM_CLEAR(varnamebuf);\n    varnamebuflen = 0;\n    return NULL;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 144,
    "line_new": 144,
    "critical_vars": [
      "gap"
    ],
    "function": "find_ucmd",
    "filename": "vim/CVE-2022-0696/CVE-2022-0696_CWE-476_0f6e28f686dbb59ab3b562408ab9b2234797b9b1_usercmd.c.diff",
    "function_code": "find_ucmd(\n    exarg_T\t*eap,\n    char_u\t*p,\t // end of the command (possibly including count)\n    int\t\t*full,\t // set to TRUE for a full match\n    expand_T\t*xp,\t // used for completion, NULL otherwise\n    int\t\t*complp) // completion flags or NULL\n{\n    int\t\tlen = (int)(p - eap->cmd);\n    int\t\tj, k, matchlen = 0;\n    ucmd_T\t*uc;\n    int\t\tfound = FALSE;\n    int\t\tpossible = FALSE;\n    char_u\t*cp, *np;\t    // Point into typed cmd and test name\n    garray_T\t*gap;\n    int\t\tamb_local = FALSE;  // Found ambiguous buffer-local command,\n\t\t\t\t    // only full match global is accepted.\n\n    /*\n     * Look for buffer-local user commands first, then global ones.\n     */\n    gap = &prevwin_curwin()->w_buffer->b_ucmds;\n    for (;;)\n    {\n\tfor (j = 0; j < gap->ga_len; ++j)\n\t{\n\t    uc = USER_CMD_GA(gap, j);\n\t    cp = eap->cmd;\n\t    np = uc->uc_name;\n\t    k = 0;\n\t    while (k < len && *np != NUL && *cp++ == *np++)\n\t\tk++;\n\t    if (k == len || (*np == NUL && vim_isdigit(eap->cmd[k])))\n\t    {\n\t\t// If finding a second match, the command is ambiguous.  But\n\t\t// not if a buffer-local command wasn't a full match and a\n\t\t// global command is a full match.\n\t\tif (k == len && found && *np != NUL)\n\t\t{\n\t\t    if (gap == &ucmds)\n\t\t\treturn NULL;\n\t\t    amb_local = TRUE;\n\t\t}\n\n\t\tif (!found || (k == len && *np == NUL))\n\t\t{\n\t\t    // If we matched up to a digit, then there could\n\t\t    // be another command including the digit that we\n\t\t    // should use instead.\n\t\t    if (k == len)\n\t\t\tfound = TRUE;\n\t\t    else\n\t\t\tpossible = TRUE;\n\n\t\t    if (gap == &ucmds)\n\t\t\teap->cmdidx = CMD_USER;\n\t\t    else\n\t\t\teap->cmdidx = CMD_USER_BUF;\n\t\t    eap->argt = (long)uc->uc_argt;\n\t\t    eap->useridx = j;\n\t\t    eap->addr_type = uc->uc_addr_type;\n\n\t\t    if (complp != NULL)\n\t\t\t*complp = uc->uc_compl;\n# ifdef FEAT_EVAL\n\t\t    if (xp != NULL)\n\t\t    {\n\t\t\txp->xp_arg = uc->uc_compl_arg;\n\t\t\txp->xp_script_ctx = uc->uc_script_ctx;\n\t\t\txp->xp_script_ctx.sc_lnum += SOURCING_LNUM;\n\t\t    }\n# endif\n\t\t    // Do not search for further abbreviations\n\t\t    // if this is an exact match.\n\t\t    matchlen = k;\n\t\t    if (k == len && *np == NUL)\n\t\t    {\n\t\t\tif (full != NULL)\n\t\t\t    *full = TRUE;\n\t\t\tamb_local = FALSE;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\t// Stop if we found a full match or searched all.\n\tif (j < gap->ga_len || gap == &ucmds)\n\t    break;\n\tgap = &ucmds;\n    }\n\n    // Only found ambiguous matches.\n    if (amb_local)\n    {\n\tif (xp != NULL)\n\t    xp->xp_context = EXPAND_UNSUCCESSFUL;\n\treturn NULL;\n    }\n\n    // The match we found may be followed immediately by a number.  Move \"p\"\n    // back to point to it.\n    if (found || possible)\n\treturn p + (matchlen - len);\n    return p;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 389,
    "line_new": 381,
    "critical_vars": [
      "*buf"
    ],
    "function": "get_user_command_name",
    "filename": "vim/CVE-2022-0696/CVE-2022-0696_CWE-476_0f6e28f686dbb59ab3b562408ab9b2234797b9b1_usercmd.c.diff",
    "function_code": "get_user_command_name(int idx, int cmdidx)\n{\n    if (cmdidx == CMD_USER && idx < ucmds.ga_len)\n\treturn USER_CMD(idx)->uc_name;\n    if (cmdidx == CMD_USER_BUF)\n    {\n\t// In cmdwin, the alternative buffer should be used.\n\tbuf_T *buf = prevwin_curwin()->w_buffer;\n\n\tif (idx < buf->b_ucmds.ga_len)\n\t    return USER_CMD_GA(&buf->b_ucmds, idx)->uc_name;\n    }\n    return NULL;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 481,
    "line_new": 469,
    "critical_vars": [
      "gap"
    ],
    "function": "uc_list",
    "filename": "vim/CVE-2022-0696/CVE-2022-0696_CWE-476_0f6e28f686dbb59ab3b562408ab9b2234797b9b1_usercmd.c.diff",
    "function_code": "uc_list(char_u *name, size_t name_len)\n{\n    int\t\ti, j;\n    int\t\tfound = FALSE;\n    ucmd_T\t*cmd;\n    int\t\tlen;\n    int\t\tover;\n    long\ta;\n    garray_T\t*gap;\n\n    // In cmdwin, the alternative buffer should be used.\n    gap = &prevwin_curwin()->w_buffer->b_ucmds;\n    for (;;)\n    {\n\tfor (i = 0; i < gap->ga_len; ++i)\n\t{\n\t    cmd = USER_CMD_GA(gap, i);\n\t    a = (long)cmd->uc_argt;\n\n\t    // Skip commands which don't match the requested prefix and\n\t    // commands filtered out.\n\t    if (STRNCMP(name, cmd->uc_name, name_len) != 0\n\t\t    || message_filtered(cmd->uc_name))\n\t\tcontinue;\n\n\t    // Put out the title first time\n\t    if (!found)\n\t\tmsg_puts_title(_(\"\\n    Name              Args Address Complete    Definition\"));\n\t    found = TRUE;\n\t    msg_putchar('\\n');\n\t    if (got_int)\n\t\tbreak;\n\n\t    // Special cases\n\t    len = 4;\n\t    if (a & EX_BANG)\n\t    {\n\t\tmsg_putchar('!');\n\t\t--len;\n\t    }\n\t    if (a & EX_REGSTR)\n\t    {\n\t\tmsg_putchar('\"');\n\t\t--len;\n\t    }\n\t    if (gap != &ucmds)\n\t    {\n\t\tmsg_putchar('b');\n\t\t--len;\n\t    }\n\t    if (a & EX_TRLBAR)\n\t    {\n\t\tmsg_putchar('|');\n\t\t--len;\n\t    }\n\t    while (len-- > 0)\n\t\tmsg_putchar(' ');\n\n\t    msg_outtrans_attr(cmd->uc_name, HL_ATTR(HLF_D));\n\t    len = (int)STRLEN(cmd->uc_name) + 4;\n\n\t    do {\n\t\tmsg_putchar(' ');\n\t\t++len;\n\t    } while (len < 22);\n\n\t    // \"over\" is how much longer the name is than the column width for\n\t    // the name, we'll try to align what comes after.\n\t    over = len - 22;\n\t    len = 0;\n\n\t    // Arguments\n\t    switch ((int)(a & (EX_EXTRA|EX_NOSPC|EX_NEEDARG)))\n\t    {\n\t\tcase 0:\t\t\t\tIObuff[len++] = '0'; break;\n\t\tcase (EX_EXTRA):\t\tIObuff[len++] = '*'; break;\n\t\tcase (EX_EXTRA|EX_NOSPC):\tIObuff[len++] = '?'; break;\n\t\tcase (EX_EXTRA|EX_NEEDARG):\tIObuff[len++] = '+'; break;\n\t\tcase (EX_EXTRA|EX_NOSPC|EX_NEEDARG): IObuff[len++] = '1'; break;\n\t    }\n\n\t    do {\n\t\tIObuff[len++] = ' ';\n\t    } while (len < 5 - over);\n\n\t    // Address / Range\n\t    if (a & (EX_RANGE|EX_COUNT))\n\t    {\n\t\tif (a & EX_COUNT)\n\t\t{\n\t\t    // -count=N\n\t\t    sprintf((char *)IObuff + len, \"%ldc\", cmd->uc_def);\n\t\t    len += (int)STRLEN(IObuff + len);\n\t\t}\n\t\telse if (a & EX_DFLALL)\n\t\t    IObuff[len++] = '%';\n\t\telse if (cmd->uc_def >= 0)\n\t\t{\n\t\t    // -range=N\n\t\t    sprintf((char *)IObuff + len, \"%ld\", cmd->uc_def);\n\t\t    len += (int)STRLEN(IObuff + len);\n\t\t}\n\t\telse\n\t\t    IObuff[len++] = '.';\n\t    }\n\n\t    do {\n\t\tIObuff[len++] = ' ';\n\t    } while (len < 8 - over);\n\n\t    // Address Type\n\t    for (j = 0; addr_type_complete[j].expand != ADDR_NONE; ++j)\n\t\tif (addr_type_complete[j].expand != ADDR_LINES\n\t\t\t&& addr_type_complete[j].expand == cmd->uc_addr_type)\n\t\t{\n\t\t    STRCPY(IObuff + len, addr_type_complete[j].shortname);\n\t\t    len += (int)STRLEN(IObuff + len);\n\t\t    break;\n\t\t}\n\n\t    do {\n\t\tIObuff[len++] = ' ';\n\t    } while (len < 13 - over);\n\n\t    // Completion\n\t    for (j = 0; command_complete[j].expand != 0; ++j)\n\t\tif (command_complete[j].expand == cmd->uc_compl)\n\t\t{\n\t\t    STRCPY(IObuff + len, command_complete[j].name);\n\t\t    len += (int)STRLEN(IObuff + len);\n#ifdef FEAT_EVAL\n\t\t    if (p_verbose > 0 && cmd->uc_compl_arg != NULL\n\t\t\t\t\t    && STRLEN(cmd->uc_compl_arg) < 200)\n\t\t    {\n\t\t\tIObuff[len] = ',';\n\t\t\tSTRCPY(IObuff + len + 1, cmd->uc_compl_arg);\n\t\t\tlen += (int)STRLEN(IObuff + len);\n\t\t    }\n#endif\n\t\t    break;\n\t\t}\n\n\t    do {\n\t\tIObuff[len++] = ' ';\n\t    } while (len < 25 - over);\n\n\t    IObuff[len] = '\\0';\n\t    msg_outtrans(IObuff);\n\n\t    msg_outtrans_special(cmd->uc_rep, FALSE,\n\t\t\t\t\t     name_len == 0 ? Columns - 47 : 0);\n#ifdef FEAT_EVAL\n\t    if (p_verbose > 0)\n\t\tlast_set_msg(cmd->uc_script_ctx);\n#endif\n\t    out_flush();\n\t    ui_breakcheck();\n\t    if (got_int)\n\t\tbreak;\n\t}\n\tif (gap == &ucmds || i < gap->ga_len)\n\t    break;\n\tgap = &ucmds;\n    }\n\n    if (!found)\n\tmsg(_(\"No user-defined commands found\"));\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 98,
    "critical_vars": [
      "buffer"
    ],
    "function": "*realloc_buffer",
    "filename": "vim/CVE-2018-20786/CVE-2018-20786_CWE-476_cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8_termscreen.c.diff",
    "function_code": "static ScreenCell *realloc_buffer(VTermScreen *screen, ScreenCell *buffer, int new_rows, int new_cols)\n{\n  ScreenCell *new_buffer = vterm_allocator_malloc(screen->vt, sizeof(ScreenCell) * new_rows * new_cols);\n  int row, col;\n\n  for(row = 0; row < new_rows; row++) {\n    for(col = 0; col < new_cols; col++) {\n      ScreenCell *new_cell = new_buffer + row*new_cols + col;\n\n      if(buffer && row < screen->rows && col < screen->cols)\n        *new_cell = buffer[row * screen->cols + col];\n      else {\n        new_cell->chars[0] = 0;\n        new_cell->pen = screen->pen;\n      }\n    }\n  }\n\n  if(buffer)\n    vterm_allocator_free(screen->vt, buffer);\n\n  return new_buffer;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 99,
    "critical_vars": [
      "screen->vt",
      "buffer"
    ],
    "function": "*realloc_buffer",
    "filename": "vim/CVE-2018-20786/CVE-2018-20786_CWE-476_cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8_termscreen.c.diff",
    "function_code": "static ScreenCell *realloc_buffer(VTermScreen *screen, ScreenCell *buffer, int new_rows, int new_cols)\n{\n  ScreenCell *new_buffer = vterm_allocator_malloc(screen->vt, sizeof(ScreenCell) * new_rows * new_cols);\n  int row, col;\n\n  for(row = 0; row < new_rows; row++) {\n    for(col = 0; col < new_cols; col++) {\n      ScreenCell *new_cell = new_buffer + row*new_cols + col;\n\n      if(buffer && row < screen->rows && col < screen->cols)\n        *new_cell = buffer[row * screen->cols + col];\n      else {\n        new_cell->chars[0] = 0;\n        new_cell->pen = screen->pen;\n      }\n    }\n  }\n\n  vterm_allocator_free(screen->vt, buffer);\n\n  return new_buffer;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 521,
    "critical_vars": [
      "screen->sb_buffer"
    ],
    "function": "resize",
    "filename": "vim/CVE-2018-20786/CVE-2018-20786_CWE-476_cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8_termscreen.c.diff",
    "function_code": "static int resize(int new_rows, int new_cols, VTermPos *delta, void *user)\n{\n  VTermScreen *screen = user;\n\n  int is_altscreen = (screen->buffers[1] && screen->buffer == screen->buffers[1]);\n\n  int old_rows = screen->rows;\n  int old_cols = screen->cols;\n  int first_blank_row;\n\n  if(!is_altscreen && new_rows < old_rows) {\n    // Fewer rows - determine if we're going to scroll at all, and if so, push\n    // those lines to scrollback\n    VTermPos pos = { 0, 0 };\n    VTermPos cursor = screen->state->pos;\n    // Find the first blank row after the cursor.\n    for(pos.row = old_rows - 1; pos.row >= new_rows; pos.row--)\n      if(!vterm_screen_is_eol(screen, pos) || cursor.row == pos.row)\n        break;\n\n    first_blank_row = pos.row + 1;\n    if(first_blank_row > new_rows) {\n      VTermRect rect = {0,0,0,0};\n      rect.end_row   = old_rows;\n      rect.end_col   = old_cols;\n      scrollrect(rect, first_blank_row - new_rows, 0, user);\n      vterm_screen_flush_damage(screen);\n\n      delta->row -= first_blank_row - new_rows;\n    }\n  }\n\n  screen->buffers[0] = realloc_buffer(screen, screen->buffers[0], new_rows, new_cols);\n  if(screen->buffers[1])\n    screen->buffers[1] = realloc_buffer(screen, screen->buffers[1], new_rows, new_cols);\n\n  screen->buffer = is_altscreen ? screen->buffers[1] : screen->buffers[0];\n\n  screen->rows = new_rows;\n  screen->cols = new_cols;\n\n  if(screen->sb_buffer)\n    vterm_allocator_free(screen->vt, screen->sb_buffer);\n\n  screen->sb_buffer = vterm_allocator_malloc(screen->vt, sizeof(VTermScreenCell) * new_cols);\n\n  if(new_cols > old_cols) {\n    VTermRect rect;\n    rect.start_row = 0;\n    rect.end_row   = old_rows;\n    rect.start_col = old_cols;\n    rect.end_col   = new_cols;\n    damagerect(screen, rect);\n  }\n\n  if(new_rows > old_rows) {\n    if(!is_altscreen && screen->callbacks && screen->callbacks->sb_popline) {\n      int rows = new_rows - old_rows;\n      while(rows) {\n        VTermRect rect = {0,0,0,0};\n        VTermPos pos = { 0, 0 };\n        if(!(screen->callbacks->sb_popline(screen->cols, screen->sb_buffer, screen->cbdata)))\n          break;\n\n\trect.end_row   = screen->rows;\n\trect.end_col   = screen->cols;\n        scrollrect(rect, -1, 0, user);\n\n        for(pos.col = 0; pos.col < screen->cols; pos.col += screen->sb_buffer[pos.col].width)\n          vterm_screen_set_cell(screen, pos, screen->sb_buffer + pos.col);\n\n        rect.end_row = 1;\n        damagerect(screen, rect);\n\n        vterm_screen_flush_damage(screen);\n\n        rows--;\n        delta->row++;\n      }\n    }\n\n    {\n      VTermRect rect;\n      rect.start_row = old_rows;\n      rect.end_row   = new_rows;\n      rect.start_col = 0;\n      rect.end_col   = new_cols;\n      damagerect(screen, rect);\n    }\n  }\n\n  if(screen->callbacks && screen->callbacks->resize)\n    return (*screen->callbacks->resize)(new_rows, new_cols, screen->cbdata);\n\n  return 1;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 521,
    "critical_vars": [
      "screen->vt",
      "screen->sb_buffer"
    ],
    "function": "resize",
    "filename": "vim/CVE-2018-20786/CVE-2018-20786_CWE-476_cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8_termscreen.c.diff",
    "function_code": "static int resize(int new_rows, int new_cols, VTermPos *delta, void *user)\n{\n  VTermScreen *screen = user;\n\n  int is_altscreen = (screen->buffers[1] && screen->buffer == screen->buffers[1]);\n\n  int old_rows = screen->rows;\n  int old_cols = screen->cols;\n  int first_blank_row;\n\n  if(!is_altscreen && new_rows < old_rows) {\n    // Fewer rows - determine if we're going to scroll at all, and if so, push\n    // those lines to scrollback\n    VTermPos pos = { 0, 0 };\n    VTermPos cursor = screen->state->pos;\n    // Find the first blank row after the cursor.\n    for(pos.row = old_rows - 1; pos.row >= new_rows; pos.row--)\n      if(!vterm_screen_is_eol(screen, pos) || cursor.row == pos.row)\n        break;\n\n    first_blank_row = pos.row + 1;\n    if(first_blank_row > new_rows) {\n      VTermRect rect = {0,0,0,0};\n      rect.end_row   = old_rows;\n      rect.end_col   = old_cols;\n      scrollrect(rect, first_blank_row - new_rows, 0, user);\n      vterm_screen_flush_damage(screen);\n\n      delta->row -= first_blank_row - new_rows;\n    }\n  }\n\n  screen->buffers[0] = realloc_buffer(screen, screen->buffers[0], new_rows, new_cols);\n  if(screen->buffers[1])\n    screen->buffers[1] = realloc_buffer(screen, screen->buffers[1], new_rows, new_cols);\n\n  screen->buffer = is_altscreen ? screen->buffers[1] : screen->buffers[0];\n\n  screen->rows = new_rows;\n  screen->cols = new_cols;\n\n  vterm_allocator_free(screen->vt, screen->sb_buffer);\n\n  screen->sb_buffer = vterm_allocator_malloc(screen->vt, sizeof(VTermScreenCell) * new_cols);\n\n  if(new_cols > old_cols) {\n    VTermRect rect;\n    rect.start_row = 0;\n    rect.end_row   = old_rows;\n    rect.start_col = old_cols;\n    rect.end_col   = new_cols;\n    damagerect(screen, rect);\n  }\n\n  if(new_rows > old_rows) {\n    if(!is_altscreen && screen->callbacks && screen->callbacks->sb_popline) {\n      int rows = new_rows - old_rows;\n      while(rows) {\n        VTermRect rect = {0,0,0,0};\n        VTermPos pos = { 0, 0 };\n        if(!(screen->callbacks->sb_popline(screen->cols, screen->sb_buffer, screen->cbdata)))\n          break;\n\n\trect.end_row   = screen->rows;\n\trect.end_col   = screen->cols;\n        scrollrect(rect, -1, 0, user);\n\n        for(pos.col = 0; pos.col < screen->cols; pos.col += screen->sb_buffer[pos.col].width)\n          vterm_screen_set_cell(screen, pos, screen->sb_buffer + pos.col);\n\n        rect.end_row = 1;\n        damagerect(screen, rect);\n\n        vterm_screen_flush_damage(screen);\n\n        rows--;\n        delta->row++;\n      }\n    }\n\n    {\n      VTermRect rect;\n      rect.start_row = old_rows;\n      rect.end_row   = new_rows;\n      rect.start_col = 0;\n      rect.end_col   = new_cols;\n      damagerect(screen, rect);\n    }\n  }\n\n  if(screen->callbacks && screen->callbacks->resize)\n    return (*screen->callbacks->resize)(new_rows, new_cols, screen->cbdata);\n\n  return 1;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 655,
    "critical_vars": [
      "screen->buffer",
      "screen->sb_buffer"
    ],
    "function": "*screen_new",
    "filename": "vim/CVE-2018-20786/CVE-2018-20786_CWE-476_cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8_termscreen.c.diff",
    "function_code": "static VTermScreen *screen_new(VTerm *vt)\n{\n  VTermState *state = vterm_obtain_state(vt);\n  VTermScreen *screen;\n  int rows, cols;\n\n  if (state == NULL)\n    return NULL;\n  screen = vterm_allocator_malloc(vt, sizeof(VTermScreen));\n  if (screen == NULL)\n    return NULL;\n\n  vterm_get_size(vt, &rows, &cols);\n\n  screen->vt = vt;\n  screen->state = state;\n\n  screen->damage_merge = VTERM_DAMAGE_CELL;\n  screen->damaged.start_row = -1;\n  screen->pending_scrollrect.start_row = -1;\n\n  screen->rows = rows;\n  screen->cols = cols;\n\n  screen->callbacks = NULL;\n  screen->cbdata    = NULL;\n\n  screen->buffers[0] = realloc_buffer(screen, NULL, rows, cols);\n  screen->buffer = screen->buffers[0];\n  screen->sb_buffer = vterm_allocator_malloc(screen->vt, sizeof(VTermScreenCell) * cols);\n  if (screen->buffer == NULL || screen->sb_buffer == NULL)\n  {\n    vterm_screen_free(screen);\n    return NULL;\n  }\n\n  vterm_state_set_callbacks(screen->state, &state_cbs, screen);\n\n  return screen;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 662,
    "critical_vars": [
      "screen->buffers[1]"
    ],
    "function": "*screen_new",
    "filename": "vim/CVE-2018-20786/CVE-2018-20786_CWE-476_cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8_termscreen.c.diff",
    "function_code": "static VTermScreen *screen_new(VTerm *vt)\n{\n  VTermState *state = vterm_obtain_state(vt);\n  VTermScreen *screen;\n  int rows, cols;\n\n  if(!state)\n    return NULL;\n\n  screen = vterm_allocator_malloc(vt, sizeof(VTermScreen));\n\n  vterm_get_size(vt, &rows, &cols);\n\n  screen->vt = vt;\n  screen->state = state;\n\n  screen->damage_merge = VTERM_DAMAGE_CELL;\n  screen->damaged.start_row = -1;\n  screen->pending_scrollrect.start_row = -1;\n\n  screen->rows = rows;\n  screen->cols = cols;\n\n  screen->callbacks = NULL;\n  screen->cbdata    = NULL;\n\n  screen->buffers[0] = realloc_buffer(screen, NULL, rows, cols);\n\n  screen->buffer = screen->buffers[0];\n\n  screen->sb_buffer = vterm_allocator_malloc(screen->vt, sizeof(VTermScreenCell) * cols);\n\n  vterm_state_set_callbacks(screen->state, &state_cbs, screen);\n\n  return screen;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 3719,
    "critical_vars": [
      "vterm"
    ],
    "function": "create_vterm",
    "filename": "vim/CVE-2018-20786/CVE-2018-20786_CWE-476_cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8_terminal.c.diff",
    "function_code": "create_vterm(term_T *term, int rows, int cols)\n{\n    VTerm\t    *vterm;\n    VTermScreen\t    *screen;\n    VTermState\t    *state;\n    VTermValue\t    value;\n\n    vterm = vterm_new_with_allocator(rows, cols, &vterm_allocator, NULL);\n    term->tl_vterm = vterm;\n    if (vterm == NULL)\n\treturn FAIL;\n\n    // Allocate screen and state here, so we can bail out if that fails.\n    state = vterm_obtain_state(vterm);\n    screen = vterm_obtain_screen(vterm);\n    if (state == NULL || screen == NULL)\n    {\n\tvterm_free(vterm);\n\treturn FAIL;\n    }\n\n    vterm_screen_set_callbacks(screen, &screen_callbacks, term);\n    /* TODO: depends on 'encoding'. */\n    vterm_set_utf8(vterm, 1);\n\n    init_default_colors(term);\n\n    vterm_state_set_default_colors(\n\t    state,\n\t    &term->tl_default_color.fg,\n\t    &term->tl_default_color.bg);\n\n    if (t_colors >= 16)\n\tvterm_state_set_bold_highbright(vterm_obtain_state(vterm), 1);\n\n    /* Required to initialize most things. */\n    vterm_screen_reset(screen, 1 /* hard */);\n\n    /* Allow using alternate screen. */\n    vterm_screen_enable_altscreen(screen, 1);\n\n    /* For unix do not use a blinking cursor.  In an xterm this causes the\n     * cursor to blink if it's blinking in the xterm.\n     * For Windows we respect the system wide setting. */\n#ifdef WIN3264\n    if (GetCaretBlinkTime() == INFINITE)\n\tvalue.boolean = 0;\n    else\n\tvalue.boolean = 1;\n#else\n    value.boolean = 0;\n#endif\n    vterm_state_set_termprop(state, VTERM_PROP_CURSORBLINK, &value);\n    vterm_state_set_unrecognised_fallbacks(state, &parser_fallbacks, term);\n\n    return OK;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 3725,
    "critical_vars": [
      "vterm"
    ],
    "function": "create_vterm",
    "filename": "vim/CVE-2018-20786/CVE-2018-20786_CWE-476_cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8_terminal.c.diff",
    "function_code": "create_vterm(term_T *term, int rows, int cols)\n{\n    VTerm\t    *vterm;\n    VTermScreen\t    *screen;\n    VTermState\t    *state;\n    VTermValue\t    value;\n\n    vterm = vterm_new_with_allocator(rows, cols, &vterm_allocator, NULL);\n    term->tl_vterm = vterm;\n    screen = vterm_obtain_screen(vterm);\n    vterm_screen_set_callbacks(screen, &screen_callbacks, term);\n    /* TODO: depends on 'encoding'. */\n    vterm_set_utf8(vterm, 1);\n\n    init_default_colors(term);\n\n    vterm_state_set_default_colors(\n\t    vterm_obtain_state(vterm),\n\t    &term->tl_default_color.fg,\n\t    &term->tl_default_color.bg);\n\n    if (t_colors >= 16)\n\tvterm_state_set_bold_highbright(vterm_obtain_state(vterm), 1);\n\n    /* Required to initialize most things. */\n    vterm_screen_reset(screen, 1 /* hard */);\n\n    /* Allow using alternate screen. */\n    vterm_screen_enable_altscreen(screen, 1);\n\n    /* For unix do not use a blinking cursor.  In an xterm this causes the\n     * cursor to blink if it's blinking in the xterm.\n     * For Windows we respect the system wide setting. */\n#ifdef WIN3264\n    if (GetCaretBlinkTime() == INFINITE)\n\tvalue.boolean = 0;\n    else\n\tvalue.boolean = 1;\n#else\n    value.boolean = 0;\n#endif\n    state = vterm_obtain_state(vterm);\n    vterm_state_set_termprop(state, VTERM_PROP_CURSORBLINK, &value);\n    vterm_state_set_unrecognised_fallbacks(state, &parser_fallbacks, term);\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 5632,
    "critical_vars": [
      "term->tl_cols",
      "term",
      "term->tl_rows"
    ],
    "function": "term_and_job_init",
    "filename": "vim/CVE-2018-20786/CVE-2018-20786_CWE-476_cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8_terminal.c.diff",
    "function_code": "term_and_job_init(\n\tterm_T\t    *term,\n\ttypval_T    *argvar,\n\tchar\t    **argv UNUSED,\n\tjobopt_T    *opt,\n\tjobopt_T    *orig_opt)\n{\n    WCHAR\t    *cmd_wchar = NULL;\n    WCHAR\t    *cwd_wchar = NULL;\n    WCHAR\t    *env_wchar = NULL;\n    channel_T\t    *channel = NULL;\n    job_T\t    *job = NULL;\n    DWORD\t    error;\n    HANDLE\t    jo = NULL;\n    HANDLE\t    child_process_handle;\n    HANDLE\t    child_thread_handle;\n    void\t    *winpty_err = NULL;\n    void\t    *spawn_config = NULL;\n    garray_T\t    ga_cmd, ga_env;\n    char_u\t    *cmd = NULL;\n\n    if (dyn_winpty_init(TRUE) == FAIL)\n\treturn FAIL;\n    ga_init2(&ga_cmd, (int)sizeof(char*), 20);\n    ga_init2(&ga_env, (int)sizeof(char*), 20);\n\n    if (argvar->v_type == VAR_STRING)\n    {\n\tcmd = argvar->vval.v_string;\n    }\n    else if (argvar->v_type == VAR_LIST)\n    {\n\tif (win32_build_cmd(argvar->vval.v_list, &ga_cmd) == FAIL)\n\t    goto failed;\n\tcmd = ga_cmd.ga_data;\n    }\n    if (cmd == NULL || *cmd == NUL)\n    {\n\tEMSG(_(e_invarg));\n\tgoto failed;\n    }\n\n    cmd_wchar = enc_to_utf16(cmd, NULL);\n    ga_clear(&ga_cmd);\n    if (cmd_wchar == NULL)\n\tgoto failed;\n    if (opt->jo_cwd != NULL)\n\tcwd_wchar = enc_to_utf16(opt->jo_cwd, NULL);\n\n    win32_build_env(opt->jo_env, &ga_env, TRUE);\n    env_wchar = ga_env.ga_data;\n\n    term->tl_winpty_config = winpty_config_new(0, &winpty_err);\n    if (term->tl_winpty_config == NULL)\n\tgoto failed;\n\n    winpty_config_set_mouse_mode(term->tl_winpty_config,\n\t\t\t\t\t\t    WINPTY_MOUSE_MODE_FORCE);\n    winpty_config_set_initial_size(term->tl_winpty_config,\n\t\t\t\t\t\t term->tl_cols, term->tl_rows);\n    term->tl_winpty = winpty_open(term->tl_winpty_config, &winpty_err);\n    if (term->tl_winpty == NULL)\n\tgoto failed;\n\n    spawn_config = winpty_spawn_config_new(\n\t    WINPTY_SPAWN_FLAG_AUTO_SHUTDOWN |\n\t\tWINPTY_SPAWN_FLAG_EXIT_AFTER_SHUTDOWN,\n\t    NULL,\n\t    cmd_wchar,\n\t    cwd_wchar,\n\t    env_wchar,\n\t    &winpty_err);\n    if (spawn_config == NULL)\n\tgoto failed;\n\n    channel = add_channel();\n    if (channel == NULL)\n\tgoto failed;\n\n    job = job_alloc();\n    if (job == NULL)\n\tgoto failed;\n    if (argvar->v_type == VAR_STRING)\n    {\n\tint argc;\n\n\tbuild_argv_from_string(cmd, &job->jv_argv, &argc);\n    }\n    else\n    {\n\tint argc;\n\n\tbuild_argv_from_list(argvar->vval.v_list, &job->jv_argv, &argc);\n    }\n\n    if (opt->jo_set & JO_IN_BUF)\n\tjob->jv_in_buf = buflist_findnr(opt->jo_io_buf[PART_IN]);\n\n    if (!winpty_spawn(term->tl_winpty, spawn_config, &child_process_handle,\n\t    &child_thread_handle, &error, &winpty_err))\n\tgoto failed;\n\n    channel_set_pipes(channel,\n\t(sock_T)CreateFileW(\n\t    winpty_conin_name(term->tl_winpty),\n\t    GENERIC_WRITE, 0, NULL,\n\t    OPEN_EXISTING, 0, NULL),\n\t(sock_T)CreateFileW(\n\t    winpty_conout_name(term->tl_winpty),\n\t    GENERIC_READ, 0, NULL,\n\t    OPEN_EXISTING, 0, NULL),\n\t(sock_T)CreateFileW(\n\t    winpty_conerr_name(term->tl_winpty),\n\t    GENERIC_READ, 0, NULL,\n\t    OPEN_EXISTING, 0, NULL));\n\n    /* Write lines with CR instead of NL. */\n    channel->ch_write_text_mode = TRUE;\n\n    jo = CreateJobObject(NULL, NULL);\n    if (jo == NULL)\n\tgoto failed;\n\n    if (!AssignProcessToJobObject(jo, child_process_handle))\n    {\n\t/* Failed, switch the way to terminate process with TerminateProcess. */\n\tCloseHandle(jo);\n\tjo = NULL;\n    }\n\n    winpty_spawn_config_free(spawn_config);\n    vim_free(cmd_wchar);\n    vim_free(cwd_wchar);\n    vim_free(env_wchar);\n\n    create_vterm(term, term->tl_rows, term->tl_cols);\n\n#if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)\n    if (opt->jo_set2 & JO2_ANSI_COLORS)\n\tset_vterm_palette(term->tl_vterm, opt->jo_ansi_colors);\n    else\n\tinit_vterm_ansi_colors(term->tl_vterm);\n#endif\n\n    channel_set_job(channel, job, opt);\n    job_set_options(job, opt);\n\n    job->jv_channel = channel;\n    job->jv_proc_info.hProcess = child_process_handle;\n    job->jv_proc_info.dwProcessId = GetProcessId(child_process_handle);\n    job->jv_job_object = jo;\n    job->jv_status = JOB_STARTED;\n    job->jv_tty_in = utf16_to_enc(\n\t    (short_u*)winpty_conin_name(term->tl_winpty), NULL);\n    job->jv_tty_out = utf16_to_enc(\n\t    (short_u*)winpty_conout_name(term->tl_winpty), NULL);\n    ++job->jv_refcount;\n    term->tl_job = job;\n\n    /* Redirecting stdout and stderr doesn't work at the job level.  Instead\n     * open the file here and handle it in.  opt->jo_io was changed in\n     * setup_job_options(), use the original flags here. */\n    if (orig_opt->jo_io[PART_OUT] == JIO_FILE)\n    {\n\tchar_u *fname = opt->jo_io_name[PART_OUT];\n\n\tch_log(channel, \"Opening output file %s\", fname);\n\tterm->tl_out_fd = mch_fopen((char *)fname, WRITEBIN);\n\tif (term->tl_out_fd == NULL)\n\t    EMSG2(_(e_notopen), fname);\n    }\n\n    return OK;\n\nfailed:\n    ga_clear(&ga_cmd);\n    ga_clear(&ga_env);\n    vim_free(cmd_wchar);\n    vim_free(cwd_wchar);\n    if (spawn_config != NULL)\n\twinpty_spawn_config_free(spawn_config);\n    if (channel != NULL)\n\tchannel_clear(channel);\n    if (job != NULL)\n    {\n\tjob->jv_channel = NULL;\n\tjob_cleanup(job);\n    }\n    term->tl_job = NULL;\n    if (jo != NULL)\n\tCloseHandle(jo);\n    if (term->tl_winpty != NULL)\n\twinpty_free(term->tl_winpty);\n    term->tl_winpty = NULL;\n    if (term->tl_winpty_config != NULL)\n\twinpty_config_free(term->tl_winpty_config);\n    term->tl_winpty_config = NULL;\n    if (winpty_err != NULL)\n    {\n\tchar_u *msg = utf16_to_enc(\n\t\t\t\t(short_u *)winpty_error_msg(winpty_err), NULL);\n\n\tEMSG(msg);\n\twinpty_error_free(winpty_err);\n    }\n    return FAIL;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 5646,
    "critical_vars": [
      "term->tl_cols",
      "term",
      "term->tl_rows"
    ],
    "function": "term_and_job_init",
    "filename": "vim/CVE-2018-20786/CVE-2018-20786_CWE-476_cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8_terminal.c.diff",
    "function_code": "term_and_job_init(\n\tterm_T\t    *term,\n\ttypval_T    *argvar,\n\tchar\t    **argv UNUSED,\n\tjobopt_T    *opt,\n\tjobopt_T    *orig_opt)\n{\n    WCHAR\t    *cmd_wchar = NULL;\n    WCHAR\t    *cwd_wchar = NULL;\n    WCHAR\t    *env_wchar = NULL;\n    channel_T\t    *channel = NULL;\n    job_T\t    *job = NULL;\n    DWORD\t    error;\n    HANDLE\t    jo = NULL;\n    HANDLE\t    child_process_handle;\n    HANDLE\t    child_thread_handle;\n    void\t    *winpty_err = NULL;\n    void\t    *spawn_config = NULL;\n    garray_T\t    ga_cmd, ga_env;\n    char_u\t    *cmd = NULL;\n\n    if (dyn_winpty_init(TRUE) == FAIL)\n\treturn FAIL;\n    ga_init2(&ga_cmd, (int)sizeof(char*), 20);\n    ga_init2(&ga_env, (int)sizeof(char*), 20);\n\n    if (argvar->v_type == VAR_STRING)\n    {\n\tcmd = argvar->vval.v_string;\n    }\n    else if (argvar->v_type == VAR_LIST)\n    {\n\tif (win32_build_cmd(argvar->vval.v_list, &ga_cmd) == FAIL)\n\t    goto failed;\n\tcmd = ga_cmd.ga_data;\n    }\n    if (cmd == NULL || *cmd == NUL)\n    {\n\tEMSG(_(e_invarg));\n\tgoto failed;\n    }\n\n    cmd_wchar = enc_to_utf16(cmd, NULL);\n    ga_clear(&ga_cmd);\n    if (cmd_wchar == NULL)\n\tgoto failed;\n    if (opt->jo_cwd != NULL)\n\tcwd_wchar = enc_to_utf16(opt->jo_cwd, NULL);\n\n    win32_build_env(opt->jo_env, &ga_env, TRUE);\n    env_wchar = ga_env.ga_data;\n\n    term->tl_winpty_config = winpty_config_new(0, &winpty_err);\n    if (term->tl_winpty_config == NULL)\n\tgoto failed;\n\n    winpty_config_set_mouse_mode(term->tl_winpty_config,\n\t\t\t\t\t\t    WINPTY_MOUSE_MODE_FORCE);\n    winpty_config_set_initial_size(term->tl_winpty_config,\n\t\t\t\t\t\t term->tl_cols, term->tl_rows);\n    term->tl_winpty = winpty_open(term->tl_winpty_config, &winpty_err);\n    if (term->tl_winpty == NULL)\n\tgoto failed;\n\n    spawn_config = winpty_spawn_config_new(\n\t    WINPTY_SPAWN_FLAG_AUTO_SHUTDOWN |\n\t\tWINPTY_SPAWN_FLAG_EXIT_AFTER_SHUTDOWN,\n\t    NULL,\n\t    cmd_wchar,\n\t    cwd_wchar,\n\t    env_wchar,\n\t    &winpty_err);\n    if (spawn_config == NULL)\n\tgoto failed;\n\n    channel = add_channel();\n    if (channel == NULL)\n\tgoto failed;\n\n    job = job_alloc();\n    if (job == NULL)\n\tgoto failed;\n    if (argvar->v_type == VAR_STRING)\n    {\n\tint argc;\n\n\tbuild_argv_from_string(cmd, &job->jv_argv, &argc);\n    }\n    else\n    {\n\tint argc;\n\n\tbuild_argv_from_list(argvar->vval.v_list, &job->jv_argv, &argc);\n    }\n\n    if (opt->jo_set & JO_IN_BUF)\n\tjob->jv_in_buf = buflist_findnr(opt->jo_io_buf[PART_IN]);\n\n    if (!winpty_spawn(term->tl_winpty, spawn_config, &child_process_handle,\n\t    &child_thread_handle, &error, &winpty_err))\n\tgoto failed;\n\n    channel_set_pipes(channel,\n\t(sock_T)CreateFileW(\n\t    winpty_conin_name(term->tl_winpty),\n\t    GENERIC_WRITE, 0, NULL,\n\t    OPEN_EXISTING, 0, NULL),\n\t(sock_T)CreateFileW(\n\t    winpty_conout_name(term->tl_winpty),\n\t    GENERIC_READ, 0, NULL,\n\t    OPEN_EXISTING, 0, NULL),\n\t(sock_T)CreateFileW(\n\t    winpty_conerr_name(term->tl_winpty),\n\t    GENERIC_READ, 0, NULL,\n\t    OPEN_EXISTING, 0, NULL));\n\n    /* Write lines with CR instead of NL. */\n    channel->ch_write_text_mode = TRUE;\n\n    jo = CreateJobObject(NULL, NULL);\n    if (jo == NULL)\n\tgoto failed;\n\n    if (!AssignProcessToJobObject(jo, child_process_handle))\n    {\n\t/* Failed, switch the way to terminate process with TerminateProcess. */\n\tCloseHandle(jo);\n\tjo = NULL;\n    }\n\n    winpty_spawn_config_free(spawn_config);\n    vim_free(cmd_wchar);\n    vim_free(cwd_wchar);\n    vim_free(env_wchar);\n\n    if (create_vterm(term, term->tl_rows, term->tl_cols) == FAIL)\n\tgoto failed;\n\n#if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)\n    if (opt->jo_set2 & JO2_ANSI_COLORS)\n\tset_vterm_palette(term->tl_vterm, opt->jo_ansi_colors);\n    else\n\tinit_vterm_ansi_colors(term->tl_vterm);\n#endif\n\n    channel_set_job(channel, job, opt);\n    job_set_options(job, opt);\n\n    job->jv_channel = channel;\n    job->jv_proc_info.hProcess = child_process_handle;\n    job->jv_proc_info.dwProcessId = GetProcessId(child_process_handle);\n    job->jv_job_object = jo;\n    job->jv_status = JOB_STARTED;\n    job->jv_tty_in = utf16_to_enc(\n\t    (short_u*)winpty_conin_name(term->tl_winpty), NULL);\n    job->jv_tty_out = utf16_to_enc(\n\t    (short_u*)winpty_conout_name(term->tl_winpty), NULL);\n    ++job->jv_refcount;\n    term->tl_job = job;\n\n    /* Redirecting stdout and stderr doesn't work at the job level.  Instead\n     * open the file here and handle it in.  opt->jo_io was changed in\n     * setup_job_options(), use the original flags here. */\n    if (orig_opt->jo_io[PART_OUT] == JIO_FILE)\n    {\n\tchar_u *fname = opt->jo_io_name[PART_OUT];\n\n\tch_log(channel, \"Opening output file %s\", fname);\n\tterm->tl_out_fd = mch_fopen((char *)fname, WRITEBIN);\n\tif (term->tl_out_fd == NULL)\n\t    EMSG2(_(e_notopen), fname);\n    }\n\n    return OK;\n\nfailed:\n    ga_clear(&ga_cmd);\n    ga_clear(&ga_env);\n    vim_free(cmd_wchar);\n    vim_free(cwd_wchar);\n    if (spawn_config != NULL)\n\twinpty_spawn_config_free(spawn_config);\n    if (channel != NULL)\n\tchannel_clear(channel);\n    if (job != NULL)\n    {\n\tjob->jv_channel = NULL;\n\tjob_cleanup(job);\n    }\n    term->tl_job = NULL;\n    if (jo != NULL)\n\tCloseHandle(jo);\n    if (term->tl_winpty != NULL)\n\twinpty_free(term->tl_winpty);\n    term->tl_winpty = NULL;\n    if (term->tl_winpty_config != NULL)\n\twinpty_config_free(term->tl_winpty_config);\n    term->tl_winpty_config = NULL;\n    if (winpty_err != NULL)\n    {\n\tchar_u *msg = utf16_to_enc(\n\t\t\t\t(short_u *)winpty_error_msg(winpty_err), NULL);\n\n\tEMSG(msg);\n\twinpty_error_free(winpty_err);\n    }\n    return FAIL;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 5713,
    "critical_vars": [
      "term->tl_cols",
      "term",
      "term->tl_rows"
    ],
    "function": "create_pty_only",
    "filename": "vim/CVE-2018-20786/CVE-2018-20786_CWE-476_cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8_terminal.c.diff",
    "function_code": "create_pty_only(term_T *term, jobopt_T *options)\n{\n    HANDLE\t    hPipeIn = INVALID_HANDLE_VALUE;\n    HANDLE\t    hPipeOut = INVALID_HANDLE_VALUE;\n    char\t    in_name[80], out_name[80];\n    channel_T\t    *channel = NULL;\n\n    create_vterm(term, term->tl_rows, term->tl_cols);\n\n    vim_snprintf(in_name, sizeof(in_name), \"\\\\\\\\.\\\\pipe\\\\vim-%d-in-%d\",\n\t    GetCurrentProcessId(),\n\t    curbuf->b_fnum);\n    hPipeIn = CreateNamedPipe(in_name, PIPE_ACCESS_OUTBOUND,\n\t    PIPE_TYPE_MESSAGE | PIPE_NOWAIT,\n\t    PIPE_UNLIMITED_INSTANCES,\n\t    0, 0, NMPWAIT_NOWAIT, NULL);\n    if (hPipeIn == INVALID_HANDLE_VALUE)\n\tgoto failed;\n\n    vim_snprintf(out_name, sizeof(out_name), \"\\\\\\\\.\\\\pipe\\\\vim-%d-out-%d\",\n\t    GetCurrentProcessId(),\n\t    curbuf->b_fnum);\n    hPipeOut = CreateNamedPipe(out_name, PIPE_ACCESS_INBOUND,\n\t    PIPE_TYPE_MESSAGE | PIPE_NOWAIT,\n\t    PIPE_UNLIMITED_INSTANCES,\n\t    0, 0, 0, NULL);\n    if (hPipeOut == INVALID_HANDLE_VALUE)\n\tgoto failed;\n\n    ConnectNamedPipe(hPipeIn, NULL);\n    ConnectNamedPipe(hPipeOut, NULL);\n\n    term->tl_job = job_alloc();\n    if (term->tl_job == NULL)\n\tgoto failed;\n    ++term->tl_job->jv_refcount;\n\n    /* behave like the job is already finished */\n    term->tl_job->jv_status = JOB_FINISHED;\n\n    channel = add_channel();\n    if (channel == NULL)\n\tgoto failed;\n    term->tl_job->jv_channel = channel;\n    channel->ch_keep_open = TRUE;\n    channel->ch_named_pipe = TRUE;\n\n    channel_set_pipes(channel,\n\t(sock_T)hPipeIn,\n\t(sock_T)hPipeOut,\n\t(sock_T)hPipeOut);\n    channel_set_job(channel, term->tl_job, options);\n    term->tl_job->jv_tty_in = vim_strsave((char_u*)in_name);\n    term->tl_job->jv_tty_out = vim_strsave((char_u*)out_name);\n\n    return OK;\n\nfailed:\n    if (hPipeIn != NULL)\n\tCloseHandle(hPipeIn);\n    if (hPipeOut != NULL)\n\tCloseHandle(hPipeOut);\n    return FAIL;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 5728,
    "critical_vars": [
      "term->tl_cols",
      "term",
      "term->tl_rows"
    ],
    "function": "create_pty_only",
    "filename": "vim/CVE-2018-20786/CVE-2018-20786_CWE-476_cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8_terminal.c.diff",
    "function_code": "create_pty_only(term_T *term, jobopt_T *options)\n{\n    HANDLE\t    hPipeIn = INVALID_HANDLE_VALUE;\n    HANDLE\t    hPipeOut = INVALID_HANDLE_VALUE;\n    char\t    in_name[80], out_name[80];\n    channel_T\t    *channel = NULL;\n\n    if (create_vterm(term, term->tl_rows, term->tl_cols) == FAIL)\n\treturn FAIL;\n\n    vim_snprintf(in_name, sizeof(in_name), \"\\\\\\\\.\\\\pipe\\\\vim-%d-in-%d\",\n\t    GetCurrentProcessId(),\n\t    curbuf->b_fnum);\n    hPipeIn = CreateNamedPipe(in_name, PIPE_ACCESS_OUTBOUND,\n\t    PIPE_TYPE_MESSAGE | PIPE_NOWAIT,\n\t    PIPE_UNLIMITED_INSTANCES,\n\t    0, 0, NMPWAIT_NOWAIT, NULL);\n    if (hPipeIn == INVALID_HANDLE_VALUE)\n\tgoto failed;\n\n    vim_snprintf(out_name, sizeof(out_name), \"\\\\\\\\.\\\\pipe\\\\vim-%d-out-%d\",\n\t    GetCurrentProcessId(),\n\t    curbuf->b_fnum);\n    hPipeOut = CreateNamedPipe(out_name, PIPE_ACCESS_INBOUND,\n\t    PIPE_TYPE_MESSAGE | PIPE_NOWAIT,\n\t    PIPE_UNLIMITED_INSTANCES,\n\t    0, 0, 0, NULL);\n    if (hPipeOut == INVALID_HANDLE_VALUE)\n\tgoto failed;\n\n    ConnectNamedPipe(hPipeIn, NULL);\n    ConnectNamedPipe(hPipeOut, NULL);\n\n    term->tl_job = job_alloc();\n    if (term->tl_job == NULL)\n\tgoto failed;\n    ++term->tl_job->jv_refcount;\n\n    /* behave like the job is already finished */\n    term->tl_job->jv_status = JOB_FINISHED;\n\n    channel = add_channel();\n    if (channel == NULL)\n\tgoto failed;\n    term->tl_job->jv_channel = channel;\n    channel->ch_keep_open = TRUE;\n    channel->ch_named_pipe = TRUE;\n\n    channel_set_pipes(channel,\n\t(sock_T)hPipeIn,\n\t(sock_T)hPipeOut,\n\t(sock_T)hPipeOut);\n    channel_set_job(channel, term->tl_job, options);\n    term->tl_job->jv_tty_in = vim_strsave((char_u*)in_name);\n    term->tl_job->jv_tty_out = vim_strsave((char_u*)out_name);\n\n    return OK;\n\nfailed:\n    if (hPipeIn != NULL)\n\tCloseHandle(hPipeIn);\n    if (hPipeOut != NULL)\n\tCloseHandle(hPipeOut);\n    return FAIL;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 45,
    "critical_vars": [
      "vt"
    ],
    "function": "*vterm_new_with_allocator",
    "filename": "vim/CVE-2018-20786/CVE-2018-20786_CWE-476_cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8_vterm.c.diff",
    "function_code": "VTerm *vterm_new_with_allocator(int rows, int cols, VTermAllocatorFunctions *funcs, void *allocdata)\n{\n  /* Need to bootstrap using the allocator function directly */\n  VTerm *vt = (*funcs->malloc)(sizeof(VTerm), allocdata);\n\n  if (vt == NULL)\n    return NULL;\n  vt->allocator = funcs;\n  vt->allocdata = allocdata;\n\n  vt->rows = rows;\n  vt->cols = cols;\n\n  vt->parser.state = NORMAL;\n\n  vt->parser.callbacks = NULL;\n  vt->parser.cbdata    = NULL;\n\n  vt->parser.strbuffer_len = 500; /* should be able to hold an OSC string */\n  vt->parser.strbuffer_cur = 0;\n  vt->parser.strbuffer = vterm_allocator_malloc(vt, vt->parser.strbuffer_len);\n  if (vt->parser.strbuffer == NULL)\n  {\n    vterm_allocator_free(vt, vt);\n    return NULL;\n  }\n\n  vt->outbuffer_len = 200;\n  vt->outbuffer_cur = 0;\n  vt->outbuffer = vterm_allocator_malloc(vt, vt->outbuffer_len);\n  if (vt->outbuffer == NULL)\n  {\n    vterm_allocator_free(vt, vt->parser.strbuffer);\n    vterm_allocator_free(vt, vt);\n    return NULL;\n  }\n\n  return vt;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 56,
    "critical_vars": [
      "state"
    ],
    "function": "*vterm_state_new",
    "filename": "vim/CVE-2018-20786/CVE-2018-20786_CWE-476_cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8_state.c.diff",
    "function_code": "static VTermState *vterm_state_new(VTerm *vt)\n{\n  VTermState *state = vterm_allocator_malloc(vt, sizeof(VTermState));\n\n  if (state == NULL)\n    return NULL;\n  state->vt = vt;\n\n  state->rows = vt->rows;\n  state->cols = vt->cols;\n\n  state->mouse_col     = 0;\n  state->mouse_row     = 0;\n  state->mouse_buttons = 0;\n\n  state->mouse_protocol = MOUSE_X10;\n\n  state->callbacks = NULL;\n  state->cbdata    = NULL;\n\n  vterm_state_newpen(state);\n\n  state->bold_is_highbright = 0;\n\n  return state;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1709,
    "critical_vars": [
      "state"
    ],
    "function": "*vterm_obtain_state",
    "filename": "vim/CVE-2018-20786/CVE-2018-20786_CWE-476_cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8_state.c.diff",
    "function_code": "VTermState *vterm_obtain_state(VTerm *vt)\n{\n  VTermState *state;\n  if(vt->state)\n    return vt->state;\n\n  state = vterm_state_new(vt);\n  if (state == NULL)\n    return NULL;\n  vt->state = state;\n\n  state->combine_chars_size = 16;\n  state->combine_chars = vterm_allocator_malloc(state->vt, state->combine_chars_size * sizeof(state->combine_chars[0]));\n\n  state->tabstops = vterm_allocator_malloc(state->vt, (state->cols + 7) / 8);\n\n  state->lineinfo = vterm_allocator_malloc(state->vt, state->rows * sizeof(VTermLineInfo));\n\n  state->encoding_utf8.enc = vterm_lookup_encoding(ENC_UTF8, 'u');\n  if(*state->encoding_utf8.enc->init != NULL)\n    (*state->encoding_utf8.enc->init)(state->encoding_utf8.enc, state->encoding_utf8.data);\n\n  vterm_parser_set_callbacks(vt, &parser_callbacks, state);\n\n  return state;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 304,
    "critical_vars": [
      "y_current->y_array"
    ],
    "function": "get_register",
    "filename": "vim/CVE-2023-2609/CVE-2023-2609_CWE-476_d1ae8366aff286d41e7f5bc513cc0a1af5130aad_register.c.diff",
    "function_code": "get_register(\n    int\t\tname,\n    int\t\tcopy)\t// make a copy, if FALSE make register empty.\n{\n    yankreg_T\t*reg;\n    int\t\ti;\n\n#ifdef FEAT_CLIPBOARD\n    // When Visual area changed, may have to update selection.  Obtain the\n    // selection too.\n    if (name == '*' && clip_star.available)\n    {\n\tif (clip_isautosel_star())\n\t    clip_update_selection(&clip_star);\n\tmay_get_selection(name);\n    }\n    if (name == '+' && clip_plus.available)\n    {\n\tif (clip_isautosel_plus())\n\t    clip_update_selection(&clip_plus);\n\tmay_get_selection(name);\n    }\n#endif\n\n    get_yank_register(name, 0);\n    reg = ALLOC_ONE(yankreg_T);\n    if (reg == NULL)\n\treturn (void *)NULL;\n\n    *reg = *y_current;\n    if (copy)\n    {\n\t// If we run out of memory some or all of the lines are empty.\n\tif (reg->y_size == 0 || y_current->y_array == NULL)\n\t    reg->y_array = NULL;\n\telse\n\t    reg->y_array = ALLOC_MULT(char_u *, reg->y_size);\n\tif (reg->y_array != NULL)\n\t{\n\t    for (i = 0; i < reg->y_size; ++i)\n\t\treg->y_array[i] = vim_strsave(y_current->y_array[i]);\n\t}\n    }\n    else\n\ty_current->y_array = NULL;\n    return (void *)reg;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 2960,
    "critical_vars": [
      "rmp->regprog"
    ],
    "function": "fname_match",
    "filename": "vim/CVE-2022-1620/CVE-2022-1620_CWE-476_8e4b76da1d7e987d43ca960dfbc372d1c617466f_buffer.c.diff",
    "function_code": "fname_match(\n    regmatch_T\t*rmp,\n    char_u\t*name,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match = NULL;\n    char_u\t*p;\n\n    if (name != NULL)\n    {\n\t// Ignore case when 'fileignorecase' or the argument is set.\n\trmp->rm_ic = p_fic || ignore_case;\n\tif (vim_regexec(rmp, name, (colnr_T)0))\n\t    match = name;\n\telse if (rmp->regprog != NULL)\n\t{\n\t    // Replace $(HOME) with '~' and try matching again.\n\t    p = home_replace_save(NULL, name);\n\t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n\t\tmatch = name;\n\t    vim_free(p);\n\t}\n    }\n\n    return match;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 3477,
    "critical_vars": [
      "c1"
    ],
    "function": "vgetorpeek",
    "filename": "vim/CVE-2023-1264/CVE-2023-1264_CWE-476_7ac5023a5f1a37baafbe1043645f97ba3443d9f6_getchar.c.diff",
    "function_code": "vgetorpeek(int advance)\n{\n    int\t\tc, c1;\n    int\t\ttimedout = FALSE;\t// waited for more than 'timeoutlen'\n\t\t\t\t\t// for mapping to complete or\n\t\t\t\t\t// 'ttimeoutlen' for complete key code\n    int\t\tmapdepth = 0;\t\t// check for recursive mapping\n    int\t\tmode_deleted = FALSE;   // set when mode has been deleted\n    int\t\tnew_wcol, new_wrow;\n#ifdef FEAT_GUI\n    int\t\tshape_changed = FALSE;  // adjusted cursor shape\n#endif\n    int\t\tn;\n    int\t\told_wcol, old_wrow;\n    int\t\twait_tb_len;\n\n    /*\n     * This function doesn't work very well when called recursively.  This may\n     * happen though, because of:\n     * 1. The call to add_to_showcmd().\tchar_avail() is then used to check if\n     * there is a character available, which calls this function.  In that\n     * case we must return NUL, to indicate no character is available.\n     * 2. A GUI callback function writes to the screen, causing a\n     * wait_return().\n     * Using \":normal\" can also do this, but it saves the typeahead buffer,\n     * thus it should be OK.  But don't get a key from the user then.\n     */\n    if (vgetc_busy > 0 && ex_normal_busy == 0)\n\treturn NUL;\n\n    ++vgetc_busy;\n\n    if (advance)\n    {\n\tKeyStuffed = FALSE;\n\ttypebuf_was_empty = FALSE;\n    }\n\n    init_typebuf();\n    start_stuff();\n    check_end_reg_executing(advance);\n    do\n    {\n/*\n * get a character: 1. from the stuffbuffer\n */\n\tif (typeahead_char != 0)\n\t{\n\t    c = typeahead_char;\n\t    if (advance)\n\t\ttypeahead_char = 0;\n\t}\n\telse\n\t    c = read_readbuffers(advance);\n\tif (c != NUL && !got_int)\n\t{\n\t    if (advance)\n\t    {\n\t\t// KeyTyped = FALSE;  When the command that stuffed something\n\t\t// was typed, behave like the stuffed command was typed.\n\t\t// needed for CTRL-W CTRL-] to open a fold, for example.\n\t\tKeyStuffed = TRUE;\n\t    }\n\t    if (typebuf.tb_no_abbr_cnt == 0)\n\t\ttypebuf.tb_no_abbr_cnt = 1;\t// no abbreviations now\n\t}\n\telse\n\t{\n\t    /*\n\t     * Loop until we either find a matching mapped key, or we\n\t     * are sure that it is not a mapped key.\n\t     * If a mapped key sequence is found we go back to the start to\n\t     * try re-mapping.\n\t     */\n\t    for (;;)\n\t    {\n\t\tlong\twait_time;\n\t\tint\tkeylen = 0;\n\t\tint\tshowcmd_idx;\n\t\tcheck_end_reg_executing(advance);\n\t\t/*\n\t\t * ui_breakcheck() is slow, don't use it too often when\n\t\t * inside a mapping.  But call it each time for typed\n\t\t * characters.\n\t\t */\n\t\tif (typebuf.tb_maplen)\n\t\t    line_breakcheck();\n\t\telse\n\t\t    ui_breakcheck();\t\t// check for CTRL-C\n\t\tif (got_int)\n\t\t{\n\t\t    // flush all input\n\t\t    c = inchar(typebuf.tb_buf, typebuf.tb_buflen - 1, 0L);\n\n\t\t    /*\n\t\t     * If inchar() returns TRUE (script file was active) or we\n\t\t     * are inside a mapping, get out of Insert mode.\n\t\t     * Otherwise we behave like having gotten a CTRL-C.\n\t\t     * As a result typing CTRL-C in insert mode will\n\t\t     * really insert a CTRL-C.\n\t\t     */\n\t\t    if ((c || typebuf.tb_maplen)\n\t\t\t\t     && (State & (MODE_INSERT | MODE_CMDLINE)))\n\t\t\tc = ESC;\n\t\t    else\n\t\t\tc = Ctrl_C;\n\t\t    flush_buffers(FLUSH_INPUT);\t// flush all typeahead\n\n\t\t    if (advance)\n\t\t    {\n\t\t\t// Also record this character, it might be needed to\n\t\t\t// get out of Insert mode.\n\t\t\t*typebuf.tb_buf = c;\n\t\t\tgotchars(typebuf.tb_buf, 1);\n\t\t    }\n\t\t    cmd_silent = FALSE;\n\n\t\t    break;\n\t\t}\n\t\telse if (typebuf.tb_len > 0)\n\t\t{\n\t\t    /*\n\t\t     * Check for a mapping in \"typebuf\".\n\t\t     */\n\t\t    map_result_T result = handle_mapping(\n\t\t\t\t\t\t&keylen, &timedout, &mapdepth);\n\n\t\t    if (result == map_result_retry)\n\t\t\t// try mapping again\n\t\t\tcontinue;\n\t\t    if (result == map_result_fail)\n\t\t    {\n\t\t\t// failed, use the outer loop\n\t\t\tc = -1;\n\t\t\tbreak;\n\t\t    }\n\t\t    if (result == map_result_get)\n\t\t    {\n/*\n * get a character: 2. from the typeahead buffer\n */\n\t\t\tc = typebuf.tb_buf[typebuf.tb_off];\n\t\t\tif (advance)\t// remove chars from tb_buf\n\t\t\t{\n\t\t\t    cmd_silent = (typebuf.tb_silent > 0);\n\t\t\t    if (typebuf.tb_maplen > 0)\n\t\t\t\tKeyTyped = FALSE;\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tKeyTyped = TRUE;\n\t\t\t\t// write char to script file(s)\n\t\t\t\tgotchars(typebuf.tb_buf\n\t\t\t\t\t\t + typebuf.tb_off, 1);\n\t\t\t    }\n\t\t\t    KeyNoremap = typebuf.tb_noremap[\n\t\t\t\t\t\t      typebuf.tb_off];\n\t\t\t    del_typebuf(1, 0);\n\t\t\t}\n\t\t\tbreak;  // got character, break the for loop\n\t\t    }\n\n\t\t    // not enough characters, get more\n\t\t}\n\n/*\n * get a character: 3. from the user - handle <Esc> in Insert mode\n */\n\t\t/*\n\t\t * Special case: if we get an <ESC> in Insert mode and there\n\t\t * are no more characters at once, we pretend to go out of\n\t\t * Insert mode.  This prevents the one second delay after\n\t\t * typing an <ESC>.  If we get something after all, we may\n\t\t * have to redisplay the mode. That the cursor is in the wrong\n\t\t * place does not matter.\n\t\t * Do not do this if the kitty keyboard protocol is used, every\n\t\t * <ESC> is the start of an escape sequence then.\n\t\t */\n\t\tc = 0;\n\t\tnew_wcol = curwin->w_wcol;\n\t\tnew_wrow = curwin->w_wrow;\n\t\tif (\t   advance\n\t\t\t&& typebuf.tb_len == 1\n\t\t\t&& typebuf.tb_buf[typebuf.tb_off] == ESC\n\t\t\t&& !no_mapping\n\t\t\t&& kitty_protocol_state != KKPS_ENABLED\n\t\t\t&& ex_normal_busy == 0\n\t\t\t&& typebuf.tb_maplen == 0\n\t\t\t&& (State & MODE_INSERT)\n\t\t\t&& (p_timeout\n\t\t\t    || (keylen == KEYLEN_PART_KEY && p_ttimeout))\n\t\t\t&& (c = inchar(typebuf.tb_buf + typebuf.tb_off\n\t\t\t\t\t       + typebuf.tb_len, 3, 25L)) == 0)\n\t\t{\n\t\t    colnr_T\tcol = 0;\n\t\t    char_u\t*ptr;\n\n\t\t    if (mode_displayed)\n\t\t    {\n\t\t\tunshowmode(TRUE);\n\t\t\tmode_deleted = TRUE;\n\t\t    }\n#ifdef FEAT_GUI\n\t\t    // may show a different cursor shape\n\t\t    if (gui.in_use && State != MODE_NORMAL && !cmd_silent)\n\t\t    {\n\t\t\tint\t    save_State;\n\n\t\t\tsave_State = State;\n\t\t\tState = MODE_NORMAL;\n\t\t\tgui_update_cursor(TRUE, FALSE);\n\t\t\tState = save_State;\n\t\t\tshape_changed = TRUE;\n\t\t    }\n#endif\n\t\t    validate_cursor();\n\t\t    old_wcol = curwin->w_wcol;\n\t\t    old_wrow = curwin->w_wrow;\n\n\t\t    // move cursor left, if possible\n\t\t    if (curwin->w_cursor.col != 0)\n\t\t    {\n\t\t\tif (curwin->w_wcol > 0)\n\t\t\t{\n\t\t\t    // After auto-indenting and no text is following,\n\t\t\t    // we are expecting to truncate the trailing\n\t\t\t    // white-space, so find the last non-white\n\t\t\t    // character -- webb\n\t\t\t    if (did_ai && *skipwhite(ml_get_curline()\n\t\t\t\t\t\t+ curwin->w_cursor.col) == NUL)\n\t\t\t    {\n\t\t\t\tchartabsize_T cts;\n\n\t\t\t\tcurwin->w_wcol = 0;\n\t\t\t\tptr = ml_get_curline();\n\t\t\t\tinit_chartabsize_arg(&cts, curwin,\n\t\t\t\t\t  curwin->w_cursor.lnum, 0, ptr, ptr);\n\t\t\t\twhile (cts.cts_ptr < ptr + curwin->w_cursor.col)\n\t\t\t\t{\n\t\t\t\t    if (!VIM_ISWHITE(*cts.cts_ptr))\n\t\t\t\t\tcurwin->w_wcol = cts.cts_vcol;\n\t\t\t\t    cts.cts_vcol += lbr_chartabsize(&cts);\n\t\t\t\t    if (has_mbyte)\n\t\t\t\t\tcts.cts_ptr +=\n\t\t\t\t\t\t   (*mb_ptr2len)(cts.cts_ptr);\n\t\t\t\t    else\n\t\t\t\t\t++cts.cts_ptr;\n\t\t\t\t}\n\t\t\t\tclear_chartabsize_arg(&cts);\n\n\t\t\t\tcurwin->w_wrow = curwin->w_cline_row\n\t\t\t\t\t   + curwin->w_wcol / curwin->w_width;\n\t\t\t\tcurwin->w_wcol %= curwin->w_width;\n\t\t\t\tcurwin->w_wcol += curwin_col_off();\n\t\t\t\tcol = 0;\t// no correction needed\n\t\t\t    }\n\t\t\t    else\n\t\t\t    {\n\t\t\t\t--curwin->w_wcol;\n\t\t\t\tcol = curwin->w_cursor.col - 1;\n\t\t\t    }\n\t\t\t}\n\t\t\telse if (curwin->w_p_wrap && curwin->w_wrow)\n\t\t\t{\n\t\t\t    --curwin->w_wrow;\n\t\t\t    curwin->w_wcol = curwin->w_width - 1;\n\t\t\t    col = curwin->w_cursor.col - 1;\n\t\t\t}\n\t\t\tif (has_mbyte && col > 0 && curwin->w_wcol > 0)\n\t\t\t{\n\t\t\t    // Correct when the cursor is on the right halve\n\t\t\t    // of a double-wide character.\n\t\t\t    ptr = ml_get_curline();\n\t\t\t    col -= (*mb_head_off)(ptr, ptr + col);\n\t\t\t    if ((*mb_ptr2cells)(ptr + col) > 1)\n\t\t\t\t--curwin->w_wcol;\n\t\t\t}\n\t\t    }\n\t\t    setcursor();\n\t\t    out_flush();\n\t\t    new_wcol = curwin->w_wcol;\n\t\t    new_wrow = curwin->w_wrow;\n\t\t    curwin->w_wcol = old_wcol;\n\t\t    curwin->w_wrow = old_wrow;\n\t\t}\n\t\tif (c < 0)\n\t\t    continue;\t// end of input script reached\n\n\t\t// Allow mapping for just typed characters. When we get here c\n\t\t// is the number of extra bytes and typebuf.tb_len is 1.\n\t\tfor (n = 1; n <= c; ++n)\n\t\t    typebuf.tb_noremap[typebuf.tb_off + n] = RM_YES;\n\t\ttypebuf.tb_len += c;\n\n\t\t// buffer full, don't map\n\t\tif (typebuf.tb_len >= typebuf.tb_maplen + MAXMAPLEN)\n\t\t{\n\t\t    timedout = TRUE;\n\t\t    continue;\n\t\t}\n\n\t\tif (ex_normal_busy > 0)\n\t\t{\n\t\t    static int tc = 0;\n\n\t\t    // No typeahead left and inside \":normal\".  Must return\n\t\t    // something to avoid getting stuck.  When an incomplete\n\t\t    // mapping is present, behave like it timed out.\n\t\t    if (typebuf.tb_len > 0)\n\t\t    {\n\t\t\ttimedout = TRUE;\n\t\t\tcontinue;\n\t\t    }\n\n\t\t    // When 'insertmode' is set, ESC just beeps in Insert\n\t\t    // mode.  Use CTRL-L to make edit() return.\n\t\t    // For the command line only CTRL-C always breaks it.\n\t\t    // For the cmdline window: Alternate between ESC and\n\t\t    // CTRL-C: ESC for most situations and CTRL-C to close the\n\t\t    // cmdline window.\n\t\t    if (p_im && (State & MODE_INSERT))\n\t\t\tc = Ctrl_L;\n#ifdef FEAT_TERMINAL\n\t\t    else if (terminal_is_active())\n\t\t\tc = K_CANCEL;\n#endif\n\t\t    else if ((State & MODE_CMDLINE)\n\t\t\t\t\t     || (cmdwin_type > 0 && tc == ESC))\n\t\t\tc = Ctrl_C;\n\t\t    else\n\t\t\tc = ESC;\n\t\t    tc = c;\n\t\t    // set a flag to indicate this wasn't a normal char\n\t\t    if (advance)\n\t\t\ttypebuf_was_empty = TRUE;\n\n\t\t    // return from main_loop()\n\t\t    if (pending_exmode_active)\n\t\t\texmode_active = EXMODE_NORMAL;\n\n\t\t    // no chars to block abbreviation for\n\t\t    typebuf.tb_no_abbr_cnt = 0;\n\n\t\t    break;\n\t\t}\n\n/*\n * get a character: 3. from the user - update display\n */\n\t\t// In insert mode a screen update is skipped when characters\n\t\t// are still available.  But when those available characters\n\t\t// are part of a mapping, and we are going to do a blocking\n\t\t// wait here.  Need to update the screen to display the\n\t\t// changed text so far. Also for when 'lazyredraw' is set and\n\t\t// redrawing was postponed because there was something in the\n\t\t// input buffer (e.g., termresponse).\n\t\tif (((State & MODE_INSERT) != 0 || p_lz)\n\t\t\t&& (State & MODE_CMDLINE) == 0\n\t\t\t&& advance && must_redraw != 0 && !need_wait_return)\n\t\t{\n\t\t    update_screen(0);\n\t\t    setcursor(); // put cursor back where it belongs\n\t\t}\n\n\t\t/*\n\t\t * If we have a partial match (and are going to wait for more\n\t\t * input from the user), show the partially matched characters\n\t\t * to the user with showcmd.\n\t\t */\n\t\tshowcmd_idx = 0;\n\t\tc1 = 0;\n\t\tif (typebuf.tb_len > 0 && advance && !exmode_active)\n\t\t{\n\t\t    if (((State & (MODE_NORMAL | MODE_INSERT))\n\t\t\t\t\t\t      || State == MODE_LANGMAP)\n\t\t\t    && State != MODE_HITRETURN)\n\t\t    {\n\t\t\t// this looks nice when typing a dead character map\n\t\t\tif (State & MODE_INSERT\n\t\t\t    && ptr2cells(typebuf.tb_buf + typebuf.tb_off\n\t\t\t\t\t\t   + typebuf.tb_len - 1) == 1)\n\t\t\t{\n\t\t\t    edit_putchar(typebuf.tb_buf[typebuf.tb_off\n\t\t\t\t\t\t+ typebuf.tb_len - 1], FALSE);\n\t\t\t    setcursor(); // put cursor back where it belongs\n\t\t\t    c1 = 1;\n\t\t\t}\n\t\t\t// need to use the col and row from above here\n\t\t\told_wcol = curwin->w_wcol;\n\t\t\told_wrow = curwin->w_wrow;\n\t\t\tcurwin->w_wcol = new_wcol;\n\t\t\tcurwin->w_wrow = new_wrow;\n\t\t\tpush_showcmd();\n\t\t\tif (typebuf.tb_len > SHOWCMD_COLS)\n\t\t\t    showcmd_idx = typebuf.tb_len - SHOWCMD_COLS;\n\t\t\twhile (showcmd_idx < typebuf.tb_len)\n\t\t\t    (void)add_to_showcmd(\n\t\t\t       typebuf.tb_buf[typebuf.tb_off + showcmd_idx++]);\n\t\t\tcurwin->w_wcol = old_wcol;\n\t\t\tcurwin->w_wrow = old_wrow;\n\t\t    }\n\n\t\t    // this looks nice when typing a dead character map\n\t\t    if ((State & MODE_CMDLINE)\n#if defined(FEAT_CRYPT) || defined(FEAT_EVAL)\n\t\t\t    && cmdline_star == 0\n#endif\n\t\t\t    && ptr2cells(typebuf.tb_buf + typebuf.tb_off\n\t\t\t\t\t\t   + typebuf.tb_len - 1) == 1)\n\t\t    {\n\t\t\tputcmdline(typebuf.tb_buf[typebuf.tb_off\n\t\t\t\t\t\t+ typebuf.tb_len - 1], FALSE);\n\t\t\tc1 = 1;\n\t\t    }\n\t\t}\n\n/*\n * get a character: 3. from the user - get it\n */\n\t\tif (typebuf.tb_len == 0)\n\t\t    // timedout may have been set if a mapping with empty RHS\n\t\t    // fully matched while longer mappings timed out.\n\t\t    timedout = FALSE;\n\n\t\tif (advance)\n\t\t{\n\t\t    if (typebuf.tb_len == 0\n\t\t\t    || !(p_timeout\n\t\t\t\t || (p_ttimeout && keylen == KEYLEN_PART_KEY)))\n\t\t\t// blocking wait\n\t\t\twait_time = -1L;\n\t\t    else if (keylen == KEYLEN_PART_KEY && p_ttm >= 0)\n\t\t\twait_time = p_ttm;\n\t\t    else\n\t\t\twait_time = p_tm;\n\t\t}\n\t\telse\n\t\t    wait_time = 0;\n\n\t\twait_tb_len = typebuf.tb_len;\n\t\tc = inchar(typebuf.tb_buf + typebuf.tb_off + typebuf.tb_len,\n\t\t\ttypebuf.tb_buflen - typebuf.tb_off - typebuf.tb_len - 1,\n\t\t\twait_time);\n\n\t\tif (showcmd_idx != 0)\n\t\t    pop_showcmd();\n\t\tif (c1 == 1)\n\t\t{\n\t\t    if (State & MODE_INSERT)\n\t\t\tedit_unputchar();\n\t\t    if (State & MODE_CMDLINE)\n\t\t\tunputcmdline();\n\t\t    else\n\t\t\tsetcursor();\t// put cursor back where it belongs\n\t\t}\n\n\t\tif (c < 0)\n\t\t    continue;\t\t// end of input script reached\n\t\tif (c == NUL)\t\t// no character available\n\t\t{\n\t\t    if (!advance)\n\t\t\tbreak;\n\t\t    if (wait_tb_len > 0)\t// timed out\n\t\t    {\n\t\t\ttimedout = TRUE;\n\t\t\tcontinue;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\t    // allow mapping for just typed characters\n\t\t    while (typebuf.tb_buf[typebuf.tb_off\n\t\t\t\t\t\t     + typebuf.tb_len] != NUL)\n\t\t\ttypebuf.tb_noremap[typebuf.tb_off\n\t\t\t\t\t\t + typebuf.tb_len++] = RM_YES;\n#ifdef HAVE_INPUT_METHOD\n\t\t    // Get IM status right after getting keys, not after the\n\t\t    // timeout for a mapping (focus may be lost by then).\n\t\t    vgetc_im_active = im_get_status();\n#endif\n\t\t}\n\t    }\t    // for (;;)\n\t}\t// if (!character from stuffbuf)\n\n\t// if advance is FALSE don't loop on NULs\n    } while ((c < 0 && c != K_CANCEL) || (advance && c == NUL));\n\n    /*\n     * The \"INSERT\" message is taken care of here:\n     *\t if we return an ESC to exit insert mode, the message is deleted\n     *\t if we don't return an ESC but deleted the message before, redisplay it\n     */\n    if (advance && p_smd && msg_silent == 0 && (State & MODE_INSERT))\n    {\n\tif (c == ESC && !mode_deleted && !no_mapping && mode_displayed)\n\t{\n\t    if (typebuf.tb_len && !KeyTyped)\n\t\tredraw_cmdline = TRUE;\t    // delete mode later\n\t    else\n\t\tunshowmode(FALSE);\n\t}\n\telse if (c != ESC && mode_deleted)\n\t{\n\t    if (typebuf.tb_len && !KeyTyped)\n\t\tredraw_cmdline = TRUE;\t    // show mode later\n\t    else\n\t\tshowmode();\n\t}\n    }\n#ifdef FEAT_GUI\n    // may unshow different cursor shape\n    if (gui.in_use && shape_changed)\n\tgui_update_cursor(TRUE, FALSE);\n#endif\n    if (timedout && c == ESC)\n    {\n\tchar_u nop_buf[3];\n\n\t// When recording there will be no timeout.  Add a <Nop> after the ESC\n\t// to avoid that it forms a key code with following characters.\n\tnop_buf[0] = K_SPECIAL;\n\tnop_buf[1] = KS_EXTRA;\n\tnop_buf[2] = KE_NOP;\n\tgotchars(nop_buf, 3);\n    }\n\n    --vgetc_busy;\n\n    return c;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 3477,
    "critical_vars": [
      "showing_partial"
    ],
    "function": "vgetorpeek",
    "filename": "vim/CVE-2023-1264/CVE-2023-1264_CWE-476_7ac5023a5f1a37baafbe1043645f97ba3443d9f6_getchar.c.diff",
    "function_code": "vgetorpeek(int advance)\n{\n    int\t\tc;\n    int\t\ttimedout = FALSE;\t// waited for more than 'timeoutlen'\n\t\t\t\t\t// for mapping to complete or\n\t\t\t\t\t// 'ttimeoutlen' for complete key code\n    int\t\tmapdepth = 0;\t\t// check for recursive mapping\n    int\t\tmode_deleted = FALSE;   // set when mode has been deleted\n    int\t\tnew_wcol, new_wrow;\n#ifdef FEAT_GUI\n    int\t\tshape_changed = FALSE;  // adjusted cursor shape\n#endif\n    int\t\tn;\n    int\t\told_wcol, old_wrow;\n    int\t\twait_tb_len;\n\n    /*\n     * This function doesn't work very well when called recursively.  This may\n     * happen though, because of:\n     * 1. The call to add_to_showcmd().\tchar_avail() is then used to check if\n     * there is a character available, which calls this function.  In that\n     * case we must return NUL, to indicate no character is available.\n     * 2. A GUI callback function writes to the screen, causing a\n     * wait_return().\n     * Using \":normal\" can also do this, but it saves the typeahead buffer,\n     * thus it should be OK.  But don't get a key from the user then.\n     */\n    if (vgetc_busy > 0 && ex_normal_busy == 0)\n\treturn NUL;\n\n    ++vgetc_busy;\n\n    if (advance)\n    {\n\tKeyStuffed = FALSE;\n\ttypebuf_was_empty = FALSE;\n    }\n\n    init_typebuf();\n    start_stuff();\n    check_end_reg_executing(advance);\n    do\n    {\n/*\n * get a character: 1. from the stuffbuffer\n */\n\tif (typeahead_char != 0)\n\t{\n\t    c = typeahead_char;\n\t    if (advance)\n\t\ttypeahead_char = 0;\n\t}\n\telse\n\t    c = read_readbuffers(advance);\n\tif (c != NUL && !got_int)\n\t{\n\t    if (advance)\n\t    {\n\t\t// KeyTyped = FALSE;  When the command that stuffed something\n\t\t// was typed, behave like the stuffed command was typed.\n\t\t// needed for CTRL-W CTRL-] to open a fold, for example.\n\t\tKeyStuffed = TRUE;\n\t    }\n\t    if (typebuf.tb_no_abbr_cnt == 0)\n\t\ttypebuf.tb_no_abbr_cnt = 1;\t// no abbreviations now\n\t}\n\telse\n\t{\n\t    /*\n\t     * Loop until we either find a matching mapped key, or we\n\t     * are sure that it is not a mapped key.\n\t     * If a mapped key sequence is found we go back to the start to\n\t     * try re-mapping.\n\t     */\n\t    for (;;)\n\t    {\n\t\tlong\twait_time;\n\t\tint\tkeylen = 0;\n\t\tint\tshowcmd_idx;\n\t\tcheck_end_reg_executing(advance);\n\t\t/*\n\t\t * ui_breakcheck() is slow, don't use it too often when\n\t\t * inside a mapping.  But call it each time for typed\n\t\t * characters.\n\t\t */\n\t\tif (typebuf.tb_maplen)\n\t\t    line_breakcheck();\n\t\telse\n\t\t    ui_breakcheck();\t\t// check for CTRL-C\n\t\tif (got_int)\n\t\t{\n\t\t    // flush all input\n\t\t    c = inchar(typebuf.tb_buf, typebuf.tb_buflen - 1, 0L);\n\n\t\t    /*\n\t\t     * If inchar() returns TRUE (script file was active) or we\n\t\t     * are inside a mapping, get out of Insert mode.\n\t\t     * Otherwise we behave like having gotten a CTRL-C.\n\t\t     * As a result typing CTRL-C in insert mode will\n\t\t     * really insert a CTRL-C.\n\t\t     */\n\t\t    if ((c || typebuf.tb_maplen)\n\t\t\t\t     && (State & (MODE_INSERT | MODE_CMDLINE)))\n\t\t\tc = ESC;\n\t\t    else\n\t\t\tc = Ctrl_C;\n\t\t    flush_buffers(FLUSH_INPUT);\t// flush all typeahead\n\n\t\t    if (advance)\n\t\t    {\n\t\t\t// Also record this character, it might be needed to\n\t\t\t// get out of Insert mode.\n\t\t\t*typebuf.tb_buf = c;\n\t\t\tgotchars(typebuf.tb_buf, 1);\n\t\t    }\n\t\t    cmd_silent = FALSE;\n\n\t\t    break;\n\t\t}\n\t\telse if (typebuf.tb_len > 0)\n\t\t{\n\t\t    /*\n\t\t     * Check for a mapping in \"typebuf\".\n\t\t     */\n\t\t    map_result_T result = handle_mapping(\n\t\t\t\t\t\t&keylen, &timedout, &mapdepth);\n\n\t\t    if (result == map_result_retry)\n\t\t\t// try mapping again\n\t\t\tcontinue;\n\t\t    if (result == map_result_fail)\n\t\t    {\n\t\t\t// failed, use the outer loop\n\t\t\tc = -1;\n\t\t\tbreak;\n\t\t    }\n\t\t    if (result == map_result_get)\n\t\t    {\n/*\n * get a character: 2. from the typeahead buffer\n */\n\t\t\tc = typebuf.tb_buf[typebuf.tb_off];\n\t\t\tif (advance)\t// remove chars from tb_buf\n\t\t\t{\n\t\t\t    cmd_silent = (typebuf.tb_silent > 0);\n\t\t\t    if (typebuf.tb_maplen > 0)\n\t\t\t\tKeyTyped = FALSE;\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tKeyTyped = TRUE;\n\t\t\t\t// write char to script file(s)\n\t\t\t\tgotchars(typebuf.tb_buf\n\t\t\t\t\t\t + typebuf.tb_off, 1);\n\t\t\t    }\n\t\t\t    KeyNoremap = typebuf.tb_noremap[\n\t\t\t\t\t\t      typebuf.tb_off];\n\t\t\t    del_typebuf(1, 0);\n\t\t\t}\n\t\t\tbreak;  // got character, break the for loop\n\t\t    }\n\n\t\t    // not enough characters, get more\n\t\t}\n\n/*\n * get a character: 3. from the user - handle <Esc> in Insert mode\n */\n\t\t/*\n\t\t * Special case: if we get an <ESC> in Insert mode and there\n\t\t * are no more characters at once, we pretend to go out of\n\t\t * Insert mode.  This prevents the one second delay after\n\t\t * typing an <ESC>.  If we get something after all, we may\n\t\t * have to redisplay the mode. That the cursor is in the wrong\n\t\t * place does not matter.\n\t\t * Do not do this if the kitty keyboard protocol is used, every\n\t\t * <ESC> is the start of an escape sequence then.\n\t\t */\n\t\tc = 0;\n\t\tnew_wcol = curwin->w_wcol;\n\t\tnew_wrow = curwin->w_wrow;\n\t\tif (\t   advance\n\t\t\t&& typebuf.tb_len == 1\n\t\t\t&& typebuf.tb_buf[typebuf.tb_off] == ESC\n\t\t\t&& !no_mapping\n\t\t\t&& kitty_protocol_state != KKPS_ENABLED\n\t\t\t&& ex_normal_busy == 0\n\t\t\t&& typebuf.tb_maplen == 0\n\t\t\t&& (State & MODE_INSERT)\n\t\t\t&& (p_timeout\n\t\t\t    || (keylen == KEYLEN_PART_KEY && p_ttimeout))\n\t\t\t&& (c = inchar(typebuf.tb_buf + typebuf.tb_off\n\t\t\t\t\t       + typebuf.tb_len, 3, 25L)) == 0)\n\t\t{\n\t\t    colnr_T\tcol = 0;\n\t\t    char_u\t*ptr;\n\n\t\t    if (mode_displayed)\n\t\t    {\n\t\t\tunshowmode(TRUE);\n\t\t\tmode_deleted = TRUE;\n\t\t    }\n#ifdef FEAT_GUI\n\t\t    // may show a different cursor shape\n\t\t    if (gui.in_use && State != MODE_NORMAL && !cmd_silent)\n\t\t    {\n\t\t\tint\t    save_State;\n\n\t\t\tsave_State = State;\n\t\t\tState = MODE_NORMAL;\n\t\t\tgui_update_cursor(TRUE, FALSE);\n\t\t\tState = save_State;\n\t\t\tshape_changed = TRUE;\n\t\t    }\n#endif\n\t\t    validate_cursor();\n\t\t    old_wcol = curwin->w_wcol;\n\t\t    old_wrow = curwin->w_wrow;\n\n\t\t    // move cursor left, if possible\n\t\t    if (curwin->w_cursor.col != 0)\n\t\t    {\n\t\t\tif (curwin->w_wcol > 0)\n\t\t\t{\n\t\t\t    // After auto-indenting and no text is following,\n\t\t\t    // we are expecting to truncate the trailing\n\t\t\t    // white-space, so find the last non-white\n\t\t\t    // character -- webb\n\t\t\t    if (did_ai && *skipwhite(ml_get_curline()\n\t\t\t\t\t\t+ curwin->w_cursor.col) == NUL)\n\t\t\t    {\n\t\t\t\tchartabsize_T cts;\n\n\t\t\t\tcurwin->w_wcol = 0;\n\t\t\t\tptr = ml_get_curline();\n\t\t\t\tinit_chartabsize_arg(&cts, curwin,\n\t\t\t\t\t  curwin->w_cursor.lnum, 0, ptr, ptr);\n\t\t\t\twhile (cts.cts_ptr < ptr + curwin->w_cursor.col)\n\t\t\t\t{\n\t\t\t\t    if (!VIM_ISWHITE(*cts.cts_ptr))\n\t\t\t\t\tcurwin->w_wcol = cts.cts_vcol;\n\t\t\t\t    cts.cts_vcol += lbr_chartabsize(&cts);\n\t\t\t\t    if (has_mbyte)\n\t\t\t\t\tcts.cts_ptr +=\n\t\t\t\t\t\t   (*mb_ptr2len)(cts.cts_ptr);\n\t\t\t\t    else\n\t\t\t\t\t++cts.cts_ptr;\n\t\t\t\t}\n\t\t\t\tclear_chartabsize_arg(&cts);\n\n\t\t\t\tcurwin->w_wrow = curwin->w_cline_row\n\t\t\t\t\t   + curwin->w_wcol / curwin->w_width;\n\t\t\t\tcurwin->w_wcol %= curwin->w_width;\n\t\t\t\tcurwin->w_wcol += curwin_col_off();\n\t\t\t\tcol = 0;\t// no correction needed\n\t\t\t    }\n\t\t\t    else\n\t\t\t    {\n\t\t\t\t--curwin->w_wcol;\n\t\t\t\tcol = curwin->w_cursor.col - 1;\n\t\t\t    }\n\t\t\t}\n\t\t\telse if (curwin->w_p_wrap && curwin->w_wrow)\n\t\t\t{\n\t\t\t    --curwin->w_wrow;\n\t\t\t    curwin->w_wcol = curwin->w_width - 1;\n\t\t\t    col = curwin->w_cursor.col - 1;\n\t\t\t}\n\t\t\tif (has_mbyte && col > 0 && curwin->w_wcol > 0)\n\t\t\t{\n\t\t\t    // Correct when the cursor is on the right halve\n\t\t\t    // of a double-wide character.\n\t\t\t    ptr = ml_get_curline();\n\t\t\t    col -= (*mb_head_off)(ptr, ptr + col);\n\t\t\t    if ((*mb_ptr2cells)(ptr + col) > 1)\n\t\t\t\t--curwin->w_wcol;\n\t\t\t}\n\t\t    }\n\t\t    setcursor();\n\t\t    out_flush();\n\t\t    new_wcol = curwin->w_wcol;\n\t\t    new_wrow = curwin->w_wrow;\n\t\t    curwin->w_wcol = old_wcol;\n\t\t    curwin->w_wrow = old_wrow;\n\t\t}\n\t\tif (c < 0)\n\t\t    continue;\t// end of input script reached\n\n\t\t// Allow mapping for just typed characters. When we get here c\n\t\t// is the number of extra bytes and typebuf.tb_len is 1.\n\t\tfor (n = 1; n <= c; ++n)\n\t\t    typebuf.tb_noremap[typebuf.tb_off + n] = RM_YES;\n\t\ttypebuf.tb_len += c;\n\n\t\t// buffer full, don't map\n\t\tif (typebuf.tb_len >= typebuf.tb_maplen + MAXMAPLEN)\n\t\t{\n\t\t    timedout = TRUE;\n\t\t    continue;\n\t\t}\n\n\t\tif (ex_normal_busy > 0)\n\t\t{\n\t\t    static int tc = 0;\n\n\t\t    // No typeahead left and inside \":normal\".  Must return\n\t\t    // something to avoid getting stuck.  When an incomplete\n\t\t    // mapping is present, behave like it timed out.\n\t\t    if (typebuf.tb_len > 0)\n\t\t    {\n\t\t\ttimedout = TRUE;\n\t\t\tcontinue;\n\t\t    }\n\n\t\t    // When 'insertmode' is set, ESC just beeps in Insert\n\t\t    // mode.  Use CTRL-L to make edit() return.\n\t\t    // For the command line only CTRL-C always breaks it.\n\t\t    // For the cmdline window: Alternate between ESC and\n\t\t    // CTRL-C: ESC for most situations and CTRL-C to close the\n\t\t    // cmdline window.\n\t\t    if (p_im && (State & MODE_INSERT))\n\t\t\tc = Ctrl_L;\n#ifdef FEAT_TERMINAL\n\t\t    else if (terminal_is_active())\n\t\t\tc = K_CANCEL;\n#endif\n\t\t    else if ((State & MODE_CMDLINE)\n\t\t\t\t\t     || (cmdwin_type > 0 && tc == ESC))\n\t\t\tc = Ctrl_C;\n\t\t    else\n\t\t\tc = ESC;\n\t\t    tc = c;\n\t\t    // set a flag to indicate this wasn't a normal char\n\t\t    if (advance)\n\t\t\ttypebuf_was_empty = TRUE;\n\n\t\t    // return from main_loop()\n\t\t    if (pending_exmode_active)\n\t\t\texmode_active = EXMODE_NORMAL;\n\n\t\t    // no chars to block abbreviation for\n\t\t    typebuf.tb_no_abbr_cnt = 0;\n\n\t\t    break;\n\t\t}\n\n/*\n * get a character: 3. from the user - update display\n */\n\t\t// In insert mode a screen update is skipped when characters\n\t\t// are still available.  But when those available characters\n\t\t// are part of a mapping, and we are going to do a blocking\n\t\t// wait here.  Need to update the screen to display the\n\t\t// changed text so far. Also for when 'lazyredraw' is set and\n\t\t// redrawing was postponed because there was something in the\n\t\t// input buffer (e.g., termresponse).\n\t\tif (((State & MODE_INSERT) != 0 || p_lz)\n\t\t\t&& (State & MODE_CMDLINE) == 0\n\t\t\t&& advance && must_redraw != 0 && !need_wait_return)\n\t\t{\n\t\t    update_screen(0);\n\t\t    setcursor(); // put cursor back where it belongs\n\t\t}\n\n\t\t/*\n\t\t * If we have a partial match (and are going to wait for more\n\t\t * input from the user), show the partially matched characters\n\t\t * to the user with showcmd.\n\t\t */\n\t\tshowcmd_idx = 0;\n\t\tint showing_partial = FALSE;\n\t\tif (typebuf.tb_len > 0 && advance && !exmode_active)\n\t\t{\n\t\t    if (((State & (MODE_NORMAL | MODE_INSERT))\n\t\t\t\t\t\t      || State == MODE_LANGMAP)\n\t\t\t    && State != MODE_HITRETURN)\n\t\t    {\n\t\t\t// this looks nice when typing a dead character map\n\t\t\tif (State & MODE_INSERT\n\t\t\t    && ptr2cells(typebuf.tb_buf + typebuf.tb_off\n\t\t\t\t\t\t   + typebuf.tb_len - 1) == 1)\n\t\t\t{\n\t\t\t    edit_putchar(typebuf.tb_buf[typebuf.tb_off\n\t\t\t\t\t\t+ typebuf.tb_len - 1], FALSE);\n\t\t\t    setcursor(); // put cursor back where it belongs\n\t\t\t    showing_partial = TRUE;\n\t\t\t}\n\t\t\t// need to use the col and row from above here\n\t\t\told_wcol = curwin->w_wcol;\n\t\t\told_wrow = curwin->w_wrow;\n\t\t\tcurwin->w_wcol = new_wcol;\n\t\t\tcurwin->w_wrow = new_wrow;\n\t\t\tpush_showcmd();\n\t\t\tif (typebuf.tb_len > SHOWCMD_COLS)\n\t\t\t    showcmd_idx = typebuf.tb_len - SHOWCMD_COLS;\n\t\t\twhile (showcmd_idx < typebuf.tb_len)\n\t\t\t    (void)add_to_showcmd(\n\t\t\t       typebuf.tb_buf[typebuf.tb_off + showcmd_idx++]);\n\t\t\tcurwin->w_wcol = old_wcol;\n\t\t\tcurwin->w_wrow = old_wrow;\n\t\t    }\n\n\t\t    // This looks nice when typing a dead character map.\n\t\t    // There is no actual command line for get_number().\n\t\t    if ((State & MODE_CMDLINE)\n\t\t\t    && get_cmdline_info()->cmdbuff != NULL\n#if defined(FEAT_CRYPT) || defined(FEAT_EVAL)\n\t\t\t    && cmdline_star == 0\n#endif\n\t\t\t    && ptr2cells(typebuf.tb_buf + typebuf.tb_off\n\t\t\t\t\t\t   + typebuf.tb_len - 1) == 1)\n\t\t    {\n\t\t\tputcmdline(typebuf.tb_buf[typebuf.tb_off\n\t\t\t\t\t\t+ typebuf.tb_len - 1], FALSE);\n\t\t\tshowing_partial = TRUE;\n\t\t    }\n\t\t}\n\n/*\n * get a character: 3. from the user - get it\n */\n\t\tif (typebuf.tb_len == 0)\n\t\t    // timedout may have been set if a mapping with empty RHS\n\t\t    // fully matched while longer mappings timed out.\n\t\t    timedout = FALSE;\n\n\t\tif (advance)\n\t\t{\n\t\t    if (typebuf.tb_len == 0\n\t\t\t    || !(p_timeout\n\t\t\t\t || (p_ttimeout && keylen == KEYLEN_PART_KEY)))\n\t\t\t// blocking wait\n\t\t\twait_time = -1L;\n\t\t    else if (keylen == KEYLEN_PART_KEY && p_ttm >= 0)\n\t\t\twait_time = p_ttm;\n\t\t    else\n\t\t\twait_time = p_tm;\n\t\t}\n\t\telse\n\t\t    wait_time = 0;\n\n\t\twait_tb_len = typebuf.tb_len;\n\t\tc = inchar(typebuf.tb_buf + typebuf.tb_off + typebuf.tb_len,\n\t\t\ttypebuf.tb_buflen - typebuf.tb_off - typebuf.tb_len - 1,\n\t\t\twait_time);\n\n\t\tif (showcmd_idx != 0)\n\t\t    pop_showcmd();\n\t\tif (showing_partial)\n\t\t{\n\t\t    if (State & MODE_INSERT)\n\t\t\tedit_unputchar();\n\t\t    if ((State & MODE_CMDLINE)\n\t\t\t\t\t&& get_cmdline_info()->cmdbuff != NULL)\n\t\t\tunputcmdline();\n\t\t    else\n\t\t\tsetcursor();\t// put cursor back where it belongs\n\t\t}\n\n\t\tif (c < 0)\n\t\t    continue;\t\t// end of input script reached\n\t\tif (c == NUL)\t\t// no character available\n\t\t{\n\t\t    if (!advance)\n\t\t\tbreak;\n\t\t    if (wait_tb_len > 0)\t// timed out\n\t\t    {\n\t\t\ttimedout = TRUE;\n\t\t\tcontinue;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\t    // allow mapping for just typed characters\n\t\t    while (typebuf.tb_buf[typebuf.tb_off\n\t\t\t\t\t\t     + typebuf.tb_len] != NUL)\n\t\t\ttypebuf.tb_noremap[typebuf.tb_off\n\t\t\t\t\t\t + typebuf.tb_len++] = RM_YES;\n#ifdef HAVE_INPUT_METHOD\n\t\t    // Get IM status right after getting keys, not after the\n\t\t    // timeout for a mapping (focus may be lost by then).\n\t\t    vgetc_im_active = im_get_status();\n#endif\n\t\t}\n\t    }\t    // for (;;)\n\t}\t// if (!character from stuffbuf)\n\n\t// if advance is FALSE don't loop on NULs\n    } while ((c < 0 && c != K_CANCEL) || (advance && c == NUL));\n\n    /*\n     * The \"INSERT\" message is taken care of here:\n     *\t if we return an ESC to exit insert mode, the message is deleted\n     *\t if we don't return an ESC but deleted the message before, redisplay it\n     */\n    if (advance && p_smd && msg_silent == 0 && (State & MODE_INSERT))\n    {\n\tif (c == ESC && !mode_deleted && !no_mapping && mode_displayed)\n\t{\n\t    if (typebuf.tb_len && !KeyTyped)\n\t\tredraw_cmdline = TRUE;\t    // delete mode later\n\t    else\n\t\tunshowmode(FALSE);\n\t}\n\telse if (c != ESC && mode_deleted)\n\t{\n\t    if (typebuf.tb_len && !KeyTyped)\n\t\tredraw_cmdline = TRUE;\t    // show mode later\n\t    else\n\t\tshowmode();\n\t}\n    }\n#ifdef FEAT_GUI\n    // may unshow different cursor shape\n    if (gui.in_use && shape_changed)\n\tgui_update_cursor(TRUE, FALSE);\n#endif\n    if (timedout && c == ESC)\n    {\n\tchar_u nop_buf[3];\n\n\t// When recording there will be no timeout.  Add a <Nop> after the ESC\n\t// to avoid that it forms a key code with following characters.\n\tnop_buf[0] = K_SPECIAL;\n\tnop_buf[1] = KS_EXTRA;\n\tnop_buf[2] = KE_NOP;\n\tgotchars(nop_buf, 3);\n    }\n\n    --vgetc_busy;\n\n    return c;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 2935,
    "critical_vars": [
      "rmp->regprog"
    ],
    "function": "buflist_match",
    "filename": "vim/CVE-2022-1674/CVE-2022-1674_CWE-476_a59f2dfd0cf9ee1a584d3de5b7c2d47648e79060_buffer.c.diff",
    "function_code": "buflist_match(\n    regmatch_T\t*rmp,\n    buf_T\t*buf,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match;\n\n    // First try the short file name, then the long file name.\n    match = fname_match(rmp, buf->b_sfname, ignore_case);\n    if (match == NULL && rmp->regprog != NULL)\n\tmatch = fname_match(rmp, buf->b_ffname, ignore_case);\n\n    return match;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 621,
    "critical_vars": [
      "trylevel"
    ],
    "function": "f_assert_fails",
    "filename": "vim/CVE-2022-3153/CVE-2022-3153_CWE-476_1540d334a04d874c2aa9d26b82dbbcd4bc5a78de_testing.c.diff",
    "function_code": "f_assert_fails(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*cmd;\n    garray_T\tga;\n    int\t\tsave_trylevel = trylevel;\n    int\t\tcalled_emsg_before = called_emsg;\n    char\t*wrong_arg_msg = NULL;\n    char_u\t*tofree = NULL;\n\n    if (check_for_string_or_number_arg(argvars, 0) == FAIL\n\t    || check_for_opt_string_or_list_arg(argvars, 1) == FAIL\n\t    || (argvars[1].v_type != VAR_UNKNOWN\n\t\t&& (argvars[2].v_type != VAR_UNKNOWN\n\t\t    && (check_for_opt_number_arg(argvars, 3) == FAIL\n\t\t\t|| (argvars[3].v_type != VAR_UNKNOWN\n\t\t\t    && check_for_opt_string_arg(argvars, 4) == FAIL)))))\n\treturn;\n\n    cmd = tv_get_string_chk(&argvars[0]);\n\n    // trylevel must be zero for a \":throw\" command to be considered failed\n    trylevel = 0;\n    suppress_errthrow = TRUE;\n    in_assert_fails = TRUE;\n\n    do_cmdline_cmd(cmd);\n\n    // reset here for any errors reported below\n    trylevel = save_trylevel;\n    suppress_errthrow = FALSE;\n\n    if (called_emsg == called_emsg_before)\n    {\n\tprepare_assert_error(&ga);\n\tga_concat(&ga, (char_u *)\"command did not fail: \");\n\tassert_append_cmd_or_arg(&ga, argvars, cmd);\n\tassert_error(&ga);\n\tga_clear(&ga);\n\trettv->vval.v_number = 1;\n    }\n    else if (argvars[1].v_type != VAR_UNKNOWN)\n    {\n\tchar_u\tbuf[NUMBUFLEN];\n\tchar_u\t*expected;\n\tchar_u\t*expected_str = NULL;\n\tint\terror_found = FALSE;\n\tint\terror_found_index = 1;\n\tchar_u\t*actual = emsg_assert_fails_msg == NULL ? (char_u *)\"[unknown]\"\n\t\t\t\t\t\t       : emsg_assert_fails_msg;\n\n\tif (argvars[1].v_type == VAR_STRING)\n\t{\n\t    expected = tv_get_string_buf_chk(&argvars[1], buf);\n\t    error_found = expected == NULL\n\t\t\t   || strstr((char *)actual, (char *)expected) == NULL;\n\t}\n\telse if (argvars[1].v_type == VAR_LIST)\n\t{\n\t    list_T\t*list = argvars[1].vval.v_list;\n\t    typval_T\t*tv;\n\n\t    if (list == NULL || list->lv_len < 1 || list->lv_len > 2)\n\t    {\n\t\twrong_arg_msg = e_assert_fails_second_arg;\n\t\tgoto theend;\n\t    }\n\t    CHECK_LIST_MATERIALIZE(list);\n\t    tv = &list->lv_first->li_tv;\n\t    expected = tv_get_string_buf_chk(tv, buf);\n\t    if (expected == NULL)\n\t\tgoto theend;\n\t    if (!pattern_match(expected, actual, FALSE))\n\t    {\n\t\terror_found = TRUE;\n\t\texpected_str = expected;\n\t    }\n\t    else if (list->lv_len == 2)\n\t    {\n\t\t// make a copy, an error in pattern_match() may free it\n\t\ttofree = actual = vim_strsave(get_vim_var_str(VV_ERRMSG));\n\t\tif (actual != NULL)\n\t\t{\n\t\t    tv = &list->lv_u.mat.lv_last->li_tv;\n\t\t    expected = tv_get_string_buf_chk(tv, buf);\n\t\t    if (expected == NULL)\n\t\t\tgoto theend;\n\t\t    if (!pattern_match(expected, actual, FALSE))\n\t\t    {\n\t\t\terror_found = TRUE;\n\t\t\texpected_str = expected;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    wrong_arg_msg = e_assert_fails_second_arg;\n\t    goto theend;\n\t}\n\n\tif (!error_found && argvars[2].v_type != VAR_UNKNOWN\n\t\t&& argvars[3].v_type != VAR_UNKNOWN)\n\t{\n\t    if (argvars[3].v_type != VAR_NUMBER)\n\t    {\n\t\twrong_arg_msg = e_assert_fails_fourth_argument;\n\t\tgoto theend;\n\t    }\n\t    else if (argvars[3].vval.v_number >= 0\n\t\t\t && argvars[3].vval.v_number != emsg_assert_fails_lnum)\n\t    {\n\t\terror_found = TRUE;\n\t\terror_found_index = 3;\n\t    }\n\t    if (!error_found && argvars[4].v_type != VAR_UNKNOWN)\n\t    {\n\t\tif (argvars[4].v_type != VAR_STRING)\n\t\t{\n\t\t    wrong_arg_msg = e_assert_fails_fifth_argument;\n\t\t    goto theend;\n\t\t}\n\t\telse if (argvars[4].vval.v_string != NULL\n\t\t    && !pattern_match(argvars[4].vval.v_string,\n\t\t\t\t\t     emsg_assert_fails_context, FALSE))\n\t\t{\n\t\t    error_found = TRUE;\n\t\t    error_found_index = 4;\n\t\t}\n\t    }\n\t}\n\n\tif (error_found)\n\t{\n\t    typval_T actual_tv;\n\n\t    prepare_assert_error(&ga);\n\t    if (error_found_index == 3)\n\t    {\n\t\tactual_tv.v_type = VAR_NUMBER;\n\t\tactual_tv.vval.v_number = emsg_assert_fails_lnum;\n\t    }\n\t    else if (error_found_index == 4)\n\t    {\n\t\tactual_tv.v_type = VAR_STRING;\n\t\tactual_tv.vval.v_string = emsg_assert_fails_context;\n\t    }\n\t    else\n\t    {\n\t\tactual_tv.v_type = VAR_STRING;\n\t\tactual_tv.vval.v_string = actual;\n\t    }\n\t    fill_assert_error(&ga, &argvars[2], expected_str,\n\t\t\t&argvars[error_found_index], &actual_tv, ASSERT_OTHER);\n\t    ga_concat(&ga, (char_u *)\": \");\n\t    assert_append_cmd_or_arg(&ga, argvars, cmd);\n\t    assert_error(&ga);\n\t    ga_clear(&ga);\n\t    rettv->vval.v_number = 1;\n\t}\n    }\n\ntheend:\n    trylevel = save_trylevel;\n    suppress_errthrow = FALSE;\n    in_assert_fails = FALSE;\n    did_emsg = FALSE;\n    got_int = FALSE;\n    msg_col = 0;\n    need_wait_return = FALSE;\n    emsg_on_display = FALSE;\n    msg_scrolled = 0;\n    lines_left = Rows;\n    VIM_CLEAR(emsg_assert_fails_msg);\n    vim_free(tofree);\n    set_vim_var_string(VV_ERRMSG, NULL, 0);\n    if (wrong_arg_msg != NULL)\n\temsg(_(wrong_arg_msg));\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 2645,
    "critical_vars": [
      "regmatch.regprog"
    ],
    "function": "buflist_findpat",
    "filename": "vim/CVE-2022-1725/CVE-2022-1725_CWE-476_b62dc5e7825bc195efe3041d5b3a9f1528359e1c_buffer.c.diff",
    "function_code": "buflist_findpat(\n    char_u\t*pattern,\n    char_u\t*pattern_end,\t// pointer to first char after pattern\n    int\t\tunlisted,\t// find unlisted buffers\n    int\t\tdiffmode UNUSED, // find diff-mode buffers only\n    int\t\tcurtab_only)\t// find buffers in current tab only\n{\n    buf_T\t*buf;\n    int\t\tmatch = -1;\n    int\t\tfind_listed;\n    char_u\t*pat;\n    char_u\t*patend;\n    int\t\tattempt;\n    char_u\t*p;\n    int\t\ttoggledollar;\n\n    // \"%\" is current file, \"%%\" or \"#\" is alternate file\n    if ((pattern_end == pattern + 1 && (*pattern == '%' || *pattern == '#'))\n\t    || (in_vim9script() && pattern_end == pattern + 2\n\t\t\t\t    && pattern[0] == '%' && pattern[1] == '%'))\n    {\n\tif (*pattern == '#' || pattern_end == pattern + 2)\n\t    match = curwin->w_alt_fnum;\n\telse\n\t    match = curbuf->b_fnum;\n#ifdef FEAT_DIFF\n\tif (diffmode && !diff_mode_buf(buflist_findnr(match)))\n\t    match = -1;\n#endif\n    }\n\n    /*\n     * Try four ways of matching a listed buffer:\n     * attempt == 0: without '^' or '$' (at any position)\n     * attempt == 1: with '^' at start (only at position 0)\n     * attempt == 2: with '$' at end (only match at end)\n     * attempt == 3: with '^' at start and '$' at end (only full match)\n     * Repeat this for finding an unlisted buffer if there was no matching\n     * listed buffer.\n     */\n    else\n    {\n\tpat = file_pat_to_reg_pat(pattern, pattern_end, NULL, FALSE);\n\tif (pat == NULL)\n\t    return -1;\n\tpatend = pat + STRLEN(pat) - 1;\n\ttoggledollar = (patend > pat && *patend == '$');\n\n\t// First try finding a listed buffer.  If not found and \"unlisted\"\n\t// is TRUE, try finding an unlisted buffer.\n\tfind_listed = TRUE;\n\tfor (;;)\n\t{\n\t    for (attempt = 0; attempt <= 3; ++attempt)\n\t    {\n\t\tregmatch_T\tregmatch;\n\n\t\t// may add '^' and '$'\n\t\tif (toggledollar)\n\t\t    *patend = (attempt < 2) ? NUL : '$'; // add/remove '$'\n\t\tp = pat;\n\t\tif (*p == '^' && !(attempt & 1))\t // add/remove '^'\n\t\t    ++p;\n\t\tregmatch.regprog = vim_regcomp(p, magic_isset() ? RE_MAGIC : 0);\n\t\tif (regmatch.regprog == NULL)\n\t\t{\n\t\t    vim_free(pat);\n\t\t    return -1;\n\t\t}\n\n\t\tFOR_ALL_BUFS_FROM_LAST(buf)\n\t\t    if (buf->b_p_bl == find_listed\n#ifdef FEAT_DIFF\n\t\t\t    && (!diffmode || diff_mode_buf(buf))\n#endif\n\t\t\t    && buflist_match(&regmatch, buf, FALSE) != NULL)\n\t\t    {\n\t\t\tif (curtab_only)\n\t\t\t{\n\t\t\t    // Ignore the match if the buffer is not open in\n\t\t\t    // the current tab.\n\t\t\t    win_T\t*wp;\n\n\t\t\t    FOR_ALL_WINDOWS(wp)\n\t\t\t\tif (wp->w_buffer == buf)\n\t\t\t\t    break;\n\t\t\t    if (wp == NULL)\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (match >= 0)\t\t// already found a match\n\t\t\t{\n\t\t\t    match = -2;\n\t\t\t    break;\n\t\t\t}\n\t\t\tmatch = buf->b_fnum;\t// remember first match\n\t\t    }\n\n\t\tvim_regfree(regmatch.regprog);\n\t\tif (match >= 0)\t\t\t// found one match\n\t\t    break;\n\t    }\n\n\t    // Only search for unlisted buffers if there was no match with\n\t    // a listed buffer.\n\t    if (!unlisted || !find_listed || match != -1)\n\t\tbreak;\n\t    find_listed = FALSE;\n\t}\n\n\tvim_free(pat);\n    }\n\n    if (match == -2)\n\tsemsg(_(e_more_than_one_match_for_str), pattern);\n    else if (match < 0)\n\tsemsg(_(e_no_matching_buffer_for_str), pattern);\n    return match;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 2648,
    "critical_vars": [
      "regmatch.regprog"
    ],
    "function": "buflist_findpat",
    "filename": "vim/CVE-2022-1725/CVE-2022-1725_CWE-476_b62dc5e7825bc195efe3041d5b3a9f1528359e1c_buffer.c.diff",
    "function_code": "buflist_findpat(\n    char_u\t*pattern,\n    char_u\t*pattern_end,\t// pointer to first char after pattern\n    int\t\tunlisted,\t// find unlisted buffers\n    int\t\tdiffmode UNUSED, // find diff-mode buffers only\n    int\t\tcurtab_only)\t// find buffers in current tab only\n{\n    buf_T\t*buf;\n    int\t\tmatch = -1;\n    int\t\tfind_listed;\n    char_u\t*pat;\n    char_u\t*patend;\n    int\t\tattempt;\n    char_u\t*p;\n    int\t\ttoggledollar;\n\n    // \"%\" is current file, \"%%\" or \"#\" is alternate file\n    if ((pattern_end == pattern + 1 && (*pattern == '%' || *pattern == '#'))\n\t    || (in_vim9script() && pattern_end == pattern + 2\n\t\t\t\t    && pattern[0] == '%' && pattern[1] == '%'))\n    {\n\tif (*pattern == '#' || pattern_end == pattern + 2)\n\t    match = curwin->w_alt_fnum;\n\telse\n\t    match = curbuf->b_fnum;\n#ifdef FEAT_DIFF\n\tif (diffmode && !diff_mode_buf(buflist_findnr(match)))\n\t    match = -1;\n#endif\n    }\n\n    /*\n     * Try four ways of matching a listed buffer:\n     * attempt == 0: without '^' or '$' (at any position)\n     * attempt == 1: with '^' at start (only at position 0)\n     * attempt == 2: with '$' at end (only match at end)\n     * attempt == 3: with '^' at start and '$' at end (only full match)\n     * Repeat this for finding an unlisted buffer if there was no matching\n     * listed buffer.\n     */\n    else\n    {\n\tpat = file_pat_to_reg_pat(pattern, pattern_end, NULL, FALSE);\n\tif (pat == NULL)\n\t    return -1;\n\tpatend = pat + STRLEN(pat) - 1;\n\ttoggledollar = (patend > pat && *patend == '$');\n\n\t// First try finding a listed buffer.  If not found and \"unlisted\"\n\t// is TRUE, try finding an unlisted buffer.\n\tfind_listed = TRUE;\n\tfor (;;)\n\t{\n\t    for (attempt = 0; attempt <= 3; ++attempt)\n\t    {\n\t\tregmatch_T\tregmatch;\n\n\t\t// may add '^' and '$'\n\t\tif (toggledollar)\n\t\t    *patend = (attempt < 2) ? NUL : '$'; // add/remove '$'\n\t\tp = pat;\n\t\tif (*p == '^' && !(attempt & 1))\t // add/remove '^'\n\t\t    ++p;\n\t\tregmatch.regprog = vim_regcomp(p, magic_isset() ? RE_MAGIC : 0);\n\n\t\tFOR_ALL_BUFS_FROM_LAST(buf)\n\t\t{\n\t\t    if (regmatch.regprog == NULL)\n\t\t    {\n\t\t\t// invalid pattern, possibly after switching engine\n\t\t\tvim_free(pat);\n\t\t\treturn -1;\n\t\t    }\n\t\t    if (buf->b_p_bl == find_listed\n#ifdef FEAT_DIFF\n\t\t\t    && (!diffmode || diff_mode_buf(buf))\n#endif\n\t\t\t    && buflist_match(&regmatch, buf, FALSE) != NULL)\n\t\t    {\n\t\t\tif (curtab_only)\n\t\t\t{\n\t\t\t    // Ignore the match if the buffer is not open in\n\t\t\t    // the current tab.\n\t\t\t    win_T\t*wp;\n\n\t\t\t    FOR_ALL_WINDOWS(wp)\n\t\t\t\tif (wp->w_buffer == buf)\n\t\t\t\t    break;\n\t\t\t    if (wp == NULL)\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (match >= 0)\t\t// already found a match\n\t\t\t{\n\t\t\t    match = -2;\n\t\t\t    break;\n\t\t\t}\n\t\t\tmatch = buf->b_fnum;\t// remember first match\n\t\t    }\n\t\t}\n\n\t\tvim_regfree(regmatch.regprog);\n\t\tif (match >= 0)\t\t\t// found one match\n\t\t    break;\n\t    }\n\n\t    // Only search for unlisted buffers if there was no match with\n\t    // a listed buffer.\n\t    if (!unlisted || !find_listed || match != -1)\n\t\tbreak;\n\t    find_listed = FALSE;\n\t}\n\n\tvim_free(pat);\n    }\n\n    if (match == -2)\n\tsemsg(_(e_more_than_one_match_for_str), pattern);\n    else if (match < 0)\n\tsemsg(_(e_no_matching_buffer_for_str), pattern);\n    return match;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 2769,
    "critical_vars": [
      "regmatch.regprog"
    ],
    "function": "ExpandBufnames",
    "filename": "vim/CVE-2022-1725/CVE-2022-1725_CWE-476_b62dc5e7825bc195efe3041d5b3a9f1528359e1c_buffer.c.diff",
    "function_code": "ExpandBufnames(\n    char_u\t*pat,\n    int\t\t*num_file,\n    char_u\t***file,\n    int\t\toptions)\n{\n    int\t\tcount = 0;\n    buf_T\t*buf;\n    int\t\tround;\n    char_u\t*p;\n    int\t\tattempt;\n    char_u\t*patc = NULL;\n#ifdef FEAT_VIMINFO\n    bufmatch_T\t*matches = NULL;\n#endif\n    int\t\tfuzzy;\n    fuzmatch_str_T  *fuzmatch = NULL;\n\n    *num_file = 0;\t\t    // return values in case of FAIL\n    *file = NULL;\n\n#ifdef FEAT_DIFF\n    if ((options & BUF_DIFF_FILTER) && !curwin->w_p_diff)\n\treturn FAIL;\n#endif\n\n    fuzzy = cmdline_fuzzy_complete(pat);\n\n    // Make a copy of \"pat\" and change \"^\" to \"\\(^\\|[\\/]\\)\" (if doing regular\n    // expression matching)\n    if (!fuzzy)\n    {\n\tif (*pat == '^')\n\t{\n\t    patc = alloc(STRLEN(pat) + 11);\n\t    if (patc == NULL)\n\t\treturn FAIL;\n\t    STRCPY(patc, \"\\\\(^\\\\|[\\\\/]\\\\)\");\n\t    STRCPY(patc + 11, pat + 1);\n\t}\n\telse\n\t    patc = pat;\n    }\n\n    // attempt == 0: try match with    '\\<', match at start of word\n    // attempt == 1: try match without '\\<', match anywhere\n    for (attempt = 0; attempt <= (fuzzy ? 0 : 1); ++attempt)\n    {\n\tregmatch_T\tregmatch;\n\tint\t\tscore = 0;\n\n\tif (!fuzzy)\n\t{\n\t    if (attempt > 0 && patc == pat)\n\t\tbreak;\t// there was no anchor, no need to try again\n\t    regmatch.regprog = vim_regcomp(patc + attempt * 11, RE_MAGIC);\n\t    if (regmatch.regprog == NULL)\n\t    {\n\t\tif (patc != pat)\n\t\t    vim_free(patc);\n\t\treturn FAIL;\n\t    }\n\t}\n\n\t// round == 1: Count the matches.\n\t// round == 2: Build the array to keep the matches.\n\tfor (round = 1; round <= 2; ++round)\n\t{\n\t    count = 0;\n\t    FOR_ALL_BUFFERS(buf)\n\t    {\n\t\tif (!buf->b_p_bl)\t// skip unlisted buffers\n\t\t    continue;\n#ifdef FEAT_DIFF\n\t\tif (options & BUF_DIFF_FILTER)\n\t\t    // Skip buffers not suitable for\n\t\t    // :diffget or :diffput completion.\n\t\t    if (buf == curbuf || !diff_mode_buf(buf))\n\t\t\tcontinue;\n#endif\n\n\t\tif (!fuzzy)\n\t\t    p = buflist_match(&regmatch, buf, p_wic);\n\t\telse\n\t\t{\n\t\t    p = NULL;\n\t\t    // first try matching with the short file name\n\t\t    if ((score = fuzzy_match_str(buf->b_sfname, pat)) != 0)\n\t\t\tp = buf->b_sfname;\n\t\t    if (p == NULL)\n\t\t    {\n\t\t\t// next try matching with the full path file name\n\t\t\tif ((score = fuzzy_match_str(buf->b_ffname, pat)) != 0)\n\t\t\t    p = buf->b_ffname;\n\t\t    }\n\t\t}\n\n\t\tif (p == NULL)\n\t\t    continue;\n\n\t\tif (round == 1)\n\t\t{\n\t\t    ++count;\n\t\t    continue;\n\t\t}\n\n\t\tif (options & WILD_HOME_REPLACE)\n\t\t    p = home_replace_save(buf, p);\n\t\telse\n\t\t    p = vim_strsave(p);\n\n\t\tif (!fuzzy)\n\t\t{\n#ifdef FEAT_VIMINFO\n\t\t    if (matches != NULL)\n\t\t    {\n\t\t\tmatches[count].buf = buf;\n\t\t\tmatches[count].match = p;\n\t\t\tcount++;\n\t\t    }\n\t\t    else\n#endif\n\t\t\t(*file)[count++] = p;\n\t\t}\n\t\telse\n\t\t{\n\t\t    fuzmatch[count].idx = count;\n\t\t    fuzmatch[count].str = p;\n\t\t    fuzmatch[count].score = score;\n\t\t    count++;\n\t\t}\n\t    }\n\t    if (count == 0)\t// no match found, break here\n\t\tbreak;\n\t    if (round == 1)\n\t    {\n\t\tif (!fuzzy)\n\t\t{\n\t\t    *file = ALLOC_MULT(char_u *, count);\n\t\t    if (*file == NULL)\n\t\t    {\n\t\t\tvim_regfree(regmatch.regprog);\n\t\t\tif (patc != pat)\n\t\t\t    vim_free(patc);\n\t\t\treturn FAIL;\n\t\t    }\n#ifdef FEAT_VIMINFO\n\t\t    if (options & WILD_BUFLASTUSED)\n\t\t\tmatches = ALLOC_MULT(bufmatch_T, count);\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t    fuzmatch = ALLOC_MULT(fuzmatch_str_T, count);\n\t\t    if (fuzmatch == NULL)\n\t\t    {\n\t\t\t*num_file = 0;\n\t\t\t*file = NULL;\n\t\t\treturn FAIL;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\tif (!fuzzy)\n\t{\n\t    vim_regfree(regmatch.regprog);\n\t    if (count)\t\t// match(es) found, break here\n\t\tbreak;\n\t}\n    }\n\n    if (!fuzzy && patc != pat)\n\tvim_free(patc);\n\n#ifdef FEAT_VIMINFO\n    if (!fuzzy)\n    {\n\tif (matches != NULL)\n\t{\n\t    int i;\n\t    if (count > 1)\n\t\tqsort(matches, count, sizeof(bufmatch_T), buf_compare);\n\t    // if the current buffer is first in the list, place it at the end\n\t    if (matches[0].buf == curbuf)\n\t    {\n\t\tfor (i = 1; i < count; i++)\n\t\t    (*file)[i-1] = matches[i].match;\n\t\t(*file)[count-1] = matches[0].match;\n\t    }\n\t    else\n\t    {\n\t\tfor (i = 0; i < count; i++)\n\t\t    (*file)[i] = matches[i].match;\n\t    }\n\t    vim_free(matches);\n\t}\n    }\n    else\n    {\n\tif (fuzzymatches_to_strmatches(fuzmatch, file, count, FALSE) == FAIL)\n\t    return FAIL;\n    }\n#endif\n\n    *num_file = count;\n    return (count == 0 ? FAIL : OK);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 2793,
    "critical_vars": [
      "regmatch.regprog"
    ],
    "function": "ExpandBufnames",
    "filename": "vim/CVE-2022-1725/CVE-2022-1725_CWE-476_b62dc5e7825bc195efe3041d5b3a9f1528359e1c_buffer.c.diff",
    "function_code": "ExpandBufnames(\n    char_u\t*pat,\n    int\t\t*num_file,\n    char_u\t***file,\n    int\t\toptions)\n{\n    int\t\tcount = 0;\n    buf_T\t*buf;\n    int\t\tround;\n    char_u\t*p;\n    int\t\tattempt;\n    char_u\t*patc = NULL;\n#ifdef FEAT_VIMINFO\n    bufmatch_T\t*matches = NULL;\n#endif\n    int\t\tfuzzy;\n    fuzmatch_str_T  *fuzmatch = NULL;\n\n    *num_file = 0;\t\t    // return values in case of FAIL\n    *file = NULL;\n\n#ifdef FEAT_DIFF\n    if ((options & BUF_DIFF_FILTER) && !curwin->w_p_diff)\n\treturn FAIL;\n#endif\n\n    fuzzy = cmdline_fuzzy_complete(pat);\n\n    // Make a copy of \"pat\" and change \"^\" to \"\\(^\\|[\\/]\\)\" (if doing regular\n    // expression matching)\n    if (!fuzzy)\n    {\n\tif (*pat == '^')\n\t{\n\t    patc = alloc(STRLEN(pat) + 11);\n\t    if (patc == NULL)\n\t\treturn FAIL;\n\t    STRCPY(patc, \"\\\\(^\\\\|[\\\\/]\\\\)\");\n\t    STRCPY(patc + 11, pat + 1);\n\t}\n\telse\n\t    patc = pat;\n    }\n\n    // attempt == 0: try match with    '\\<', match at start of word\n    // attempt == 1: try match without '\\<', match anywhere\n    for (attempt = 0; attempt <= (fuzzy ? 0 : 1); ++attempt)\n    {\n\tregmatch_T\tregmatch;\n\tint\t\tscore = 0;\n\n\tif (!fuzzy)\n\t{\n\t    if (attempt > 0 && patc == pat)\n\t\tbreak;\t// there was no anchor, no need to try again\n\t    regmatch.regprog = vim_regcomp(patc + attempt * 11, RE_MAGIC);\n\t}\n\n\t// round == 1: Count the matches.\n\t// round == 2: Build the array to keep the matches.\n\tfor (round = 1; round <= 2; ++round)\n\t{\n\t    count = 0;\n\t    FOR_ALL_BUFFERS(buf)\n\t    {\n\t\tif (!buf->b_p_bl)\t// skip unlisted buffers\n\t\t    continue;\n#ifdef FEAT_DIFF\n\t\tif (options & BUF_DIFF_FILTER)\n\t\t    // Skip buffers not suitable for\n\t\t    // :diffget or :diffput completion.\n\t\t    if (buf == curbuf || !diff_mode_buf(buf))\n\t\t\tcontinue;\n#endif\n\n\t\tif (!fuzzy)\n\t\t{\n\t\t    if (regmatch.regprog == NULL)\n\t\t    {\n\t\t\t// invalid pattern, possibly after recompiling\n\t\t\tif (patc != pat)\n\t\t\t    vim_free(patc);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    p = buflist_match(&regmatch, buf, p_wic);\n\t\t}\n\t\telse\n\t\t{\n\t\t    p = NULL;\n\t\t    // first try matching with the short file name\n\t\t    if ((score = fuzzy_match_str(buf->b_sfname, pat)) != 0)\n\t\t\tp = buf->b_sfname;\n\t\t    if (p == NULL)\n\t\t    {\n\t\t\t// next try matching with the full path file name\n\t\t\tif ((score = fuzzy_match_str(buf->b_ffname, pat)) != 0)\n\t\t\t    p = buf->b_ffname;\n\t\t    }\n\t\t}\n\n\t\tif (p == NULL)\n\t\t    continue;\n\n\t\tif (round == 1)\n\t\t{\n\t\t    ++count;\n\t\t    continue;\n\t\t}\n\n\t\tif (options & WILD_HOME_REPLACE)\n\t\t    p = home_replace_save(buf, p);\n\t\telse\n\t\t    p = vim_strsave(p);\n\n\t\tif (!fuzzy)\n\t\t{\n#ifdef FEAT_VIMINFO\n\t\t    if (matches != NULL)\n\t\t    {\n\t\t\tmatches[count].buf = buf;\n\t\t\tmatches[count].match = p;\n\t\t\tcount++;\n\t\t    }\n\t\t    else\n#endif\n\t\t\t(*file)[count++] = p;\n\t\t}\n\t\telse\n\t\t{\n\t\t    fuzmatch[count].idx = count;\n\t\t    fuzmatch[count].str = p;\n\t\t    fuzmatch[count].score = score;\n\t\t    count++;\n\t\t}\n\t    }\n\t    if (count == 0)\t// no match found, break here\n\t\tbreak;\n\t    if (round == 1)\n\t    {\n\t\tif (!fuzzy)\n\t\t{\n\t\t    *file = ALLOC_MULT(char_u *, count);\n\t\t    if (*file == NULL)\n\t\t    {\n\t\t\tvim_regfree(regmatch.regprog);\n\t\t\tif (patc != pat)\n\t\t\t    vim_free(patc);\n\t\t\treturn FAIL;\n\t\t    }\n#ifdef FEAT_VIMINFO\n\t\t    if (options & WILD_BUFLASTUSED)\n\t\t\tmatches = ALLOC_MULT(bufmatch_T, count);\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t    fuzmatch = ALLOC_MULT(fuzmatch_str_T, count);\n\t\t    if (fuzmatch == NULL)\n\t\t    {\n\t\t\t*num_file = 0;\n\t\t\t*file = NULL;\n\t\t\treturn FAIL;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\tif (!fuzzy)\n\t{\n\t    vim_regfree(regmatch.regprog);\n\t    if (count)\t\t// match(es) found, break here\n\t\tbreak;\n\t}\n    }\n\n    if (!fuzzy && patc != pat)\n\tvim_free(patc);\n\n#ifdef FEAT_VIMINFO\n    if (!fuzzy)\n    {\n\tif (matches != NULL)\n\t{\n\t    int i;\n\t    if (count > 1)\n\t\tqsort(matches, count, sizeof(bufmatch_T), buf_compare);\n\t    // if the current buffer is first in the list, place it at the end\n\t    if (matches[0].buf == curbuf)\n\t    {\n\t\tfor (i = 1; i < count; i++)\n\t\t    (*file)[i-1] = matches[i].match;\n\t\t(*file)[count-1] = matches[0].match;\n\t    }\n\t    else\n\t    {\n\t\tfor (i = 0; i < count; i++)\n\t\t    (*file)[i] = matches[i].match;\n\t    }\n\t    vim_free(matches);\n\t}\n    }\n    else\n    {\n\tif (fuzzymatches_to_strmatches(fuzmatch, file, count, FALSE) == FAIL)\n\t    return FAIL;\n    }\n#endif\n\n    *num_file = count;\n    return (count == 0 ? FAIL : OK);\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 2294,
    "line_new": 2294,
    "critical_vars": [
      "*getnext"
    ],
    "function": "eval_next_non_blank",
    "filename": "vim/CVE-2022-3278/CVE-2022-3278_CWE-476_69082916c8b5d321545d60b9f5facad0a2dd5a4e_eval.c.diff",
    "function_code": "eval_next_non_blank(char_u *arg, evalarg_T *evalarg, int *getnext)\n{\n    char_u *p = skipwhite(arg);\n\n    *getnext = FALSE;\n    if (in_vim9script()\n\t    && evalarg != NULL\n\t    && (evalarg->eval_cookie != NULL || evalarg->eval_cctx != NULL\n\t\t\t\t\t\t\t\t   || *p == NL)\n\t    && (*p == NUL || *p == NL\n\t\t\t     || (vim9_comment_start(p) && VIM_ISWHITE(p[-1]))))\n    {\n\tchar_u *next;\n\n\tif (*p == NL)\n\t    next = newline_skip_comments(p);\n\telse if (evalarg->eval_cookie != NULL)\n\t    next = getline_peek_skip_comments(evalarg);\n\telse\n\t    next = peek_next_line_from_context(evalarg->eval_cctx);\n\n\tif (next != NULL)\n\t{\n\t    *getnext = *p != NL;\n\t    return skipwhite(next);\n\t}\n    }\n    return p;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 4421,
    "critical_vars": [
      "exmode_active"
    ],
    "function": "gui_do_scroll",
    "filename": "vim/CVE-2023-5441/CVE-2023-5441_CWE-476_20d161ace307e28690229b68584f2d84556f8960_gui.c.diff",
    "function_code": "gui_do_scroll(void)\n{\n    win_T\t*wp, *save_wp;\n    int\t\ti;\n    long\tnlines;\n    pos_T\told_cursor;\n    linenr_T\told_topline;\n#ifdef FEAT_DIFF\n    int\t\told_topfill;\n#endif\n\n    for (wp = firstwin, i = 0; i < current_scrollbar; wp = W_NEXT(wp), i++)\n\tif (wp == NULL)\n\t    break;\n    if (wp == NULL)\n\t// Couldn't find window\n\treturn FALSE;\n    // don't redraw, LineOffset and similar are not valid!\n    if (exmode_active)\n\treturn FALSE;\n\n    /*\n     * Compute number of lines to scroll.  If zero, nothing to do.\n     */\n    nlines = (long)scrollbar_value + 1 - (long)wp->w_topline;\n    if (nlines == 0)\n\treturn FALSE;\n\n    save_wp = curwin;\n    old_topline = wp->w_topline;\n#ifdef FEAT_DIFF\n    old_topfill = wp->w_topfill;\n#endif\n    old_cursor = wp->w_cursor;\n    curwin = wp;\n    curbuf = wp->w_buffer;\n    if (nlines < 0)\n\tscrolldown(-nlines, gui.dragged_wp == NULL);\n    else\n\tscrollup(nlines, gui.dragged_wp == NULL);\n    // Reset dragged_wp after using it.  \"dragged_sb\" will have been reset for\n    // the mouse-up event already, but we still want it to behave like when\n    // dragging.  But not the next click in an arrow.\n    if (gui.dragged_sb == SBAR_NONE)\n\tgui.dragged_wp = NULL;\n\n    if (old_topline != wp->w_topline\n#ifdef FEAT_DIFF\n\t    || old_topfill != wp->w_topfill\n#endif\n\t    )\n    {\n\tif (get_scrolloff_value() != 0)\n\t{\n\t    cursor_correct();\t\t// fix window for 'so'\n\t    update_topline();\t\t// avoid up/down jump\n\t}\n\tif (old_cursor.lnum != wp->w_cursor.lnum)\n\t    coladvance(wp->w_curswant);\n\twp->w_scbind_pos = wp->w_topline;\n    }\n\n    // Make sure wp->w_leftcol and wp->w_skipcol are correct.\n    validate_cursor();\n\n    curwin = save_wp;\n    curbuf = save_wp->w_buffer;\n\n    /*\n     * Don't call updateWindow() when nothing has changed (it will overwrite\n     * the status line!).\n     */\n    if (old_topline != wp->w_topline\n\t    || wp->w_redr_type != 0\n#ifdef FEAT_DIFF\n\t    || old_topfill != wp->w_topfill\n#endif\n\t    )\n    {\n\tint type = UPD_VALID;\n\n\tif (pum_visible())\n\t{\n\t    type = UPD_NOT_VALID;\n\t    wp->w_lines_valid = 0;\n\t}\n\n\t// Don't set must_redraw here, it may cause the popup menu to\n\t// disappear when losing focus after a scrollbar drag.\n\tif (wp->w_redr_type < type)\n\t    wp->w_redr_type = type;\n\tmch_disable_flush();\n\tupdateWindow(wp);   // update window, status line, and cmdline\n\tmch_enable_flush();\n    }\n\n    // May need to redraw the popup menu.\n    if (pum_visible())\n\tpum_redraw();\n\n    return (wp == curwin && !EQUAL_POS(curwin->w_cursor, old_cursor));\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 125,
    "critical_vars": [
      "need_diff_redraw"
    ],
    "function": "diff_buf_delete",
    "filename": "vim/CVE-2022-2208/CVE-2022-2208_CWE-476_cd38bb4d83c942c4bad596835c6766cbf32e5195_diff.c.diff",
    "function_code": "diff_buf_delete(buf_T *buf)\n{\n    int\t\ti;\n    tabpage_T\t*tp;\n\n    FOR_ALL_TABPAGES(tp)\n    {\n\ti = diff_buf_idx_tp(buf, tp);\n\tif (i != DB_COUNT)\n\t{\n\t    tp->tp_diffbuf[i] = NULL;\n\t    tp->tp_diff_invalid = TRUE;\n\t    if (tp == curtab)\n\t    {\n\t\t// don't redraw right away, more might change or buffer state\n\t\t// is invalid right now\n\t\tneed_diff_redraw = TRUE;\n\t\tredraw_later(VALID);\n\t    }\n\t}\n    }\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 679,
    "critical_vars": [
      "wp->w_buffer"
    ],
    "function": "diff_redraw",
    "filename": "vim/CVE-2022-2208/CVE-2022-2208_CWE-476_cd38bb4d83c942c4bad596835c6766cbf32e5195_diff.c.diff",
    "function_code": "diff_redraw(\n    int\t\tdofold)\t    // also recompute the folds\n{\n    win_T\t*wp;\n    win_T\t*wp_other = NULL;\n    int\t\tused_max_fill_other = FALSE;\n    int\t\tused_max_fill_curwin = FALSE;\n    int\t\tn;\n\n    need_diff_redraw = FALSE;\n    FOR_ALL_WINDOWS(wp)\n\t// when closing windows or wiping buffers skip invalid window\n\tif (wp->w_p_diff && buf_valid(wp->w_buffer))\n\t{\n\t    redraw_win_later(wp, SOME_VALID);\n\t    if (wp != curwin)\n\t\twp_other = wp;\n#ifdef FEAT_FOLDING\n\t    if (dofold && foldmethodIsDiff(wp))\n\t\tfoldUpdateAll(wp);\n#endif\n\t    // A change may have made filler lines invalid, need to take care\n\t    // of that for other windows.\n\t    n = diff_check(wp, wp->w_topline);\n\t    if ((wp != curwin && wp->w_topfill > 0) || n > 0)\n\t    {\n\t\tif (wp->w_topfill > n)\n\t\t    wp->w_topfill = (n < 0 ? 0 : n);\n\t\telse if (n > 0 && n > wp->w_topfill)\n\t\t{\n\t\t    wp->w_topfill = n;\n\t\t    if (wp == curwin)\n\t\t\tused_max_fill_curwin = TRUE;\n\t\t    else if (wp_other != NULL)\n\t\t\tused_max_fill_other = TRUE;\n\t\t}\n\t\tcheck_topfill(wp, FALSE);\n\t    }\n\t}\n\n    if (wp_other != NULL && curwin->w_p_scb)\n    {\n\tif (used_max_fill_curwin)\n\t    // The current window was set to use the maximum number of filler\n\t    // lines, may need to reduce them.\n\t    diff_set_topline(wp_other, curwin);\n\telse if (used_max_fill_other)\n\t    // The other window was set to use the maximum number of filler\n\t    // lines, may need to reduce them.\n\t    diff_set_topline(curwin, wp_other);\n    }\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 2234,
    "critical_vars": [
      "gc",
      "gui.dpy",
      "blank_pixmap"
    ],
    "function": "gui_x11_create_blank_mouse",
    "filename": "vim/CVE-2022-47024/CVE-2022-47024_CWE-476_a63ad78ed31e36dbdf3a9cd28071dcdbefce7d19_gui_x11.c.diff",
    "function_code": "gui_x11_create_blank_mouse(void)\n{\n    Pixmap blank_pixmap = XCreatePixmap(gui.dpy, gui.wid, 1, 1, 1);\n    GC gc = XCreateGC(gui.dpy, blank_pixmap, (unsigned long)0, (XGCValues*)0);\n    XDrawPoint(gui.dpy, blank_pixmap, gc, 0, 0);\n    XFreeGC(gui.dpy, gc);\n    return XCreatePixmapCursor(gui.dpy, blank_pixmap, blank_pixmap,\n\t    (XColor*)&gui.norm_pixel, (XColor*)&gui.norm_pixel, 0, 0);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 2235,
    "critical_vars": [
      "gc"
    ],
    "function": "gui_x11_create_blank_mouse",
    "filename": "vim/CVE-2022-47024/CVE-2022-47024_CWE-476_a63ad78ed31e36dbdf3a9cd28071dcdbefce7d19_gui_x11.c.diff",
    "function_code": "gui_x11_create_blank_mouse(void)\n{\n    Pixmap blank_pixmap = XCreatePixmap(gui.dpy, gui.wid, 1, 1, 1);\n    GC gc = XCreateGC(gui.dpy, blank_pixmap, (unsigned long)0, (XGCValues*)0);\n\n    if (gc != NULL)\n    {\n\tXDrawPoint(gui.dpy, blank_pixmap, gc, 0, 0);\n\tXFreeGC(gui.dpy, gc);\n    }\n    return XCreatePixmapCursor(gui.dpy, blank_pixmap, blank_pixmap,\n\t\t     (XColor*)&gui.norm_pixel, (XColor*)&gui.norm_pixel, 0, 0);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 215,
    "critical_vars": [
      "haystack_char"
    ],
    "function": "vips_utf8_strcasestr",
    "filename": "libvips/CVE-2023-40032/CVE-2023-40032_CWE-476_e091d65835966ef56d53a4105a7362cafdb1582b_svgload.c.diff",
    "function_code": "vips_utf8_strcasestr( const char *haystack_start, const char *needle_start, \n\tint len_bytes )\n{\n        int needle_len = g_utf8_strlen( needle_start, -1 );\n        int needle_len_bytes = strlen( needle_start );\n\n\tconst char *haystack;\n\n\tfor( haystack = haystack_start; \n\t\thaystack - haystack_start <= len_bytes - needle_len_bytes; \n\t\thaystack = g_utf8_find_next_char( haystack, NULL ) ) {\n                const char *needle_char;\n                const char *haystack_char;\n\t\tint i;\n\n                haystack_char = haystack;\n                needle_char = needle_start;\n                for( i = 0; i < needle_len; i++ ) {\n\t\t\t/* Haystack isn't necessarily null-terminated and\n\t\t\t * might end half-way through a utf-8 character, so we\n\t\t\t * need to be careful not to run off the end.\n\t\t\t */\n                        gunichar a = \n\t\t\t\tg_utf8_get_char_validated( haystack_char, \n\t\t\t\t\thaystack_start + len_bytes - haystack );\n                        gunichar b = \n\t\t\t\tg_utf8_get_char_validated( needle_char, -1 );\n\n                        /* Invalid utf8? \n\t\t\t *\n\t\t\t * gunichar is a uint32, so we can't compare < 0, we \n\t\t\t * have to look for -1 and -2 (the two possible error \n\t\t\t * values).\n                         */\n                        if( a == (gunichar) -1 ||\n\t\t\t\ta == (gunichar) -2 ||\n\t\t\t\tb == (gunichar) -1 ||\n\t\t\t\tb == (gunichar) -2 )\n                                return( NULL );\n\n                        /* Disallow codepoint U+0000 as it's a nul byte.\n                         * This is redundant with GLib >= 2.63.0, see:\n                         * https://gitlab.gnome.org/GNOME/glib/-/merge_requests/967\n                         */\n#if !GLIB_CHECK_VERSION( 2, 63, 0 )\n                        if( a == (gunichar) 0 )\n                                return( NULL );\n#endif\n\n                        /* Mismatch.\n                         */\n                        if( g_unichar_tolower( a ) != g_unichar_tolower( b ) )\n                                break;\n\n                        haystack_char = \n\t\t\t\tg_utf8_find_next_char( haystack_char, \n\t\t\t\t\thaystack_start + len_bytes );\n\n                        /* End of haystack. There can't be a complete needle\n                         * anywhere.\n                         */\n                        if( haystack_char == NULL )\n                                return( NULL );\n\n                        /* needle_char will never be NULL.\n                         */\n                        needle_char = \n\t\t\t\tg_utf8_find_next_char( needle_char, NULL );\n                }\n\n                if( i == needle_len )\n\t\t\t/* Walked the whole of needle, so we must have found a \n\t\t\t * complete match.\n\t\t\t */\n                        return( haystack );\n        }\n\n        /* Walked the whole of haystack without finding a match.\n         */\n        return( NULL );\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 803,
    "critical_vars": [
      "load->error"
    ],
    "function": "vips_foreign_load_start",
    "filename": "libvips/CVE-2018-7998/CVE-2018-7998_CWE-476_20d840e6da15c1574b3ed998bc92f91d1e36c2a5_foreign.c.diff",
    "function_code": "vips_foreign_load_start( VipsImage *out, void *a, void *b )\n{\n\tVipsForeignLoad *load = VIPS_FOREIGN_LOAD( b );\n\tVipsForeignLoadClass *class = VIPS_FOREIGN_LOAD_GET_CLASS( load );\n\n\t/* If this start has failed before in another thread, we can fail now.\n\t */\n\tif( load->error )\n\t\treturn( NULL );\n\n\tif( !load->real ) {\n\t\tif( !(load->real = vips_foreign_load_temp( load )) )\n\t\t\treturn( NULL );\n\n#ifdef DEBUG\n\t\tprintf( \"vips_foreign_load_start: triggering ->load()\\n\" );\n#endif /*DEBUG*/\n\n\t\t/* Read the image in. This may involve a long computation and\n\t\t * will finish with load->real holding the decompressed image. \n\t\t *\n\t\t * We want our caller to be able to see this computation on\n\t\t * @out, so eval signals on ->real need to appear on ->out.\n\t\t */\n\t\tload->real->progress_signal = load->out;\n\n\t\t/* Note the load object on the image. Loaders can use \n\t\t * this to signal invalidate if they hit a load error. See\n\t\t * vips_foreign_load_invalidate() below.\n\t\t */\n\t\tg_object_set_qdata( G_OBJECT( load->real ), \n\t\t\tvips__foreign_load_operation, load ); \n\n\t\t/* Load the image and check the result.\n\t\t *\n\t\t * ->header() read the header into @out, load has read the\n\t\t * image into @real. They must match exactly in size, bands,\n\t\t * format and coding for the copy to work.  \n\t\t *\n\t\t * Some versions of ImageMagick give different results between\n\t\t * Ping and Load for some formats, for example.\n\t\t *\n\t\t * If the load fails, we need to stop\n\t\t */\n\t\tif( class->load( load ) ||\n\t\t\tvips_image_pio_input( load->real ) || \n\t\t\tvips_foreign_load_iscompat( load->real, out ) ) {\n\t\t\tvips_operation_invalidate( VIPS_OPERATION( load ) ); \n\t\t\tload->error = TRUE;\n\n\t\t\treturn( NULL );\n\t\t}\n\n\t\t/* We have to tell vips that out depends on real. We've set\n\t\t * the demand hint below, but not given an input there.\n\t\t */\n\t\tvips_image_pipelinev( load->out, load->out->dhint, \n\t\t\tload->real, NULL );\n\t}\n\n\treturn( vips_region_new( load->real ) );\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 822,
    "critical_vars": [
      "load->real",
      "load"
    ],
    "function": "vips_foreign_load_start",
    "filename": "libvips/CVE-2018-7998/CVE-2018-7998_CWE-476_20d840e6da15c1574b3ed998bc92f91d1e36c2a5_foreign.c.diff",
    "function_code": "vips_foreign_load_start( VipsImage *out, void *a, void *b )\n{\n\tVipsForeignLoad *load = VIPS_FOREIGN_LOAD( b );\n\tVipsForeignLoadClass *class = VIPS_FOREIGN_LOAD_GET_CLASS( load );\n\n\tif( !load->real ) {\n\t\tif( !(load->real = vips_foreign_load_temp( load )) )\n\t\t\treturn( NULL );\n\n#ifdef DEBUG\n\t\tprintf( \"vips_foreign_load_start: triggering ->load()\\n\" );\n#endif /*DEBUG*/\n\n\t\t/* Read the image in. This may involve a long computation and\n\t\t * will finish with load->real holding the decompressed image. \n\t\t *\n\t\t * We want our caller to be able to see this computation on\n\t\t * @out, so eval signals on ->real need to appear on ->out.\n\t\t */\n\t\tload->real->progress_signal = load->out;\n\n\t\t/* Note the load object on the image. Loaders can use \n\t\t * this to signal invalidate if they hit a load error. See\n\t\t * vips_foreign_load_invalidate() below.\n\t\t */\n\t\tg_object_set_qdata( G_OBJECT( load->real ), \n\t\t\tvips__foreign_load_operation, load ); \n\n\t\tif( class->load( load ) ||\n\t\t\tvips_image_pio_input( load->real ) ) \n\t\t\treturn( NULL );\n\n\t\t/* ->header() read the header into @out, load has read the\n\t\t * image into @real. They must match exactly in size, bands,\n\t\t * format and coding for the copy to work.  \n\t\t *\n\t\t * Some versions of ImageMagick give different results between\n\t\t * Ping and Load for some formats, for example.\n\t\t */\n\t\tif( !vips_foreign_load_iscompat( load->real, out ) )\n\t\t\treturn( NULL );\n\n\t\t/* We have to tell vips that out depends on real. We've set\n\t\t * the demand hint below, but not given an input there.\n\t\t */\n\t\tvips_image_pipelinev( load->out, load->out->dhint, \n\t\t\tload->real, NULL );\n\t}\n\n\treturn( vips_region_new( load->real ) );\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 338,
    "critical_vars": [
      "buf",
      "bufptr"
    ],
    "function": "file_extension",
    "filename": "htmldoc/CVE-2021-23180/CVE-2021-23180_CWE-476_19c582fb32eac74b57e155cffbb529377a9e751a_file.c.diff",
    "function_code": "file_extension(const char *s)\t/* I - Filename or URL */\n{\n  const char\t*extension;\t/* Pointer to directory separator */\n  char\t\t*bufptr;\t/* Pointer into buffer */\n  static char\tbuf[1024];\t/* Buffer for files with targets */\n\n\n  if (s == NULL)\n    return (NULL);\n  else if (!strncmp(s, \"data:image/bmp;\", 15))\n    return (\"bmp\");\n  else if (!strncmp(s, \"data:image/gif;\", 15))\n    return (\"gif\");\n  else if (!strncmp(s, \"data:image/jpeg;\", 16))\n    return (\"jpg\");\n  else if (!strncmp(s, \"data:image/png;\", 15))\n    return (\"png\");\n  else if ((extension = strrchr(s, '/')) != NULL)\n    extension ++;\n  else if ((extension = strrchr(s, '\\\\')) != NULL)\n    extension ++;\n  else\n    extension = s;\n\n  if ((extension = strrchr(extension, '.')) == NULL)\n    return (\"\");\n  else\n    extension ++;\n\n  if (strchr(extension, '#') == NULL)\n    return (extension);\n\n  strlcpy(buf, extension, sizeof(buf));\n\n  if ((bufptr = strchr(buf, '#')) != NULL)\n    *bufptr = '\\0';\n\n  return (buf);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1016,
    "critical_vars": [
      "wc->url",
      "\"data:\""
    ],
    "function": "file_rlookup",
    "filename": "htmldoc/CVE-2021-23191/CVE-2021-23191_CWE-476_369b2ea1fd0d0537ba707f20a2f047b6afd2fbdc_file.c.diff",
    "function_code": "file_rlookup(const char *filename)\t/* I - Filename */\n{\n  int\t\ti;\t\t\t/* Looping var */\n  cache_t\t*wc;\t\t\t/* Current cache file */\n\n\n  for (i = web_files, wc = web_cache; i > 0; i --, wc ++)\n  {\n    if (!strcmp(wc->name, filename))\n    {\n      if (!strncmp(wc->url, \"data:\", 5))\n        return (\"data URL\");\n      else\n        return (wc->url);\n    }\n  }\n\n  return (filename);\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 235,
    "line_new": 207,
    "critical_vars": [
      "upsample"
    ],
    "function": "build_ycc_rgb_table",
    "filename": "libjpeg-turbo/CVE-2020-35538/CVE-2020-35538_CWE-476_9120a247436e84c0b4eea828cb11e8f665fcde30_jdmerge.c.diff",
    "function_code": "build_ycc_rgb_table(j_decompress_ptr cinfo)\n{\n  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;\n  int i;\n  JLONG x;\n  SHIFT_TEMPS\n\n  upsample->Cr_r_tab = (int *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (MAXJSAMPLE + 1) * sizeof(int));\n  upsample->Cb_b_tab = (int *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (MAXJSAMPLE + 1) * sizeof(int));\n  upsample->Cr_g_tab = (JLONG *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (MAXJSAMPLE + 1) * sizeof(JLONG));\n  upsample->Cb_g_tab = (JLONG *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (MAXJSAMPLE + 1) * sizeof(JLONG));\n\n  for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {\n    /* i is the actual input pixel value, in the range 0..MAXJSAMPLE */\n    /* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE */\n    /* Cr=>R value is nearest int to 1.40200 * x */\n    upsample->Cr_r_tab[i] = (int)\n                    RIGHT_SHIFT(FIX(1.40200) * x + ONE_HALF, SCALEBITS);\n    /* Cb=>B value is nearest int to 1.77200 * x */\n    upsample->Cb_b_tab[i] = (int)\n                    RIGHT_SHIFT(FIX(1.77200) * x + ONE_HALF, SCALEBITS);\n    /* Cr=>G value is scaled-up -0.71414 * x */\n    upsample->Cr_g_tab[i] = (-FIX(0.71414)) * x;\n    /* Cb=>G value is scaled-up -0.34414 * x */\n    /* We also add in ONE_HALF so that need not do it in inner loop */\n    upsample->Cb_g_tab[i] = (-FIX(0.34414)) * x + ONE_HALF;\n  }\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 257,
    "line_new": 229,
    "critical_vars": [
      "upsample"
    ],
    "function": "merged_2v_upsample",
    "filename": "libjpeg-turbo/CVE-2020-35538/CVE-2020-35538_CWE-476_9120a247436e84c0b4eea828cb11e8f665fcde30_jdmerge.c.diff",
    "function_code": "merged_2v_upsample(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n                   JDIMENSION *in_row_group_ctr,\n                   JDIMENSION in_row_groups_avail, JSAMPARRAY output_buf,\n                   JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)\n/* 2:1 vertical sampling case: may need a spare row. */\n{\n  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;\n  JSAMPROW work_ptrs[2];\n  JDIMENSION num_rows;          /* number of rows returned to caller */\n\n  if (upsample->spare_full) {\n    /* If we have a spare row saved from a previous cycle, just return it. */\n    JDIMENSION size = upsample->out_row_width;\n    if (cinfo->out_color_space == JCS_RGB565)\n      size = cinfo->output_width * 2;\n    jcopy_sample_rows(&upsample->spare_row, 0, output_buf + *out_row_ctr, 0, 1,\n                      size);\n    num_rows = 1;\n    upsample->spare_full = FALSE;\n  } else {\n    /* Figure number of rows to return to caller. */\n    num_rows = 2;\n    /* Not more than the distance to the end of the image. */\n    if (num_rows > upsample->rows_to_go)\n      num_rows = upsample->rows_to_go;\n    /* And not more than what the client can accept: */\n    out_rows_avail -= *out_row_ctr;\n    if (num_rows > out_rows_avail)\n      num_rows = out_rows_avail;\n    /* Create output pointer array for upsampler. */\n    work_ptrs[0] = output_buf[*out_row_ctr];\n    if (num_rows > 1) {\n      work_ptrs[1] = output_buf[*out_row_ctr + 1];\n    } else {\n      work_ptrs[1] = upsample->spare_row;\n      upsample->spare_full = TRUE;\n    }\n    /* Now do the upsampling. */\n    (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr, work_ptrs);\n  }\n\n  /* Adjust counts */\n  *out_row_ctr += num_rows;\n  upsample->rows_to_go -= num_rows;\n  /* When the buffer is emptied, declare this input row group consumed */\n  if (!upsample->spare_full)\n    (*in_row_group_ctr)++;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 308,
    "line_new": 280,
    "critical_vars": [
      "upsample"
    ],
    "function": "merged_1v_upsample",
    "filename": "libjpeg-turbo/CVE-2020-35538/CVE-2020-35538_CWE-476_9120a247436e84c0b4eea828cb11e8f665fcde30_jdmerge.c.diff",
    "function_code": "merged_1v_upsample(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n                   JDIMENSION *in_row_group_ctr,\n                   JDIMENSION in_row_groups_avail, JSAMPARRAY output_buf,\n                   JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)\n/* 1:1 vertical sampling case: much easier, never need a spare row. */\n{\n  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;\n\n  /* Just do the upsampling. */\n  (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr,\n                         output_buf + *out_row_ctr);\n  /* Adjust counts */\n  (*out_row_ctr)++;\n  (*in_row_group_ctr)++;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 353,
    "critical_vars": [
      "cinfo->post->post_process_data",
      "master->using_merged_upsample",
      "cinfo->post"
    ],
    "function": "read_and_discard_scanlines",
    "filename": "libjpeg-turbo/CVE-2020-35538/CVE-2020-35538_CWE-476_9120a247436e84c0b4eea828cb11e8f665fcde30_jdapistd.c.diff",
    "function_code": "read_and_discard_scanlines(j_decompress_ptr cinfo, JDIMENSION num_lines)\n{\n  JDIMENSION n;\n  my_master_ptr master = (my_master_ptr)cinfo->master;\n  void (*color_convert) (j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n                         JDIMENSION input_row, JSAMPARRAY output_buf,\n                         int num_rows) = NULL;\n  void (*color_quantize) (j_decompress_ptr cinfo, JSAMPARRAY input_buf,\n                          JSAMPARRAY output_buf, int num_rows) = NULL;\n  void (*post_process_data) (j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n                             JDIMENSION *in_row_group_ctr,\n                             JDIMENSION in_row_groups_avail,\n                             JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,\n                             JDIMENSION out_rows_avail) = NULL;\n\n  if (cinfo->cconvert && cinfo->cconvert->color_convert) {\n    color_convert = cinfo->cconvert->color_convert;\n    cinfo->cconvert->color_convert = noop_convert;\n  }\n\n  if (cinfo->cquantize && cinfo->cquantize->color_quantize) {\n    color_quantize = cinfo->cquantize->color_quantize;\n    cinfo->cquantize->color_quantize = noop_quantize;\n  }\n\n  if (master->using_merged_upsample && cinfo->post &&\n      cinfo->post->post_process_data) {\n    post_process_data = cinfo->post->post_process_data;\n    cinfo->post->post_process_data = noop_post_process;\n  }\n\n  for (n = 0; n < num_lines; n++)\n    jpeg_read_scanlines(cinfo, NULL, 1);\n\n  if (color_convert)\n    cinfo->cconvert->color_convert = color_convert;\n\n  if (color_quantize)\n    cinfo->cquantize->color_quantize = color_quantize;\n\n  if (post_process_data)\n    cinfo->post->post_process_data = post_process_data;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 385,
    "critical_vars": [
      "upsample"
    ],
    "function": "jpeg_skip_scanlines",
    "filename": "libjpeg-turbo/CVE-2020-35538/CVE-2020-35538_CWE-476_9120a247436e84c0b4eea828cb11e8f665fcde30_jdapistd.c.diff",
    "function_code": "jpeg_skip_scanlines(j_decompress_ptr cinfo, JDIMENSION num_lines)\n{\n  my_main_ptr main_ptr = (my_main_ptr)cinfo->main;\n  my_coef_ptr coef = (my_coef_ptr)cinfo->coef;\n  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n  JDIMENSION i, x;\n  int y;\n  JDIMENSION lines_per_iMCU_row, lines_left_in_iMCU_row, lines_after_iMCU_row;\n  JDIMENSION lines_to_skip, lines_to_read;\n\n  if (cinfo->global_state != DSTATE_SCANNING)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n\n  /* Do not skip past the bottom of the image. */\n  if (cinfo->output_scanline + num_lines >= cinfo->output_height) {\n    cinfo->output_scanline = cinfo->output_height;\n    (*cinfo->inputctl->finish_input_pass) (cinfo);\n    cinfo->inputctl->eoi_reached = TRUE;\n    return cinfo->output_height - cinfo->output_scanline;\n  }\n\n  if (num_lines == 0)\n    return 0;\n\n  lines_per_iMCU_row = cinfo->_min_DCT_scaled_size * cinfo->max_v_samp_factor;\n  lines_left_in_iMCU_row =\n    (lines_per_iMCU_row - (cinfo->output_scanline % lines_per_iMCU_row)) %\n    lines_per_iMCU_row;\n  lines_after_iMCU_row = num_lines - lines_left_in_iMCU_row;\n\n  /* Skip the lines remaining in the current iMCU row.  When upsampling\n   * requires context rows, we need the previous and next rows in order to read\n   * the current row.  This adds some complexity.\n   */\n  if (cinfo->upsample->need_context_rows) {\n    /* If the skipped lines would not move us past the current iMCU row, we\n     * read the lines and ignore them.  There might be a faster way of doing\n     * this, but we are facing increasing complexity for diminishing returns.\n     * The increasing complexity would be a by-product of meddling with the\n     * state machine used to skip context rows.  Near the end of an iMCU row,\n     * the next iMCU row may have already been entropy-decoded.  In this unique\n     * case, we will read the next iMCU row if we cannot skip past it as well.\n     */\n    if ((num_lines < lines_left_in_iMCU_row + 1) ||\n        (lines_left_in_iMCU_row <= 1 && main_ptr->buffer_full &&\n         lines_after_iMCU_row < lines_per_iMCU_row + 1)) {\n      read_and_discard_scanlines(cinfo, num_lines);\n      return num_lines;\n    }\n\n    /* If the next iMCU row has already been entropy-decoded, make sure that\n     * we do not skip too far.\n     */\n    if (lines_left_in_iMCU_row <= 1 && main_ptr->buffer_full) {\n      cinfo->output_scanline += lines_left_in_iMCU_row + lines_per_iMCU_row;\n      lines_after_iMCU_row -= lines_per_iMCU_row;\n    } else {\n      cinfo->output_scanline += lines_left_in_iMCU_row;\n    }\n\n    /* If we have just completed the first block, adjust the buffer pointers */\n    if (main_ptr->iMCU_row_ctr == 0 ||\n        (main_ptr->iMCU_row_ctr == 1 && lines_left_in_iMCU_row > 2))\n      set_wraparound_pointers(cinfo);\n    main_ptr->buffer_full = FALSE;\n    main_ptr->rowgroup_ctr = 0;\n    main_ptr->context_state = CTX_PREPARE_FOR_IMCU;\n    upsample->next_row_out = cinfo->max_v_samp_factor;\n    upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n  }\n\n  /* Skipping is much simpler when context rows are not required. */\n  else {\n    if (num_lines < lines_left_in_iMCU_row) {\n      increment_simple_rowgroup_ctr(cinfo, num_lines);\n      return num_lines;\n    } else {\n      cinfo->output_scanline += lines_left_in_iMCU_row;\n      main_ptr->buffer_full = FALSE;\n      main_ptr->rowgroup_ctr = 0;\n      upsample->next_row_out = cinfo->max_v_samp_factor;\n      upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n    }\n  }\n\n  /* Calculate how many full iMCU rows we can skip. */\n  if (cinfo->upsample->need_context_rows)\n    lines_to_skip = ((lines_after_iMCU_row - 1) / lines_per_iMCU_row) *\n                    lines_per_iMCU_row;\n  else\n    lines_to_skip = (lines_after_iMCU_row / lines_per_iMCU_row) *\n                    lines_per_iMCU_row;\n  /* Calculate the number of lines that remain to be skipped after skipping all\n   * of the full iMCU rows that we can.  We will not read these lines unless we\n   * have to.\n   */\n  lines_to_read = lines_after_iMCU_row - lines_to_skip;\n\n  /* For images requiring multiple scans (progressive, non-interleaved, etc.),\n   * all of the entropy decoding occurs in jpeg_start_decompress(), assuming\n   * that the input data source is non-suspending.  This makes skipping easy.\n   */\n  if (cinfo->inputctl->has_multiple_scans) {\n    if (cinfo->upsample->need_context_rows) {\n      cinfo->output_scanline += lines_to_skip;\n      cinfo->output_iMCU_row += lines_to_skip / lines_per_iMCU_row;\n      main_ptr->iMCU_row_ctr += lines_to_skip / lines_per_iMCU_row;\n      /* It is complex to properly move to the middle of a context block, so\n       * read the remaining lines instead of skipping them.\n       */\n      read_and_discard_scanlines(cinfo, lines_to_read);\n    } else {\n      cinfo->output_scanline += lines_to_skip;\n      cinfo->output_iMCU_row += lines_to_skip / lines_per_iMCU_row;\n      increment_simple_rowgroup_ctr(cinfo, lines_to_read);\n    }\n    upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n    return num_lines;\n  }\n\n  /* Skip the iMCU rows that we can safely skip. */\n  for (i = 0; i < lines_to_skip; i += lines_per_iMCU_row) {\n    for (y = 0; y < coef->MCU_rows_per_iMCU_row; y++) {\n      for (x = 0; x < cinfo->MCUs_per_row; x++) {\n        /* Calling decode_mcu() with a NULL pointer causes it to discard the\n         * decoded coefficients.  This is ~5% faster for large subsets, but\n         * it's tough to tell a difference for smaller images.\n         */\n        (*cinfo->entropy->decode_mcu) (cinfo, NULL);\n      }\n    }\n    cinfo->input_iMCU_row++;\n    cinfo->output_iMCU_row++;\n    if (cinfo->input_iMCU_row < cinfo->total_iMCU_rows)\n      start_iMCU_row(cinfo);\n    else\n      (*cinfo->inputctl->finish_input_pass) (cinfo);\n  }\n  cinfo->output_scanline += lines_to_skip;\n\n  if (cinfo->upsample->need_context_rows) {\n    /* Context-based upsampling keeps track of iMCU rows. */\n    main_ptr->iMCU_row_ctr += lines_to_skip / lines_per_iMCU_row;\n\n    /* It is complex to properly move to the middle of a context block, so\n     * read the remaining lines instead of skipping them.\n     */\n    read_and_discard_scanlines(cinfo, lines_to_read);\n  } else {\n    increment_simple_rowgroup_ctr(cinfo, lines_to_read);\n  }\n\n  /* Since skipping lines involves skipping the upsampling step, the value of\n   * \"rows_to_go\" will become invalid unless we set it here.  NOTE: This is a\n   * bit odd, since \"rows_to_go\" seems to be redundantly keeping track of\n   * output_scanline.\n   */\n  upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n\n  /* Always skip the requested number of lines. */\n  return num_lines;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 412,
    "critical_vars": [
      "master"
    ],
    "function": "jpeg_skip_scanlines",
    "filename": "libjpeg-turbo/CVE-2020-35538/CVE-2020-35538_CWE-476_9120a247436e84c0b4eea828cb11e8f665fcde30_jdapistd.c.diff",
    "function_code": "jpeg_skip_scanlines(j_decompress_ptr cinfo, JDIMENSION num_lines)\n{\n  my_main_ptr main_ptr = (my_main_ptr)cinfo->main;\n  my_coef_ptr coef = (my_coef_ptr)cinfo->coef;\n  my_master_ptr master = (my_master_ptr)cinfo->master;\n  JDIMENSION i, x;\n  int y;\n  JDIMENSION lines_per_iMCU_row, lines_left_in_iMCU_row, lines_after_iMCU_row;\n  JDIMENSION lines_to_skip, lines_to_read;\n\n  if (cinfo->global_state != DSTATE_SCANNING)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n\n  /* Do not skip past the bottom of the image. */\n  if (cinfo->output_scanline + num_lines >= cinfo->output_height) {\n    cinfo->output_scanline = cinfo->output_height;\n    (*cinfo->inputctl->finish_input_pass) (cinfo);\n    cinfo->inputctl->eoi_reached = TRUE;\n    return cinfo->output_height - cinfo->output_scanline;\n  }\n\n  if (num_lines == 0)\n    return 0;\n\n  lines_per_iMCU_row = cinfo->_min_DCT_scaled_size * cinfo->max_v_samp_factor;\n  lines_left_in_iMCU_row =\n    (lines_per_iMCU_row - (cinfo->output_scanline % lines_per_iMCU_row)) %\n    lines_per_iMCU_row;\n  lines_after_iMCU_row = num_lines - lines_left_in_iMCU_row;\n\n  /* Skip the lines remaining in the current iMCU row.  When upsampling\n   * requires context rows, we need the previous and next rows in order to read\n   * the current row.  This adds some complexity.\n   */\n  if (cinfo->upsample->need_context_rows) {\n    /* If the skipped lines would not move us past the current iMCU row, we\n     * read the lines and ignore them.  There might be a faster way of doing\n     * this, but we are facing increasing complexity for diminishing returns.\n     * The increasing complexity would be a by-product of meddling with the\n     * state machine used to skip context rows.  Near the end of an iMCU row,\n     * the next iMCU row may have already been entropy-decoded.  In this unique\n     * case, we will read the next iMCU row if we cannot skip past it as well.\n     */\n    if ((num_lines < lines_left_in_iMCU_row + 1) ||\n        (lines_left_in_iMCU_row <= 1 && main_ptr->buffer_full &&\n         lines_after_iMCU_row < lines_per_iMCU_row + 1)) {\n      read_and_discard_scanlines(cinfo, num_lines);\n      return num_lines;\n    }\n\n    /* If the next iMCU row has already been entropy-decoded, make sure that\n     * we do not skip too far.\n     */\n    if (lines_left_in_iMCU_row <= 1 && main_ptr->buffer_full) {\n      cinfo->output_scanline += lines_left_in_iMCU_row + lines_per_iMCU_row;\n      lines_after_iMCU_row -= lines_per_iMCU_row;\n    } else {\n      cinfo->output_scanline += lines_left_in_iMCU_row;\n    }\n\n    /* If we have just completed the first block, adjust the buffer pointers */\n    if (main_ptr->iMCU_row_ctr == 0 ||\n        (main_ptr->iMCU_row_ctr == 1 && lines_left_in_iMCU_row > 2))\n      set_wraparound_pointers(cinfo);\n    main_ptr->buffer_full = FALSE;\n    main_ptr->rowgroup_ctr = 0;\n    main_ptr->context_state = CTX_PREPARE_FOR_IMCU;\n    if (master->using_merged_upsample) {\n      my_merged_upsample_ptr upsample =\n        (my_merged_upsample_ptr)cinfo->upsample;\n      upsample->spare_full = FALSE;\n      upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n    } else {\n      my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n      upsample->next_row_out = cinfo->max_v_samp_factor;\n      upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n    }\n  }\n\n  /* Skipping is much simpler when context rows are not required. */\n  else {\n    if (num_lines < lines_left_in_iMCU_row) {\n      increment_simple_rowgroup_ctr(cinfo, num_lines);\n      return num_lines;\n    } else {\n      cinfo->output_scanline += lines_left_in_iMCU_row;\n      main_ptr->buffer_full = FALSE;\n      main_ptr->rowgroup_ctr = 0;\n      if (master->using_merged_upsample) {\n        my_merged_upsample_ptr upsample =\n          (my_merged_upsample_ptr)cinfo->upsample;\n        upsample->spare_full = FALSE;\n        upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n      } else {\n        my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n        upsample->next_row_out = cinfo->max_v_samp_factor;\n        upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n      }\n    }\n  }\n\n  /* Calculate how many full iMCU rows we can skip. */\n  if (cinfo->upsample->need_context_rows)\n    lines_to_skip = ((lines_after_iMCU_row - 1) / lines_per_iMCU_row) *\n                    lines_per_iMCU_row;\n  else\n    lines_to_skip = (lines_after_iMCU_row / lines_per_iMCU_row) *\n                    lines_per_iMCU_row;\n  /* Calculate the number of lines that remain to be skipped after skipping all\n   * of the full iMCU rows that we can.  We will not read these lines unless we\n   * have to.\n   */\n  lines_to_read = lines_after_iMCU_row - lines_to_skip;\n\n  /* For images requiring multiple scans (progressive, non-interleaved, etc.),\n   * all of the entropy decoding occurs in jpeg_start_decompress(), assuming\n   * that the input data source is non-suspending.  This makes skipping easy.\n   */\n  if (cinfo->inputctl->has_multiple_scans) {\n    if (cinfo->upsample->need_context_rows) {\n      cinfo->output_scanline += lines_to_skip;\n      cinfo->output_iMCU_row += lines_to_skip / lines_per_iMCU_row;\n      main_ptr->iMCU_row_ctr += lines_to_skip / lines_per_iMCU_row;\n      /* It is complex to properly move to the middle of a context block, so\n       * read the remaining lines instead of skipping them.\n       */\n      read_and_discard_scanlines(cinfo, lines_to_read);\n    } else {\n      cinfo->output_scanline += lines_to_skip;\n      cinfo->output_iMCU_row += lines_to_skip / lines_per_iMCU_row;\n      increment_simple_rowgroup_ctr(cinfo, lines_to_read);\n    }\n    if (master->using_merged_upsample) {\n      my_merged_upsample_ptr upsample =\n        (my_merged_upsample_ptr)cinfo->upsample;\n      upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n    } else {\n      my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n      upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n    }\n    return num_lines;\n  }\n\n  /* Skip the iMCU rows that we can safely skip. */\n  for (i = 0; i < lines_to_skip; i += lines_per_iMCU_row) {\n    for (y = 0; y < coef->MCU_rows_per_iMCU_row; y++) {\n      for (x = 0; x < cinfo->MCUs_per_row; x++) {\n        /* Calling decode_mcu() with a NULL pointer causes it to discard the\n         * decoded coefficients.  This is ~5% faster for large subsets, but\n         * it's tough to tell a difference for smaller images.\n         */\n        (*cinfo->entropy->decode_mcu) (cinfo, NULL);\n      }\n    }\n    cinfo->input_iMCU_row++;\n    cinfo->output_iMCU_row++;\n    if (cinfo->input_iMCU_row < cinfo->total_iMCU_rows)\n      start_iMCU_row(cinfo);\n    else\n      (*cinfo->inputctl->finish_input_pass) (cinfo);\n  }\n  cinfo->output_scanline += lines_to_skip;\n\n  if (cinfo->upsample->need_context_rows) {\n    /* Context-based upsampling keeps track of iMCU rows. */\n    main_ptr->iMCU_row_ctr += lines_to_skip / lines_per_iMCU_row;\n\n    /* It is complex to properly move to the middle of a context block, so\n     * read the remaining lines instead of skipping them.\n     */\n    read_and_discard_scanlines(cinfo, lines_to_read);\n  } else {\n    increment_simple_rowgroup_ctr(cinfo, lines_to_read);\n  }\n\n  /* Since skipping lines involves skipping the upsampling step, the value of\n   * \"rows_to_go\" will become invalid unless we set it here.  NOTE: This is a\n   * bit odd, since \"rows_to_go\" seems to be redundantly keeping track of\n   * output_scanline.\n   */\n  if (master->using_merged_upsample) {\n    my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;\n    upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n  } else {\n    my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n    upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n  }\n\n  /* Always skip the requested number of lines. */\n  return num_lines;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 22,
    "line_new": 22,
    "critical_vars": [
      "upsample"
    ],
    "function": "h2v1_merged_upsample_565_internal",
    "filename": "libjpeg-turbo/CVE-2020-35538/CVE-2020-35538_CWE-476_9120a247436e84c0b4eea828cb11e8f665fcde30_jdmrg565.c.diff",
    "function_code": "h2v1_merged_upsample_565_internal(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n                                  JDIMENSION in_row_group_ctr,\n                                  JSAMPARRAY output_buf)\n{\n  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;\n  register int y, cred, cgreen, cblue;\n  int cb, cr;\n  register JSAMPROW outptr;\n  JSAMPROW inptr0, inptr1, inptr2;\n  JDIMENSION col;\n  /* copy these pointers into registers if possible */\n  register JSAMPLE *range_limit = cinfo->sample_range_limit;\n  int *Crrtab = upsample->Cr_r_tab;\n  int *Cbbtab = upsample->Cb_b_tab;\n  JLONG *Crgtab = upsample->Cr_g_tab;\n  JLONG *Cbgtab = upsample->Cb_g_tab;\n  unsigned int r, g, b;\n  JLONG rgb;\n  SHIFT_TEMPS\n\n  inptr0 = input_buf[0][in_row_group_ctr];\n  inptr1 = input_buf[1][in_row_group_ctr];\n  inptr2 = input_buf[2][in_row_group_ctr];\n  outptr = output_buf[0];\n\n  /* Loop for each pair of output pixels */\n  for (col = cinfo->output_width >> 1; col > 0; col--) {\n    /* Do the chroma part of the calculation */\n    cb = GETJSAMPLE(*inptr1++);\n    cr = GETJSAMPLE(*inptr2++);\n    cred = Crrtab[cr];\n    cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);\n    cblue = Cbbtab[cb];\n\n    /* Fetch 2 Y values and emit 2 pixels */\n    y  = GETJSAMPLE(*inptr0++);\n    r = range_limit[y + cred];\n    g = range_limit[y + cgreen];\n    b = range_limit[y + cblue];\n    rgb = PACK_SHORT_565(r, g, b);\n\n    y  = GETJSAMPLE(*inptr0++);\n    r = range_limit[y + cred];\n    g = range_limit[y + cgreen];\n    b = range_limit[y + cblue];\n    rgb = PACK_TWO_PIXELS(rgb, PACK_SHORT_565(r, g, b));\n\n    WRITE_TWO_PIXELS(outptr, rgb);\n    outptr += 4;\n  }\n\n  /* If image width is odd, do the last output column separately */\n  if (cinfo->output_width & 1) {\n    cb = GETJSAMPLE(*inptr1);\n    cr = GETJSAMPLE(*inptr2);\n    cred = Crrtab[cr];\n    cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);\n    cblue = Cbbtab[cb];\n    y  = GETJSAMPLE(*inptr0);\n    r = range_limit[y + cred];\n    g = range_limit[y + cgreen];\n    b = range_limit[y + cblue];\n    rgb = PACK_SHORT_565(r, g, b);\n    *(INT16 *)outptr = (INT16)rgb;\n  }\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 93,
    "line_new": 93,
    "critical_vars": [
      "upsample"
    ],
    "function": "h2v1_merged_upsample_565D_internal",
    "filename": "libjpeg-turbo/CVE-2020-35538/CVE-2020-35538_CWE-476_9120a247436e84c0b4eea828cb11e8f665fcde30_jdmrg565.c.diff",
    "function_code": "h2v1_merged_upsample_565D_internal(j_decompress_ptr cinfo,\n                                   JSAMPIMAGE input_buf,\n                                   JDIMENSION in_row_group_ctr,\n                                   JSAMPARRAY output_buf)\n{\n  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;\n  register int y, cred, cgreen, cblue;\n  int cb, cr;\n  register JSAMPROW outptr;\n  JSAMPROW inptr0, inptr1, inptr2;\n  JDIMENSION col;\n  /* copy these pointers into registers if possible */\n  register JSAMPLE *range_limit = cinfo->sample_range_limit;\n  int *Crrtab = upsample->Cr_r_tab;\n  int *Cbbtab = upsample->Cb_b_tab;\n  JLONG *Crgtab = upsample->Cr_g_tab;\n  JLONG *Cbgtab = upsample->Cb_g_tab;\n  JLONG d0 = dither_matrix[cinfo->output_scanline & DITHER_MASK];\n  unsigned int r, g, b;\n  JLONG rgb;\n  SHIFT_TEMPS\n\n  inptr0 = input_buf[0][in_row_group_ctr];\n  inptr1 = input_buf[1][in_row_group_ctr];\n  inptr2 = input_buf[2][in_row_group_ctr];\n  outptr = output_buf[0];\n\n  /* Loop for each pair of output pixels */\n  for (col = cinfo->output_width >> 1; col > 0; col--) {\n    /* Do the chroma part of the calculation */\n    cb = GETJSAMPLE(*inptr1++);\n    cr = GETJSAMPLE(*inptr2++);\n    cred = Crrtab[cr];\n    cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);\n    cblue = Cbbtab[cb];\n\n    /* Fetch 2 Y values and emit 2 pixels */\n    y  = GETJSAMPLE(*inptr0++);\n    r = range_limit[DITHER_565_R(y + cred, d0)];\n    g = range_limit[DITHER_565_G(y + cgreen, d0)];\n    b = range_limit[DITHER_565_B(y + cblue, d0)];\n    d0 = DITHER_ROTATE(d0);\n    rgb = PACK_SHORT_565(r, g, b);\n\n    y  = GETJSAMPLE(*inptr0++);\n    r = range_limit[DITHER_565_R(y + cred, d0)];\n    g = range_limit[DITHER_565_G(y + cgreen, d0)];\n    b = range_limit[DITHER_565_B(y + cblue, d0)];\n    d0 = DITHER_ROTATE(d0);\n    rgb = PACK_TWO_PIXELS(rgb, PACK_SHORT_565(r, g, b));\n\n    WRITE_TWO_PIXELS(outptr, rgb);\n    outptr += 4;\n  }\n\n  /* If image width is odd, do the last output column separately */\n  if (cinfo->output_width & 1) {\n    cb = GETJSAMPLE(*inptr1);\n    cr = GETJSAMPLE(*inptr2);\n    cred = Crrtab[cr];\n    cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);\n    cblue = Cbbtab[cb];\n    y  = GETJSAMPLE(*inptr0);\n    r = range_limit[DITHER_565_R(y + cred, d0)];\n    g = range_limit[DITHER_565_G(y + cgreen, d0)];\n    b = range_limit[DITHER_565_B(y + cblue, d0)];\n    rgb = PACK_SHORT_565(r, g, b);\n    *(INT16 *)outptr = (INT16)rgb;\n  }\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 166,
    "line_new": 166,
    "critical_vars": [
      "upsample"
    ],
    "function": "h2v2_merged_upsample_565_internal",
    "filename": "libjpeg-turbo/CVE-2020-35538/CVE-2020-35538_CWE-476_9120a247436e84c0b4eea828cb11e8f665fcde30_jdmrg565.c.diff",
    "function_code": "h2v2_merged_upsample_565_internal(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n                                  JDIMENSION in_row_group_ctr,\n                                  JSAMPARRAY output_buf)\n{\n  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;\n  register int y, cred, cgreen, cblue;\n  int cb, cr;\n  register JSAMPROW outptr0, outptr1;\n  JSAMPROW inptr00, inptr01, inptr1, inptr2;\n  JDIMENSION col;\n  /* copy these pointers into registers if possible */\n  register JSAMPLE *range_limit = cinfo->sample_range_limit;\n  int *Crrtab = upsample->Cr_r_tab;\n  int *Cbbtab = upsample->Cb_b_tab;\n  JLONG *Crgtab = upsample->Cr_g_tab;\n  JLONG *Cbgtab = upsample->Cb_g_tab;\n  unsigned int r, g, b;\n  JLONG rgb;\n  SHIFT_TEMPS\n\n  inptr00 = input_buf[0][in_row_group_ctr * 2];\n  inptr01 = input_buf[0][in_row_group_ctr * 2 + 1];\n  inptr1 = input_buf[1][in_row_group_ctr];\n  inptr2 = input_buf[2][in_row_group_ctr];\n  outptr0 = output_buf[0];\n  outptr1 = output_buf[1];\n\n  /* Loop for each group of output pixels */\n  for (col = cinfo->output_width >> 1; col > 0; col--) {\n    /* Do the chroma part of the calculation */\n    cb = GETJSAMPLE(*inptr1++);\n    cr = GETJSAMPLE(*inptr2++);\n    cred = Crrtab[cr];\n    cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);\n    cblue = Cbbtab[cb];\n\n    /* Fetch 4 Y values and emit 4 pixels */\n    y  = GETJSAMPLE(*inptr00++);\n    r = range_limit[y + cred];\n    g = range_limit[y + cgreen];\n    b = range_limit[y + cblue];\n    rgb = PACK_SHORT_565(r, g, b);\n\n    y  = GETJSAMPLE(*inptr00++);\n    r = range_limit[y + cred];\n    g = range_limit[y + cgreen];\n    b = range_limit[y + cblue];\n    rgb = PACK_TWO_PIXELS(rgb, PACK_SHORT_565(r, g, b));\n\n    WRITE_TWO_PIXELS(outptr0, rgb);\n    outptr0 += 4;\n\n    y  = GETJSAMPLE(*inptr01++);\n    r = range_limit[y + cred];\n    g = range_limit[y + cgreen];\n    b = range_limit[y + cblue];\n    rgb = PACK_SHORT_565(r, g, b);\n\n    y  = GETJSAMPLE(*inptr01++);\n    r = range_limit[y + cred];\n    g = range_limit[y + cgreen];\n    b = range_limit[y + cblue];\n    rgb = PACK_TWO_PIXELS(rgb, PACK_SHORT_565(r, g, b));\n\n    WRITE_TWO_PIXELS(outptr1, rgb);\n    outptr1 += 4;\n  }\n\n  /* If image width is odd, do the last output column separately */\n  if (cinfo->output_width & 1) {\n    cb = GETJSAMPLE(*inptr1);\n    cr = GETJSAMPLE(*inptr2);\n    cred = Crrtab[cr];\n    cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);\n    cblue = Cbbtab[cb];\n\n    y  = GETJSAMPLE(*inptr00);\n    r = range_limit[y + cred];\n    g = range_limit[y + cgreen];\n    b = range_limit[y + cblue];\n    rgb = PACK_SHORT_565(r, g, b);\n    *(INT16 *)outptr0 = (INT16)rgb;\n\n    y  = GETJSAMPLE(*inptr01);\n    r = range_limit[y + cred];\n    g = range_limit[y + cgreen];\n    b = range_limit[y + cblue];\n    rgb = PACK_SHORT_565(r, g, b);\n    *(INT16 *)outptr1 = (INT16)rgb;\n  }\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 262,
    "line_new": 262,
    "critical_vars": [
      "upsample"
    ],
    "function": "h2v2_merged_upsample_565D_internal",
    "filename": "libjpeg-turbo/CVE-2020-35538/CVE-2020-35538_CWE-476_9120a247436e84c0b4eea828cb11e8f665fcde30_jdmrg565.c.diff",
    "function_code": "h2v2_merged_upsample_565D_internal(j_decompress_ptr cinfo,\n                                   JSAMPIMAGE input_buf,\n                                   JDIMENSION in_row_group_ctr,\n                                   JSAMPARRAY output_buf)\n{\n  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;\n  register int y, cred, cgreen, cblue;\n  int cb, cr;\n  register JSAMPROW outptr0, outptr1;\n  JSAMPROW inptr00, inptr01, inptr1, inptr2;\n  JDIMENSION col;\n  /* copy these pointers into registers if possible */\n  register JSAMPLE *range_limit = cinfo->sample_range_limit;\n  int *Crrtab = upsample->Cr_r_tab;\n  int *Cbbtab = upsample->Cb_b_tab;\n  JLONG *Crgtab = upsample->Cr_g_tab;\n  JLONG *Cbgtab = upsample->Cb_g_tab;\n  JLONG d0 = dither_matrix[cinfo->output_scanline & DITHER_MASK];\n  JLONG d1 = dither_matrix[(cinfo->output_scanline + 1) & DITHER_MASK];\n  unsigned int r, g, b;\n  JLONG rgb;\n  SHIFT_TEMPS\n\n  inptr00 = input_buf[0][in_row_group_ctr * 2];\n  inptr01 = input_buf[0][in_row_group_ctr * 2 + 1];\n  inptr1 = input_buf[1][in_row_group_ctr];\n  inptr2 = input_buf[2][in_row_group_ctr];\n  outptr0 = output_buf[0];\n  outptr1 = output_buf[1];\n\n  /* Loop for each group of output pixels */\n  for (col = cinfo->output_width >> 1; col > 0; col--) {\n    /* Do the chroma part of the calculation */\n    cb = GETJSAMPLE(*inptr1++);\n    cr = GETJSAMPLE(*inptr2++);\n    cred = Crrtab[cr];\n    cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);\n    cblue = Cbbtab[cb];\n\n    /* Fetch 4 Y values and emit 4 pixels */\n    y  = GETJSAMPLE(*inptr00++);\n    r = range_limit[DITHER_565_R(y + cred, d0)];\n    g = range_limit[DITHER_565_G(y + cgreen, d0)];\n    b = range_limit[DITHER_565_B(y + cblue, d0)];\n    d0 = DITHER_ROTATE(d0);\n    rgb = PACK_SHORT_565(r, g, b);\n\n    y  = GETJSAMPLE(*inptr00++);\n    r = range_limit[DITHER_565_R(y + cred, d0)];\n    g = range_limit[DITHER_565_G(y + cgreen, d0)];\n    b = range_limit[DITHER_565_B(y + cblue, d0)];\n    d0 = DITHER_ROTATE(d0);\n    rgb = PACK_TWO_PIXELS(rgb, PACK_SHORT_565(r, g, b));\n\n    WRITE_TWO_PIXELS(outptr0, rgb);\n    outptr0 += 4;\n\n    y  = GETJSAMPLE(*inptr01++);\n    r = range_limit[DITHER_565_R(y + cred, d1)];\n    g = range_limit[DITHER_565_G(y + cgreen, d1)];\n    b = range_limit[DITHER_565_B(y + cblue, d1)];\n    d1 = DITHER_ROTATE(d1);\n    rgb = PACK_SHORT_565(r, g, b);\n\n    y  = GETJSAMPLE(*inptr01++);\n    r = range_limit[DITHER_565_R(y + cred, d1)];\n    g = range_limit[DITHER_565_G(y + cgreen, d1)];\n    b = range_limit[DITHER_565_B(y + cblue, d1)];\n    d1 = DITHER_ROTATE(d1);\n    rgb = PACK_TWO_PIXELS(rgb, PACK_SHORT_565(r, g, b));\n\n    WRITE_TWO_PIXELS(outptr1, rgb);\n    outptr1 += 4;\n  }\n\n  /* If image width is odd, do the last output column separately */\n  if (cinfo->output_width & 1) {\n    cb = GETJSAMPLE(*inptr1);\n    cr = GETJSAMPLE(*inptr2);\n    cred = Crrtab[cr];\n    cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);\n    cblue = Cbbtab[cb];\n\n    y  = GETJSAMPLE(*inptr00);\n    r = range_limit[DITHER_565_R(y + cred, d0)];\n    g = range_limit[DITHER_565_G(y + cgreen, d0)];\n    b = range_limit[DITHER_565_B(y + cblue, d0)];\n    rgb = PACK_SHORT_565(r, g, b);\n    *(INT16 *)outptr0 = (INT16)rgb;\n\n    y  = GETJSAMPLE(*inptr01);\n    r = range_limit[DITHER_565_R(y + cred, d1)];\n    g = range_limit[DITHER_565_G(y + cgreen, d1)];\n    b = range_limit[DITHER_565_B(y + cblue, d1)];\n    rgb = PACK_SHORT_565(r, g, b);\n    *(INT16 *)outptr1 = (INT16)rgb;\n  }\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 28,
    "line_new": 28,
    "critical_vars": [
      "upsample"
    ],
    "function": "h2v1_merged_upsample_internal",
    "filename": "libjpeg-turbo/CVE-2020-35538/CVE-2020-35538_CWE-476_9120a247436e84c0b4eea828cb11e8f665fcde30_jdmrgext.c.diff",
    "function_code": "h2v1_merged_upsample_internal(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n                              JDIMENSION in_row_group_ctr,\n                              JSAMPARRAY output_buf)\n{\n  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;\n  register int y, cred, cgreen, cblue;\n  int cb, cr;\n  register JSAMPROW outptr;\n  JSAMPROW inptr0, inptr1, inptr2;\n  JDIMENSION col;\n  /* copy these pointers into registers if possible */\n  register JSAMPLE *range_limit = cinfo->sample_range_limit;\n  int *Crrtab = upsample->Cr_r_tab;\n  int *Cbbtab = upsample->Cb_b_tab;\n  JLONG *Crgtab = upsample->Cr_g_tab;\n  JLONG *Cbgtab = upsample->Cb_g_tab;\n  SHIFT_TEMPS\n\n  inptr0 = input_buf[0][in_row_group_ctr];\n  inptr1 = input_buf[1][in_row_group_ctr];\n  inptr2 = input_buf[2][in_row_group_ctr];\n  outptr = output_buf[0];\n  /* Loop for each pair of output pixels */\n  for (col = cinfo->output_width >> 1; col > 0; col--) {\n    /* Do the chroma part of the calculation */\n    cb = GETJSAMPLE(*inptr1++);\n    cr = GETJSAMPLE(*inptr2++);\n    cred = Crrtab[cr];\n    cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);\n    cblue = Cbbtab[cb];\n    /* Fetch 2 Y values and emit 2 pixels */\n    y  = GETJSAMPLE(*inptr0++);\n    outptr[RGB_RED] =   range_limit[y + cred];\n    outptr[RGB_GREEN] = range_limit[y + cgreen];\n    outptr[RGB_BLUE] =  range_limit[y + cblue];\n#ifdef RGB_ALPHA\n    outptr[RGB_ALPHA] = 0xFF;\n#endif\n    outptr += RGB_PIXELSIZE;\n    y  = GETJSAMPLE(*inptr0++);\n    outptr[RGB_RED] =   range_limit[y + cred];\n    outptr[RGB_GREEN] = range_limit[y + cgreen];\n    outptr[RGB_BLUE] =  range_limit[y + cblue];\n#ifdef RGB_ALPHA\n    outptr[RGB_ALPHA] = 0xFF;\n#endif\n    outptr += RGB_PIXELSIZE;\n  }\n  /* If image width is odd, do the last output column separately */\n  if (cinfo->output_width & 1) {\n    cb = GETJSAMPLE(*inptr1);\n    cr = GETJSAMPLE(*inptr2);\n    cred = Crrtab[cr];\n    cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);\n    cblue = Cbbtab[cb];\n    y  = GETJSAMPLE(*inptr0);\n    outptr[RGB_RED] =   range_limit[y + cred];\n    outptr[RGB_GREEN] = range_limit[y + cgreen];\n    outptr[RGB_BLUE] =  range_limit[y + cblue];\n#ifdef RGB_ALPHA\n    outptr[RGB_ALPHA] = 0xFF;\n#endif\n  }\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1702,
    "critical_vars": [
      "s"
    ],
    "function": "tgs_build_reply",
    "filename": "heimdal/CVE-2021-3671/CVE-2021-3671_CWE-476_04171147948d0a3636bc6374181926f0fb2ec83a_krb5tgs.c.diff",
    "function_code": "tgs_build_reply(astgs_request_t priv,\n\t\thdb_entry_ex *krbtgt,\n\t\tkrb5_enctype krbtgt_etype,\n\t\tconst krb5_keyblock *replykey,\n\t\tint rk_is_subkey,\n\t\tkrb5_ticket *ticket,\n\t\tconst char **e_text,\n\t\tAuthorizationData **auth_data,\n\t\tconst struct sockaddr *from_addr)\n{\n    krb5_context context = priv->context;\n    krb5_kdc_configuration *config = priv->config;\n    KDC_REQ *req = &priv->req;\n    KDC_REQ_BODY *b = &priv->req.req_body;\n    const char *from = priv->from;\n    krb5_error_code ret, ret2;\n    krb5_principal cp = NULL, sp = NULL, rsp = NULL, tp = NULL, dp = NULL;\n    krb5_principal krbtgt_out_principal = NULL;\n    char *spn = NULL, *cpn = NULL, *tpn = NULL, *dpn = NULL, *krbtgt_out_n = NULL;\n    hdb_entry_ex *server = NULL, *client = NULL, *s4u2self_impersonated_client = NULL;\n    HDB *clientdb, *s4u2self_impersonated_clientdb;\n    krb5_realm ref_realm = NULL;\n    EncTicketPart *tgt = &ticket->ticket;\n    krb5_principals spp = NULL;\n    const EncryptionKey *ekey;\n    krb5_keyblock sessionkey;\n    krb5_kvno kvno;\n    krb5_data rspac;\n    const char *tgt_realm = /* Realm of TGT issuer */\n        krb5_principal_get_realm(context, krbtgt->entry.principal);\n    const char *our_realm = /* Realm of this KDC */\n        krb5_principal_get_comp_string(context, krbtgt->entry.principal, 1);\n    char **capath = NULL;\n    size_t num_capath = 0;\n\n    hdb_entry_ex *krbtgt_out = NULL;\n\n    METHOD_DATA enc_pa_data;\n\n    PrincipalName *s;\n    Realm r;\n    EncTicketPart adtkt;\n    char opt_str[128];\n    int signedpath = 0;\n\n    Key *tkey_check;\n    Key *tkey_sign;\n    int flags = HDB_F_FOR_TGS_REQ;\n\n    memset(&sessionkey, 0, sizeof(sessionkey));\n    memset(&adtkt, 0, sizeof(adtkt));\n    krb5_data_zero(&rspac);\n    memset(&enc_pa_data, 0, sizeof(enc_pa_data));\n\n    s = b->sname;\n    r = b->realm;\n\n    /*\n     * The canonicalize KDC option is passed as a hint to the backend, but\n     * can typically be ignored. Per RFC 6806, names are not canonicalized\n     * in response to a TGS request (although we make an exception, see\n     * force-canonicalize below).\n     */\n    if (b->kdc_options.canonicalize)\n\tflags |= HDB_F_CANON;\n\n    if(b->kdc_options.enc_tkt_in_skey){\n\tTicket *t;\n\thdb_entry_ex *uu;\n\tkrb5_principal p;\n\tKey *uukey;\n\tkrb5uint32 second_kvno = 0;\n\tkrb5uint32 *kvno_ptr = NULL;\n\n\tif(b->additional_tickets == NULL ||\n\t   b->additional_tickets->len == 0){\n\t    ret = KRB5KDC_ERR_BADOPTION; /* ? */\n\t    kdc_log(context, config, 4,\n\t\t    \"No second ticket present in user-to-user request\");\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"No second ticket present in user-to-user request\");\n\t    goto out;\n\t}\n\tt = &b->additional_tickets->val[0];\n\tif(!get_krbtgt_realm(&t->sname)){\n\t    kdc_log(context, config, 4,\n\t\t    \"Additional ticket is not a ticket-granting ticket\");\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"Additional ticket is not a ticket-granting ticket\");\n\t    ret = KRB5KDC_ERR_POLICY;\n\t    goto out;\n\t}\n\t_krb5_principalname2krb5_principal(context, &p, t->sname, t->realm);\n\tret = krb5_unparse_name(context, p, &tpn);\n\tif (ret)\n\t\tgoto out;\n\tif(t->enc_part.kvno){\n\t    second_kvno = *t->enc_part.kvno;\n\t    kvno_ptr = &second_kvno;\n\t}\n\tret = _kdc_db_fetch(context, config, p,\n\t\t\t    HDB_F_GET_KRBTGT, kvno_ptr,\n\t\t\t    NULL, &uu);\n\tkrb5_free_principal(context, p);\n\tif(ret){\n\t    if (ret == HDB_ERR_NOENTRY)\n\t\tret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"User-to-user service principal (TGS) unknown\");\n\t    goto out;\n\t}\n\tret = hdb_enctype2key(context, &uu->entry, NULL,\n\t\t\t      t->enc_part.etype, &uukey);\n\tif(ret){\n\t    _kdc_free_ent(context, uu);\n\t    ret = KRB5KDC_ERR_ETYPE_NOSUPP; /* XXX */\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"User-to-user enctype not supported\");\n\t    goto out;\n\t}\n\tret = krb5_decrypt_ticket(context, t, &uukey->key, &adtkt, 0);\n\t_kdc_free_ent(context, uu);\n\tif(ret) {\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"User-to-user TGT decrypt failure\");\n\t    goto out;\n        }\n\n\tret = verify_flags(context, config, &adtkt, tpn);\n\tif (ret) {\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"User-to-user TGT expired or invalid\");\n\t    goto out;\n        }\n\n\ts = &adtkt.cname;\n\tr = adtkt.crealm;\n    } else if (s == NULL) {\n\tret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n\t_kdc_set_e_text(r, \"No server in request\");\n\tgoto out;\n    }\n\n    _krb5_principalname2krb5_principal(context, &sp, *s, r);\n    ret = krb5_unparse_name(context, sp, &priv->sname);\n    if (ret)\n\tgoto out;\n    spn = priv->sname;\n    _krb5_principalname2krb5_principal(context, &cp, tgt->cname, tgt->crealm);\n    ret = krb5_unparse_name(context, cp, &priv->cname);\n    if (ret)\n\tgoto out;\n    cpn = priv->cname;\n    unparse_flags (KDCOptions2int(b->kdc_options),\n\t\t   asn1_KDCOptions_units(),\n\t\t   opt_str, sizeof(opt_str));\n    if(*opt_str)\n\tkdc_log(context, config, 4,\n\t\t\"TGS-REQ %s from %s for %s [%s]\",\n\t\tcpn, from, spn, opt_str);\n    else\n\tkdc_log(context, config, 4,\n\t\t\"TGS-REQ %s from %s for %s\", cpn, from, spn);\n\n    /*\n     * Fetch server\n     */\n\nserver_lookup:\n    ret = _kdc_db_fetch(context, config, sp,\n                        HDB_F_GET_SERVER | HDB_F_DELAY_NEW_KEYS | flags,\n\t\t\tNULL, NULL, &server);\n    priv->server = server;\n    if (ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(context, config, 5, \"target %s does not have secrets at this KDC, need to proxy\", spn);\n        _kdc_audit_addreason((kdc_request_t)priv, \"Target not found here\");\n\tgoto out;\n    } else if (ret == HDB_ERR_WRONG_REALM) {\n        free(ref_realm);\n\tref_realm = strdup(server->entry.principal->realm);\n\tif (ref_realm == NULL) {\n            ret = krb5_enomem(context);\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 4,\n\t\t\"Returning a referral to realm %s for \"\n\t\t\"server %s.\",\n\t\tref_realm, spn);\n\tkrb5_free_principal(context, sp);\n\tsp = NULL;\n\tret = krb5_make_principal(context, &sp, r, KRB5_TGS_NAME,\n\t\t\t\t  ref_realm, NULL);\n\tif (ret)\n\t    goto out;\n\tfree(priv->sname);\n        priv->sname = NULL;\n\tret = krb5_unparse_name(context, sp, &priv->sname);\n\tif (ret)\n\t    goto out;\n\tspn = priv->sname;\n\n\tgoto server_lookup;\n    } else if (ret) {\n\tconst char *new_rlm, *msg;\n\tRealm req_rlm;\n\tkrb5_realm *realms;\n\n\tif ((req_rlm = get_krbtgt_realm(&sp->name)) != NULL) {\n            if (capath == NULL) {\n                /* With referalls, hierarchical capaths are always enabled */\n                ret2 = _krb5_find_capath(context, tgt->crealm, our_realm,\n                                         req_rlm, TRUE, &capath, &num_capath);\n                if (ret2) {\n                    ret = ret2;\n                    _kdc_audit_addreason((kdc_request_t)priv,\n                                         \"No trusted path from client realm to ours\");\n                    goto out;\n                }\n            }\n            new_rlm = num_capath > 0 ? capath[--num_capath] : NULL;\n            if (new_rlm) {\n                kdc_log(context, config, 5, \"krbtgt from %s via %s for \"\n                        \"realm %s not found, trying %s\", tgt->crealm,\n                        our_realm, req_rlm, new_rlm);\n\n                free(ref_realm);\n                ref_realm = strdup(new_rlm);\n                if (ref_realm == NULL) {\n                    ret = krb5_enomem(context);\n                    goto out;\n                }\n\n                krb5_free_principal(context, sp);\n                sp = NULL;\n                krb5_make_principal(context, &sp, r,\n                                    KRB5_TGS_NAME, ref_realm, NULL);\n                free(priv->sname);\n                priv->sname = NULL;\n                ret = krb5_unparse_name(context, sp, &priv->sname);\n                if (ret)\n                    goto out;\n                spn = priv->sname;\n                goto server_lookup;\n            }\n\t} else if (need_referral(context, config, &b->kdc_options, sp, &realms)) {\n\t    if (strcmp(realms[0], sp->realm) != 0) {\n\t\tkdc_log(context, config, 4,\n\t\t\t\"Returning a referral to realm %s for \"\n\t\t\t\"server %s that was not found\",\n\t\t\trealms[0], spn);\n\t\tkrb5_free_principal(context, sp);\n                sp = NULL;\n\t\tkrb5_make_principal(context, &sp, r, KRB5_TGS_NAME,\n\t\t\t\t    realms[0], NULL);\n\t\tfree(priv->sname);\n                priv->sname = NULL;\n\t\tret = krb5_unparse_name(context, sp, &priv->sname);\n\t\tif (ret) {\n\t\t    krb5_free_host_realm(context, realms);\n\t\t    goto out;\n\t\t}\n\t\tspn = priv->sname;\n\n                free(ref_realm);\n\t\tref_realm = strdup(realms[0]);\n\n\t\tkrb5_free_host_realm(context, realms);\n\t\tgoto server_lookup;\n\t    }\n\t    krb5_free_host_realm(context, realms);\n\t}\n\tmsg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 3,\n\t\t\"Server not found in database: %s: %s\", spn, msg);\n\tkrb5_free_error_message(context, msg);\n\tif (ret == HDB_ERR_NOENTRY)\n\t    ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n        _kdc_audit_addreason((kdc_request_t)priv,\n                             \"Service principal unknown\");\n\tgoto out;\n    }\n\n    /*\n     * RFC 6806 notes that names MUST NOT be changed in the response to\n     * a TGS request. Hence we ignore the setting of the canonicalize\n     * KDC option. However, for legacy interoperability we do allow the\n     * backend to override this by setting the force-canonicalize HDB\n     * flag in the server entry.\n     */\n    if (server->entry.flags.force_canonicalize)\n\trsp = server->entry.principal;\n    else\n\trsp = sp;\n\n    /*\n     * Select enctype, return key and kvno.\n     */\n\n    {\n\tkrb5_enctype etype;\n\n\tif(b->kdc_options.enc_tkt_in_skey) {\n\t    size_t i;\n\t    ekey = &adtkt.key;\n\t    for(i = 0; i < b->etype.len; i++)\n\t\tif (b->etype.val[i] == adtkt.key.keytype)\n\t\t    break;\n\t    if(i == b->etype.len) {\n\t\tkdc_log(context, config, 4,\n\t\t\t\"Addition ticket have not matching etypes\");\n\t\tkrb5_clear_error_message(context);\n\t\tret = KRB5KDC_ERR_ETYPE_NOSUPP;\n                _kdc_audit_addreason((kdc_request_t)priv,\n                                     \"No matching enctypes for 2nd ticket\");\n\t\tgoto out;\n\t    }\n\t    etype = b->etype.val[i];\n\t    kvno = 0;\n\t} else {\n\t    Key *skey;\n\n\t    ret = _kdc_find_etype(priv, krb5_principal_is_krbtgt(context, sp)\n\t\t\t\t\t\t\t     ? KFE_IS_TGS : 0,\n\t\t\t\t  b->etype.val, b->etype.len, &etype, NULL,\n\t\t\t\t  NULL);\n\t    if(ret) {\n\t\tkdc_log(context, config, 4,\n\t\t\t\"Server (%s) has no support for etypes\", spn);\n                _kdc_audit_addreason((kdc_request_t)priv,\n                                     \"Enctype not supported\");\n\t\tgoto out;\n\t    }\n\t    ret = _kdc_get_preferred_key(context, config, server, spn,\n\t\t\t\t\t NULL, &skey);\n\t    if(ret) {\n\t\tkdc_log(context, config, 4,\n\t\t\t\"Server (%s) has no supported etypes\", spn);\n                _kdc_audit_addreason((kdc_request_t)priv,\n                                     \"Enctype not supported\");\n\t\tgoto out;\n\t    }\n\t    ekey = &skey->key;\n\t    kvno = server->entry.kvno;\n\t}\n\n\tret = krb5_generate_random_keyblock(context, etype, &sessionkey);\n\tif (ret)\n\t    goto out;\n    }\n\n    /*\n     * Check that service is in the same realm as the krbtgt. If it's\n     * not the same, it's someone that is using a uni-directional trust\n     * backward.\n     */\n\n    /*\n     * Validate authorization data\n     */\n\n    ret = hdb_enctype2key(context, &krbtgt->entry, NULL, /* XXX use the right kvno! */\n\t\t\t  krbtgt_etype, &tkey_check);\n    if(ret) {\n\tkdc_log(context, config, 4,\n\t\t    \"Failed to find key for krbtgt PAC check\");\n        _kdc_audit_addreason((kdc_request_t)priv,\n                             \"No key for krbtgt PAC check\");\n\tgoto out;\n    }\n\n    /* \n     * Now refetch the primary krbtgt, and get the current kvno (the\n     * sign check may have been on an old kvno, and the server may\n     * have been an incoming trust)\n     */\n    \n    ret = krb5_make_principal(context,\n                              &krbtgt_out_principal,\n                              our_realm,\n                              KRB5_TGS_NAME,\n                              our_realm,\n                              NULL);\n    if (ret) {\n        kdc_log(context, config, 4,\n                \"Failed to make krbtgt principal name object for \"\n                \"authz-data signatures\");\n        goto out;\n    }\n    ret = krb5_unparse_name(context, krbtgt_out_principal, &krbtgt_out_n);\n    if (ret) {\n        kdc_log(context, config, 4,\n                \"Failed to make krbtgt principal name object for \"\n                \"authz-data signatures\");\n        goto out;\n    }\n\n    ret = _kdc_db_fetch(context, config, krbtgt_out_principal,\n\t\t\tHDB_F_GET_KRBTGT, NULL, NULL, &krbtgt_out);\n    if (ret) {\n\tchar *ktpn = NULL;\n\tret = krb5_unparse_name(context, krbtgt->entry.principal, &ktpn);\n\tkdc_log(context, config, 4,\n\t\t\"No such principal %s (needed for authz-data signature keys) \"\n\t\t\"while processing TGS-REQ for service %s with krbtg %s\",\n\t\tkrbtgt_out_n, spn, (ret == 0) ? ktpn : \"<unknown>\");\n\tfree(ktpn);\n\tret = KRB5KRB_AP_ERR_NOT_US;\n\tgoto out;\n    }\n\n    /* \n     * The first realm is the realm of the service, the second is\n     * krbtgt/<this>/@REALM component of the krbtgt DN the request was\n     * encrypted to.  The redirection via the krbtgt_out entry allows\n     * the DB to possibly correct the case of the realm (Samba4 does\n     * this) before the strcmp() \n     */\n    if (strcmp(krb5_principal_get_realm(context, server->entry.principal),\n\t       krb5_principal_get_realm(context, krbtgt_out->entry.principal)) != 0) {\n\tchar *ktpn;\n\tret = krb5_unparse_name(context, krbtgt_out->entry.principal, &ktpn);\n\tkdc_log(context, config, 4,\n\t\t\"Request with wrong krbtgt: %s\",\n\t\t(ret == 0) ? ktpn : \"<unknown>\");\n\tif(ret == 0)\n\t    free(ktpn);\n\tret = KRB5KRB_AP_ERR_NOT_US;\n        _kdc_audit_addreason((kdc_request_t)priv, \"Request with wrong TGT\");\n\tgoto out;\n    }\n\n    ret = _kdc_get_preferred_key(context, config, krbtgt_out, krbtgt_out_n,\n\t\t\t\t NULL, &tkey_sign);\n    if (ret) {\n\tkdc_log(context, config, 4,\n\t\t    \"Failed to find key for krbtgt PAC signature\");\n        _kdc_audit_addreason((kdc_request_t)priv,\n                             \"Failed to find key for krbtgt PAC signature\");\n\tgoto out;\n    }\n    ret = hdb_enctype2key(context, &krbtgt_out->entry, NULL,\n\t\t\t  tkey_sign->key.keytype, &tkey_sign);\n    if(ret) {\n\tkdc_log(context, config, 4,\n\t\t    \"Failed to find key for krbtgt PAC signature\");\n        _kdc_audit_addreason((kdc_request_t)priv,\n                             \"Failed to find key for krbtgt PAC signature\");\n\tgoto out;\n    }\n\n    {\n        krb5_data verified_cas;\n\n        /*\n         * If the client doesn't exist in the HDB but has a TGT and it's\n         * obtained with PKINIT then we assume it's a synthetic client -- that\n         * is, a client whose name was vouched for by a CA using a PKINIT SAN,\n         * but which doesn't exist in the HDB proper.  We'll allow such a\n         * client to do TGT requests even though normally we'd reject all\n         * clients that don't exist in the HDB.\n         */\n        ret = krb5_ticket_get_authorization_data_type(context, ticket,\n                                                      KRB5_AUTHDATA_INITIAL_VERIFIED_CAS,\n                                                      &verified_cas);\n        if (ret == 0) {\n            krb5_data_free(&verified_cas);\n            flags |= HDB_F_SYNTHETIC_OK;\n        }\n    }\n    ret = _kdc_db_fetch(context, config, cp, HDB_F_GET_CLIENT | flags,\n\t\t\tNULL, &clientdb, &client);\n    flags &= ~HDB_F_SYNTHETIC_OK;\n    priv->client = client;\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\t/* This is OK, we are just trying to find out if they have\n\t * been disabled or deleted in the meantime, missing secrets\n\t * is OK */\n    } else if(ret){\n\tconst char *krbtgt_realm, *msg;\n\n\t/*\n\t * If the client belongs to the same realm as our krbtgt, it\n\t * should exist in the local database.\n\t *\n\t */\n\n\tkrbtgt_realm = krb5_principal_get_realm(context, krbtgt_out->entry.principal);\n\n\tif(strcmp(krb5_principal_get_realm(context, cp), krbtgt_realm) == 0) {\n\t    if (ret == HDB_ERR_NOENTRY)\n\t\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\t    kdc_log(context, config, 4, \"Client no longer in database: %s\",\n\t\t    cpn);\n            _kdc_audit_addreason((kdc_request_t)priv, \"Client no longer in HDB\");\n\t    goto out;\n\t}\n\n\tmsg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 4, \"Client not found in database: %s\", msg);\n        _kdc_audit_addreason((kdc_request_t)priv, \"Client does not exist\");\n\tkrb5_free_error_message(context, msg);\n    } else if (ret == 0 &&\n               (client->entry.flags.invalid || !client->entry.flags.client)) {\n        _kdc_audit_addreason((kdc_request_t)priv, \"Client has invalid bit set\");\n        kdc_log(context, config, 4, \"Client has invalid bit set\");\n        ret = KRB5KDC_ERR_POLICY;\n        goto out;\n    }\n\n    ret = check_PAC(context, config, cp, NULL,\n\t\t    client, server, krbtgt,\n\t\t    &tkey_check->key,\n\t\t    ekey, &tkey_sign->key,\n\t\t    tgt, &rspac, &signedpath);\n    if (ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n        _kdc_audit_addreason((kdc_request_t)priv, \"PAC check failed\");\n\tkdc_log(context, config, 4,\n\t\t\"Verify PAC failed for %s (%s) from %s with %s\",\n\t\tspn, cpn, from, msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n\n    /* also check the krbtgt for signature */\n    ret = check_KRB5SignedPath(context,\n\t\t\t       config,\n\t\t\t       krbtgt,\n\t\t\t       cp,\n\t\t\t       tgt,\n\t\t\t       &spp,\n\t\t\t       &signedpath);\n    if (ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n        _kdc_audit_addreason((kdc_request_t)priv, \"KRB5SignedPath check failed\");\n\tkdc_log(context, config, 4,\n\t\t\"KRB5SignedPath check failed for %s (%s) from %s with %s\",\n\t\tspn, cpn, from, msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n\n    /*\n     * Process request\n     */\n\n    /* by default the tgt principal matches the client principal */\n    tp = cp;\n    tpn = cpn;\n\n    if (client) {\n\tconst PA_DATA *sdata;\n\tint i = 0;\n\n\tsdata = _kdc_find_padata(req, &i, KRB5_PADATA_FOR_USER);\n\tif (sdata) {\n\t    struct astgs_request_desc imp_req;\n\t    krb5_crypto crypto;\n\t    krb5_data datack;\n\t    PA_S4U2Self self;\n\t    const char *str;\n\n\t    ret = decode_PA_S4U2Self(sdata->padata_value.data,\n\t\t\t\t     sdata->padata_value.length,\n\t\t\t\t     &self, NULL);\n\t    if (ret) {\n                _kdc_audit_addreason((kdc_request_t)priv,\n                                     \"Failed to decode PA-S4U2Self\");\n\t\tkdc_log(context, config, 4, \"Failed to decode PA-S4U2Self\");\n\t\tgoto out;\n\t    }\n\n\t    if (!krb5_checksum_is_keyed(context, self.cksum.cksumtype)) {\n\t\tfree_PA_S4U2Self(&self);\n                _kdc_audit_addreason((kdc_request_t)priv,\n                                     \"PA-S4U2Self with unkeyed checksum\");\n\t\tkdc_log(context, config, 4, \"Reject PA-S4U2Self with unkeyed checksum\");\n\t\tret = KRB5KRB_AP_ERR_INAPP_CKSUM;\n\t\tgoto out;\n\t    }\n\n\t    ret = _krb5_s4u2self_to_checksumdata(context, &self, &datack);\n\t    if (ret)\n\t\tgoto out;\n\n\t    ret = krb5_crypto_init(context, &tgt->key, 0, &crypto);\n\t    if (ret) {\n\t\tconst char *msg = krb5_get_error_message(context, ret);\n\t\tfree_PA_S4U2Self(&self);\n\t\tkrb5_data_free(&datack);\n\t\tkdc_log(context, config, 4, \"krb5_crypto_init failed: %s\", msg);\n\t\tkrb5_free_error_message(context, msg);\n\t\tgoto out;\n\t    }\n\n\t    /* Allow HMAC_MD5 checksum with any key type */\n\t    if (self.cksum.cksumtype == CKSUMTYPE_HMAC_MD5) {\n\t\tstruct krb5_crypto_iov iov;\n\t\tunsigned char csdata[16];\n\t\tChecksum cs;\n\n\t\tcs.checksum.length = sizeof(csdata);\n\t\tcs.checksum.data = &csdata;\n\n\t\tiov.data.data = datack.data;\n\t\tiov.data.length = datack.length;\n\t\tiov.flags = KRB5_CRYPTO_TYPE_DATA;\n\n\t\tret = _krb5_HMAC_MD5_checksum(context, NULL, &crypto->key,\n\t\t\t\t\t      KRB5_KU_OTHER_CKSUM, &iov, 1,\n\t\t\t\t\t      &cs);\n\t\tif (ret == 0 &&\n\t\t    krb5_data_ct_cmp(&cs.checksum, &self.cksum.checksum) != 0)\n\t\t    ret = KRB5KRB_AP_ERR_BAD_INTEGRITY;\n\t    }\n\t    else {\n\t\tret = krb5_verify_checksum(context,\n\t\t\t\t\t   crypto,\n\t\t\t\t\t   KRB5_KU_OTHER_CKSUM,\n\t\t\t\t\t   datack.data,\n\t\t\t\t\t   datack.length,\n\t\t\t\t\t   &self.cksum);\n\t    }\n\t    krb5_data_free(&datack);\n\t    krb5_crypto_destroy(context, crypto);\n\t    if (ret) {\n\t\tconst char *msg = krb5_get_error_message(context, ret);\n\t\tfree_PA_S4U2Self(&self);\n                _kdc_audit_addreason((kdc_request_t)priv,\n                                     \"S4U2Self checksum failed\");\n\t\tkdc_log(context, config, 4,\n\t\t\t\"krb5_verify_checksum failed for S4U2Self: %s\", msg);\n\t\tkrb5_free_error_message(context, msg);\n\t\tgoto out;\n\t    }\n\n\t    ret = _krb5_principalname2krb5_principal(context,\n\t\t\t\t\t\t     &tp,\n\t\t\t\t\t\t     self.name,\n\t\t\t\t\t\t     self.realm);\n\t    free_PA_S4U2Self(&self);\n\t    if (ret)\n\t\tgoto out;\n\n\t    ret = krb5_unparse_name(context, tp, &tpn);\n\t    if (ret)\n\t\tgoto out;\n\n            /*\n             * Note no HDB_F_SYNTHETIC_OK -- impersonating non-existent clients\n             * is probably not desirable!\n             */\n\t    ret = _kdc_db_fetch(context, config, tp, HDB_F_GET_CLIENT | flags,\n\t\t\t\tNULL, &s4u2self_impersonated_clientdb,\n\t\t\t\t&s4u2self_impersonated_client);\n\t    if (ret) {\n\t\tconst char *msg;\n\n\t\t/*\n\t\t * If the client belongs to the same realm as our krbtgt, it\n\t\t * should exist in the local database.\n\t\t *\n\t\t */\n\n\t\tif (ret == HDB_ERR_NOENTRY)\n\t\t    ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\t\tmsg = krb5_get_error_message(context, ret);\n                _kdc_audit_addreason((kdc_request_t)priv,\n                                     \"S4U2Self principal to impersonate not found\");\n\t\tkdc_log(context, config, 2,\n\t\t\t\"S4U2Self principal to impersonate %s not found in database: %s\",\n\t\t\ttpn, msg);\n\t\tkrb5_free_error_message(context, msg);\n\t\tgoto out;\n\t    }\n\n\t    /* Ignore require_pwchange and pw_end attributes (as Windows does),\n\t     * since S4U2Self is not password authentication. */\n\t    s4u2self_impersonated_client->entry.flags.require_pwchange = FALSE;\n\t    free(s4u2self_impersonated_client->entry.pw_end);\n\t    s4u2self_impersonated_client->entry.pw_end = NULL;\n\n\t    imp_req = *priv;\n\t    imp_req.client = s4u2self_impersonated_client;\n\t    imp_req.client_princ = tp;\n\n\t    ret = kdc_check_flags(&imp_req, FALSE);\n\t    if (ret)\n\t\tgoto out; /* kdc_check_flags() calls _kdc_audit_addreason() */\n\n\t    /* If we were about to put a PAC into the ticket, we better fix it to be the right PAC */\n\t    if(rspac.data) {\n\t\tkrb5_pac p = NULL;\n\t\tkrb5_data_free(&rspac);\n\t\tret = _kdc_pac_generate(context, s4u2self_impersonated_client, &p);\n\t\tif (ret) {\n                    _kdc_audit_addreason((kdc_request_t)priv,\n                                         \"KRB5SignedPath missing\");\n\t\t    kdc_log(context, config, 4, \"PAC generation failed for -- %s\",\n\t\t\t    tpn);\n\t\t    goto out;\n\t\t}\n\t\tif (p != NULL) {\n\t\t    ret = _krb5_pac_sign(context, p, ticket->ticket.authtime,\n\t\t\t\t\t s4u2self_impersonated_client->entry.principal,\n\t\t\t\t\t ekey, &tkey_sign->key,\n\t\t\t\t\t &rspac);\n\t\t    krb5_pac_free(context, p);\n\t\t    if (ret) {\n\t\t\tkdc_log(context, config, 4, \"PAC signing failed for -- %s\",\n\t\t\t\ttpn);\n\t\t\tgoto out;\n\t\t    }\n\t\t}\n\t    }\n\n\t    /*\n\t     * Check that service doing the impersonating is\n\t     * requesting a ticket to it-self.\n\t     */\n\t    ret = check_s4u2self(context, config, clientdb, client, sp);\n\t    if (ret) {\n\t\tkdc_log(context, config, 4, \"S4U2Self: %s is not allowed \"\n\t\t\t\"to impersonate to service \"\n\t\t\t\"(tried for user %s to service %s)\",\n\t\t\tcpn, tpn, spn);\n\t\tgoto out;\n\t    }\n\n\t    /*\n\t     * If the service isn't trusted for authentication to\n\t     * delegation or if the impersonate client is disallowed\n\t     * forwardable, remove the forwardable flag.\n\t     */\n\n\t    if (client->entry.flags.trusted_for_delegation &&\n\t\ts4u2self_impersonated_client->entry.flags.forwardable) {\n\t\tstr = \"[forwardable]\";\n\t    } else {\n\t\tb->kdc_options.forwardable = 0;\n\t\tstr = \"\";\n\t    }\n\t    kdc_log(context, config, 4, \"s4u2self %s impersonating %s to \"\n\t\t    \"service %s %s\", cpn, tpn, spn, str);\n\t}\n    }\n\n    /*\n     * Constrained delegation\n     */\n\n    if (client != NULL\n\t&& b->additional_tickets != NULL\n\t&& b->additional_tickets->len != 0\n\t&& b->kdc_options.cname_in_addl_tkt\n\t&& b->kdc_options.enc_tkt_in_skey == 0)\n    {\n\tint ad_signedpath = 0;\n\tKey *clientkey;\n\tTicket *t;\n\n\t/*\n\t * Require that the KDC have issued the service's krbtgt (not\n\t * self-issued ticket with kimpersonate(1).\n\t */\n\tif (!signedpath) {\n\t    ret = KRB5KDC_ERR_BADOPTION;\n            _kdc_audit_addreason((kdc_request_t)priv, \"KRB5SignedPath missing\");\n\t    kdc_log(context, config, 4,\n\t\t    \"Constrained delegation done on service ticket %s/%s\",\n\t\t    cpn, spn);\n\t    goto out;\n\t}\n\n\tt = &b->additional_tickets->val[0];\n\n\tret = hdb_enctype2key(context, &client->entry,\n\t\t\t      hdb_kvno2keys(context, &client->entry,\n\t\t\t\t\t    t->enc_part.kvno ? * t->enc_part.kvno : 0),\n\t\t\t      t->enc_part.etype, &clientkey);\n\tif(ret){\n\t    ret = KRB5KDC_ERR_ETYPE_NOSUPP; /* XXX */\n\t    goto out;\n\t}\n\n\tret = krb5_decrypt_ticket(context, t, &clientkey->key, &adtkt, 0);\n\tif (ret) {\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"Failed to decrypt constrained delegation ticket\");\n\t    kdc_log(context, config, 4,\n\t\t    \"failed to decrypt ticket for \"\n\t\t    \"constrained delegation from %s to %s \", cpn, spn);\n\t    goto out;\n\t}\n\n\tret = _krb5_principalname2krb5_principal(context,\n\t\t\t\t\t\t &tp,\n\t\t\t\t\t\t adtkt.cname,\n\t\t\t\t\t\t adtkt.crealm);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_unparse_name(context, tp, &tpn);\n\tif (ret)\n\t    goto out;\n\n        _kdc_audit_addkv((kdc_request_t)priv, 0, \"impersonatee\", \"%s\", tpn);\n\n\tret = _krb5_principalname2krb5_principal(context,\n\t\t\t\t\t\t &dp,\n\t\t\t\t\t\t t->sname,\n\t\t\t\t\t\t t->realm);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_unparse_name(context, dp, &dpn);\n\tif (ret)\n\t    goto out;\n\n\t/* check that ticket is valid */\n\tif (adtkt.flags.forwardable == 0) {\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"Missing forwardable flag on ticket for constrained delegation\");\n\t    kdc_log(context, config, 4,\n\t\t    \"Missing forwardable flag on ticket for \"\n\t\t    \"constrained delegation from %s (%s) as %s to %s \",\n\t\t    cpn, dpn, tpn, spn);\n\t    ret = KRB5KDC_ERR_BADOPTION;\n\t    goto out;\n\t}\n\n\tret = check_constrained_delegation(context, config, clientdb,\n\t\t\t\t\t   client, server, sp);\n\tif (ret) {\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"Constrained delegation not allowed\");\n\t    kdc_log(context, config, 4,\n\t\t    \"constrained delegation from %s (%s) as %s to %s not allowed\",\n\t\t    cpn, dpn, tpn, spn);\n\t    goto out;\n\t}\n\n\tret = verify_flags(context, config, &adtkt, tpn);\n\tif (ret) {\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"Constrained delegation ticket expired or invalid\");\n\t    goto out;\n\t}\n\n\tkrb5_data_free(&rspac);\n\n\t/*\n\t * generate the PAC for the user.\n\t *\n\t * TODO: pass in t->sname and t->realm and build\n\t * a S4U_DELEGATION_INFO blob to the PAC.\n\t */\n\tret = check_PAC(context, config, tp, dp,\n\t\t\tclient, server, krbtgt,\n\t\t\t&clientkey->key,\n\t\t\tekey, &tkey_sign->key,\n\t\t\t&adtkt, &rspac, &ad_signedpath);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"Constrained delegation ticket PAC check failed\");\n\t    kdc_log(context, config, 4,\n\t\t    \"Verify delegated PAC failed to %s for client\"\n\t\t    \"%s (%s) as %s from %s with %s\",\n\t\t    spn, cpn, dpn, tpn, from, msg);\n\t    krb5_free_error_message(context, msg);\n\t    goto out;\n\t}\n\n\t/*\n\t * Check that the KDC issued the user's ticket.\n\t */\n\tret = check_KRB5SignedPath(context,\n\t\t\t\t   config,\n\t\t\t\t   krbtgt,\n\t\t\t\t   cp,\n\t\t\t\t   &adtkt,\n\t\t\t\t   NULL,\n\t\t\t\t   &ad_signedpath);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    kdc_log(context, config, 4,\n\t\t    \"KRB5SignedPath check from service %s failed \"\n\t\t    \"for delegation to %s for client %s (%s)\"\n\t\t    \"from %s failed with %s\",\n\t\t    spn, tpn, dpn, cpn, from, msg);\n\t    krb5_free_error_message(context, msg);\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"KRB5SignedPath check failed\");\n\t    goto out;\n\t}\n\n\tif (!ad_signedpath) {\n\t    ret = KRB5KDC_ERR_BADOPTION;\n\t    kdc_log(context, config, 4,\n\t\t    \"Ticket not signed with PAC nor SignedPath service %s failed \"\n\t\t    \"for delegation to %s for client %s (%s)\"\n\t\t    \"from %s\",\n\t\t    spn, tpn, dpn, cpn, from);\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"Constrained delegation ticket not signed\");\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 4, \"constrained delegation for %s \"\n\t\t\"from %s (%s) to %s\", tpn, cpn, dpn, spn);\n    }\n\n    /*\n     * Check flags\n     */\n\n    ret = kdc_check_flags(priv, FALSE);\n    if(ret)\n\tgoto out;\n\n    if((b->kdc_options.validate || b->kdc_options.renew) &&\n       !krb5_principal_compare(context,\n\t\t\t       krbtgt->entry.principal,\n\t\t\t       server->entry.principal)){\n        _kdc_audit_addreason((kdc_request_t)priv, \"Inconsistent request\");\n\tkdc_log(context, config, 4, \"Inconsistent request.\");\n\tret = KRB5KDC_ERR_SERVER_NOMATCH;\n\tgoto out;\n    }\n\n    /* check for valid set of addresses */\n    if (!_kdc_check_addresses(priv, tgt->caddr, from_addr)) {\n        if (config->check_ticket_addresses) {\n            ret = KRB5KRB_AP_ERR_BADADDR;\n            _kdc_audit_addkv((kdc_request_t)priv, 0, \"wrongaddr\", \"yes\");\n            kdc_log(context, config, 4, \"Request from wrong address\");\n            _kdc_audit_addreason((kdc_request_t)priv, \"Request from wrong address\");\n            goto out;\n        } else if (config->warn_ticket_addresses) {\n            _kdc_audit_addkv((kdc_request_t)priv, 0, \"wrongaddr\", \"yes\");\n        }\n    }\n\n    /* check local and per-principal anonymous ticket issuance policy */\n    if (is_anon_tgs_request_p(b, tgt)) {\n\tret = _kdc_check_anon_policy(priv);\n\tif (ret)\n\t    goto out;\n    }\n\n    /*\n     * If this is an referral, add server referral data to the\n     * auth_data reply .\n     */\n    if (ref_realm) {\n\tPA_DATA pa;\n\tkrb5_crypto crypto;\n\n\tkdc_log(context, config, 3,\n\t\t\"Adding server referral to %s\", ref_realm);\n\n\tret = krb5_crypto_init(context, &sessionkey, 0, &crypto);\n\tif (ret)\n\t    goto out;\n\n\tret = build_server_referral(context, config, crypto, ref_realm,\n\t\t\t\t    NULL, s, &pa.padata_value);\n\tkrb5_crypto_destroy(context, crypto);\n\tif (ret) {\n            _kdc_audit_addreason((kdc_request_t)priv, \"Referral build failed\");\n\t    kdc_log(context, config, 4,\n\t\t    \"Failed building server referral\");\n\t    goto out;\n\t}\n\tpa.padata_type = KRB5_PADATA_SERVER_REFERRAL;\n\n\tret = add_METHOD_DATA(&enc_pa_data, &pa);\n\tkrb5_data_free(&pa.padata_value);\n\tif (ret) {\n\t    kdc_log(context, config, 4,\n\t\t    \"Add server referral METHOD-DATA failed\");\n\t    goto out;\n\t}\n    }\n\n    /*\n     *\n     */\n\n    ret = tgs_make_reply(priv,\n\t\t\t tp,\n\t\t\t tgt,\n\t\t\t replykey,\n\t\t\t rk_is_subkey,\n\t\t\t ekey,\n\t\t\t &sessionkey,\n\t\t\t kvno,\n\t\t\t *auth_data,\n\t\t\t server,\n\t\t\t rsp,\n\t\t\t client,\n\t\t\t cp,\n                         tgt_realm,\n\t\t\t krbtgt_out,\n\t\t\t tkey_sign->key.keytype,\n\t\t\t spp,\n\t\t\t &rspac,\n\t\t\t &enc_pa_data);\n\nout:\n    if (tpn != cpn)\n\t    free(tpn);\n    free(dpn);\n    free(krbtgt_out_n);\n    _krb5_free_capath(context, capath);\n\n    krb5_data_free(&rspac);\n    krb5_free_keyblock_contents(context, &sessionkey);\n    if(krbtgt_out)\n\t_kdc_free_ent(context, krbtgt_out);\n    if(server)\n\t_kdc_free_ent(context, server);\n    if(client)\n\t_kdc_free_ent(context, client);\n    if(s4u2self_impersonated_client)\n\t_kdc_free_ent(context, s4u2self_impersonated_client);\n\n    if (tp && tp != cp)\n\tkrb5_free_principal(context, tp);\n    krb5_free_principal(context, cp);\n    krb5_free_principal(context, dp);\n    krb5_free_principal(context, sp);\n    krb5_free_principal(context, krbtgt_out_principal);\n    free(ref_realm);\n    free_METHOD_DATA(&enc_pa_data);\n\n    free_EncTicketPart(&adtkt);\n\n    return ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 174,
    "critical_vars": [
      "s",
      "aString",
      "bufsize"
    ],
    "function": "DU_getStringDOElement",
    "filename": "dcmtk/CVE-2021-41689/CVE-2021-41689_CWE-476_5c14bf53fb42ceca12bbcc0016e8704b1580920d_diutil.cc.diff",
    "function_code": "DU_getStringDOElement(DcmItem *obj, DcmTagKey t, char *s, size_t bufsize)\n{\n    DcmByteString *elem;\n    DcmStack stack;\n    OFCondition ec = EC_Normal;\n    char* aString;\n\n    ec = obj->search(t, stack);\n    elem = (DcmByteString*) stack.top();\n    if (ec == EC_Normal && elem != NULL) {\n        if (elem->getLength() == 0) {\n            s[0] = '\\0';\n        } else {\n            ec =  elem->getString(aString);\n            OFStandard::strlcpy(s, aString, bufsize);\n        }\n    }\n    return (ec == EC_Normal);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 174,
    "critical_vars": [
      "EC_Normal",
      "ec"
    ],
    "function": "DU_getStringDOElement",
    "filename": "dcmtk/CVE-2021-41689/CVE-2021-41689_CWE-476_5c14bf53fb42ceca12bbcc0016e8704b1580920d_diutil.cc.diff",
    "function_code": "DU_getStringDOElement(DcmItem *obj, DcmTagKey t, char *s, size_t bufsize)\n{\n    DcmByteString *elem;\n    DcmStack stack;\n    OFCondition ec = EC_Normal;\n    char* aString;\n\n    ec = obj->search(t, stack);\n    elem = (DcmByteString*) stack.top();\n    if (ec == EC_Normal && elem != NULL) {\n        if (elem->getLength() == 0) {\n            s[0] = '\\0';\n        } else {\n            ec =  elem->getString(aString);\n            if (ec == EC_Normal)\n                OFStandard::strlcpy(s, aString, bufsize);\n        }\n    }\n    return (ec == EC_Normal);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 927,
    "critical_vars": [
      "json"
    ],
    "function": "parse_json",
    "filename": "open5gs/CVE-2021-44108/CVE-2021-44108_CWE-476_d919b2744cd05abae043490f0a3dd1946c1ccb8c_message.c.diff",
    "function_code": "static int parse_json(ogs_sbi_message_t *message,\n        char *content_type, char *json)\n{\n    int rv = OGS_OK;\n    cJSON *item = NULL;\n\n    ogs_assert(message);\n\n    if (!json)\n        return OGS_OK;\n\n    if (!content_type) {\n        ogs_error(\"No Content-type\");\n        return OGS_ERROR;\n    }\n\n    ogs_log_print(OGS_LOG_TRACE, \"%s\", json);\n    item = cJSON_Parse(json);\n    if (!item) {\n        ogs_error(\"JSON parse error [%s]\", json);\n        return OGS_ERROR;\n    }\n\n    if (content_type &&\n        !strncmp(content_type, OGS_SBI_CONTENT_PROBLEM_TYPE,\n            strlen(OGS_SBI_CONTENT_PROBLEM_TYPE))) {\n        message->ProblemDetails = OpenAPI_problem_details_parseFromJSON(item);\n    } else if (content_type &&\n                !strncmp(content_type, OGS_SBI_CONTENT_PATCH_TYPE,\n                    strlen(OGS_SBI_CONTENT_PATCH_TYPE))) {\n        if (item) {\n            OpenAPI_patch_item_t *patch_item = NULL;\n            cJSON *patchJSON = NULL;\n            message->PatchItemList = OpenAPI_list_create();\n            cJSON_ArrayForEach(patchJSON, item) {\n                if (!cJSON_IsObject(patchJSON)) {\n                    rv = OGS_ERROR;\n                    ogs_error(\"Unknown JSON\");\n                    goto cleanup;\n                }\n\n                patch_item = OpenAPI_patch_item_parseFromJSON(patchJSON);\n                OpenAPI_list_add(message->PatchItemList, patch_item);\n            }\n        }\n    } else {\n        SWITCH(message->h.service.name)\n        CASE(OGS_SBI_SERVICE_NAME_NNRF_NFM)\n\n            SWITCH(message->h.resource.component[0])\n            CASE(OGS_SBI_RESOURCE_NAME_NF_INSTANCES)\n                message->NFProfile =\n                    OpenAPI_nf_profile_parseFromJSON(item);\n                if (!message->NFProfile) {\n                    rv = OGS_ERROR;\n                    ogs_error(\"JSON parse error\");\n                }\n                break;\n\n            CASE(OGS_SBI_RESOURCE_NAME_SUBSCRIPTIONS)\n                message->SubscriptionData =\n                    OpenAPI_subscription_data_parseFromJSON(item);\n                if (!message->SubscriptionData) {\n                    rv = OGS_ERROR;\n                    ogs_error(\"JSON parse error\");\n                }\n                break;\n\n            CASE(OGS_SBI_RESOURCE_NAME_NF_STATUS_NOTIFY)\n                message->NotificationData =\n                    OpenAPI_notification_data_parseFromJSON(item);\n                if (!message->NotificationData) {\n                    rv = OGS_ERROR;\n                    ogs_error(\"JSON parse error\");\n                }\n                break;\n\n            DEFAULT\n                rv = OGS_ERROR;\n                ogs_error(\"Unknown resource name [%s]\",\n                        message->h.resource.component[0]);\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NNRF_DISC)\n            SWITCH(message->h.resource.component[0])\n            CASE(OGS_SBI_RESOURCE_NAME_NF_INSTANCES)\n                message->SearchResult =\n                    OpenAPI_search_result_parseFromJSON(item);\n                if (!message->SearchResult) {\n                    rv = OGS_ERROR;\n                    ogs_error(\"JSON parse error\");\n                }\n                break;\n\n            DEFAULT\n                rv = OGS_ERROR;\n                ogs_error(\"Unknown resource name [%s]\",\n                        message->h.resource.component[0]);\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NAUSF_AUTH)\n            SWITCH(message->h.resource.component[0])\n            CASE(OGS_SBI_RESOURCE_NAME_UE_AUTHENTICATIONS)\n                SWITCH(message->h.method)\n                CASE(OGS_SBI_HTTP_METHOD_POST)\n                    if (message->res_status == 0) {\n                        message->AuthenticationInfo =\n                            OpenAPI_authentication_info_parseFromJSON(item);\n                        if (!message->AuthenticationInfo) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    } else if (message->res_status ==\n                            OGS_SBI_HTTP_STATUS_CREATED) {\n                        message->UeAuthenticationCtx =\n                        OpenAPI_ue_authentication_ctx_parseFromJSON(item);\n                        if (!message->UeAuthenticationCtx) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    }\n                    break;\n                CASE(OGS_SBI_HTTP_METHOD_PUT)\n                    if (message->res_status == 0) {\n                        message->ConfirmationData =\n                            OpenAPI_confirmation_data_parseFromJSON(item);\n                        if (!message->ConfirmationData) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    } else if (message->res_status == OGS_SBI_HTTP_STATUS_OK) {\n                        message->ConfirmationDataResponse =\n                            OpenAPI_confirmation_data_response_parseFromJSON(\n                                    item);\n                        if (!message->ConfirmationDataResponse) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    }\n                    break;\n                DEFAULT\n                    rv = OGS_ERROR;\n                    ogs_error(\"Unknown method [%s]\", message->h.method);\n                END\n                break;\n\n            DEFAULT\n                rv = OGS_ERROR;\n                ogs_error(\"Unknown resource name [%s]\",\n                        message->h.resource.component[0]);\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NUDM_UEAU)\n            SWITCH(message->h.resource.component[1])\n            CASE(OGS_SBI_RESOURCE_NAME_SECURITY_INFORMATION)\n                SWITCH(message->h.resource.component[2])\n                CASE(OGS_SBI_RESOURCE_NAME_GENERATE_AUTH_DATA)\n                    if (message->res_status == 0) {\n                        message->AuthenticationInfoRequest =\n                        OpenAPI_authentication_info_request_parseFromJSON(\n                                item);\n                        if (!message->AuthenticationInfoRequest) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    } else if (message->res_status == OGS_SBI_HTTP_STATUS_OK) {\n                        message->AuthenticationInfoResult =\n                        OpenAPI_authentication_info_result_parseFromJSON(\n                                item);\n                        if (!message->AuthenticationInfoResult) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    }\n                    break;\n                DEFAULT\n                    rv = OGS_ERROR;\n                    ogs_error(\"Unknown resource name [%s]\",\n                            message->h.resource.component[2]);\n                END\n                break;\n\n            CASE(OGS_SBI_RESOURCE_NAME_AUTH_EVENTS)\n                message->AuthEvent = OpenAPI_auth_event_parseFromJSON(item);\n                if (!message->AuthEvent) {\n                    rv = OGS_ERROR;\n                    ogs_error(\"JSON parse error\");\n                }\n                break;\n\n            DEFAULT\n                rv = OGS_ERROR;\n                ogs_error(\"Unknown resource name [%s]\",\n                        message->h.resource.component[1]);\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NUDM_UECM)\n            SWITCH(message->h.resource.component[1])\n            CASE(OGS_SBI_RESOURCE_NAME_REGISTRATIONS)\n                SWITCH(message->h.resource.component[2])\n                CASE(OGS_SBI_RESOURCE_NAME_AMF_3GPP_ACCESS)\n                    message->Amf3GppAccessRegistration =\n                        OpenAPI_amf3_gpp_access_registration_parseFromJSON(\n                                item);\n                    if (!message->Amf3GppAccessRegistration) {\n                        rv = OGS_ERROR;\n                        ogs_error(\"JSON parse error\");\n                    }\n                    break;\n                DEFAULT\n                    rv = OGS_ERROR;\n                    ogs_error(\"Unknown resource name [%s]\",\n                            message->h.resource.component[2]);\n                END\n                break;\n\n            DEFAULT\n                rv = OGS_ERROR;\n                ogs_error(\"Unknown resource name [%s]\",\n                        message->h.resource.component[1]);\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NUDM_SDM)\n            SWITCH(message->h.resource.component[1])\n            CASE(OGS_SBI_RESOURCE_NAME_AM_DATA)\n                message->AccessAndMobilitySubscriptionData =\n                    OpenAPI_access_and_mobility_subscription_data_parseFromJSON(\n                            item);\n                if (!message->AccessAndMobilitySubscriptionData) {\n                    rv = OGS_ERROR;\n                    ogs_error(\"JSON parse error\");\n                }\n                break;\n\n            CASE(OGS_SBI_RESOURCE_NAME_SMF_SELECT_DATA)\n                message->SmfSelectionSubscriptionData =\n                    OpenAPI_smf_selection_subscription_data_parseFromJSON(item);\n                if (!message->SmfSelectionSubscriptionData) {\n                    rv = OGS_ERROR;\n                    ogs_error(\"JSON parse error\");\n                }\n                break;\n\n            CASE(OGS_SBI_RESOURCE_NAME_UE_CONTEXT_IN_SMF_DATA)\n                message->UeContextInSmfData =\n                    OpenAPI_ue_context_in_smf_data_parseFromJSON(item);\n                if (!message->UeContextInSmfData) {\n                    rv = OGS_ERROR;\n                    ogs_error(\"JSON parse error\");\n                }\n                break;\n\n            CASE(OGS_SBI_RESOURCE_NAME_SM_DATA)\n                message->SessionManagementSubscriptionData =\n                    OpenAPI_session_management_subscription_data_parseFromJSON(\n                            item);\n                if (!message->SessionManagementSubscriptionData) {\n                    rv = OGS_ERROR;\n                    ogs_error(\"JSON parse error\");\n                }\n                break;\n\n            DEFAULT\n                rv = OGS_ERROR;\n                ogs_error(\"Unknown resource name [%s]\",\n                        message->h.resource.component[1]);\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NUDR_DR)\n            SWITCH(message->h.resource.component[0])\n            CASE(OGS_SBI_RESOURCE_NAME_SUBSCRIPTION_DATA)\n                SWITCH(message->h.resource.component[2])\n                CASE(OGS_SBI_RESOURCE_NAME_AUTHENTICATION_DATA)\n                    SWITCH(message->h.resource.component[3])\n                    CASE(OGS_SBI_RESOURCE_NAME_AUTHENTICATION_SUBSCRIPTION)\n                        if (message->res_status == OGS_SBI_HTTP_STATUS_OK) {\n                            message->AuthenticationSubscription =\n                                OpenAPI_authentication_subscription_parseFromJSON(item);\n                            if (!message->AuthenticationSubscription) {\n                                rv = OGS_ERROR;\n                                ogs_error(\"JSON parse error\");\n                            }\n                        }\n                        break;\n                    CASE(OGS_SBI_RESOURCE_NAME_AUTHENTICATION_STATUS)\n                        message->AuthEvent =\n                            OpenAPI_auth_event_parseFromJSON(item);\n                        if (!message->AuthEvent) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                        break;\n                    DEFAULT\n                        rv = OGS_ERROR;\n                        ogs_error(\"Unknown resource name [%s]\",\n                                message->h.resource.component[3]);\n                    END\n                    break;\n\n                CASE(OGS_SBI_RESOURCE_NAME_CONTEXT_DATA)\n                    message->Amf3GppAccessRegistration =\n                        OpenAPI_amf3_gpp_access_registration_parseFromJSON(\n                                item);\n                    if (!message->Amf3GppAccessRegistration) {\n                        rv = OGS_ERROR;\n                        ogs_error(\"JSON parse error\");\n                    }\n                    break;\n\n                DEFAULT\n                    SWITCH(message->h.resource.component[3])\n                    CASE(OGS_SBI_RESOURCE_NAME_PROVISIONED_DATA)\n                        SWITCH(message->h.resource.component[4])\n                        CASE(OGS_SBI_RESOURCE_NAME_AM_DATA)\n                            message->AccessAndMobilitySubscriptionData =\n                                OpenAPI_access_and_mobility_subscription_data_parseFromJSON(item);\n                            if (!message->AccessAndMobilitySubscriptionData) {\n                                rv = OGS_ERROR;\n                                ogs_error(\"JSON parse error\");\n                            }\n                            break;\n\n                        CASE(OGS_SBI_RESOURCE_NAME_SMF_SELECTION_SUBSCRIPTION_DATA)\n                            message->SmfSelectionSubscriptionData =\n                                OpenAPI_smf_selection_subscription_data_parseFromJSON(item);\n                            if (!message->SmfSelectionSubscriptionData) {\n                                rv = OGS_ERROR;\n                                ogs_error(\"JSON parse error\");\n                            }\n                            break;\n\n                        CASE(OGS_SBI_RESOURCE_NAME_UE_CONTEXT_IN_SMF_DATA)\n                            message->UeContextInSmfData =\n                                OpenAPI_ue_context_in_smf_data_parseFromJSON(\n                                        item);\n                            if (!message->UeContextInSmfData) {\n                                rv = OGS_ERROR;\n                                ogs_error(\"JSON parse error\");\n                            }\n                            break;\n\n                        CASE(OGS_SBI_RESOURCE_NAME_SM_DATA)\n                            message->SessionManagementSubscriptionData =\n                                OpenAPI_session_management_subscription_data_parseFromJSON(item);\n                            if (!message->SessionManagementSubscriptionData) {\n                                rv = OGS_ERROR;\n                                ogs_error(\"JSON parse error\");\n                            }\n                            break;\n\n                        DEFAULT\n                            rv = OGS_ERROR;\n                            ogs_error(\"Unknown resource name [%s]\",\n                                    message->h.resource.component[4]);\n                        END\n                        break;\n\n                    DEFAULT\n                        rv = OGS_ERROR;\n                        ogs_error(\"Unknown resource name [%s]\",\n                                message->h.resource.component[3]);\n                    END\n                END\n                break;\n\n            CASE(OGS_SBI_RESOURCE_NAME_POLICY_DATA)\n                SWITCH(message->h.resource.component[1])\n                CASE(OGS_SBI_RESOURCE_NAME_UES)\n                    SWITCH(message->h.resource.component[3])\n                    CASE(OGS_SBI_RESOURCE_NAME_AM_DATA)\n\n                        message->AmPolicyData =\n                            OpenAPI_am_policy_data_parseFromJSON(item);\n                        if (!message->AmPolicyData) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                        break;\n\n                    CASE(OGS_SBI_RESOURCE_NAME_SM_DATA)\n\n                        message->SmPolicyData =\n                            OpenAPI_sm_policy_data_parseFromJSON(item);\n                        if (!message->SmPolicyData) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                        break;\n\n                    DEFAULT\n                        rv = OGS_ERROR;\n                        ogs_error(\"Unknown resource name [%s]\",\n                                message->h.resource.component[3]);\n                    END\n                    break;\n\n                DEFAULT\n                    rv = OGS_ERROR;\n                    ogs_error(\"Unknown resource name [%s]\",\n                            message->h.resource.component[1]);\n                END\n                break;\n\n            DEFAULT\n                rv = OGS_ERROR;\n                ogs_error(\"Unknown resource name [%s]\",\n                        message->h.resource.component[0]);\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NSMF_PDUSESSION)\n            SWITCH(message->h.resource.component[0])\n            CASE(OGS_SBI_RESOURCE_NAME_SM_CONTEXTS)\n                SWITCH(message->h.resource.component[2])\n                CASE(OGS_SBI_RESOURCE_NAME_MODIFY)\n                    if (message->res_status == 0) {\n                        message->SmContextUpdateData =\n                            OpenAPI_sm_context_update_data_parseFromJSON(item);\n                        if (!message->SmContextUpdateData) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    } else if (message->res_status == OGS_SBI_HTTP_STATUS_OK) {\n                        message->SmContextUpdatedData =\n                            OpenAPI_sm_context_updated_data_parseFromJSON(item);\n                        if (!message->SmContextUpdatedData) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    } else if (message->res_status ==\n                            OGS_SBI_HTTP_STATUS_BAD_REQUEST ||\n                                message->res_status ==\n                                    OGS_SBI_HTTP_STATUS_FORBIDDEN ||\n                                message->res_status ==\n                                    OGS_SBI_HTTP_STATUS_NOT_FOUND ||\n                                message->res_status ==\n                                    OGS_SBI_HTTP_STATUS_INTERNAL_SERVER_ERROR ||\n                                message->res_status ==\n                                    OGS_SBI_HTTP_STATUS_SERVICE_UNAVAILABLE ||\n                                message->res_status ==\n                                    OGS_SBI_HTTP_STATUS_GATEWAY_TIMEOUT) {\n                        message->SmContextUpdateError =\n                            OpenAPI_sm_context_update_error_parseFromJSON(item);\n                        if (!message->SmContextUpdateError) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    }\n                    break;\n                CASE(OGS_SBI_RESOURCE_NAME_RELEASE)\n                    if (message->res_status == 0) {\n                        message->SmContextReleaseData =\n                            OpenAPI_sm_context_release_data_parseFromJSON(item);\n                        if (!message->SmContextReleaseData) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    } else if (message->res_status ==\n                            OGS_SBI_HTTP_STATUS_NO_CONTENT) {\n                    } else if (message->res_status == OGS_SBI_HTTP_STATUS_OK) {\n                        message->SmContextReleasedData =\n                            OpenAPI_sm_context_released_data_parseFromJSON(\n                                    item);\n                        if (!message->SmContextReleasedData) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    }\n                    break;\n                DEFAULT\n                    if (message->res_status == 0) {\n                        message->SmContextCreateData =\n                            OpenAPI_sm_context_create_data_parseFromJSON(item);\n                        if (!message->SmContextCreateData) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    } else if (message->res_status ==\n                            OGS_SBI_HTTP_STATUS_CREATED) {\n                        message->SmContextCreatedData =\n                            OpenAPI_sm_context_created_data_parseFromJSON(item);\n                        if (!message->SmContextCreatedData) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    } else if (message->res_status ==\n                            OGS_SBI_HTTP_STATUS_BAD_REQUEST ||\n                                message->res_status ==\n                                    OGS_SBI_HTTP_STATUS_FORBIDDEN ||\n                                message->res_status ==\n                                    OGS_SBI_HTTP_STATUS_NOT_FOUND ||\n                                message->res_status ==\n                                    OGS_SBI_HTTP_STATUS_INTERNAL_SERVER_ERROR ||\n                                message->res_status ==\n                                    OGS_SBI_HTTP_STATUS_SERVICE_UNAVAILABLE ||\n                                message->res_status ==\n                                    OGS_SBI_HTTP_STATUS_GATEWAY_TIMEOUT) {\n                        message->SmContextCreateError =\n                            OpenAPI_sm_context_create_error_parseFromJSON(item);\n                        if (!message->SmContextCreateError) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    }\n                END\n                break;\n\n            DEFAULT\n                rv = OGS_ERROR;\n                ogs_error(\"Unknown resource name [%s]\",\n                        message->h.resource.component[0]);\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NAMF_COMM)\n            SWITCH(message->h.resource.component[0])\n            CASE(OGS_SBI_RESOURCE_NAME_UE_CONTEXTS)\n                SWITCH(message->h.resource.component[2])\n                CASE(OGS_SBI_RESOURCE_NAME_N1_N2_MESSAGES)\n                    if (message->res_status == 0) {\n                        message->N1N2MessageTransferReqData =\n                            OpenAPI_n1_n2_message_transfer_req_data_parseFromJSON(item);\n                        if (!message->N1N2MessageTransferReqData) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    } else if (message->res_status ==\n                                OGS_SBI_HTTP_STATUS_OK ||\n                                message->res_status ==\n                                    OGS_SBI_HTTP_STATUS_ACCEPTED) {\n                        message->N1N2MessageTransferRspData =\n                            OpenAPI_n1_n2_message_transfer_rsp_data_parseFromJSON(item);\n                        if (!message->N1N2MessageTransferRspData) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    }\n                    break;\n\n                DEFAULT\n                    rv = OGS_ERROR;\n                    ogs_error(\"Unknown resource name [%s]\",\n                            message->h.resource.component[2]);\n                END\n                break;\n\n            DEFAULT\n                rv = OGS_ERROR;\n                ogs_error(\"Unknown resource name [%s]\",\n                        message->h.resource.component[0]);\n            END\n            break;\n        CASE(OGS_SBI_SERVICE_NAME_NPCF_AM_POLICY_CONTROL)\n            SWITCH(message->h.resource.component[0])\n            CASE(OGS_SBI_RESOURCE_NAME_POLICIES)\n                if (message->res_status == 0) {\n                    message->PolicyAssociationRequest =\n                        OpenAPI_policy_association_request_parseFromJSON(\n                                item);\n                    if (!message->PolicyAssociationRequest) {\n                        rv = OGS_ERROR;\n                        ogs_error(\"JSON parse error\");\n                    }\n                } else if (message->res_status == OGS_SBI_HTTP_STATUS_CREATED) {\n                    message->PolicyAssociation =\n                        OpenAPI_policy_association_parseFromJSON(item);\n                    if (!message->PolicyAssociation) {\n                        rv = OGS_ERROR;\n                        ogs_error(\"JSON parse error\");\n                    }\n                }\n                break;\n\n            DEFAULT\n                rv = OGS_ERROR;\n                ogs_error(\"Unknown resource name [%s]\",\n                        message->h.resource.component[0]);\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NPCF_SMPOLICYCONTROL)\n            SWITCH(message->h.resource.component[0])\n            CASE(OGS_SBI_RESOURCE_NAME_SM_POLICIES)\n                if (!message->h.resource.component[1]) {\n                    if (message->res_status == 0) {\n                        message->SmPolicyContextData =\n                            OpenAPI_sm_policy_context_data_parseFromJSON(item);\n                        if (!message->SmPolicyContextData) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    } else if (message->res_status ==\n                            OGS_SBI_HTTP_STATUS_CREATED) {\n                        message->SmPolicyDecision =\n                            OpenAPI_sm_policy_decision_parseFromJSON(item);\n                        if (!message->SmPolicyDecision) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    }\n                } else {\n                    SWITCH(message->h.resource.component[2])\n                    CASE(OGS_SBI_RESOURCE_NAME_DELETE)\n                        if (message->res_status == 0) {\n                            message->SmPolicyDeleteData =\n                                OpenAPI_sm_policy_delete_data_parseFromJSON(\n                                        item);\n                            if (!message->SmPolicyDeleteData) {\n                                rv = OGS_ERROR;\n                                ogs_error(\"JSON parse error\");\n                            }\n                        }\n                        break;\n                    DEFAULT\n                        rv = OGS_ERROR;\n                        ogs_error(\"Unknown resource name [%s]\",\n                                message->h.resource.component[2]);\n                    END\n                    break;\n                }\n                break;\n\n            DEFAULT\n                rv = OGS_ERROR;\n                ogs_error(\"Unknown resource name [%s]\",\n                        message->h.resource.component[0]);\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NNSSF_NSSELECTION)\n            SWITCH(message->h.resource.component[0])\n            CASE(OGS_SBI_RESOURCE_NAME_NETWORK_SLICE_INFORMATION)\n                if (message->res_status == OGS_SBI_HTTP_STATUS_OK) {\n                    message->AuthorizedNetworkSliceInfo =\n                        OpenAPI_authorized_network_slice_info_parseFromJSON(\n                                item);\n                    if (!message->AuthorizedNetworkSliceInfo) {\n                        rv = OGS_ERROR;\n                        ogs_error(\"JSON parse error\");\n                    }\n                }\n                break;\n\n            DEFAULT\n                rv = OGS_ERROR;\n                ogs_error(\"Unknown resource name [%s]\",\n                        message->h.resource.component[0]);\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NBSF_MANAGEMENT)\n            SWITCH(message->h.resource.component[0])\n            CASE(OGS_SBI_RESOURCE_NAME_PCF_BINDINGS)\n                if (message->h.resource.component[1]) {\n                    SWITCH(message->h.method)\n                    CASE(OGS_SBI_HTTP_METHOD_PATCH)\n                        if (message->res_status == OGS_SBI_HTTP_STATUS_OK) {\n                            message->PcfBinding =\n                                OpenAPI_pcf_binding_parseFromJSON(item);\n                            if (!message->PcfBinding) {\n                                rv = OGS_ERROR;\n                                ogs_error(\"JSON parse error\");\n                            }\n                        }\n                        break;\n                    CASE(OGS_SBI_HTTP_METHOD_DELETE)\n                        break;\n                    DEFAULT\n                        rv = OGS_ERROR;\n                        ogs_error(\"Unknown method [%s]\", message->h.method);\n                    END\n                    break;\n                } else {\n                    SWITCH(message->h.method)\n                    CASE(OGS_SBI_HTTP_METHOD_POST)\n                        if (message->res_status == 0 ||\n                            message->res_status ==\n                                OGS_SBI_HTTP_STATUS_CREATED) {\n                            message->PcfBinding =\n                                OpenAPI_pcf_binding_parseFromJSON(item);\n                            if (!message->PcfBinding) {\n                                rv = OGS_ERROR;\n                                ogs_error(\"JSON parse error\");\n                            }\n                        }\n                        break;\n\n                    CASE(OGS_SBI_HTTP_METHOD_GET)\n                        if (message->res_status == OGS_SBI_HTTP_STATUS_OK) {\n                            message->PcfBinding =\n                                OpenAPI_pcf_binding_parseFromJSON(item);\n                            if (!message->PcfBinding) {\n                                rv = OGS_ERROR;\n                                ogs_error(\"JSON parse error\");\n                            }\n                        }\n                        break;\n                    DEFAULT\n                        rv = OGS_ERROR;\n                        ogs_error(\"Unknown method [%s]\", message->h.method);\n                    END\n                    break;\n                }\n\n            DEFAULT\n                rv = OGS_ERROR;\n                ogs_error(\"Unknown resource name [%s]\",\n                        message->h.resource.component[0]);\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NPCF_POLICYAUTHORIZATION)\n            SWITCH(message->h.resource.component[0])\n            CASE(OGS_SBI_RESOURCE_NAME_APP_SESSIONS)\n                if (message->h.resource.component[1]) {\n                    if (message->h.resource.component[2]) {\n                        SWITCH(message->h.resource.component[2])\n                        CASE(OGS_SBI_RESOURCE_NAME_DELETE)\n                            /* Nothing */\n                            break;\n                        DEFAULT\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        END\n                    } else {\n                        SWITCH(message->h.method)\n                        CASE(OGS_SBI_HTTP_METHOD_PATCH)\n                            message->AppSessionContextUpdateDataPatch =\n                                OpenAPI_app_session_context_update_data_patch_parseFromJSON(item);\n                            if (!message->AppSessionContextUpdateDataPatch) {\n                                rv = OGS_ERROR;\n                                ogs_error(\"JSON parse error\");\n                            }\n                            break;\n                        DEFAULT\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        END\n                    }\n                } else {\n                    SWITCH(message->h.method)\n                    CASE(OGS_SBI_HTTP_METHOD_POST)\n                        if (message->res_status == 0 ||\n                            message->res_status ==\n                                OGS_SBI_HTTP_STATUS_CREATED) {\n                            message->AppSessionContext =\n                                OpenAPI_app_session_context_parseFromJSON(item);\n                            if (!message->AppSessionContext) {\n                                rv = OGS_ERROR;\n                                ogs_error(\"JSON parse error\");\n                            }\n                        }\n                        break;\n                    DEFAULT\n                        rv = OGS_ERROR;\n                        ogs_error(\"Unknown method [%s]\", message->h.method);\n                    END\n                }\n                break;\n            DEFAULT\n                rv = OGS_ERROR;\n                ogs_error(\"Unknown resource name [%s]\",\n                        message->h.resource.component[0]);\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NAMF_CALLBACK)\n            SWITCH(message->h.resource.component[1])\n            CASE(OGS_SBI_RESOURCE_NAME_SM_CONTEXT_STATUS)\n                message->SmContextStatusNotification =\n                    OpenAPI_sm_context_status_notification_parseFromJSON(item);\n                if (!message->SmContextStatusNotification) {\n                    rv = OGS_ERROR;\n                    ogs_error(\"JSON parse error\");\n                }\n                break;\n\n            DEFAULT\n                rv = OGS_ERROR;\n                ogs_error(\"Unknown resource name [%s]\",\n                        message->h.resource.component[1]);\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NSMF_CALLBACK)\n            SWITCH(message->h.resource.component[0])\n            CASE(OGS_SBI_RESOURCE_NAME_N1_N2_FAILURE_NOTIFY)\n                message->N1N2MsgTxfrFailureNotification =\n                    OpenAPI_n1_n2_msg_txfr_failure_notification_parseFromJSON(\n                            item);\n                if (!message->N1N2MsgTxfrFailureNotification) {\n                    rv = OGS_ERROR;\n                    ogs_error(\"JSON parse error\");\n                }\n                break;\n\n            CASE(OGS_SBI_RESOURCE_NAME_SM_POLICY_NOTIFY)\n                SWITCH(message->h.resource.component[2])\n                CASE(OGS_SBI_RESOURCE_NAME_UPDATE)\n                    message->SmPolicyNotification =\n                        OpenAPI_sm_policy_notification_parseFromJSON(item);\n                    if (!message->SmPolicyNotification) {\n                        rv = OGS_ERROR;\n                        ogs_error(\"JSON parse error\");\n                    }\n                    break;\n                CASE(OGS_SBI_RESOURCE_NAME_TERMINATE)\n                    message->TerminationNotification =\n                        OpenAPI_termination_notification_parseFromJSON(item);\n                    if (!message->TerminationNotification) {\n                        rv = OGS_ERROR;\n                        ogs_error(\"JSON parse error\");\n                    }\n                    break;\n\n                DEFAULT\n                    rv = OGS_ERROR;\n                    ogs_error(\"Unknown resource name [%s]\",\n                            message->h.resource.component[2]);\n                END\n                break;\n\n            DEFAULT\n                rv = OGS_ERROR;\n                ogs_error(\"Unknown resource name [%s]\",\n                        message->h.resource.component[0]);\n            END\n            break;\n\n        DEFAULT\n            rv = OGS_ERROR;\n            ogs_error(\"Not implemented API name [%s]\",\n                    message->h.service.name);\n        END\n    }\n\ncleanup:\n\n    cJSON_Delete(item);\n    return rv;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1836,
    "critical_vars": [
      "data->num_of_part"
    ],
    "function": "on_header_value",
    "filename": "open5gs/CVE-2021-44108/CVE-2021-44108_CWE-476_d919b2744cd05abae043490f0a3dd1946c1ccb8c_message.c.diff",
    "function_code": "static int on_header_value(\n        multipart_parser *parser, const char *at, size_t length)\n{\n    multipart_parser_data_t *data = NULL;\n\n    ogs_assert(parser);\n    data = multipart_parser_get_data(parser);\n    ogs_assert(data);\n\n    if (data->num_of_part < OGS_SBI_MAX_NUM_OF_PART && at && length) {\n        SWITCH(data->header_field)\n        CASE(OGS_SBI_CONTENT_TYPE)\n            ogs_assert(data->part[data->num_of_part].content_type == NULL);\n            data->part[data->num_of_part].content_type =\n                ogs_strndup(at, length);\n            ogs_assert(data->part[data->num_of_part].content_type);\n            break;\n        CASE(OGS_SBI_CONTENT_ID)\n            ogs_assert(data->part[data->num_of_part].content_id == NULL);\n            data->part[data->num_of_part].content_id =\n                ogs_strndup(at, length);\n            ogs_assert(data->part[data->num_of_part].content_id);\n            break;\n\n        DEFAULT\n            ogs_error(\"Unknown header field [%s]\", data->header_field);\n        END\n    }\n\n    return 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 1839,
    "critical_vars": [
      "data->part[data->num_of_part].content_type"
    ],
    "function": "on_header_value",
    "filename": "open5gs/CVE-2021-44108/CVE-2021-44108_CWE-476_d919b2744cd05abae043490f0a3dd1946c1ccb8c_message.c.diff",
    "function_code": "static int on_header_value(\n        multipart_parser *parser, const char *at, size_t length)\n{\n    multipart_parser_data_t *data = NULL;\n\n    ogs_assert(parser);\n    data = multipart_parser_get_data(parser);\n    ogs_assert(data);\n\n    if (at && length) {\n        SWITCH(data->header_field)\n        CASE(OGS_SBI_CONTENT_TYPE)\n            if (data->part[data->num_of_part].content_type)\n                ogs_free(data->part[data->num_of_part].content_type);\n            data->part[data->num_of_part].content_type =\n                ogs_strndup(at, length);\n            ogs_assert(data->part[data->num_of_part].content_type);\n            break;\n        CASE(OGS_SBI_CONTENT_ID)\n            if (data->part[data->num_of_part].content_id)\n                ogs_free(data->part[data->num_of_part].content_id);\n            data->part[data->num_of_part].content_id =\n                ogs_strndup(at, length);\n            ogs_assert(data->part[data->num_of_part].content_id);\n            break;\n\n        DEFAULT\n            ogs_error(\"Unknown header field [%s]\", data->header_field);\n        END\n    }\n\n    return 0;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1868,
    "critical_vars": [
      "data->num_of_part"
    ],
    "function": "on_part_data",
    "filename": "open5gs/CVE-2021-44108/CVE-2021-44108_CWE-476_d919b2744cd05abae043490f0a3dd1946c1ccb8c_message.c.diff",
    "function_code": "static int on_part_data(\n        multipart_parser *parser, const char *at, size_t length)\n{\n    multipart_parser_data_t *data = NULL;\n\n    ogs_assert(parser);\n    data = multipart_parser_get_data(parser);\n    ogs_assert(data);\n\n    if (data->num_of_part < OGS_SBI_MAX_NUM_OF_PART && at && length) {\n        SWITCH(data->part[data->num_of_part].content_type)\n        CASE(OGS_SBI_CONTENT_JSON_TYPE)\n        CASE(OGS_SBI_CONTENT_5GNAS_TYPE)\n        CASE(OGS_SBI_CONTENT_NGAP_TYPE)\n            size_t offset = 0;\n\n            if (data->part[data->num_of_part].content == NULL) {\n                data->part[data->num_of_part].content_length = length;\n                data->part[data->num_of_part].content =\n                    (char *)ogs_malloc(length + 1);\n                ogs_assert(data->part[data->num_of_part].content);\n            } else {\n                offset = data->part[data->num_of_part].content_length;\n                if ((data->part[data->num_of_part].content_length + length) >\n                        OGS_HUGE_LEN) {\n                    ogs_error(\"Overflow length [%d:%d]\",\n                        (int)data->part[data->num_of_part].content_length,\n                        (int)length);\n                    ogs_assert_if_reached();\n                    return 0;\n                }\n                data->part[data->num_of_part].content_length += length;\n                data->part[data->num_of_part].content = (char *)ogs_realloc(\n                    data->part[data->num_of_part].content,\n                    data->part[data->num_of_part].content_length + 1);\n                ogs_assert(data->part[data->num_of_part].content);\n            }\n            memcpy(data->part[data->num_of_part].content + offset, at, length);\n            data->part[data->num_of_part].content[\n                data->part[data->num_of_part].content_length] = 0;\n            break;\n\n        DEFAULT\n            ogs_error(\"Unknown content_type [%s]\",\n                    data->part[data->num_of_part].content_type);\n            ogs_log_hexdump(OGS_LOG_ERROR, (unsigned char *)at, length);\n        END\n    }\n    return 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 1904,
    "critical_vars": [
      "length",
      "at"
    ],
    "function": "on_part_data",
    "filename": "open5gs/CVE-2021-44108/CVE-2021-44108_CWE-476_d919b2744cd05abae043490f0a3dd1946c1ccb8c_message.c.diff",
    "function_code": "static int on_part_data(\n        multipart_parser *parser, const char *at, size_t length)\n{\n    multipart_parser_data_t *data = NULL;\n\n    ogs_assert(parser);\n    data = multipart_parser_get_data(parser);\n    ogs_assert(data);\n\n    if (at && length) {\n        SWITCH(data->part[data->num_of_part].content_type)\n        CASE(OGS_SBI_CONTENT_JSON_TYPE)\n        CASE(OGS_SBI_CONTENT_5GNAS_TYPE)\n        CASE(OGS_SBI_CONTENT_NGAP_TYPE)\n            size_t offset = 0;\n\n            if (data->part[data->num_of_part].content == NULL) {\n                data->part[data->num_of_part].content_length = length;\n                data->part[data->num_of_part].content =\n                    (char *)ogs_malloc(length + 1);\n                ogs_assert(data->part[data->num_of_part].content);\n            } else {\n                offset = data->part[data->num_of_part].content_length;\n                if ((data->part[data->num_of_part].content_length + length) >\n                        OGS_HUGE_LEN) {\n                    ogs_error(\"Overflow length [%d:%d]\",\n                        (int)data->part[data->num_of_part].content_length,\n                        (int)length);\n                    ogs_assert_if_reached();\n                    return 0;\n                }\n                data->part[data->num_of_part].content_length += length;\n                data->part[data->num_of_part].content = (char *)ogs_realloc(\n                    data->part[data->num_of_part].content,\n                    data->part[data->num_of_part].content_length + 1);\n                ogs_assert(data->part[data->num_of_part].content);\n            }\n            memcpy(data->part[data->num_of_part].content + offset, at, length);\n            data->part[data->num_of_part].content[\n                data->part[data->num_of_part].content_length] = 0;\n            break;\n\n        DEFAULT\n            ogs_log_hexdump(OGS_LOG_FATAL, (unsigned char *)at, length);\n            ogs_error(\"Unknown content_type [%s]\",\n                    data->part[data->num_of_part].content_type);\n        END\n    }\n    return 0;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 1920,
    "critical_vars": [
      "data->num_of_part"
    ],
    "function": "on_part_data_end",
    "filename": "open5gs/CVE-2021-44108/CVE-2021-44108_CWE-476_d919b2744cd05abae043490f0a3dd1946c1ccb8c_message.c.diff",
    "function_code": "static int on_part_data_end(multipart_parser *parser)\n{\n    multipart_parser_data_t *data = NULL;\n\n    ogs_assert(parser);\n    data = multipart_parser_get_data(parser);\n    ogs_assert(data);\n\n    data->num_of_part++;\n\n    return 0;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1918,
    "critical_vars": [
      "data->num_of_part"
    ],
    "function": "on_part_data_end",
    "filename": "open5gs/CVE-2021-44108/CVE-2021-44108_CWE-476_d919b2744cd05abae043490f0a3dd1946c1ccb8c_message.c.diff",
    "function_code": "static int on_part_data_end(multipart_parser *parser)\n{\n    multipart_parser_data_t *data = NULL;\n\n    ogs_assert(parser);\n    data = multipart_parser_get_data(parser);\n    ogs_assert(data);\n\n    if (data->num_of_part < OGS_SBI_MAX_NUM_OF_PART) {\n        data->num_of_part++;\n    }\n\n    return 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1970,
    "critical_vars": [
      "data.num_of_part"
    ],
    "function": "parse_multipart",
    "filename": "open5gs/CVE-2021-44108/CVE-2021-44108_CWE-476_d919b2744cd05abae043490f0a3dd1946c1ccb8c_message.c.diff",
    "function_code": "static int parse_multipart(\n        ogs_sbi_message_t *message, ogs_sbi_http_message_t *http)\n{\n    char *boundary = NULL;\n    int i;\n\n    multipart_parser_settings settings;\n    multipart_parser_data_t data;\n\n    multipart_parser *parser = NULL;\n\n    ogs_assert(message);\n    ogs_assert(http);\n\n    memset(&settings, 0, sizeof(settings));\n    settings.on_header_field = &on_header_field;\n    settings.on_header_value = &on_header_value;\n    settings.on_part_data = &on_part_data;\n    settings.on_part_data_end = &on_part_data_end;\n\n    for (i = 0; i < http->content_length; i++) {\n        if (http->content[i] == '\\r' && http->content[i+1] == '\\n')\n            break;\n    }\n\n    if (i >= http->content_length) {\n        ogs_error(\"Invalid HTTP content [%d]\", i);\n        ogs_log_hexdump(OGS_LOG_ERROR,\n                (unsigned char *)http->content, http->content_length);\n        return OGS_ERROR;\n    }\n\n    boundary = ogs_strndup(http->content, i);\n    ogs_assert(boundary);\n\n    parser = multipart_parser_init(boundary, &settings);\n    ogs_assert(parser);\n\n    memset(&data, 0, sizeof(data));\n    multipart_parser_set_data(parser, &data);\n    multipart_parser_execute(parser, http->content, http->content_length);\n\n    multipart_parser_free(parser);\n    ogs_free(boundary);\n\n    if (data.num_of_part > OGS_SBI_MAX_NUM_OF_PART) {\n        /* Overflow Issues #1247 */\n        ogs_fatal(\"Overflow num_of_part[%d]\", data.num_of_part);\n        ogs_assert_if_reached();\n    }\n    for (i = 0; i < data.num_of_part; i++) {\n        SWITCH(data.part[i].content_type)\n        CASE(OGS_SBI_CONTENT_JSON_TYPE)\n            parse_json(message,\n                    data.part[i].content_type, data.part[i].content);\n\n            if (data.part[i].content_id)\n                ogs_free(data.part[i].content_id);\n            if (data.part[i].content_type)\n                ogs_free(data.part[i].content_type);\n            if (data.part[i].content)\n                ogs_free(data.part[i].content);\n\n            break;\n\n        CASE(OGS_SBI_CONTENT_5GNAS_TYPE)\n        CASE(OGS_SBI_CONTENT_NGAP_TYPE)\n            http->part[http->num_of_part].content_id =\n                data.part[i].content_id;\n            http->part[http->num_of_part].content_type =\n                data.part[i].content_type;\n            http->part[http->num_of_part].pkbuf =\n                ogs_pkbuf_alloc(NULL, data.part[i].content_length);\n            ogs_expect_or_return_val(\n                http->part[http->num_of_part].pkbuf, OGS_ERROR);\n            ogs_pkbuf_put_data(http->part[http->num_of_part].pkbuf,\n                data.part[i].content, data.part[i].content_length);\n\n            message->part[message->num_of_part].content_id =\n                http->part[http->num_of_part].content_id;\n            message->part[message->num_of_part].content_type =\n                http->part[http->num_of_part].content_type;\n            message->part[message->num_of_part].pkbuf =\n                ogs_pkbuf_copy(http->part[http->num_of_part].pkbuf);\n            ogs_expect_or_return_val(\n                message->part[message->num_of_part].pkbuf, OGS_ERROR);\n\n            http->num_of_part++;\n            message->num_of_part++;\n\n            if (data.part[i].content)\n                ogs_free(data.part[i].content);\n            break;\n\n        DEFAULT\n            ogs_error(\"Unknown content-type[%s]\", data.part[i].content_type);\n\n            if (data.part[i].content_id)\n                ogs_free(data.part[i].content_id);\n            if (data.part[i].content_type)\n                ogs_free(data.part[i].content_type);\n        END\n    }\n\n    if (data.header_field)\n        ogs_free(data.header_field);\n\n    return OGS_OK;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 2019,
    "critical_vars": [
      "data.part[i].content_id"
    ],
    "function": "parse_multipart",
    "filename": "open5gs/CVE-2021-44108/CVE-2021-44108_CWE-476_d919b2744cd05abae043490f0a3dd1946c1ccb8c_message.c.diff",
    "function_code": "static int parse_multipart(\n        ogs_sbi_message_t *message, ogs_sbi_http_message_t *http)\n{\n    char *boundary = NULL;\n    int i;\n\n    multipart_parser_settings settings;\n    multipart_parser_data_t data;\n\n    multipart_parser *parser = NULL;\n\n    ogs_assert(message);\n    ogs_assert(http);\n\n    memset(&settings, 0, sizeof(settings));\n    settings.on_header_field = &on_header_field;\n    settings.on_header_value = &on_header_value;\n    settings.on_part_data = &on_part_data;\n    settings.on_part_data_end = &on_part_data_end;\n\n    for (i = 0; i < http->content_length; i++) {\n        if (http->content[i] == '\\r' && http->content[i+1] == '\\n')\n            break;\n    }\n\n    if (i >= http->content_length) {\n        ogs_error(\"Invalid HTTP content [%d]\", i);\n        ogs_log_hexdump(OGS_LOG_ERROR,\n                (unsigned char *)http->content, http->content_length);\n        return OGS_ERROR;\n    }\n\n    boundary = ogs_strndup(http->content, i);\n    ogs_assert(boundary);\n\n    parser = multipart_parser_init(boundary, &settings);\n    ogs_assert(parser);\n\n    memset(&data, 0, sizeof(data));\n    multipart_parser_set_data(parser, &data);\n    multipart_parser_execute(parser, http->content, http->content_length);\n\n    multipart_parser_free(parser);\n    ogs_free(boundary);\n\n    for (i = 0; i < data.num_of_part; i++) {\n        SWITCH(data.part[i].content_type)\n        CASE(OGS_SBI_CONTENT_JSON_TYPE)\n            parse_json(message,\n                    data.part[i].content_type, data.part[i].content);\n\n            if (data.part[i].content_id)\n                ogs_free(data.part[i].content_id);\n            if (data.part[i].content_type)\n                ogs_free(data.part[i].content_type);\n            if (data.part[i].content)\n                ogs_free(data.part[i].content);\n\n            break;\n\n        CASE(OGS_SBI_CONTENT_5GNAS_TYPE)\n        CASE(OGS_SBI_CONTENT_NGAP_TYPE)\n            http->part[http->num_of_part].content_id =\n                data.part[i].content_id;\n            http->part[http->num_of_part].content_type =\n                data.part[i].content_type;\n            http->part[http->num_of_part].pkbuf =\n                ogs_pkbuf_alloc(NULL, data.part[i].content_length);\n            ogs_expect_or_return_val(\n                http->part[http->num_of_part].pkbuf, OGS_ERROR);\n            ogs_pkbuf_put_data(http->part[http->num_of_part].pkbuf,\n                data.part[i].content, data.part[i].content_length);\n\n            message->part[message->num_of_part].content_id =\n                http->part[http->num_of_part].content_id;\n            message->part[message->num_of_part].content_type =\n                http->part[http->num_of_part].content_type;\n            message->part[message->num_of_part].pkbuf =\n                ogs_pkbuf_copy(http->part[http->num_of_part].pkbuf);\n            ogs_expect_or_return_val(\n                message->part[message->num_of_part].pkbuf, OGS_ERROR);\n\n            http->num_of_part++;\n            message->num_of_part++;\n\n            if (data.part[i].content)\n                ogs_free(data.part[i].content);\n            break;\n\n        DEFAULT\n            ogs_error(\"Unknown content-type[%s]\", data.part[i].content_type);\n        END\n    }\n\n    if (data.part[i].content_id)\n        ogs_free(data.part[i].content_id);\n    if (data.part[i].content_type)\n        ogs_free(data.part[i].content_type);\n\n    if (data.header_field)\n        ogs_free(data.header_field);\n\n    return OGS_OK;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 56,
    "critical_vars": [
      "ngapIeType"
    ],
    "function": "amf_namf_comm_handle_n1_n2_message_transfer",
    "filename": "open5gs/CVE-2021-44108/CVE-2021-44108_CWE-476_d919b2744cd05abae043490f0a3dd1946c1ccb8c_namf-handler.c.diff",
    "function_code": "int amf_namf_comm_handle_n1_n2_message_transfer(\n        ogs_sbi_stream_t *stream, ogs_sbi_message_t *recvmsg)\n{\n    int status;\n\n    amf_ue_t *amf_ue = NULL;\n    amf_sess_t *sess = NULL;\n\n    ogs_pkbuf_t *n1buf = NULL;\n    ogs_pkbuf_t *n2buf = NULL;\n\n    ogs_pkbuf_t *gmmbuf = NULL;\n    ogs_pkbuf_t *ngapbuf = NULL;\n\n    char *supi = NULL;\n    uint8_t pdu_session_id = OGS_NAS_PDU_SESSION_IDENTITY_UNASSIGNED;\n\n    ogs_sbi_message_t sendmsg;\n    ogs_sbi_response_t *response = NULL;\n\n    OpenAPI_n1_n2_message_transfer_req_data_t *N1N2MessageTransferReqData;\n    OpenAPI_n1_n2_message_transfer_rsp_data_t N1N2MessageTransferRspData;\n    OpenAPI_n1_message_container_t *n1MessageContainer = NULL;\n    OpenAPI_ref_to_binary_data_t *n1MessageContent = NULL;\n    OpenAPI_n2_info_container_t *n2InfoContainer = NULL;\n    OpenAPI_n2_sm_information_t *smInfo = NULL;\n    OpenAPI_n2_info_content_t *n2InfoContent = NULL;\n    OpenAPI_ref_to_binary_data_t *ngapData = NULL;\n\n    OpenAPI_ngap_ie_type_e ngapIeType = OpenAPI_ngap_ie_type_NULL;\n\n    ogs_assert(stream);\n    ogs_assert(recvmsg);\n\n    N1N2MessageTransferReqData = recvmsg->N1N2MessageTransferReqData;\n    if (!N1N2MessageTransferReqData) {\n        ogs_error(\"No N1N2MessageTransferReqData\");\n        return OGS_ERROR;\n    }\n\n    if (N1N2MessageTransferReqData->is_pdu_session_id == false) {\n        ogs_error(\"No PDU Session Identity\");\n        return OGS_ERROR;\n    }\n    pdu_session_id = N1N2MessageTransferReqData->pdu_session_id;\n\n    supi = recvmsg->h.resource.component[1];\n    if (!supi) {\n        ogs_error(\"No SUPI\");\n        return OGS_ERROR;\n    }\n\n    amf_ue = amf_ue_find_by_supi(supi);\n    if (!amf_ue) {\n        ogs_error(\"No UE context [%s]\", supi);\n        return OGS_ERROR;\n    }\n\n    sess = amf_sess_find_by_psi(amf_ue, pdu_session_id);\n    if (!sess) {\n        ogs_error(\"[%s] No PDU Session Context [%d]\",\n                amf_ue->supi, pdu_session_id);\n        return OGS_ERROR;\n    }\n\n    n1MessageContainer = N1N2MessageTransferReqData->n1_message_container;\n    if (n1MessageContainer) {\n        n1MessageContent = n1MessageContainer->n1_message_content;\n        if (!n1MessageContent || !n1MessageContent->content_id) {\n            ogs_error(\"No n1MessageContent\");\n            return OGS_ERROR;\n        }\n\n        n1buf = ogs_sbi_find_part_by_content_id(\n                recvmsg, n1MessageContent->content_id);\n        if (!n1buf) {\n            ogs_error(\"[%s] No N1 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        /*\n         * NOTE : The pkbuf created in the SBI message will be removed\n         *        from ogs_sbi_message_free(), so it must be copied.\n         */\n        n1buf = ogs_pkbuf_copy(n1buf);\n        ogs_assert(n1buf);\n    }\n\n    n2InfoContainer = N1N2MessageTransferReqData->n2_info_container;\n    if (n2InfoContainer) {\n        smInfo = n2InfoContainer->sm_info;\n        if (!smInfo) {\n            ogs_error(\"No smInfo\");\n            return OGS_ERROR;\n        }\n\n        n2InfoContent = smInfo->n2_info_content;\n        if (!n2InfoContent) {\n            ogs_error(\"No n2InfoContent\");\n            return OGS_ERROR;\n        }\n\n        ngapIeType = n2InfoContent->ngap_ie_type;\n\n        ngapData = n2InfoContent->ngap_data;\n        if (!ngapData || !ngapData->content_id) {\n            ogs_error(\"No ngapData\");\n            return OGS_ERROR;\n        }\n        n2buf = ogs_sbi_find_part_by_content_id(\n                recvmsg, ngapData->content_id);\n        if (!n2buf) {\n            ogs_error(\"[%s] No N2 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        /*\n         * NOTE : The pkbuf created in the SBI message will be removed\n         *        from ogs_sbi_message_free(), so it must be copied.\n         */\n        n2buf = ogs_pkbuf_copy(n2buf);\n        ogs_assert(n2buf);\n    }\n\n    memset(&sendmsg, 0, sizeof(sendmsg));\n\n    status = OGS_SBI_HTTP_STATUS_OK;\n\n    memset(&N1N2MessageTransferRspData, 0, sizeof(N1N2MessageTransferRspData));\n    N1N2MessageTransferRspData.cause =\n        OpenAPI_n1_n2_message_transfer_cause_N1_N2_TRANSFER_INITIATED;\n\n    sendmsg.N1N2MessageTransferRspData = &N1N2MessageTransferRspData;\n\n    switch (ngapIeType) {\n    case OpenAPI_ngap_ie_type_PDU_RES_SETUP_REQ:\n        if (!n2buf) {\n            ogs_error(\"[%s] No N2 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        if (n1buf) {\n            gmmbuf = gmm_build_dl_nas_transport(sess,\n                    OGS_NAS_PAYLOAD_CONTAINER_N1_SM_INFORMATION, n1buf, 0, 0);\n            ogs_assert(gmmbuf);\n        }\n\n        if (gmmbuf) {\n            ran_ue_t *ran_ue = NULL;\n\n            /***********************************\n             * 4.3.2 PDU Session Establishment *\n             ***********************************/\n\n            ran_ue = ran_ue_cycle(amf_ue->ran_ue);\n            ogs_assert(ran_ue);\n\n            if (sess->pdu_session_establishment_accept) {\n                ogs_pkbuf_free(sess->pdu_session_establishment_accept);\n                sess->pdu_session_establishment_accept = NULL;\n            }\n\n            if (ran_ue->initial_context_setup_request_sent == true) {\n                ngapbuf = ngap_sess_build_pdu_session_resource_setup_request(\n                        sess, gmmbuf, n2buf);\n                ogs_assert(ngapbuf);\n            } else {\n                ngapbuf = ngap_sess_build_initial_context_setup_request(\n                        sess, gmmbuf, n2buf);\n                ogs_assert(ngapbuf);\n\n                ran_ue->initial_context_setup_request_sent = true;\n            }\n\n            if (SESSION_CONTEXT_IN_SMF(sess)) {\n                /*\n                 * [1-CLIENT] /nsmf-pdusession/v1/sm-contexts\n                 * [2-SERVER] /namf-comm/v1/ue-contexts/{supi}/n1-n2-messages\n                 *\n                 * If [2-SERVER] arrives after [1-CLIENT],\n                 * sm-context-ref is created in [1-CLIENT].\n                 * So, the PDU session establishment accpet can be transmitted.\n                 */\n                if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK)\n                    ogs_error(\"nas_5gs_send_to_gnb() failed\");\n            } else {\n                sess->pdu_session_establishment_accept = ngapbuf;\n            }\n\n        } else {\n            /*********************************************\n             * 4.2.3.3 Network Triggered Service Request *\n             *********************************************/\n\n            if (CM_IDLE(amf_ue)) {\n                ogs_sbi_server_t *server = NULL;\n                ogs_sbi_header_t header;\n                ogs_sbi_client_t *client = NULL;\n                ogs_sockaddr_t *addr = NULL;\n\n                if (!N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri) {\n                    ogs_error(\"[%s:%d] No n1-n2-failure-notification-uri\",\n                            amf_ue->supi, sess->psi);\n                    return OGS_ERROR;\n                }\n\n                addr = ogs_sbi_getaddr_from_uri(\n                        N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri);\n                if (!addr) {\n                    ogs_error(\"[%s:%d] Invalid URI [%s]\",\n                            amf_ue->supi, sess->psi,\n                            N1N2MessageTransferReqData->\n                                n1n2_failure_txf_notif_uri);\n                    return OGS_ERROR;;\n                }\n\n                client = ogs_sbi_client_find(addr);\n                if (!client) {\n                    client = ogs_sbi_client_add(addr);\n                    ogs_assert(client);\n                }\n                OGS_SETUP_SBI_CLIENT(&sess->paging, client);\n\n                ogs_freeaddrinfo(addr);\n\n                status = OGS_SBI_HTTP_STATUS_ACCEPTED;\n                N1N2MessageTransferRspData.cause =\n                    OpenAPI_n1_n2_message_transfer_cause_ATTEMPTING_TO_REACH_UE;\n\n                /* Location */\n                server = ogs_sbi_server_from_stream(stream);\n                ogs_assert(server);\n\n                memset(&header, 0, sizeof(header));\n                header.service.name = (char *)OGS_SBI_SERVICE_NAME_NAMF_COMM;\n                header.api.version = (char *)OGS_SBI_API_V1;\n                header.resource.component[0] =\n                    (char *)OGS_SBI_RESOURCE_NAME_UE_CONTEXTS;\n                header.resource.component[1] = amf_ue->supi;\n                header.resource.component[2] =\n                    (char *)OGS_SBI_RESOURCE_NAME_N1_N2_MESSAGES;\n                header.resource.component[3] = sess->sm_context_ref;\n\n                sendmsg.http.location = ogs_sbi_server_uri(server, &header);\n\n                /* Store Paging Info */\n                AMF_SESS_STORE_PAGING_INFO(\n                        sess, sendmsg.http.location,\n                        N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri);\n\n                /* Store N2 Transfer message */\n                AMF_SESS_STORE_N2_TRANSFER(\n                        sess, pdu_session_resource_setup_request, n2buf);\n\n                ogs_assert(OGS_OK == ngap_send_paging(amf_ue));\n\n            } else if (CM_CONNECTED(amf_ue)) {\n                ogs_assert(OGS_OK ==\n                    ngap_send_pdu_resource_setup_request(sess, n2buf));\n\n            } else {\n\n                ogs_fatal(\"[%s] Invalid AMF-UE state\", amf_ue->supi);\n                ogs_assert_if_reached();\n\n            }\n\n        }\n        break;\n\n    case OpenAPI_ngap_ie_type_PDU_RES_MOD_REQ:\n        if (!n1buf) {\n            ogs_error(\"[%s] No N1 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n        if (!n2buf) {\n            ogs_error(\"[%s] No N2 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        if (CM_IDLE(amf_ue)) {\n            ogs_sbi_server_t *server = NULL;\n            ogs_sbi_header_t header;\n\n            status = OGS_SBI_HTTP_STATUS_ACCEPTED;\n            N1N2MessageTransferRspData.cause =\n                OpenAPI_n1_n2_message_transfer_cause_ATTEMPTING_TO_REACH_UE;\n\n            /* Location */\n            server = ogs_sbi_server_from_stream(stream);\n            ogs_assert(server);\n\n            memset(&header, 0, sizeof(header));\n            header.service.name = (char *)OGS_SBI_SERVICE_NAME_NAMF_COMM;\n            header.api.version = (char *)OGS_SBI_API_V1;\n            header.resource.component[0] =\n                (char *)OGS_SBI_RESOURCE_NAME_UE_CONTEXTS;\n            header.resource.component[1] = amf_ue->supi;\n            header.resource.component[2] =\n                (char *)OGS_SBI_RESOURCE_NAME_N1_N2_MESSAGES;\n            header.resource.component[3] = sess->sm_context_ref;\n\n            sendmsg.http.location = ogs_sbi_server_uri(server, &header);\n\n            /* Store Paging Info */\n            AMF_SESS_STORE_PAGING_INFO(\n                    sess, sendmsg.http.location, NULL);\n\n            /* Store 5GSM Message */\n            AMF_SESS_STORE_5GSM_MESSAGE(sess,\n                    OGS_NAS_5GS_PDU_SESSION_MODIFICATION_COMMAND,\n                    n1buf, n2buf);\n\n            ogs_assert(OGS_OK == ngap_send_paging(amf_ue));\n\n        } else if (CM_CONNECTED(amf_ue)) {\n            gmmbuf = gmm_build_dl_nas_transport(sess,\n                    OGS_NAS_PAYLOAD_CONTAINER_N1_SM_INFORMATION, n1buf, 0, 0);\n            ogs_assert(gmmbuf);\n\n            ngapbuf = ngap_build_pdu_session_resource_modify_request(\n                    sess, gmmbuf, n2buf);\n            ogs_assert(ngapbuf);\n\n            if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK)\n                ogs_error(\"nas_5gs_send_to_gnb() failed\");\n\n        } else {\n            ogs_fatal(\"[%s] Invalid AMF-UE state\", amf_ue->supi);\n            ogs_assert_if_reached();\n        }\n\n        break;\n\n    case OpenAPI_ngap_ie_type_PDU_RES_REL_CMD:\n        if (!n2buf) {\n            ogs_error(\"[%s] No N2 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        if (n1buf)\n            ogs_pkbuf_free(n1buf);\n\n        if (CM_IDLE(amf_ue)) {\n            if (n2buf)\n                ogs_pkbuf_free(n2buf);\n\n            if (N1N2MessageTransferReqData->is_skip_ind == true &&\n                N1N2MessageTransferReqData->skip_ind == true) {\n                N1N2MessageTransferRspData.cause =\n                    OpenAPI_n1_n2_message_transfer_cause_N1_MSG_NOT_TRANSFERRED;\n            } else {\n                ogs_fatal(\"[%s] No skipInd\", amf_ue->supi);\n                ogs_assert_if_reached();\n            }\n\n        } else if (CM_CONNECTED(amf_ue)) {\n            ngapbuf = ngap_build_pdu_session_resource_release_command(\n                    sess, NULL, n2buf);\n            ogs_assert(ngapbuf);\n\n            if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK)\n                ogs_error(\"nas_5gs_send_to_gnb() failed\");\n\n        } else {\n            ogs_fatal(\"[%s] Invalid AMF-UE state\", amf_ue->supi);\n            ogs_assert_if_reached();\n        }\n        break;\n\n    default:\n        ogs_error(\"Not implemented ngapIeType[%d]\", ngapIeType);\n        ogs_assert_if_reached();\n    }\n\n    response = ogs_sbi_build_response(&sendmsg, status);\n    ogs_assert(response);\n    ogs_assert(true == ogs_sbi_server_send_response(stream, response));\n\n    if (sendmsg.http.location)\n        ogs_free(sendmsg.http.location);\n\n    return OGS_OK;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 156,
    "critical_vars": [
      "n2InfoContent->ngap_ie_type"
    ],
    "function": "amf_namf_comm_handle_n1_n2_message_transfer",
    "filename": "open5gs/CVE-2021-44108/CVE-2021-44108_CWE-476_d919b2744cd05abae043490f0a3dd1946c1ccb8c_namf-handler.c.diff",
    "function_code": "int amf_namf_comm_handle_n1_n2_message_transfer(\n        ogs_sbi_stream_t *stream, ogs_sbi_message_t *recvmsg)\n{\n    int status;\n\n    amf_ue_t *amf_ue = NULL;\n    amf_sess_t *sess = NULL;\n\n    ogs_pkbuf_t *n1buf = NULL;\n    ogs_pkbuf_t *n2buf = NULL;\n\n    ogs_pkbuf_t *gmmbuf = NULL;\n    ogs_pkbuf_t *ngapbuf = NULL;\n\n    char *supi = NULL;\n    uint8_t pdu_session_id = OGS_NAS_PDU_SESSION_IDENTITY_UNASSIGNED;\n\n    ogs_sbi_message_t sendmsg;\n    ogs_sbi_response_t *response = NULL;\n\n    OpenAPI_n1_n2_message_transfer_req_data_t *N1N2MessageTransferReqData;\n    OpenAPI_n1_n2_message_transfer_rsp_data_t N1N2MessageTransferRspData;\n    OpenAPI_n1_message_container_t *n1MessageContainer = NULL;\n    OpenAPI_ref_to_binary_data_t *n1MessageContent = NULL;\n    OpenAPI_n2_info_container_t *n2InfoContainer = NULL;\n    OpenAPI_n2_sm_information_t *smInfo = NULL;\n    OpenAPI_n2_info_content_t *n2InfoContent = NULL;\n    OpenAPI_ref_to_binary_data_t *ngapData = NULL;\n\n    ogs_assert(stream);\n    ogs_assert(recvmsg);\n\n    N1N2MessageTransferReqData = recvmsg->N1N2MessageTransferReqData;\n    if (!N1N2MessageTransferReqData) {\n        ogs_error(\"No N1N2MessageTransferReqData\");\n        return OGS_ERROR;\n    }\n\n    if (N1N2MessageTransferReqData->is_pdu_session_id == false) {\n        ogs_error(\"No PDU Session Identity\");\n        return OGS_ERROR;\n    }\n    pdu_session_id = N1N2MessageTransferReqData->pdu_session_id;\n\n    supi = recvmsg->h.resource.component[1];\n    if (!supi) {\n        ogs_error(\"No SUPI\");\n        return OGS_ERROR;\n    }\n\n    amf_ue = amf_ue_find_by_supi(supi);\n    if (!amf_ue) {\n        ogs_error(\"No UE context [%s]\", supi);\n        return OGS_ERROR;\n    }\n\n    sess = amf_sess_find_by_psi(amf_ue, pdu_session_id);\n    if (!sess) {\n        ogs_error(\"[%s] No PDU Session Context [%d]\",\n                amf_ue->supi, pdu_session_id);\n        return OGS_ERROR;\n    }\n\n    n1MessageContainer = N1N2MessageTransferReqData->n1_message_container;\n    if (n1MessageContainer) {\n        n1MessageContent = n1MessageContainer->n1_message_content;\n        if (!n1MessageContent || !n1MessageContent->content_id) {\n            ogs_error(\"No n1MessageContent\");\n            return OGS_ERROR;\n        }\n\n        n1buf = ogs_sbi_find_part_by_content_id(\n                recvmsg, n1MessageContent->content_id);\n        if (!n1buf) {\n            ogs_error(\"[%s] No N1 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        /*\n         * NOTE : The pkbuf created in the SBI message will be removed\n         *        from ogs_sbi_message_free(), so it must be copied.\n         */\n        n1buf = ogs_pkbuf_copy(n1buf);\n        ogs_assert(n1buf);\n    }\n\n    n2InfoContainer = N1N2MessageTransferReqData->n2_info_container;\n    if (n2InfoContainer) {\n        smInfo = n2InfoContainer->sm_info;\n        if (!smInfo) {\n            ogs_error(\"No smInfo\");\n            return OGS_ERROR;\n        }\n        n2InfoContent = smInfo->n2_info_content;\n        if (!n2InfoContent) {\n            ogs_error(\"No n2InfoContent\");\n            return OGS_ERROR;\n        }\n\n        ngapData = n2InfoContent->ngap_data;\n        if (!ngapData || !ngapData->content_id) {\n            ogs_error(\"No ngapData\");\n            return OGS_ERROR;\n        }\n        n2buf = ogs_sbi_find_part_by_content_id(\n                recvmsg, ngapData->content_id);\n        if (!n2buf) {\n            ogs_error(\"[%s] No N2 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        /*\n         * NOTE : The pkbuf created in the SBI message will be removed\n         *        from ogs_sbi_message_free(), so it must be copied.\n         */\n        n2buf = ogs_pkbuf_copy(n2buf);\n        ogs_assert(n2buf);\n    }\n\n    memset(&sendmsg, 0, sizeof(sendmsg));\n\n    status = OGS_SBI_HTTP_STATUS_OK;\n\n    memset(&N1N2MessageTransferRspData, 0, sizeof(N1N2MessageTransferRspData));\n    N1N2MessageTransferRspData.cause =\n        OpenAPI_n1_n2_message_transfer_cause_N1_N2_TRANSFER_INITIATED;\n\n    sendmsg.N1N2MessageTransferRspData = &N1N2MessageTransferRspData;\n\n    switch (n2InfoContent->ngap_ie_type) {\n    case OpenAPI_ngap_ie_type_PDU_RES_SETUP_REQ:\n        if (!n2buf) {\n            ogs_error(\"[%s] No N2 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        if (n1buf) {\n            gmmbuf = gmm_build_dl_nas_transport(sess,\n                    OGS_NAS_PAYLOAD_CONTAINER_N1_SM_INFORMATION, n1buf, 0, 0);\n            ogs_assert(gmmbuf);\n        }\n\n        if (gmmbuf) {\n            ran_ue_t *ran_ue = NULL;\n\n            /***********************************\n             * 4.3.2 PDU Session Establishment *\n             ***********************************/\n\n            ran_ue = ran_ue_cycle(amf_ue->ran_ue);\n            ogs_assert(ran_ue);\n\n            if (sess->pdu_session_establishment_accept) {\n                ogs_pkbuf_free(sess->pdu_session_establishment_accept);\n                sess->pdu_session_establishment_accept = NULL;\n            }\n\n            if (ran_ue->initial_context_setup_request_sent == true) {\n                ngapbuf = ngap_sess_build_pdu_session_resource_setup_request(\n                        sess, gmmbuf, n2buf);\n                ogs_assert(ngapbuf);\n            } else {\n                ngapbuf = ngap_sess_build_initial_context_setup_request(\n                        sess, gmmbuf, n2buf);\n                ogs_assert(ngapbuf);\n\n                ran_ue->initial_context_setup_request_sent = true;\n            }\n\n            if (SESSION_CONTEXT_IN_SMF(sess)) {\n                /*\n                 * [1-CLIENT] /nsmf-pdusession/v1/sm-contexts\n                 * [2-SERVER] /namf-comm/v1/ue-contexts/{supi}/n1-n2-messages\n                 *\n                 * If [2-SERVER] arrives after [1-CLIENT],\n                 * sm-context-ref is created in [1-CLIENT].\n                 * So, the PDU session establishment accpet can be transmitted.\n                 */\n                if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK)\n                    ogs_error(\"nas_5gs_send_to_gnb() failed\");\n            } else {\n                sess->pdu_session_establishment_accept = ngapbuf;\n            }\n\n        } else {\n            /*********************************************\n             * 4.2.3.3 Network Triggered Service Request *\n             *********************************************/\n\n            if (CM_IDLE(amf_ue)) {\n                ogs_sbi_server_t *server = NULL;\n                ogs_sbi_header_t header;\n                ogs_sbi_client_t *client = NULL;\n                ogs_sockaddr_t *addr = NULL;\n\n                if (!N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri) {\n                    ogs_error(\"[%s:%d] No n1-n2-failure-notification-uri\",\n                            amf_ue->supi, sess->psi);\n                    return OGS_ERROR;\n                }\n\n                addr = ogs_sbi_getaddr_from_uri(\n                        N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri);\n                if (!addr) {\n                    ogs_error(\"[%s:%d] Invalid URI [%s]\",\n                            amf_ue->supi, sess->psi,\n                            N1N2MessageTransferReqData->\n                                n1n2_failure_txf_notif_uri);\n                    return OGS_ERROR;;\n                }\n\n                client = ogs_sbi_client_find(addr);\n                if (!client) {\n                    client = ogs_sbi_client_add(addr);\n                    ogs_assert(client);\n                }\n                OGS_SETUP_SBI_CLIENT(&sess->paging, client);\n\n                ogs_freeaddrinfo(addr);\n\n                status = OGS_SBI_HTTP_STATUS_ACCEPTED;\n                N1N2MessageTransferRspData.cause =\n                    OpenAPI_n1_n2_message_transfer_cause_ATTEMPTING_TO_REACH_UE;\n\n                /* Location */\n                server = ogs_sbi_server_from_stream(stream);\n                ogs_assert(server);\n\n                memset(&header, 0, sizeof(header));\n                header.service.name = (char *)OGS_SBI_SERVICE_NAME_NAMF_COMM;\n                header.api.version = (char *)OGS_SBI_API_V1;\n                header.resource.component[0] =\n                    (char *)OGS_SBI_RESOURCE_NAME_UE_CONTEXTS;\n                header.resource.component[1] = amf_ue->supi;\n                header.resource.component[2] =\n                    (char *)OGS_SBI_RESOURCE_NAME_N1_N2_MESSAGES;\n                header.resource.component[3] = sess->sm_context_ref;\n\n                sendmsg.http.location = ogs_sbi_server_uri(server, &header);\n\n                /* Store Paging Info */\n                AMF_SESS_STORE_PAGING_INFO(\n                        sess, sendmsg.http.location,\n                        N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri);\n\n                /* Store N2 Transfer message */\n                AMF_SESS_STORE_N2_TRANSFER(\n                        sess, pdu_session_resource_setup_request, n2buf);\n\n                ogs_assert(OGS_OK == ngap_send_paging(amf_ue));\n\n            } else if (CM_CONNECTED(amf_ue)) {\n                ogs_assert(OGS_OK ==\n                    ngap_send_pdu_resource_setup_request(sess, n2buf));\n\n            } else {\n\n                ogs_fatal(\"[%s] Invalid AMF-UE state\", amf_ue->supi);\n                ogs_assert_if_reached();\n\n            }\n\n        }\n        break;\n\n    case OpenAPI_ngap_ie_type_PDU_RES_MOD_REQ:\n        if (!n1buf) {\n            ogs_error(\"[%s] No N1 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n        if (!n2buf) {\n            ogs_error(\"[%s] No N2 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        if (CM_IDLE(amf_ue)) {\n            ogs_sbi_server_t *server = NULL;\n            ogs_sbi_header_t header;\n\n            status = OGS_SBI_HTTP_STATUS_ACCEPTED;\n            N1N2MessageTransferRspData.cause =\n                OpenAPI_n1_n2_message_transfer_cause_ATTEMPTING_TO_REACH_UE;\n\n            /* Location */\n            server = ogs_sbi_server_from_stream(stream);\n            ogs_assert(server);\n\n            memset(&header, 0, sizeof(header));\n            header.service.name = (char *)OGS_SBI_SERVICE_NAME_NAMF_COMM;\n            header.api.version = (char *)OGS_SBI_API_V1;\n            header.resource.component[0] =\n                (char *)OGS_SBI_RESOURCE_NAME_UE_CONTEXTS;\n            header.resource.component[1] = amf_ue->supi;\n            header.resource.component[2] =\n                (char *)OGS_SBI_RESOURCE_NAME_N1_N2_MESSAGES;\n            header.resource.component[3] = sess->sm_context_ref;\n\n            sendmsg.http.location = ogs_sbi_server_uri(server, &header);\n\n            /* Store Paging Info */\n            AMF_SESS_STORE_PAGING_INFO(\n                    sess, sendmsg.http.location, NULL);\n\n            /* Store 5GSM Message */\n            AMF_SESS_STORE_5GSM_MESSAGE(sess,\n                    OGS_NAS_5GS_PDU_SESSION_MODIFICATION_COMMAND,\n                    n1buf, n2buf);\n\n            ogs_assert(OGS_OK == ngap_send_paging(amf_ue));\n\n        } else if (CM_CONNECTED(amf_ue)) {\n            gmmbuf = gmm_build_dl_nas_transport(sess,\n                    OGS_NAS_PAYLOAD_CONTAINER_N1_SM_INFORMATION, n1buf, 0, 0);\n            ogs_assert(gmmbuf);\n\n            ngapbuf = ngap_build_pdu_session_resource_modify_request(\n                    sess, gmmbuf, n2buf);\n            ogs_assert(ngapbuf);\n\n            if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK)\n                ogs_error(\"nas_5gs_send_to_gnb() failed\");\n\n        } else {\n            ogs_fatal(\"[%s] Invalid AMF-UE state\", amf_ue->supi);\n            ogs_assert_if_reached();\n        }\n\n        break;\n\n    case OpenAPI_ngap_ie_type_PDU_RES_REL_CMD:\n        if (!n2buf) {\n            ogs_error(\"[%s] No N2 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        if (n1buf)\n            ogs_pkbuf_free(n1buf);\n\n        if (CM_IDLE(amf_ue)) {\n            if (n2buf)\n                ogs_pkbuf_free(n2buf);\n\n            if (N1N2MessageTransferReqData->is_skip_ind == true &&\n                N1N2MessageTransferReqData->skip_ind == true) {\n                N1N2MessageTransferRspData.cause =\n                    OpenAPI_n1_n2_message_transfer_cause_N1_MSG_NOT_TRANSFERRED;\n            } else {\n                ogs_fatal(\"[%s] No skipInd\", amf_ue->supi);\n                ogs_assert_if_reached();\n            }\n\n        } else if (CM_CONNECTED(amf_ue)) {\n            ngapbuf = ngap_build_pdu_session_resource_release_command(\n                    sess, NULL, n2buf);\n            ogs_assert(ngapbuf);\n\n            if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK)\n                ogs_error(\"nas_5gs_send_to_gnb() failed\");\n\n        } else {\n            ogs_fatal(\"[%s] Invalid AMF-UE state\", amf_ue->supi);\n            ogs_assert_if_reached();\n        }\n        break;\n\n    default:\n        ogs_error(\"Not implemented ngap_ie_type[%d]\",\n                n2InfoContent->ngap_ie_type);\n        ogs_assert_if_reached();\n    }\n\n    response = ogs_sbi_build_response(&sendmsg, status);\n    ogs_assert(response);\n    ogs_assert(true == ogs_sbi_server_send_response(stream, response));\n\n    if (sendmsg.http.location)\n        ogs_free(sendmsg.http.location);\n\n    return OGS_OK;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 45,
    "critical_vars": [
      "val"
    ],
    "function": "parserule",
    "filename": "samurai/CVE-2021-30219/CVE-2021-30219_CWE-476_d2af3bc375e2a77139c3a28d6128c60cd8d08655_parse.c.diff",
    "function_code": "parserule(struct scanner *s, struct environment *env)\n{\n\tstruct rule *r;\n\tchar *var;\n\tstruct evalstring *val;\n\tbool hascommand = false, hasrspfile = false, hasrspcontent = false;\n\n\tr = mkrule(scanname(s));\n\tscannewline(s);\n\twhile (scanindent(s)) {\n\t\tvar = scanname(s);\n\t\tparselet(s, &val);\n\t\truleaddvar(r, var, val);\n\t\tif (!val)\n\t\t\tcontinue;\n\t\tif (strcmp(var, \"command\") == 0)\n\t\t\thascommand = true;\n\t\telse if (strcmp(var, \"rspfile\") == 0)\n\t\t\thasrspfile = true;\n\t\telse if (strcmp(var, \"rspfile_content\") == 0)\n\t\t\thasrspcontent = true;\n\t}\n\tif (!hascommand)\n\t\tfatal(\"rule '%s' has no command\", r->name);\n\tif (hasrspfile != hasrspcontent)\n\t\tfatal(\"rule '%s' has rspfile and no rspfile_content or vice versa\", r->name);\n\tenvaddrule(env, r);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 261,
    "critical_vars": [
      "s"
    ],
    "function": "writefile",
    "filename": "samurai/CVE-2021-30218/CVE-2021-30218_CWE-476_e84b6d99c85043fa1ba54851ee500540ec206918_util.c.diff",
    "function_code": "writefile(const char *name, struct string *s)\n{\n\tFILE *f;\n\tint ret;\n\n\tf = fopen(name, \"w\");\n\tif (!f) {\n\t\twarn(\"open %s:\", name);\n\t\treturn -1;\n\t}\n\tret = 0;\n\tif (s && (fwrite(s->s, 1, s->n, f) != s->n || fflush(f) != 0)) {\n\t\twarn(\"write %s:\", name);\n\t\tret = -1;\n\t}\n\tfclose(f);\n\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 253,
    "critical_vars": [
      "defaultMemory"
    ],
    "function": "run",
    "filename": "WAVM/CVE-2018-17293/CVE-2018-17293_CWE-476_31d670b6489e6d708c3b04b911cdf14ac43d846d_wavm.cpp.diff",
    "function_code": "static int run(const CommandLineOptions& options)\n{\n\tIR::Module irModule;\n\n\t// Load the module.\n\tif(!loadModule(options.filename, irModule)) { return EXIT_FAILURE; }\n\tif(options.onlyCheck) { return EXIT_SUCCESS; }\n\n\t// Compile the module.\n\tRuntime::Module* module = nullptr;\n\tif(!options.precompiled) { module = Runtime::compileModule(irModule); }\n\telse\n\t{\n\t\tconst UserSection* precompiledObjectSection = nullptr;\n\t\tfor(const UserSection& userSection : irModule.userSections)\n\t\t{\n\t\t\tif(userSection.name == \"wavm.precompiled_object\")\n\t\t\t{\n\t\t\t\tprecompiledObjectSection = &userSection;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(!precompiledObjectSection)\n\t\t{\n\t\t\tLog::printf(Log::error, \"Input file did not contain 'wavm.precompiled_object' section\");\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmodule = Runtime::loadPrecompiledModule(irModule, precompiledObjectSection->data);\n\t\t}\n\t}\n\n\t// Link the module with the intrinsic modules.\n\tCompartment* compartment = Runtime::createCompartment();\n\tContext* context = Runtime::createContext(compartment);\n\tRootResolver rootResolver(compartment);\n\n\tEmscripten::Instance* emscriptenInstance = nullptr;\n\tif(options.enableEmscripten)\n\t{\n\t\temscriptenInstance = Emscripten::instantiate(compartment, irModule);\n\t\tif(emscriptenInstance)\n\t\t{\n\t\t\trootResolver.moduleNameToInstanceMap.set(\"env\", emscriptenInstance->env);\n\t\t\trootResolver.moduleNameToInstanceMap.set(\"asm2wasm\", emscriptenInstance->asm2wasm);\n\t\t\trootResolver.moduleNameToInstanceMap.set(\"global\", emscriptenInstance->global);\n\t\t}\n\t}\n\n\tif(options.enableThreadTest)\n\t{\n\t\tModuleInstance* threadTestInstance = ThreadTest::instantiate(compartment);\n\t\trootResolver.moduleNameToInstanceMap.set(\"threadTest\", threadTestInstance);\n\t}\n\n\tLinkResult linkResult = linkModule(irModule, rootResolver);\n\tif(!linkResult.success)\n\t{\n\t\tLog::printf(Log::error, \"Failed to link module:\\n\");\n\t\tfor(auto& missingImport : linkResult.missingImports)\n\t\t{\n\t\t\tLog::printf(Log::error,\n\t\t\t\t\t\t\"Missing import: module=\\\"%s\\\" export=\\\"%s\\\" type=\\\"%s\\\"\\n\",\n\t\t\t\t\t\tmissingImport.moduleName.c_str(),\n\t\t\t\t\t\tmissingImport.exportName.c_str(),\n\t\t\t\t\t\tasString(missingImport.type).c_str());\n\t\t}\n\t\treturn EXIT_FAILURE;\n\t}\n\n\t// Instantiate the module.\n\tModuleInstance* moduleInstance = instantiateModule(\n\t\tcompartment, module, std::move(linkResult.resolvedImports), options.filename);\n\tif(!moduleInstance) { return EXIT_FAILURE; }\n\n\t// Call the module start function, if it has one.\n\tFunctionInstance* startFunction = getStartFunction(moduleInstance);\n\tif(startFunction) { invokeFunctionChecked(context, startFunction, {}); }\n\n\tif(options.enableEmscripten)\n\t{\n\t\t// Call the Emscripten global initalizers.\n\t\tEmscripten::initializeGlobals(context, irModule, moduleInstance);\n\t}\n\n\t// Look up the function export to call.\n\tFunctionInstance* functionInstance;\n\tif(!options.functionName)\n\t{\n\t\tfunctionInstance = asFunctionNullable(getInstanceExport(moduleInstance, \"main\"));\n\t\tif(!functionInstance)\n\t\t{ functionInstance = asFunctionNullable(getInstanceExport(moduleInstance, \"_main\")); }\n\t\tif(!functionInstance)\n\t\t{\n\t\t\tLog::printf(Log::error, \"Module does not export main function\\n\");\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tfunctionInstance\n\t\t\t= asFunctionNullable(getInstanceExport(moduleInstance, options.functionName));\n\t\tif(!functionInstance)\n\t\t{\n\t\t\tLog::printf(Log::error, \"Module does not export '%s'\\n\", options.functionName);\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n\tFunctionType functionType = getFunctionType(functionInstance);\n\n\t// Set up the arguments for the invoke.\n\tstd::vector<Value> invokeArgs;\n\tif(!options.functionName)\n\t{\n\t\tif(functionType.params().size() == 2)\n\t\t{\n\t\t\tMemoryInstance* defaultMemory = Runtime::getDefaultMemory(moduleInstance);\n\t\t\tif(!defaultMemory)\n\t\t\t{\n\t\t\t\tLog::printf(\n\t\t\t\t\tLog::error,\n\t\t\t\t\t\"Module does not declare a default memory object to put arguments in.\\n\");\n\t\t\t\treturn EXIT_FAILURE;\n\t\t\t}\n\n\t\t\tstd::vector<const char*> argStrings;\n\t\t\targStrings.push_back(options.filename);\n\t\t\tchar** args = options.args;\n\t\t\twhile(*args) { argStrings.push_back(*args++); };\n\n\t\t\tEmscripten::injectCommandArgs(emscriptenInstance, argStrings, invokeArgs);\n\t\t}\n\t\telse if(functionType.params().size() > 0)\n\t\t{\n\t\t\tLog::printf(Log::error,\n\t\t\t\t\t\t\"WebAssembly function requires %\" PRIu64\n\t\t\t\t\t\t\" argument(s), but only 0 or 2 can be passed!\",\n\t\t\t\t\t\tfunctionType.params().size());\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor(U32 i = 0; options.args[i]; ++i)\n\t\t{\n\t\t\tValue value;\n\t\t\tswitch(functionType.params()[i])\n\t\t\t{\n\t\t\tcase ValueType::i32: value = (U32)atoi(options.args[i]); break;\n\t\t\tcase ValueType::i64: value = (U64)atol(options.args[i]); break;\n\t\t\tcase ValueType::f32: value = (F32)atof(options.args[i]); break;\n\t\t\tcase ValueType::f64: value = atof(options.args[i]); break;\n\t\t\tcase ValueType::v128:\n\t\t\tcase ValueType::anyref:\n\t\t\tcase ValueType::anyfunc:\n\t\t\t\tErrors::fatalf(\"Cannot parse command-line argument for %s function parameter\",\n\t\t\t\t\t\t\t   asString(functionType.params()[i]));\n\t\t\tdefault: Errors::unreachable();\n\t\t\t}\n\t\t\tinvokeArgs.push_back(value);\n\t\t}\n\t}\n\n\t// Invoke the function.\n\tTiming::Timer executionTimer;\n\tIR::ValueTuple functionResults = invokeFunctionChecked(context, functionInstance, invokeArgs);\n\tTiming::logTimer(\"Invoked function\", executionTimer);\n\n\tif(options.functionName)\n\t{\n\t\tLog::printf(Log::debug,\n\t\t\t\t\t\"%s returned: %s\\n\",\n\t\t\t\t\toptions.functionName,\n\t\t\t\t\tasString(functionResults).c_str());\n\t\treturn EXIT_SUCCESS;\n\t}\n\telse if(functionResults.size() == 1 && functionResults[0].type == ValueType::i32)\n\t{\n\t\treturn functionResults[0].i32;\n\t}\n\telse\n\t{\n\t\treturn EXIT_SUCCESS;\n\t}\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 253,
    "critical_vars": [
      "emscriptenInstance"
    ],
    "function": "run",
    "filename": "WAVM/CVE-2018-17293/CVE-2018-17293_CWE-476_31d670b6489e6d708c3b04b911cdf14ac43d846d_wavm.cpp.diff",
    "function_code": "static int run(const CommandLineOptions& options)\n{\n\tIR::Module irModule;\n\n\t// Load the module.\n\tif(!loadModule(options.filename, irModule)) { return EXIT_FAILURE; }\n\tif(options.onlyCheck) { return EXIT_SUCCESS; }\n\n\t// Compile the module.\n\tRuntime::Module* module = nullptr;\n\tif(!options.precompiled) { module = Runtime::compileModule(irModule); }\n\telse\n\t{\n\t\tconst UserSection* precompiledObjectSection = nullptr;\n\t\tfor(const UserSection& userSection : irModule.userSections)\n\t\t{\n\t\t\tif(userSection.name == \"wavm.precompiled_object\")\n\t\t\t{\n\t\t\t\tprecompiledObjectSection = &userSection;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(!precompiledObjectSection)\n\t\t{\n\t\t\tLog::printf(Log::error, \"Input file did not contain 'wavm.precompiled_object' section\");\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmodule = Runtime::loadPrecompiledModule(irModule, precompiledObjectSection->data);\n\t\t}\n\t}\n\n\t// Link the module with the intrinsic modules.\n\tCompartment* compartment = Runtime::createCompartment();\n\tContext* context = Runtime::createContext(compartment);\n\tRootResolver rootResolver(compartment);\n\n\tEmscripten::Instance* emscriptenInstance = nullptr;\n\tif(options.enableEmscripten)\n\t{\n\t\temscriptenInstance = Emscripten::instantiate(compartment, irModule);\n\t\tif(emscriptenInstance)\n\t\t{\n\t\t\trootResolver.moduleNameToInstanceMap.set(\"env\", emscriptenInstance->env);\n\t\t\trootResolver.moduleNameToInstanceMap.set(\"asm2wasm\", emscriptenInstance->asm2wasm);\n\t\t\trootResolver.moduleNameToInstanceMap.set(\"global\", emscriptenInstance->global);\n\t\t}\n\t}\n\n\tif(options.enableThreadTest)\n\t{\n\t\tModuleInstance* threadTestInstance = ThreadTest::instantiate(compartment);\n\t\trootResolver.moduleNameToInstanceMap.set(\"threadTest\", threadTestInstance);\n\t}\n\n\tLinkResult linkResult = linkModule(irModule, rootResolver);\n\tif(!linkResult.success)\n\t{\n\t\tLog::printf(Log::error, \"Failed to link module:\\n\");\n\t\tfor(auto& missingImport : linkResult.missingImports)\n\t\t{\n\t\t\tLog::printf(Log::error,\n\t\t\t\t\t\t\"Missing import: module=\\\"%s\\\" export=\\\"%s\\\" type=\\\"%s\\\"\\n\",\n\t\t\t\t\t\tmissingImport.moduleName.c_str(),\n\t\t\t\t\t\tmissingImport.exportName.c_str(),\n\t\t\t\t\t\tasString(missingImport.type).c_str());\n\t\t}\n\t\treturn EXIT_FAILURE;\n\t}\n\n\t// Instantiate the module.\n\tModuleInstance* moduleInstance = instantiateModule(\n\t\tcompartment, module, std::move(linkResult.resolvedImports), options.filename);\n\tif(!moduleInstance) { return EXIT_FAILURE; }\n\n\t// Call the module start function, if it has one.\n\tFunctionInstance* startFunction = getStartFunction(moduleInstance);\n\tif(startFunction) { invokeFunctionChecked(context, startFunction, {}); }\n\n\tif(options.enableEmscripten)\n\t{\n\t\t// Call the Emscripten global initalizers.\n\t\tEmscripten::initializeGlobals(context, irModule, moduleInstance);\n\t}\n\n\t// Look up the function export to call.\n\tFunctionInstance* functionInstance;\n\tif(!options.functionName)\n\t{\n\t\tfunctionInstance = asFunctionNullable(getInstanceExport(moduleInstance, \"main\"));\n\t\tif(!functionInstance)\n\t\t{ functionInstance = asFunctionNullable(getInstanceExport(moduleInstance, \"_main\")); }\n\t\tif(!functionInstance)\n\t\t{\n\t\t\tLog::printf(Log::error, \"Module does not export main function\\n\");\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tfunctionInstance\n\t\t\t= asFunctionNullable(getInstanceExport(moduleInstance, options.functionName));\n\t\tif(!functionInstance)\n\t\t{\n\t\t\tLog::printf(Log::error, \"Module does not export '%s'\\n\", options.functionName);\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n\tFunctionType functionType = getFunctionType(functionInstance);\n\n\t// Set up the arguments for the invoke.\n\tstd::vector<Value> invokeArgs;\n\tif(!options.functionName)\n\t{\n\t\tif(functionType.params().size() == 2)\n\t\t{\n\t\t\tif(!emscriptenInstance)\n\t\t\t{\n\t\t\t\tLog::printf(\n\t\t\t\t\tLog::error,\n\t\t\t\t\t\"Module does not declare a default memory object to put arguments in.\\n\");\n\t\t\t\treturn EXIT_FAILURE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstd::vector<const char*> argStrings;\n\t\t\t\targStrings.push_back(options.filename);\n\t\t\t\tchar** args = options.args;\n\t\t\t\twhile(*args) { argStrings.push_back(*args++); };\n\n\t\t\t\twavmAssert(emscriptenInstance);\n\t\t\t\tEmscripten::injectCommandArgs(emscriptenInstance, argStrings, invokeArgs);\n\t\t\t}\n\t\t}\n\t\telse if(functionType.params().size() > 0)\n\t\t{\n\t\t\tLog::printf(Log::error,\n\t\t\t\t\t\t\"WebAssembly function requires %\" PRIu64\n\t\t\t\t\t\t\" argument(s), but only 0 or 2 can be passed!\",\n\t\t\t\t\t\tfunctionType.params().size());\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor(U32 i = 0; options.args[i]; ++i)\n\t\t{\n\t\t\tValue value;\n\t\t\tswitch(functionType.params()[i])\n\t\t\t{\n\t\t\tcase ValueType::i32: value = (U32)atoi(options.args[i]); break;\n\t\t\tcase ValueType::i64: value = (U64)atol(options.args[i]); break;\n\t\t\tcase ValueType::f32: value = (F32)atof(options.args[i]); break;\n\t\t\tcase ValueType::f64: value = atof(options.args[i]); break;\n\t\t\tcase ValueType::v128:\n\t\t\tcase ValueType::anyref:\n\t\t\tcase ValueType::anyfunc:\n\t\t\t\tErrors::fatalf(\"Cannot parse command-line argument for %s function parameter\",\n\t\t\t\t\t\t\t   asString(functionType.params()[i]));\n\t\t\tdefault: Errors::unreachable();\n\t\t\t}\n\t\t\tinvokeArgs.push_back(value);\n\t\t}\n\t}\n\n\t// Invoke the function.\n\tTiming::Timer executionTimer;\n\tIR::ValueTuple functionResults = invokeFunctionChecked(context, functionInstance, invokeArgs);\n\tTiming::logTimer(\"Invoked function\", executionTimer);\n\n\tif(options.functionName)\n\t{\n\t\tLog::printf(Log::debug,\n\t\t\t\t\t\"%s returned: %s\\n\",\n\t\t\t\t\toptions.functionName,\n\t\t\t\t\tasString(functionResults).c_str());\n\t\treturn EXIT_SUCCESS;\n\t}\n\telse if(functionResults.size() == 1 && functionResults[0].type == ValueType::i32)\n\t{\n\t\treturn functionResults[0].i32;\n\t}\n\telse\n\t{\n\t\treturn EXIT_SUCCESS;\n\t}\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 3238,
    "critical_vars": [
      "*low"
    ],
    "function": "forward_search_range",
    "filename": "oniguruma/CVE-2017-9229/CVE-2017-9229_CWE-476_b690371bbf97794b4a1d3f295d4fb9a8b05d402d_regexec.c.diff",
    "function_code": "forward_search_range(regex_t* reg, const UChar* str, const UChar* end, UChar* s,\n\t\t     UChar* range, UChar** low, UChar** high, UChar** low_prev)\n{\n  UChar *p, *pprev = (UChar* )NULL;\n\n#ifdef ONIG_DEBUG_SEARCH\n  fprintf(stderr, \"forward_search_range: str: %d, end: %d, s: %d, range: %d\\n\",\n\t  (int )str, (int )end, (int )s, (int )range);\n#endif\n\n  p = s;\n  if (reg->dmin > 0) {\n    if (ONIGENC_IS_SINGLEBYTE(reg->enc)) {\n      p += reg->dmin;\n    }\n    else {\n      UChar *q = p + reg->dmin;\n\n      if (q >= end) return 0; /* fail */\n      while (p < q) p += enclen(reg->enc, p);\n    }\n  }\n\n retry:\n  switch (reg->optimize) {\n  case ONIG_OPTIMIZE_EXACT:\n    p = slow_search(reg->enc, reg->exact, reg->exact_end, p, end, range);\n    break;\n  case ONIG_OPTIMIZE_EXACT_IC:\n    p = slow_search_ic(reg->enc, reg->case_fold_flag,\n                       reg->exact, reg->exact_end, p, end, range);\n    break;\n\n  case ONIG_OPTIMIZE_EXACT_BM:\n    p = bm_search(reg, reg->exact, reg->exact_end, p, end, range);\n    break;\n\n  case ONIG_OPTIMIZE_EXACT_BM_NOT_REV:\n    p = bm_search_notrev(reg, reg->exact, reg->exact_end, p, end, range);\n    break;\n\n  case ONIG_OPTIMIZE_MAP:\n    p = map_search(reg->enc, reg->map, p, range);\n    break;\n  }\n\n  if (p && p < range) {\n    if (p - reg->dmin < s) {\n    retry_gate:\n      pprev = p;\n      p += enclen(reg->enc, p);\n      goto retry;\n    }\n\n    if (reg->sub_anchor) {\n      UChar* prev;\n\n      switch (reg->sub_anchor) {\n      case ANCHOR_BEGIN_LINE:\n        if (!ON_STR_BEGIN(p)) {\n          prev = onigenc_get_prev_char_head(reg->enc,\n                                            (pprev ? pprev : str), p);\n          if (!ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end))\n            goto retry_gate;\n        }\n        break;\n\n      case ANCHOR_END_LINE:\n        if (ON_STR_END(p)) {\n#ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE\n          prev = (UChar* )onigenc_get_prev_char_head(reg->enc,\n                                                     (pprev ? pprev : str), p);\n          if (prev && ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end))\n            goto retry_gate;\n#endif\n        }\n        else if (! ONIGENC_IS_MBC_NEWLINE(reg->enc, p, end)\n#ifdef USE_CRNL_AS_LINE_TERMINATOR\n                 && ! ONIGENC_IS_MBC_CRNL(reg->enc, p, end)\n#endif\n                 )\n          goto retry_gate;\n        break;\n      }\n    }\n\n    if (reg->dmax == 0) {\n      *low = p;\n      if (low_prev) {\n        if (*low > s)\n          *low_prev = onigenc_get_prev_char_head(reg->enc, s, p);\n        else\n          *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                 (pprev ? pprev : str), p);\n      }\n    }\n    else {\n      if (reg->dmax != ONIG_INFINITE_DISTANCE) {\n        *low = p - reg->dmax;\n        if (*low > s) {\n          *low = onigenc_get_right_adjust_char_head_with_prev(reg->enc, s,\n                                          *low, (const UChar** )low_prev);\n          if (low_prev && IS_NULL(*low_prev))\n            *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                   (pprev ? pprev : s), *low);\n        }\n        else {\n          if (low_prev)\n            *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                   (pprev ? pprev : str), *low);\n        }\n      }\n    }\n    /* no needs to adjust *high, *high is used as range check only */\n    *high = p - reg->dmin;\n\n#ifdef ONIG_DEBUG_SEARCH\n    fprintf(stderr,\n    \"forward_search_range success: low: %d, high: %d, dmin: %d, dmax: %d\\n\",\n\t    (int )(*low - str), (int )(*high - str), reg->dmin, reg->dmax);\n#endif\n    return 1; /* success */\n  }\n\n  return 0; /* fail */\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 3238,
    "critical_vars": [
      "p",
      "str"
    ],
    "function": "forward_search_range",
    "filename": "oniguruma/CVE-2017-9229/CVE-2017-9229_CWE-476_b690371bbf97794b4a1d3f295d4fb9a8b05d402d_regexec.c.diff",
    "function_code": "forward_search_range(regex_t* reg, const UChar* str, const UChar* end, UChar* s,\n\t\t     UChar* range, UChar** low, UChar** high, UChar** low_prev)\n{\n  UChar *p, *pprev = (UChar* )NULL;\n\n#ifdef ONIG_DEBUG_SEARCH\n  fprintf(stderr, \"forward_search_range: str: %d, end: %d, s: %d, range: %d\\n\",\n\t  (int )str, (int )end, (int )s, (int )range);\n#endif\n\n  p = s;\n  if (reg->dmin > 0) {\n    if (ONIGENC_IS_SINGLEBYTE(reg->enc)) {\n      p += reg->dmin;\n    }\n    else {\n      UChar *q = p + reg->dmin;\n\n      if (q >= end) return 0; /* fail */\n      while (p < q) p += enclen(reg->enc, p);\n    }\n  }\n\n retry:\n  switch (reg->optimize) {\n  case ONIG_OPTIMIZE_EXACT:\n    p = slow_search(reg->enc, reg->exact, reg->exact_end, p, end, range);\n    break;\n  case ONIG_OPTIMIZE_EXACT_IC:\n    p = slow_search_ic(reg->enc, reg->case_fold_flag,\n                       reg->exact, reg->exact_end, p, end, range);\n    break;\n\n  case ONIG_OPTIMIZE_EXACT_BM:\n    p = bm_search(reg, reg->exact, reg->exact_end, p, end, range);\n    break;\n\n  case ONIG_OPTIMIZE_EXACT_BM_NOT_REV:\n    p = bm_search_notrev(reg, reg->exact, reg->exact_end, p, end, range);\n    break;\n\n  case ONIG_OPTIMIZE_MAP:\n    p = map_search(reg->enc, reg->map, p, range);\n    break;\n  }\n\n  if (p && p < range) {\n    if (p - reg->dmin < s) {\n    retry_gate:\n      pprev = p;\n      p += enclen(reg->enc, p);\n      goto retry;\n    }\n\n    if (reg->sub_anchor) {\n      UChar* prev;\n\n      switch (reg->sub_anchor) {\n      case ANCHOR_BEGIN_LINE:\n        if (!ON_STR_BEGIN(p)) {\n          prev = onigenc_get_prev_char_head(reg->enc,\n                                            (pprev ? pprev : str), p);\n          if (!ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end))\n            goto retry_gate;\n        }\n        break;\n\n      case ANCHOR_END_LINE:\n        if (ON_STR_END(p)) {\n#ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE\n          prev = (UChar* )onigenc_get_prev_char_head(reg->enc,\n                                                     (pprev ? pprev : str), p);\n          if (prev && ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end))\n            goto retry_gate;\n#endif\n        }\n        else if (! ONIGENC_IS_MBC_NEWLINE(reg->enc, p, end)\n#ifdef USE_CRNL_AS_LINE_TERMINATOR\n                 && ! ONIGENC_IS_MBC_CRNL(reg->enc, p, end)\n#endif\n                 )\n          goto retry_gate;\n        break;\n      }\n    }\n\n    if (reg->dmax == 0) {\n      *low = p;\n      if (low_prev) {\n        if (*low > s)\n          *low_prev = onigenc_get_prev_char_head(reg->enc, s, p);\n        else\n          *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                 (pprev ? pprev : str), p);\n      }\n    }\n    else {\n      if (reg->dmax != ONIG_INFINITE_DISTANCE) {\n        if (p - str < reg->dmax) {\n          *low = (UChar* )str;\n          if (low_prev)\n            *low_prev = onigenc_get_prev_char_head(reg->enc, str, *low);\n        }\n        else {\n          *low = p - reg->dmax;\n          if (*low > s) {\n            *low = onigenc_get_right_adjust_char_head_with_prev(reg->enc, s,\n                                                 *low, (const UChar** )low_prev);\n            if (low_prev && IS_NULL(*low_prev))\n              *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                     (pprev ? pprev : s), *low);\n          }\n          else {\n            if (low_prev)\n              *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                     (pprev ? pprev : str), *low);\n          }\n        }\n      }\n    }\n    /* no needs to adjust *high, *high is used as range check only */\n    *high = p - reg->dmin;\n\n#ifdef ONIG_DEBUG_SEARCH\n    fprintf(stderr,\n    \"forward_search_range success: low: %d, high: %d, dmin: %d, dmax: %d\\n\",\n\t    (int )(*low - str), (int )(*high - str), reg->dmin, reg->dmax);\n#endif\n    return 1; /* success */\n  }\n\n  return 0; /* fail */\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 1310,
    "critical_vars": [
      "len"
    ],
    "function": "compile_length_bag_node",
    "filename": "oniguruma/CVE-2019-13225/CVE-2019-13225_CWE-476_c509265c5f6ae7264f7b8a8aae1cfa5fc59d108c_regcomp.c.diff",
    "function_code": "compile_length_bag_node(BagNode* node, regex_t* reg)\n{\n  int len;\n  int tlen;\n\n  if (node->type == BAG_OPTION)\n    return compile_length_option_node(node, reg);\n\n  if (NODE_BAG_BODY(node)) {\n    tlen = compile_length_tree(NODE_BAG_BODY(node), reg);\n    if (tlen < 0) return tlen;\n  }\n  else\n    tlen = 0;\n\n  switch (node->type) {\n  case BAG_MEMORY:\n#ifdef USE_CALL\n\n    if (node->m.regnum == 0 && NODE_IS_CALLED(node)) {\n      len = tlen + SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN;\n      return len;\n    }\n\n    if (NODE_IS_CALLED(node)) {\n      len = SIZE_OP_MEMORY_START_PUSH + tlen\n        + SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN;\n      if (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum))\n        len += (NODE_IS_RECURSION(node)\n                ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_PUSH);\n      else\n        len += (NODE_IS_RECURSION(node)\n                ? SIZE_OP_MEMORY_END_REC : SIZE_OP_MEMORY_END);\n    }\n    else if (NODE_IS_RECURSION(node)) {\n      len = SIZE_OP_MEMORY_START_PUSH;\n      len += tlen + (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum)\n                     ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_REC);\n    }\n    else\n#endif\n    {\n      if (MEM_STATUS_AT0(reg->bt_mem_start, node->m.regnum))\n        len = SIZE_OP_MEMORY_START_PUSH;\n      else\n        len = SIZE_OP_MEMORY_START;\n\n      len += tlen + (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum)\n                     ? SIZE_OP_MEMORY_END_PUSH : SIZE_OP_MEMORY_END);\n    }\n    break;\n\n  case BAG_STOP_BACKTRACK:\n    if (NODE_IS_STOP_BT_SIMPLE_REPEAT(node)) {\n      int v;\n      QuantNode* qn;\n\n      qn = QUANT_(NODE_BAG_BODY(node));\n      tlen = compile_length_tree(NODE_QUANT_BODY(qn), reg);\n      if (tlen < 0) return tlen;\n\n      v = onig_positive_int_multiply(qn->lower, tlen);\n      if (v < 0) return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;\n      len = v + SIZE_OP_PUSH + tlen + SIZE_OP_POP_OUT + SIZE_OP_JUMP;\n    }\n    else {\n      len = SIZE_OP_ATOMIC_START + tlen + SIZE_OP_ATOMIC_END;\n    }\n    break;\n\n  case BAG_IF_ELSE:\n    {\n      Node* cond = NODE_BAG_BODY(node);\n      Node* Then = node->te.Then;\n      Node* Else = node->te.Else;\n\n      len = compile_length_tree(cond, reg);\n      if (len < 0) return len;\n      len += SIZE_OP_PUSH;\n      len += SIZE_OP_ATOMIC_START + SIZE_OP_ATOMIC_END;\n\n      if (IS_NOT_NULL(Then)) {\n        tlen = compile_length_tree(Then, reg);\n        if (tlen < 0) return tlen;\n        len += tlen;\n      }\n\n      len += SIZE_OP_JUMP + SIZE_OP_ATOMIC_END;\n\n      if (IS_NOT_NULL(Else)) {\n        tlen = compile_length_tree(Else, reg);\n        if (tlen < 0) return tlen;\n        len += tlen;\n      }\n    }\n    break;\n\n  case BAG_OPTION:\n    /* never come here, but set for escape warning */\n    len = 0;\n    break;\n  }\n\n  return len;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 1311,
    "critical_vars": [
      "len"
    ],
    "function": "compile_length_bag_node",
    "filename": "oniguruma/CVE-2019-13225/CVE-2019-13225_CWE-476_c509265c5f6ae7264f7b8a8aae1cfa5fc59d108c_regcomp.c.diff",
    "function_code": "compile_length_bag_node(BagNode* node, regex_t* reg)\n{\n  int len;\n  int tlen;\n\n  if (node->type == BAG_OPTION)\n    return compile_length_option_node(node, reg);\n\n  if (NODE_BAG_BODY(node)) {\n    tlen = compile_length_tree(NODE_BAG_BODY(node), reg);\n    if (tlen < 0) return tlen;\n  }\n  else\n    tlen = 0;\n\n  switch (node->type) {\n  case BAG_MEMORY:\n#ifdef USE_CALL\n\n    if (node->m.regnum == 0 && NODE_IS_CALLED(node)) {\n      len = tlen + SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN;\n      return len;\n    }\n\n    if (NODE_IS_CALLED(node)) {\n      len = SIZE_OP_MEMORY_START_PUSH + tlen\n        + SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN;\n      if (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum))\n        len += (NODE_IS_RECURSION(node)\n                ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_PUSH);\n      else\n        len += (NODE_IS_RECURSION(node)\n                ? SIZE_OP_MEMORY_END_REC : SIZE_OP_MEMORY_END);\n    }\n    else if (NODE_IS_RECURSION(node)) {\n      len = SIZE_OP_MEMORY_START_PUSH;\n      len += tlen + (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum)\n                     ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_REC);\n    }\n    else\n#endif\n    {\n      if (MEM_STATUS_AT0(reg->bt_mem_start, node->m.regnum))\n        len = SIZE_OP_MEMORY_START_PUSH;\n      else\n        len = SIZE_OP_MEMORY_START;\n\n      len += tlen + (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum)\n                     ? SIZE_OP_MEMORY_END_PUSH : SIZE_OP_MEMORY_END);\n    }\n    break;\n\n  case BAG_STOP_BACKTRACK:\n    if (NODE_IS_STOP_BT_SIMPLE_REPEAT(node)) {\n      int v;\n      QuantNode* qn;\n\n      qn = QUANT_(NODE_BAG_BODY(node));\n      tlen = compile_length_tree(NODE_QUANT_BODY(qn), reg);\n      if (tlen < 0) return tlen;\n\n      v = onig_positive_int_multiply(qn->lower, tlen);\n      if (v < 0) return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;\n      len = v + SIZE_OP_PUSH + tlen + SIZE_OP_POP_OUT + SIZE_OP_JUMP;\n    }\n    else {\n      len = SIZE_OP_ATOMIC_START + tlen + SIZE_OP_ATOMIC_END;\n    }\n    break;\n\n  case BAG_IF_ELSE:\n    {\n      Node* cond = NODE_BAG_BODY(node);\n      Node* Then = node->te.Then;\n      Node* Else = node->te.Else;\n\n      len = compile_length_tree(cond, reg);\n      if (len < 0) return len;\n      len += SIZE_OP_PUSH;\n      len += SIZE_OP_ATOMIC_START + SIZE_OP_ATOMIC_END;\n\n      if (IS_NOT_NULL(Then)) {\n        tlen = compile_length_tree(Then, reg);\n        if (tlen < 0) return tlen;\n        len += tlen;\n      }\n\n      if (IS_NOT_NULL(Else)) {\n        len += SIZE_OP_JUMP;\n        tlen = compile_length_tree(Else, reg);\n        if (tlen < 0) return tlen;\n        len += tlen;\n      }\n    }\n    break;\n\n  case BAG_OPTION:\n    /* never come here, but set for escape warning */\n    len = 0;\n    break;\n  }\n\n  return len;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 1459,
    "critical_vars": [
      "else_len"
    ],
    "function": "compile_bag_node",
    "filename": "oniguruma/CVE-2019-13225/CVE-2019-13225_CWE-476_c509265c5f6ae7264f7b8a8aae1cfa5fc59d108c_regcomp.c.diff",
    "function_code": "compile_bag_node(BagNode* node, regex_t* reg, ScanEnv* env)\n{\n  int r, len;\n\n  switch (node->type) {\n  case BAG_MEMORY:\n    r = compile_bag_memory_node(node, reg, env);\n    break;\n\n  case BAG_OPTION:\n    r = compile_option_node(node, reg, env);\n    break;\n\n  case BAG_STOP_BACKTRACK:\n    if (NODE_IS_STOP_BT_SIMPLE_REPEAT(node)) {\n      QuantNode* qn = QUANT_(NODE_BAG_BODY(node));\n      r = compile_tree_n_times(NODE_QUANT_BODY(qn), qn->lower, reg, env);\n      if (r != 0) return r;\n\n      len = compile_length_tree(NODE_QUANT_BODY(qn), reg);\n      if (len < 0) return len;\n\n      r = add_op(reg, OP_PUSH);\n      if (r != 0) return r;\n      COP(reg)->push.addr = SIZE_INC_OP + len + SIZE_OP_POP_OUT + SIZE_OP_JUMP;\n\n      r = compile_tree(NODE_QUANT_BODY(qn), reg, env);\n      if (r != 0) return r;\n      r = add_op(reg, OP_POP_OUT);\n      if (r != 0) return r;\n\n      r = add_op(reg, OP_JUMP);\n      if (r != 0) return r;\n      COP(reg)->jump.addr = -((int )SIZE_OP_PUSH + len + (int )SIZE_OP_POP_OUT);\n    }\n    else {\n      r = add_op(reg, OP_ATOMIC_START);\n      if (r != 0) return r;\n      r = compile_tree(NODE_BAG_BODY(node), reg, env);\n      if (r != 0) return r;\n      r = add_op(reg, OP_ATOMIC_END);\n    }\n    break;\n\n  case BAG_IF_ELSE:\n    {\n      int cond_len, then_len, else_len, jump_len;\n      Node* cond = NODE_BAG_BODY(node);\n      Node* Then = node->te.Then;\n      Node* Else = node->te.Else;\n\n      r = add_op(reg, OP_ATOMIC_START);\n      if (r != 0) return r;\n\n      cond_len = compile_length_tree(cond, reg);\n      if (cond_len < 0) return cond_len;\n      if (IS_NOT_NULL(Then)) {\n        then_len = compile_length_tree(Then, reg);\n        if (then_len < 0) return then_len;\n      }\n      else\n        then_len = 0;\n\n      jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END + SIZE_OP_JUMP;\n\n      r = add_op(reg, OP_PUSH);\n      if (r != 0) return r;\n      COP(reg)->push.addr = SIZE_INC_OP + jump_len;\n\n      r = compile_tree(cond, reg, env);\n      if (r != 0) return r;\n      r = add_op(reg, OP_ATOMIC_END);\n      if (r != 0) return r;\n\n      if (IS_NOT_NULL(Then)) {\n        r = compile_tree(Then, reg, env);\n        if (r != 0) return r;\n      }\n\n      if (IS_NOT_NULL(Else)) {\n        else_len = compile_length_tree(Else, reg);\n        if (else_len < 0) return else_len;\n      }\n      else\n        else_len = 0;\n\n      r = add_op(reg, OP_JUMP);\n      if (r != 0) return r;\n      COP(reg)->jump.addr = SIZE_OP_ATOMIC_END + else_len + SIZE_INC_OP;\n\n      r = add_op(reg, OP_ATOMIC_END);\n      if (r != 0) return r;\n\n      if (IS_NOT_NULL(Else)) {\n        r = compile_tree(Else, reg, env);\n      }\n    }\n    break;\n  }\n\n  return r;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 1476,
    "critical_vars": [
      "Else"
    ],
    "function": "compile_bag_node",
    "filename": "oniguruma/CVE-2019-13225/CVE-2019-13225_CWE-476_c509265c5f6ae7264f7b8a8aae1cfa5fc59d108c_regcomp.c.diff",
    "function_code": "compile_bag_node(BagNode* node, regex_t* reg, ScanEnv* env)\n{\n  int r, len;\n\n  switch (node->type) {\n  case BAG_MEMORY:\n    r = compile_bag_memory_node(node, reg, env);\n    break;\n\n  case BAG_OPTION:\n    r = compile_option_node(node, reg, env);\n    break;\n\n  case BAG_STOP_BACKTRACK:\n    if (NODE_IS_STOP_BT_SIMPLE_REPEAT(node)) {\n      QuantNode* qn = QUANT_(NODE_BAG_BODY(node));\n      r = compile_tree_n_times(NODE_QUANT_BODY(qn), qn->lower, reg, env);\n      if (r != 0) return r;\n\n      len = compile_length_tree(NODE_QUANT_BODY(qn), reg);\n      if (len < 0) return len;\n\n      r = add_op(reg, OP_PUSH);\n      if (r != 0) return r;\n      COP(reg)->push.addr = SIZE_INC_OP + len + SIZE_OP_POP_OUT + SIZE_OP_JUMP;\n\n      r = compile_tree(NODE_QUANT_BODY(qn), reg, env);\n      if (r != 0) return r;\n      r = add_op(reg, OP_POP_OUT);\n      if (r != 0) return r;\n\n      r = add_op(reg, OP_JUMP);\n      if (r != 0) return r;\n      COP(reg)->jump.addr = -((int )SIZE_OP_PUSH + len + (int )SIZE_OP_POP_OUT);\n    }\n    else {\n      r = add_op(reg, OP_ATOMIC_START);\n      if (r != 0) return r;\n      r = compile_tree(NODE_BAG_BODY(node), reg, env);\n      if (r != 0) return r;\n      r = add_op(reg, OP_ATOMIC_END);\n    }\n    break;\n\n  case BAG_IF_ELSE:\n    {\n      int cond_len, then_len, jump_len;\n      Node* cond = NODE_BAG_BODY(node);\n      Node* Then = node->te.Then;\n      Node* Else = node->te.Else;\n\n      r = add_op(reg, OP_ATOMIC_START);\n      if (r != 0) return r;\n\n      cond_len = compile_length_tree(cond, reg);\n      if (cond_len < 0) return cond_len;\n      if (IS_NOT_NULL(Then)) {\n        then_len = compile_length_tree(Then, reg);\n        if (then_len < 0) return then_len;\n      }\n      else\n        then_len = 0;\n\n      jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END;\n      if (IS_NOT_NULL(Else)) jump_len += SIZE_OP_JUMP;\n\n      r = add_op(reg, OP_PUSH);\n      if (r != 0) return r;\n      COP(reg)->push.addr = SIZE_INC_OP + jump_len;\n\n      r = compile_tree(cond, reg, env);\n      if (r != 0) return r;\n      r = add_op(reg, OP_ATOMIC_END);\n      if (r != 0) return r;\n\n      if (IS_NOT_NULL(Then)) {\n        r = compile_tree(Then, reg, env);\n        if (r != 0) return r;\n      }\n\n      if (IS_NOT_NULL(Else)) {\n        int else_len = compile_length_tree(Else, reg);\n        r = add_op(reg, OP_JUMP);\n        if (r != 0) return r;\n        COP(reg)->jump.addr = else_len + SIZE_INC_OP;\n\n        r = compile_tree(Else, reg, env);\n      }\n    }\n    break;\n  }\n\n  return r;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 2571,
    "critical_vars": [
      "text[1]"
    ],
    "function": "read_escaped_char",
    "filename": "yara/CVE-2016-10210/CVE-2016-10210_CWE-476_3119b232c9c453c98d8fa8b6ae4e37ba18117cd4_re_lexer.c.diff",
    "function_code": "\nint read_escaped_char(\n    yyscan_t yyscanner,\n    uint8_t* escaped_char)\n{\n  char text[4] = {0, 0, 0, 0};\n\n  text[0] = '\\\\';\n  text[1] = RE_YY_INPUT(yyscanner);\n\n  if (text[1] == EOF || text[1] == 0)\n    return 0;\n\n  if (text[1] == 'x')\n  {\n    text[2] = RE_YY_INPUT(yyscanner);\n\n    if (!isxdigit(text[2]))\n      return 0;\n\n    text[3] = RE_YY_INPUT(yyscanner);\n\n    if (!isxdigit(text[3]))\n      return 0;\n  }\n\n  *escaped_char = escaped_char_value(text);\n\n  return 1;",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1206,
    "critical_vars": [
      "dim",
      "r"
    ],
    "function": "lookup1_values",
    "filename": "stb/CVE-2019-13219/CVE-2019-13219_CWE-476_98fdfc6df88b1e34a736d5e126e6c8139c8de1a6_stb_vorbis.c.diff",
    "function_code": "static int lookup1_values(int entries, int dim)\n{\n   int r = (int) floor(exp((float) log((float) entries) / dim));\n   if ((int) floor(pow((float) r+1, dim)) <= entries)   // (int) cast for MinGW warning;\n      ++r;                                              // floor() to avoid _ftol() when non-CRT\n   if (pow((float) r+1, dim) <= entries)\n      return -1;\n   if ((int) floor(pow((float) r, dim)) > entries)\n      return -1;\n   return r;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Fun-Call",
    "line_old": 2016,
    "line_new": 2019,
    "critical_vars": [
      "inverse_db_table[y&255]",
      "inverse_db_table[y]"
    ],
    "function": "draw_line",
    "filename": "stb/CVE-2019-13219/CVE-2019-13219_CWE-476_98fdfc6df88b1e34a736d5e126e6c8139c8de1a6_stb_vorbis.c.diff",
    "function_code": "static __forceinline void draw_line(float *output, int x0, int y0, int x1, int y1, int n)\n{\n   int dy = y1 - y0;\n   int adx = x1 - x0;\n   int ady = abs(dy);\n   int base;\n   int x=x0,y=y0;\n   int err = 0;\n   int sy;\n\n#ifdef STB_VORBIS_DIVIDE_TABLE\n   if (adx < DIVTAB_DENOM && ady < DIVTAB_NUMER) {\n      if (dy < 0) {\n         base = -integer_divide_table[ady][adx];\n         sy = base-1;\n      } else {\n         base =  integer_divide_table[ady][adx];\n         sy = base+1;\n      }\n   } else {\n      base = dy / adx;\n      if (dy < 0)\n         sy = base - 1;\n      else\n         sy = base+1;\n   }\n#else\n   base = dy / adx;\n   if (dy < 0)\n      sy = base - 1;\n   else\n      sy = base+1;\n#endif\n   ady -= abs(base) * adx;\n   if (x1 > n) x1 = n;\n   if (x < x1) {\n      LINE_OP(output[x], inverse_db_table[y&255]);\n      for (++x; x < x1; ++x) {\n         err += ady;\n         if (err >= adx) {\n            err -= adx;\n            y += sy;\n         } else\n            y += base;\n         LINE_OP(output[x], inverse_db_table[y&255]);\n      }\n   }\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 3459,
    "critical_vars": [
      "w"
    ],
    "function": "vorbis_finish_frame",
    "filename": "stb/CVE-2019-13219/CVE-2019-13219_CWE-476_98fdfc6df88b1e34a736d5e126e6c8139c8de1a6_stb_vorbis.c.diff",
    "function_code": "static int vorbis_finish_frame(stb_vorbis *f, int len, int left, int right)\n{\n   int prev,i,j;\n   // we use right&left (the start of the right- and left-window sin()-regions)\n   // to determine how much to return, rather than inferring from the rules\n   // (same result, clearer code); 'left' indicates where our sin() window\n   // starts, therefore where the previous window's right edge starts, and\n   // therefore where to start mixing from the previous buffer. 'right'\n   // indicates where our sin() ending-window starts, therefore that's where\n   // we start saving, and where our returned-data ends.\n\n   // mixin from previous window\n   if (f->previous_length) {\n      int i,j, n = f->previous_length;\n      float *w = get_window(f, n);\n      if (w == NULL) return 0;\n      for (i=0; i < f->channels; ++i) {\n         for (j=0; j < n; ++j)\n            f->channel_buffers[i][left+j] =\n               f->channel_buffers[i][left+j]*w[    j] +\n               f->previous_window[i][     j]*w[n-1-j];\n      }\n   }\n\n   prev = f->previous_length;\n\n   // last half of this data becomes previous window\n   f->previous_length = len - right;\n\n   // @OPTIMIZE: could avoid this copy by double-buffering the\n   // output (flipping previous_window with channel_buffers), but\n   // then previous_window would have to be 2x as large, and\n   // channel_buffers couldn't be temp mem (although they're NOT\n   // currently temp mem, they could be (unless we want to level\n   // performance by spreading out the computation))\n   for (i=0; i < f->channels; ++i)\n      for (j=0; right+j < len; ++j)\n         f->previous_window[i][j] = f->channel_buffers[i][right+j];\n\n   if (!prev)\n      // there was no previous packet, so this data isn't valid...\n      // this isn't entirely true, only the would-have-overlapped data\n      // isn't valid, but this seems to be what the spec requires\n      return 0;\n\n   // truncate a short frame\n   if (len < right) right = len;\n\n   f->samples_output += right-left;\n\n   return right - left;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 3701,
    "critical_vars": [
      "current_length"
    ],
    "function": "start_decoder",
    "filename": "stb/CVE-2019-13219/CVE-2019-13219_CWE-476_98fdfc6df88b1e34a736d5e126e6c8139c8de1a6_stb_vorbis.c.diff",
    "function_code": "static int start_decoder(vorb *f)\n{\n   uint8 header[6], x,y;\n   int len,i,j,k, max_submaps = 0;\n   int longest_floorlist=0;\n\n   // first page, first packet\n\n   if (!start_page(f))                              return FALSE;\n   // validate page flag\n   if (!(f->page_flag & PAGEFLAG_first_page))       return error(f, VORBIS_invalid_first_page);\n   if (f->page_flag & PAGEFLAG_last_page)           return error(f, VORBIS_invalid_first_page);\n   if (f->page_flag & PAGEFLAG_continued_packet)    return error(f, VORBIS_invalid_first_page);\n   // check for expected packet length\n   if (f->segment_count != 1)                       return error(f, VORBIS_invalid_first_page);\n   if (f->segments[0] != 30) {\n      // check for the Ogg skeleton fishead identifying header to refine our error\n      if (f->segments[0] == 64 &&\n          getn(f, header, 6) &&\n          header[0] == 'f' &&\n          header[1] == 'i' &&\n          header[2] == 's' &&\n          header[3] == 'h' &&\n          header[4] == 'e' &&\n          header[5] == 'a' &&\n          get8(f)   == 'd' &&\n          get8(f)   == '\\0')                        return error(f, VORBIS_ogg_skeleton_not_supported);\n      else\n                                                    return error(f, VORBIS_invalid_first_page);\n   }\n\n   // read packet\n   // check packet header\n   if (get8(f) != VORBIS_packet_id)                 return error(f, VORBIS_invalid_first_page);\n   if (!getn(f, header, 6))                         return error(f, VORBIS_unexpected_eof);\n   if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_first_page);\n   // vorbis_version\n   if (get32(f) != 0)                               return error(f, VORBIS_invalid_first_page);\n   f->channels = get8(f); if (!f->channels)         return error(f, VORBIS_invalid_first_page);\n   if (f->channels > STB_VORBIS_MAX_CHANNELS)       return error(f, VORBIS_too_many_channels);\n   f->sample_rate = get32(f); if (!f->sample_rate)  return error(f, VORBIS_invalid_first_page);\n   get32(f); // bitrate_maximum\n   get32(f); // bitrate_nominal\n   get32(f); // bitrate_minimum\n   x = get8(f);\n   {\n      int log0,log1;\n      log0 = x & 15;\n      log1 = x >> 4;\n      f->blocksize_0 = 1 << log0;\n      f->blocksize_1 = 1 << log1;\n      if (log0 < 6 || log0 > 13)                       return error(f, VORBIS_invalid_setup);\n      if (log1 < 6 || log1 > 13)                       return error(f, VORBIS_invalid_setup);\n      if (log0 > log1)                                 return error(f, VORBIS_invalid_setup);\n   }\n\n   // framing_flag\n   x = get8(f);\n   if (!(x & 1))                                    return error(f, VORBIS_invalid_first_page);\n\n   // second packet!\n   if (!start_page(f))                              return FALSE;\n\n   if (!start_packet(f))                            return FALSE;\n   do {\n      len = next_segment(f);\n      skip(f, len);\n      f->bytes_in_seg = 0;\n   } while (len);\n\n   // third packet!\n   if (!start_packet(f))                            return FALSE;\n\n   #ifndef STB_VORBIS_NO_PUSHDATA_API\n   if (IS_PUSH_MODE(f)) {\n      if (!is_whole_packet_present(f, TRUE)) {\n         // convert error in ogg header to write type\n         if (f->error == VORBIS_invalid_stream)\n            f->error = VORBIS_invalid_setup;\n         return FALSE;\n      }\n   }\n   #endif\n\n   crc32_init(); // always init it, to avoid multithread race conditions\n\n   if (get8_packet(f) != VORBIS_packet_setup)       return error(f, VORBIS_invalid_setup);\n   for (i=0; i < 6; ++i) header[i] = get8_packet(f);\n   if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_setup);\n\n   // codebooks\n\n   f->codebook_count = get_bits(f,8) + 1;\n   f->codebooks = (Codebook *) setup_malloc(f, sizeof(*f->codebooks) * f->codebook_count);\n   if (f->codebooks == NULL)                        return error(f, VORBIS_outofmem);\n   memset(f->codebooks, 0, sizeof(*f->codebooks) * f->codebook_count);\n   for (i=0; i < f->codebook_count; ++i) {\n      uint32 *values;\n      int ordered, sorted_count;\n      int total=0;\n      uint8 *lengths;\n      Codebook *c = f->codebooks+i;\n      CHECK(f);\n      x = get_bits(f, 8); if (x != 0x42)            return error(f, VORBIS_invalid_setup);\n      x = get_bits(f, 8); if (x != 0x43)            return error(f, VORBIS_invalid_setup);\n      x = get_bits(f, 8); if (x != 0x56)            return error(f, VORBIS_invalid_setup);\n      x = get_bits(f, 8);\n      c->dimensions = (get_bits(f, 8)<<8) + x;\n      x = get_bits(f, 8);\n      y = get_bits(f, 8);\n      c->entries = (get_bits(f, 8)<<16) + (y<<8) + x;\n      ordered = get_bits(f,1);\n      c->sparse = ordered ? 0 : get_bits(f,1);\n\n      if (c->dimensions == 0 && c->entries != 0)    return error(f, VORBIS_invalid_setup);\n\n      if (c->sparse)\n         lengths = (uint8 *) setup_temp_malloc(f, c->entries);\n      else\n         lengths = c->codeword_lengths = (uint8 *) setup_malloc(f, c->entries);\n\n      if (!lengths) return error(f, VORBIS_outofmem);\n\n      if (ordered) {\n         int current_entry = 0;\n         int current_length = get_bits(f,5) + 1;\n         while (current_entry < c->entries) {\n            int limit = c->entries - current_entry;\n            int n = get_bits(f, ilog(limit));\n            if (current_length >= 32) return error(f, VORBIS_invalid_setup);\n            if (current_entry + n > (int) c->entries) { return error(f, VORBIS_invalid_setup); }\n            memset(lengths + current_entry, current_length, n);\n            current_entry += n;\n            ++current_length;\n         }\n      } else {\n         for (j=0; j < c->entries; ++j) {\n            int present = c->sparse ? get_bits(f,1) : 1;\n            if (present) {\n               lengths[j] = get_bits(f, 5) + 1;\n               ++total;\n               if (lengths[j] == 32)\n                  return error(f, VORBIS_invalid_setup);\n            } else {\n               lengths[j] = NO_CODE;\n            }\n         }\n      }\n\n      if (c->sparse && total >= c->entries >> 2) {\n         // convert sparse items to non-sparse!\n         if (c->entries > (int) f->setup_temp_memory_required)\n            f->setup_temp_memory_required = c->entries;\n\n         c->codeword_lengths = (uint8 *) setup_malloc(f, c->entries);\n         if (c->codeword_lengths == NULL) return error(f, VORBIS_outofmem);\n         memcpy(c->codeword_lengths, lengths, c->entries);\n         setup_temp_free(f, lengths, c->entries); // note this is only safe if there have been no intervening temp mallocs!\n         lengths = c->codeword_lengths;\n         c->sparse = 0;\n      }\n\n      // compute the size of the sorted tables\n      if (c->sparse) {\n         sorted_count = total;\n      } else {\n         sorted_count = 0;\n         #ifndef STB_VORBIS_NO_HUFFMAN_BINARY_SEARCH\n         for (j=0; j < c->entries; ++j)\n            if (lengths[j] > STB_VORBIS_FAST_HUFFMAN_LENGTH && lengths[j] != NO_CODE)\n               ++sorted_count;\n         #endif\n      }\n\n      c->sorted_entries = sorted_count;\n      values = NULL;\n\n      CHECK(f);\n      if (!c->sparse) {\n         c->codewords = (uint32 *) setup_malloc(f, sizeof(c->codewords[0]) * c->entries);\n         if (!c->codewords)                  return error(f, VORBIS_outofmem);\n      } else {\n         unsigned int size;\n         if (c->sorted_entries) {\n            c->codeword_lengths = (uint8 *) setup_malloc(f, c->sorted_entries);\n            if (!c->codeword_lengths)           return error(f, VORBIS_outofmem);\n            c->codewords = (uint32 *) setup_temp_malloc(f, sizeof(*c->codewords) * c->sorted_entries);\n            if (!c->codewords)                  return error(f, VORBIS_outofmem);\n            values = (uint32 *) setup_temp_malloc(f, sizeof(*values) * c->sorted_entries);\n            if (!values)                        return error(f, VORBIS_outofmem);\n         }\n         size = c->entries + (sizeof(*c->codewords) + sizeof(*values)) * c->sorted_entries;\n         if (size > f->setup_temp_memory_required)\n            f->setup_temp_memory_required = size;\n      }\n\n      if (!compute_codewords(c, lengths, c->entries, values)) {\n         if (c->sparse) setup_temp_free(f, values, 0);\n         return error(f, VORBIS_invalid_setup);\n      }\n\n      if (c->sorted_entries) {\n         // allocate an extra slot for sentinels\n         c->sorted_codewords = (uint32 *) setup_malloc(f, sizeof(*c->sorted_codewords) * (c->sorted_entries+1));\n         if (c->sorted_codewords == NULL) return error(f, VORBIS_outofmem);\n         // allocate an extra slot at the front so that c->sorted_values[-1] is defined\n         // so that we can catch that case without an extra if\n         c->sorted_values    = ( int   *) setup_malloc(f, sizeof(*c->sorted_values   ) * (c->sorted_entries+1));\n         if (c->sorted_values == NULL) return error(f, VORBIS_outofmem);\n         ++c->sorted_values;\n         c->sorted_values[-1] = -1;\n         compute_sorted_huffman(c, lengths, values);\n      }\n\n      if (c->sparse) {\n         setup_temp_free(f, values, sizeof(*values)*c->sorted_entries);\n         setup_temp_free(f, c->codewords, sizeof(*c->codewords)*c->sorted_entries);\n         setup_temp_free(f, lengths, c->entries);\n         c->codewords = NULL;\n      }\n\n      compute_accelerated_huffman(c);\n\n      CHECK(f);\n      c->lookup_type = get_bits(f, 4);\n      if (c->lookup_type > 2) return error(f, VORBIS_invalid_setup);\n      if (c->lookup_type > 0) {\n         uint16 *mults;\n         c->minimum_value = float32_unpack(get_bits(f, 32));\n         c->delta_value = float32_unpack(get_bits(f, 32));\n         c->value_bits = get_bits(f, 4)+1;\n         c->sequence_p = get_bits(f,1);\n         if (c->lookup_type == 1) {\n            int values = lookup1_values(c->entries, c->dimensions);\n            if (values < 0) return error(f, VORBIS_invalid_setup);\n            c->lookup_values = (uint32) values;\n         } else {\n            c->lookup_values = c->entries * c->dimensions;\n         }\n         if (c->lookup_values == 0) return error(f, VORBIS_invalid_setup);\n         mults = (uint16 *) setup_temp_malloc(f, sizeof(mults[0]) * c->lookup_values);\n         if (mults == NULL) return error(f, VORBIS_outofmem);\n         for (j=0; j < (int) c->lookup_values; ++j) {\n            int q = get_bits(f, c->value_bits);\n            if (q == EOP) { setup_temp_free(f,mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_invalid_setup); }\n            mults[j] = q;\n         }\n\n#ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK\n         if (c->lookup_type == 1) {\n            int len, sparse = c->sparse;\n            float last=0;\n            // pre-expand the lookup1-style multiplicands, to avoid a divide in the inner loop\n            if (sparse) {\n               if (c->sorted_entries == 0) goto skip;\n               c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->sorted_entries * c->dimensions);\n            } else\n               c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->entries        * c->dimensions);\n            if (c->multiplicands == NULL) { setup_temp_free(f,mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_outofmem); }\n            len = sparse ? c->sorted_entries : c->entries;\n            for (j=0; j < len; ++j) {\n               unsigned int z = sparse ? c->sorted_values[j] : j;\n               unsigned int div=1;\n               for (k=0; k < c->dimensions; ++k) {\n                  int off = (z / div) % c->lookup_values;\n                  float val = mults[off];\n                  val = mults[off]*c->delta_value + c->minimum_value + last;\n                  c->multiplicands[j*c->dimensions + k] = val;\n                  if (c->sequence_p)\n                     last = val;\n                  if (k+1 < c->dimensions) {\n                     if (div > UINT_MAX / (unsigned int) c->lookup_values) {\n                        setup_temp_free(f, mults,sizeof(mults[0])*c->lookup_values);\n                        return error(f, VORBIS_invalid_setup);\n                     }\n                     div *= c->lookup_values;\n                  }\n               }\n            }\n            c->lookup_type = 2;\n         }\n         else\n#endif\n         {\n            float last=0;\n            CHECK(f);\n            c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->lookup_values);\n            if (c->multiplicands == NULL) { setup_temp_free(f, mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_outofmem); }\n            for (j=0; j < (int) c->lookup_values; ++j) {\n               float val = mults[j] * c->delta_value + c->minimum_value + last;\n               c->multiplicands[j] = val;\n               if (c->sequence_p)\n                  last = val;\n            }\n         }\n#ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK\n        skip:;\n#endif\n         setup_temp_free(f, mults, sizeof(mults[0])*c->lookup_values);\n\n         CHECK(f);\n      }\n      CHECK(f);\n   }\n\n   // time domain transfers (notused)\n\n   x = get_bits(f, 6) + 1;\n   for (i=0; i < x; ++i) {\n      uint32 z = get_bits(f, 16);\n      if (z != 0) return error(f, VORBIS_invalid_setup);\n   }\n\n   // Floors\n   f->floor_count = get_bits(f, 6)+1;\n   f->floor_config = (Floor *)  setup_malloc(f, f->floor_count * sizeof(*f->floor_config));\n   if (f->floor_config == NULL) return error(f, VORBIS_outofmem);\n   for (i=0; i < f->floor_count; ++i) {\n      f->floor_types[i] = get_bits(f, 16);\n      if (f->floor_types[i] > 1) return error(f, VORBIS_invalid_setup);\n      if (f->floor_types[i] == 0) {\n         Floor0 *g = &f->floor_config[i].floor0;\n         g->order = get_bits(f,8);\n         g->rate = get_bits(f,16);\n         g->bark_map_size = get_bits(f,16);\n         g->amplitude_bits = get_bits(f,6);\n         g->amplitude_offset = get_bits(f,8);\n         g->number_of_books = get_bits(f,4) + 1;\n         for (j=0; j < g->number_of_books; ++j)\n            g->book_list[j] = get_bits(f,8);\n         return error(f, VORBIS_feature_not_supported);\n      } else {\n         stbv__floor_ordering p[31*8+2];\n         Floor1 *g = &f->floor_config[i].floor1;\n         int max_class = -1; \n         g->partitions = get_bits(f, 5);\n         for (j=0; j < g->partitions; ++j) {\n            g->partition_class_list[j] = get_bits(f, 4);\n            if (g->partition_class_list[j] > max_class)\n               max_class = g->partition_class_list[j];\n         }\n         for (j=0; j <= max_class; ++j) {\n            g->class_dimensions[j] = get_bits(f, 3)+1;\n            g->class_subclasses[j] = get_bits(f, 2);\n            if (g->class_subclasses[j]) {\n               g->class_masterbooks[j] = get_bits(f, 8);\n               if (g->class_masterbooks[j] >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n            }\n            for (k=0; k < 1 << g->class_subclasses[j]; ++k) {\n               g->subclass_books[j][k] = get_bits(f,8)-1;\n               if (g->subclass_books[j][k] >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n            }\n         }\n         g->floor1_multiplier = get_bits(f,2)+1;\n         g->rangebits = get_bits(f,4);\n         g->Xlist[0] = 0;\n         g->Xlist[1] = 1 << g->rangebits;\n         g->values = 2;\n         for (j=0; j < g->partitions; ++j) {\n            int c = g->partition_class_list[j];\n            for (k=0; k < g->class_dimensions[c]; ++k) {\n               g->Xlist[g->values] = get_bits(f, g->rangebits);\n               ++g->values;\n            }\n         }\n         // precompute the sorting\n         for (j=0; j < g->values; ++j) {\n            p[j].x = g->Xlist[j];\n            p[j].id = j;\n         }\n         qsort(p, g->values, sizeof(p[0]), point_compare);\n         for (j=0; j < g->values-1; ++j)\n            if (p[j].x == p[j+1].x)\n               return error(f, VORBIS_invalid_setup);\n         for (j=0; j < g->values; ++j)\n            g->sorted_order[j] = (uint8) p[j].id;\n         // precompute the neighbors\n         for (j=2; j < g->values; ++j) {\n            int low,hi;\n            neighbors(g->Xlist, j, &low,&hi);\n            g->neighbors[j][0] = low;\n            g->neighbors[j][1] = hi;\n         }\n\n         if (g->values > longest_floorlist)\n            longest_floorlist = g->values;\n      }\n   }\n\n   // Residue\n   f->residue_count = get_bits(f, 6)+1;\n   f->residue_config = (Residue *) setup_malloc(f, f->residue_count * sizeof(f->residue_config[0]));\n   if (f->residue_config == NULL) return error(f, VORBIS_outofmem);\n   memset(f->residue_config, 0, f->residue_count * sizeof(f->residue_config[0]));\n   for (i=0; i < f->residue_count; ++i) {\n      uint8 residue_cascade[64];\n      Residue *r = f->residue_config+i;\n      f->residue_types[i] = get_bits(f, 16);\n      if (f->residue_types[i] > 2) return error(f, VORBIS_invalid_setup);\n      r->begin = get_bits(f, 24);\n      r->end = get_bits(f, 24);\n      if (r->end < r->begin) return error(f, VORBIS_invalid_setup);\n      r->part_size = get_bits(f,24)+1;\n      r->classifications = get_bits(f,6)+1;\n      r->classbook = get_bits(f,8);\n      if (r->classbook >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n      for (j=0; j < r->classifications; ++j) {\n         uint8 high_bits=0;\n         uint8 low_bits=get_bits(f,3);\n         if (get_bits(f,1))\n            high_bits = get_bits(f,5);\n         residue_cascade[j] = high_bits*8 + low_bits;\n      }\n      r->residue_books = (short (*)[8]) setup_malloc(f, sizeof(r->residue_books[0]) * r->classifications);\n      if (r->residue_books == NULL) return error(f, VORBIS_outofmem);\n      for (j=0; j < r->classifications; ++j) {\n         for (k=0; k < 8; ++k) {\n            if (residue_cascade[j] & (1 << k)) {\n               r->residue_books[j][k] = get_bits(f, 8);\n               if (r->residue_books[j][k] >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n            } else {\n               r->residue_books[j][k] = -1;\n            }\n         }\n      }\n      // precompute the classifications[] array to avoid inner-loop mod/divide\n      // call it 'classdata' since we already have r->classifications\n      r->classdata = (uint8 **) setup_malloc(f, sizeof(*r->classdata) * f->codebooks[r->classbook].entries);\n      if (!r->classdata) return error(f, VORBIS_outofmem);\n      memset(r->classdata, 0, sizeof(*r->classdata) * f->codebooks[r->classbook].entries);\n      for (j=0; j < f->codebooks[r->classbook].entries; ++j) {\n         int classwords = f->codebooks[r->classbook].dimensions;\n         int temp = j;\n         r->classdata[j] = (uint8 *) setup_malloc(f, sizeof(r->classdata[j][0]) * classwords);\n         if (r->classdata[j] == NULL) return error(f, VORBIS_outofmem);\n         for (k=classwords-1; k >= 0; --k) {\n            r->classdata[j][k] = temp % r->classifications;\n            temp /= r->classifications;\n         }\n      }\n   }\n\n   f->mapping_count = get_bits(f,6)+1;\n   f->mapping = (Mapping *) setup_malloc(f, f->mapping_count * sizeof(*f->mapping));\n   if (f->mapping == NULL) return error(f, VORBIS_outofmem);\n   memset(f->mapping, 0, f->mapping_count * sizeof(*f->mapping));\n   for (i=0; i < f->mapping_count; ++i) {\n      Mapping *m = f->mapping + i;      \n      int mapping_type = get_bits(f,16);\n      if (mapping_type != 0) return error(f, VORBIS_invalid_setup);\n      m->chan = (MappingChannel *) setup_malloc(f, f->channels * sizeof(*m->chan));\n      if (m->chan == NULL) return error(f, VORBIS_outofmem);\n      if (get_bits(f,1))\n         m->submaps = get_bits(f,4)+1;\n      else\n         m->submaps = 1;\n      if (m->submaps > max_submaps)\n         max_submaps = m->submaps;\n      if (get_bits(f,1)) {\n         m->coupling_steps = get_bits(f,8)+1;\n         if (m->coupling_steps > f->channels) return error(f, VORBIS_invalid_setup);\n         for (k=0; k < m->coupling_steps; ++k) {\n            m->chan[k].magnitude = get_bits(f, ilog(f->channels-1));\n            m->chan[k].angle = get_bits(f, ilog(f->channels-1));\n            if (m->chan[k].magnitude >= f->channels)        return error(f, VORBIS_invalid_setup);\n            if (m->chan[k].angle     >= f->channels)        return error(f, VORBIS_invalid_setup);\n            if (m->chan[k].magnitude == m->chan[k].angle)   return error(f, VORBIS_invalid_setup);\n         }\n      } else\n         m->coupling_steps = 0;\n\n      // reserved field\n      if (get_bits(f,2)) return error(f, VORBIS_invalid_setup);\n      if (m->submaps > 1) {\n         for (j=0; j < f->channels; ++j) {\n            m->chan[j].mux = get_bits(f, 4);\n            if (m->chan[j].mux >= m->submaps)                return error(f, VORBIS_invalid_setup);\n         }\n      } else\n         // @SPECIFICATION: this case is missing from the spec\n         for (j=0; j < f->channels; ++j)\n            m->chan[j].mux = 0;\n\n      for (j=0; j < m->submaps; ++j) {\n         get_bits(f,8); // discard\n         m->submap_floor[j] = get_bits(f,8);\n         m->submap_residue[j] = get_bits(f,8);\n         if (m->submap_floor[j] >= f->floor_count)      return error(f, VORBIS_invalid_setup);\n         if (m->submap_residue[j] >= f->residue_count)  return error(f, VORBIS_invalid_setup);\n      }\n   }\n\n   // Modes\n   f->mode_count = get_bits(f, 6)+1;\n   for (i=0; i < f->mode_count; ++i) {\n      Mode *m = f->mode_config+i;\n      m->blockflag = get_bits(f,1);\n      m->windowtype = get_bits(f,16);\n      m->transformtype = get_bits(f,16);\n      m->mapping = get_bits(f,8);\n      if (m->windowtype != 0)                 return error(f, VORBIS_invalid_setup);\n      if (m->transformtype != 0)              return error(f, VORBIS_invalid_setup);\n      if (m->mapping >= f->mapping_count)     return error(f, VORBIS_invalid_setup);\n   }\n\n   flush_packet(f);\n\n   f->previous_length = 0;\n\n   for (i=0; i < f->channels; ++i) {\n      f->channel_buffers[i] = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1);\n      f->previous_window[i] = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1/2);\n      f->finalY[i]          = (int16 *) setup_malloc(f, sizeof(int16) * longest_floorlist);\n      if (f->channel_buffers[i] == NULL || f->previous_window[i] == NULL || f->finalY[i] == NULL) return error(f, VORBIS_outofmem);\n      memset(f->channel_buffers[i], 0, sizeof(float) * f->blocksize_1);\n      #ifdef STB_VORBIS_NO_DEFER_FLOOR\n      f->floor_buffers[i]   = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1/2);\n      if (f->floor_buffers[i] == NULL) return error(f, VORBIS_outofmem);\n      #endif\n   }\n\n   if (!init_blocksize(f, 0, f->blocksize_0)) return FALSE;\n   if (!init_blocksize(f, 1, f->blocksize_1)) return FALSE;\n   f->blocksize[0] = f->blocksize_0;\n   f->blocksize[1] = f->blocksize_1;\n\n#ifdef STB_VORBIS_DIVIDE_TABLE\n   if (integer_divide_table[1][1]==0)\n      for (i=0; i < DIVTAB_NUMER; ++i)\n         for (j=1; j < DIVTAB_DENOM; ++j)\n            integer_divide_table[i][j] = i / j;\n#endif\n\n   // compute how much temporary memory is needed\n\n   // 1.\n   {\n      uint32 imdct_mem = (f->blocksize_1 * sizeof(float) >> 1);\n      uint32 classify_mem;\n      int i,max_part_read=0;\n      for (i=0; i < f->residue_count; ++i) {\n         Residue *r = f->residue_config + i;\n         unsigned int actual_size = f->blocksize_1 / 2;\n         unsigned int limit_r_begin = r->begin < actual_size ? r->begin : actual_size;\n         unsigned int limit_r_end   = r->end   < actual_size ? r->end   : actual_size;\n         int n_read = limit_r_end - limit_r_begin;\n         int part_read = n_read / r->part_size;\n         if (part_read > max_part_read)\n            max_part_read = part_read;\n      }\n      #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n      classify_mem = f->channels * (sizeof(void*) + max_part_read * sizeof(uint8 *));\n      #else\n      classify_mem = f->channels * (sizeof(void*) + max_part_read * sizeof(int *));\n      #endif\n\n      // maximum reasonable partition size is f->blocksize_1\n\n      f->temp_memory_required = classify_mem;\n      if (imdct_mem > f->temp_memory_required)\n         f->temp_memory_required = imdct_mem;\n   }\n\n   f->first_decode = TRUE;\n\n   if (f->alloc.alloc_buffer) {\n      assert(f->temp_offset == f->alloc.alloc_buffer_length_in_bytes);\n      // check if there's enough temp memory so we don't error later\n      if (f->setup_offset + sizeof(*f) + f->temp_memory_required > (unsigned) f->temp_offset)\n         return error(f, VORBIS_outofmem);\n   }\n\n   f->first_audio_page_offset = stb_vorbis_get_file_offset(f);\n\n   return TRUE;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 3801,
    "critical_vars": [
      "c->lookup_values"
    ],
    "function": "start_decoder",
    "filename": "stb/CVE-2019-13219/CVE-2019-13219_CWE-476_98fdfc6df88b1e34a736d5e126e6c8139c8de1a6_stb_vorbis.c.diff",
    "function_code": "static int start_decoder(vorb *f)\n{\n   uint8 header[6], x,y;\n   int len,i,j,k, max_submaps = 0;\n   int longest_floorlist=0;\n\n   // first page, first packet\n\n   if (!start_page(f))                              return FALSE;\n   // validate page flag\n   if (!(f->page_flag & PAGEFLAG_first_page))       return error(f, VORBIS_invalid_first_page);\n   if (f->page_flag & PAGEFLAG_last_page)           return error(f, VORBIS_invalid_first_page);\n   if (f->page_flag & PAGEFLAG_continued_packet)    return error(f, VORBIS_invalid_first_page);\n   // check for expected packet length\n   if (f->segment_count != 1)                       return error(f, VORBIS_invalid_first_page);\n   if (f->segments[0] != 30) {\n      // check for the Ogg skeleton fishead identifying header to refine our error\n      if (f->segments[0] == 64 &&\n          getn(f, header, 6) &&\n          header[0] == 'f' &&\n          header[1] == 'i' &&\n          header[2] == 's' &&\n          header[3] == 'h' &&\n          header[4] == 'e' &&\n          header[5] == 'a' &&\n          get8(f)   == 'd' &&\n          get8(f)   == '\\0')                        return error(f, VORBIS_ogg_skeleton_not_supported);\n      else\n                                                    return error(f, VORBIS_invalid_first_page);\n   }\n\n   // read packet\n   // check packet header\n   if (get8(f) != VORBIS_packet_id)                 return error(f, VORBIS_invalid_first_page);\n   if (!getn(f, header, 6))                         return error(f, VORBIS_unexpected_eof);\n   if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_first_page);\n   // vorbis_version\n   if (get32(f) != 0)                               return error(f, VORBIS_invalid_first_page);\n   f->channels = get8(f); if (!f->channels)         return error(f, VORBIS_invalid_first_page);\n   if (f->channels > STB_VORBIS_MAX_CHANNELS)       return error(f, VORBIS_too_many_channels);\n   f->sample_rate = get32(f); if (!f->sample_rate)  return error(f, VORBIS_invalid_first_page);\n   get32(f); // bitrate_maximum\n   get32(f); // bitrate_nominal\n   get32(f); // bitrate_minimum\n   x = get8(f);\n   {\n      int log0,log1;\n      log0 = x & 15;\n      log1 = x >> 4;\n      f->blocksize_0 = 1 << log0;\n      f->blocksize_1 = 1 << log1;\n      if (log0 < 6 || log0 > 13)                       return error(f, VORBIS_invalid_setup);\n      if (log1 < 6 || log1 > 13)                       return error(f, VORBIS_invalid_setup);\n      if (log0 > log1)                                 return error(f, VORBIS_invalid_setup);\n   }\n\n   // framing_flag\n   x = get8(f);\n   if (!(x & 1))                                    return error(f, VORBIS_invalid_first_page);\n\n   // second packet!\n   if (!start_page(f))                              return FALSE;\n\n   if (!start_packet(f))                            return FALSE;\n   do {\n      len = next_segment(f);\n      skip(f, len);\n      f->bytes_in_seg = 0;\n   } while (len);\n\n   // third packet!\n   if (!start_packet(f))                            return FALSE;\n\n   #ifndef STB_VORBIS_NO_PUSHDATA_API\n   if (IS_PUSH_MODE(f)) {\n      if (!is_whole_packet_present(f, TRUE)) {\n         // convert error in ogg header to write type\n         if (f->error == VORBIS_invalid_stream)\n            f->error = VORBIS_invalid_setup;\n         return FALSE;\n      }\n   }\n   #endif\n\n   crc32_init(); // always init it, to avoid multithread race conditions\n\n   if (get8_packet(f) != VORBIS_packet_setup)       return error(f, VORBIS_invalid_setup);\n   for (i=0; i < 6; ++i) header[i] = get8_packet(f);\n   if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_setup);\n\n   // codebooks\n\n   f->codebook_count = get_bits(f,8) + 1;\n   f->codebooks = (Codebook *) setup_malloc(f, sizeof(*f->codebooks) * f->codebook_count);\n   if (f->codebooks == NULL)                        return error(f, VORBIS_outofmem);\n   memset(f->codebooks, 0, sizeof(*f->codebooks) * f->codebook_count);\n   for (i=0; i < f->codebook_count; ++i) {\n      uint32 *values;\n      int ordered, sorted_count;\n      int total=0;\n      uint8 *lengths;\n      Codebook *c = f->codebooks+i;\n      CHECK(f);\n      x = get_bits(f, 8); if (x != 0x42)            return error(f, VORBIS_invalid_setup);\n      x = get_bits(f, 8); if (x != 0x43)            return error(f, VORBIS_invalid_setup);\n      x = get_bits(f, 8); if (x != 0x56)            return error(f, VORBIS_invalid_setup);\n      x = get_bits(f, 8);\n      c->dimensions = (get_bits(f, 8)<<8) + x;\n      x = get_bits(f, 8);\n      y = get_bits(f, 8);\n      c->entries = (get_bits(f, 8)<<16) + (y<<8) + x;\n      ordered = get_bits(f,1);\n      c->sparse = ordered ? 0 : get_bits(f,1);\n\n      if (c->dimensions == 0 && c->entries != 0)    return error(f, VORBIS_invalid_setup);\n\n      if (c->sparse)\n         lengths = (uint8 *) setup_temp_malloc(f, c->entries);\n      else\n         lengths = c->codeword_lengths = (uint8 *) setup_malloc(f, c->entries);\n\n      if (!lengths) return error(f, VORBIS_outofmem);\n\n      if (ordered) {\n         int current_entry = 0;\n         int current_length = get_bits(f,5) + 1;\n         while (current_entry < c->entries) {\n            int limit = c->entries - current_entry;\n            int n = get_bits(f, ilog(limit));\n            if (current_entry + n > (int) c->entries) { return error(f, VORBIS_invalid_setup); }\n            memset(lengths + current_entry, current_length, n);\n            current_entry += n;\n            ++current_length;\n         }\n      } else {\n         for (j=0; j < c->entries; ++j) {\n            int present = c->sparse ? get_bits(f,1) : 1;\n            if (present) {\n               lengths[j] = get_bits(f, 5) + 1;\n               ++total;\n               if (lengths[j] == 32)\n                  return error(f, VORBIS_invalid_setup);\n            } else {\n               lengths[j] = NO_CODE;\n            }\n         }\n      }\n\n      if (c->sparse && total >= c->entries >> 2) {\n         // convert sparse items to non-sparse!\n         if (c->entries > (int) f->setup_temp_memory_required)\n            f->setup_temp_memory_required = c->entries;\n\n         c->codeword_lengths = (uint8 *) setup_malloc(f, c->entries);\n         if (c->codeword_lengths == NULL) return error(f, VORBIS_outofmem);\n         memcpy(c->codeword_lengths, lengths, c->entries);\n         setup_temp_free(f, lengths, c->entries); // note this is only safe if there have been no intervening temp mallocs!\n         lengths = c->codeword_lengths;\n         c->sparse = 0;\n      }\n\n      // compute the size of the sorted tables\n      if (c->sparse) {\n         sorted_count = total;\n      } else {\n         sorted_count = 0;\n         #ifndef STB_VORBIS_NO_HUFFMAN_BINARY_SEARCH\n         for (j=0; j < c->entries; ++j)\n            if (lengths[j] > STB_VORBIS_FAST_HUFFMAN_LENGTH && lengths[j] != NO_CODE)\n               ++sorted_count;\n         #endif\n      }\n\n      c->sorted_entries = sorted_count;\n      values = NULL;\n\n      CHECK(f);\n      if (!c->sparse) {\n         c->codewords = (uint32 *) setup_malloc(f, sizeof(c->codewords[0]) * c->entries);\n         if (!c->codewords)                  return error(f, VORBIS_outofmem);\n      } else {\n         unsigned int size;\n         if (c->sorted_entries) {\n            c->codeword_lengths = (uint8 *) setup_malloc(f, c->sorted_entries);\n            if (!c->codeword_lengths)           return error(f, VORBIS_outofmem);\n            c->codewords = (uint32 *) setup_temp_malloc(f, sizeof(*c->codewords) * c->sorted_entries);\n            if (!c->codewords)                  return error(f, VORBIS_outofmem);\n            values = (uint32 *) setup_temp_malloc(f, sizeof(*values) * c->sorted_entries);\n            if (!values)                        return error(f, VORBIS_outofmem);\n         }\n         size = c->entries + (sizeof(*c->codewords) + sizeof(*values)) * c->sorted_entries;\n         if (size > f->setup_temp_memory_required)\n            f->setup_temp_memory_required = size;\n      }\n\n      if (!compute_codewords(c, lengths, c->entries, values)) {\n         if (c->sparse) setup_temp_free(f, values, 0);\n         return error(f, VORBIS_invalid_setup);\n      }\n\n      if (c->sorted_entries) {\n         // allocate an extra slot for sentinels\n         c->sorted_codewords = (uint32 *) setup_malloc(f, sizeof(*c->sorted_codewords) * (c->sorted_entries+1));\n         if (c->sorted_codewords == NULL) return error(f, VORBIS_outofmem);\n         // allocate an extra slot at the front so that c->sorted_values[-1] is defined\n         // so that we can catch that case without an extra if\n         c->sorted_values    = ( int   *) setup_malloc(f, sizeof(*c->sorted_values   ) * (c->sorted_entries+1));\n         if (c->sorted_values == NULL) return error(f, VORBIS_outofmem);\n         ++c->sorted_values;\n         c->sorted_values[-1] = -1;\n         compute_sorted_huffman(c, lengths, values);\n      }\n\n      if (c->sparse) {\n         setup_temp_free(f, values, sizeof(*values)*c->sorted_entries);\n         setup_temp_free(f, c->codewords, sizeof(*c->codewords)*c->sorted_entries);\n         setup_temp_free(f, lengths, c->entries);\n         c->codewords = NULL;\n      }\n\n      compute_accelerated_huffman(c);\n\n      CHECK(f);\n      c->lookup_type = get_bits(f, 4);\n      if (c->lookup_type > 2) return error(f, VORBIS_invalid_setup);\n      if (c->lookup_type > 0) {\n         uint16 *mults;\n         c->minimum_value = float32_unpack(get_bits(f, 32));\n         c->delta_value = float32_unpack(get_bits(f, 32));\n         c->value_bits = get_bits(f, 4)+1;\n         c->sequence_p = get_bits(f,1);\n         if (c->lookup_type == 1) {\n            c->lookup_values = lookup1_values(c->entries, c->dimensions);\n         } else {\n            c->lookup_values = c->entries * c->dimensions;\n         }\n         if (c->lookup_values == 0) return error(f, VORBIS_invalid_setup);\n         mults = (uint16 *) setup_temp_malloc(f, sizeof(mults[0]) * c->lookup_values);\n         if (mults == NULL) return error(f, VORBIS_outofmem);\n         for (j=0; j < (int) c->lookup_values; ++j) {\n            int q = get_bits(f, c->value_bits);\n            if (q == EOP) { setup_temp_free(f,mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_invalid_setup); }\n            mults[j] = q;\n         }\n\n#ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK\n         if (c->lookup_type == 1) {\n            int len, sparse = c->sparse;\n            float last=0;\n            // pre-expand the lookup1-style multiplicands, to avoid a divide in the inner loop\n            if (sparse) {\n               if (c->sorted_entries == 0) goto skip;\n               c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->sorted_entries * c->dimensions);\n            } else\n               c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->entries        * c->dimensions);\n            if (c->multiplicands == NULL) { setup_temp_free(f,mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_outofmem); }\n            len = sparse ? c->sorted_entries : c->entries;\n            for (j=0; j < len; ++j) {\n               unsigned int z = sparse ? c->sorted_values[j] : j;\n               unsigned int div=1;\n               for (k=0; k < c->dimensions; ++k) {\n                  int off = (z / div) % c->lookup_values;\n                  float val = mults[off];\n                  val = mults[off]*c->delta_value + c->minimum_value + last;\n                  c->multiplicands[j*c->dimensions + k] = val;\n                  if (c->sequence_p)\n                     last = val;\n                  if (k+1 < c->dimensions) {\n                     if (div > UINT_MAX / (unsigned int) c->lookup_values) {\n                        setup_temp_free(f, mults,sizeof(mults[0])*c->lookup_values);\n                        return error(f, VORBIS_invalid_setup);\n                     }\n                     div *= c->lookup_values;\n                  }\n               }\n            }\n            c->lookup_type = 2;\n         }\n         else\n#endif\n         {\n            float last=0;\n            CHECK(f);\n            c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->lookup_values);\n            if (c->multiplicands == NULL) { setup_temp_free(f, mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_outofmem); }\n            for (j=0; j < (int) c->lookup_values; ++j) {\n               float val = mults[j] * c->delta_value + c->minimum_value + last;\n               c->multiplicands[j] = val;\n               if (c->sequence_p)\n                  last = val;\n            }\n         }\n#ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK\n        skip:;\n#endif\n         setup_temp_free(f, mults, sizeof(mults[0])*c->lookup_values);\n\n         CHECK(f);\n      }\n      CHECK(f);\n   }\n\n   // time domain transfers (notused)\n\n   x = get_bits(f, 6) + 1;\n   for (i=0; i < x; ++i) {\n      uint32 z = get_bits(f, 16);\n      if (z != 0) return error(f, VORBIS_invalid_setup);\n   }\n\n   // Floors\n   f->floor_count = get_bits(f, 6)+1;\n   f->floor_config = (Floor *)  setup_malloc(f, f->floor_count * sizeof(*f->floor_config));\n   if (f->floor_config == NULL) return error(f, VORBIS_outofmem);\n   for (i=0; i < f->floor_count; ++i) {\n      f->floor_types[i] = get_bits(f, 16);\n      if (f->floor_types[i] > 1) return error(f, VORBIS_invalid_setup);\n      if (f->floor_types[i] == 0) {\n         Floor0 *g = &f->floor_config[i].floor0;\n         g->order = get_bits(f,8);\n         g->rate = get_bits(f,16);\n         g->bark_map_size = get_bits(f,16);\n         g->amplitude_bits = get_bits(f,6);\n         g->amplitude_offset = get_bits(f,8);\n         g->number_of_books = get_bits(f,4) + 1;\n         for (j=0; j < g->number_of_books; ++j)\n            g->book_list[j] = get_bits(f,8);\n         return error(f, VORBIS_feature_not_supported);\n      } else {\n         stbv__floor_ordering p[31*8+2];\n         Floor1 *g = &f->floor_config[i].floor1;\n         int max_class = -1; \n         g->partitions = get_bits(f, 5);\n         for (j=0; j < g->partitions; ++j) {\n            g->partition_class_list[j] = get_bits(f, 4);\n            if (g->partition_class_list[j] > max_class)\n               max_class = g->partition_class_list[j];\n         }\n         for (j=0; j <= max_class; ++j) {\n            g->class_dimensions[j] = get_bits(f, 3)+1;\n            g->class_subclasses[j] = get_bits(f, 2);\n            if (g->class_subclasses[j]) {\n               g->class_masterbooks[j] = get_bits(f, 8);\n               if (g->class_masterbooks[j] >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n            }\n            for (k=0; k < 1 << g->class_subclasses[j]; ++k) {\n               g->subclass_books[j][k] = get_bits(f,8)-1;\n               if (g->subclass_books[j][k] >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n            }\n         }\n         g->floor1_multiplier = get_bits(f,2)+1;\n         g->rangebits = get_bits(f,4);\n         g->Xlist[0] = 0;\n         g->Xlist[1] = 1 << g->rangebits;\n         g->values = 2;\n         for (j=0; j < g->partitions; ++j) {\n            int c = g->partition_class_list[j];\n            for (k=0; k < g->class_dimensions[c]; ++k) {\n               g->Xlist[g->values] = get_bits(f, g->rangebits);\n               ++g->values;\n            }\n         }\n         // precompute the sorting\n         for (j=0; j < g->values; ++j) {\n            p[j].x = g->Xlist[j];\n            p[j].id = j;\n         }\n         qsort(p, g->values, sizeof(p[0]), point_compare);\n         for (j=0; j < g->values; ++j)\n            g->sorted_order[j] = (uint8) p[j].id;\n         // precompute the neighbors\n         for (j=2; j < g->values; ++j) {\n            int low,hi;\n            neighbors(g->Xlist, j, &low,&hi);\n            g->neighbors[j][0] = low;\n            g->neighbors[j][1] = hi;\n         }\n\n         if (g->values > longest_floorlist)\n            longest_floorlist = g->values;\n      }\n   }\n\n   // Residue\n   f->residue_count = get_bits(f, 6)+1;\n   f->residue_config = (Residue *) setup_malloc(f, f->residue_count * sizeof(f->residue_config[0]));\n   if (f->residue_config == NULL) return error(f, VORBIS_outofmem);\n   memset(f->residue_config, 0, f->residue_count * sizeof(f->residue_config[0]));\n   for (i=0; i < f->residue_count; ++i) {\n      uint8 residue_cascade[64];\n      Residue *r = f->residue_config+i;\n      f->residue_types[i] = get_bits(f, 16);\n      if (f->residue_types[i] > 2) return error(f, VORBIS_invalid_setup);\n      r->begin = get_bits(f, 24);\n      r->end = get_bits(f, 24);\n      if (r->end < r->begin) return error(f, VORBIS_invalid_setup);\n      r->part_size = get_bits(f,24)+1;\n      r->classifications = get_bits(f,6)+1;\n      r->classbook = get_bits(f,8);\n      if (r->classbook >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n      for (j=0; j < r->classifications; ++j) {\n         uint8 high_bits=0;\n         uint8 low_bits=get_bits(f,3);\n         if (get_bits(f,1))\n            high_bits = get_bits(f,5);\n         residue_cascade[j] = high_bits*8 + low_bits;\n      }\n      r->residue_books = (short (*)[8]) setup_malloc(f, sizeof(r->residue_books[0]) * r->classifications);\n      if (r->residue_books == NULL) return error(f, VORBIS_outofmem);\n      for (j=0; j < r->classifications; ++j) {\n         for (k=0; k < 8; ++k) {\n            if (residue_cascade[j] & (1 << k)) {\n               r->residue_books[j][k] = get_bits(f, 8);\n               if (r->residue_books[j][k] >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n            } else {\n               r->residue_books[j][k] = -1;\n            }\n         }\n      }\n      // precompute the classifications[] array to avoid inner-loop mod/divide\n      // call it 'classdata' since we already have r->classifications\n      r->classdata = (uint8 **) setup_malloc(f, sizeof(*r->classdata) * f->codebooks[r->classbook].entries);\n      if (!r->classdata) return error(f, VORBIS_outofmem);\n      memset(r->classdata, 0, sizeof(*r->classdata) * f->codebooks[r->classbook].entries);\n      for (j=0; j < f->codebooks[r->classbook].entries; ++j) {\n         int classwords = f->codebooks[r->classbook].dimensions;\n         int temp = j;\n         r->classdata[j] = (uint8 *) setup_malloc(f, sizeof(r->classdata[j][0]) * classwords);\n         if (r->classdata[j] == NULL) return error(f, VORBIS_outofmem);\n         for (k=classwords-1; k >= 0; --k) {\n            r->classdata[j][k] = temp % r->classifications;\n            temp /= r->classifications;\n         }\n      }\n   }\n\n   f->mapping_count = get_bits(f,6)+1;\n   f->mapping = (Mapping *) setup_malloc(f, f->mapping_count * sizeof(*f->mapping));\n   if (f->mapping == NULL) return error(f, VORBIS_outofmem);\n   memset(f->mapping, 0, f->mapping_count * sizeof(*f->mapping));\n   for (i=0; i < f->mapping_count; ++i) {\n      Mapping *m = f->mapping + i;      \n      int mapping_type = get_bits(f,16);\n      if (mapping_type != 0) return error(f, VORBIS_invalid_setup);\n      m->chan = (MappingChannel *) setup_malloc(f, f->channels * sizeof(*m->chan));\n      if (m->chan == NULL) return error(f, VORBIS_outofmem);\n      if (get_bits(f,1))\n         m->submaps = get_bits(f,4)+1;\n      else\n         m->submaps = 1;\n      if (m->submaps > max_submaps)\n         max_submaps = m->submaps;\n      if (get_bits(f,1)) {\n         m->coupling_steps = get_bits(f,8)+1;\n         for (k=0; k < m->coupling_steps; ++k) {\n            m->chan[k].magnitude = get_bits(f, ilog(f->channels-1));\n            m->chan[k].angle = get_bits(f, ilog(f->channels-1));\n            if (m->chan[k].magnitude >= f->channels)        return error(f, VORBIS_invalid_setup);\n            if (m->chan[k].angle     >= f->channels)        return error(f, VORBIS_invalid_setup);\n            if (m->chan[k].magnitude == m->chan[k].angle)   return error(f, VORBIS_invalid_setup);\n         }\n      } else\n         m->coupling_steps = 0;\n\n      // reserved field\n      if (get_bits(f,2)) return error(f, VORBIS_invalid_setup);\n      if (m->submaps > 1) {\n         for (j=0; j < f->channels; ++j) {\n            m->chan[j].mux = get_bits(f, 4);\n            if (m->chan[j].mux >= m->submaps)                return error(f, VORBIS_invalid_setup);\n         }\n      } else\n         // @SPECIFICATION: this case is missing from the spec\n         for (j=0; j < f->channels; ++j)\n            m->chan[j].mux = 0;\n\n      for (j=0; j < m->submaps; ++j) {\n         get_bits(f,8); // discard\n         m->submap_floor[j] = get_bits(f,8);\n         m->submap_residue[j] = get_bits(f,8);\n         if (m->submap_floor[j] >= f->floor_count)      return error(f, VORBIS_invalid_setup);\n         if (m->submap_residue[j] >= f->residue_count)  return error(f, VORBIS_invalid_setup);\n      }\n   }\n\n   // Modes\n   f->mode_count = get_bits(f, 6)+1;\n   for (i=0; i < f->mode_count; ++i) {\n      Mode *m = f->mode_config+i;\n      m->blockflag = get_bits(f,1);\n      m->windowtype = get_bits(f,16);\n      m->transformtype = get_bits(f,16);\n      m->mapping = get_bits(f,8);\n      if (m->windowtype != 0)                 return error(f, VORBIS_invalid_setup);\n      if (m->transformtype != 0)              return error(f, VORBIS_invalid_setup);\n      if (m->mapping >= f->mapping_count)     return error(f, VORBIS_invalid_setup);\n   }\n\n   flush_packet(f);\n\n   f->previous_length = 0;\n\n   for (i=0; i < f->channels; ++i) {\n      f->channel_buffers[i] = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1);\n      f->previous_window[i] = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1/2);\n      f->finalY[i]          = (int16 *) setup_malloc(f, sizeof(int16) * longest_floorlist);\n      if (f->channel_buffers[i] == NULL || f->previous_window[i] == NULL || f->finalY[i] == NULL) return error(f, VORBIS_outofmem);\n      memset(f->channel_buffers[i], 0, sizeof(float) * f->blocksize_1);\n      #ifdef STB_VORBIS_NO_DEFER_FLOOR\n      f->floor_buffers[i]   = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1/2);\n      if (f->floor_buffers[i] == NULL) return error(f, VORBIS_outofmem);\n      #endif\n   }\n\n   if (!init_blocksize(f, 0, f->blocksize_0)) return FALSE;\n   if (!init_blocksize(f, 1, f->blocksize_1)) return FALSE;\n   f->blocksize[0] = f->blocksize_0;\n   f->blocksize[1] = f->blocksize_1;\n\n#ifdef STB_VORBIS_DIVIDE_TABLE\n   if (integer_divide_table[1][1]==0)\n      for (i=0; i < DIVTAB_NUMER; ++i)\n         for (j=1; j < DIVTAB_DENOM; ++j)\n            integer_divide_table[i][j] = i / j;\n#endif\n\n   // compute how much temporary memory is needed\n\n   // 1.\n   {\n      uint32 imdct_mem = (f->blocksize_1 * sizeof(float) >> 1);\n      uint32 classify_mem;\n      int i,max_part_read=0;\n      for (i=0; i < f->residue_count; ++i) {\n         Residue *r = f->residue_config + i;\n         unsigned int actual_size = f->blocksize_1 / 2;\n         unsigned int limit_r_begin = r->begin < actual_size ? r->begin : actual_size;\n         unsigned int limit_r_end   = r->end   < actual_size ? r->end   : actual_size;\n         int n_read = limit_r_end - limit_r_begin;\n         int part_read = n_read / r->part_size;\n         if (part_read > max_part_read)\n            max_part_read = part_read;\n      }\n      #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n      classify_mem = f->channels * (sizeof(void*) + max_part_read * sizeof(uint8 *));\n      #else\n      classify_mem = f->channels * (sizeof(void*) + max_part_read * sizeof(int *));\n      #endif\n\n      // maximum reasonable partition size is f->blocksize_1\n\n      f->temp_memory_required = classify_mem;\n      if (imdct_mem > f->temp_memory_required)\n         f->temp_memory_required = imdct_mem;\n   }\n\n   f->first_decode = TRUE;\n\n   if (f->alloc.alloc_buffer) {\n      assert(f->temp_offset == f->alloc.alloc_buffer_length_in_bytes);\n      // check if there's enough temp memory so we don't error later\n      if (f->setup_offset + sizeof(*f) + f->temp_memory_required > (unsigned) f->temp_offset)\n         return error(f, VORBIS_outofmem);\n   }\n\n   f->first_audio_page_offset = stb_vorbis_get_file_offset(f);\n\n   return TRUE;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 720,
    "critical_vars": [
      "rdp",
      "length",
      "s->p"
    ],
    "function": "rdp_decrypt",
    "filename": "FreeRDP/CVE-2013-4118/CVE-2013-4118_CWE-476_7d58aac24fe20ffaad7bd9b40c9ddf457c1b06e7_rdp.c.diff",
    "function_code": "BOOL rdp_decrypt(rdpRdp* rdp, STREAM* s, int length, UINT16 securityFlags)\n{\n\tBYTE cmac[8];\n\tBYTE wmac[8];\n\n\tif (rdp->settings->EncryptionMethods == ENCRYPTION_METHOD_FIPS)\n\t{\n\t\tUINT16 len;\n\t\tBYTE version, pad;\n\t\tBYTE* sig;\n\n\t\tif (stream_get_left(s) < 12)\n\t\t\treturn FALSE;\n\n\t\tstream_read_UINT16(s, len); /* 0x10 */\n\t\tstream_read_BYTE(s, version); /* 0x1 */\n\t\tstream_read_BYTE(s, pad);\n\n\t\tsig = s->p;\n\t\tstream_seek(s, 8);\t/* signature */\n\n\t\tlength -= 12;\n\n\t\tif (!security_fips_decrypt(s->p, length, rdp))\n\t\t{\n\t\t\tprintf(\"FATAL: cannot decrypt\\n\");\n\t\t\treturn FALSE; /* TODO */\n\t\t}\n\n\t\tif (!security_fips_check_signature(s->p, length - pad, sig, rdp))\n\t\t{\n\t\t\tprintf(\"FATAL: invalid packet signature\\n\");\n\t\t\treturn FALSE; /* TODO */\n\t\t}\n\n\t\t/* is this what needs adjusting? */\n\t\ts->size -= pad;\n\t\treturn TRUE;\n\t}\n\n\tif (stream_get_left(s) < 8)\n\t\treturn FALSE;\n\n\tstream_read(s, wmac, sizeof(wmac));\n\tlength -= sizeof(wmac);\n\tsecurity_decrypt(s->p, length, rdp);\n\n\tif (securityFlags & SEC_SECURE_CHECKSUM)\n\t\tsecurity_salted_mac_signature(rdp, s->p, length, FALSE, cmac);\n\telse\n\t\tsecurity_mac_signature(rdp, s->p, length, cmac);\n\n\tif (memcmp(wmac, cmac, sizeof(wmac)) != 0)\n\t{\n\t\tprintf(\"WARNING: invalid packet signature\\n\");\n\t\t/*\n\t\t * Because Standard RDP Security is totally broken,\n\t\t * and cannot protect against MITM, don't treat signature\n\t\t * verification failure as critical. This at least enables\n\t\t * us to work with broken RDP clients and servers that\n\t\t * generate invalid signatures.\n\t\t */\n\t\t//return FALSE;\n\t}\n\n\treturn TRUE;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 720,
    "critical_vars": [
      "rdp",
      "length",
      "s->p"
    ],
    "function": "rdp_decrypt",
    "filename": "FreeRDP/CVE-2013-4118/CVE-2013-4118_CWE-476_7d58aac24fe20ffaad7bd9b40c9ddf457c1b06e7_rdp.c.diff",
    "function_code": "BOOL rdp_decrypt(rdpRdp* rdp, STREAM* s, int length, UINT16 securityFlags)\n{\n\tBYTE cmac[8];\n\tBYTE wmac[8];\n\n\tif (rdp->settings->EncryptionMethods == ENCRYPTION_METHOD_FIPS)\n\t{\n\t\tUINT16 len;\n\t\tBYTE version, pad;\n\t\tBYTE* sig;\n\n\t\tif (stream_get_left(s) < 12)\n\t\t\treturn FALSE;\n\n\t\tstream_read_UINT16(s, len); /* 0x10 */\n\t\tstream_read_BYTE(s, version); /* 0x1 */\n\t\tstream_read_BYTE(s, pad);\n\n\t\tsig = s->p;\n\t\tstream_seek(s, 8);\t/* signature */\n\n\t\tlength -= 12;\n\n\t\tif (!security_fips_decrypt(s->p, length, rdp))\n\t\t{\n\t\t\tprintf(\"FATAL: cannot decrypt\\n\");\n\t\t\treturn FALSE; /* TODO */\n\t\t}\n\n\t\tif (!security_fips_check_signature(s->p, length - pad, sig, rdp))\n\t\t{\n\t\t\tprintf(\"FATAL: invalid packet signature\\n\");\n\t\t\treturn FALSE; /* TODO */\n\t\t}\n\n\t\t/* is this what needs adjusting? */\n\t\ts->size -= pad;\n\t\treturn TRUE;\n\t}\n\n\tif (stream_get_left(s) < 8)\n\t\treturn FALSE;\n\n\tstream_read(s, wmac, sizeof(wmac));\n\tlength -= sizeof(wmac);\n\tif (!security_decrypt(s->p, length, rdp))\n\t\treturn FALSE;\n\n\tif (securityFlags & SEC_SECURE_CHECKSUM)\n\t\tsecurity_salted_mac_signature(rdp, s->p, length, FALSE, cmac);\n\telse\n\t\tsecurity_mac_signature(rdp, s->p, length, cmac);\n\n\tif (memcmp(wmac, cmac, sizeof(wmac)) != 0)\n\t{\n\t\tprintf(\"WARNING: invalid packet signature\\n\");\n\t\t/*\n\t\t * Because Standard RDP Security is totally broken,\n\t\t * and cannot protect against MITM, don't treat signature\n\t\t * verification failure as critical. This at least enables\n\t\t * us to work with broken RDP clients and servers that\n\t\t * generate invalid signatures.\n\t\t */\n\t\t//return FALSE;\n\t}\n\n\treturn TRUE;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 1248,
    "critical_vars": [
      "&credssp->context"
    ],
    "function": "credssp_new",
    "filename": "FreeRDP/CVE-2013-4119/CVE-2013-4119_CWE-476_0773bb9303d24473fe1185d85a424dfe159aff53_nla.c.diff",
    "function_code": "rdpCredssp* credssp_new(freerdp* instance, rdpTransport* transport, rdpSettings* settings)\n{\n\trdpCredssp* credssp;\n\n\tcredssp = (rdpCredssp*) malloc(sizeof(rdpCredssp));\n\tZeroMemory(credssp, sizeof(rdpCredssp));\n\n\tif (credssp != NULL)\n\t{\n\t\tHKEY hKey;\n\t\tLONG status;\n\t\tDWORD dwType;\n\t\tDWORD dwSize;\n\n\t\tcredssp->instance = instance;\n\t\tcredssp->settings = settings;\n\t\tcredssp->server = settings->ServerMode;\n\t\tcredssp->transport = transport;\n\t\tcredssp->send_seq_num = 0;\n\t\tcredssp->recv_seq_num = 0;\n\t\tZeroMemory(&credssp->negoToken, sizeof(SecBuffer));\n\t\tZeroMemory(&credssp->pubKeyAuth, sizeof(SecBuffer));\n\t\tZeroMemory(&credssp->authInfo, sizeof(SecBuffer));\n\t\tSecInvalidateHandle(&credssp->context);\n\n\t\tif (credssp->server)\n\t\t{\n\t\t\tstatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T(\"Software\\\\FreeRDP\\\\Server\"),\n\t\t\t\t\t0, KEY_READ | KEY_WOW64_64KEY, &hKey);\n\n\t\t\tif (status == ERROR_SUCCESS)\n\t\t\t{\n\t\t\t\tstatus = RegQueryValueEx(hKey, _T(\"SspiModule\"), NULL, &dwType, NULL, &dwSize);\n\n\t\t\t\tif (status == ERROR_SUCCESS)\n\t\t\t\t{\n\t\t\t\t\tcredssp->SspiModule = (LPTSTR) malloc(dwSize + sizeof(TCHAR));\n\n\t\t\t\t\tstatus = RegQueryValueEx(hKey, _T(\"SspiModule\"), NULL, &dwType,\n\t\t\t\t\t\t\t(BYTE*) credssp->SspiModule, &dwSize);\n\n\t\t\t\t\tif (status == ERROR_SUCCESS)\n\t\t\t\t\t{\n\t\t\t\t\t\t_tprintf(_T(\"Using SSPI Module: %s\\n\"), credssp->SspiModule);\n\t\t\t\t\t\tRegCloseKey(hKey);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn credssp;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 162,
    "critical_vars": [
      "transport->credssp"
    ],
    "function": "transport_connect_nla",
    "filename": "FreeRDP/CVE-2013-4119/CVE-2013-4119_CWE-476_0773bb9303d24473fe1185d85a424dfe159aff53_transport.c.diff",
    "function_code": "BOOL transport_connect_nla(rdpTransport* transport)\n{\n\tfreerdp* instance;\n\trdpSettings* settings;\n\n\tif (transport->layer == TRANSPORT_LAYER_TSG)\n\t\treturn TRUE;\n\n\tif (!transport_connect_tls(transport))\n\t\treturn FALSE;\n\n\t/* Network Level Authentication */\n\n\tif (transport->settings->Authentication != TRUE)\n\t\treturn TRUE;\n\n\tsettings = transport->settings;\n\tinstance = (freerdp*) settings->instance;\n\n\tif (transport->credssp == NULL)\n\t\ttransport->credssp = credssp_new(instance, transport, settings);\n\n\tif (credssp_authenticate(transport->credssp) < 0)\n\t{\n\t\tif (!connectErrorCode)\n\t\t\tconnectErrorCode = AUTHENTICATIONERROR;\n\n\t\tfprintf(stderr, \"Authentication failure, check credentials.\\n\"\n\t\t\t\"If credentials are valid, the NTLMSSP implementation may be to blame.\\n\");\n\n\t\tcredssp_free(transport->credssp);\n\t\ttransport->credssp = NULL;\n\t\treturn FALSE;\n\t}\n\n\tcredssp_free(transport->credssp);\n\n\treturn TRUE;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 296,
    "critical_vars": [
      "transport->credssp"
    ],
    "function": "transport_accept_nla",
    "filename": "FreeRDP/CVE-2013-4119/CVE-2013-4119_CWE-476_0773bb9303d24473fe1185d85a424dfe159aff53_transport.c.diff",
    "function_code": "BOOL transport_accept_nla(rdpTransport* transport)\n{\n\tfreerdp* instance;\n\trdpSettings* settings;\n\n\tif (transport->TlsIn == NULL)\n\t\ttransport->TlsIn = tls_new(transport->settings);\n\n\tif (transport->TlsOut == NULL)\n\t\ttransport->TlsOut = transport->TlsIn;\n\n\ttransport->layer = TRANSPORT_LAYER_TLS;\n\ttransport->TlsIn->sockfd = transport->TcpIn->sockfd;\n\n\tif (tls_accept(transport->TlsIn, transport->settings->CertificateFile, transport->settings->PrivateKeyFile) != TRUE)\n\t\treturn FALSE;\n\n\t/* Network Level Authentication */\n\n\tif (transport->settings->Authentication != TRUE)\n\t\treturn TRUE;\n\n\tsettings = transport->settings;\n\tinstance = (freerdp*) settings->instance;\n\n\tif (transport->credssp == NULL)\n\t\ttransport->credssp = credssp_new(instance, transport, settings);\n\n\tif (credssp_authenticate(transport->credssp) < 0)\n\t{\n\t\tfprintf(stderr, \"client authentication failure\\n\");\n\t\tcredssp_free(transport->credssp);\n\t\ttransport->credssp = NULL;\n\t\treturn FALSE;\n\t}\n\n\t/* don't free credssp module yet, we need to copy the credentials from it first */\n\n\treturn TRUE;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 251,
    "critical_vars": [
      "handle"
    ],
    "function": "sspi_SecureHandleGetLowerPointer",
    "filename": "FreeRDP/CVE-2013-4119/CVE-2013-4119_CWE-476_0773bb9303d24473fe1185d85a424dfe159aff53_sspi.c.diff",
    "function_code": "void* sspi_SecureHandleGetLowerPointer(SecHandle* handle)\n{\n\tvoid* pointer;\n\n\tif (!handle || !SecIsValidHandle(handle))\n\t\treturn NULL;\n\n\tpointer = (void*) ~((size_t) handle->dwLower);\n\n\treturn pointer;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 271,
    "critical_vars": [
      "handle"
    ],
    "function": "sspi_SecureHandleGetUpperPointer",
    "filename": "FreeRDP/CVE-2013-4119/CVE-2013-4119_CWE-476_0773bb9303d24473fe1185d85a424dfe159aff53_sspi.c.diff",
    "function_code": "void* sspi_SecureHandleGetUpperPointer(SecHandle* handle)\n{\n\tvoid* pointer;\n\n\tif (!handle || !SecIsValidHandle(handle))\n\t\treturn NULL;\n\n\tpointer = (void*) ~((size_t) handle->dwUpper);\n\n\treturn pointer;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 275,
    "critical_vars": [
      "rdp->nego->transport->credssp"
    ],
    "function": "peer_recv_callback",
    "filename": "FreeRDP/CVE-2013-4119/CVE-2013-4119_CWE-476_0773bb9303d24473fe1185d85a424dfe159aff53_peer.c.diff",
    "function_code": "static int peer_recv_callback(rdpTransport* transport, wStream* s, void* extra)\n{\n\tfreerdp_peer* client = (freerdp_peer*) extra;\n\trdpRdp* rdp = client->context->rdp;\n\n\tswitch (rdp->state)\n\t{\n\t\tcase CONNECTION_STATE_INITIAL:\n\t\t\tif (!rdp_server_accept_nego(rdp, s))\n\t\t\t\treturn -1;\n\n\t\t\tif (rdp->nego->selected_protocol & PROTOCOL_NLA)\n\t\t\t{\n\t\t\t\tsspi_CopyAuthIdentity(&client->identity, &(rdp->nego->transport->credssp->identity));\n\t\t\t\tIFCALLRET(client->Logon, client->authenticated, client, &client->identity, TRUE);\n\t\t\t\tcredssp_free(rdp->nego->transport->credssp);\n\t\t\t\trdp->nego->transport->credssp = NULL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tIFCALLRET(client->Logon, client->authenticated, client, &client->identity, FALSE);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_NEGO:\n\t\t\tif (!rdp_server_accept_mcs_connect_initial(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_CONNECT:\n\t\t\tif (!rdp_server_accept_mcs_erect_domain_request(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_ERECT_DOMAIN:\n\t\t\tif (!rdp_server_accept_mcs_attach_user_request(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_ATTACH_USER:\n\t\t\tif (!rdp_server_accept_mcs_channel_join_request(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_CHANNEL_JOIN:\n\t\t\tif (rdp->settings->DisableEncryption)\n\t\t\t{\n\t\t\t\tif (!rdp_server_accept_client_keys(rdp, s))\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trdp->state = CONNECTION_STATE_ESTABLISH_KEYS;\n\t\t\t/* FALLTHROUGH */\n\n\t\tcase CONNECTION_STATE_ESTABLISH_KEYS:\n\t\t\tif (!rdp_server_accept_client_info(rdp, s))\n\t\t\t\treturn -1;\n\n\t\t\tIFCALL(client->Capabilities, client);\n\n\t\t\tif (!rdp_send_demand_active(rdp))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_LICENSE:\n\t\t\tif (!rdp_server_accept_confirm_active(rdp, s))\n\t\t\t{\n\t\t\t\t/**\n\t\t\t\t * During reactivation sequence the client might sent some input or channel data\n\t\t\t\t * before receiving the Deactivate All PDU. We need to process them as usual.\n\t\t\t\t */\n\t\t\t\tStream_SetPosition(s, 0);\n\t\t\t\treturn peer_recv_pdu(client, s);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_ACTIVE:\n\t\t\tif (peer_recv_pdu(client, s) < 0)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Invalid state %d\\n\", rdp->state);\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 664,
    "critical_vars": [
      "text"
    ],
    "function": "escape_xml",
    "filename": "exif/CVE-2021-27815/CVE-2021-27815_CWE-476_f6334d9d32437ef13dc902f0a88a2be0063d9d1c_actions.c.diff",
    "function_code": "escape_xml(const char *text)\n{\n\tstatic char *escaped;\n\tstatic size_t escaped_size;\n\tchar *out;\n\tsize_t len;\n\n\tif (!strlen(text)) return \"empty string\";\n\n\tfor (out=escaped, len=0; *text; ++len, ++out, ++text) {\n\t\t/* Make sure there's plenty of room for a quoted character */\n\t\tif ((len + 8) > escaped_size) {\n\t\t\tchar *bigger_escaped;\n\t\t\tescaped_size += 128;\n\t\t\tbigger_escaped = realloc(escaped, escaped_size);\n\t\t\tif (!bigger_escaped) {\n\t\t\t\tfree(escaped);\t/* avoid leaking memory */\n\t\t\t\tescaped = NULL;\n\t\t\t\tescaped_size = 0;\n\t\t\t\t/* Error string is cleverly chosen to fail XML validation */\n\t\t\t\treturn \">>> out of memory <<<\";\n\t\t\t}\n\t\t\tout = bigger_escaped + len;\n\t\t\tescaped = bigger_escaped;\n\t\t}\n\t\tswitch (*text) {\n\t\t\tcase '&':\n\t\t\t\tstrcpy(out, \"&amp;\");\n\t\t\t\tlen += strlen(out) - 1;\n\t\t\t\tout = escaped + len;\n\t\t\t\tbreak;\n\t\t\tcase '<':\n\t\t\t\tstrcpy(out, \"&lt;\");\n\t\t\t\tlen += strlen(out) - 1;\n\t\t\t\tout = escaped + len;\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\tstrcpy(out, \"&gt;\");\n\t\t\t\tlen += strlen(out) - 1;\n\t\t\t\tout = escaped + len;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t*out = *text;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t*out = '\\x0';  /* NUL terminate the string */\n\treturn escaped;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 1237,
    "critical_vars": [
      "Message"
    ],
    "function": "CClient::OnTextMessage",
    "filename": "znc/CVE-2020-13775/CVE-2020-13775_CWE-476_d229761821da38d984a9e4098ad96842490dc001_Client.cpp.diff",
    "function_code": "bool CClient::OnTextMessage(CTextMessage& Message) {\n    CString sTargets = Message.GetTarget();\n\n    VCString vTargets;\n    sTargets.Split(\",\", vTargets, false);\n\n    for (CString& sTarget : vTargets) {\n        Message.SetTarget(sTarget);\n        if (m_pNetwork) {\n            // May be nullptr.\n            Message.SetChan(m_pNetwork->FindChan(sTarget));\n        }\n\n        if (sTarget.TrimPrefix(m_pUser->GetStatusPrefix())) {\n            EchoMessage(Message);\n\n            if (sTarget.Equals(\"status\")) {\n                CString sMsg = Message.GetText();\n                UserCommand(sMsg);\n            } else {\n                CALLMOD(sTarget, this, m_pUser, m_pNetwork,\n                        OnModCommand(Message.GetText()));\n            }\n            continue;\n        }\n\n        bool bContinue = false;\n        NETWORKMODULECALL(OnUserTextMessage(Message), m_pUser, m_pNetwork, this,\n                          &bContinue);\n        if (bContinue) continue;\n\n        if (!GetIRCSock()) {\n            // Some lagmeters do a PRIVMSG to their own nick, ignore those.\n            if (!sTarget.Equals(m_sNick))\n                PutStatus(\n                    t_f(\"Your message to {1} got lost, you are not connected \"\n                        \"to IRC!\")(Message.GetTarget()));\n            continue;\n        }\n\n        if (m_pNetwork) {\n            AddBuffer(Message);\n            EchoMessage(Message);\n            PutIRC(Message.ToString(CMessage::ExcludePrefix |\n                                    CMessage::ExcludeTags));\n        }\n    }\n\n    return true;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 285,
    "critical_vars": [
      "table",
      "&parsed_url_in",
      "eventURLPath"
    ],
    "function": "*FindServiceEventURLPath",
    "filename": "pupnp/CVE-2020-13848/CVE-2020-13848_CWE-476_c805c1de1141cb22f74c0d94dd5664bda37398e0_service_table.c.diff",
    "function_code": "service_info *FindServiceEventURLPath(\n\tservice_table *table, const char *eventURLPath)\n{\n\tservice_info *finger = NULL;\n\turi_type parsed_url;\n\turi_type parsed_url_in;\n\n\tif (table &&\n\t\tparse_uri(eventURLPath, strlen(eventURLPath), &parsed_url_in) ==\n\t\t\tHTTP_SUCCESS) {\n\t\tfinger = table->serviceList;\n\t\twhile (finger) {\n\t\t\tif (finger->eventURL) {\n\t\t\t\tif (parse_uri(finger->eventURL,\n\t\t\t\t\t    strlen(finger->eventURL),\n\t\t\t\t\t    &parsed_url) == HTTP_SUCCESS) {\n\t\t\t\t\tif (!token_cmp(&parsed_url.pathquery,\n\t\t\t\t\t\t    &parsed_url_in.pathquery)) {\n\t\t\t\t\t\treturn finger;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinger = finger->next;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 285,
    "critical_vars": [
      "eventURLPath",
      "table"
    ],
    "function": "*FindServiceEventURLPath",
    "filename": "pupnp/CVE-2020-13848/CVE-2020-13848_CWE-476_c805c1de1141cb22f74c0d94dd5664bda37398e0_service_table.c.diff",
    "function_code": "service_info *FindServiceEventURLPath(\n\tservice_table *table, const char *eventURLPath)\n{\n\tservice_info *finger = NULL;\n\turi_type parsed_url;\n\turi_type parsed_url_in;\n\n\tif (!table || !eventURLPath) {\n\t\treturn NULL;\n\t}\n\tif (parse_uri(eventURLPath, strlen(eventURLPath), &parsed_url_in) ==\n\t\tHTTP_SUCCESS) {\n\t\tfinger = table->serviceList;\n\t\twhile (finger) {\n\t\t\tif (finger->eventURL) {\n\t\t\t\tif (parse_uri(finger->eventURL,\n\t\t\t\t\t    strlen(finger->eventURL),\n\t\t\t\t\t    &parsed_url) == HTTP_SUCCESS) {\n\t\t\t\t\tif (!token_cmp(&parsed_url.pathquery,\n\t\t\t\t\t\t    &parsed_url_in.pathquery)) {\n\t\t\t\t\t\treturn finger;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinger = finger->next;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 330,
    "critical_vars": [
      "table",
      "controlURLPath",
      "&parsed_url_in"
    ],
    "function": "*FindServiceControlURLPath",
    "filename": "pupnp/CVE-2020-13848/CVE-2020-13848_CWE-476_c805c1de1141cb22f74c0d94dd5664bda37398e0_service_table.c.diff",
    "function_code": "service_info *FindServiceControlURLPath(\n\tservice_table *table, const char *controlURLPath)\n{\n\tservice_info *finger = NULL;\n\turi_type parsed_url;\n\turi_type parsed_url_in;\n\n\tif (table && parse_uri(controlURLPath,\n\t\t\t     strlen(controlURLPath),\n\t\t\t     &parsed_url_in) == HTTP_SUCCESS) {\n\t\tfinger = table->serviceList;\n\t\twhile (finger) {\n\t\t\tif (finger->controlURL) {\n\t\t\t\tif (parse_uri(finger->controlURL,\n\t\t\t\t\t    strlen(finger->controlURL),\n\t\t\t\t\t    &parsed_url) == HTTP_SUCCESS) {\n\t\t\t\t\tif (!token_cmp(&parsed_url.pathquery,\n\t\t\t\t\t\t    &parsed_url_in.pathquery)) {\n\t\t\t\t\t\treturn finger;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinger = finger->next;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 332,
    "critical_vars": [
      "table",
      "controlURLPath"
    ],
    "function": "*FindServiceControlURLPath",
    "filename": "pupnp/CVE-2020-13848/CVE-2020-13848_CWE-476_c805c1de1141cb22f74c0d94dd5664bda37398e0_service_table.c.diff",
    "function_code": "service_info *FindServiceControlURLPath(\n\tservice_table *table, const char *controlURLPath)\n{\n\tservice_info *finger = NULL;\n\turi_type parsed_url;\n\turi_type parsed_url_in;\n\n\tif (!table || !controlURLPath) {\n\t\treturn NULL;\n\t}\n\tif (parse_uri(controlURLPath, strlen(controlURLPath), &parsed_url_in) ==\n\t\tHTTP_SUCCESS) {\n\t\tfinger = table->serviceList;\n\t\twhile (finger) {\n\t\t\tif (finger->controlURL) {\n\t\t\t\tif (parse_uri(finger->controlURL,\n\t\t\t\t\t    strlen(finger->controlURL),\n\t\t\t\t\t    &parsed_url) == HTTP_SUCCESS) {\n\t\t\t\t\tif (!token_cmp(&parsed_url.pathquery,\n\t\t\t\t\t\t    &parsed_url_in.pathquery)) {\n\t\t\t\t\t\treturn finger;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinger = finger->next;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1606,
    "critical_vars": [
      "val"
    ],
    "function": "gen_hash",
    "filename": "mruby/CVE-2022-0481/CVE-2022-0481_CWE-476_ae3c99767a27f5c6c584162e2adc6a5d0eb2c54e_codegen.c.diff",
    "function_code": "gen_hash(codegen_scope *s, node *tree, int val, int limit)\n{\n  int slimit = GEN_VAL_STACK_MAX;\n  if (cursp() >= GEN_LIT_ARY_MAX) slimit = INT16_MAX;\n  int len = 0;\n  mrb_bool update = FALSE;\n\n  while (tree) {\n    if (nint(tree->car->car->car) == NODE_KW_REST_ARGS) {\n      if (len > 0) {\n        pop_n(len*2);\n        if (!update) {\n          genop_2(s, OP_HASH, cursp(), len);\n        }\n        else {\n          pop();\n          genop_2(s, OP_HASHADD, cursp(), len);\n        }\n        push();\n      }\n      codegen(s, tree->car->cdr, val);\n      if (len > 0 || update) {\n        pop(); pop();\n        genop_1(s, OP_HASHCAT, cursp());\n        push();\n      }\n      update = TRUE;\n      len = 0;\n    }\n    else {\n      codegen(s, tree->car->car, val);\n      codegen(s, tree->car->cdr, val);\n      len++;\n    }\n    tree = tree->cdr;\n    if (val && cursp() >= slimit) {\n      pop_n(len*2);\n      if (!update) {\n        genop_2(s, OP_HASH, cursp(), len);\n      }\n      else {\n        pop();\n        genop_2(s, OP_HASHADD, cursp(), len);\n      }\n      push();\n      update = TRUE;\n      len = 0;\n    }\n  }\n  if (update) {\n    if (val && len > 0) {\n      pop_n(len*2+1);\n      genop_2(s, OP_HASHADD, cursp(), len);\n      push();\n    }\n    return -1;                  /* variable length */\n  }\n  return len;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 1654,
    "critical_vars": [
      "update"
    ],
    "function": "gen_hash",
    "filename": "mruby/CVE-2022-0326/CVE-2022-0326_CWE-476_b611c43a5de061ec21b343967e1b64c45c373d7e_codegen.c.diff",
    "function_code": "gen_hash(codegen_scope *s, node *tree, int val, int limit)\n{\n  int slimit = GEN_VAL_STACK_MAX;\n  if (cursp() >= GEN_LIT_ARY_MAX) slimit = INT16_MAX;\n  int len = 0;\n  mrb_bool update = FALSE;\n\n  while (tree) {\n    if (nint(tree->car->car->car) == NODE_KW_REST_ARGS) {\n      if (len > 0) {\n        pop_n(len*2);\n        if (!update) {\n          genop_2(s, OP_HASH, cursp(), len);\n        }\n        else {\n          pop();\n          genop_2(s, OP_HASHADD, cursp(), len);\n        }\n        push();\n      }\n      codegen(s, tree->car->cdr, val);\n      if (len > 0 || update) {\n        pop(); pop();\n        genop_1(s, OP_HASHCAT, cursp());\n        push();\n      }\n      update = TRUE;\n      len = 0;\n    }\n    else {\n      codegen(s, tree->car->car, val);\n      codegen(s, tree->car->cdr, val);\n      len++;\n    }\n    tree = tree->cdr;\n    if (val && cursp() >= slimit) {\n      pop_n(len*2);\n      if (!update) {\n        genop_2(s, OP_HASH, cursp(), len);\n      }\n      else {\n        pop();\n        genop_2(s, OP_HASHADD, cursp(), len);\n      }\n      push();\n      update = TRUE;\n      len = 0;\n    }\n  }\n  if (update) {\n    if (len > 0) {\n      pop_n(len*2+1);\n      genop_2(s, OP_HASHADD, cursp(), len);\n      push();\n    }\n    return -1;                  /* variable length */\n  }\n  if (update) return -1;\n  return len;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 212,
    "critical_vars": [
      "a->upper"
    ],
    "function": "mrb_proc_copy",
    "filename": "mruby/CVE-2021-4110/CVE-2021-4110_CWE-476_f5e10c5a79a17939af763b1dcf5232ce47e24a34_proc.c.diff",
    "function_code": "mrb_proc_copy(mrb_state *mrb, struct RProc *a, struct RProc *b)\n{\n  if (a->body.irep) {\n    /* already initialized proc */\n    return;\n  }\n  a->flags = b->flags;\n  a->body = b->body;\n  a->upper = b->upper;\n  if (!MRB_PROC_CFUNC_P(a) && a->body.irep) {\n    mrb_irep_incref(mrb, (mrb_irep*)a->body.irep);\n  }\n  a->e.env = b->e.env;\n  /* a->e.target_class = a->e.target_class; */\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 215,
    "critical_vars": [
      "a->upper"
    ],
    "function": "mrb_proc_copy",
    "filename": "mruby/CVE-2021-4110/CVE-2021-4110_CWE-476_f5e10c5a79a17939af763b1dcf5232ce47e24a34_proc.c.diff",
    "function_code": "mrb_proc_copy(struct RProc *a, struct RProc *b)\n{\n  if (a->body.irep) {\n    /* already initialized proc */\n    return;\n  }\n  a->flags = b->flags;\n  a->body = b->body;\n  if (!MRB_PROC_CFUNC_P(a) && a->body.irep) {\n    mrb_irep_incref(NULL, (mrb_irep*)a->body.irep);\n  }\n  a->upper = b->upper;\n  a->e.env = b->e.env;\n  /* a->e.target_class = a->e.target_class; */\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 230,
    "critical_vars": [
      "mrb"
    ],
    "function": "mrb_proc_s_new",
    "filename": "mruby/CVE-2021-4110/CVE-2021-4110_CWE-476_f5e10c5a79a17939af763b1dcf5232ce47e24a34_proc.c.diff",
    "function_code": "mrb_proc_s_new(mrb_state *mrb, mrb_value proc_class)\n{\n  mrb_value blk;\n  mrb_value proc;\n  struct RProc *p;\n\n  /* Calling Proc.new without a block is not implemented yet */\n  mrb_get_args(mrb, \"&!\", &blk);\n  p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb_class_ptr(proc_class));\n  mrb_proc_copy(mrb, p, mrb_proc_ptr(blk));\n  proc = mrb_obj_value(p);\n  mrb_funcall_with_block(mrb, proc, MRB_SYM(initialize), 0, NULL, proc);\n  if (!MRB_PROC_STRICT_P(p) &&\n      mrb->c->ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb->c->ci[-1].u.env) {\n    p->flags |= MRB_PROC_ORPHAN;\n  }\n  return proc;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 248,
    "critical_vars": [
      "mrb"
    ],
    "function": "mrb_proc_init_copy",
    "filename": "mruby/CVE-2021-4110/CVE-2021-4110_CWE-476_f5e10c5a79a17939af763b1dcf5232ce47e24a34_proc.c.diff",
    "function_code": "mrb_proc_init_copy(mrb_state *mrb, mrb_value self)\n{\n  mrb_value proc = mrb_get_arg1(mrb);\n\n  if (!mrb_proc_p(proc)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"not a proc\");\n  }\n  mrb_proc_copy(mrb, mrb_proc_ptr(self), mrb_proc_ptr(proc));\n  return self;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 284,
    "critical_vars": [
      "mrb"
    ],
    "function": "proc_lambda",
    "filename": "mruby/CVE-2021-4110/CVE-2021-4110_CWE-476_f5e10c5a79a17939af763b1dcf5232ce47e24a34_proc.c.diff",
    "function_code": "proc_lambda(mrb_state *mrb, mrb_value self)\n{\n  mrb_value blk;\n  struct RProc *p;\n\n  mrb_get_args(mrb, \"&\", &blk);\n  if (mrb_nil_p(blk)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"tried to create Proc object without a block\");\n  }\n  if (!mrb_proc_p(blk)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"not a proc\");\n  }\n  p = mrb_proc_ptr(blk);\n  if (!MRB_PROC_STRICT_P(p)) {\n    struct RProc *p2 = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, p->c);\n    mrb_proc_copy(mrb, p2, p);\n    p2->flags |= MRB_PROC_STRICT;\n    return mrb_obj_value(p2);\n  }\n  return blk;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 2572,
    "critical_vars": [
      "mrb"
    ],
    "function": "mrb_mod_define_method_m",
    "filename": "mruby/CVE-2021-4110/CVE-2021-4110_CWE-476_f5e10c5a79a17939af763b1dcf5232ce47e24a34_class.c.diff",
    "function_code": "mrb_mod_define_method_m(mrb_state *mrb, struct RClass *c)\n{\n  struct RProc *p;\n  mrb_method_t m;\n  mrb_sym mid;\n  mrb_value proc = mrb_undef_value();\n  mrb_value blk;\n\n  mrb_get_args(mrb, \"n|o&\", &mid, &proc, &blk);\n  switch (mrb_type(proc)) {\n    case MRB_TT_PROC:\n      blk = proc;\n      break;\n    case MRB_TT_UNDEF:\n      /* ignored */\n      break;\n    default:\n      mrb_raisef(mrb, E_TYPE_ERROR, \"wrong argument type %T (expected Proc)\", proc);\n      break;\n  }\n  if (mrb_nil_p(blk)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"no block given\");\n  }\n  p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb->proc_class);\n  mrb_proc_copy(mrb, p, mrb_proc_ptr(blk));\n  p->flags |= MRB_PROC_STRICT;\n  MRB_METHOD_FROM_PROC(m, p);\n  mrb_define_method_raw(mrb, c, mid, m);\n  mrb_method_added(mrb, c, mid);\n  return mrb_symbol_value(mid);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1686,
    "critical_vars": [
      "obj->c"
    ],
    "function": "mrb_singleton_class_ptr",
    "filename": "mruby/CVE-2022-0240/CVE-2022-0240_CWE-476_31fa3304049fc406a201a72293cce140f0557dca_class.c.diff",
    "function_code": "mrb_singleton_class_ptr(mrb_state *mrb, mrb_value v)\n{\n  struct RBasic *obj;\n\n  switch (mrb_type(v)) {\n  case MRB_TT_FALSE:\n    if (mrb_nil_p(v))\n      return mrb->nil_class;\n    return mrb->false_class;\n  case MRB_TT_TRUE:\n    return mrb->true_class;\n  case MRB_TT_CPTR:\n  case MRB_TT_SYMBOL:\n  case MRB_TT_INTEGER:\n#ifndef MRB_NO_FLOAT\n  case MRB_TT_FLOAT:\n#endif\n    return NULL;\n  default:\n    break;\n  }\n  obj = mrb_basic_ptr(v);\n  if (obj->c == NULL) return NULL;\n  prepare_singleton_class(mrb, obj);\n  return obj->c;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 351,
    "line_new": 351,
    "critical_vars": [
      "p->flags"
    ],
    "function": "mrb_obj_clone",
    "filename": "mruby/CVE-2018-12247/CVE-2018-12247_CWE-476_55edae0226409de25e59922807cb09acb45731a2_kernel.c.diff",
    "function_code": "mrb_obj_clone(mrb_state *mrb, mrb_value self)\n{\n  struct RObject *p;\n  mrb_value clone;\n\n  if (mrb_immediate_p(self)) {\n    mrb_raisef(mrb, E_TYPE_ERROR, \"can't clone %S\", self);\n  }\n  if (mrb_type(self) == MRB_TT_SCLASS) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't clone singleton class\");\n  }\n  p = (struct RObject*)mrb_obj_alloc(mrb, mrb_type(self), mrb_obj_class(mrb, self));\n  p->c = mrb_singleton_class_clone(mrb, self);\n  mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)p->c);\n  clone = mrb_obj_value(p);\n  init_copy(mrb, clone, self);\n  p->flags |= mrb_obj_ptr(self)->flags & MRB_FLAG_IS_FROZEN;\n\n  return clone;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 211,
    "critical_vars": [
      "mrb",
      "len"
    ],
    "function": "fiber_switch",
    "filename": "mruby/CVE-2022-0890/CVE-2022-0890_CWE-476_da48e7dbb20024c198493b8724adae1b842083aa_fiber.c.diff",
    "function_code": "fiber_switch(mrb_state *mrb, mrb_value self, mrb_int len, const mrb_value *a, mrb_bool resume, mrb_bool vmexec)\n{\n  struct mrb_context *c = fiber_check(mrb, self);\n  struct mrb_context *old_c = mrb->c;\n  enum mrb_fiber_state status;\n  mrb_value value;\n\n  fiber_check_cfunc(mrb, c);\n  status = c->status;\n  switch (status) {\n  case MRB_FIBER_TRANSFERRED:\n    if (resume) {\n      mrb_raise(mrb, E_FIBER_ERROR, \"resuming transferred fiber\");\n    }\n    break;\n  case MRB_FIBER_RUNNING:\n  case MRB_FIBER_RESUMED:\n    mrb_raise(mrb, E_FIBER_ERROR, \"double resume\");\n    break;\n  case MRB_FIBER_TERMINATED:\n    mrb_raise(mrb, E_FIBER_ERROR, \"resuming dead fiber\");\n    break;\n  default:\n    break;\n  }\n  old_c->status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED;\n  c->prev = resume ? mrb->c : (c->prev ? c->prev : mrb->root_c);\n  fiber_switch_context(mrb, c);\n  if (status == MRB_FIBER_CREATED) {\n    mrb_value *b, *e;\n\n    if (!c->ci->proc) {\n      mrb_raise(mrb, E_FIBER_ERROR, \"double resume (current)\");\n    }\n    mrb_stack_extend(mrb, len+2); /* for receiver and (optional) block */\n    b = c->stbase+1;\n    e = b + len;\n    while (b<e) {\n      *b++ = *a++;\n    }\n    if (vmexec) {\n      c->ci--;                    /* pop dummy callinfo */\n    }\n    c->cibase->n = len;\n    value = c->stbase[0] = MRB_PROC_ENV(c->cibase->proc)->stack[0];\n  }\n  else {\n    value = fiber_result(mrb, a, len);\n    if (vmexec) {\n      c->ci[1].stack[0] = value;\n    }\n  }\n\n  if (vmexec) {\n    c->vmexec = TRUE;\n    value = mrb_vm_exec(mrb, c->ci->proc, c->ci->pc);\n    mrb->c = old_c;\n  }\n  else {\n    MARK_CONTEXT_MODIFY(c);\n  }\n  return value;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 214,
    "critical_vars": [
      "len"
    ],
    "function": "fiber_switch",
    "filename": "mruby/CVE-2022-0890/CVE-2022-0890_CWE-476_da48e7dbb20024c198493b8724adae1b842083aa_fiber.c.diff",
    "function_code": "fiber_switch(mrb_state *mrb, mrb_value self, mrb_int len, const mrb_value *a, mrb_bool resume, mrb_bool vmexec)\n{\n  struct mrb_context *c = fiber_check(mrb, self);\n  struct mrb_context *old_c = mrb->c;\n  enum mrb_fiber_state status;\n  mrb_value value;\n\n  fiber_check_cfunc(mrb, c);\n  status = c->status;\n  switch (status) {\n  case MRB_FIBER_TRANSFERRED:\n    if (resume) {\n      mrb_raise(mrb, E_FIBER_ERROR, \"resuming transferred fiber\");\n    }\n    break;\n  case MRB_FIBER_RUNNING:\n  case MRB_FIBER_RESUMED:\n    mrb_raise(mrb, E_FIBER_ERROR, \"double resume\");\n    break;\n  case MRB_FIBER_TERMINATED:\n    mrb_raise(mrb, E_FIBER_ERROR, \"resuming dead fiber\");\n    break;\n  default:\n    break;\n  }\n  old_c->status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED;\n  c->prev = resume ? mrb->c : (c->prev ? c->prev : mrb->root_c);\n  fiber_switch_context(mrb, c);\n  if (status == MRB_FIBER_CREATED) {\n    mrb_value *b, *e;\n\n    if (!c->ci->proc) {\n      mrb_raise(mrb, E_FIBER_ERROR, \"double resume (current)\");\n    }\n    if (vmexec) {\n      c->ci--;                    /* pop dummy callinfo */\n    }\n    if (len >= 15) {\n      mrb_stack_extend(mrb, 3);   /* for receiver, args and (optional) block */\n      c->stbase[1] = mrb_ary_new_from_values(mrb, len, a);\n      len = 15;\n    }\n    else {\n      mrb_stack_extend(mrb, len+2); /* for receiver and (optional) block */\n      b = c->stbase+1;\n      e = b + len;\n      while (b<e) {\n        *b++ = *a++;\n      }\n    }\n    c->cibase->n = len;\n    value = c->stbase[0] = MRB_PROC_ENV(c->cibase->proc)->stack[0];\n  }\n  else {\n    value = fiber_result(mrb, a, len);\n    if (vmexec) {\n      c->ci[1].stack[0] = value;\n    }\n  }\n\n  if (vmexec) {\n    c->vmexec = TRUE;\n    value = mrb_vm_exec(mrb, c->ci->proc, c->ci->pc);\n    mrb->c = old_c;\n  }\n  else {\n    MARK_CONTEXT_MODIFY(c);\n  }\n  return value;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 2957,
    "line_new": 2957,
    "critical_vars": [
      "s2"
    ],
    "function": "codegen",
    "filename": "mruby/CVE-2022-0632/CVE-2022-0632_CWE-476_44f591aa8f7091e6ca6cb418e428ae6d4ceaf77d_codegen.c.diff",
    "function_code": "codegen(codegen_scope *s, node *tree, int val)\n{\n  int nt;\n  int rlev = s->rlev;\n\n  if (!tree) {\n    if (val) {\n      genop_1(s, OP_LOADNIL, cursp());\n      push();\n    }\n    return;\n  }\n\n  s->rlev++;\n  if (s->rlev > MRB_CODEGEN_LEVEL_MAX) {\n    codegen_error(s, \"too complex expression\");\n  }\n  if (s->irep && s->filename_index != tree->filename_index) {\n    mrb_sym fname = mrb_parser_get_filename(s->parser, s->filename_index);\n    const char *filename = mrb_sym_name_len(s->mrb, fname, NULL);\n\n    mrb_debug_info_append_file(s->mrb, s->irep->debug_info,\n                               filename, s->lines, s->debug_start_pos, s->pc);\n    s->debug_start_pos = s->pc;\n    s->filename_index = tree->filename_index;\n    s->filename_sym = mrb_parser_get_filename(s->parser, tree->filename_index);\n  }\n\n  nt = nint(tree->car);\n  s->lineno = tree->lineno;\n  tree = tree->cdr;\n  switch (nt) {\n  case NODE_BEGIN:\n    if (val && !tree) {\n      genop_1(s, OP_LOADNIL, cursp());\n      push();\n    }\n    while (tree) {\n      codegen(s, tree->car, tree->cdr ? NOVAL : val);\n      tree = tree->cdr;\n    }\n    break;\n\n  case NODE_RESCUE:\n    {\n      int noexc;\n      uint32_t exend, pos1, pos2, tmp;\n      struct loopinfo *lp;\n      int catch_entry, begin, end;\n\n      if (tree->car == NULL) goto exit;\n      lp = loop_push(s, LOOP_BEGIN);\n      lp->pc0 = new_label(s);\n      catch_entry = catch_handler_new(s);\n      begin = s->pc;\n      codegen(s, tree->car, VAL);\n      pop();\n      lp->type = LOOP_RESCUE;\n      end = s->pc;\n      noexc = genjmp_0(s, OP_JMP);\n      catch_handler_set(s, catch_entry, MRB_CATCH_RESCUE, begin, end, s->pc);\n      tree = tree->cdr;\n      exend = JMPLINK_START;\n      pos1 = JMPLINK_START;\n      if (tree->car) {\n        node *n2 = tree->car;\n        int exc = cursp();\n\n        genop_1(s, OP_EXCEPT, exc);\n        push();\n        while (n2) {\n          node *n3 = n2->car;\n          node *n4 = n3->car;\n\n          dispatch(s, pos1);\n          pos2 = JMPLINK_START;\n          do {\n            if (n4 && n4->car && nint(n4->car->car) == NODE_SPLAT) {\n              codegen(s, n4->car, VAL);\n              gen_move(s, cursp(), exc, 0);\n              push_n(2); pop_n(2); /* space for one arg and a block */\n              pop();\n              genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_SYM_2(s->mrb, __case_eqq)), 1);\n            }\n            else {\n              if (n4) {\n                codegen(s, n4->car, VAL);\n              }\n              else {\n                genop_2(s, OP_GETCONST, cursp(), new_sym(s, MRB_SYM_2(s->mrb, StandardError)));\n                push();\n              }\n              pop();\n              genop_2(s, OP_RESCUE, exc, cursp());\n            }\n            tmp = genjmp2(s, OP_JMPIF, cursp(), pos2, val);\n            pos2 = tmp;\n            if (n4) {\n              n4 = n4->cdr;\n            }\n          } while (n4);\n          pos1 = genjmp_0(s, OP_JMP);\n          dispatch_linked(s, pos2);\n\n          pop();\n          if (n3->cdr->car) {\n            gen_assignment(s, n3->cdr->car, NULL, exc, NOVAL);\n          }\n          if (n3->cdr->cdr->car) {\n            codegen(s, n3->cdr->cdr->car, val);\n            if (val) pop();\n          }\n          tmp = genjmp(s, OP_JMP, exend);\n          exend = tmp;\n          n2 = n2->cdr;\n          push();\n        }\n        if (pos1 != JMPLINK_START) {\n          dispatch(s, pos1);\n          genop_1(s, OP_RAISEIF, exc);\n        }\n      }\n      pop();\n      tree = tree->cdr;\n      dispatch(s, noexc);\n      if (tree->car) {\n        codegen(s, tree->car, val);\n      }\n      else if (val) {\n        push();\n      }\n      dispatch_linked(s, exend);\n      loop_pop(s, NOVAL);\n    }\n    break;\n\n  case NODE_ENSURE:\n    if (!tree->cdr || !tree->cdr->cdr ||\n        (nint(tree->cdr->cdr->car) == NODE_BEGIN &&\n         tree->cdr->cdr->cdr)) {\n      int catch_entry, begin, end, target;\n      int idx;\n\n      catch_entry = catch_handler_new(s);\n      begin = s->pc;\n      codegen(s, tree->car, val);\n      end = target = s->pc;\n      push();\n      idx = cursp();\n      genop_1(s, OP_EXCEPT, idx);\n      push();\n      codegen(s, tree->cdr->cdr, NOVAL);\n      pop();\n      genop_1(s, OP_RAISEIF, idx);\n      pop();\n      catch_handler_set(s, catch_entry, MRB_CATCH_ENSURE, begin, end, target);\n    }\n    else {                      /* empty ensure ignored */\n      codegen(s, tree->car, val);\n    }\n    break;\n\n  case NODE_LAMBDA:\n    if (val) {\n      int idx = lambda_body(s, tree, 1);\n\n      genop_2(s, OP_LAMBDA, cursp(), idx);\n      push();\n    }\n    break;\n\n  case NODE_BLOCK:\n    if (val) {\n      int idx = lambda_body(s, tree, 1);\n\n      genop_2(s, OP_BLOCK, cursp(), idx);\n      push();\n    }\n    break;\n\n  case NODE_IF:\n    {\n      uint32_t pos1, pos2;\n      mrb_bool nil_p = FALSE;\n      node *elsepart = tree->cdr->cdr->car;\n\n      if (!tree->car) {\n        codegen(s, elsepart, val);\n        goto exit;\n      }\n      if (true_always(tree->car)) {\n        codegen(s, tree->cdr->car, val);\n        goto exit;\n      }\n      if (false_always(tree->car)) {\n        codegen(s, elsepart, val);\n        goto exit;\n      }\n      if (nint(tree->car->car) == NODE_CALL) {\n        node *n = tree->car->cdr;\n        mrb_sym mid = nsym(n->cdr->car);\n        mrb_sym sym_nil_p = MRB_SYM_Q_2(s->mrb, nil);\n        if (mid == sym_nil_p && n->cdr->cdr->car == NULL) {\n          nil_p = TRUE;\n          codegen(s, n->car, VAL);\n        }\n      }\n      if (!nil_p) {\n        codegen(s, tree->car, VAL);\n      }\n      pop();\n      if (val || tree->cdr->car) {\n        if (nil_p) {\n          pos2 = genjmp2_0(s, OP_JMPNIL, cursp(), val);\n          pos1 = genjmp_0(s, OP_JMP);\n          dispatch(s, pos2);\n        }\n        else {\n          pos1 = genjmp2_0(s, OP_JMPNOT, cursp(), val);\n        }\n        codegen(s, tree->cdr->car, val);\n        if (val) pop();\n        if (elsepart || val) {\n          pos2 = genjmp_0(s, OP_JMP);\n          dispatch(s, pos1);\n          codegen(s, elsepart, val);\n          dispatch(s, pos2);\n        }\n        else {\n          dispatch(s, pos1);\n        }\n      }\n      else {                    /* empty then-part */\n        if (elsepart) {\n          if (nil_p) {\n            pos1 = genjmp2_0(s, OP_JMPNIL, cursp(), val);\n          }\n          else {\n            pos1 = genjmp2_0(s, OP_JMPIF, cursp(), val);\n          }\n          codegen(s, elsepart, val);\n          dispatch(s, pos1);\n        }\n        else if (val && !nil_p) {\n          genop_1(s, OP_LOADNIL, cursp());\n          push();\n        }\n      }\n    }\n    break;\n\n  case NODE_AND:\n    {\n      uint32_t pos;\n\n      if (true_always(tree->car)) {\n        codegen(s, tree->cdr, val);\n        goto exit;\n      }\n      if (false_always(tree->car)) {\n        codegen(s, tree->car, val);\n        goto exit;\n      }\n      codegen(s, tree->car, VAL);\n      pop();\n      pos = genjmp2_0(s, OP_JMPNOT, cursp(), val);\n      codegen(s, tree->cdr, val);\n      dispatch(s, pos);\n    }\n    break;\n\n  case NODE_OR:\n    {\n      uint32_t pos;\n\n      if (true_always(tree->car)) {\n        codegen(s, tree->car, val);\n        goto exit;\n      }\n      if (false_always(tree->car)) {\n        codegen(s, tree->cdr, val);\n        goto exit;\n      }\n      codegen(s, tree->car, VAL);\n      pop();\n      pos = genjmp2_0(s, OP_JMPIF, cursp(), val);\n      codegen(s, tree->cdr, val);\n      dispatch(s, pos);\n    }\n    break;\n\n  case NODE_WHILE:\n  case NODE_UNTIL:\n    {\n      if (true_always(tree->car)) {\n        if (nt == NODE_UNTIL) {\n          if (val) {\n            genop_1(s, OP_LOADNIL, cursp());\n            push();\n          }\n          goto exit;\n        }\n      }\n      else if (false_always(tree->car)) {\n        if (nt == NODE_WHILE) {\n          if (val) {\n            genop_1(s, OP_LOADNIL, cursp());\n            push();\n          }\n          goto exit;\n        }\n      }\n\n      uint32_t pos = JMPLINK_START;\n      struct loopinfo *lp = loop_push(s, LOOP_NORMAL);\n\n      if (!val) lp->reg = -1;\n      lp->pc0 = new_label(s);\n      codegen(s, tree->car, VAL);\n      pop();\n      if (nt == NODE_WHILE) {\n        pos = genjmp2_0(s, OP_JMPNOT, cursp(), NOVAL);\n      }\n      else {\n        pos = genjmp2_0(s, OP_JMPIF, cursp(), NOVAL);\n      }\n      lp->pc1 = new_label(s);\n      codegen(s, tree->cdr, NOVAL);\n      genjmp(s, OP_JMP, lp->pc0);\n      dispatch(s, pos);\n      loop_pop(s, val);\n    }\n    break;\n\n  case NODE_FOR:\n    for_body(s, tree);\n    if (val) push();\n    break;\n\n  case NODE_CASE:\n    {\n      int head = 0;\n      uint32_t pos1, pos2, pos3, tmp;\n      node *n;\n\n      pos3 = JMPLINK_START;\n      if (tree->car) {\n        head = cursp();\n        codegen(s, tree->car, VAL);\n      }\n      tree = tree->cdr;\n      while (tree) {\n        n = tree->car->car;\n        pos1 = pos2 = JMPLINK_START;\n        while (n) {\n          codegen(s, n->car, VAL);\n          if (head) {\n            gen_move(s, cursp(), head, 0);\n            push(); push(); pop(); pop(); pop();\n            if (nint(n->car->car) == NODE_SPLAT) {\n              genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_SYM_2(s->mrb, __case_eqq)), 1);\n            }\n            else {\n              genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_OPSYM_2(s->mrb, eqq)), 1);\n            }\n          }\n          else {\n            pop();\n          }\n          tmp = genjmp2(s, OP_JMPIF, cursp(), pos2, NOVAL);\n          pos2 = tmp;\n          n = n->cdr;\n        }\n        if (tree->car->car) {\n          pos1 = genjmp_0(s, OP_JMP);\n          dispatch_linked(s, pos2);\n        }\n        codegen(s, tree->car->cdr, val);\n        if (val) pop();\n        tmp = genjmp(s, OP_JMP, pos3);\n        pos3 = tmp;\n        dispatch(s, pos1);\n        tree = tree->cdr;\n      }\n      if (val) {\n        uint32_t pos = cursp();\n        genop_1(s, OP_LOADNIL, cursp());\n        if (pos3 != JMPLINK_START) dispatch_linked(s, pos3);\n        if (head) pop();\n        if (cursp() != pos) {\n          gen_move(s, cursp(), pos, 0);\n        }\n        push();\n      }\n      else {\n        if (pos3 != JMPLINK_START) {\n          dispatch_linked(s, pos3);\n        }\n        if (head) {\n          pop();\n        }\n      }\n    }\n    break;\n\n  case NODE_SCOPE:\n    scope_body(s, tree, NOVAL);\n    break;\n\n  case NODE_FCALL:\n  case NODE_CALL:\n    gen_call(s, tree, val, 0);\n    break;\n  case NODE_SCALL:\n    gen_call(s, tree, val, 1);\n    break;\n\n  case NODE_DOT2:\n    codegen(s, tree->car, val);\n    codegen(s, tree->cdr, val);\n    if (val) {\n      pop(); pop();\n      genop_1(s, OP_RANGE_INC, cursp());\n      push();\n    }\n    break;\n\n  case NODE_DOT3:\n    codegen(s, tree->car, val);\n    codegen(s, tree->cdr, val);\n    if (val) {\n      pop(); pop();\n      genop_1(s, OP_RANGE_EXC, cursp());\n      push();\n    }\n    break;\n\n  case NODE_COLON2:\n    {\n      int sym = new_sym(s, nsym(tree->cdr));\n\n      codegen(s, tree->car, VAL);\n      pop();\n      genop_2(s, OP_GETMCNST, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_COLON3:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_1(s, OP_OCLASS, cursp());\n      genop_2(s, OP_GETMCNST, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_ARRAY:\n    {\n      int n;\n\n      n = gen_values(s, tree, val, 0);\n      if (val) {\n        if (n >= 0) {\n          pop_n(n);\n          genop_2(s, OP_ARRAY, cursp(), n);\n        }\n        push();\n      }\n    }\n    break;\n\n  case NODE_HASH:\n  case NODE_KW_HASH:\n    {\n      int nk = gen_hash(s, tree, val, GEN_LIT_ARY_MAX);\n      if (val && nk >= 0) {\n        pop_n(nk*2);\n        genop_2(s, OP_HASH, cursp(), nk);\n        push();\n      }\n    }\n    break;\n\n  case NODE_SPLAT:\n    codegen(s, tree, val);\n    break;\n\n  case NODE_ASGN:\n    gen_assignment(s, tree->car, tree->cdr, 0, val);\n    break;\n\n  case NODE_MASGN:\n    {\n      int len = 0, n = 0, post = 0;\n      node *t = tree->cdr, *p;\n      int rhs = cursp();\n\n      if (nint(t->car) == NODE_ARRAY && t->cdr && nosplat(t->cdr)) {\n        /* fixed rhs */\n        t = t->cdr;\n        while (t) {\n          codegen(s, t->car, VAL);\n          len++;\n          t = t->cdr;\n        }\n        tree = tree->car;\n        if (tree->car) {                /* pre */\n          t = tree->car;\n          n = 0;\n          while (t) {\n            if (n < len) {\n              gen_assignment(s, t->car, NULL, rhs+n, NOVAL);\n              n++;\n            }\n            else {\n              genop_1(s, OP_LOADNIL, rhs+n);\n              gen_assignment(s, t->car, NULL, rhs+n, NOVAL);\n            }\n            t = t->cdr;\n          }\n        }\n        t = tree->cdr;\n        if (t) {\n          if (t->cdr) {         /* post count */\n            p = t->cdr->car;\n            while (p) {\n              post++;\n              p = p->cdr;\n            }\n          }\n          if (t->car) {         /* rest (len - pre - post) */\n            int rn;\n\n            if (len < post + n) {\n              rn = 0;\n            }\n            else {\n              rn = len - post - n;\n            }\n            genop_3(s, OP_ARRAY2, cursp(), rhs+n, rn);\n            gen_assignment(s, t->car, NULL, cursp(), NOVAL);\n            n += rn;\n          }\n          if (t->cdr && t->cdr->car) {\n            t = t->cdr->car;\n            while (n<len) {\n              gen_assignment(s, t->car, NULL, rhs+n, NOVAL);\n              t = t->cdr;\n              n++;\n            }\n          }\n        }\n        pop_n(len);\n        if (val) {\n          genop_2(s, OP_ARRAY, rhs, len);\n          push();\n        }\n      }\n      else {\n        /* variable rhs */\n        codegen(s, t, VAL);\n        gen_vmassignment(s, tree->car, rhs, val);\n        if (!val) {\n          pop();\n        }\n      }\n    }\n    break;\n\n  case NODE_OP_ASGN:\n    {\n      mrb_sym sym = nsym(tree->cdr->car);\n      mrb_int len;\n      const char *name = mrb_sym_name_len(s->mrb, sym, &len);\n      int idx, callargs = -1, vsp = -1;\n\n      if ((len == 2 && name[0] == '|' && name[1] == '|') &&\n          (nint(tree->car->car) == NODE_CONST ||\n           nint(tree->car->car) == NODE_CVAR)) {\n        int catch_entry, begin, end;\n        int noexc, exc;\n        struct loopinfo *lp;\n\n        lp = loop_push(s, LOOP_BEGIN);\n        lp->pc0 = new_label(s);\n        catch_entry = catch_handler_new(s);\n        begin = s->pc;\n        exc = cursp();\n        codegen(s, tree->car, VAL);\n        end = s->pc;\n        noexc = genjmp_0(s, OP_JMP);\n        lp->type = LOOP_RESCUE;\n        catch_handler_set(s, catch_entry, MRB_CATCH_RESCUE, begin, end, s->pc);\n        genop_1(s, OP_EXCEPT, exc);\n        genop_1(s, OP_LOADF, exc);\n        dispatch(s, noexc);\n        loop_pop(s, NOVAL);\n      }\n      else if (nint(tree->car->car) == NODE_CALL) {\n        node *n = tree->car->cdr;\n        int base, i, nargs = 0;\n        callargs = 0;\n\n        if (val) {\n          vsp = cursp();\n          push();\n        }\n        codegen(s, n->car, VAL);   /* receiver */\n        idx = new_sym(s, nsym(n->cdr->car));\n        base = cursp()-1;\n        if (n->cdr->cdr->car) {\n          nargs = gen_values(s, n->cdr->cdr->car->car, VAL, 13);\n          if (nargs >= 0) {\n            callargs = nargs;\n          }\n          else { /* varargs */\n            push();\n            nargs = 1;\n            callargs = CALL_MAXARGS;\n          }\n        }\n        /* copy receiver and arguments */\n        gen_move(s, cursp(), base, 1);\n        for (i=0; i<nargs; i++) {\n          gen_move(s, cursp()+i+1, base+i+1, 1);\n        }\n        push_n(nargs+2);pop_n(nargs+2); /* space for receiver, arguments and a block */\n        genop_3(s, OP_SEND, cursp(), idx, callargs);\n        push();\n      }\n      else {\n        codegen(s, tree->car, VAL);\n      }\n      if (len == 2 &&\n          ((name[0] == '|' && name[1] == '|') ||\n           (name[0] == '&' && name[1] == '&'))) {\n        uint32_t pos;\n\n        pop();\n        if (val) {\n          if (vsp >= 0) {\n            gen_move(s, vsp, cursp(), 1);\n          }\n          pos = genjmp2_0(s, name[0]=='|'?OP_JMPIF:OP_JMPNOT, cursp(), val);\n        }\n        else {\n          pos = genjmp2_0(s, name[0]=='|'?OP_JMPIF:OP_JMPNOT, cursp(), val);\n        }\n        codegen(s, tree->cdr->cdr->car, VAL);\n        pop();\n        if (val && vsp >= 0) {\n          gen_move(s, vsp, cursp(), 1);\n        }\n        if (nint(tree->car->car) == NODE_CALL) {\n          if (callargs == CALL_MAXARGS) {\n            pop();\n            genop_2(s, OP_ARYPUSH, cursp(), 1);\n          }\n          else {\n            pop_n(callargs);\n            callargs++;\n          }\n          pop();\n          idx = new_sym(s, attrsym(s, nsym(tree->car->cdr->cdr->car)));\n          genop_3(s, OP_SEND, cursp(), idx, callargs);\n        }\n        else {\n          gen_assignment(s, tree->car, NULL, cursp(), val);\n        }\n        dispatch(s, pos);\n        goto exit;\n      }\n      codegen(s, tree->cdr->cdr->car, VAL);\n      push(); pop();\n      pop(); pop();\n\n      if (len == 1 && name[0] == '+')  {\n        gen_addsub(s, OP_ADD, cursp());\n      }\n      else if (len == 1 && name[0] == '-')  {\n        gen_addsub(s, OP_SUB, cursp());\n      }\n      else if (len == 1 && name[0] == '*')  {\n        genop_1(s, OP_MUL, cursp());\n      }\n      else if (len == 1 && name[0] == '/')  {\n        genop_1(s, OP_DIV, cursp());\n      }\n      else if (len == 1 && name[0] == '<')  {\n        genop_1(s, OP_LT, cursp());\n      }\n      else if (len == 2 && name[0] == '<' && name[1] == '=')  {\n        genop_1(s, OP_LE, cursp());\n      }\n      else if (len == 1 && name[0] == '>')  {\n        genop_1(s, OP_GT, cursp());\n      }\n      else if (len == 2 && name[0] == '>' && name[1] == '=')  {\n        genop_1(s, OP_GE, cursp());\n      }\n      else {\n        idx = new_sym(s, sym);\n        genop_3(s, OP_SEND, cursp(), idx, 1);\n      }\n      if (callargs < 0) {\n        gen_assignment(s, tree->car, NULL, cursp(), val);\n      }\n      else {\n        if (val && vsp >= 0) {\n          gen_move(s, vsp, cursp(), 0);\n        }\n        if (callargs == CALL_MAXARGS) {\n          pop();\n          genop_2(s, OP_ARYPUSH, cursp(), 1);\n        }\n        else {\n          pop_n(callargs);\n          callargs++;\n        }\n        pop();\n        idx = new_sym(s, attrsym(s,nsym(tree->car->cdr->cdr->car)));\n        genop_3(s, OP_SEND, cursp(), idx, callargs);\n      }\n    }\n    break;\n\n  case NODE_SUPER:\n    {\n      codegen_scope *s2 = s;\n      int lv = 0;\n      int n = 0, nk = 0, st = 0;\n\n      push();\n      while (!s2->mscope) {\n        lv++;\n        s2 = s2->prev;\n        if (!s2) break;\n      }\n      if (tree) {\n        node *args = tree->car;\n        if (args) {\n          st = n = gen_values(s, args, VAL, 14);\n          if (n < 0) {\n            st = 1; n = 15;\n            push();\n          }\n        }\n        /* keyword arguments */\n        if (s2 && (s2->ainfo & 0x1) && tree->cdr->car) {\n          nk = gen_hash(s, tree->cdr->car->cdr, VAL, 14);\n          if (nk < 0) {st++; nk = 15;}\n          else st += nk*2;\n          n |= nk<<4;\n        }\n        /* block arguments */\n        if (tree->cdr->cdr) {\n          codegen(s, tree->cdr->cdr, VAL);\n        }\n        else if (s2) gen_blkmove(s, s2->ainfo, lv);\n        else {\n          genop_1(s, OP_LOADNIL, cursp());\n          push();\n        }\n      }\n      else {\n        if (s2) gen_blkmove(s, s2->ainfo, lv);\n        else {\n          genop_1(s, OP_LOADNIL, cursp());\n          push();\n        }\n      }\n      st++;\n      pop_n(st+1);\n      genop_2(s, OP_SUPER, cursp(), n);\n      if (val) push();\n    }\n    break;\n\n  case NODE_ZSUPER:\n    {\n      codegen_scope *s2 = s;\n      int lv = 0;\n      uint16_t ainfo = 0;\n      int n = CALL_MAXARGS;\n      int sp = cursp();\n\n      push();        /* room for receiver */\n      while (!s2->mscope) {\n        lv++;\n        s2 = s2->prev;\n        if (!s2) break;\n      }\n      if (s2 && s2->ainfo > 0) {\n        ainfo = s2->ainfo;\n      }\n      if (ainfo > 0) {\n        genop_2S(s, OP_ARGARY, cursp(), (ainfo<<4)|(lv & 0xf));\n        push(); push(); push();   /* ARGARY pushes 3 values at most */\n        pop(); pop(); pop();\n        /* keyword arguments */\n        if (ainfo & 0x1) {\n          n |= CALL_MAXARGS<<4;\n          push();\n        }\n        /* block argument */\n        if (tree && tree->cdr && tree->cdr->cdr) {\n          push();\n          codegen(s, tree->cdr->cdr, VAL);\n        }\n      }\n      else {\n        /* block argument */\n        if (tree && tree->cdr && tree->cdr->cdr) {\n          codegen(s, tree->cdr->cdr, VAL);\n        }\n        else {\n          gen_blkmove(s, 0, lv);\n        }\n        n = 0;\n      }\n      s->sp = sp;\n      genop_2(s, OP_SUPER, cursp(), n);\n      if (val) push();\n    }\n    break;\n\n  case NODE_RETURN:\n    if (tree) {\n      gen_retval(s, tree);\n    }\n    else {\n      genop_1(s, OP_LOADNIL, cursp());\n    }\n    if (s->loop) {\n      gen_return(s, OP_RETURN_BLK, cursp());\n    }\n    else {\n      gen_return(s, OP_RETURN, cursp());\n    }\n    if (val) push();\n    break;\n\n  case NODE_YIELD:\n    {\n      codegen_scope *s2 = s;\n      int lv = 0, ainfo = -1;\n      int n = 0, sendv = 0;\n\n      while (!s2->mscope) {\n        lv++;\n        s2 = s2->prev;\n        if (!s2) break;\n      }\n      if (s2) {\n        ainfo = (int)s2->ainfo;\n      }\n      if (ainfo < 0) codegen_error(s, \"invalid yield (SyntaxError)\");\n      push();\n      if (tree) {\n        n = gen_values(s, tree, VAL, 14);\n        if (n < 0) {\n          n = sendv = 1;\n          push();\n        }\n      }\n      push();pop(); /* space for a block */\n      pop_n(n+1);\n      genop_2S(s, OP_BLKPUSH, cursp(), (ainfo<<4)|(lv & 0xf));\n      if (sendv) n = CALL_MAXARGS;\n      genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_SYM_2(s->mrb, call)), n);\n      if (val) push();\n    }\n    break;\n\n  case NODE_BREAK:\n    loop_break(s, tree);\n    if (val) push();\n    break;\n\n  case NODE_NEXT:\n    if (!s->loop) {\n      raise_error(s, \"unexpected next\");\n    }\n    else if (s->loop->type == LOOP_NORMAL) {\n      codegen(s, tree, NOVAL);\n      genjmp(s, OP_JMPUW, s->loop->pc0);\n    }\n    else {\n      if (tree) {\n        codegen(s, tree, VAL);\n        pop();\n      }\n      else {\n        genop_1(s, OP_LOADNIL, cursp());\n      }\n      gen_return(s, OP_RETURN, cursp());\n    }\n    if (val) push();\n    break;\n\n  case NODE_REDO:\n    if (!s->loop || s->loop->type == LOOP_BEGIN || s->loop->type == LOOP_RESCUE) {\n      raise_error(s, \"unexpected redo\");\n    }\n    else {\n      genjmp(s, OP_JMPUW, s->loop->pc1);\n    }\n    if (val) push();\n    break;\n\n  case NODE_RETRY:\n    {\n      const char *msg = \"unexpected retry\";\n      const struct loopinfo *lp = s->loop;\n\n      while (lp && lp->type != LOOP_RESCUE) {\n        lp = lp->prev;\n      }\n      if (!lp) {\n        raise_error(s, msg);\n      }\n      else {\n        genjmp(s, OP_JMPUW, lp->pc0);\n      }\n      if (val) push();\n    }\n    break;\n\n  case NODE_LVAR:\n    if (val) {\n      int idx = lv_idx(s, nsym(tree));\n\n      if (idx > 0) {\n        gen_move(s, cursp(), idx, val);\n      }\n      else {\n        gen_getupvar(s, cursp(), nsym(tree));\n      }\n      push();\n    }\n    break;\n\n  case NODE_NVAR:\n    if (val) {\n      int idx = nint(tree);\n\n      gen_move(s, cursp(), idx, val);\n\n      push();\n    }\n    break;\n\n  case NODE_GVAR:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_GETGV, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_IVAR:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_GETIV, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_CVAR:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_GETCV, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_CONST:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_GETCONST, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_BACK_REF:\n    if (val) {\n      char buf[] = {'$', nchar(tree)};\n      int sym = new_sym(s, mrb_intern(s->mrb, buf, sizeof(buf)));\n\n      genop_2(s, OP_GETGV, cursp(), sym);\n      push();\n    }\n    break;\n\n  case NODE_NTH_REF:\n    if (val) {\n      mrb_state *mrb = s->mrb;\n      mrb_value str;\n      int sym;\n\n      str = mrb_format(mrb, \"$%d\", nint(tree));\n      sym = new_sym(s, mrb_intern_str(mrb, str));\n      genop_2(s, OP_GETGV, cursp(), sym);\n      push();\n    }\n    break;\n\n  case NODE_ARG:\n    /* should not happen */\n    break;\n\n  case NODE_BLOCK_ARG:\n    if (!tree) {\n      int idx = lv_idx(s, MRB_OPSYM_2(s->mrb, and));\n\n      if (idx == 0) {\n        codegen_error(s, \"no anonymous block argument\");\n      }\n      gen_move(s, cursp(), idx, val);\n      if (val) push();\n    }\n    else {\n      codegen(s, tree, val);\n    }\n    break;\n\n  case NODE_INT:\n    if (val) {\n      char *p = (char*)tree->car;\n      int base = nint(tree->cdr->car);\n      mrb_int i;\n      mrb_bool overflow;\n\n      i = readint(s, p, base, FALSE, &overflow);\n      if (overflow) {\n        int off = new_litbn(s, p, base, FALSE);\n        genop_2(s, OP_LOADL, cursp(), off);\n      }\n      else {\n        gen_int(s, cursp(), i);\n      }\n      push();\n    }\n    break;\n\n#ifndef MRB_NO_FLOAT\n  case NODE_FLOAT:\n    if (val) {\n      char *p = (char*)tree;\n      mrb_float f = mrb_float_read(p, NULL);\n      int off = new_lit(s, mrb_float_value(s->mrb, f));\n\n      genop_2(s, OP_LOADL, cursp(), off);\n      push();\n    }\n    break;\n#endif\n\n  case NODE_NEGATE:\n    {\n      nt = nint(tree->car);\n      switch (nt) {\n#ifndef MRB_NO_FLOAT\n      case NODE_FLOAT:\n        if (val) {\n          char *p = (char*)tree->cdr;\n          mrb_float f = mrb_float_read(p, NULL);\n          int off = new_lit(s, mrb_float_value(s->mrb, -f));\n\n          genop_2(s, OP_LOADL, cursp(), off);\n          push();\n        }\n        break;\n#endif\n\n      case NODE_INT:\n        if (val) {\n          char *p = (char*)tree->cdr->car;\n          int base = nint(tree->cdr->cdr->car);\n          mrb_int i;\n          mrb_bool overflow;\n\n          i = readint(s, p, base, TRUE, &overflow);\n          if (overflow) {\n            int off = new_litbn(s, p, base, TRUE);\n            genop_2(s, OP_LOADL, cursp(), off);\n          }\n          else {\n            gen_int(s, cursp(), i);\n          }\n          push();\n        }\n        break;\n\n      default:\n        if (val) {\n          codegen(s, tree, VAL);\n          pop();\n          push_n(2);pop_n(2); /* space for receiver&block */\n          mrb_sym minus = MRB_OPSYM_2(s->mrb, minus);\n          if (!gen_uniop(s, minus, cursp())) {\n            genop_3(s, OP_SEND, cursp(), new_sym(s, minus), 0);\n          }\n          push();\n        }\n        else {\n          codegen(s, tree, NOVAL);\n        }\n        break;\n      }\n    }\n    break;\n\n  case NODE_STR:\n    if (val) {\n      char *p = (char*)tree->car;\n      size_t len = (intptr_t)tree->cdr;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int off = new_lit(s, mrb_str_new(s->mrb, p, len));\n\n      mrb_gc_arena_restore(s->mrb, ai);\n      genop_2(s, OP_STRING, cursp(), off);\n      push();\n    }\n    break;\n\n  case NODE_HEREDOC:\n    tree = ((struct mrb_parser_heredoc_info *)tree)->doc;\n    /* fall through */\n  case NODE_DSTR:\n    if (val) {\n      node *n = tree;\n\n      if (!n) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n        break;\n      }\n      codegen(s, n->car, VAL);\n      n = n->cdr;\n      while (n) {\n        codegen(s, n->car, VAL);\n        pop(); pop();\n        genop_1(s, OP_STRCAT, cursp());\n        push();\n        n = n->cdr;\n      }\n    }\n    else {\n      node *n = tree;\n\n      while (n) {\n        if (nint(n->car->car) != NODE_STR) {\n          codegen(s, n->car, NOVAL);\n        }\n        n = n->cdr;\n      }\n    }\n    break;\n\n  case NODE_WORDS:\n    gen_literal_array(s, tree, FALSE, val);\n    break;\n\n  case NODE_SYMBOLS:\n    gen_literal_array(s, tree, TRUE, val);\n    break;\n\n  case NODE_DXSTR:\n    {\n      node *n;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int sym = new_sym(s, MRB_SYM_2(s->mrb, Kernel));\n\n      genop_1(s, OP_LOADSELF, cursp());\n      push();\n      codegen(s, tree->car, VAL);\n      n = tree->cdr;\n      while (n) {\n        if (nint(n->car->car) == NODE_XSTR) {\n          n->car->car = (struct mrb_ast_node*)(intptr_t)NODE_STR;\n          mrb_assert(!n->cdr); /* must be the end */\n        }\n        codegen(s, n->car, VAL);\n        pop(); pop();\n        genop_1(s, OP_STRCAT, cursp());\n        push();\n        n = n->cdr;\n      }\n      push();                   /* for block */\n      pop_n(3);\n      sym = new_sym(s, MRB_OPSYM_2(s->mrb, tick)); /* ` */\n      genop_3(s, OP_SEND, cursp(), sym, 1);\n      if (val) push();\n      mrb_gc_arena_restore(s->mrb, ai);\n    }\n    break;\n\n  case NODE_XSTR:\n    {\n      char *p = (char*)tree->car;\n      size_t len = (intptr_t)tree->cdr;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int off = new_lit(s, mrb_str_new(s->mrb, p, len));\n      int sym;\n\n      genop_1(s, OP_LOADSELF, cursp());\n      push();\n      genop_2(s, OP_STRING, cursp(), off);\n      push(); push();\n      pop_n(3);\n      sym = new_sym(s, MRB_OPSYM_2(s->mrb, tick)); /* ` */\n      genop_3(s, OP_SEND, cursp(), sym, 1);\n      if (val) push();\n      mrb_gc_arena_restore(s->mrb, ai);\n    }\n    break;\n\n  case NODE_REGX:\n    if (val) {\n      char *p1 = (char*)tree->car;\n      char *p2 = (char*)tree->cdr->car;\n      char *p3 = (char*)tree->cdr->cdr;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int sym = new_sym(s, mrb_intern_lit(s->mrb, REGEXP_CLASS));\n      int off = new_lit(s, mrb_str_new_cstr(s->mrb, p1));\n      int argc = 1;\n\n      genop_1(s, OP_OCLASS, cursp());\n      genop_2(s, OP_GETMCNST, cursp(), sym);\n      push();\n      genop_2(s, OP_STRING, cursp(), off);\n      push();\n      if (p2 || p3) {\n        if (p2) { /* opt */\n          off = new_lit(s, mrb_str_new_cstr(s->mrb, p2));\n          genop_2(s, OP_STRING, cursp(), off);\n        }\n        else {\n          genop_1(s, OP_LOADNIL, cursp());\n        }\n        push();\n        argc++;\n        if (p3) { /* enc */\n          off = new_lit(s, mrb_str_new(s->mrb, p3, 1));\n          genop_2(s, OP_STRING, cursp(), off);\n          push();\n          argc++;\n        }\n      }\n      push(); /* space for a block */\n      pop_n(argc+2);\n      sym = new_sym(s, MRB_SYM_2(s->mrb, compile));\n      genop_3(s, OP_SEND, cursp(), sym, argc);\n      mrb_gc_arena_restore(s->mrb, ai);\n      push();\n    }\n    break;\n\n  case NODE_DREGX:\n    if (val) {\n      node *n = tree->car;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int sym = new_sym(s, mrb_intern_lit(s->mrb, REGEXP_CLASS));\n      int argc = 1;\n      int off;\n      char *p;\n\n      genop_1(s, OP_OCLASS, cursp());\n      genop_2(s, OP_GETMCNST, cursp(), sym);\n      push();\n      codegen(s, n->car, VAL);\n      n = n->cdr;\n      while (n) {\n        codegen(s, n->car, VAL);\n        pop(); pop();\n        genop_1(s, OP_STRCAT, cursp());\n        push();\n        n = n->cdr;\n      }\n      n = tree->cdr->cdr;\n      if (n->car) { /* tail */\n        p = (char*)n->car;\n        off = new_lit(s, mrb_str_new_cstr(s->mrb, p));\n        codegen(s, tree->car, VAL);\n        genop_2(s, OP_STRING, cursp(), off);\n        pop();\n        genop_1(s, OP_STRCAT, cursp());\n        push();\n      }\n      if (n->cdr->car) { /* opt */\n        char *p2 = (char*)n->cdr->car;\n        off = new_lit(s, mrb_str_new_cstr(s->mrb, p2));\n        genop_2(s, OP_STRING, cursp(), off);\n        push();\n        argc++;\n      }\n      if (n->cdr->cdr) { /* enc */\n        char *p2 = (char*)n->cdr->cdr;\n        off = new_lit(s, mrb_str_new_cstr(s->mrb, p2));\n        genop_2(s, OP_STRING, cursp(), off);\n        push();\n        argc++;\n      }\n      push(); /* space for a block */\n      pop_n(argc+2);\n      sym = new_sym(s, MRB_SYM_2(s->mrb, compile));\n      genop_3(s, OP_SEND, cursp(), sym, argc);\n      mrb_gc_arena_restore(s->mrb, ai);\n      push();\n    }\n    else {\n      node *n = tree->car;\n\n      while (n) {\n        if (nint(n->car->car) != NODE_STR) {\n          codegen(s, n->car, NOVAL);\n        }\n        n = n->cdr;\n      }\n    }\n    break;\n\n  case NODE_SYM:\n    if (val) {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_LOADSYM, cursp(), sym);\n      push();\n    }\n    break;\n\n  case NODE_DSYM:\n    codegen(s, tree, val);\n    if (val) {\n      gen_intern(s);\n    }\n    break;\n\n  case NODE_SELF:\n    if (val) {\n      genop_1(s, OP_LOADSELF, cursp());\n      push();\n    }\n    break;\n\n  case NODE_NIL:\n    if (val) {\n      genop_1(s, OP_LOADNIL, cursp());\n      push();\n    }\n    break;\n\n  case NODE_TRUE:\n    if (val) {\n      genop_1(s, OP_LOADT, cursp());\n      push();\n    }\n    break;\n\n  case NODE_FALSE:\n    if (val) {\n      genop_1(s, OP_LOADF, cursp());\n      push();\n    }\n    break;\n\n  case NODE_ALIAS:\n    {\n      int a = new_sym(s, nsym(tree->car));\n      int b = new_sym(s, nsym(tree->cdr));\n\n      genop_2(s, OP_ALIAS, a, b);\n      if (val) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n    }\n   break;\n\n  case NODE_UNDEF:\n    {\n      node *t = tree;\n\n      while (t) {\n        int symbol = new_sym(s, nsym(t->car));\n        genop_1(s, OP_UNDEF, symbol);\n        t = t->cdr;\n      }\n      if (val) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n    }\n    break;\n\n  case NODE_CLASS:\n    {\n      int idx;\n      node *body;\n\n      if (tree->car->car == (node*)0) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n      else if (tree->car->car == (node*)1) {\n        genop_1(s, OP_OCLASS, cursp());\n        push();\n      }\n      else {\n        codegen(s, tree->car->car, VAL);\n      }\n      if (tree->cdr->car) {\n        codegen(s, tree->cdr->car, VAL);\n      }\n      else {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n      pop(); pop();\n      idx = new_sym(s, nsym(tree->car->cdr));\n      genop_2(s, OP_CLASS, cursp(), idx);\n      body = tree->cdr->cdr->car;\n      if (nint(body->cdr->car) == NODE_BEGIN && body->cdr->cdr == NULL) {\n        genop_1(s, OP_LOADNIL, cursp());\n      }\n      else {\n        idx = scope_body(s, body, val);\n        genop_2(s, OP_EXEC, cursp(), idx);\n      }\n      if (val) {\n        push();\n      }\n    }\n    break;\n\n  case NODE_MODULE:\n    {\n      int idx;\n\n      if (tree->car->car == (node*)0) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n      else if (tree->car->car == (node*)1) {\n        genop_1(s, OP_OCLASS, cursp());\n        push();\n      }\n      else {\n        codegen(s, tree->car->car, VAL);\n      }\n      pop();\n      idx = new_sym(s, nsym(tree->car->cdr));\n      genop_2(s, OP_MODULE, cursp(), idx);\n      if (nint(tree->cdr->car->cdr->car) == NODE_BEGIN &&\n          tree->cdr->car->cdr->cdr == NULL) {\n        genop_1(s, OP_LOADNIL, cursp());\n      }\n      else {\n        idx = scope_body(s, tree->cdr->car, val);\n        genop_2(s, OP_EXEC, cursp(), idx);\n      }\n      if (val) {\n        push();\n      }\n    }\n    break;\n\n  case NODE_SCLASS:\n    {\n      int idx;\n\n      codegen(s, tree->car, VAL);\n      pop();\n      genop_1(s, OP_SCLASS, cursp());\n      if (nint(tree->cdr->car->cdr->car) == NODE_BEGIN &&\n          tree->cdr->car->cdr->cdr == NULL) {\n        genop_1(s, OP_LOADNIL, cursp());\n      }\n      else {\n        idx = scope_body(s, tree->cdr->car, val);\n        genop_2(s, OP_EXEC, cursp(), idx);\n      }\n      if (val) {\n        push();\n      }\n    }\n    break;\n\n  case NODE_DEF:\n    {\n      int sym = new_sym(s, nsym(tree->car));\n      int idx = lambda_body(s, tree->cdr, 0);\n\n      genop_1(s, OP_TCLASS, cursp());\n      push();\n      genop_2(s, OP_METHOD, cursp(), idx);\n      push(); pop();\n      pop();\n      genop_2(s, OP_DEF, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_SDEF:\n    {\n      node *recv = tree->car;\n      int sym = new_sym(s, nsym(tree->cdr->car));\n      int idx = lambda_body(s, tree->cdr->cdr, 0);\n\n      codegen(s, recv, VAL);\n      pop();\n      genop_1(s, OP_SCLASS, cursp());\n      push();\n      genop_2(s, OP_METHOD, cursp(), idx);\n      pop();\n      genop_2(s, OP_DEF, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_POSTEXE:\n    codegen(s, tree, NOVAL);\n    break;\n\n  default:\n    break;\n  }\n exit:\n  s->rlev = rlev;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 2961,
    "critical_vars": [
      "s",
      "lv",
      "s2->ainfo"
    ],
    "function": "codegen",
    "filename": "mruby/CVE-2022-0632/CVE-2022-0632_CWE-476_44f591aa8f7091e6ca6cb418e428ae6d4ceaf77d_codegen.c.diff",
    "function_code": "codegen(codegen_scope *s, node *tree, int val)\n{\n  int nt;\n  int rlev = s->rlev;\n\n  if (!tree) {\n    if (val) {\n      genop_1(s, OP_LOADNIL, cursp());\n      push();\n    }\n    return;\n  }\n\n  s->rlev++;\n  if (s->rlev > MRB_CODEGEN_LEVEL_MAX) {\n    codegen_error(s, \"too complex expression\");\n  }\n  if (s->irep && s->filename_index != tree->filename_index) {\n    mrb_sym fname = mrb_parser_get_filename(s->parser, s->filename_index);\n    const char *filename = mrb_sym_name_len(s->mrb, fname, NULL);\n\n    mrb_debug_info_append_file(s->mrb, s->irep->debug_info,\n                               filename, s->lines, s->debug_start_pos, s->pc);\n    s->debug_start_pos = s->pc;\n    s->filename_index = tree->filename_index;\n    s->filename_sym = mrb_parser_get_filename(s->parser, tree->filename_index);\n  }\n\n  nt = nint(tree->car);\n  s->lineno = tree->lineno;\n  tree = tree->cdr;\n  switch (nt) {\n  case NODE_BEGIN:\n    if (val && !tree) {\n      genop_1(s, OP_LOADNIL, cursp());\n      push();\n    }\n    while (tree) {\n      codegen(s, tree->car, tree->cdr ? NOVAL : val);\n      tree = tree->cdr;\n    }\n    break;\n\n  case NODE_RESCUE:\n    {\n      int noexc;\n      uint32_t exend, pos1, pos2, tmp;\n      struct loopinfo *lp;\n      int catch_entry, begin, end;\n\n      if (tree->car == NULL) goto exit;\n      lp = loop_push(s, LOOP_BEGIN);\n      lp->pc0 = new_label(s);\n      catch_entry = catch_handler_new(s);\n      begin = s->pc;\n      codegen(s, tree->car, VAL);\n      pop();\n      lp->type = LOOP_RESCUE;\n      end = s->pc;\n      noexc = genjmp_0(s, OP_JMP);\n      catch_handler_set(s, catch_entry, MRB_CATCH_RESCUE, begin, end, s->pc);\n      tree = tree->cdr;\n      exend = JMPLINK_START;\n      pos1 = JMPLINK_START;\n      if (tree->car) {\n        node *n2 = tree->car;\n        int exc = cursp();\n\n        genop_1(s, OP_EXCEPT, exc);\n        push();\n        while (n2) {\n          node *n3 = n2->car;\n          node *n4 = n3->car;\n\n          dispatch(s, pos1);\n          pos2 = JMPLINK_START;\n          do {\n            if (n4 && n4->car && nint(n4->car->car) == NODE_SPLAT) {\n              codegen(s, n4->car, VAL);\n              gen_move(s, cursp(), exc, 0);\n              push_n(2); pop_n(2); /* space for one arg and a block */\n              pop();\n              genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_SYM_2(s->mrb, __case_eqq)), 1);\n            }\n            else {\n              if (n4) {\n                codegen(s, n4->car, VAL);\n              }\n              else {\n                genop_2(s, OP_GETCONST, cursp(), new_sym(s, MRB_SYM_2(s->mrb, StandardError)));\n                push();\n              }\n              pop();\n              genop_2(s, OP_RESCUE, exc, cursp());\n            }\n            tmp = genjmp2(s, OP_JMPIF, cursp(), pos2, val);\n            pos2 = tmp;\n            if (n4) {\n              n4 = n4->cdr;\n            }\n          } while (n4);\n          pos1 = genjmp_0(s, OP_JMP);\n          dispatch_linked(s, pos2);\n\n          pop();\n          if (n3->cdr->car) {\n            gen_assignment(s, n3->cdr->car, NULL, exc, NOVAL);\n          }\n          if (n3->cdr->cdr->car) {\n            codegen(s, n3->cdr->cdr->car, val);\n            if (val) pop();\n          }\n          tmp = genjmp(s, OP_JMP, exend);\n          exend = tmp;\n          n2 = n2->cdr;\n          push();\n        }\n        if (pos1 != JMPLINK_START) {\n          dispatch(s, pos1);\n          genop_1(s, OP_RAISEIF, exc);\n        }\n      }\n      pop();\n      tree = tree->cdr;\n      dispatch(s, noexc);\n      if (tree->car) {\n        codegen(s, tree->car, val);\n      }\n      else if (val) {\n        push();\n      }\n      dispatch_linked(s, exend);\n      loop_pop(s, NOVAL);\n    }\n    break;\n\n  case NODE_ENSURE:\n    if (!tree->cdr || !tree->cdr->cdr ||\n        (nint(tree->cdr->cdr->car) == NODE_BEGIN &&\n         tree->cdr->cdr->cdr)) {\n      int catch_entry, begin, end, target;\n      int idx;\n\n      catch_entry = catch_handler_new(s);\n      begin = s->pc;\n      codegen(s, tree->car, val);\n      end = target = s->pc;\n      push();\n      idx = cursp();\n      genop_1(s, OP_EXCEPT, idx);\n      push();\n      codegen(s, tree->cdr->cdr, NOVAL);\n      pop();\n      genop_1(s, OP_RAISEIF, idx);\n      pop();\n      catch_handler_set(s, catch_entry, MRB_CATCH_ENSURE, begin, end, target);\n    }\n    else {                      /* empty ensure ignored */\n      codegen(s, tree->car, val);\n    }\n    break;\n\n  case NODE_LAMBDA:\n    if (val) {\n      int idx = lambda_body(s, tree, 1);\n\n      genop_2(s, OP_LAMBDA, cursp(), idx);\n      push();\n    }\n    break;\n\n  case NODE_BLOCK:\n    if (val) {\n      int idx = lambda_body(s, tree, 1);\n\n      genop_2(s, OP_BLOCK, cursp(), idx);\n      push();\n    }\n    break;\n\n  case NODE_IF:\n    {\n      uint32_t pos1, pos2;\n      mrb_bool nil_p = FALSE;\n      node *elsepart = tree->cdr->cdr->car;\n\n      if (!tree->car) {\n        codegen(s, elsepart, val);\n        goto exit;\n      }\n      if (true_always(tree->car)) {\n        codegen(s, tree->cdr->car, val);\n        goto exit;\n      }\n      if (false_always(tree->car)) {\n        codegen(s, elsepart, val);\n        goto exit;\n      }\n      if (nint(tree->car->car) == NODE_CALL) {\n        node *n = tree->car->cdr;\n        mrb_sym mid = nsym(n->cdr->car);\n        mrb_sym sym_nil_p = MRB_SYM_Q_2(s->mrb, nil);\n        if (mid == sym_nil_p && n->cdr->cdr->car == NULL) {\n          nil_p = TRUE;\n          codegen(s, n->car, VAL);\n        }\n      }\n      if (!nil_p) {\n        codegen(s, tree->car, VAL);\n      }\n      pop();\n      if (val || tree->cdr->car) {\n        if (nil_p) {\n          pos2 = genjmp2_0(s, OP_JMPNIL, cursp(), val);\n          pos1 = genjmp_0(s, OP_JMP);\n          dispatch(s, pos2);\n        }\n        else {\n          pos1 = genjmp2_0(s, OP_JMPNOT, cursp(), val);\n        }\n        codegen(s, tree->cdr->car, val);\n        if (val) pop();\n        if (elsepart || val) {\n          pos2 = genjmp_0(s, OP_JMP);\n          dispatch(s, pos1);\n          codegen(s, elsepart, val);\n          dispatch(s, pos2);\n        }\n        else {\n          dispatch(s, pos1);\n        }\n      }\n      else {                    /* empty then-part */\n        if (elsepart) {\n          if (nil_p) {\n            pos1 = genjmp2_0(s, OP_JMPNIL, cursp(), val);\n          }\n          else {\n            pos1 = genjmp2_0(s, OP_JMPIF, cursp(), val);\n          }\n          codegen(s, elsepart, val);\n          dispatch(s, pos1);\n        }\n        else if (val && !nil_p) {\n          genop_1(s, OP_LOADNIL, cursp());\n          push();\n        }\n      }\n    }\n    break;\n\n  case NODE_AND:\n    {\n      uint32_t pos;\n\n      if (true_always(tree->car)) {\n        codegen(s, tree->cdr, val);\n        goto exit;\n      }\n      if (false_always(tree->car)) {\n        codegen(s, tree->car, val);\n        goto exit;\n      }\n      codegen(s, tree->car, VAL);\n      pop();\n      pos = genjmp2_0(s, OP_JMPNOT, cursp(), val);\n      codegen(s, tree->cdr, val);\n      dispatch(s, pos);\n    }\n    break;\n\n  case NODE_OR:\n    {\n      uint32_t pos;\n\n      if (true_always(tree->car)) {\n        codegen(s, tree->car, val);\n        goto exit;\n      }\n      if (false_always(tree->car)) {\n        codegen(s, tree->cdr, val);\n        goto exit;\n      }\n      codegen(s, tree->car, VAL);\n      pop();\n      pos = genjmp2_0(s, OP_JMPIF, cursp(), val);\n      codegen(s, tree->cdr, val);\n      dispatch(s, pos);\n    }\n    break;\n\n  case NODE_WHILE:\n  case NODE_UNTIL:\n    {\n      if (true_always(tree->car)) {\n        if (nt == NODE_UNTIL) {\n          if (val) {\n            genop_1(s, OP_LOADNIL, cursp());\n            push();\n          }\n          goto exit;\n        }\n      }\n      else if (false_always(tree->car)) {\n        if (nt == NODE_WHILE) {\n          if (val) {\n            genop_1(s, OP_LOADNIL, cursp());\n            push();\n          }\n          goto exit;\n        }\n      }\n\n      uint32_t pos = JMPLINK_START;\n      struct loopinfo *lp = loop_push(s, LOOP_NORMAL);\n\n      if (!val) lp->reg = -1;\n      lp->pc0 = new_label(s);\n      codegen(s, tree->car, VAL);\n      pop();\n      if (nt == NODE_WHILE) {\n        pos = genjmp2_0(s, OP_JMPNOT, cursp(), NOVAL);\n      }\n      else {\n        pos = genjmp2_0(s, OP_JMPIF, cursp(), NOVAL);\n      }\n      lp->pc1 = new_label(s);\n      codegen(s, tree->cdr, NOVAL);\n      genjmp(s, OP_JMP, lp->pc0);\n      dispatch(s, pos);\n      loop_pop(s, val);\n    }\n    break;\n\n  case NODE_FOR:\n    for_body(s, tree);\n    if (val) push();\n    break;\n\n  case NODE_CASE:\n    {\n      int head = 0;\n      uint32_t pos1, pos2, pos3, tmp;\n      node *n;\n\n      pos3 = JMPLINK_START;\n      if (tree->car) {\n        head = cursp();\n        codegen(s, tree->car, VAL);\n      }\n      tree = tree->cdr;\n      while (tree) {\n        n = tree->car->car;\n        pos1 = pos2 = JMPLINK_START;\n        while (n) {\n          codegen(s, n->car, VAL);\n          if (head) {\n            gen_move(s, cursp(), head, 0);\n            push(); push(); pop(); pop(); pop();\n            if (nint(n->car->car) == NODE_SPLAT) {\n              genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_SYM_2(s->mrb, __case_eqq)), 1);\n            }\n            else {\n              genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_OPSYM_2(s->mrb, eqq)), 1);\n            }\n          }\n          else {\n            pop();\n          }\n          tmp = genjmp2(s, OP_JMPIF, cursp(), pos2, NOVAL);\n          pos2 = tmp;\n          n = n->cdr;\n        }\n        if (tree->car->car) {\n          pos1 = genjmp_0(s, OP_JMP);\n          dispatch_linked(s, pos2);\n        }\n        codegen(s, tree->car->cdr, val);\n        if (val) pop();\n        tmp = genjmp(s, OP_JMP, pos3);\n        pos3 = tmp;\n        dispatch(s, pos1);\n        tree = tree->cdr;\n      }\n      if (val) {\n        uint32_t pos = cursp();\n        genop_1(s, OP_LOADNIL, cursp());\n        if (pos3 != JMPLINK_START) dispatch_linked(s, pos3);\n        if (head) pop();\n        if (cursp() != pos) {\n          gen_move(s, cursp(), pos, 0);\n        }\n        push();\n      }\n      else {\n        if (pos3 != JMPLINK_START) {\n          dispatch_linked(s, pos3);\n        }\n        if (head) {\n          pop();\n        }\n      }\n    }\n    break;\n\n  case NODE_SCOPE:\n    scope_body(s, tree, NOVAL);\n    break;\n\n  case NODE_FCALL:\n  case NODE_CALL:\n    gen_call(s, tree, val, 0);\n    break;\n  case NODE_SCALL:\n    gen_call(s, tree, val, 1);\n    break;\n\n  case NODE_DOT2:\n    codegen(s, tree->car, val);\n    codegen(s, tree->cdr, val);\n    if (val) {\n      pop(); pop();\n      genop_1(s, OP_RANGE_INC, cursp());\n      push();\n    }\n    break;\n\n  case NODE_DOT3:\n    codegen(s, tree->car, val);\n    codegen(s, tree->cdr, val);\n    if (val) {\n      pop(); pop();\n      genop_1(s, OP_RANGE_EXC, cursp());\n      push();\n    }\n    break;\n\n  case NODE_COLON2:\n    {\n      int sym = new_sym(s, nsym(tree->cdr));\n\n      codegen(s, tree->car, VAL);\n      pop();\n      genop_2(s, OP_GETMCNST, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_COLON3:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_1(s, OP_OCLASS, cursp());\n      genop_2(s, OP_GETMCNST, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_ARRAY:\n    {\n      int n;\n\n      n = gen_values(s, tree, val, 0);\n      if (val) {\n        if (n >= 0) {\n          pop_n(n);\n          genop_2(s, OP_ARRAY, cursp(), n);\n        }\n        push();\n      }\n    }\n    break;\n\n  case NODE_HASH:\n  case NODE_KW_HASH:\n    {\n      int nk = gen_hash(s, tree, val, GEN_LIT_ARY_MAX);\n      if (val && nk >= 0) {\n        pop_n(nk*2);\n        genop_2(s, OP_HASH, cursp(), nk);\n        push();\n      }\n    }\n    break;\n\n  case NODE_SPLAT:\n    codegen(s, tree, val);\n    break;\n\n  case NODE_ASGN:\n    gen_assignment(s, tree->car, tree->cdr, 0, val);\n    break;\n\n  case NODE_MASGN:\n    {\n      int len = 0, n = 0, post = 0;\n      node *t = tree->cdr, *p;\n      int rhs = cursp();\n\n      if (nint(t->car) == NODE_ARRAY && t->cdr && nosplat(t->cdr)) {\n        /* fixed rhs */\n        t = t->cdr;\n        while (t) {\n          codegen(s, t->car, VAL);\n          len++;\n          t = t->cdr;\n        }\n        tree = tree->car;\n        if (tree->car) {                /* pre */\n          t = tree->car;\n          n = 0;\n          while (t) {\n            if (n < len) {\n              gen_assignment(s, t->car, NULL, rhs+n, NOVAL);\n              n++;\n            }\n            else {\n              genop_1(s, OP_LOADNIL, rhs+n);\n              gen_assignment(s, t->car, NULL, rhs+n, NOVAL);\n            }\n            t = t->cdr;\n          }\n        }\n        t = tree->cdr;\n        if (t) {\n          if (t->cdr) {         /* post count */\n            p = t->cdr->car;\n            while (p) {\n              post++;\n              p = p->cdr;\n            }\n          }\n          if (t->car) {         /* rest (len - pre - post) */\n            int rn;\n\n            if (len < post + n) {\n              rn = 0;\n            }\n            else {\n              rn = len - post - n;\n            }\n            genop_3(s, OP_ARRAY2, cursp(), rhs+n, rn);\n            gen_assignment(s, t->car, NULL, cursp(), NOVAL);\n            n += rn;\n          }\n          if (t->cdr && t->cdr->car) {\n            t = t->cdr->car;\n            while (n<len) {\n              gen_assignment(s, t->car, NULL, rhs+n, NOVAL);\n              t = t->cdr;\n              n++;\n            }\n          }\n        }\n        pop_n(len);\n        if (val) {\n          genop_2(s, OP_ARRAY, rhs, len);\n          push();\n        }\n      }\n      else {\n        /* variable rhs */\n        codegen(s, t, VAL);\n        gen_vmassignment(s, tree->car, rhs, val);\n        if (!val) {\n          pop();\n        }\n      }\n    }\n    break;\n\n  case NODE_OP_ASGN:\n    {\n      mrb_sym sym = nsym(tree->cdr->car);\n      mrb_int len;\n      const char *name = mrb_sym_name_len(s->mrb, sym, &len);\n      int idx, callargs = -1, vsp = -1;\n\n      if ((len == 2 && name[0] == '|' && name[1] == '|') &&\n          (nint(tree->car->car) == NODE_CONST ||\n           nint(tree->car->car) == NODE_CVAR)) {\n        int catch_entry, begin, end;\n        int noexc, exc;\n        struct loopinfo *lp;\n\n        lp = loop_push(s, LOOP_BEGIN);\n        lp->pc0 = new_label(s);\n        catch_entry = catch_handler_new(s);\n        begin = s->pc;\n        exc = cursp();\n        codegen(s, tree->car, VAL);\n        end = s->pc;\n        noexc = genjmp_0(s, OP_JMP);\n        lp->type = LOOP_RESCUE;\n        catch_handler_set(s, catch_entry, MRB_CATCH_RESCUE, begin, end, s->pc);\n        genop_1(s, OP_EXCEPT, exc);\n        genop_1(s, OP_LOADF, exc);\n        dispatch(s, noexc);\n        loop_pop(s, NOVAL);\n      }\n      else if (nint(tree->car->car) == NODE_CALL) {\n        node *n = tree->car->cdr;\n        int base, i, nargs = 0;\n        callargs = 0;\n\n        if (val) {\n          vsp = cursp();\n          push();\n        }\n        codegen(s, n->car, VAL);   /* receiver */\n        idx = new_sym(s, nsym(n->cdr->car));\n        base = cursp()-1;\n        if (n->cdr->cdr->car) {\n          nargs = gen_values(s, n->cdr->cdr->car->car, VAL, 13);\n          if (nargs >= 0) {\n            callargs = nargs;\n          }\n          else { /* varargs */\n            push();\n            nargs = 1;\n            callargs = CALL_MAXARGS;\n          }\n        }\n        /* copy receiver and arguments */\n        gen_move(s, cursp(), base, 1);\n        for (i=0; i<nargs; i++) {\n          gen_move(s, cursp()+i+1, base+i+1, 1);\n        }\n        push_n(nargs+2);pop_n(nargs+2); /* space for receiver, arguments and a block */\n        genop_3(s, OP_SEND, cursp(), idx, callargs);\n        push();\n      }\n      else {\n        codegen(s, tree->car, VAL);\n      }\n      if (len == 2 &&\n          ((name[0] == '|' && name[1] == '|') ||\n           (name[0] == '&' && name[1] == '&'))) {\n        uint32_t pos;\n\n        pop();\n        if (val) {\n          if (vsp >= 0) {\n            gen_move(s, vsp, cursp(), 1);\n          }\n          pos = genjmp2_0(s, name[0]=='|'?OP_JMPIF:OP_JMPNOT, cursp(), val);\n        }\n        else {\n          pos = genjmp2_0(s, name[0]=='|'?OP_JMPIF:OP_JMPNOT, cursp(), val);\n        }\n        codegen(s, tree->cdr->cdr->car, VAL);\n        pop();\n        if (val && vsp >= 0) {\n          gen_move(s, vsp, cursp(), 1);\n        }\n        if (nint(tree->car->car) == NODE_CALL) {\n          if (callargs == CALL_MAXARGS) {\n            pop();\n            genop_2(s, OP_ARYPUSH, cursp(), 1);\n          }\n          else {\n            pop_n(callargs);\n            callargs++;\n          }\n          pop();\n          idx = new_sym(s, attrsym(s, nsym(tree->car->cdr->cdr->car)));\n          genop_3(s, OP_SEND, cursp(), idx, callargs);\n        }\n        else {\n          gen_assignment(s, tree->car, NULL, cursp(), val);\n        }\n        dispatch(s, pos);\n        goto exit;\n      }\n      codegen(s, tree->cdr->cdr->car, VAL);\n      push(); pop();\n      pop(); pop();\n\n      if (len == 1 && name[0] == '+')  {\n        gen_addsub(s, OP_ADD, cursp());\n      }\n      else if (len == 1 && name[0] == '-')  {\n        gen_addsub(s, OP_SUB, cursp());\n      }\n      else if (len == 1 && name[0] == '*')  {\n        genop_1(s, OP_MUL, cursp());\n      }\n      else if (len == 1 && name[0] == '/')  {\n        genop_1(s, OP_DIV, cursp());\n      }\n      else if (len == 1 && name[0] == '<')  {\n        genop_1(s, OP_LT, cursp());\n      }\n      else if (len == 2 && name[0] == '<' && name[1] == '=')  {\n        genop_1(s, OP_LE, cursp());\n      }\n      else if (len == 1 && name[0] == '>')  {\n        genop_1(s, OP_GT, cursp());\n      }\n      else if (len == 2 && name[0] == '>' && name[1] == '=')  {\n        genop_1(s, OP_GE, cursp());\n      }\n      else {\n        idx = new_sym(s, sym);\n        genop_3(s, OP_SEND, cursp(), idx, 1);\n      }\n      if (callargs < 0) {\n        gen_assignment(s, tree->car, NULL, cursp(), val);\n      }\n      else {\n        if (val && vsp >= 0) {\n          gen_move(s, vsp, cursp(), 0);\n        }\n        if (callargs == CALL_MAXARGS) {\n          pop();\n          genop_2(s, OP_ARYPUSH, cursp(), 1);\n        }\n        else {\n          pop_n(callargs);\n          callargs++;\n        }\n        pop();\n        idx = new_sym(s, attrsym(s,nsym(tree->car->cdr->cdr->car)));\n        genop_3(s, OP_SEND, cursp(), idx, callargs);\n      }\n    }\n    break;\n\n  case NODE_SUPER:\n    {\n      codegen_scope *s2 = s;\n      int lv = 0;\n      int n = 0, nk = 0, st = 0;\n\n      push();\n      while (!s2->mscope) {\n        lv++;\n        s2 = s2->prev;\n        if (!s2) break;\n      }\n      if (tree) {\n        node *args = tree->car;\n        if (args) {\n          st = n = gen_values(s, args, VAL, 14);\n          if (n < 0) {\n            st = 1; n = 15;\n            push();\n          }\n        }\n        /* keyword arguments */\n        if (s2 && (s2->ainfo & 0x1) && tree->cdr->car) {\n          nk = gen_hash(s, tree->cdr->car->cdr, VAL, 14);\n          if (nk < 0) {st++; nk = 15;}\n          else st += nk*2;\n          n |= nk<<4;\n        }\n        /* block arguments */\n        if (tree->cdr->cdr) {\n          codegen(s, tree->cdr->cdr, VAL);\n        }\n        else if (!s2) {/* super at top-level */\n          push();      /* no need to push block */\n        }\n        else {\n          gen_blkmove(s, s2->ainfo, lv);\n        }\n        st++;\n      }\n      else {\n        if (!s2) push();\n        else gen_blkmove(s, s2->ainfo, lv);\n        st++;\n      }\n      pop_n(st+1);\n      genop_2(s, OP_SUPER, cursp(), n);\n      if (val) push();\n    }\n    break;\n\n  case NODE_ZSUPER:\n    {\n      codegen_scope *s2 = s;\n      int lv = 0;\n      uint16_t ainfo = 0;\n      int n = CALL_MAXARGS;\n      int sp = cursp();\n\n      push();        /* room for receiver */\n      while (!s2->mscope) {\n        lv++;\n        s2 = s2->prev;\n        if (!s2) break;\n      }\n      if (s2 && s2->ainfo > 0) {\n        ainfo = s2->ainfo;\n      }\n      if (ainfo > 0) {\n        genop_2S(s, OP_ARGARY, cursp(), (ainfo<<4)|(lv & 0xf));\n        push(); push(); push();   /* ARGARY pushes 3 values at most */\n        pop(); pop(); pop();\n        /* keyword arguments */\n        if (ainfo & 0x1) {\n          n |= CALL_MAXARGS<<4;\n          push();\n        }\n        /* block argument */\n        if (tree && tree->cdr && tree->cdr->cdr) {\n          push();\n          codegen(s, tree->cdr->cdr, VAL);\n        }\n      }\n      else {\n        /* block argument */\n        if (tree && tree->cdr && tree->cdr->cdr) {\n          codegen(s, tree->cdr->cdr, VAL);\n        }\n        else {\n          gen_blkmove(s, 0, lv);\n        }\n        n = 0;\n      }\n      s->sp = sp;\n      genop_2(s, OP_SUPER, cursp(), n);\n      if (val) push();\n    }\n    break;\n\n  case NODE_RETURN:\n    if (tree) {\n      gen_retval(s, tree);\n    }\n    else {\n      genop_1(s, OP_LOADNIL, cursp());\n    }\n    if (s->loop) {\n      gen_return(s, OP_RETURN_BLK, cursp());\n    }\n    else {\n      gen_return(s, OP_RETURN, cursp());\n    }\n    if (val) push();\n    break;\n\n  case NODE_YIELD:\n    {\n      codegen_scope *s2 = s;\n      int lv = 0, ainfo = -1;\n      int n = 0, sendv = 0;\n\n      while (!s2->mscope) {\n        lv++;\n        s2 = s2->prev;\n        if (!s2) break;\n      }\n      if (s2) {\n        ainfo = (int)s2->ainfo;\n      }\n      if (ainfo < 0) codegen_error(s, \"invalid yield (SyntaxError)\");\n      push();\n      if (tree) {\n        n = gen_values(s, tree, VAL, 14);\n        if (n < 0) {\n          n = sendv = 1;\n          push();\n        }\n      }\n      push();pop(); /* space for a block */\n      pop_n(n+1);\n      genop_2S(s, OP_BLKPUSH, cursp(), (ainfo<<4)|(lv & 0xf));\n      if (sendv) n = CALL_MAXARGS;\n      genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_SYM_2(s->mrb, call)), n);\n      if (val) push();\n    }\n    break;\n\n  case NODE_BREAK:\n    loop_break(s, tree);\n    if (val) push();\n    break;\n\n  case NODE_NEXT:\n    if (!s->loop) {\n      raise_error(s, \"unexpected next\");\n    }\n    else if (s->loop->type == LOOP_NORMAL) {\n      codegen(s, tree, NOVAL);\n      genjmp(s, OP_JMPUW, s->loop->pc0);\n    }\n    else {\n      if (tree) {\n        codegen(s, tree, VAL);\n        pop();\n      }\n      else {\n        genop_1(s, OP_LOADNIL, cursp());\n      }\n      gen_return(s, OP_RETURN, cursp());\n    }\n    if (val) push();\n    break;\n\n  case NODE_REDO:\n    if (!s->loop || s->loop->type == LOOP_BEGIN || s->loop->type == LOOP_RESCUE) {\n      raise_error(s, \"unexpected redo\");\n    }\n    else {\n      genjmp(s, OP_JMPUW, s->loop->pc1);\n    }\n    if (val) push();\n    break;\n\n  case NODE_RETRY:\n    {\n      const char *msg = \"unexpected retry\";\n      const struct loopinfo *lp = s->loop;\n\n      while (lp && lp->type != LOOP_RESCUE) {\n        lp = lp->prev;\n      }\n      if (!lp) {\n        raise_error(s, msg);\n      }\n      else {\n        genjmp(s, OP_JMPUW, lp->pc0);\n      }\n      if (val) push();\n    }\n    break;\n\n  case NODE_LVAR:\n    if (val) {\n      int idx = lv_idx(s, nsym(tree));\n\n      if (idx > 0) {\n        gen_move(s, cursp(), idx, val);\n      }\n      else {\n        gen_getupvar(s, cursp(), nsym(tree));\n      }\n      push();\n    }\n    break;\n\n  case NODE_NVAR:\n    if (val) {\n      int idx = nint(tree);\n\n      gen_move(s, cursp(), idx, val);\n\n      push();\n    }\n    break;\n\n  case NODE_GVAR:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_GETGV, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_IVAR:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_GETIV, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_CVAR:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_GETCV, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_CONST:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_GETCONST, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_BACK_REF:\n    if (val) {\n      char buf[] = {'$', nchar(tree)};\n      int sym = new_sym(s, mrb_intern(s->mrb, buf, sizeof(buf)));\n\n      genop_2(s, OP_GETGV, cursp(), sym);\n      push();\n    }\n    break;\n\n  case NODE_NTH_REF:\n    if (val) {\n      mrb_state *mrb = s->mrb;\n      mrb_value str;\n      int sym;\n\n      str = mrb_format(mrb, \"$%d\", nint(tree));\n      sym = new_sym(s, mrb_intern_str(mrb, str));\n      genop_2(s, OP_GETGV, cursp(), sym);\n      push();\n    }\n    break;\n\n  case NODE_ARG:\n    /* should not happen */\n    break;\n\n  case NODE_BLOCK_ARG:\n    if (!tree) {\n      int idx = lv_idx(s, MRB_OPSYM_2(s->mrb, and));\n\n      if (idx == 0) {\n        codegen_error(s, \"no anonymous block argument\");\n      }\n      gen_move(s, cursp(), idx, val);\n    }\n    else {\n      codegen(s, tree, val);\n    }\n    break;\n\n  case NODE_INT:\n    if (val) {\n      char *p = (char*)tree->car;\n      int base = nint(tree->cdr->car);\n      mrb_int i;\n      mrb_bool overflow;\n\n      i = readint(s, p, base, FALSE, &overflow);\n      if (overflow) {\n        int off = new_litbn(s, p, base, FALSE);\n        genop_2(s, OP_LOADL, cursp(), off);\n      }\n      else {\n        gen_int(s, cursp(), i);\n      }\n      push();\n    }\n    break;\n\n#ifndef MRB_NO_FLOAT\n  case NODE_FLOAT:\n    if (val) {\n      char *p = (char*)tree;\n      mrb_float f = mrb_float_read(p, NULL);\n      int off = new_lit(s, mrb_float_value(s->mrb, f));\n\n      genop_2(s, OP_LOADL, cursp(), off);\n      push();\n    }\n    break;\n#endif\n\n  case NODE_NEGATE:\n    {\n      nt = nint(tree->car);\n      switch (nt) {\n#ifndef MRB_NO_FLOAT\n      case NODE_FLOAT:\n        if (val) {\n          char *p = (char*)tree->cdr;\n          mrb_float f = mrb_float_read(p, NULL);\n          int off = new_lit(s, mrb_float_value(s->mrb, -f));\n\n          genop_2(s, OP_LOADL, cursp(), off);\n          push();\n        }\n        break;\n#endif\n\n      case NODE_INT:\n        if (val) {\n          char *p = (char*)tree->cdr->car;\n          int base = nint(tree->cdr->cdr->car);\n          mrb_int i;\n          mrb_bool overflow;\n\n          i = readint(s, p, base, TRUE, &overflow);\n          if (overflow) {\n            int off = new_litbn(s, p, base, TRUE);\n            genop_2(s, OP_LOADL, cursp(), off);\n          }\n          else {\n            gen_int(s, cursp(), i);\n          }\n          push();\n        }\n        break;\n\n      default:\n        if (val) {\n          codegen(s, tree, VAL);\n          pop();\n          push_n(2);pop_n(2); /* space for receiver&block */\n          mrb_sym minus = MRB_OPSYM_2(s->mrb, minus);\n          if (!gen_uniop(s, minus, cursp())) {\n            genop_3(s, OP_SEND, cursp(), new_sym(s, minus), 0);\n          }\n          push();\n        }\n        else {\n          codegen(s, tree, NOVAL);\n        }\n        break;\n      }\n    }\n    break;\n\n  case NODE_STR:\n    if (val) {\n      char *p = (char*)tree->car;\n      size_t len = (intptr_t)tree->cdr;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int off = new_lit(s, mrb_str_new(s->mrb, p, len));\n\n      mrb_gc_arena_restore(s->mrb, ai);\n      genop_2(s, OP_STRING, cursp(), off);\n      push();\n    }\n    break;\n\n  case NODE_HEREDOC:\n    tree = ((struct mrb_parser_heredoc_info *)tree)->doc;\n    /* fall through */\n  case NODE_DSTR:\n    if (val) {\n      node *n = tree;\n\n      if (!n) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n        break;\n      }\n      codegen(s, n->car, VAL);\n      n = n->cdr;\n      while (n) {\n        codegen(s, n->car, VAL);\n        pop(); pop();\n        genop_1(s, OP_STRCAT, cursp());\n        push();\n        n = n->cdr;\n      }\n    }\n    else {\n      node *n = tree;\n\n      while (n) {\n        if (nint(n->car->car) != NODE_STR) {\n          codegen(s, n->car, NOVAL);\n        }\n        n = n->cdr;\n      }\n    }\n    break;\n\n  case NODE_WORDS:\n    gen_literal_array(s, tree, FALSE, val);\n    break;\n\n  case NODE_SYMBOLS:\n    gen_literal_array(s, tree, TRUE, val);\n    break;\n\n  case NODE_DXSTR:\n    {\n      node *n;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int sym = new_sym(s, MRB_SYM_2(s->mrb, Kernel));\n\n      genop_1(s, OP_LOADSELF, cursp());\n      push();\n      codegen(s, tree->car, VAL);\n      n = tree->cdr;\n      while (n) {\n        if (nint(n->car->car) == NODE_XSTR) {\n          n->car->car = (struct mrb_ast_node*)(intptr_t)NODE_STR;\n          mrb_assert(!n->cdr); /* must be the end */\n        }\n        codegen(s, n->car, VAL);\n        pop(); pop();\n        genop_1(s, OP_STRCAT, cursp());\n        push();\n        n = n->cdr;\n      }\n      push();                   /* for block */\n      pop_n(3);\n      sym = new_sym(s, MRB_OPSYM_2(s->mrb, tick)); /* ` */\n      genop_3(s, OP_SEND, cursp(), sym, 1);\n      if (val) push();\n      mrb_gc_arena_restore(s->mrb, ai);\n    }\n    break;\n\n  case NODE_XSTR:\n    {\n      char *p = (char*)tree->car;\n      size_t len = (intptr_t)tree->cdr;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int off = new_lit(s, mrb_str_new(s->mrb, p, len));\n      int sym;\n\n      genop_1(s, OP_LOADSELF, cursp());\n      push();\n      genop_2(s, OP_STRING, cursp(), off);\n      push(); push();\n      pop_n(3);\n      sym = new_sym(s, MRB_OPSYM_2(s->mrb, tick)); /* ` */\n      genop_3(s, OP_SEND, cursp(), sym, 1);\n      if (val) push();\n      mrb_gc_arena_restore(s->mrb, ai);\n    }\n    break;\n\n  case NODE_REGX:\n    if (val) {\n      char *p1 = (char*)tree->car;\n      char *p2 = (char*)tree->cdr->car;\n      char *p3 = (char*)tree->cdr->cdr;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int sym = new_sym(s, mrb_intern_lit(s->mrb, REGEXP_CLASS));\n      int off = new_lit(s, mrb_str_new_cstr(s->mrb, p1));\n      int argc = 1;\n\n      genop_1(s, OP_OCLASS, cursp());\n      genop_2(s, OP_GETMCNST, cursp(), sym);\n      push();\n      genop_2(s, OP_STRING, cursp(), off);\n      push();\n      if (p2 || p3) {\n        if (p2) { /* opt */\n          off = new_lit(s, mrb_str_new_cstr(s->mrb, p2));\n          genop_2(s, OP_STRING, cursp(), off);\n        }\n        else {\n          genop_1(s, OP_LOADNIL, cursp());\n        }\n        push();\n        argc++;\n        if (p3) { /* enc */\n          off = new_lit(s, mrb_str_new(s->mrb, p3, 1));\n          genop_2(s, OP_STRING, cursp(), off);\n          push();\n          argc++;\n        }\n      }\n      push(); /* space for a block */\n      pop_n(argc+2);\n      sym = new_sym(s, MRB_SYM_2(s->mrb, compile));\n      genop_3(s, OP_SEND, cursp(), sym, argc);\n      mrb_gc_arena_restore(s->mrb, ai);\n      push();\n    }\n    break;\n\n  case NODE_DREGX:\n    if (val) {\n      node *n = tree->car;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int sym = new_sym(s, mrb_intern_lit(s->mrb, REGEXP_CLASS));\n      int argc = 1;\n      int off;\n      char *p;\n\n      genop_1(s, OP_OCLASS, cursp());\n      genop_2(s, OP_GETMCNST, cursp(), sym);\n      push();\n      codegen(s, n->car, VAL);\n      n = n->cdr;\n      while (n) {\n        codegen(s, n->car, VAL);\n        pop(); pop();\n        genop_1(s, OP_STRCAT, cursp());\n        push();\n        n = n->cdr;\n      }\n      n = tree->cdr->cdr;\n      if (n->car) { /* tail */\n        p = (char*)n->car;\n        off = new_lit(s, mrb_str_new_cstr(s->mrb, p));\n        codegen(s, tree->car, VAL);\n        genop_2(s, OP_STRING, cursp(), off);\n        pop();\n        genop_1(s, OP_STRCAT, cursp());\n        push();\n      }\n      if (n->cdr->car) { /* opt */\n        char *p2 = (char*)n->cdr->car;\n        off = new_lit(s, mrb_str_new_cstr(s->mrb, p2));\n        genop_2(s, OP_STRING, cursp(), off);\n        push();\n        argc++;\n      }\n      if (n->cdr->cdr) { /* enc */\n        char *p2 = (char*)n->cdr->cdr;\n        off = new_lit(s, mrb_str_new_cstr(s->mrb, p2));\n        genop_2(s, OP_STRING, cursp(), off);\n        push();\n        argc++;\n      }\n      push(); /* space for a block */\n      pop_n(argc+2);\n      sym = new_sym(s, MRB_SYM_2(s->mrb, compile));\n      genop_3(s, OP_SEND, cursp(), sym, argc);\n      mrb_gc_arena_restore(s->mrb, ai);\n      push();\n    }\n    else {\n      node *n = tree->car;\n\n      while (n) {\n        if (nint(n->car->car) != NODE_STR) {\n          codegen(s, n->car, NOVAL);\n        }\n        n = n->cdr;\n      }\n    }\n    break;\n\n  case NODE_SYM:\n    if (val) {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_LOADSYM, cursp(), sym);\n      push();\n    }\n    break;\n\n  case NODE_DSYM:\n    codegen(s, tree, val);\n    if (val) {\n      gen_intern(s);\n    }\n    break;\n\n  case NODE_SELF:\n    if (val) {\n      genop_1(s, OP_LOADSELF, cursp());\n      push();\n    }\n    break;\n\n  case NODE_NIL:\n    if (val) {\n      genop_1(s, OP_LOADNIL, cursp());\n      push();\n    }\n    break;\n\n  case NODE_TRUE:\n    if (val) {\n      genop_1(s, OP_LOADT, cursp());\n      push();\n    }\n    break;\n\n  case NODE_FALSE:\n    if (val) {\n      genop_1(s, OP_LOADF, cursp());\n      push();\n    }\n    break;\n\n  case NODE_ALIAS:\n    {\n      int a = new_sym(s, nsym(tree->car));\n      int b = new_sym(s, nsym(tree->cdr));\n\n      genop_2(s, OP_ALIAS, a, b);\n      if (val) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n    }\n   break;\n\n  case NODE_UNDEF:\n    {\n      node *t = tree;\n\n      while (t) {\n        int symbol = new_sym(s, nsym(t->car));\n        genop_1(s, OP_UNDEF, symbol);\n        t = t->cdr;\n      }\n      if (val) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n    }\n    break;\n\n  case NODE_CLASS:\n    {\n      int idx;\n      node *body;\n\n      if (tree->car->car == (node*)0) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n      else if (tree->car->car == (node*)1) {\n        genop_1(s, OP_OCLASS, cursp());\n        push();\n      }\n      else {\n        codegen(s, tree->car->car, VAL);\n      }\n      if (tree->cdr->car) {\n        codegen(s, tree->cdr->car, VAL);\n      }\n      else {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n      pop(); pop();\n      idx = new_sym(s, nsym(tree->car->cdr));\n      genop_2(s, OP_CLASS, cursp(), idx);\n      body = tree->cdr->cdr->car;\n      if (nint(body->cdr->car) == NODE_BEGIN && body->cdr->cdr == NULL) {\n        genop_1(s, OP_LOADNIL, cursp());\n      }\n      else {\n        idx = scope_body(s, body, val);\n        genop_2(s, OP_EXEC, cursp(), idx);\n      }\n      if (val) {\n        push();\n      }\n    }\n    break;\n\n  case NODE_MODULE:\n    {\n      int idx;\n\n      if (tree->car->car == (node*)0) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n      else if (tree->car->car == (node*)1) {\n        genop_1(s, OP_OCLASS, cursp());\n        push();\n      }\n      else {\n        codegen(s, tree->car->car, VAL);\n      }\n      pop();\n      idx = new_sym(s, nsym(tree->car->cdr));\n      genop_2(s, OP_MODULE, cursp(), idx);\n      if (nint(tree->cdr->car->cdr->car) == NODE_BEGIN &&\n          tree->cdr->car->cdr->cdr == NULL) {\n        genop_1(s, OP_LOADNIL, cursp());\n      }\n      else {\n        idx = scope_body(s, tree->cdr->car, val);\n        genop_2(s, OP_EXEC, cursp(), idx);\n      }\n      if (val) {\n        push();\n      }\n    }\n    break;\n\n  case NODE_SCLASS:\n    {\n      int idx;\n\n      codegen(s, tree->car, VAL);\n      pop();\n      genop_1(s, OP_SCLASS, cursp());\n      if (nint(tree->cdr->car->cdr->car) == NODE_BEGIN &&\n          tree->cdr->car->cdr->cdr == NULL) {\n        genop_1(s, OP_LOADNIL, cursp());\n      }\n      else {\n        idx = scope_body(s, tree->cdr->car, val);\n        genop_2(s, OP_EXEC, cursp(), idx);\n      }\n      if (val) {\n        push();\n      }\n    }\n    break;\n\n  case NODE_DEF:\n    {\n      int sym = new_sym(s, nsym(tree->car));\n      int idx = lambda_body(s, tree->cdr, 0);\n\n      genop_1(s, OP_TCLASS, cursp());\n      push();\n      genop_2(s, OP_METHOD, cursp(), idx);\n      push(); pop();\n      pop();\n      genop_2(s, OP_DEF, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_SDEF:\n    {\n      node *recv = tree->car;\n      int sym = new_sym(s, nsym(tree->cdr->car));\n      int idx = lambda_body(s, tree->cdr->cdr, 0);\n\n      codegen(s, recv, VAL);\n      pop();\n      genop_1(s, OP_SCLASS, cursp());\n      push();\n      genop_2(s, OP_METHOD, cursp(), idx);\n      pop();\n      genop_2(s, OP_DEF, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_POSTEXE:\n    codegen(s, tree, NOVAL);\n    break;\n\n  default:\n    break;\n  }\n exit:\n  s->rlev = rlev;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 330,
    "critical_vars": [
      "fe->fi_file_name",
      "&m3"
    ],
    "function": "print_just_file_entry_details",
    "filename": "libdwarf-code/CVE-2020-28163/CVE-2020-28163_CWE-476_faf99408e3f9f706fc3809dd400e831f989778d3_dwarf_print_lines.c.diff",
    "function_code": "print_just_file_entry_details(Dwarf_Debug dbg,\n    Dwarf_Line_Context line_context)\n{\n    unsigned fiu = 0;\n    Dwarf_File_Entry fe = line_context->lc_file_entries;\n    Dwarf_File_Entry fe2 = fe;\n    dwarfstring m3;\n\n    dwarfstring_constructor_static(&m3,locallinebuf,\n        sizeof(locallinebuf));\n    dwarfstring_append_printf_i(&m3,\n        \"  file names count      %d\\n\",\n        line_context->lc_file_entry_count);\n    _dwarf_printf(dbg,dwarfstring_string(&m3));\n    dwarfstring_reset(&m3);\n    for (fiu = 0 ; fe2 ; fe2 = fe->fi_next,++fiu ) {\n        Dwarf_Unsigned tlm2 = 0;\n        unsigned filenum = 0;\n\n        fe = fe2;\n        tlm2 = fe->fi_time_last_mod;\n        filenum = fiu+1;\n\n        /*  The space character at the end of line is silly,\n            but lets leave it there for the moment to avoid\n            changing output.  */\n        if (line_context->lc_file_entry_count > 9) {\n            dwarfstring_append_printf_u(&m3,\n                \"  file[%2u] \",fiu);\n            dwarfstring_append_printf_s(&m3,\n                \"%-20s \",\n                (char *) fe->fi_file_name);\n            dwarfstring_append_printf_u(&m3,\n                \"(file-number: %u)\\n\",\n                filenum);\n        } else {\n            dwarfstring_append_printf_u(&m3,\n                \"  file[%u]  \", fiu);\n            dwarfstring_append_printf_s(&m3,\n                \"%-20s \",(char *)fe->fi_file_name);\n            dwarfstring_append_printf_u(&m3,\n                \"(file-number: %u)\\n\",filenum);\n        }\n        _dwarf_printf(dbg,dwarfstring_string(&m3));\n        dwarfstring_reset(&m3);\n        if (fe->fi_dir_index_present) {\n            Dwarf_Unsigned di = 0;\n            di = fe->fi_dir_index;\n            dwarfstring_append_printf_i(&m3,\n                \"    dir index %d\\n\", di);\n        }\n        if (fe->fi_time_last_mod_present) {\n            time_t tt = (time_t) tlm2;\n\n            /* ctime supplies newline */\n            dwarfstring_append_printf_u(&m3,\n                \"    last time 0x%x \",tlm2);\n            dwarfstring_append(&m3,(char *)ctime(&tt));\n        }\n        if (fe->fi_file_length_present) {\n            Dwarf_Unsigned fl = 0;\n\n            fl = fe->fi_file_length;\n            dwarfstring_append_printf_i(&m3,\n                \"    file length %ld \",fl);\n            dwarfstring_append_printf_u(&m3,\n                \"0x%lx\\n\",fl);\n        }\n        if (fe->fi_md5_present) {\n            char *c = (char *)&fe->fi_md5_value;\n            char *end = c+sizeof(fe->fi_md5_value);\n            dwarfstring_append(&m3, \"    file md5 value 0x\");\n            while(c < end) {\n                dwarfstring_append_printf_u(&m3,\n                    \"%02x\",0xff&*c);\n                ++c;\n            }\n            dwarfstring_append(&m3,\"\\n\");\n        }\n        if (dwarfstring_strlen(&m3)) {\n            _dwarf_printf(dbg,dwarfstring_string(&m3));\n            dwarfstring_reset(&m3);\n        }\n    }\n    dwarfstring_destructor(&m3);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 345,
    "critical_vars": [
      "fe->fi_file_name",
      "&m3"
    ],
    "function": "print_just_file_entry_details",
    "filename": "libdwarf-code/CVE-2020-28163/CVE-2020-28163_CWE-476_faf99408e3f9f706fc3809dd400e831f989778d3_dwarf_print_lines.c.diff",
    "function_code": "print_just_file_entry_details(Dwarf_Debug dbg,\n    Dwarf_Line_Context line_context)\n{\n    unsigned fiu = 0;\n    Dwarf_File_Entry fe = line_context->lc_file_entries;\n    Dwarf_File_Entry fe2 = fe;\n    dwarfstring m3;\n\n    dwarfstring_constructor_static(&m3,locallinebuf,\n        sizeof(locallinebuf));\n    dwarfstring_append_printf_i(&m3,\n        \"  file names count      %d\\n\",\n        line_context->lc_file_entry_count);\n    _dwarf_printf(dbg,dwarfstring_string(&m3));\n    dwarfstring_reset(&m3);\n    for (fiu = 0 ; fe2 ; fe2 = fe->fi_next,++fiu ) {\n        Dwarf_Unsigned tlm2 = 0;\n        unsigned filenum = 0;\n\n        fe = fe2;\n        tlm2 = fe->fi_time_last_mod;\n        filenum = fiu+1;\n\n        /*  The space character at the end of line is silly,\n            but lets leave it there for the moment to avoid\n            changing output.  */\n        if (line_context->lc_file_entry_count > 9) {\n            dwarfstring_append_printf_u(&m3,\n                \"  file[%2u] \",fiu);\n        } else {\n            dwarfstring_append_printf_u(&m3,\n                \"  file[%u]  \", fiu);\n        }\n        /*  DWARF5 can have a null fi_file_name\n            if  the format code in the\n            line table header is unknown, such\n            as in a corrupt object file. */\n        dwarfstring_append_printf_s(&m3,\n            \"%-20s \",\n            fe->fi_file_name?\n            (char *) fe->fi_file_name:\n            \"<no file name>\");\n        dwarfstring_append_printf_u(&m3,\n            \"(file-number: %u)\\n\",\n            filenum);\n        _dwarf_printf(dbg,dwarfstring_string(&m3));\n        dwarfstring_reset(&m3);\n        if (fe->fi_dir_index_present) {\n            Dwarf_Unsigned di = 0;\n            di = fe->fi_dir_index;\n            dwarfstring_append_printf_i(&m3,\n                \"    dir index %d\\n\", di);\n        }\n        if (fe->fi_time_last_mod_present) {\n            time_t tt = (time_t) tlm2;\n\n            /* ctime supplies newline */\n            dwarfstring_append_printf_u(&m3,\n                \"    last time 0x%x \",tlm2);\n            dwarfstring_append(&m3,(char *)ctime(&tt));\n        }\n        if (fe->fi_file_length_present) {\n            Dwarf_Unsigned fl = 0;\n\n            fl = fe->fi_file_length;\n            dwarfstring_append_printf_i(&m3,\n                \"    file length %ld \",fl);\n            dwarfstring_append_printf_u(&m3,\n                \"0x%lx\\n\",fl);\n        }\n        if (fe->fi_md5_present) {\n            char *c = (char *)&fe->fi_md5_value;\n            char *end = c+sizeof(fe->fi_md5_value);\n            dwarfstring_append(&m3, \"    file md5 value 0x\");\n            while(c < end) {\n                dwarfstring_append_printf_u(&m3,\n                    \"%02x\",0xff&*c);\n                ++c;\n            }\n            dwarfstring_append(&m3,\"\\n\");\n        }\n        if (dwarfstring_strlen(&m3)) {\n            _dwarf_printf(dbg,dwarfstring_string(&m3));\n            dwarfstring_reset(&m3);\n        }\n    }\n    dwarfstring_destructor(&m3);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 91,
    "critical_vars": [
      "m_StscAtom"
    ],
    "function": "AP4_AtomSampleTable::GetSample",
    "filename": "Bento4/CVE-2017-12476/CVE-2017-12476_CWE-476_4d3f0bebd5f8518fd775f671c12bea58c68e814e_Ap4AtomSampleTable.cpp.diff",
    "function_code": "AP4_AtomSampleTable::GetSample(AP4_Ordinal index, \n                               AP4_Sample& sample)\n{\n    AP4_Result result;\n\n    // check that we have an stsc atom\n    if (!m_StscAtom) {\n        return AP4_ERROR_INVALID_FORMAT;\n    }\n    \n    // check that we have a chunk offset table\n    if (m_StcoAtom == NULL && m_Co64Atom == NULL) {\n        return AP4_ERROR_INVALID_FORMAT;\n    }\n\n    // MP4 uses 1-based indexes internally, so adjust by one\n    index++;\n\n    // find out in which chunk this sample is located\n    AP4_Ordinal chunk, skip, desc;\n    result = m_StscAtom->GetChunkForSample(index, chunk, skip, desc);\n    if (AP4_FAILED(result)) return result;\n    \n    // check that the result is within bounds\n    if (skip > index) return AP4_ERROR_INTERNAL;\n\n    // get the atom offset for this chunk\n    AP4_UI64 offset;\n    if (m_StcoAtom) {\n        AP4_UI32 offset_32;\n        result = m_StcoAtom->GetChunkOffset(chunk, offset_32);\n        offset = offset_32;\n    } else {\n        result = m_Co64Atom->GetChunkOffset(chunk, offset);\n    }\n    if (AP4_FAILED(result)) return result;\n    \n    // compute the additional offset inside the chunk\n    for (unsigned int i = index-skip; i < index; i++) {\n        AP4_Size size = 0;\n        if (m_StszAtom) {\n            result = m_StszAtom->GetSampleSize(i, size); \n        } else if (m_Stz2Atom) {\n            result = m_Stz2Atom->GetSampleSize(i, size); \n        } else {\n            result = AP4_ERROR_INVALID_FORMAT;\n        }\n        if (AP4_FAILED(result)) return result;\n        offset += size;\n    }\n\n    // set the description index\n    sample.SetDescriptionIndex(desc-1); // adjust for 0-based indexes\n\n    // set the dts and cts\n    AP4_UI32 cts_offset = 0;\n    AP4_UI64 dts        = 0;\n    AP4_UI32 duration   = 0;\n    result = m_SttsAtom->GetDts(index, dts, &duration);\n    if (AP4_FAILED(result)) return result;\n    sample.SetDuration(duration);\n    sample.SetDts(dts);\n    if (m_CttsAtom == NULL) {\n        sample.SetCts(dts);\n    } else {\n        result = m_CttsAtom->GetCtsOffset(index, cts_offset); \n\t    if (AP4_FAILED(result)) return result;\n        sample.SetCtsDelta(cts_offset);\n    }     \n\n    // set the size\n    AP4_Size sample_size = 0;\n    if (m_StszAtom) {\n        result = m_StszAtom->GetSampleSize(index, sample_size); \n    } else if (m_Stz2Atom) {\n        result = m_Stz2Atom->GetSampleSize(index, sample_size); \n    } else {\n        result = AP4_ERROR_INVALID_FORMAT;\n    }\n    if (AP4_FAILED(result)) return result;\n    sample.SetSize(sample_size);\n\n    // set the sync flag\n    if (m_StssAtom == NULL) {\n        sample.SetSync(true);\n    } else {\n        sample.SetSync(m_StssAtom->IsSampleSync(index));\n    }\n\n    // set the offset\n    sample.SetOffset(offset);\n\n    // set the data stream\n    sample.SetDataStream(m_SampleStream);\n\n\n    return AP4_SUCCESS;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 557,
    "critical_vars": [
      "cursors"
    ],
    "function": "AP4_Processor::Process",
    "filename": "Bento4/CVE-2017-12476/CVE-2017-12476_CWE-476_4d3f0bebd5f8518fd775f671c12bea58c68e814e_Ap4Processor.cpp.diff",
    "function_code": "AP4_Processor::Process(AP4_ByteStream&   input, \n                       AP4_ByteStream&   output,\n                       AP4_ByteStream*   fragments,\n                       ProgressListener* listener,\n                       AP4_AtomFactory&  atom_factory)\n{\n    // read all atoms.\n    // keep all atoms except [mdat]\n    // keep a ref to [moov]\n    // put [moof] atoms in a separate list\n    AP4_AtomParent              top_level;\n    AP4_MoovAtom*               moov = NULL;\n    AP4_ContainerAtom*          mfra = NULL;\n    AP4_SidxAtom*               sidx = NULL;\n    AP4_List<AP4_AtomLocator>   frags;\n    AP4_UI64                    stream_offset = 0;\n    bool                        in_fragments = false;\n    unsigned int                sidx_count = 0;\n    for (AP4_Atom* atom = NULL;\n        AP4_SUCCEEDED(atom_factory.CreateAtomFromStream(input, atom));\n        input.Tell(stream_offset)) {\n        if (atom->GetType() == AP4_ATOM_TYPE_MDAT) {\n            delete atom;\n            continue;\n        } else if (atom->GetType() == AP4_ATOM_TYPE_MOOV) {\n            moov = AP4_DYNAMIC_CAST(AP4_MoovAtom, atom);\n            if (fragments) break;\n        } else if (atom->GetType() == AP4_ATOM_TYPE_MFRA) {\n            mfra = AP4_DYNAMIC_CAST(AP4_ContainerAtom, atom);\n            continue;\n        } else if (atom->GetType() == AP4_ATOM_TYPE_SIDX) {\n            // don't keep the index, it is likely to be invalidated, we will recompute it later\n            ++sidx_count;\n            if (sidx == NULL) {\n                sidx = AP4_DYNAMIC_CAST(AP4_SidxAtom, atom);\n            } else {\n                delete atom;\n                continue;\n            }\n        } else if (atom->GetType() == AP4_ATOM_TYPE_SSIX) {\n            // don't keep the index, it is likely to be invalidated\n            delete atom;\n            continue;\n        } else if (!fragments && (in_fragments || atom->GetType() == AP4_ATOM_TYPE_MOOF)) {\n            in_fragments = true;\n            frags.Add(new AP4_AtomLocator(atom, stream_offset));\n            continue;\n        }\n        top_level.AddChild(atom);\n    }\n\n    // check that we have at most one sidx (we can't deal with multi-sidx streams here\n    if (sidx_count > 1) {\n        top_level.RemoveChild(sidx);\n        delete sidx;\n        sidx = NULL;\n    }\n    \n    // if we have a fragments stream, get the fragment locators from there\n    if (fragments) {\n        stream_offset = 0;\n        for (AP4_Atom* atom = NULL;\n            AP4_SUCCEEDED(atom_factory.CreateAtomFromStream(*fragments, atom));\n            fragments->Tell(stream_offset)) {\n            if (atom->GetType() == AP4_ATOM_TYPE_MDAT) {\n                delete atom;\n                continue;\n            }\n            frags.Add(new AP4_AtomLocator(atom, stream_offset));\n        }\n    }\n    \n    // initialize the processor\n    AP4_Result result = Initialize(top_level, input);\n    if (AP4_FAILED(result)) return result;\n\n    // process the tracks if we have a moov atom\n    AP4_Array<AP4_SampleLocator> locators;\n    AP4_Cardinal                 track_count       = 0;\n    AP4_List<AP4_TrakAtom>*      trak_atoms        = NULL;\n    AP4_LargeSize                mdat_payload_size = 0;\n    AP4_SampleCursor*            cursors           = NULL;\n    if (moov) {\n        // build an array of track sample locators\n        trak_atoms = &moov->GetTrakAtoms();\n        track_count = trak_atoms->ItemCount();\n        cursors = new AP4_SampleCursor[track_count];\n        m_TrackHandlers.SetItemCount(track_count);\n        m_TrackIds.SetItemCount(track_count);\n        for (AP4_Ordinal i=0; i<track_count; i++) {\n            m_TrackHandlers[i] = NULL;\n            m_TrackIds[i] = 0;\n        }\n        \n        unsigned int index = 0;\n        for (AP4_List<AP4_TrakAtom>::Item* item = trak_atoms->FirstItem(); item; item=item->GetNext()) {\n            AP4_TrakAtom* trak = item->GetData();\n\n            // find the stsd atom\n            AP4_ContainerAtom* stbl = AP4_DYNAMIC_CAST(AP4_ContainerAtom, trak->FindChild(\"mdia/minf/stbl\"));\n            if (stbl == NULL) continue;\n            \n            // see if there's an external data source for this track\n            AP4_ByteStream* trak_data_stream = &input;\n            for (AP4_List<ExternalTrackData>::Item* ditem = m_ExternalTrackData.FirstItem(); ditem; ditem=ditem->GetNext()) {\n                ExternalTrackData* tdata = ditem->GetData();\n                if (tdata->m_TrackId == trak->GetId()) {\n                    trak_data_stream = tdata->m_MediaData;\n                    break;\n                }\n            }\n\n            // create the track handler    \n            m_TrackHandlers[index] = CreateTrackHandler(trak);\n            m_TrackIds[index]      = trak->GetId();\n            cursors[index].m_Locator.m_TrakIndex   = index;\n            cursors[index].m_Locator.m_SampleTable = new AP4_AtomSampleTable(stbl, *trak_data_stream);\n            cursors[index].m_Locator.m_SampleIndex = 0;\n            cursors[index].m_Locator.m_ChunkIndex  = 0;\n            if (cursors[index].m_Locator.m_SampleTable->GetSampleCount()) {\n                cursors[index].m_Locator.m_SampleTable->GetSample(0, cursors[index].m_Locator.m_Sample);\n            } else {\n                cursors[index].m_EndReached = true;\n            }\n\n            index++;            \n        }\n\n        // figure out the layout of the chunks\n        for (;;) {\n            // see which is the next sample to write\n            AP4_UI64 min_offset = (AP4_UI64)(-1);\n            int cursor = -1;\n            for (unsigned int i=0; i<track_count; i++) {\n                if (!cursors[i].m_EndReached &&\n                    cursors[i].m_Locator.m_SampleTable &&\n                    cursors[i].m_Locator.m_Sample.GetOffset() <= min_offset) {\n                    min_offset = cursors[i].m_Locator.m_Sample.GetOffset();\n                    cursor = i;\n                }\n            }\n\n            // stop if all cursors are exhausted\n            if (cursor == -1) break;\n\n            // append this locator to the layout list\n            AP4_SampleLocator& locator = cursors[cursor].m_Locator;\n            locators.Append(locator);\n\n            // move the cursor to the next sample\n            locator.m_SampleIndex++;\n            if (locator.m_SampleIndex == locator.m_SampleTable->GetSampleCount()) {\n                // mark this track as completed\n                cursors[cursor].m_EndReached = true;\n            } else {\n                // get the next sample info\n                locator.m_SampleTable->GetSample(locator.m_SampleIndex, locator.m_Sample);\n                AP4_Ordinal skip, sdesc;\n                locator.m_SampleTable->GetChunkForSample(locator.m_SampleIndex,\n                                                         locator.m_ChunkIndex,\n                                                         skip, sdesc);\n            }\n        }\n\n        // update the stbl atoms and compute the mdat size\n        int current_track = -1;\n        int current_chunk = -1;\n        AP4_Position current_chunk_offset = 0;\n        AP4_Size current_chunk_size = 0;\n        for (AP4_Ordinal i=0; i<locators.ItemCount(); i++) {\n            AP4_SampleLocator& locator = locators[i];\n            if ((int)locator.m_TrakIndex  != current_track ||\n                (int)locator.m_ChunkIndex != current_chunk) {\n                // start a new chunk for this track\n                current_chunk_offset += current_chunk_size;\n                current_chunk_size = 0;\n                current_track = locator.m_TrakIndex;\n                current_chunk = locator.m_ChunkIndex;\n                locator.m_SampleTable->SetChunkOffset(locator.m_ChunkIndex, current_chunk_offset);\n            } \n            AP4_Size sample_size;\n            TrackHandler* handler = m_TrackHandlers[locator.m_TrakIndex];\n            if (handler) {\n                sample_size = handler->GetProcessedSampleSize(locator.m_Sample);\n                locator.m_SampleTable->SetSampleSize(locator.m_SampleIndex, sample_size);\n            } else {\n                sample_size = locator.m_Sample.GetSize();\n            }\n            current_chunk_size += sample_size;\n            mdat_payload_size  += sample_size;\n        }\n\n        // process the tracks (ex: sample descriptions processing)\n        for (AP4_Ordinal i=0; i<track_count; i++) {\n            TrackHandler* handler = m_TrackHandlers[i];\n            if (handler) handler->ProcessTrack();\n        }\n    }\n\n    // finalize the processor\n    Finalize(top_level);\n\n    if (!fragments) {\n        // calculate the size of all atoms combined\n        AP4_UI64 atoms_size = 0;\n        top_level.GetChildren().Apply(AP4_AtomSizeAdder(atoms_size));\n\n        // see if we need a 64-bit or 32-bit mdat\n        AP4_Size mdat_header_size = AP4_ATOM_HEADER_SIZE;\n        if (mdat_payload_size+mdat_header_size > 0xFFFFFFFF) {\n            // we need a 64-bit size\n            mdat_header_size += 8;\n        }\n        \n        // adjust the chunk offsets\n        for (AP4_Ordinal i=0; i<track_count; i++) {\n            AP4_TrakAtom* trak;\n            trak_atoms->Get(i, trak);\n            trak->AdjustChunkOffsets(atoms_size+mdat_header_size);\n        }\n\n        // write all atoms\n        top_level.GetChildren().Apply(AP4_AtomListWriter(output));\n\n        // write mdat header\n        if (mdat_payload_size) {\n            if (mdat_header_size == AP4_ATOM_HEADER_SIZE) {\n                // 32-bit size\n                output.WriteUI32((AP4_UI32)(mdat_header_size+mdat_payload_size));\n                output.WriteUI32(AP4_ATOM_TYPE_MDAT);\n            } else {\n                // 64-bit size\n                output.WriteUI32(1);\n                output.WriteUI32(AP4_ATOM_TYPE_MDAT);\n                output.WriteUI64(mdat_header_size+mdat_payload_size);\n            }\n        }        \n    }\n    \n    // write the samples\n    if (moov) {\n        if (!fragments) {\n#if defined(AP4_DEBUG)\n            AP4_Position before;\n            output.Tell(before);\n#endif\n            AP4_Sample     sample;\n            AP4_DataBuffer data_in;\n            AP4_DataBuffer data_out;\n            for (unsigned int i=0; i<locators.ItemCount(); i++) {\n                AP4_SampleLocator& locator = locators[i];\n                locator.m_Sample.ReadData(data_in);\n                TrackHandler* handler = m_TrackHandlers[locator.m_TrakIndex];\n                if (handler) {\n                    result = handler->ProcessSample(data_in, data_out);\n                    if (AP4_FAILED(result)) return result;\n                    output.Write(data_out.GetData(), data_out.GetDataSize());\n                } else {\n                    output.Write(data_in.GetData(), data_in.GetDataSize());            \n                }\n\n                // notify the progress listener\n                if (listener) {\n                    listener->OnProgress(i+1, locators.ItemCount());\n                }\n            }\n\n#if defined(AP4_DEBUG)\n            AP4_Position after;\n            output.Tell(after);\n            AP4_ASSERT(after-before == mdat_payload_size);\n#endif\n        }\n        \n        // find the position of the sidx atom\n        AP4_Position sidx_position = 0;\n        if (sidx) {\n            for (AP4_List<AP4_Atom>::Item* item = top_level.GetChildren().FirstItem();\n                                           item;\n                                           item = item->GetNext()) {\n                AP4_Atom* atom = item->GetData();\n                if (atom->GetType() == AP4_ATOM_TYPE_SIDX) {\n                    break;\n                }\n                sidx_position += atom->GetSize();\n            }\n        }\n        \n        // process the fragments, if any\n        result = ProcessFragments(moov, frags, mfra, sidx, sidx_position, fragments?*fragments:input, output);\n        if (AP4_FAILED(result)) return result;\n        \n        // update and re-write the sidx if we have one\n        if (sidx && sidx_position) {\n            AP4_Position where = 0;\n            output.Tell(where);\n            output.Seek(sidx_position);\n            result = sidx->Write(output);\n            if (AP4_FAILED(result)) return result;\n            output.Seek(where);\n        }\n        \n        if (!fragments) {\n            // write the mfra atom at the end if we have one\n            if (mfra) {\n                mfra->Write(output);\n            }\n        }\n        \n        // cleanup\n        for (AP4_Ordinal i=0; i<track_count; i++) {\n            delete cursors[i].m_Locator.m_SampleTable;\n            delete m_TrackHandlers[i];\n        }\n        m_TrackHandlers.Clear();\n        delete[] cursors;\n    }\n\n    // cleanup\n    frags.DeleteReferences();\n    delete mfra;\n    \n    return AP4_SUCCESS;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 83,
    "critical_vars": [
      "name_size"
    ],
    "function": "AP4_HdlrAtom::AP4_HdlrAtom",
    "filename": "Bento4/CVE-2017-14642/CVE-2017-14642_CWE-476_22192de5367fa0cee985917f092be4060b7c00b0_Ap4HdlrAtom.cpp.diff",
    "function_code": "AP4_HdlrAtom::AP4_HdlrAtom(AP4_UI32        size, \n                           AP4_UI08        version,\n                           AP4_UI32        flags,\n                           AP4_ByteStream& stream) :\n    AP4_Atom(AP4_ATOM_TYPE_HDLR, size, version, flags)\n{\n    AP4_UI32 predefined;\n    stream.ReadUI32(predefined);\n    stream.ReadUI32(m_HandlerType);\n    stream.ReadUI32(m_Reserved[0]);\n    stream.ReadUI32(m_Reserved[1]);\n    stream.ReadUI32(m_Reserved[2]);\n    \n    // read the name unless it is empty\n    int name_size = size-(AP4_FULL_ATOM_HEADER_SIZE+20);\n    if (name_size == 0) return;\n    char* name = new char[name_size+1];\n    stream.Read(name, name_size);\n    name[name_size] = '\\0'; // force a null termination\n    // handle a special case: the Quicktime files have a pascal\n    // string here, but ISO MP4 files have a C string.\n    // we try to detect a pascal encoding and correct it.\n    if (name[0] == name_size-1) {\n        m_HandlerName = name+1;\n    } else {\n        m_HandlerName = name;\n    }\n    delete[] name;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 83,
    "critical_vars": [
      "size"
    ],
    "function": "AP4_HdlrAtom::AP4_HdlrAtom",
    "filename": "Bento4/CVE-2017-14642/CVE-2017-14642_CWE-476_22192de5367fa0cee985917f092be4060b7c00b0_Ap4HdlrAtom.cpp.diff",
    "function_code": "AP4_HdlrAtom::AP4_HdlrAtom(AP4_UI32        size, \n                           AP4_UI08        version,\n                           AP4_UI32        flags,\n                           AP4_ByteStream& stream) :\n    AP4_Atom(AP4_ATOM_TYPE_HDLR, size, version, flags)\n{\n    AP4_UI32 predefined;\n    stream.ReadUI32(predefined);\n    stream.ReadUI32(m_HandlerType);\n    stream.ReadUI32(m_Reserved[0]);\n    stream.ReadUI32(m_Reserved[1]);\n    stream.ReadUI32(m_Reserved[2]);\n    \n    // read the name unless it is empty\n    if (size < AP4_FULL_ATOM_HEADER_SIZE+20) return;\n    AP4_UI32 name_size = size-(AP4_FULL_ATOM_HEADER_SIZE+20);\n    char* name = new char[name_size+1];\n    if (name == NULL) return;\n    stream.Read(name, name_size);\n    name[name_size] = '\\0'; // force a null termination\n    // handle a special case: the Quicktime files have a pascal\n    // string here, but ISO MP4 files have a C string.\n    // we try to detect a pascal encoding and correct it.\n    if (name[0] == name_size-1) {\n        m_HandlerName = name+1;\n    } else {\n        m_HandlerName = name;\n    }\n    delete[] name;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 493,
    "critical_vars": [
      "atom"
    ],
    "function": "AP4_AtomFactory::CreateAtomFromStream",
    "filename": "Bento4/CVE-2017-14638/CVE-2017-14638_CWE-476_be7185faf7f52674028977dcf501c6039ff03aa5_Ap4AtomFactory.cpp.diff",
    "function_code": "AP4_AtomFactory::CreateAtomFromStream(AP4_ByteStream& stream, \n                                      AP4_UI32        type,\n                                      AP4_UI32        size_32,\n                                      AP4_UI64        size_64,\n                                      AP4_Atom*&      atom)\n{\n    bool atom_is_large = (size_32 == 1);\n    bool force_64 = (size_32==1 && ((size_64>>32) == 0));\n    \n    // create the atom\n    if (GetContext() == AP4_ATOM_TYPE_STSD) {\n        // sample entry\n        if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n        switch (type) {\n          case AP4_ATOM_TYPE_MP4A:\n            atom = new AP4_Mp4aSampleEntry(size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_MP4V:\n            atom = new AP4_Mp4vSampleEntry(size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_MP4S:\n            atom = new AP4_Mp4sSampleEntry(size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_ENCA:\n            atom = new AP4_EncaSampleEntry(size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_ENCV:\n            atom = new AP4_EncvSampleEntry(size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_DRMS:\n            atom = new AP4_DrmsSampleEntry(size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_DRMI:\n            atom = new AP4_DrmiSampleEntry(size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_AVC1:\n          case AP4_ATOM_TYPE_AVC2:\n          case AP4_ATOM_TYPE_AVC3:\n          case AP4_ATOM_TYPE_AVC4:\n          case AP4_ATOM_TYPE_DVAV:\n          case AP4_ATOM_TYPE_DVA1:\n            atom = new AP4_AvcSampleEntry(type, size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_HEV1:\n          case AP4_ATOM_TYPE_HVC1:\n          case AP4_ATOM_TYPE_DVHE:\n          case AP4_ATOM_TYPE_DVH1:\n            atom = new AP4_HevcSampleEntry(type, size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_ALAC:\n          case AP4_ATOM_TYPE_AC_3:\n          case AP4_ATOM_TYPE_EC_3:\n          case AP4_ATOM_TYPE_DTSC:\n          case AP4_ATOM_TYPE_DTSH:\n          case AP4_ATOM_TYPE_DTSL:\n          case AP4_ATOM_TYPE_DTSE:\n            atom = new AP4_AudioSampleEntry(type, size_32, stream, *this);\n            break;\n            \n          case AP4_ATOM_TYPE_RTP_:\n            atom = new AP4_RtpHintSampleEntry(size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_STPP:\n            atom = new AP4_SubtitleSampleEntry(type, size_32, stream, *this);\n            break;\n\n          default: {\n            // try all the external type handlers\n            AP4_List<TypeHandler>::Item* handler_item = m_TypeHandlers.FirstItem();\n            while (handler_item) {\n                TypeHandler* handler = handler_item->GetData();\n                if (AP4_SUCCEEDED(handler->CreateAtom(type, size_32, stream, GetContext(), atom))) {\n                    break;\n                }\n                handler_item = handler_item->GetNext();\n            }\n\n            // no custom handler, create a generic entry\n            if (atom == NULL) {\n                atom = new AP4_UnknownSampleEntry(type, (AP4_UI32)size_64, stream);\n            }\n\n            break;\n          }\n        }\n    } else {\n        // regular atom\n        switch (type) {\n          case AP4_ATOM_TYPE_MOOV:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_MoovAtom::Create(size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_MVHD:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_MvhdAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_MEHD:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_MehdAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_MFHD:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_MfhdAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_TRAK:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_TrakAtom::Create(size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_TREX:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_TrexAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_HDLR:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_HdlrAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_TKHD:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_TkhdAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_TFHD:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_TfhdAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_TRUN:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_TrunAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_TFRA:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_TfraAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_MFRO:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_MfroAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_MDHD:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_MdhdAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_STSD:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_StsdAtom::Create(size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_STSC:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_StscAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_STCO:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_StcoAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_CO64:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_Co64Atom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_STSZ:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_StszAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_STZ2:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_Stz2Atom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_STTS:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_SttsAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_CTTS:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_CttsAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_STSS:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_StssAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_IODS:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_IodsAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_ESDS:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_EsdsAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_AVCC:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_AvccAtom::Create(size_32, stream);\n            break;\n            \n          case AP4_ATOM_TYPE_HVCC:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_HvccAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_DVCC:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_DvccAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_HVCE:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_HvccAtom::Create(size_32, stream);\n            if (atom) {\n                atom->SetType(AP4_ATOM_TYPE_HVCE);\n            }\n            break;\n\n          case AP4_ATOM_TYPE_AVCE:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_AvccAtom::Create(size_32, stream);\n            if (atom) {\n                atom->SetType(AP4_ATOM_TYPE_AVCE);\n            }\n            break;\n\n    #if !defined(AP4_CONFIG_MINI_BUILD)\n          case AP4_ATOM_TYPE_UUID: {\n              AP4_UI08 uuid[16];\n              AP4_Result result = stream.Read(uuid, 16);\n              if (AP4_FAILED(result)) return result;\n              \n              if (AP4_CompareMemory(uuid, AP4_UUID_PIFF_TRACK_ENCRYPTION_ATOM, 16) == 0) {\n                  atom = AP4_PiffTrackEncryptionAtom::Create((AP4_UI32)size_64, stream);\n              } else if (AP4_CompareMemory(uuid, AP4_UUID_PIFF_SAMPLE_ENCRYPTION_ATOM, 16) == 0) {\n                  atom = AP4_PiffSampleEncryptionAtom::Create((AP4_UI32)size_64, stream);\n              } else {\n                  atom = new AP4_UnknownUuidAtom(size_64, uuid, stream);\n              }\n              break;\n          }\n            \n          case AP4_ATOM_TYPE_8ID_:\n            atom = new AP4_NullTerminatedStringAtom(type, size_64, stream);\n            break;\n\n          case AP4_ATOM_TYPE_8BDL:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_8bdlAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_DREF:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_DrefAtom::Create(size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_URL:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_UrlAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_ELST:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_ElstAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_VMHD:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_VmhdAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_SMHD:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_SmhdAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_NMHD:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_NmhdAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_STHD:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_SthdAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_HMHD:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_HmhdAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_FRMA:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_FrmaAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_SCHM:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_SchmAtom::Create(size_32, &m_ContextStack, stream);\n            break;\n\n          case AP4_ATOM_TYPE_FTYP:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_FtypAtom::Create(size_32, stream);\n            break;\n                        \n          case AP4_ATOM_TYPE_TIMS:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_TimsAtom::Create(size_32, stream);\n            break;\n     \n          case AP4_ATOM_TYPE_SDP_:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_SdpAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_IKMS:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_IkmsAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_ISFM:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_IsfmAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_ISLT:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_IsltAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_ODHE:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_OdheAtom::Create(size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_OHDR:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_OhdrAtom::Create(size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_ODDA:\n            atom = AP4_OddaAtom::Create(size_64, stream);\n            break;\n\n          case AP4_ATOM_TYPE_ODAF:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_OdafAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_GRPI:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_GrpiAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_IPRO:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_IproAtom::Create(size_32, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_RTP_:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_RtpAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_TFDT:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_TfdtAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_TENC:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_TencAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_SENC:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_SencAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_SAIZ:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_SaizAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_SAIO:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_SaioAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_PDIN:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_PdinAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_BLOC:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_BlocAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_AINF:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_AinfAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_PSSH:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_PsshAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_SIDX:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_SidxAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_SBGP:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_SbgpAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_SGPD:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_SgpdAtom::Create(size_32, stream);\n            break;\n\n          case AP4_ATOM_TYPE_MKID:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            if (GetContext() == AP4_ATOM_TYPE_MARL) {\n                atom = AP4_MkidAtom::Create(size_32, stream);\n            }\n            break;\n\n          case AP4_ATOM_TYPE_DEC3:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            if (GetContext() == AP4_ATOM_TYPE_EC_3 || GetContext() == AP4_ATOM_TYPE_ENCA) {\n                atom = AP4_Dec3Atom::Create(size_32, stream);\n            }\n            break;\n\n          // track ref types\n          case AP4_ATOM_TYPE_HINT:\n          case AP4_ATOM_TYPE_CDSC:\n          case AP4_ATOM_TYPE_SYNC:\n          case AP4_ATOM_TYPE_MPOD:\n          case AP4_ATOM_TYPE_DPND:\n          case AP4_ATOM_TYPE_IPIR:\n          case AP4_ATOM_TYPE_ALIS:\n          case AP4_ATOM_TYPE_CHAP:\n            if (GetContext() == AP4_ATOM_TYPE_TREF) {\n                if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n                atom = AP4_TrefTypeAtom::Create(type, size_32, stream);\n            }\n            break;\n\n    #endif // AP4_CONFIG_MINI_BUILD\n\n          // container atoms\n          case AP4_ATOM_TYPE_MOOF:\n          case AP4_ATOM_TYPE_MVEX:\n          case AP4_ATOM_TYPE_TRAF:\n          case AP4_ATOM_TYPE_TREF:\n          case AP4_ATOM_TYPE_MFRA:\n          case AP4_ATOM_TYPE_HNTI:\n          case AP4_ATOM_TYPE_STBL:\n          case AP4_ATOM_TYPE_MDIA:\n          case AP4_ATOM_TYPE_DINF:\n          case AP4_ATOM_TYPE_MINF:\n          case AP4_ATOM_TYPE_SCHI:\n          case AP4_ATOM_TYPE_SINF:\n          case AP4_ATOM_TYPE_UDTA:\n          case AP4_ATOM_TYPE_ILST:\n          case AP4_ATOM_TYPE_EDTS: \n          case AP4_ATOM_TYPE_MDRI:\n          case AP4_ATOM_TYPE_WAVE:\n            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n            atom = AP4_ContainerAtom::Create(type, size_64, false, force_64, stream, *this);\n            break;\n\n          // containers, only at the top\n          case AP4_ATOM_TYPE_MARL:\n            if (GetContext() == 0) {\n                atom = AP4_ContainerAtom::Create(type, size_64, false, force_64, stream, *this);\n            }\n            break;\n            \n          // full container atoms\n          case AP4_ATOM_TYPE_META:\n          case AP4_ATOM_TYPE_ODRM:\n          case AP4_ATOM_TYPE_ODKM:\n            atom = AP4_ContainerAtom::Create(type, size_64, true, force_64, stream, *this);\n            break;\n\n          case AP4_ATOM_TYPE_FREE:\n          case AP4_ATOM_TYPE_WIDE:\n          case AP4_ATOM_TYPE_MDAT:\n            // generic atoms\n            break;\n            \n          default: {\n            // try all the external type handlers\n            AP4_List<TypeHandler>::Item* handler_item = m_TypeHandlers.FirstItem();\n            while (handler_item) {\n                TypeHandler* handler = handler_item->GetData();\n                if (AP4_SUCCEEDED(handler->CreateAtom(type, size_32, stream, GetContext(), atom))) {\n                    break;\n                }\n                handler_item = handler_item->GetNext();\n            }\n\n            break;\n          }\n        }\n    }\n    \n    return AP4_SUCCESS;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Fun-Call",
    "line_old": 1337,
    "line_new": 1338,
    "critical_vars": [
      "size"
    ],
    "function": "AP4_DataAtom::AP4_DataAtom",
    "filename": "Bento4/CVE-2017-14641/CVE-2017-14641_CWE-476_41cad602709436628f07b4c4f64e9ff7a611f687_Ap4MetaData.cpp.diff",
    "function_code": "AP4_DataAtom::AP4_DataAtom(AP4_UI32 size, AP4_ByteStream& stream) :\n    AP4_Atom(AP4_ATOM_TYPE_DATA, size),\n    m_Source(NULL)\n{\n    if (size < AP4_ATOM_HEADER_SIZE+8) return;\n\n    AP4_UI32 i;\n    stream.ReadUI32(i); m_DataType = (DataType)i;\n    stream.ReadUI32(i); m_DataLang = (DataLang)i;\n\n    // the stream for the data is a substream of this source\n    AP4_Position data_offset;\n    stream.Tell(data_offset);\n    AP4_Size data_size = size-AP4_ATOM_HEADER_SIZE-8;\n    m_Source = new AP4_SubStream(stream, data_offset, data_size);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 143,
    "critical_vars": [
      "result"
    ],
    "function": "AP4_AtomSampleTable::GetSample",
    "filename": "Bento4/CVE-2017-14640/CVE-2017-14640_CWE-476_2f267f89f957088197f4b1fc254632d1645b415d_Ap4AtomSampleTable.cpp.diff",
    "function_code": "AP4_AtomSampleTable::GetSample(AP4_Ordinal index, \n                               AP4_Sample& sample)\n{\n    AP4_Result result;\n\n    // check that we have an stsc atom\n    if (!m_StscAtom) {\n        return AP4_ERROR_INVALID_FORMAT;\n    }\n    \n    // check that we have a chunk offset table\n    if (m_StcoAtom == NULL && m_Co64Atom == NULL) {\n        return AP4_ERROR_INVALID_FORMAT;\n    }\n\n    // MP4 uses 1-based indexes internally, so adjust by one\n    index++;\n\n    // find out in which chunk this sample is located\n    AP4_Ordinal chunk, skip, desc;\n    result = m_StscAtom->GetChunkForSample(index, chunk, skip, desc);\n    if (AP4_FAILED(result)) return result;\n    \n    // check that the result is within bounds\n    if (skip > index) return AP4_ERROR_INTERNAL;\n\n    // get the atom offset for this chunk\n    AP4_UI64 offset;\n    if (m_StcoAtom) {\n        AP4_UI32 offset_32;\n        result = m_StcoAtom->GetChunkOffset(chunk, offset_32);\n        offset = offset_32;\n    } else {\n        result = m_Co64Atom->GetChunkOffset(chunk, offset);\n    }\n    if (AP4_FAILED(result)) return result;\n    \n    // compute the additional offset inside the chunk\n    for (unsigned int i = index-skip; i < index; i++) {\n        AP4_Size size = 0;\n        if (m_StszAtom) {\n            result = m_StszAtom->GetSampleSize(i, size); \n        } else if (m_Stz2Atom) {\n            result = m_Stz2Atom->GetSampleSize(i, size); \n        } else {\n            result = AP4_ERROR_INVALID_FORMAT;\n        }\n        if (AP4_FAILED(result)) return result;\n        offset += size;\n    }\n\n    // set the description index\n    sample.SetDescriptionIndex(desc-1); // adjust for 0-based indexes\n\n    // set the dts and cts\n    AP4_UI32 cts_offset = 0;\n    AP4_UI64 dts        = 0;\n    AP4_UI32 duration   = 0;\n    result = m_SttsAtom->GetDts(index, dts, &duration);\n    if (AP4_FAILED(result)) return result;\n    sample.SetDuration(duration);\n    sample.SetDts(dts);\n    if (m_CttsAtom == NULL) {\n        sample.SetCts(dts);\n    } else {\n        result = m_CttsAtom->GetCtsOffset(index, cts_offset); \n\t    if (AP4_FAILED(result)) return result;\n        sample.SetCtsDelta(cts_offset);\n    }     \n\n    // set the size\n    AP4_Size sample_size = 0;\n    if (m_StszAtom) {\n        result = m_StszAtom->GetSampleSize(index, sample_size); \n    } else if (m_Stz2Atom) {\n        result = m_Stz2Atom->GetSampleSize(index, sample_size); \n    } else {\n        result = AP4_ERROR_INVALID_FORMAT;\n    }\n    if (AP4_FAILED(result)) return result;\n    sample.SetSize(sample_size);\n\n    // set the sync flag\n    if (m_StssAtom == NULL) {\n        sample.SetSync(true);\n    } else {\n        sample.SetSync(m_StssAtom->IsSampleSync(index));\n    }\n\n    // set the offset\n    sample.SetOffset(offset);\n\n    // set the data stream\n    sample.SetDataStream(m_SampleStream);\n\n\n    return AP4_SUCCESS;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 444,
    "critical_vars": [
      "*head"
    ],
    "function": "git_pkt_parse_line",
    "filename": "libgit2/CVE-2016-10129/CVE-2016-10129_CWE-476_2fdef641fd0dd2828bd948234ae86de75221a11a_smart_pkt.c.diff",
    "function_code": "int git_pkt_parse_line(\n\tgit_pkt **head, const char *line, const char **out, size_t bufflen)\n{\n\tint ret;\n\tint32_t len;\n\n\t/* Not even enough for the length */\n\tif (bufflen > 0 && bufflen < PKT_LEN_SIZE)\n\t\treturn GIT_EBUFS;\n\n\tlen = parse_len(line);\n\tif (len < 0) {\n\t\t/*\n\t\t * If we fail to parse the length, it might be because the\n\t\t * server is trying to send us the packfile already.\n\t\t */\n\t\tif (bufflen >= 4 && !git__prefixcmp(line, \"PACK\")) {\n\t\t\tgiterr_clear();\n\t\t\t*out = line;\n\t\t\treturn pack_pkt(head);\n\t\t}\n\n\t\treturn (int)len;\n\t}\n\n\t/*\n\t * If we were given a buffer length, then make sure there is\n\t * enough in the buffer to satisfy this line\n\t */\n\tif (bufflen > 0 && bufflen < (size_t)len)\n\t\treturn GIT_EBUFS;\n\n\t/*\n\t * The length has to be exactly 0 in case of a flush\n\t * packet or greater than PKT_LEN_SIZE, as the decoded\n\t * length includes its own encoded length of four bytes.\n\t */\n\tif (len != 0 && len < PKT_LEN_SIZE)\n\t\treturn GIT_ERROR;\n\n\tline += PKT_LEN_SIZE;\n\t/*\n\t * TODO: How do we deal with empty lines? Try again? with the next\n\t * line?\n\t */\n\tif (len == PKT_LEN_SIZE) {\n\t\t*head = NULL;\n\t\t*out = line;\n\t\treturn 0;\n\t}\n\n\tif (len == 0) { /* Flush pkt */\n\t\t*out = line;\n\t\treturn flush_pkt(head);\n\t}\n\n\tlen -= PKT_LEN_SIZE; /* the encoded length includes its own size */\n\n\tif (*line == GIT_SIDE_BAND_DATA)\n\t\tret = data_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_PROGRESS)\n\t\tret = sideband_progress_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_ERROR)\n\t\tret = sideband_error_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ACK\"))\n\t\tret = ack_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"NAK\"))\n\t\tret = nak_pkt(head);\n\telse if (!git__prefixcmp(line, \"ERR \"))\n\t\tret = err_pkt(head, line, len);\n\telse if (*line == '#')\n\t\tret = comment_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ok\"))\n\t\tret = ok_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ng\"))\n\t\tret = ng_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"unpack\"))\n\t\tret = unpack_pkt(head, line, len);\n\telse\n\t\tret = ref_pkt(head, line, len);\n\n\t*out = line + len;\n\n\treturn ret;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 771,
    "critical_vars": [
      "pkt"
    ],
    "function": "add_push_report_sideband_pkt",
    "filename": "libgit2/CVE-2016-10129/CVE-2016-10129_CWE-476_2fdef641fd0dd2828bd948234ae86de75221a11a_smart_protocol.c.diff",
    "function_code": "static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)\n{\n\tgit_pkt *pkt;\n\tconst char *line, *line_end = NULL;\n\tsize_t line_len;\n\tint error;\n\tint reading_from_buf = data_pkt_buf->size > 0;\n\n\tif (reading_from_buf) {\n\t\t/* We had an existing partial packet, so add the new\n\t\t * packet to the buffer and parse the whole thing */\n\t\tgit_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);\n\t\tline = data_pkt_buf->ptr;\n\t\tline_len = data_pkt_buf->size;\n\t}\n\telse {\n\t\tline = data_pkt->data;\n\t\tline_len = data_pkt->len;\n\t}\n\n\twhile (line_len > 0) {\n\t\terror = git_pkt_parse_line(&pkt, line, &line_end, line_len);\n\n\t\tif (error == GIT_EBUFS) {\n\t\t\t/* Buffer the data when the inner packet is split\n\t\t\t * across multiple sideband packets */\n\t\t\tif (!reading_from_buf)\n\t\t\t\tgit_buf_put(data_pkt_buf, line, line_len);\n\t\t\terror = 0;\n\t\t\tgoto done;\n\t\t}\n\t\telse if (error < 0)\n\t\t\tgoto done;\n\n\t\t/* Advance in the buffer */\n\t\tline_len -= (line_end - line);\n\t\tline = line_end;\n\n\t\t/* When a valid packet with no content has been\n\t\t * read, git_pkt_parse_line does not report an\n\t\t * error, but the pkt pointer has not been set.\n\t\t * Handle this by skipping over empty packets.\n\t\t */\n\t\tif (pkt == NULL)\n\t\t\tcontinue;\n\n\t\terror = add_push_report_pkt(push, pkt);\n\n\t\tgit_pkt_free(pkt);\n\n\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\tgoto done;\n\t}\n\n\terror = 0;\n\ndone:\n\tif (reading_from_buf)\n\t\tgit_buf_consume(data_pkt_buf, line_end);\n\treturn error;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 828,
    "critical_vars": [
      "pkt"
    ],
    "function": "parse_report",
    "filename": "libgit2/CVE-2016-10129/CVE-2016-10129_CWE-476_2fdef641fd0dd2828bd948234ae86de75221a11a_smart_protocol.c.diff",
    "function_code": "static int parse_report(transport_smart *transport, git_push *push)\n{\n\tgit_pkt *pkt = NULL;\n\tconst char *line_end = NULL;\n\tgitno_buffer *buf = &transport->buffer;\n\tint error, recvd;\n\tgit_buf data_pkt_buf = GIT_BUF_INIT;\n\n\tfor (;;) {\n\t\tif (buf->offset > 0)\n\t\t\terror = git_pkt_parse_line(&pkt, buf->data,\n\t\t\t\t\t\t   &line_end, buf->offset);\n\t\telse\n\t\t\terror = GIT_EBUFS;\n\n\t\tif (error < 0 && error != GIT_EBUFS) {\n\t\t\terror = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (error == GIT_EBUFS) {\n\t\t\tif ((recvd = gitno_recv(buf)) < 0) {\n\t\t\t\terror = recvd;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (recvd == 0) {\n\t\t\t\tgiterr_set(GITERR_NET, \"early EOF\");\n\t\t\t\terror = GIT_EEOF;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tgitno_consume(buf, line_end);\n\n\t\terror = 0;\n\n\t\tif (pkt == NULL)\n\t\t\tcontinue;\n\n\t\tswitch (pkt->type) {\n\t\t\tcase GIT_PKT_DATA:\n\t\t\t\t/* This is a sideband packet which contains other packets */\n\t\t\t\terror = add_push_report_sideband_pkt(push, (git_pkt_data *)pkt, &data_pkt_buf);\n\t\t\t\tbreak;\n\t\t\tcase GIT_PKT_ERR:\n\t\t\t\tgiterr_set(GITERR_NET, \"report-status: Error reported: %s\",\n\t\t\t\t\t((git_pkt_err *)pkt)->error);\n\t\t\t\terror = -1;\n\t\t\t\tbreak;\n\t\t\tcase GIT_PKT_PROGRESS:\n\t\t\t\tif (transport->progress_cb) {\n\t\t\t\t\tgit_pkt_progress *p = (git_pkt_progress *) pkt;\n\t\t\t\t\terror = transport->progress_cb(p->data, p->len, transport->message_cb_payload);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terror = add_push_report_pkt(push, pkt);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tgit_pkt_free(pkt);\n\n\t\t/* add_push_report_pkt returns GIT_ITEROVER when it receives a flush */\n\t\tif (error == GIT_ITEROVER) {\n\t\t\terror = 0;\n\t\t\tif (data_pkt_buf.size > 0) {\n\t\t\t\t/* If there was data remaining in the pack data buffer,\n\t\t\t\t * then the server sent a partial pkt-line */\n\t\t\t\tgiterr_set(GITERR_NET, \"Incomplete pack data pkt-line\");\n\t\t\t\terror = GIT_ERROR;\n\t\t\t}\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (error < 0) {\n\t\t\tgoto done;\n\t\t}\n\t}\ndone:\n\tgit_buf_free(&data_pkt_buf);\n\treturn error;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 1078,
    "critical_vars": [
      "targetDb"
    ],
    "function": "sqlcipher_exportFunc",
    "filename": "sqlcipher/CVE-2021-3119/CVE-2021-3119_CWE-476_cb71f53e8cea4802509f182fa5bead0ac6ab0e7f_crypto.c.diff",
    "function_code": "void sqlcipher_exportFunc(sqlite3_context *context, int argc, sqlite3_value **argv) {\n  sqlite3 *db = sqlite3_context_db_handle(context);\n  const char* targetDb, *sourceDb; \n  int targetDb_idx = 0;\n  u64 saved_flags = db->flags;        /* Saved value of the db->flags */\n  u32 saved_mDbFlags = db->mDbFlags;        /* Saved value of the db->mDbFlags */\n  int saved_nChange = db->nChange;      /* Saved value of db->nChange */\n  int saved_nTotalChange = db->nTotalChange; /* Saved value of db->nTotalChange */\n  u8 saved_mTrace = db->mTrace;        /* Saved value of db->mTrace */\n  int rc = SQLITE_OK;     /* Return code from service routines */\n  char *zSql = NULL;         /* SQL statements */\n  char *pzErrMsg = NULL;\n\n  if(argc != 1 && argc != 2) {\n    rc = SQLITE_ERROR;\n    pzErrMsg = sqlite3_mprintf(\"invalid number of arguments (%d) passed to sqlcipher_export\", argc);\n    goto end_of_export;\n  }\n\n  targetDb = (const char*) sqlite3_value_text(argv[0]);\n  sourceDb = (argc == 2) ? (char *) sqlite3_value_text(argv[1]) : \"main\";\n\n  /* if the name of the target is not main, but the index returned is zero \n     there is a mismatch and we should not proceed */\n  targetDb_idx =  sqlcipher_find_db_index(db, targetDb);\n  if(targetDb_idx == 0 && sqlite3StrICmp(\"main\", targetDb) != 0) {\n    rc = SQLITE_ERROR;\n    pzErrMsg = sqlite3_mprintf(\"unknown database %s\", targetDb);\n    goto end_of_export;\n  }\n  db->init.iDb = targetDb_idx;\n\n  db->flags |= SQLITE_WriteSchema | SQLITE_IgnoreChecks; \n  db->mDbFlags |= DBFLAG_PreferBuiltin | DBFLAG_Vacuum;\n  db->flags &= ~(u64)(SQLITE_ForeignKeys | SQLITE_ReverseOrder | SQLITE_Defensive | SQLITE_CountRows); \n  db->mTrace = 0;\n\n  /* Query the schema of the main database. Create a mirror schema\n  ** in the temporary database.\n  */\n  zSql = sqlite3_mprintf(\n    \"SELECT sql \"\n    \"  FROM %s.sqlite_master WHERE type='table' AND name!='sqlite_sequence'\"\n    \"   AND rootpage>0\"\n  , sourceDb);\n  rc = (zSql == NULL) ? SQLITE_NOMEM : sqlcipher_execExecSql(db, &pzErrMsg, zSql); \n  if( rc!=SQLITE_OK ) goto end_of_export;\n  sqlite3_free(zSql);\n\n  zSql = sqlite3_mprintf(\n    \"SELECT sql \"\n    \"  FROM %s.sqlite_master WHERE sql LIKE 'CREATE INDEX %%' \"\n  , sourceDb);\n  rc = (zSql == NULL) ? SQLITE_NOMEM : sqlcipher_execExecSql(db, &pzErrMsg, zSql); \n  if( rc!=SQLITE_OK ) goto end_of_export;\n  sqlite3_free(zSql);\n\n  zSql = sqlite3_mprintf(\n    \"SELECT sql \"\n    \"  FROM %s.sqlite_master WHERE sql LIKE 'CREATE UNIQUE INDEX %%'\"\n  , sourceDb);\n  rc = (zSql == NULL) ? SQLITE_NOMEM : sqlcipher_execExecSql(db, &pzErrMsg, zSql); \n  if( rc!=SQLITE_OK ) goto end_of_export;\n  sqlite3_free(zSql);\n\n  /* Loop through the tables in the main database. For each, do\n  ** an \"INSERT INTO rekey_db.xxx SELECT * FROM main.xxx;\" to copy\n  ** the contents to the temporary database.\n  */\n  zSql = sqlite3_mprintf(\n    \"SELECT 'INSERT INTO %s.' || quote(name) \"\n    \"|| ' SELECT * FROM %s.' || quote(name) || ';'\"\n    \"FROM %s.sqlite_master \"\n    \"WHERE type = 'table' AND name!='sqlite_sequence' \"\n    \"  AND rootpage>0\"\n  , targetDb, sourceDb, sourceDb);\n  rc = (zSql == NULL) ? SQLITE_NOMEM : sqlcipher_execExecSql(db, &pzErrMsg, zSql); \n  if( rc!=SQLITE_OK ) goto end_of_export;\n  sqlite3_free(zSql);\n\n  /* Copy over the contents of the sequence table\n  */\n  zSql = sqlite3_mprintf(\n    \"SELECT 'INSERT INTO %s.' || quote(name) \"\n    \"|| ' SELECT * FROM %s.' || quote(name) || ';' \"\n    \"FROM %s.sqlite_master WHERE name=='sqlite_sequence';\"\n  , targetDb, sourceDb, targetDb);\n  rc = (zSql == NULL) ? SQLITE_NOMEM : sqlcipher_execExecSql(db, &pzErrMsg, zSql); \n  if( rc!=SQLITE_OK ) goto end_of_export;\n  sqlite3_free(zSql);\n\n  /* Copy the triggers, views, and virtual tables from the main database\n  ** over to the temporary database.  None of these objects has any\n  ** associated storage, so all we have to do is copy their entries\n  ** from the SQLITE_MASTER table.\n  */\n  zSql = sqlite3_mprintf(\n    \"INSERT INTO %s.sqlite_master \"\n    \"  SELECT type, name, tbl_name, rootpage, sql\"\n    \"    FROM %s.sqlite_master\"\n    \"   WHERE type='view' OR type='trigger'\"\n    \"      OR (type='table' AND rootpage=0)\"\n  , targetDb, sourceDb);\n  rc = (zSql == NULL) ? SQLITE_NOMEM : sqlcipher_execSql(db, &pzErrMsg, zSql); \n  if( rc!=SQLITE_OK ) goto end_of_export;\n  sqlite3_free(zSql);\n\n  zSql = NULL;\nend_of_export:\n  db->init.iDb = 0;\n  db->flags = saved_flags;\n  db->mDbFlags = saved_mDbFlags;\n  db->nChange = saved_nChange;\n  db->nTotalChange = saved_nTotalChange;\n  db->mTrace = saved_mTrace;\n\n  if(zSql) sqlite3_free(zSql);\n\n  if(rc) {\n    if(pzErrMsg != NULL) {\n      sqlite3_result_error(context, pzErrMsg, -1);\n      sqlite3DbFree(db, pzErrMsg);\n    } else {\n      sqlite3_result_error(context, sqlite3ErrStr(rc), -1);\n    }\n  }\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1078,
    "critical_vars": [
      "argv[0]"
    ],
    "function": "sqlcipher_exportFunc",
    "filename": "sqlcipher/CVE-2021-3119/CVE-2021-3119_CWE-476_cb71f53e8cea4802509f182fa5bead0ac6ab0e7f_crypto.c.diff",
    "function_code": "void sqlcipher_exportFunc(sqlite3_context *context, int argc, sqlite3_value **argv) {\n  sqlite3 *db = sqlite3_context_db_handle(context);\n  const char* targetDb, *sourceDb; \n  int targetDb_idx = 0;\n  u64 saved_flags = db->flags;        /* Saved value of the db->flags */\n  u32 saved_mDbFlags = db->mDbFlags;        /* Saved value of the db->mDbFlags */\n  int saved_nChange = db->nChange;      /* Saved value of db->nChange */\n  int saved_nTotalChange = db->nTotalChange; /* Saved value of db->nTotalChange */\n  u8 saved_mTrace = db->mTrace;        /* Saved value of db->mTrace */\n  int rc = SQLITE_OK;     /* Return code from service routines */\n  char *zSql = NULL;         /* SQL statements */\n  char *pzErrMsg = NULL;\n\n  if(argc != 1 && argc != 2) {\n    rc = SQLITE_ERROR;\n    pzErrMsg = sqlite3_mprintf(\"invalid number of arguments (%d) passed to sqlcipher_export\", argc);\n    goto end_of_export;\n  }\n\n  if(sqlite3_value_type(argv[0]) == SQLITE_NULL) {\n    rc = SQLITE_ERROR;\n    pzErrMsg = sqlite3_mprintf(\"target database can't be NULL\");\n    goto end_of_export;\n  }\n\n  targetDb = (const char*) sqlite3_value_text(argv[0]); \n  sourceDb = \"main\";\n\n  if(argc == 2) {\n    if(sqlite3_value_type(argv[1]) == SQLITE_NULL) {\n      rc = SQLITE_ERROR;\n      pzErrMsg = sqlite3_mprintf(\"target database can't be NULL\");\n      goto end_of_export;\n    }\n    sourceDb = (char *) sqlite3_value_text(argv[1]);\n  }\n\n\n  /* if the name of the target is not main, but the index returned is zero \n     there is a mismatch and we should not proceed */\n  targetDb_idx =  sqlcipher_find_db_index(db, targetDb);\n  if(targetDb_idx == 0 && targetDb != NULL && sqlite3StrICmp(\"main\", targetDb) != 0) {\n    rc = SQLITE_ERROR;\n    pzErrMsg = sqlite3_mprintf(\"unknown database %s\", targetDb);\n    goto end_of_export;\n  }\n  db->init.iDb = targetDb_idx;\n\n  db->flags |= SQLITE_WriteSchema | SQLITE_IgnoreChecks; \n  db->mDbFlags |= DBFLAG_PreferBuiltin | DBFLAG_Vacuum;\n  db->flags &= ~(u64)(SQLITE_ForeignKeys | SQLITE_ReverseOrder | SQLITE_Defensive | SQLITE_CountRows); \n  db->mTrace = 0;\n\n  /* Query the schema of the main database. Create a mirror schema\n  ** in the temporary database.\n  */\n  zSql = sqlite3_mprintf(\n    \"SELECT sql \"\n    \"  FROM %s.sqlite_master WHERE type='table' AND name!='sqlite_sequence'\"\n    \"   AND rootpage>0\"\n  , sourceDb);\n  rc = (zSql == NULL) ? SQLITE_NOMEM : sqlcipher_execExecSql(db, &pzErrMsg, zSql); \n  if( rc!=SQLITE_OK ) goto end_of_export;\n  sqlite3_free(zSql);\n\n  zSql = sqlite3_mprintf(\n    \"SELECT sql \"\n    \"  FROM %s.sqlite_master WHERE sql LIKE 'CREATE INDEX %%' \"\n  , sourceDb);\n  rc = (zSql == NULL) ? SQLITE_NOMEM : sqlcipher_execExecSql(db, &pzErrMsg, zSql); \n  if( rc!=SQLITE_OK ) goto end_of_export;\n  sqlite3_free(zSql);\n\n  zSql = sqlite3_mprintf(\n    \"SELECT sql \"\n    \"  FROM %s.sqlite_master WHERE sql LIKE 'CREATE UNIQUE INDEX %%'\"\n  , sourceDb);\n  rc = (zSql == NULL) ? SQLITE_NOMEM : sqlcipher_execExecSql(db, &pzErrMsg, zSql); \n  if( rc!=SQLITE_OK ) goto end_of_export;\n  sqlite3_free(zSql);\n\n  /* Loop through the tables in the main database. For each, do\n  ** an \"INSERT INTO rekey_db.xxx SELECT * FROM main.xxx;\" to copy\n  ** the contents to the temporary database.\n  */\n  zSql = sqlite3_mprintf(\n    \"SELECT 'INSERT INTO %s.' || quote(name) \"\n    \"|| ' SELECT * FROM %s.' || quote(name) || ';'\"\n    \"FROM %s.sqlite_master \"\n    \"WHERE type = 'table' AND name!='sqlite_sequence' \"\n    \"  AND rootpage>0\"\n  , targetDb, sourceDb, sourceDb);\n  rc = (zSql == NULL) ? SQLITE_NOMEM : sqlcipher_execExecSql(db, &pzErrMsg, zSql); \n  if( rc!=SQLITE_OK ) goto end_of_export;\n  sqlite3_free(zSql);\n\n  /* Copy over the contents of the sequence table\n  */\n  zSql = sqlite3_mprintf(\n    \"SELECT 'INSERT INTO %s.' || quote(name) \"\n    \"|| ' SELECT * FROM %s.' || quote(name) || ';' \"\n    \"FROM %s.sqlite_master WHERE name=='sqlite_sequence';\"\n  , targetDb, sourceDb, targetDb);\n  rc = (zSql == NULL) ? SQLITE_NOMEM : sqlcipher_execExecSql(db, &pzErrMsg, zSql); \n  if( rc!=SQLITE_OK ) goto end_of_export;\n  sqlite3_free(zSql);\n\n  /* Copy the triggers, views, and virtual tables from the main database\n  ** over to the temporary database.  None of these objects has any\n  ** associated storage, so all we have to do is copy their entries\n  ** from the SQLITE_MASTER table.\n  */\n  zSql = sqlite3_mprintf(\n    \"INSERT INTO %s.sqlite_master \"\n    \"  SELECT type, name, tbl_name, rootpage, sql\"\n    \"    FROM %s.sqlite_master\"\n    \"   WHERE type='view' OR type='trigger'\"\n    \"      OR (type='table' AND rootpage=0)\"\n  , targetDb, sourceDb);\n  rc = (zSql == NULL) ? SQLITE_NOMEM : sqlcipher_execSql(db, &pzErrMsg, zSql); \n  if( rc!=SQLITE_OK ) goto end_of_export;\n  sqlite3_free(zSql);\n\n  zSql = NULL;\nend_of_export:\n  db->init.iDb = 0;\n  db->flags = saved_flags;\n  db->mDbFlags = saved_mDbFlags;\n  db->nChange = saved_nChange;\n  db->nTotalChange = saved_nTotalChange;\n  db->mTrace = saved_mTrace;\n\n  if(zSql) sqlite3_free(zSql);\n\n  if(rc) {\n    if(pzErrMsg != NULL) {\n      sqlite3_result_error(context, pzErrMsg, -1);\n      sqlite3DbFree(db, pzErrMsg);\n    } else {\n      sqlite3_result_error(context, sqlite3ErrStr(rc), -1);\n    }\n  }\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "for-Condition",
    "line_new": 342,
    "critical_vars": [
      "i"
    ],
    "function": "Scan::CreateParser",
    "filename": "libjpeg/CVE-2022-32201/CVE-2022-32201_CWE-476_ea6315164b1649ff932a396b7600eac4bffcfaba_scan.cpp.diff",
    "function_code": "void Scan::CreateParser(void)\n{\n  ScanType type = m_pFrame->ScanTypeOf();\n  //\n  assert(m_pParser == NULL);\n  //\n  // Check whether all components are there.\n  for(UBYTE i = 0;i < m_ucCount && i < 4;i++) {\n    if (ComponentOf(i) == NULL) {\n      JPG_THROW(MALFORMED_STREAM,\"Scan::CreateParser\",\n                \"found a component ID in a scan that does not exist\");\n    }\n  }\n  //\n  switch(type) {\n  case Baseline:\n    m_pParser = new(m_pEnviron) class SequentialScan(m_pFrame,this,\n                                                     m_ucScanStart,m_ucScanStop,\n                                                     m_ucLowBit + m_ucHiddenBits,\n                                                     m_ucHighBit + m_ucHiddenBits,\n                                                     false,false,false,true);\n    break;\n  case Sequential:\n    m_pParser = new(m_pEnviron) class SequentialScan(m_pFrame,this,\n                                                     m_ucScanStart,m_ucScanStop,\n                                                     m_ucLowBit + m_ucHiddenBits,\n                                                     m_ucHighBit + m_ucHiddenBits);\n    break;\n  case DifferentialSequential:\n    m_pParser = new(m_pEnviron) class SequentialScan(m_pFrame,this,\n                                                     m_ucScanStart,m_ucScanStop,\n                                                     m_ucLowBit + m_ucHiddenBits,\n                                                     m_ucHighBit + m_ucHiddenBits,true);\n    break;\n  case Lossless:\n    m_pParser = new(m_pEnviron) class LosslessScan(m_pFrame,this,m_ucScanStart,\n                                                   m_ucLowBit + m_ucHiddenBits);\n    break;\n  case DifferentialLossless:\n    m_pParser = new(m_pEnviron) class LosslessScan(m_pFrame,this,0,\n                                                   m_ucLowBit + m_ucHiddenBits,true);\n    break;\n  case ACLossless:\n    m_pParser = new(m_pEnviron) class ACLosslessScan(m_pFrame,this,m_ucScanStart,\n                                                     m_ucLowBit + m_ucHiddenBits);\n    break;\n  case ACDifferentialLossless:\n    m_pParser = new(m_pEnviron) class ACLosslessScan(m_pFrame,this,0,\n                                                     m_ucLowBit + m_ucHiddenBits,true);\n    break;\n  case ACSequential:\n    m_pParser = new(m_pEnviron) class ACSequentialScan(m_pFrame,this,\n                                                       m_ucScanStart,m_ucScanStop,\n                                                       m_ucLowBit + m_ucHiddenBits,\n                                                       m_ucHighBit + m_ucHiddenBits);\n    break;\n  case ACDifferentialSequential:\n    m_pParser = new(m_pEnviron) class ACSequentialScan(m_pFrame,this,\n                                                       m_ucScanStart,m_ucScanStop,\n                                                       m_ucLowBit + m_ucHiddenBits,\n                                                       m_ucHighBit + m_ucHiddenBits,true);\n    break;\n  case Progressive:\n    if (m_ucHighBit == 0) { // The first scan is parsed off by the regular parser.\n      m_pParser = new(m_pEnviron) class SequentialScan(m_pFrame,this,\n                                                       m_ucScanStart,m_ucScanStop,\n                                                       m_ucLowBit + m_ucHiddenBits,\n                                                       m_ucHighBit + m_ucHiddenBits);\n    } else { \n      m_pParser = new(m_pEnviron) class RefinementScan(m_pFrame,this,\n                                                       m_ucScanStart,m_ucScanStop,\n                                                       m_ucLowBit + m_ucHiddenBits,\n                                                       m_ucHighBit + m_ucHiddenBits);\n    }\n    break;\n  case ResidualProgressive:\n    if (m_ucHighBit == 0) { \n      m_pParser = new(m_pEnviron) class SequentialScan(m_pFrame,this,\n                                                       m_ucScanStart,m_ucScanStop,\n                                                       m_ucLowBit + m_ucHiddenBits,\n                                                       m_ucHighBit + m_ucHiddenBits,\n                                                       true,true);\n    } else { \n      m_pParser = new(m_pEnviron) class RefinementScan(m_pFrame,this,\n                                                       m_ucScanStart,m_ucScanStop,\n                                                       m_ucLowBit + m_ucHiddenBits,\n                                                       m_ucHighBit + m_ucHiddenBits,\n                                                       true,true);\n    }\n    break;\n  case DifferentialProgressive:\n    if (m_ucHighBit == 0) { // The first scan is parsed off by the regular parser.\n      m_pParser = new(m_pEnviron) class SequentialScan(m_pFrame,this,\n                                                       m_ucScanStart,m_ucScanStop,\n                                                       m_ucLowBit + m_ucHiddenBits,\n                                                       m_ucHighBit + m_ucHiddenBits,true);\n    } else { \n      // Even though the specs do not mention this, it makes perfect sense that the\n      // refinement scan is a regular refinement scan without modification.\n      m_pParser = new(m_pEnviron) class RefinementScan(m_pFrame,this,\n                                                       m_ucScanStart,m_ucScanStop,\n                                                       m_ucLowBit + m_ucHiddenBits,\n                                                       m_ucHighBit + m_ucHiddenBits,true);\n    }\n    break;\n  case ACProgressive: \n    if (m_ucHighBit == 0) { // The first scan is parsed off by the regular parser.\n      m_pParser = new(m_pEnviron) class ACSequentialScan(m_pFrame,this,\n                                                         m_ucScanStart,m_ucScanStop,\n                                                         m_ucLowBit + m_ucHiddenBits,\n                                                         m_ucHighBit + m_ucHiddenBits);\n    } else { \n      m_pParser = new(m_pEnviron) class ACRefinementScan(m_pFrame,this,\n                                                         m_ucScanStart,m_ucScanStop,\n                                                         m_ucLowBit + m_ucHiddenBits,\n                                                         m_ucHighBit + m_ucHiddenBits);\n    }\n    break;\n  case ACDifferentialProgressive: \n    if (m_ucHighBit == 0) { // The first scan is parsed off by the regular parser.\n      m_pParser = new(m_pEnviron) class ACSequentialScan(m_pFrame,this,\n                                                         m_ucScanStart,m_ucScanStop,\n                                                         m_ucLowBit + m_ucHiddenBits,\n                                                         m_ucHighBit + m_ucHiddenBits,\n                                                         true);\n    } else { \n      m_pParser = new(m_pEnviron) class ACRefinementScan(m_pFrame,this,\n                                                         m_ucScanStart,m_ucScanStop,\n                                                         m_ucLowBit + m_ucHiddenBits,\n                                                         m_ucHighBit + m_ucHiddenBits,\n                                                         true);\n    }\n    break;\n  case ACResidualProgressive:  \n    if (m_ucHighBit == 0) { // The first scan is parsed off by the regular parser.\n      m_pParser = new(m_pEnviron) class ACSequentialScan(m_pFrame,this,\n                                                         m_ucScanStart,m_ucScanStop,\n                                                         m_ucLowBit + m_ucHiddenBits,\n                                                         m_ucHighBit + m_ucHiddenBits,\n                                                         false,true);\n    } else { \n      m_pParser = new(m_pEnviron) class ACRefinementScan(m_pFrame,this,\n                                                         m_ucScanStart,m_ucScanStop,\n                                                         m_ucLowBit + m_ucHiddenBits,\n                                                         m_ucHighBit + m_ucHiddenBits,\n                                                         false,true);\n    }\n    break;\n  case Residual:\n    m_pParser = new(m_pEnviron) SequentialScan(m_pFrame,this,\n                                               m_ucScanStart,m_ucScanStop,\n                                               m_ucLowBit + m_ucHiddenBits,\n                                               m_ucHighBit + m_ucHiddenBits,\n                                               true,true);\n    break;\n  case ACResidual:\n    m_pParser = new(m_pEnviron) ACSequentialScan(m_pFrame,this,\n                                                 m_ucScanStart,m_ucScanStop,\n                                                 m_ucLowBit + m_ucHiddenBits,\n                                                 m_ucHighBit + m_ucHiddenBits,\n                                                 true,true);  \n    break;\n  case ResidualDCT:\n    m_pParser = new(m_pEnviron) SequentialScan(m_pFrame,this,\n                                               m_ucScanStart,m_ucScanStop,\n                                               m_ucLowBit + m_ucHiddenBits,\n                                               m_ucHighBit + m_ucHiddenBits,\n                                               false,false,true);\n    break; \n  case ACResidualDCT:\n    m_pParser = new(m_pEnviron) ACSequentialScan(m_pFrame,this,\n                                                 m_ucScanStart,m_ucScanStop,\n                                                 m_ucLowBit + m_ucHiddenBits,\n                                                 m_ucHighBit + m_ucHiddenBits,\n                                                 false,false,true);\n    break;\n  case JPEG_LS:\n    // Depends on the interleaving\n    switch(m_ucScanStop) {\n    case 0:\n      if (m_ucCount != 1)\n        JPG_THROW(MALFORMED_STREAM,\"Scan::CreateParser\",\n                  \"invalid codestream, found a single comonent scan containing more than one component\");\n      m_pParser = new(m_pEnviron) class SingleComponentLSScan(m_pFrame,this,\n                                                              m_ucScanStart, // NEAR\n                                                              m_ucMappingTable,\n                                                              m_ucLowBit + m_ucHiddenBits); \n      break;\n    case 1:\n      m_pParser = new(m_pEnviron) class LineInterleavedLSScan(m_pFrame,this,\n                                                              m_ucScanStart,\n                                                              m_ucMappingTable,\n                                                              m_ucLowBit + m_ucHiddenBits);\n      break;\n    case 2:\n      m_pParser = new(m_pEnviron) class SampleInterleavedLSScan(m_pFrame,this,\n                                                                m_ucScanStart,\n                                                                m_ucMappingTable,\n                                                                m_ucLowBit + m_ucHiddenBits);\n      break;\n    }\n    break;\n  default:\n    JPG_THROW(NOT_IMPLEMENTED,\"Scan::CreateParser\",\n              \"sorry, the coding mode in the codestream is currently not supported\");\n  }\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 565,
    "critical_vars": [
      "m_pppImage[i]",
      "x",
      "dst"
    ],
    "function": "LineBitmapRequester::ReconstructRegion",
    "filename": "libjpeg/CVE-2022-32202/CVE-2022-32202_CWE-476_51c3241b6da39df30f016b63f43f31c4011222c7_linebitmaprequester.cpp.diff",
    "function_code": "void LineBitmapRequester::ReconstructRegion(const RectAngle<LONG> &orgregion,const struct RectangleRequest *rr)\n{\n  class ColorTrafo *ctrafo = ColorTrafoOf(false,!rr->rr_bColorTrafo);\n  UBYTE i;\n\n  if (m_bSubsampling && rr->rr_bUpsampling) { \n    for(i = rr->rr_usFirstComponent;i <= rr->rr_usLastComponent;i++) {\n      class Component *comp = m_pFrame->ComponentOf(i);\n      UBYTE subx            = comp->SubXOf();\n      UBYTE suby            = comp->SubYOf();\n      class UpsamplerBase *up;  // upsampler\n      LONG bx,by;\n      RectAngle<LONG> blocks;\n      //\n      // Compute the region of blocks\n      assert(subx > 0 && suby > 0);\n      if ((up = m_ppUpsampler[i])) {\n        LONG bwidth           = ((m_ulPixelWidth  + subx - 1) / subx + 7) >> 3;\n        LONG bheight          = ((m_ulPixelHeight + suby - 1) / suby + 7) >> 3;\n        LONG rx               = (subx > 1)?(1):(0);\n        LONG ry               = (suby > 1)?(1):(0);\n        // The +/-1 include additional lines required for subsampling expansion\n        blocks.ra_MinX        = ((orgregion.ra_MinX / subx - rx) >> 3);\n        blocks.ra_MaxX        = ((orgregion.ra_MaxX / subx + rx) >> 3);\n        blocks.ra_MinY        = ((orgregion.ra_MinY / suby - ry) >> 3);\n        blocks.ra_MaxY        = ((orgregion.ra_MaxY / suby + ry) >> 3);\n        // Clip.\n        if (blocks.ra_MinX < 0)        blocks.ra_MinX = 0;\n        if (blocks.ra_MaxX >= bwidth)  blocks.ra_MaxX = bwidth - 1;\n        if (blocks.ra_MinY < 0)        blocks.ra_MinY = 0;\n        if (blocks.ra_MaxY >= bheight) blocks.ra_MaxY = bheight - 1;\n        up->SetBufferedRegion(blocks); // also removes the rectangle of blocks already buffered.\n        //\n        for(by = blocks.ra_MinY;by <= blocks.ra_MaxY;by++) {\n          for(bx = blocks.ra_MinX;bx <= blocks.ra_MaxX;bx++) {\n            LONG dst[64];\n            if (*m_pppImage[i]) {\n              FetchRegion(bx,*m_pppImage[i],dst);\n            } else {\n              memset(dst,0,sizeof(dst));\n            }\n            up->DefineRegion(bx,by,dst);\n          }\n          Next8Lines(i);\n        }\n      }\n    }\n    // Now push blocks into the color transformer from the upsampler.\n    {\n      RectAngle<LONG> r;\n      ULONG minx   = orgregion.ra_MinX >> 3;\n      ULONG maxx   = orgregion.ra_MaxX >> 3;\n      ULONG miny   = orgregion.ra_MinY >> 3;\n      ULONG maxy   = orgregion.ra_MaxY >> 3;\n      ULONG x,y;\n      \n      if (maxy > m_ulMaxMCU)\n        maxy = m_ulMaxMCU;\n\n      for(y = miny,r.ra_MinY = orgregion.ra_MinY;y <= maxy;y++,r.ra_MinY = r.ra_MaxY + 1) {\n        r.ra_MaxY = (r.ra_MinY & -8) + 7;\n        if (r.ra_MaxY > orgregion.ra_MaxY)\n          r.ra_MaxY = orgregion.ra_MaxY;\n        \n        for(x = minx,r.ra_MinX = orgregion.ra_MinX;x <= maxx;x++,r.ra_MinX = r.ra_MaxX + 1) {\n          r.ra_MaxX = (r.ra_MinX & -8) + 7;\n          if (r.ra_MaxX > orgregion.ra_MaxX)\n            r.ra_MaxX = orgregion.ra_MaxX;\n          \n          for(i = 0;i < m_ucCount;i++) {\n            if (i >= rr->rr_usFirstComponent && i <= rr->rr_usLastComponent) {\n              ExtractBitmap(m_ppTempIBM[i],r,i);\n              if (m_ppUpsampler[i]) {\n                // Upsampled case, take from the upsampler, transform\n                // into the color buffer.\n                m_ppUpsampler[i]->UpsampleRegion(r,m_ppCTemp[i]);\n              } else if (*m_pppImage[i]) {\n                FetchRegion(x,*m_pppImage[i],m_ppCTemp[i]);\n              } else {\n                memset(m_ppCTemp[0],0,sizeof(LONG) * 64);\n              }\n            } else {\n              // Not requested, zero the buffer.\n              memset(m_ppCTemp[i],0,sizeof(LONG) * 64);\n            }\n          }\n          ctrafo->YCbCr2RGB(r,m_ppTempIBM,m_ppCTemp,NULL);\n        }\n        //\n        // Advance the quantized rows for the non-subsampled components,\n        // upsampled components have been advanced above.\n        for(i = rr->rr_usFirstComponent;i <= rr->rr_usLastComponent;i++) {\n          if (m_ppUpsampler[i] == NULL)\n            Next8Lines(i);\n        }\n      }\n    }\n  } else { // direct case, no upsampling required, residual coding possible.\n    RectAngle<LONG> r;\n    RectAngle<LONG> region = orgregion;\n    SubsampledRegion(region,rr);\n    ULONG minx   = region.ra_MinX >> 3;\n    ULONG maxx   = region.ra_MaxX >> 3;\n    ULONG miny   = region.ra_MinY >> 3;\n    ULONG maxy   = region.ra_MaxY >> 3;\n    ULONG x,y;\n      \n    if (maxy > m_ulMaxMCU)\n      maxy = m_ulMaxMCU;\n\n    for(y = miny,r.ra_MinY = region.ra_MinY;y <= maxy;y++,r.ra_MinY = r.ra_MaxY + 1) {\n      r.ra_MaxY = (r.ra_MinY & -8) + 7;\n      if (r.ra_MaxY > region.ra_MaxY)\n        r.ra_MaxY = region.ra_MaxY;\n        \n      for(x = minx,r.ra_MinX = region.ra_MinX;x <= maxx;x++,r.ra_MinX = r.ra_MaxX + 1) {\n        r.ra_MaxX = (r.ra_MinX & -8) + 7;\n        if (r.ra_MaxX > region.ra_MaxX)\n          r.ra_MaxX = region.ra_MaxX;\n\n        for(i = 0;i < m_ucCount;i++) {      \n          LONG *dst = m_ppCTemp[i];\n          if (i >= rr->rr_usFirstComponent && i <= rr->rr_usLastComponent) {\n            ExtractBitmap(m_ppTempIBM[i],r,i);\n            FetchRegion(x,*m_pppImage[i],dst);\n          } else {\n            memset(dst,0,sizeof(LONG) * 64);\n          }\n        }\n        //\n        // Perform the color transformation now.\n        ctrafo->YCbCr2RGB(r,m_ppTempIBM,m_ppCTemp,NULL);\n      } // of loop over x\n      //\n      // Advance the rows.\n      for(i = rr->rr_usFirstComponent;i <= rr->rr_usLastComponent;i++) {\n        Next8Lines(i);\n      }\n    }\n  }\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 565,
    "critical_vars": [
      "*m_pppImage[i]"
    ],
    "function": "LineBitmapRequester::ReconstructRegion",
    "filename": "libjpeg/CVE-2022-32202/CVE-2022-32202_CWE-476_51c3241b6da39df30f016b63f43f31c4011222c7_linebitmaprequester.cpp.diff",
    "function_code": "void LineBitmapRequester::ReconstructRegion(const RectAngle<LONG> &orgregion,const struct RectangleRequest *rr)\n{\n  class ColorTrafo *ctrafo = ColorTrafoOf(false,!rr->rr_bColorTrafo);\n  UBYTE i;\n\n  if (m_bSubsampling && rr->rr_bUpsampling) { \n    for(i = rr->rr_usFirstComponent;i <= rr->rr_usLastComponent;i++) {\n      class Component *comp = m_pFrame->ComponentOf(i);\n      UBYTE subx            = comp->SubXOf();\n      UBYTE suby            = comp->SubYOf();\n      class UpsamplerBase *up;  // upsampler\n      LONG bx,by;\n      RectAngle<LONG> blocks;\n      //\n      // Compute the region of blocks\n      assert(subx > 0 && suby > 0);\n      if ((up = m_ppUpsampler[i])) {\n        LONG bwidth           = ((m_ulPixelWidth  + subx - 1) / subx + 7) >> 3;\n        LONG bheight          = ((m_ulPixelHeight + suby - 1) / suby + 7) >> 3;\n        LONG rx               = (subx > 1)?(1):(0);\n        LONG ry               = (suby > 1)?(1):(0);\n        // The +/-1 include additional lines required for subsampling expansion\n        blocks.ra_MinX        = ((orgregion.ra_MinX / subx - rx) >> 3);\n        blocks.ra_MaxX        = ((orgregion.ra_MaxX / subx + rx) >> 3);\n        blocks.ra_MinY        = ((orgregion.ra_MinY / suby - ry) >> 3);\n        blocks.ra_MaxY        = ((orgregion.ra_MaxY / suby + ry) >> 3);\n        // Clip.\n        if (blocks.ra_MinX < 0)        blocks.ra_MinX = 0;\n        if (blocks.ra_MaxX >= bwidth)  blocks.ra_MaxX = bwidth - 1;\n        if (blocks.ra_MinY < 0)        blocks.ra_MinY = 0;\n        if (blocks.ra_MaxY >= bheight) blocks.ra_MaxY = bheight - 1;\n        up->SetBufferedRegion(blocks); // also removes the rectangle of blocks already buffered.\n        //\n        for(by = blocks.ra_MinY;by <= blocks.ra_MaxY;by++) {\n          for(bx = blocks.ra_MinX;bx <= blocks.ra_MaxX;bx++) {\n            LONG dst[64];\n            if (*m_pppImage[i]) {\n              FetchRegion(bx,*m_pppImage[i],dst);\n            } else {\n              memset(dst,0,sizeof(dst));\n            }\n            up->DefineRegion(bx,by,dst);\n          }\n          Next8Lines(i);\n        }\n      }\n    }\n    // Now push blocks into the color transformer from the upsampler.\n    {\n      RectAngle<LONG> r;\n      ULONG minx   = orgregion.ra_MinX >> 3;\n      ULONG maxx   = orgregion.ra_MaxX >> 3;\n      ULONG miny   = orgregion.ra_MinY >> 3;\n      ULONG maxy   = orgregion.ra_MaxY >> 3;\n      ULONG x,y;\n      \n      if (maxy > m_ulMaxMCU)\n        maxy = m_ulMaxMCU;\n\n      for(y = miny,r.ra_MinY = orgregion.ra_MinY;y <= maxy;y++,r.ra_MinY = r.ra_MaxY + 1) {\n        r.ra_MaxY = (r.ra_MinY & -8) + 7;\n        if (r.ra_MaxY > orgregion.ra_MaxY)\n          r.ra_MaxY = orgregion.ra_MaxY;\n        \n        for(x = minx,r.ra_MinX = orgregion.ra_MinX;x <= maxx;x++,r.ra_MinX = r.ra_MaxX + 1) {\n          r.ra_MaxX = (r.ra_MinX & -8) + 7;\n          if (r.ra_MaxX > orgregion.ra_MaxX)\n            r.ra_MaxX = orgregion.ra_MaxX;\n          \n          for(i = 0;i < m_ucCount;i++) {\n            if (i >= rr->rr_usFirstComponent && i <= rr->rr_usLastComponent) {\n              ExtractBitmap(m_ppTempIBM[i],r,i);\n              if (m_ppUpsampler[i]) {\n                // Upsampled case, take from the upsampler, transform\n                // into the color buffer.\n                m_ppUpsampler[i]->UpsampleRegion(r,m_ppCTemp[i]);\n              } else if (*m_pppImage[i]) {\n                FetchRegion(x,*m_pppImage[i],m_ppCTemp[i]);\n              } else {\n                memset(m_ppCTemp[0],0,sizeof(LONG) * 64);\n              }\n            } else {\n              // Not requested, zero the buffer.\n              memset(m_ppCTemp[i],0,sizeof(LONG) * 64);\n            }\n          }\n          ctrafo->YCbCr2RGB(r,m_ppTempIBM,m_ppCTemp,NULL);\n        }\n        //\n        // Advance the quantized rows for the non-subsampled components,\n        // upsampled components have been advanced above.\n        for(i = rr->rr_usFirstComponent;i <= rr->rr_usLastComponent;i++) {\n          if (m_ppUpsampler[i] == NULL)\n            Next8Lines(i);\n        }\n      }\n    }\n  } else { // direct case, no upsampling required, residual coding possible.\n    RectAngle<LONG> r;\n    RectAngle<LONG> region = orgregion;\n    SubsampledRegion(region,rr);\n    ULONG minx   = region.ra_MinX >> 3;\n    ULONG maxx   = region.ra_MaxX >> 3;\n    ULONG miny   = region.ra_MinY >> 3;\n    ULONG maxy   = region.ra_MaxY >> 3;\n    ULONG x,y;\n      \n    if (maxy > m_ulMaxMCU)\n      maxy = m_ulMaxMCU;\n\n    for(y = miny,r.ra_MinY = region.ra_MinY;y <= maxy;y++,r.ra_MinY = r.ra_MaxY + 1) {\n      r.ra_MaxY = (r.ra_MinY & -8) + 7;\n      if (r.ra_MaxY > region.ra_MaxY)\n        r.ra_MaxY = region.ra_MaxY;\n        \n      for(x = minx,r.ra_MinX = region.ra_MinX;x <= maxx;x++,r.ra_MinX = r.ra_MaxX + 1) {\n        r.ra_MaxX = (r.ra_MinX & -8) + 7;\n        if (r.ra_MaxX > region.ra_MaxX)\n          r.ra_MaxX = region.ra_MaxX;\n\n        for(i = 0;i < m_ucCount;i++) {      \n          LONG *dst = m_ppCTemp[i];\n          if (i >= rr->rr_usFirstComponent && i <= rr->rr_usLastComponent) {\n            ExtractBitmap(m_ppTempIBM[i],r,i);\n            if (*m_pppImage[i]) {\n              FetchRegion(x,*m_pppImage[i],dst);\n            } else {\n              memset(dst,0,sizeof(LONG) * 64);\n            }\n          } else {\n            memset(dst,0,sizeof(LONG) * 64);\n          }\n        }\n        //\n        // Perform the color transformation now.\n        ctrafo->YCbCr2RGB(r,m_ppTempIBM,m_ppCTemp,NULL);\n      } // of loop over x\n      //\n      // Advance the rows.\n      for(i = rr->rr_usFirstComponent;i <= rr->rr_usLastComponent;i++) {\n        Next8Lines(i);\n      }\n    }\n  }\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 71,
    "critical_vars": [
      "remaining"
    ],
    "function": "dnxhd_find_frame_end",
    "filename": "FFmpeg/CVE-2017-9608/CVE-2017-9608_CWE-476_611b35627488a8d0763e75c25ee0875c5b7987dd_dnxhd_parser.c.diff",
    "function_code": "static int dnxhd_find_frame_end(DNXHDParserContext *dctx,\n                                const uint8_t *buf, int buf_size)\n{\n    ParseContext *pc = &dctx->pc;\n    uint64_t state = pc->state64;\n    int pic_found = pc->frame_start_found;\n    int i = 0;\n\n    if (!pic_found) {\n        for (i = 0; i < buf_size; i++) {\n            state = (state << 8) | buf[i];\n            if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {\n                i++;\n                pic_found = 1;\n                dctx->cur_byte = 0;\n                dctx->remaining = 0;\n                break;\n            }\n        }\n    }\n\n    if (pic_found && !dctx->remaining) {\n        if (!buf_size) /* EOF considered as end of frame */\n            return 0;\n        for (; i < buf_size; i++) {\n            dctx->cur_byte++;\n            state = (state << 8) | buf[i];\n\n            if (dctx->cur_byte == 24) {\n                dctx->h = (state >> 32) & 0xFFFF;\n            } else if (dctx->cur_byte == 26) {\n                dctx->w = (state >> 32) & 0xFFFF;\n            } else if (dctx->cur_byte == 42) {\n                int cid = (state >> 32) & 0xFFFFFFFF;\n                int remaining;\n\n                if (cid <= 0)\n                    continue;\n\n                remaining = avpriv_dnxhd_get_frame_size(cid);\n                if (remaining <= 0) {\n                    remaining = ff_dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);\n                    if (remaining <= 0)\n                        continue;\n                }\n                dctx->remaining = remaining;\n                if (buf_size - i + 47 >= dctx->remaining) {\n                    int remaining = dctx->remaining;\n\n                    pc->frame_start_found = 0;\n                    pc->state64 = -1;\n                    dctx->cur_byte = 0;\n                    dctx->remaining = 0;\n                    return remaining;\n                } else {\n                    dctx->remaining -= buf_size;\n                }\n            }\n        }\n    } else if (pic_found) {\n        if (dctx->remaining > buf_size) {\n            dctx->remaining -= buf_size;\n        } else {\n            int remaining = dctx->remaining;\n\n            pc->frame_start_found = 0;\n            pc->state64 = -1;\n            dctx->cur_byte = 0;\n            dctx->remaining = 0;\n            return remaining;\n        }\n    }\n    pc->frame_start_found = pic_found;\n    pc->state64 = state;\n    return END_NOT_FOUND;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 75,
    "critical_vars": [
      "dctx->remaining"
    ],
    "function": "dnxhd_find_frame_end",
    "filename": "FFmpeg/CVE-2017-9608/CVE-2017-9608_CWE-476_611b35627488a8d0763e75c25ee0875c5b7987dd_dnxhd_parser.c.diff",
    "function_code": "static int dnxhd_find_frame_end(DNXHDParserContext *dctx,\n                                const uint8_t *buf, int buf_size)\n{\n    ParseContext *pc = &dctx->pc;\n    uint64_t state = pc->state64;\n    int pic_found = pc->frame_start_found;\n    int i = 0;\n\n    if (!pic_found) {\n        for (i = 0; i < buf_size; i++) {\n            state = (state << 8) | buf[i];\n            if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {\n                i++;\n                pic_found = 1;\n                dctx->cur_byte = 0;\n                dctx->remaining = 0;\n                break;\n            }\n        }\n    }\n\n    if (pic_found && !dctx->remaining) {\n        if (!buf_size) /* EOF considered as end of frame */\n            return 0;\n        for (; i < buf_size; i++) {\n            dctx->cur_byte++;\n            state = (state << 8) | buf[i];\n\n            if (dctx->cur_byte == 24) {\n                dctx->h = (state >> 32) & 0xFFFF;\n            } else if (dctx->cur_byte == 26) {\n                dctx->w = (state >> 32) & 0xFFFF;\n            } else if (dctx->cur_byte == 42) {\n                int cid = (state >> 32) & 0xFFFFFFFF;\n\n                if (cid <= 0)\n                    continue;\n\n                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);\n                if (dctx->remaining <= 0) {\n                    dctx->remaining = ff_dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);\n                    if (dctx->remaining <= 0)\n                        return dctx->remaining;\n                }\n                if (buf_size - i + 47 >= dctx->remaining) {\n                    int remaining = dctx->remaining;\n\n                    pc->frame_start_found = 0;\n                    pc->state64 = -1;\n                    dctx->cur_byte = 0;\n                    dctx->remaining = 0;\n                    return remaining;\n                } else {\n                    dctx->remaining -= buf_size;\n                }\n            }\n        }\n    } else if (pic_found) {\n        if (dctx->remaining > buf_size) {\n            dctx->remaining -= buf_size;\n        } else {\n            int remaining = dctx->remaining;\n\n            pc->frame_start_found = 0;\n            pc->state64 = -1;\n            dctx->cur_byte = 0;\n            dctx->remaining = 0;\n            return remaining;\n        }\n    }\n    pc->frame_start_found = pic_found;\n    pc->state64 = state;\n    return END_NOT_FOUND;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 355,
    "critical_vars": [
      "s"
    ],
    "function": "decode_main_header",
    "filename": "FFmpeg/CVE-2022-3341/CVE-2022-3341_CWE-476_9cf652cef49d74afe3d454f27d49eb1a1394951e_nutdec.c.diff",
    "function_code": "static int decode_main_header(NUTContext *nut)\n{\n    AVFormatContext *s = nut->avf;\n    AVIOContext *bc    = s->pb;\n    uint64_t tmp, end, length;\n    unsigned int stream_count;\n    int i, j, count, ret;\n    int tmp_stream, tmp_mul, tmp_pts, tmp_size, tmp_res, tmp_head_idx;\n\n    length = get_packetheader(nut, bc, 1, MAIN_STARTCODE);\n    end = length + avio_tell(bc);\n\n    nut->version = ffio_read_varlen(bc);\n    if (nut->version < NUT_MIN_VERSION ||\n        nut->version > NUT_MAX_VERSION) {\n        av_log(s, AV_LOG_ERROR, \"Version %d not supported.\\n\",\n               nut->version);\n        return AVERROR(ENOSYS);\n    }\n    if (nut->version > 3)\n        nut->minor_version = ffio_read_varlen(bc);\n\n    GET_V(stream_count, tmp > 0 && tmp <= NUT_MAX_STREAMS);\n\n    nut->max_distance = ffio_read_varlen(bc);\n    if (nut->max_distance > 65536) {\n        av_log(s, AV_LOG_DEBUG, \"max_distance %d\\n\", nut->max_distance);\n        nut->max_distance = 65536;\n    }\n\n    GET_V(nut->time_base_count, tmp > 0 && tmp < INT_MAX / sizeof(AVRational) && tmp < length/2);\n    nut->time_base = av_malloc_array(nut->time_base_count, sizeof(AVRational));\n    if (!nut->time_base)\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < nut->time_base_count; i++) {\n        GET_V(nut->time_base[i].num, tmp > 0 && tmp < (1ULL << 31));\n        GET_V(nut->time_base[i].den, tmp > 0 && tmp < (1ULL << 31));\n        if (av_gcd(nut->time_base[i].num, nut->time_base[i].den) != 1) {\n            av_log(s, AV_LOG_ERROR, \"invalid time base %d/%d\\n\",\n                   nut->time_base[i].num,\n                   nut->time_base[i].den);\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n    }\n    tmp_pts      = 0;\n    tmp_mul      = 1;\n    tmp_stream   = 0;\n    tmp_head_idx = 0;\n    for (i = 0; i < 256;) {\n        int tmp_flags  = ffio_read_varlen(bc);\n        int tmp_fields = ffio_read_varlen(bc);\n\n        if (tmp_fields > 0)\n            tmp_pts = get_s(bc);\n        if (tmp_fields > 1)\n            tmp_mul = ffio_read_varlen(bc);\n        if (tmp_fields > 2)\n            tmp_stream = ffio_read_varlen(bc);\n        if (tmp_fields > 3)\n            tmp_size = ffio_read_varlen(bc);\n        else\n            tmp_size = 0;\n        if (tmp_fields > 4)\n            tmp_res = ffio_read_varlen(bc);\n        else\n            tmp_res = 0;\n        if (tmp_fields > 5)\n            count = ffio_read_varlen(bc);\n        else\n            count = tmp_mul - (unsigned)tmp_size;\n        if (tmp_fields > 6)\n            get_s(bc);\n        if (tmp_fields > 7)\n            tmp_head_idx = ffio_read_varlen(bc);\n\n        while (tmp_fields-- > 8) {\n            if (bc->eof_reached) {\n                av_log(s, AV_LOG_ERROR, \"reached EOF while decoding main header\\n\");\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n            ffio_read_varlen(bc);\n        }\n\n        if (count <= 0 || count > 256 - (i <= 'N') - i) {\n            av_log(s, AV_LOG_ERROR, \"illegal count %d at %d\\n\", count, i);\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n        if (tmp_stream >= stream_count) {\n            av_log(s, AV_LOG_ERROR, \"illegal stream number %d >= %d\\n\",\n                   tmp_stream, stream_count);\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n        if (tmp_size < 0 || tmp_size > INT_MAX - count) {\n            av_log(s, AV_LOG_ERROR, \"illegal size\\n\");\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n\n        for (j = 0; j < count; j++, i++) {\n            if (i == 'N') {\n                nut->frame_code[i].flags = FLAG_INVALID;\n                j--;\n                continue;\n            }\n            nut->frame_code[i].flags          = tmp_flags;\n            nut->frame_code[i].pts_delta      = tmp_pts;\n            nut->frame_code[i].stream_id      = tmp_stream;\n            nut->frame_code[i].size_mul       = tmp_mul;\n            nut->frame_code[i].size_lsb       = tmp_size + j;\n            nut->frame_code[i].reserved_count = tmp_res;\n            nut->frame_code[i].header_idx     = tmp_head_idx;\n        }\n    }\n    av_assert0(nut->frame_code['N'].flags == FLAG_INVALID);\n\n    if (end > avio_tell(bc) + 4) {\n        int rem = 1024;\n        GET_V(nut->header_count, tmp < 128U);\n        nut->header_count++;\n        for (i = 1; i < nut->header_count; i++) {\n            uint8_t *hdr;\n            GET_V(nut->header_len[i], tmp > 0 && tmp < 256);\n            if (rem < nut->header_len[i]) {\n                av_log(s, AV_LOG_ERROR,\n                       \"invalid elision header %d : %d > %d\\n\",\n                       i, nut->header_len[i], rem);\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n            rem -= nut->header_len[i];\n            hdr = av_malloc(nut->header_len[i]);\n            if (!hdr) {\n                ret = AVERROR(ENOMEM);\n                goto fail;\n            }\n            avio_read(bc, hdr, nut->header_len[i]);\n            nut->header[i] = hdr;\n        }\n        av_assert0(nut->header_len[0] == 0);\n    }\n\n    // flags had been effectively introduced in version 4\n    if (nut->version > 3 && end > avio_tell(bc) + 4) {\n        nut->flags = ffio_read_varlen(bc);\n    }\n\n    if (skip_reserved(bc, end) || ffio_get_checksum(bc)) {\n        av_log(s, AV_LOG_ERROR, \"main header checksum mismatch\\n\");\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n\n    nut->stream = av_calloc(stream_count, sizeof(StreamContext));\n    if (!nut->stream) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n    for (i = 0; i < stream_count; i++)\n        avformat_new_stream(s, NULL);\n\n    return 0;\nfail:\n    av_freep(&nut->time_base);\n    for (i = 1; i < nut->header_count; i++) {\n        av_freep(&nut->header[i]);\n    }\n    nut->header_count = 0;\n    return ret;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 355,
    "critical_vars": [
      "s"
    ],
    "function": "decode_main_header",
    "filename": "FFmpeg/CVE-2022-3341/CVE-2022-3341_CWE-476_9cf652cef49d74afe3d454f27d49eb1a1394951e_nutdec.c.diff",
    "function_code": "static int decode_main_header(NUTContext *nut)\n{\n    AVFormatContext *s = nut->avf;\n    AVIOContext *bc    = s->pb;\n    uint64_t tmp, end, length;\n    unsigned int stream_count;\n    int i, j, count, ret;\n    int tmp_stream, tmp_mul, tmp_pts, tmp_size, tmp_res, tmp_head_idx;\n\n    length = get_packetheader(nut, bc, 1, MAIN_STARTCODE);\n    end = length + avio_tell(bc);\n\n    nut->version = ffio_read_varlen(bc);\n    if (nut->version < NUT_MIN_VERSION ||\n        nut->version > NUT_MAX_VERSION) {\n        av_log(s, AV_LOG_ERROR, \"Version %d not supported.\\n\",\n               nut->version);\n        return AVERROR(ENOSYS);\n    }\n    if (nut->version > 3)\n        nut->minor_version = ffio_read_varlen(bc);\n\n    GET_V(stream_count, tmp > 0 && tmp <= NUT_MAX_STREAMS);\n\n    nut->max_distance = ffio_read_varlen(bc);\n    if (nut->max_distance > 65536) {\n        av_log(s, AV_LOG_DEBUG, \"max_distance %d\\n\", nut->max_distance);\n        nut->max_distance = 65536;\n    }\n\n    GET_V(nut->time_base_count, tmp > 0 && tmp < INT_MAX / sizeof(AVRational) && tmp < length/2);\n    nut->time_base = av_malloc_array(nut->time_base_count, sizeof(AVRational));\n    if (!nut->time_base)\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < nut->time_base_count; i++) {\n        GET_V(nut->time_base[i].num, tmp > 0 && tmp < (1ULL << 31));\n        GET_V(nut->time_base[i].den, tmp > 0 && tmp < (1ULL << 31));\n        if (av_gcd(nut->time_base[i].num, nut->time_base[i].den) != 1) {\n            av_log(s, AV_LOG_ERROR, \"invalid time base %d/%d\\n\",\n                   nut->time_base[i].num,\n                   nut->time_base[i].den);\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n    }\n    tmp_pts      = 0;\n    tmp_mul      = 1;\n    tmp_stream   = 0;\n    tmp_head_idx = 0;\n    for (i = 0; i < 256;) {\n        int tmp_flags  = ffio_read_varlen(bc);\n        int tmp_fields = ffio_read_varlen(bc);\n\n        if (tmp_fields > 0)\n            tmp_pts = get_s(bc);\n        if (tmp_fields > 1)\n            tmp_mul = ffio_read_varlen(bc);\n        if (tmp_fields > 2)\n            tmp_stream = ffio_read_varlen(bc);\n        if (tmp_fields > 3)\n            tmp_size = ffio_read_varlen(bc);\n        else\n            tmp_size = 0;\n        if (tmp_fields > 4)\n            tmp_res = ffio_read_varlen(bc);\n        else\n            tmp_res = 0;\n        if (tmp_fields > 5)\n            count = ffio_read_varlen(bc);\n        else\n            count = tmp_mul - (unsigned)tmp_size;\n        if (tmp_fields > 6)\n            get_s(bc);\n        if (tmp_fields > 7)\n            tmp_head_idx = ffio_read_varlen(bc);\n\n        while (tmp_fields-- > 8) {\n            if (bc->eof_reached) {\n                av_log(s, AV_LOG_ERROR, \"reached EOF while decoding main header\\n\");\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n            ffio_read_varlen(bc);\n        }\n\n        if (count <= 0 || count > 256 - (i <= 'N') - i) {\n            av_log(s, AV_LOG_ERROR, \"illegal count %d at %d\\n\", count, i);\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n        if (tmp_stream >= stream_count) {\n            av_log(s, AV_LOG_ERROR, \"illegal stream number %d >= %d\\n\",\n                   tmp_stream, stream_count);\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n        if (tmp_size < 0 || tmp_size > INT_MAX - count) {\n            av_log(s, AV_LOG_ERROR, \"illegal size\\n\");\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n\n        for (j = 0; j < count; j++, i++) {\n            if (i == 'N') {\n                nut->frame_code[i].flags = FLAG_INVALID;\n                j--;\n                continue;\n            }\n            nut->frame_code[i].flags          = tmp_flags;\n            nut->frame_code[i].pts_delta      = tmp_pts;\n            nut->frame_code[i].stream_id      = tmp_stream;\n            nut->frame_code[i].size_mul       = tmp_mul;\n            nut->frame_code[i].size_lsb       = tmp_size + j;\n            nut->frame_code[i].reserved_count = tmp_res;\n            nut->frame_code[i].header_idx     = tmp_head_idx;\n        }\n    }\n    av_assert0(nut->frame_code['N'].flags == FLAG_INVALID);\n\n    if (end > avio_tell(bc) + 4) {\n        int rem = 1024;\n        GET_V(nut->header_count, tmp < 128U);\n        nut->header_count++;\n        for (i = 1; i < nut->header_count; i++) {\n            uint8_t *hdr;\n            GET_V(nut->header_len[i], tmp > 0 && tmp < 256);\n            if (rem < nut->header_len[i]) {\n                av_log(s, AV_LOG_ERROR,\n                       \"invalid elision header %d : %d > %d\\n\",\n                       i, nut->header_len[i], rem);\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n            rem -= nut->header_len[i];\n            hdr = av_malloc(nut->header_len[i]);\n            if (!hdr) {\n                ret = AVERROR(ENOMEM);\n                goto fail;\n            }\n            avio_read(bc, hdr, nut->header_len[i]);\n            nut->header[i] = hdr;\n        }\n        av_assert0(nut->header_len[0] == 0);\n    }\n\n    // flags had been effectively introduced in version 4\n    if (nut->version > 3 && end > avio_tell(bc) + 4) {\n        nut->flags = ffio_read_varlen(bc);\n    }\n\n    if (skip_reserved(bc, end) || ffio_get_checksum(bc)) {\n        av_log(s, AV_LOG_ERROR, \"main header checksum mismatch\\n\");\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n\n    nut->stream = av_calloc(stream_count, sizeof(StreamContext));\n    if (!nut->stream) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n    for (i = 0; i < stream_count; i++) {\n        if (!avformat_new_stream(s, NULL)) {\n            ret = AVERROR(ENOMEM);\n            goto fail;\n        }\n    }\n\n    return 0;\nfail:\n    av_freep(&nut->time_base);\n    for (i = 1; i < nut->header_count; i++) {\n        av_freep(&nut->header[i]);\n    }\n    nut->header_count = 0;\n    return ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 807,
    "critical_vars": [
      "ret"
    ],
    "function": "nut_read_header",
    "filename": "FFmpeg/CVE-2022-3341/CVE-2022-3341_CWE-476_9cf652cef49d74afe3d454f27d49eb1a1394951e_nutdec.c.diff",
    "function_code": "static int nut_read_header(AVFormatContext *s)\n{\n    NUTContext *nut = s->priv_data;\n    AVIOContext *bc = s->pb;\n    int64_t pos;\n    int initialized_stream_count, ret;\n\n    nut->avf = s;\n\n    /* main header */\n    pos = 0;\n    ret = 0;\n    do {\n        if (ret == AVERROR(ENOMEM))\n            return ret;\n\n        pos = find_startcode(bc, MAIN_STARTCODE, pos) + 1;\n        if (pos < 0 + 1) {\n            av_log(s, AV_LOG_ERROR, \"No main startcode found.\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n    } while ((ret = decode_main_header(nut)) < 0);\n\n    /* stream headers */\n    pos = 0;\n    for (initialized_stream_count = 0; initialized_stream_count < s->nb_streams;) {\n        pos = find_startcode(bc, STREAM_STARTCODE, pos) + 1;\n        if (pos < 0 + 1) {\n            av_log(s, AV_LOG_ERROR, \"Not all stream headers found.\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        if (decode_stream_header(nut) >= 0)\n            initialized_stream_count++;\n    }\n\n    /* info headers */\n    pos = 0;\n    for (;;) {\n        uint64_t startcode = find_any_startcode(bc, pos);\n        pos = avio_tell(bc);\n\n        if (startcode == 0) {\n            av_log(s, AV_LOG_ERROR, \"EOF before video frames\\n\");\n            return AVERROR_INVALIDDATA;\n        } else if (startcode == SYNCPOINT_STARTCODE) {\n            nut->next_startcode = startcode;\n            break;\n        } else if (startcode != INFO_STARTCODE) {\n            continue;\n        }\n\n        decode_info_header(nut);\n    }\n\n    ffformatcontext(s)->data_offset = pos - 8;\n\n    if (bc->seekable & AVIO_SEEKABLE_NORMAL) {\n        int64_t orig_pos = avio_tell(bc);\n        find_and_decode_index(nut);\n        avio_seek(bc, orig_pos, SEEK_SET);\n    }\n    av_assert0(nut->next_startcode == SYNCPOINT_STARTCODE);\n\n    ff_metadata_conv_ctx(s, NULL, ff_nut_metadata_conv);\n\n    return 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "while-Condition",
    "line_old": 815,
    "critical_vars": [
      "nut"
    ],
    "function": "nut_read_header",
    "filename": "FFmpeg/CVE-2022-3341/CVE-2022-3341_CWE-476_9cf652cef49d74afe3d454f27d49eb1a1394951e_nutdec.c.diff",
    "function_code": "static int nut_read_header(AVFormatContext *s)\n{\n    NUTContext *nut = s->priv_data;\n    AVIOContext *bc = s->pb;\n    int64_t pos;\n    int initialized_stream_count;\n\n    nut->avf = s;\n\n    /* main header */\n    pos = 0;\n    do {\n        pos = find_startcode(bc, MAIN_STARTCODE, pos) + 1;\n        if (pos < 0 + 1) {\n            av_log(s, AV_LOG_ERROR, \"No main startcode found.\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n    } while (decode_main_header(nut) < 0);\n\n    /* stream headers */\n    pos = 0;\n    for (initialized_stream_count = 0; initialized_stream_count < s->nb_streams;) {\n        pos = find_startcode(bc, STREAM_STARTCODE, pos) + 1;\n        if (pos < 0 + 1) {\n            av_log(s, AV_LOG_ERROR, \"Not all stream headers found.\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        if (decode_stream_header(nut) >= 0)\n            initialized_stream_count++;\n    }\n\n    /* info headers */\n    pos = 0;\n    for (;;) {\n        uint64_t startcode = find_any_startcode(bc, pos);\n        pos = avio_tell(bc);\n\n        if (startcode == 0) {\n            av_log(s, AV_LOG_ERROR, \"EOF before video frames\\n\");\n            return AVERROR_INVALIDDATA;\n        } else if (startcode == SYNCPOINT_STARTCODE) {\n            nut->next_startcode = startcode;\n            break;\n        } else if (startcode != INFO_STARTCODE) {\n            continue;\n        }\n\n        decode_info_header(nut);\n    }\n\n    ffformatcontext(s)->data_offset = pos - 8;\n\n    if (bc->seekable & AVIO_SEEKABLE_NORMAL) {\n        int64_t orig_pos = avio_tell(bc);\n        find_and_decode_index(nut);\n        avio_seek(bc, orig_pos, SEEK_SET);\n    }\n    av_assert0(nut->next_startcode == SYNCPOINT_STARTCODE);\n\n    ff_metadata_conv_ctx(s, NULL, ff_nut_metadata_conv);\n\n    return 0;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 261,
    "critical_vars": [
      "avctx->profile",
      "avctx->codec_id"
    ],
    "function": "ff_idctdsp_init",
    "filename": "FFmpeg/CVE-2018-12460/CVE-2018-12460_CWE-476_b3332a182f8ba33a34542e4a0370f38b914ccf7d_idctdsp.c.diff",
    "function_code": "av_cold void ff_idctdsp_init(IDCTDSPContext *c, AVCodecContext *avctx)\n{\n    const unsigned high_bit_depth = avctx->bits_per_raw_sample > 8;\n\n    if (avctx->lowres==1) {\n        c->idct_put  = ff_jref_idct4_put;\n        c->idct_add  = ff_jref_idct4_add;\n        c->idct      = ff_j_rev_dct4;\n        c->perm_type = FF_IDCT_PERM_NONE;\n    } else if (avctx->lowres==2) {\n        c->idct_put  = ff_jref_idct2_put;\n        c->idct_add  = ff_jref_idct2_add;\n        c->idct      = ff_j_rev_dct2;\n        c->perm_type = FF_IDCT_PERM_NONE;\n    } else if (avctx->lowres==3) {\n        c->idct_put  = ff_jref_idct1_put;\n        c->idct_add  = ff_jref_idct1_add;\n        c->idct      = ff_j_rev_dct1;\n        c->perm_type = FF_IDCT_PERM_NONE;\n    } else {\n        if (avctx->bits_per_raw_sample == 10 || avctx->bits_per_raw_sample == 9) {\n            /* 10-bit MPEG-4 Simple Studio Profile requires a higher precision IDCT\n               However, it only uses idct_put */\n            if (avctx->codec_id == AV_CODEC_ID_MPEG4 && avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO)\n                c->idct_put              = ff_simple_idct_put_int32_10bit;\n            else {\n                c->idct_put              = ff_simple_idct_put_int16_10bit;\n                c->idct_add              = ff_simple_idct_add_int16_10bit;\n                c->idct                  = ff_simple_idct_int16_10bit;\n            }\n            c->perm_type             = FF_IDCT_PERM_NONE;\n        } else if (avctx->bits_per_raw_sample == 12) {\n            c->idct_put              = ff_simple_idct_put_int16_12bit;\n            c->idct_add              = ff_simple_idct_add_int16_12bit;\n            c->idct                  = ff_simple_idct_int16_12bit;\n            c->perm_type             = FF_IDCT_PERM_NONE;\n        } else {\n            if (avctx->idct_algo == FF_IDCT_INT) {\n                c->idct_put  = ff_jref_idct_put;\n                c->idct_add  = ff_jref_idct_add;\n                c->idct      = ff_j_rev_dct;\n                c->perm_type = FF_IDCT_PERM_LIBMPEG2;\n#if CONFIG_FAANIDCT\n            } else if (avctx->idct_algo == FF_IDCT_FAAN) {\n                c->idct_put  = ff_faanidct_put;\n                c->idct_add  = ff_faanidct_add;\n                c->idct      = ff_faanidct;\n                c->perm_type = FF_IDCT_PERM_NONE;\n#endif /* CONFIG_FAANIDCT */\n            } else { // accurate/default\n                /* Be sure FF_IDCT_NONE will select this one, since it uses FF_IDCT_PERM_NONE */\n                c->idct_put  = ff_simple_idct_put_int16_8bit;\n                c->idct_add  = ff_simple_idct_add_int16_8bit;\n                c->idct      = ff_simple_idct_int16_8bit;\n                c->perm_type = FF_IDCT_PERM_NONE;\n            }\n        }\n    }\n\n    c->put_pixels_clamped        = ff_put_pixels_clamped_c;\n    c->put_signed_pixels_clamped = put_signed_pixels_clamped_c;\n    c->add_pixels_clamped        = ff_add_pixels_clamped_c;\n\n    if (CONFIG_MPEG4_DECODER && avctx->idct_algo == FF_IDCT_XVID)\n        ff_xvid_idct_init(c, avctx);\n\n    if (ARCH_AARCH64)\n        ff_idctdsp_init_aarch64(c, avctx, high_bit_depth);\n    if (ARCH_ALPHA)\n        ff_idctdsp_init_alpha(c, avctx, high_bit_depth);\n    if (ARCH_ARM)\n        ff_idctdsp_init_arm(c, avctx, high_bit_depth);\n    if (ARCH_PPC)\n        ff_idctdsp_init_ppc(c, avctx, high_bit_depth);\n    if (ARCH_X86)\n        ff_idctdsp_init_x86(c, avctx, high_bit_depth);\n    if (ARCH_MIPS)\n        ff_idctdsp_init_mips(c, avctx, high_bit_depth);\n\n    ff_init_scantable_permutation(c->idct_permutation,\n                                  c->perm_type);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 261,
    "critical_vars": [
      "c->mpeg4_studio_profile"
    ],
    "function": "ff_idctdsp_init",
    "filename": "FFmpeg/CVE-2018-12460/CVE-2018-12460_CWE-476_b3332a182f8ba33a34542e4a0370f38b914ccf7d_idctdsp.c.diff",
    "function_code": "av_cold void ff_idctdsp_init(IDCTDSPContext *c, AVCodecContext *avctx)\n{\n    const unsigned high_bit_depth = avctx->bits_per_raw_sample > 8;\n\n    if (avctx->lowres==1) {\n        c->idct_put  = ff_jref_idct4_put;\n        c->idct_add  = ff_jref_idct4_add;\n        c->idct      = ff_j_rev_dct4;\n        c->perm_type = FF_IDCT_PERM_NONE;\n    } else if (avctx->lowres==2) {\n        c->idct_put  = ff_jref_idct2_put;\n        c->idct_add  = ff_jref_idct2_add;\n        c->idct      = ff_j_rev_dct2;\n        c->perm_type = FF_IDCT_PERM_NONE;\n    } else if (avctx->lowres==3) {\n        c->idct_put  = ff_jref_idct1_put;\n        c->idct_add  = ff_jref_idct1_add;\n        c->idct      = ff_j_rev_dct1;\n        c->perm_type = FF_IDCT_PERM_NONE;\n    } else {\n        if (avctx->bits_per_raw_sample == 10 || avctx->bits_per_raw_sample == 9) {\n            /* 10-bit MPEG-4 Simple Studio Profile requires a higher precision IDCT\n               However, it only uses idct_put */\n            if (c->mpeg4_studio_profile)\n                c->idct_put              = ff_simple_idct_put_int32_10bit;\n            else {\n                c->idct_put              = ff_simple_idct_put_int16_10bit;\n                c->idct_add              = ff_simple_idct_add_int16_10bit;\n                c->idct                  = ff_simple_idct_int16_10bit;\n            }\n            c->perm_type             = FF_IDCT_PERM_NONE;\n        } else if (avctx->bits_per_raw_sample == 12) {\n            c->idct_put              = ff_simple_idct_put_int16_12bit;\n            c->idct_add              = ff_simple_idct_add_int16_12bit;\n            c->idct                  = ff_simple_idct_int16_12bit;\n            c->perm_type             = FF_IDCT_PERM_NONE;\n        } else {\n            if (avctx->idct_algo == FF_IDCT_INT) {\n                c->idct_put  = ff_jref_idct_put;\n                c->idct_add  = ff_jref_idct_add;\n                c->idct      = ff_j_rev_dct;\n                c->perm_type = FF_IDCT_PERM_LIBMPEG2;\n#if CONFIG_FAANIDCT\n            } else if (avctx->idct_algo == FF_IDCT_FAAN) {\n                c->idct_put  = ff_faanidct_put;\n                c->idct_add  = ff_faanidct_add;\n                c->idct      = ff_faanidct;\n                c->perm_type = FF_IDCT_PERM_NONE;\n#endif /* CONFIG_FAANIDCT */\n            } else { // accurate/default\n                /* Be sure FF_IDCT_NONE will select this one, since it uses FF_IDCT_PERM_NONE */\n                c->idct_put  = ff_simple_idct_put_int16_8bit;\n                c->idct_add  = ff_simple_idct_add_int16_8bit;\n                c->idct      = ff_simple_idct_int16_8bit;\n                c->perm_type = FF_IDCT_PERM_NONE;\n            }\n        }\n    }\n\n    c->put_pixels_clamped        = ff_put_pixels_clamped_c;\n    c->put_signed_pixels_clamped = put_signed_pixels_clamped_c;\n    c->add_pixels_clamped        = ff_add_pixels_clamped_c;\n\n    if (CONFIG_MPEG4_DECODER && avctx->idct_algo == FF_IDCT_XVID)\n        ff_xvid_idct_init(c, avctx);\n\n    if (ARCH_AARCH64)\n        ff_idctdsp_init_aarch64(c, avctx, high_bit_depth);\n    if (ARCH_ALPHA)\n        ff_idctdsp_init_alpha(c, avctx, high_bit_depth);\n    if (ARCH_ARM)\n        ff_idctdsp_init_arm(c, avctx, high_bit_depth);\n    if (ARCH_PPC)\n        ff_idctdsp_init_ppc(c, avctx, high_bit_depth);\n    if (ARCH_X86)\n        ff_idctdsp_init_x86(c, avctx, high_bit_depth);\n    if (ARCH_MIPS)\n        ff_idctdsp_init_mips(c, avctx, high_bit_depth);\n\n    ff_init_scantable_permutation(c->idct_permutation,\n                                  c->perm_type);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 491,
    "critical_vars": [
      "sh->first_slice_in_pic_flag",
      "s->ref"
    ],
    "function": "hls_slice_header",
    "filename": "FFmpeg/CVE-2019-11338/CVE-2019-11338_CWE-476_54655623a82632e7624714d7b2a3e039dc5faa7e_hevcdec.c.diff",
    "function_code": "static int hls_slice_header(HEVCContext *s)\n{\n    GetBitContext *gb = &s->HEVClc->gb;\n    SliceHeader *sh   = &s->sh;\n    int i, ret;\n\n    // Coded parameters\n    sh->first_slice_in_pic_flag = get_bits1(gb);\n    if (s->ref && sh->first_slice_in_pic_flag) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Two slices reporting being the first in the same frame.\\n\");\n        return 1; // This slice will be skiped later, do not corrupt state\n    }\n\n    if ((IS_IDR(s) || IS_BLA(s)) && sh->first_slice_in_pic_flag) {\n        s->seq_decode = (s->seq_decode + 1) & 0xff;\n        s->max_ra     = INT_MAX;\n        if (IS_IDR(s))\n            ff_hevc_clear_refs(s);\n    }\n    sh->no_output_of_prior_pics_flag = 0;\n    if (IS_IRAP(s))\n        sh->no_output_of_prior_pics_flag = get_bits1(gb);\n\n    sh->pps_id = get_ue_golomb_long(gb);\n    if (sh->pps_id >= HEVC_MAX_PPS_COUNT || !s->ps.pps_list[sh->pps_id]) {\n        av_log(s->avctx, AV_LOG_ERROR, \"PPS id out of range: %d\\n\", sh->pps_id);\n        return AVERROR_INVALIDDATA;\n    }\n    if (!sh->first_slice_in_pic_flag &&\n        s->ps.pps != (HEVCPPS*)s->ps.pps_list[sh->pps_id]->data) {\n        av_log(s->avctx, AV_LOG_ERROR, \"PPS changed between slices.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    s->ps.pps = (HEVCPPS*)s->ps.pps_list[sh->pps_id]->data;\n    if (s->nal_unit_type == HEVC_NAL_CRA_NUT && s->last_eos == 1)\n        sh->no_output_of_prior_pics_flag = 1;\n\n    if (s->ps.sps != (HEVCSPS*)s->ps.sps_list[s->ps.pps->sps_id]->data) {\n        const HEVCSPS *sps = (HEVCSPS*)s->ps.sps_list[s->ps.pps->sps_id]->data;\n        const HEVCSPS *last_sps = s->ps.sps;\n        enum AVPixelFormat pix_fmt;\n\n        if (last_sps && IS_IRAP(s) && s->nal_unit_type != HEVC_NAL_CRA_NUT) {\n            if (sps->width != last_sps->width || sps->height != last_sps->height ||\n                sps->temporal_layer[sps->max_sub_layers - 1].max_dec_pic_buffering !=\n                last_sps->temporal_layer[last_sps->max_sub_layers - 1].max_dec_pic_buffering)\n                sh->no_output_of_prior_pics_flag = 0;\n        }\n        ff_hevc_clear_refs(s);\n\n        ret = set_sps(s, sps, sps->pix_fmt);\n        if (ret < 0)\n            return ret;\n\n        pix_fmt = get_format(s, sps);\n        if (pix_fmt < 0)\n            return pix_fmt;\n        s->avctx->pix_fmt = pix_fmt;\n\n        s->seq_decode = (s->seq_decode + 1) & 0xff;\n        s->max_ra     = INT_MAX;\n    }\n\n    sh->dependent_slice_segment_flag = 0;\n    if (!sh->first_slice_in_pic_flag) {\n        int slice_address_length;\n\n        if (s->ps.pps->dependent_slice_segments_enabled_flag)\n            sh->dependent_slice_segment_flag = get_bits1(gb);\n\n        slice_address_length = av_ceil_log2(s->ps.sps->ctb_width *\n                                            s->ps.sps->ctb_height);\n        sh->slice_segment_addr = get_bitsz(gb, slice_address_length);\n        if (sh->slice_segment_addr >= s->ps.sps->ctb_width * s->ps.sps->ctb_height) {\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"Invalid slice segment address: %u.\\n\",\n                   sh->slice_segment_addr);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (!sh->dependent_slice_segment_flag) {\n            sh->slice_addr = sh->slice_segment_addr;\n            s->slice_idx++;\n        }\n    } else {\n        sh->slice_segment_addr = sh->slice_addr = 0;\n        s->slice_idx           = 0;\n        s->slice_initialized   = 0;\n    }\n\n    if (!sh->dependent_slice_segment_flag) {\n        s->slice_initialized = 0;\n\n        for (i = 0; i < s->ps.pps->num_extra_slice_header_bits; i++)\n            skip_bits(gb, 1);  // slice_reserved_undetermined_flag[]\n\n        sh->slice_type = get_ue_golomb_long(gb);\n        if (!(sh->slice_type == HEVC_SLICE_I ||\n              sh->slice_type == HEVC_SLICE_P ||\n              sh->slice_type == HEVC_SLICE_B)) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Unknown slice type: %d.\\n\",\n                   sh->slice_type);\n            return AVERROR_INVALIDDATA;\n        }\n        if (IS_IRAP(s) && sh->slice_type != HEVC_SLICE_I) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Inter slices in an IRAP frame.\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n\n        // when flag is not present, picture is inferred to be output\n        sh->pic_output_flag = 1;\n        if (s->ps.pps->output_flag_present_flag)\n            sh->pic_output_flag = get_bits1(gb);\n\n        if (s->ps.sps->separate_colour_plane_flag)\n            sh->colour_plane_id = get_bits(gb, 2);\n\n        if (!IS_IDR(s)) {\n            int poc, pos;\n\n            sh->pic_order_cnt_lsb = get_bits(gb, s->ps.sps->log2_max_poc_lsb);\n            poc = ff_hevc_compute_poc(s->ps.sps, s->pocTid0, sh->pic_order_cnt_lsb, s->nal_unit_type);\n            if (!sh->first_slice_in_pic_flag && poc != s->poc) {\n                av_log(s->avctx, AV_LOG_WARNING,\n                       \"Ignoring POC change between slices: %d -> %d\\n\", s->poc, poc);\n                if (s->avctx->err_recognition & AV_EF_EXPLODE)\n                    return AVERROR_INVALIDDATA;\n                poc = s->poc;\n            }\n            s->poc = poc;\n\n            sh->short_term_ref_pic_set_sps_flag = get_bits1(gb);\n            pos = get_bits_left(gb);\n            if (!sh->short_term_ref_pic_set_sps_flag) {\n                ret = ff_hevc_decode_short_term_rps(gb, s->avctx, &sh->slice_rps, s->ps.sps, 1);\n                if (ret < 0)\n                    return ret;\n\n                sh->short_term_rps = &sh->slice_rps;\n            } else {\n                int numbits, rps_idx;\n\n                if (!s->ps.sps->nb_st_rps) {\n                    av_log(s->avctx, AV_LOG_ERROR, \"No ref lists in the SPS.\\n\");\n                    return AVERROR_INVALIDDATA;\n                }\n\n                numbits = av_ceil_log2(s->ps.sps->nb_st_rps);\n                rps_idx = numbits > 0 ? get_bits(gb, numbits) : 0;\n                sh->short_term_rps = &s->ps.sps->st_rps[rps_idx];\n            }\n            sh->short_term_ref_pic_set_size = pos - get_bits_left(gb);\n\n            pos = get_bits_left(gb);\n            ret = decode_lt_rps(s, &sh->long_term_rps, gb);\n            if (ret < 0) {\n                av_log(s->avctx, AV_LOG_WARNING, \"Invalid long term RPS.\\n\");\n                if (s->avctx->err_recognition & AV_EF_EXPLODE)\n                    return AVERROR_INVALIDDATA;\n            }\n            sh->long_term_ref_pic_set_size = pos - get_bits_left(gb);\n\n            if (s->ps.sps->sps_temporal_mvp_enabled_flag)\n                sh->slice_temporal_mvp_enabled_flag = get_bits1(gb);\n            else\n                sh->slice_temporal_mvp_enabled_flag = 0;\n        } else {\n            s->sh.short_term_rps = NULL;\n            s->poc               = 0;\n        }\n\n        /* 8.3.1 */\n        if (sh->first_slice_in_pic_flag && s->temporal_id == 0 &&\n            s->nal_unit_type != HEVC_NAL_TRAIL_N &&\n            s->nal_unit_type != HEVC_NAL_TSA_N   &&\n            s->nal_unit_type != HEVC_NAL_STSA_N  &&\n            s->nal_unit_type != HEVC_NAL_RADL_N  &&\n            s->nal_unit_type != HEVC_NAL_RADL_R  &&\n            s->nal_unit_type != HEVC_NAL_RASL_N  &&\n            s->nal_unit_type != HEVC_NAL_RASL_R)\n            s->pocTid0 = s->poc;\n\n        if (s->ps.sps->sao_enabled) {\n            sh->slice_sample_adaptive_offset_flag[0] = get_bits1(gb);\n            if (s->ps.sps->chroma_format_idc) {\n                sh->slice_sample_adaptive_offset_flag[1] =\n                sh->slice_sample_adaptive_offset_flag[2] = get_bits1(gb);\n            }\n        } else {\n            sh->slice_sample_adaptive_offset_flag[0] = 0;\n            sh->slice_sample_adaptive_offset_flag[1] = 0;\n            sh->slice_sample_adaptive_offset_flag[2] = 0;\n        }\n\n        sh->nb_refs[L0] = sh->nb_refs[L1] = 0;\n        if (sh->slice_type == HEVC_SLICE_P || sh->slice_type == HEVC_SLICE_B) {\n            int nb_refs;\n\n            sh->nb_refs[L0] = s->ps.pps->num_ref_idx_l0_default_active;\n            if (sh->slice_type == HEVC_SLICE_B)\n                sh->nb_refs[L1] = s->ps.pps->num_ref_idx_l1_default_active;\n\n            if (get_bits1(gb)) { // num_ref_idx_active_override_flag\n                sh->nb_refs[L0] = get_ue_golomb_long(gb) + 1;\n                if (sh->slice_type == HEVC_SLICE_B)\n                    sh->nb_refs[L1] = get_ue_golomb_long(gb) + 1;\n            }\n            if (sh->nb_refs[L0] > HEVC_MAX_REFS || sh->nb_refs[L1] > HEVC_MAX_REFS) {\n                av_log(s->avctx, AV_LOG_ERROR, \"Too many refs: %d/%d.\\n\",\n                       sh->nb_refs[L0], sh->nb_refs[L1]);\n                return AVERROR_INVALIDDATA;\n            }\n\n            sh->rpl_modification_flag[0] = 0;\n            sh->rpl_modification_flag[1] = 0;\n            nb_refs = ff_hevc_frame_nb_refs(s);\n            if (!nb_refs) {\n                av_log(s->avctx, AV_LOG_ERROR, \"Zero refs for a frame with P or B slices.\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n\n            if (s->ps.pps->lists_modification_present_flag && nb_refs > 1) {\n                sh->rpl_modification_flag[0] = get_bits1(gb);\n                if (sh->rpl_modification_flag[0]) {\n                    for (i = 0; i < sh->nb_refs[L0]; i++)\n                        sh->list_entry_lx[0][i] = get_bits(gb, av_ceil_log2(nb_refs));\n                }\n\n                if (sh->slice_type == HEVC_SLICE_B) {\n                    sh->rpl_modification_flag[1] = get_bits1(gb);\n                    if (sh->rpl_modification_flag[1] == 1)\n                        for (i = 0; i < sh->nb_refs[L1]; i++)\n                            sh->list_entry_lx[1][i] = get_bits(gb, av_ceil_log2(nb_refs));\n                }\n            }\n\n            if (sh->slice_type == HEVC_SLICE_B)\n                sh->mvd_l1_zero_flag = get_bits1(gb);\n\n            if (s->ps.pps->cabac_init_present_flag)\n                sh->cabac_init_flag = get_bits1(gb);\n            else\n                sh->cabac_init_flag = 0;\n\n            sh->collocated_ref_idx = 0;\n            if (sh->slice_temporal_mvp_enabled_flag) {\n                sh->collocated_list = L0;\n                if (sh->slice_type == HEVC_SLICE_B)\n                    sh->collocated_list = !get_bits1(gb);\n\n                if (sh->nb_refs[sh->collocated_list] > 1) {\n                    sh->collocated_ref_idx = get_ue_golomb_long(gb);\n                    if (sh->collocated_ref_idx >= sh->nb_refs[sh->collocated_list]) {\n                        av_log(s->avctx, AV_LOG_ERROR,\n                               \"Invalid collocated_ref_idx: %d.\\n\",\n                               sh->collocated_ref_idx);\n                        return AVERROR_INVALIDDATA;\n                    }\n                }\n            }\n\n            if ((s->ps.pps->weighted_pred_flag   && sh->slice_type == HEVC_SLICE_P) ||\n                (s->ps.pps->weighted_bipred_flag && sh->slice_type == HEVC_SLICE_B)) {\n                int ret = pred_weight_table(s, gb);\n                if (ret < 0)\n                    return ret;\n            }\n\n            sh->max_num_merge_cand = 5 - get_ue_golomb_long(gb);\n            if (sh->max_num_merge_cand < 1 || sh->max_num_merge_cand > 5) {\n                av_log(s->avctx, AV_LOG_ERROR,\n                       \"Invalid number of merging MVP candidates: %d.\\n\",\n                       sh->max_num_merge_cand);\n                return AVERROR_INVALIDDATA;\n            }\n        }\n\n        sh->slice_qp_delta = get_se_golomb(gb);\n\n        if (s->ps.pps->pic_slice_level_chroma_qp_offsets_present_flag) {\n            sh->slice_cb_qp_offset = get_se_golomb(gb);\n            sh->slice_cr_qp_offset = get_se_golomb(gb);\n        } else {\n            sh->slice_cb_qp_offset = 0;\n            sh->slice_cr_qp_offset = 0;\n        }\n\n        if (s->ps.pps->chroma_qp_offset_list_enabled_flag)\n            sh->cu_chroma_qp_offset_enabled_flag = get_bits1(gb);\n        else\n            sh->cu_chroma_qp_offset_enabled_flag = 0;\n\n        if (s->ps.pps->deblocking_filter_control_present_flag) {\n            int deblocking_filter_override_flag = 0;\n\n            if (s->ps.pps->deblocking_filter_override_enabled_flag)\n                deblocking_filter_override_flag = get_bits1(gb);\n\n            if (deblocking_filter_override_flag) {\n                sh->disable_deblocking_filter_flag = get_bits1(gb);\n                if (!sh->disable_deblocking_filter_flag) {\n                    int beta_offset_div2 = get_se_golomb(gb);\n                    int tc_offset_div2   = get_se_golomb(gb) ;\n                    if (beta_offset_div2 < -6 || beta_offset_div2 > 6 ||\n                        tc_offset_div2   < -6 || tc_offset_div2   > 6) {\n                        av_log(s->avctx, AV_LOG_ERROR,\n                            \"Invalid deblock filter offsets: %d, %d\\n\",\n                            beta_offset_div2, tc_offset_div2);\n                        return AVERROR_INVALIDDATA;\n                    }\n                    sh->beta_offset = beta_offset_div2 * 2;\n                    sh->tc_offset   =   tc_offset_div2 * 2;\n                }\n            } else {\n                sh->disable_deblocking_filter_flag = s->ps.pps->disable_dbf;\n                sh->beta_offset                    = s->ps.pps->beta_offset;\n                sh->tc_offset                      = s->ps.pps->tc_offset;\n            }\n        } else {\n            sh->disable_deblocking_filter_flag = 0;\n            sh->beta_offset                    = 0;\n            sh->tc_offset                      = 0;\n        }\n\n        if (s->ps.pps->seq_loop_filter_across_slices_enabled_flag &&\n            (sh->slice_sample_adaptive_offset_flag[0] ||\n             sh->slice_sample_adaptive_offset_flag[1] ||\n             !sh->disable_deblocking_filter_flag)) {\n            sh->slice_loop_filter_across_slices_enabled_flag = get_bits1(gb);\n        } else {\n            sh->slice_loop_filter_across_slices_enabled_flag = s->ps.pps->seq_loop_filter_across_slices_enabled_flag;\n        }\n    } else if (!s->slice_initialized) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Independent slice segment missing.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    sh->num_entry_point_offsets = 0;\n    if (s->ps.pps->tiles_enabled_flag || s->ps.pps->entropy_coding_sync_enabled_flag) {\n        unsigned num_entry_point_offsets = get_ue_golomb_long(gb);\n        // It would be possible to bound this tighter but this here is simpler\n        if (num_entry_point_offsets > get_bits_left(gb)) {\n            av_log(s->avctx, AV_LOG_ERROR, \"num_entry_point_offsets %d is invalid\\n\", num_entry_point_offsets);\n            return AVERROR_INVALIDDATA;\n        }\n\n        sh->num_entry_point_offsets = num_entry_point_offsets;\n        if (sh->num_entry_point_offsets > 0) {\n            int offset_len = get_ue_golomb_long(gb) + 1;\n\n            if (offset_len < 1 || offset_len > 32) {\n                sh->num_entry_point_offsets = 0;\n                av_log(s->avctx, AV_LOG_ERROR, \"offset_len %d is invalid\\n\", offset_len);\n                return AVERROR_INVALIDDATA;\n            }\n\n            av_freep(&sh->entry_point_offset);\n            av_freep(&sh->offset);\n            av_freep(&sh->size);\n            sh->entry_point_offset = av_malloc_array(sh->num_entry_point_offsets, sizeof(unsigned));\n            sh->offset = av_malloc_array(sh->num_entry_point_offsets, sizeof(int));\n            sh->size = av_malloc_array(sh->num_entry_point_offsets, sizeof(int));\n            if (!sh->entry_point_offset || !sh->offset || !sh->size) {\n                sh->num_entry_point_offsets = 0;\n                av_log(s->avctx, AV_LOG_ERROR, \"Failed to allocate memory\\n\");\n                return AVERROR(ENOMEM);\n            }\n            for (i = 0; i < sh->num_entry_point_offsets; i++) {\n                unsigned val = get_bits_long(gb, offset_len);\n                sh->entry_point_offset[i] = val + 1; // +1; // +1 to get the size\n            }\n            if (s->threads_number > 1 && (s->ps.pps->num_tile_rows > 1 || s->ps.pps->num_tile_columns > 1)) {\n                s->enable_parallel_tiles = 0; // TODO: you can enable tiles in parallel here\n                s->threads_number = 1;\n            } else\n                s->enable_parallel_tiles = 0;\n        } else\n            s->enable_parallel_tiles = 0;\n    }\n\n    if (s->ps.pps->slice_header_extension_present_flag) {\n        unsigned int length = get_ue_golomb_long(gb);\n        if (length*8LL > get_bits_left(gb)) {\n            av_log(s->avctx, AV_LOG_ERROR, \"too many slice_header_extension_data_bytes\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        for (i = 0; i < length; i++)\n            skip_bits(gb, 8);  // slice_header_extension_data_byte\n    }\n\n    // Inferred parameters\n    sh->slice_qp = 26U + s->ps.pps->pic_init_qp_minus26 + sh->slice_qp_delta;\n    if (sh->slice_qp > 51 ||\n        sh->slice_qp < -s->ps.sps->qp_bd_offset) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"The slice_qp %d is outside the valid range \"\n               \"[%d, 51].\\n\",\n               sh->slice_qp,\n               -s->ps.sps->qp_bd_offset);\n        return AVERROR_INVALIDDATA;\n    }\n\n    sh->slice_ctb_addr_rs = sh->slice_segment_addr;\n\n    if (!s->sh.slice_ctb_addr_rs && s->sh.dependent_slice_segment_flag) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Impossible slice segment.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (get_bits_left(gb) < 0) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"Overread slice header by %d bits\\n\", -get_bits_left(gb));\n        return AVERROR_INVALIDDATA;\n    }\n\n    s->HEVClc->first_qp_group = !s->sh.dependent_slice_segment_flag;\n\n    if (!s->ps.pps->cu_qp_delta_enabled_flag)\n        s->HEVClc->qp_y = s->sh.slice_qp;\n\n    s->slice_initialized = 1;\n    s->HEVClc->tu.cu_qp_offset_cb = 0;\n    s->HEVClc->tu.cu_qp_offset_cr = 0;\n\n    return 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 2926,
    "critical_vars": [
      "ret"
    ],
    "function": "decode_nal_unit",
    "filename": "FFmpeg/CVE-2019-11338/CVE-2019-11338_CWE-476_54655623a82632e7624714d7b2a3e039dc5faa7e_hevcdec.c.diff",
    "function_code": "static int decode_nal_unit(HEVCContext *s, const H2645NAL *nal)\n{\n    HEVCLocalContext *lc = s->HEVClc;\n    GetBitContext *gb    = &lc->gb;\n    int ctb_addr_ts, ret;\n\n    *gb              = nal->gb;\n    s->nal_unit_type = nal->type;\n    s->temporal_id   = nal->temporal_id;\n\n    switch (s->nal_unit_type) {\n    case HEVC_NAL_VPS:\n        if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {\n            ret = s->avctx->hwaccel->decode_params(s->avctx,\n                                                   nal->type,\n                                                   nal->raw_data,\n                                                   nal->raw_size);\n            if (ret < 0)\n                goto fail;\n        }\n        ret = ff_hevc_decode_nal_vps(gb, s->avctx, &s->ps);\n        if (ret < 0)\n            goto fail;\n        break;\n    case HEVC_NAL_SPS:\n        if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {\n            ret = s->avctx->hwaccel->decode_params(s->avctx,\n                                                   nal->type,\n                                                   nal->raw_data,\n                                                   nal->raw_size);\n            if (ret < 0)\n                goto fail;\n        }\n        ret = ff_hevc_decode_nal_sps(gb, s->avctx, &s->ps,\n                                     s->apply_defdispwin);\n        if (ret < 0)\n            goto fail;\n        break;\n    case HEVC_NAL_PPS:\n        if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {\n            ret = s->avctx->hwaccel->decode_params(s->avctx,\n                                                   nal->type,\n                                                   nal->raw_data,\n                                                   nal->raw_size);\n            if (ret < 0)\n                goto fail;\n        }\n        ret = ff_hevc_decode_nal_pps(gb, s->avctx, &s->ps);\n        if (ret < 0)\n            goto fail;\n        break;\n    case HEVC_NAL_SEI_PREFIX:\n    case HEVC_NAL_SEI_SUFFIX:\n        if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {\n            ret = s->avctx->hwaccel->decode_params(s->avctx,\n                                                   nal->type,\n                                                   nal->raw_data,\n                                                   nal->raw_size);\n            if (ret < 0)\n                goto fail;\n        }\n        ret = ff_hevc_decode_nal_sei(gb, s->avctx, &s->sei, &s->ps, s->nal_unit_type);\n        if (ret < 0)\n            goto fail;\n        break;\n    case HEVC_NAL_TRAIL_R:\n    case HEVC_NAL_TRAIL_N:\n    case HEVC_NAL_TSA_N:\n    case HEVC_NAL_TSA_R:\n    case HEVC_NAL_STSA_N:\n    case HEVC_NAL_STSA_R:\n    case HEVC_NAL_BLA_W_LP:\n    case HEVC_NAL_BLA_W_RADL:\n    case HEVC_NAL_BLA_N_LP:\n    case HEVC_NAL_IDR_W_RADL:\n    case HEVC_NAL_IDR_N_LP:\n    case HEVC_NAL_CRA_NUT:\n    case HEVC_NAL_RADL_N:\n    case HEVC_NAL_RADL_R:\n    case HEVC_NAL_RASL_N:\n    case HEVC_NAL_RASL_R:\n        ret = hls_slice_header(s);\n        if (ret < 0)\n            return ret;\n        if (ret == 1) {\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n\n\n        if (\n            (s->avctx->skip_frame >= AVDISCARD_BIDIR && s->sh.slice_type == HEVC_SLICE_B) ||\n            (s->avctx->skip_frame >= AVDISCARD_NONINTRA && s->sh.slice_type != HEVC_SLICE_I) ||\n            (s->avctx->skip_frame >= AVDISCARD_NONKEY && !IS_IRAP(s))) {\n            break;\n        }\n\n        if (s->sh.first_slice_in_pic_flag) {\n            if (s->max_ra == INT_MAX) {\n                if (s->nal_unit_type == HEVC_NAL_CRA_NUT || IS_BLA(s)) {\n                    s->max_ra = s->poc;\n                } else {\n                    if (IS_IDR(s))\n                        s->max_ra = INT_MIN;\n                }\n            }\n\n            if ((s->nal_unit_type == HEVC_NAL_RASL_R || s->nal_unit_type == HEVC_NAL_RASL_N) &&\n                s->poc <= s->max_ra) {\n                s->is_decoded = 0;\n                break;\n            } else {\n                if (s->nal_unit_type == HEVC_NAL_RASL_R && s->poc > s->max_ra)\n                    s->max_ra = INT_MIN;\n            }\n\n            s->overlap ++;\n            ret = hevc_frame_start(s);\n            if (ret < 0)\n                return ret;\n        } else if (!s->ref) {\n            av_log(s->avctx, AV_LOG_ERROR, \"First slice in a frame missing.\\n\");\n            goto fail;\n        }\n\n        if (s->nal_unit_type != s->first_nal_type) {\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"Non-matching NAL types of the VCL NALUs: %d %d\\n\",\n                   s->first_nal_type, s->nal_unit_type);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (!s->sh.dependent_slice_segment_flag &&\n            s->sh.slice_type != HEVC_SLICE_I) {\n            ret = ff_hevc_slice_rpl(s);\n            if (ret < 0) {\n                av_log(s->avctx, AV_LOG_WARNING,\n                       \"Error constructing the reference lists for the current slice.\\n\");\n                goto fail;\n            }\n        }\n\n        if (s->sh.first_slice_in_pic_flag && s->avctx->hwaccel) {\n            ret = s->avctx->hwaccel->start_frame(s->avctx, NULL, 0);\n            if (ret < 0)\n                goto fail;\n        }\n\n        if (s->avctx->hwaccel) {\n            ret = s->avctx->hwaccel->decode_slice(s->avctx, nal->raw_data, nal->raw_size);\n            if (ret < 0)\n                goto fail;\n        } else {\n            if (s->threads_number > 1 && s->sh.num_entry_point_offsets > 0)\n                ctb_addr_ts = hls_slice_data_wpp(s, nal);\n            else\n                ctb_addr_ts = hls_slice_data(s);\n            if (ctb_addr_ts >= (s->ps.sps->ctb_width * s->ps.sps->ctb_height)) {\n                s->is_decoded = 1;\n            }\n\n            if (ctb_addr_ts < 0) {\n                ret = ctb_addr_ts;\n                goto fail;\n            }\n        }\n        break;\n    case HEVC_NAL_EOS_NUT:\n    case HEVC_NAL_EOB_NUT:\n        s->seq_decode = (s->seq_decode + 1) & 0xff;\n        s->max_ra     = INT_MAX;\n        break;\n    case HEVC_NAL_AUD:\n    case HEVC_NAL_FD_NUT:\n        break;\n    default:\n        av_log(s->avctx, AV_LOG_INFO,\n               \"Skipping NAL unit %d\\n\", s->nal_unit_type);\n    }\n\n    return 0;\nfail:\n    if (s->avctx->err_recognition & AV_EF_EXPLODE)\n        return ret;\n    return 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 2930,
    "critical_vars": [
      "s->ref"
    ],
    "function": "decode_nal_unit",
    "filename": "FFmpeg/CVE-2019-11338/CVE-2019-11338_CWE-476_54655623a82632e7624714d7b2a3e039dc5faa7e_hevcdec.c.diff",
    "function_code": "static int decode_nal_unit(HEVCContext *s, const H2645NAL *nal)\n{\n    HEVCLocalContext *lc = s->HEVClc;\n    GetBitContext *gb    = &lc->gb;\n    int ctb_addr_ts, ret;\n\n    *gb              = nal->gb;\n    s->nal_unit_type = nal->type;\n    s->temporal_id   = nal->temporal_id;\n\n    switch (s->nal_unit_type) {\n    case HEVC_NAL_VPS:\n        if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {\n            ret = s->avctx->hwaccel->decode_params(s->avctx,\n                                                   nal->type,\n                                                   nal->raw_data,\n                                                   nal->raw_size);\n            if (ret < 0)\n                goto fail;\n        }\n        ret = ff_hevc_decode_nal_vps(gb, s->avctx, &s->ps);\n        if (ret < 0)\n            goto fail;\n        break;\n    case HEVC_NAL_SPS:\n        if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {\n            ret = s->avctx->hwaccel->decode_params(s->avctx,\n                                                   nal->type,\n                                                   nal->raw_data,\n                                                   nal->raw_size);\n            if (ret < 0)\n                goto fail;\n        }\n        ret = ff_hevc_decode_nal_sps(gb, s->avctx, &s->ps,\n                                     s->apply_defdispwin);\n        if (ret < 0)\n            goto fail;\n        break;\n    case HEVC_NAL_PPS:\n        if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {\n            ret = s->avctx->hwaccel->decode_params(s->avctx,\n                                                   nal->type,\n                                                   nal->raw_data,\n                                                   nal->raw_size);\n            if (ret < 0)\n                goto fail;\n        }\n        ret = ff_hevc_decode_nal_pps(gb, s->avctx, &s->ps);\n        if (ret < 0)\n            goto fail;\n        break;\n    case HEVC_NAL_SEI_PREFIX:\n    case HEVC_NAL_SEI_SUFFIX:\n        if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {\n            ret = s->avctx->hwaccel->decode_params(s->avctx,\n                                                   nal->type,\n                                                   nal->raw_data,\n                                                   nal->raw_size);\n            if (ret < 0)\n                goto fail;\n        }\n        ret = ff_hevc_decode_nal_sei(gb, s->avctx, &s->sei, &s->ps, s->nal_unit_type);\n        if (ret < 0)\n            goto fail;\n        break;\n    case HEVC_NAL_TRAIL_R:\n    case HEVC_NAL_TRAIL_N:\n    case HEVC_NAL_TSA_N:\n    case HEVC_NAL_TSA_R:\n    case HEVC_NAL_STSA_N:\n    case HEVC_NAL_STSA_R:\n    case HEVC_NAL_BLA_W_LP:\n    case HEVC_NAL_BLA_W_RADL:\n    case HEVC_NAL_BLA_N_LP:\n    case HEVC_NAL_IDR_W_RADL:\n    case HEVC_NAL_IDR_N_LP:\n    case HEVC_NAL_CRA_NUT:\n    case HEVC_NAL_RADL_N:\n    case HEVC_NAL_RADL_R:\n    case HEVC_NAL_RASL_N:\n    case HEVC_NAL_RASL_R:\n        ret = hls_slice_header(s);\n        if (ret < 0)\n            return ret;\n\n        if (\n            (s->avctx->skip_frame >= AVDISCARD_BIDIR && s->sh.slice_type == HEVC_SLICE_B) ||\n            (s->avctx->skip_frame >= AVDISCARD_NONINTRA && s->sh.slice_type != HEVC_SLICE_I) ||\n            (s->avctx->skip_frame >= AVDISCARD_NONKEY && !IS_IRAP(s))) {\n            break;\n        }\n\n        if (s->sh.first_slice_in_pic_flag) {\n            if (s->ref) {\n                av_log(s->avctx, AV_LOG_ERROR, \"Two slices reporting being the first in the same frame.\\n\");\n                goto fail;\n            }\n            if (s->max_ra == INT_MAX) {\n                if (s->nal_unit_type == HEVC_NAL_CRA_NUT || IS_BLA(s)) {\n                    s->max_ra = s->poc;\n                } else {\n                    if (IS_IDR(s))\n                        s->max_ra = INT_MIN;\n                }\n            }\n\n            if ((s->nal_unit_type == HEVC_NAL_RASL_R || s->nal_unit_type == HEVC_NAL_RASL_N) &&\n                s->poc <= s->max_ra) {\n                s->is_decoded = 0;\n                break;\n            } else {\n                if (s->nal_unit_type == HEVC_NAL_RASL_R && s->poc > s->max_ra)\n                    s->max_ra = INT_MIN;\n            }\n\n            s->overlap ++;\n            ret = hevc_frame_start(s);\n            if (ret < 0)\n                return ret;\n        } else if (!s->ref) {\n            av_log(s->avctx, AV_LOG_ERROR, \"First slice in a frame missing.\\n\");\n            goto fail;\n        }\n\n        if (s->nal_unit_type != s->first_nal_type) {\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"Non-matching NAL types of the VCL NALUs: %d %d\\n\",\n                   s->first_nal_type, s->nal_unit_type);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (!s->sh.dependent_slice_segment_flag &&\n            s->sh.slice_type != HEVC_SLICE_I) {\n            ret = ff_hevc_slice_rpl(s);\n            if (ret < 0) {\n                av_log(s->avctx, AV_LOG_WARNING,\n                       \"Error constructing the reference lists for the current slice.\\n\");\n                goto fail;\n            }\n        }\n\n        if (s->sh.first_slice_in_pic_flag && s->avctx->hwaccel) {\n            ret = s->avctx->hwaccel->start_frame(s->avctx, NULL, 0);\n            if (ret < 0)\n                goto fail;\n        }\n\n        if (s->avctx->hwaccel) {\n            ret = s->avctx->hwaccel->decode_slice(s->avctx, nal->raw_data, nal->raw_size);\n            if (ret < 0)\n                goto fail;\n        } else {\n            if (s->threads_number > 1 && s->sh.num_entry_point_offsets > 0)\n                ctb_addr_ts = hls_slice_data_wpp(s, nal);\n            else\n                ctb_addr_ts = hls_slice_data(s);\n            if (ctb_addr_ts >= (s->ps.sps->ctb_width * s->ps.sps->ctb_height)) {\n                s->is_decoded = 1;\n            }\n\n            if (ctb_addr_ts < 0) {\n                ret = ctb_addr_ts;\n                goto fail;\n            }\n        }\n        break;\n    case HEVC_NAL_EOS_NUT:\n    case HEVC_NAL_EOB_NUT:\n        s->seq_decode = (s->seq_decode + 1) & 0xff;\n        s->max_ra     = INT_MAX;\n        break;\n    case HEVC_NAL_AUD:\n    case HEVC_NAL_FD_NUT:\n        break;\n    default:\n        av_log(s->avctx, AV_LOG_INFO,\n               \"Skipping NAL unit %d\\n\", s->nal_unit_type);\n    }\n\n    return 0;\nfail:\n    if (s->avctx->err_recognition & AV_EF_EXPLODE)\n        return ret;\n    return 0;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 165,
    "critical_vars": [
      "size",
      "buf",
      "&gb"
    ],
    "function": "avpriv_ac3_parse_header",
    "filename": "FFmpeg/CVE-2018-13303/CVE-2018-13303_CWE-476_00e8181bd97c834fe60751b0c511d4bb97875f78_ac3_parser.c.diff",
    "function_code": "int avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *buf,\n                            size_t size)\n{\n    GetBitContext gb;\n    AC3HeaderInfo *hdr;\n    int err;\n\n    if (!*phdr)\n        *phdr = av_mallocz(sizeof(AC3HeaderInfo));\n    if (!*phdr)\n        return AVERROR(ENOMEM);\n    hdr = *phdr;\n\n    init_get_bits8(&gb, buf, size);\n    err = ff_ac3_parse_header(&gb, hdr);\n    if (err < 0)\n        return AVERROR_INVALIDDATA;\n\n    return get_bits_count(&gb);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 165,
    "critical_vars": [
      "err"
    ],
    "function": "avpriv_ac3_parse_header",
    "filename": "FFmpeg/CVE-2018-13303/CVE-2018-13303_CWE-476_00e8181bd97c834fe60751b0c511d4bb97875f78_ac3_parser.c.diff",
    "function_code": "int avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *buf,\n                            size_t size)\n{\n    GetBitContext gb;\n    AC3HeaderInfo *hdr;\n    int err;\n\n    if (!*phdr)\n        *phdr = av_mallocz(sizeof(AC3HeaderInfo));\n    if (!*phdr)\n        return AVERROR(ENOMEM);\n    hdr = *phdr;\n\n    err = init_get_bits8(&gb, buf, size);\n    if (err < 0)\n        return AVERROR_INVALIDDATA;\n    err = ff_ac3_parse_header(&gb, hdr);\n    if (err < 0)\n        return AVERROR_INVALIDDATA;\n\n    return get_bits_count(&gb);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 3214,
    "critical_vars": [
      "s",
      "gb"
    ],
    "function": "ff_mpeg4_decode_picture_header",
    "filename": "FFmpeg/CVE-2018-13301/CVE-2018-13301_CWE-476_2aa9047486dbff12d9e040f917e5f799ed2fd78b_mpeg4videodec.c.diff",
    "function_code": "int ff_mpeg4_decode_picture_header(Mpeg4DecContext *ctx, GetBitContext *gb)\n{\n    MpegEncContext *s = &ctx->m;\n    unsigned startcode, v;\n    int ret;\n    int vol = 0;\n\n    /* search next start code */\n    align_get_bits(gb);\n\n    // If we have not switched to studio profile than we also did not switch bps\n    // that means something else (like a previous instance) outside set bps which\n    // would be inconsistant with the currect state, thus reset it\n    if (!s->studio_profile && s->avctx->bits_per_raw_sample != 8)\n        s->avctx->bits_per_raw_sample = 0;\n\n    if (s->codec_tag == AV_RL32(\"WV1F\") && show_bits(gb, 24) == 0x575630) {\n        skip_bits(gb, 24);\n        if (get_bits(gb, 8) == 0xF0)\n            goto end;\n    }\n\n    startcode = 0xff;\n    for (;;) {\n        if (get_bits_count(gb) >= gb->size_in_bits) {\n            if (gb->size_in_bits == 8 &&\n                (ctx->divx_version >= 0 || ctx->xvid_build >= 0) || s->codec_tag == AV_RL32(\"QMP4\")) {\n                av_log(s->avctx, AV_LOG_VERBOSE, \"frame skip %d\\n\", gb->size_in_bits);\n                return FRAME_SKIPPED;  // divx bug\n            } else\n                return AVERROR_INVALIDDATA;  // end of stream\n        }\n\n        /* use the bits after the test */\n        v = get_bits(gb, 8);\n        startcode = ((startcode << 8) | v) & 0xffffffff;\n\n        if ((startcode & 0xFFFFFF00) != 0x100)\n            continue;  // no startcode\n\n        if (s->avctx->debug & FF_DEBUG_STARTCODE) {\n            av_log(s->avctx, AV_LOG_DEBUG, \"startcode: %3X \", startcode);\n            if (startcode <= 0x11F)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Video Object Start\");\n            else if (startcode <= 0x12F)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Video Object Layer Start\");\n            else if (startcode <= 0x13F)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Reserved\");\n            else if (startcode <= 0x15F)\n                av_log(s->avctx, AV_LOG_DEBUG, \"FGS bp start\");\n            else if (startcode <= 0x1AF)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Reserved\");\n            else if (startcode == 0x1B0)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Seq Start\");\n            else if (startcode == 0x1B1)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Seq End\");\n            else if (startcode == 0x1B2)\n                av_log(s->avctx, AV_LOG_DEBUG, \"User Data\");\n            else if (startcode == 0x1B3)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Group of VOP start\");\n            else if (startcode == 0x1B4)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Video Session Error\");\n            else if (startcode == 0x1B5)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Start\");\n            else if (startcode == 0x1B6)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Video Object Plane start\");\n            else if (startcode == 0x1B7)\n                av_log(s->avctx, AV_LOG_DEBUG, \"slice start\");\n            else if (startcode == 0x1B8)\n                av_log(s->avctx, AV_LOG_DEBUG, \"extension start\");\n            else if (startcode == 0x1B9)\n                av_log(s->avctx, AV_LOG_DEBUG, \"fgs start\");\n            else if (startcode == 0x1BA)\n                av_log(s->avctx, AV_LOG_DEBUG, \"FBA Object start\");\n            else if (startcode == 0x1BB)\n                av_log(s->avctx, AV_LOG_DEBUG, \"FBA Object Plane start\");\n            else if (startcode == 0x1BC)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Mesh Object start\");\n            else if (startcode == 0x1BD)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Mesh Object Plane start\");\n            else if (startcode == 0x1BE)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Still Texture Object start\");\n            else if (startcode == 0x1BF)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Texture Spatial Layer start\");\n            else if (startcode == 0x1C0)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Texture SNR Layer start\");\n            else if (startcode == 0x1C1)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Texture Tile start\");\n            else if (startcode == 0x1C2)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Texture Shape Layer start\");\n            else if (startcode == 0x1C3)\n                av_log(s->avctx, AV_LOG_DEBUG, \"stuffing start\");\n            else if (startcode <= 0x1C5)\n                av_log(s->avctx, AV_LOG_DEBUG, \"reserved\");\n            else if (startcode <= 0x1FF)\n                av_log(s->avctx, AV_LOG_DEBUG, \"System start\");\n            av_log(s->avctx, AV_LOG_DEBUG, \" at %d\\n\", get_bits_count(gb));\n        }\n\n        if (startcode >= 0x120 && startcode <= 0x12F) {\n            if (vol) {\n                av_log(s->avctx, AV_LOG_WARNING, \"Ignoring multiple VOL headers\\n\");\n                continue;\n            }\n            vol++;\n            if ((ret = decode_vol_header(ctx, gb)) < 0)\n                return ret;\n        } else if (startcode == USER_DATA_STARTCODE) {\n            decode_user_data(ctx, gb);\n        } else if (startcode == GOP_STARTCODE) {\n            mpeg4_decode_gop_header(s, gb);\n        } else if (startcode == VOS_STARTCODE) {\n            mpeg4_decode_profile_level(s, gb);\n            if (s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&\n                (s->avctx->level > 0 && s->avctx->level < 9)) {\n                s->studio_profile = 1;\n                next_start_code_studio(gb);\n                extension_and_user_data(s, gb, 0);\n            }\n        } else if (startcode == VISUAL_OBJ_STARTCODE) {\n            if (s->studio_profile) {\n                if ((ret = decode_studiovisualobject(ctx, gb)) < 0)\n                    return ret;\n            } else\n                mpeg4_decode_visual_object(s, gb);\n        } else if (startcode == VOP_STARTCODE) {\n            break;\n        }\n\n        align_get_bits(gb);\n        startcode = 0xff;\n    }\n\nend:\n    if (s->avctx->flags & AV_CODEC_FLAG_LOW_DELAY)\n        s->low_delay = 1;\n    s->avctx->has_b_frames = !s->low_delay;\n\n    if (s->studio_profile) {\n        if (!s->avctx->bits_per_raw_sample) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Missing VOL header\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        return decode_studio_vop_header(ctx, gb);\n    } else\n        return decode_vop_header(ctx, gb);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 3214,
    "critical_vars": [
      "profile",
      "level"
    ],
    "function": "ff_mpeg4_decode_picture_header",
    "filename": "FFmpeg/CVE-2018-13301/CVE-2018-13301_CWE-476_2aa9047486dbff12d9e040f917e5f799ed2fd78b_mpeg4videodec.c.diff",
    "function_code": "int ff_mpeg4_decode_picture_header(Mpeg4DecContext *ctx, GetBitContext *gb)\n{\n    MpegEncContext *s = &ctx->m;\n    unsigned startcode, v;\n    int ret;\n    int vol = 0;\n\n    /* search next start code */\n    align_get_bits(gb);\n\n    // If we have not switched to studio profile than we also did not switch bps\n    // that means something else (like a previous instance) outside set bps which\n    // would be inconsistant with the currect state, thus reset it\n    if (!s->studio_profile && s->avctx->bits_per_raw_sample != 8)\n        s->avctx->bits_per_raw_sample = 0;\n\n    if (s->codec_tag == AV_RL32(\"WV1F\") && show_bits(gb, 24) == 0x575630) {\n        skip_bits(gb, 24);\n        if (get_bits(gb, 8) == 0xF0)\n            goto end;\n    }\n\n    startcode = 0xff;\n    for (;;) {\n        if (get_bits_count(gb) >= gb->size_in_bits) {\n            if (gb->size_in_bits == 8 &&\n                (ctx->divx_version >= 0 || ctx->xvid_build >= 0) || s->codec_tag == AV_RL32(\"QMP4\")) {\n                av_log(s->avctx, AV_LOG_VERBOSE, \"frame skip %d\\n\", gb->size_in_bits);\n                return FRAME_SKIPPED;  // divx bug\n            } else\n                return AVERROR_INVALIDDATA;  // end of stream\n        }\n\n        /* use the bits after the test */\n        v = get_bits(gb, 8);\n        startcode = ((startcode << 8) | v) & 0xffffffff;\n\n        if ((startcode & 0xFFFFFF00) != 0x100)\n            continue;  // no startcode\n\n        if (s->avctx->debug & FF_DEBUG_STARTCODE) {\n            av_log(s->avctx, AV_LOG_DEBUG, \"startcode: %3X \", startcode);\n            if (startcode <= 0x11F)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Video Object Start\");\n            else if (startcode <= 0x12F)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Video Object Layer Start\");\n            else if (startcode <= 0x13F)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Reserved\");\n            else if (startcode <= 0x15F)\n                av_log(s->avctx, AV_LOG_DEBUG, \"FGS bp start\");\n            else if (startcode <= 0x1AF)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Reserved\");\n            else if (startcode == 0x1B0)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Seq Start\");\n            else if (startcode == 0x1B1)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Seq End\");\n            else if (startcode == 0x1B2)\n                av_log(s->avctx, AV_LOG_DEBUG, \"User Data\");\n            else if (startcode == 0x1B3)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Group of VOP start\");\n            else if (startcode == 0x1B4)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Video Session Error\");\n            else if (startcode == 0x1B5)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Start\");\n            else if (startcode == 0x1B6)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Video Object Plane start\");\n            else if (startcode == 0x1B7)\n                av_log(s->avctx, AV_LOG_DEBUG, \"slice start\");\n            else if (startcode == 0x1B8)\n                av_log(s->avctx, AV_LOG_DEBUG, \"extension start\");\n            else if (startcode == 0x1B9)\n                av_log(s->avctx, AV_LOG_DEBUG, \"fgs start\");\n            else if (startcode == 0x1BA)\n                av_log(s->avctx, AV_LOG_DEBUG, \"FBA Object start\");\n            else if (startcode == 0x1BB)\n                av_log(s->avctx, AV_LOG_DEBUG, \"FBA Object Plane start\");\n            else if (startcode == 0x1BC)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Mesh Object start\");\n            else if (startcode == 0x1BD)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Mesh Object Plane start\");\n            else if (startcode == 0x1BE)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Still Texture Object start\");\n            else if (startcode == 0x1BF)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Texture Spatial Layer start\");\n            else if (startcode == 0x1C0)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Texture SNR Layer start\");\n            else if (startcode == 0x1C1)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Texture Tile start\");\n            else if (startcode == 0x1C2)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Texture Shape Layer start\");\n            else if (startcode == 0x1C3)\n                av_log(s->avctx, AV_LOG_DEBUG, \"stuffing start\");\n            else if (startcode <= 0x1C5)\n                av_log(s->avctx, AV_LOG_DEBUG, \"reserved\");\n            else if (startcode <= 0x1FF)\n                av_log(s->avctx, AV_LOG_DEBUG, \"System start\");\n            av_log(s->avctx, AV_LOG_DEBUG, \" at %d\\n\", get_bits_count(gb));\n        }\n\n        if (startcode >= 0x120 && startcode <= 0x12F) {\n            if (vol) {\n                av_log(s->avctx, AV_LOG_WARNING, \"Ignoring multiple VOL headers\\n\");\n                continue;\n            }\n            vol++;\n            if ((ret = decode_vol_header(ctx, gb)) < 0)\n                return ret;\n        } else if (startcode == USER_DATA_STARTCODE) {\n            decode_user_data(ctx, gb);\n        } else if (startcode == GOP_STARTCODE) {\n            mpeg4_decode_gop_header(s, gb);\n        } else if (startcode == VOS_STARTCODE) {\n            int profile, level;\n            mpeg4_decode_profile_level(s, gb, &profile, &level);\n            if (profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&\n                (level > 0 && level < 9)) {\n                s->studio_profile = 1;\n                next_start_code_studio(gb);\n                extension_and_user_data(s, gb, 0);\n            } else if (s->studio_profile) {\n                avpriv_request_sample(s->avctx, \"Mixes studio and non studio profile\\n\");\n                return AVERROR_PATCHWELCOME;\n            }\n            s->avctx->profile = profile;\n            s->avctx->level   = level;\n        } else if (startcode == VISUAL_OBJ_STARTCODE) {\n            if (s->studio_profile) {\n                if ((ret = decode_studiovisualobject(ctx, gb)) < 0)\n                    return ret;\n            } else\n                mpeg4_decode_visual_object(s, gb);\n        } else if (startcode == VOP_STARTCODE) {\n            break;\n        }\n\n        align_get_bits(gb);\n        startcode = 0xff;\n    }\n\nend:\n    if (s->avctx->flags & AV_CODEC_FLAG_LOW_DELAY)\n        s->low_delay = 1;\n    s->avctx->has_b_frames = !s->low_delay;\n\n    if (s->studio_profile) {\n        av_assert0(s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);\n        if (!s->avctx->bits_per_raw_sample) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Missing VOL header\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        return decode_studio_vop_header(ctx, gb);\n    } else\n        return decode_vop_header(ctx, gb);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 2119,
    "critical_vars": [
      "frame->color_primaries"
    ],
    "function": "show_frame",
    "filename": "FFmpeg/CVE-2017-14225/CVE-2017-14225_CWE-476_837cb4325b712ff1aab531bf41668933f61d75d2_ffprobe.c.diff",
    "function_code": "static void show_frame(WriterContext *w, AVFrame *frame, AVStream *stream,\n                       AVFormatContext *fmt_ctx)\n{\n    AVBPrint pbuf;\n    char val_str[128];\n    const char *s;\n    int i;\n\n    av_bprint_init(&pbuf, 1, AV_BPRINT_SIZE_UNLIMITED);\n\n    writer_print_section_header(w, SECTION_ID_FRAME);\n\n    s = av_get_media_type_string(stream->codecpar->codec_type);\n    if (s) print_str    (\"media_type\", s);\n    else   print_str_opt(\"media_type\", \"unknown\");\n    print_int(\"stream_index\",           stream->index);\n    print_int(\"key_frame\",              frame->key_frame);\n    print_ts  (\"pkt_pts\",               frame->pts);\n    print_time(\"pkt_pts_time\",          frame->pts, &stream->time_base);\n    print_ts  (\"pkt_dts\",               frame->pkt_dts);\n    print_time(\"pkt_dts_time\",          frame->pkt_dts, &stream->time_base);\n    print_ts  (\"best_effort_timestamp\", frame->best_effort_timestamp);\n    print_time(\"best_effort_timestamp_time\", frame->best_effort_timestamp, &stream->time_base);\n    print_duration_ts  (\"pkt_duration\",      frame->pkt_duration);\n    print_duration_time(\"pkt_duration_time\", frame->pkt_duration, &stream->time_base);\n    if (frame->pkt_pos != -1) print_fmt    (\"pkt_pos\", \"%\"PRId64, frame->pkt_pos);\n    else                      print_str_opt(\"pkt_pos\", \"N/A\");\n    if (frame->pkt_size != -1) print_val    (\"pkt_size\", frame->pkt_size, unit_byte_str);\n    else                       print_str_opt(\"pkt_size\", \"N/A\");\n\n    switch (stream->codecpar->codec_type) {\n        AVRational sar;\n\n    case AVMEDIA_TYPE_VIDEO:\n        print_int(\"width\",                  frame->width);\n        print_int(\"height\",                 frame->height);\n        s = av_get_pix_fmt_name(frame->format);\n        if (s) print_str    (\"pix_fmt\", s);\n        else   print_str_opt(\"pix_fmt\", \"unknown\");\n        sar = av_guess_sample_aspect_ratio(fmt_ctx, stream, frame);\n        if (sar.num) {\n            print_q(\"sample_aspect_ratio\", sar, ':');\n        } else {\n            print_str_opt(\"sample_aspect_ratio\", \"N/A\");\n        }\n        print_fmt(\"pict_type\",              \"%c\", av_get_picture_type_char(frame->pict_type));\n        print_int(\"coded_picture_number\",   frame->coded_picture_number);\n        print_int(\"display_picture_number\", frame->display_picture_number);\n        print_int(\"interlaced_frame\",       frame->interlaced_frame);\n        print_int(\"top_field_first\",        frame->top_field_first);\n        print_int(\"repeat_pict\",            frame->repeat_pict);\n\n        if (frame->color_range != AVCOL_RANGE_UNSPECIFIED)\n            print_str(\"color_range\", av_color_range_name(frame->color_range));\n        else\n            print_str_opt(\"color_range\", av_color_range_name(frame->color_range));\n\n        if (frame->colorspace != AVCOL_SPC_UNSPECIFIED)\n            print_str(\"color_space\", av_color_space_name(frame->colorspace));\n        else\n            print_str_opt(\"color_space\", av_color_space_name(frame->colorspace));\n\n        if (frame->color_primaries != AVCOL_PRI_UNSPECIFIED)\n            print_str(\"color_primaries\", av_color_primaries_name(frame->color_primaries));\n        else\n            print_str_opt(\"color_primaries\", av_color_primaries_name(frame->color_primaries));\n\n        if (frame->color_trc != AVCOL_TRC_UNSPECIFIED)\n            print_str(\"color_transfer\", av_color_transfer_name(frame->color_trc));\n        else\n            print_str_opt(\"color_transfer\", av_color_transfer_name(frame->color_trc));\n\n        if (frame->chroma_location != AVCHROMA_LOC_UNSPECIFIED)\n            print_str(\"chroma_location\", av_chroma_location_name(frame->chroma_location));\n        else\n            print_str_opt(\"chroma_location\", av_chroma_location_name(frame->chroma_location));\n        break;\n\n    case AVMEDIA_TYPE_AUDIO:\n        s = av_get_sample_fmt_name(frame->format);\n        if (s) print_str    (\"sample_fmt\", s);\n        else   print_str_opt(\"sample_fmt\", \"unknown\");\n        print_int(\"nb_samples\",         frame->nb_samples);\n        print_int(\"channels\", frame->channels);\n        if (frame->channel_layout) {\n            av_bprint_clear(&pbuf);\n            av_bprint_channel_layout(&pbuf, frame->channels,\n                                     frame->channel_layout);\n            print_str    (\"channel_layout\", pbuf.str);\n        } else\n            print_str_opt(\"channel_layout\", \"unknown\");\n        break;\n    }\n    if (do_show_frame_tags)\n        show_tags(w, frame->metadata, SECTION_ID_FRAME_TAGS);\n    if (do_show_log)\n        show_log(w, SECTION_ID_FRAME_LOGS, SECTION_ID_FRAME_LOG, do_show_log);\n    if (frame->nb_side_data) {\n        writer_print_section_header(w, SECTION_ID_FRAME_SIDE_DATA_LIST);\n        for (i = 0; i < frame->nb_side_data; i++) {\n            AVFrameSideData *sd = frame->side_data[i];\n            const char *name;\n\n            writer_print_section_header(w, SECTION_ID_FRAME_SIDE_DATA);\n            name = av_frame_side_data_name(sd->type);\n            print_str(\"side_data_type\", name ? name : \"unknown\");\n            if (sd->type == AV_FRAME_DATA_DISPLAYMATRIX && sd->size >= 9*4) {\n                writer_print_integers(w, \"displaymatrix\", sd->data, 9, \" %11d\", 3, 4, 1);\n                print_int(\"rotation\", av_display_rotation_get((int32_t *)sd->data));\n            } else if (sd->type == AV_FRAME_DATA_GOP_TIMECODE && sd->size >= 8) {\n                char tcbuf[AV_TIMECODE_STR_SIZE];\n                av_timecode_make_mpeg_tc_string(tcbuf, *(int64_t *)(sd->data));\n                print_str(\"timecode\", tcbuf);\n            } else if (sd->type == AV_FRAME_DATA_MASTERING_DISPLAY_METADATA) {\n                AVMasteringDisplayMetadata *metadata = (AVMasteringDisplayMetadata *)sd->data;\n\n                if (metadata->has_primaries) {\n                    print_q(\"red_x\", metadata->display_primaries[0][0], '/');\n                    print_q(\"red_y\", metadata->display_primaries[0][1], '/');\n                    print_q(\"green_x\", metadata->display_primaries[1][0], '/');\n                    print_q(\"green_y\", metadata->display_primaries[1][1], '/');\n                    print_q(\"blue_x\", metadata->display_primaries[2][0], '/');\n                    print_q(\"blue_y\", metadata->display_primaries[2][1], '/');\n\n                    print_q(\"white_point_x\", metadata->white_point[0], '/');\n                    print_q(\"white_point_y\", metadata->white_point[1], '/');\n                }\n\n                if (metadata->has_luminance) {\n                    print_q(\"min_luminance\", metadata->min_luminance, '/');\n                    print_q(\"max_luminance\", metadata->max_luminance, '/');\n                }\n            } else if (sd->type == AV_FRAME_DATA_CONTENT_LIGHT_LEVEL) {\n                AVContentLightMetadata *metadata = (AVContentLightMetadata *)sd->data;\n                print_int(\"max_content\", metadata->MaxCLL);\n                print_int(\"max_average\", metadata->MaxFALL);\n            } else if (sd->type == AV_FRAME_DATA_ICC_PROFILE) {\n                AVDictionaryEntry *tag = av_dict_get(sd->metadata, \"name\", NULL, AV_DICT_MATCH_CASE);\n                if (tag)\n                    print_str(tag->key, tag->value);\n                print_int(\"size\", sd->size);\n            }\n            writer_print_section_footer(w);\n        }\n        writer_print_section_footer(w);\n    }\n\n    writer_print_section_footer(w);\n\n    av_bprint_finalize(&pbuf, NULL);\n    fflush(stdout);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 2129,
    "critical_vars": [
      "w",
      "frame->color_primaries"
    ],
    "function": "show_frame",
    "filename": "FFmpeg/CVE-2017-14225/CVE-2017-14225_CWE-476_837cb4325b712ff1aab531bf41668933f61d75d2_ffprobe.c.diff",
    "function_code": "static void show_frame(WriterContext *w, AVFrame *frame, AVStream *stream,\n                       AVFormatContext *fmt_ctx)\n{\n    AVBPrint pbuf;\n    char val_str[128];\n    const char *s;\n    int i;\n\n    av_bprint_init(&pbuf, 1, AV_BPRINT_SIZE_UNLIMITED);\n\n    writer_print_section_header(w, SECTION_ID_FRAME);\n\n    s = av_get_media_type_string(stream->codecpar->codec_type);\n    if (s) print_str    (\"media_type\", s);\n    else   print_str_opt(\"media_type\", \"unknown\");\n    print_int(\"stream_index\",           stream->index);\n    print_int(\"key_frame\",              frame->key_frame);\n    print_ts  (\"pkt_pts\",               frame->pts);\n    print_time(\"pkt_pts_time\",          frame->pts, &stream->time_base);\n    print_ts  (\"pkt_dts\",               frame->pkt_dts);\n    print_time(\"pkt_dts_time\",          frame->pkt_dts, &stream->time_base);\n    print_ts  (\"best_effort_timestamp\", frame->best_effort_timestamp);\n    print_time(\"best_effort_timestamp_time\", frame->best_effort_timestamp, &stream->time_base);\n    print_duration_ts  (\"pkt_duration\",      frame->pkt_duration);\n    print_duration_time(\"pkt_duration_time\", frame->pkt_duration, &stream->time_base);\n    if (frame->pkt_pos != -1) print_fmt    (\"pkt_pos\", \"%\"PRId64, frame->pkt_pos);\n    else                      print_str_opt(\"pkt_pos\", \"N/A\");\n    if (frame->pkt_size != -1) print_val    (\"pkt_size\", frame->pkt_size, unit_byte_str);\n    else                       print_str_opt(\"pkt_size\", \"N/A\");\n\n    switch (stream->codecpar->codec_type) {\n        AVRational sar;\n\n    case AVMEDIA_TYPE_VIDEO:\n        print_int(\"width\",                  frame->width);\n        print_int(\"height\",                 frame->height);\n        s = av_get_pix_fmt_name(frame->format);\n        if (s) print_str    (\"pix_fmt\", s);\n        else   print_str_opt(\"pix_fmt\", \"unknown\");\n        sar = av_guess_sample_aspect_ratio(fmt_ctx, stream, frame);\n        if (sar.num) {\n            print_q(\"sample_aspect_ratio\", sar, ':');\n        } else {\n            print_str_opt(\"sample_aspect_ratio\", \"N/A\");\n        }\n        print_fmt(\"pict_type\",              \"%c\", av_get_picture_type_char(frame->pict_type));\n        print_int(\"coded_picture_number\",   frame->coded_picture_number);\n        print_int(\"display_picture_number\", frame->display_picture_number);\n        print_int(\"interlaced_frame\",       frame->interlaced_frame);\n        print_int(\"top_field_first\",        frame->top_field_first);\n        print_int(\"repeat_pict\",            frame->repeat_pict);\n\n        if (frame->color_range != AVCOL_RANGE_UNSPECIFIED)\n            print_str(\"color_range\", av_color_range_name(frame->color_range));\n        else\n            print_str_opt(\"color_range\", av_color_range_name(frame->color_range));\n\n        if (frame->colorspace != AVCOL_SPC_UNSPECIFIED)\n            print_str(\"color_space\", av_color_space_name(frame->colorspace));\n        else\n            print_str_opt(\"color_space\", av_color_space_name(frame->colorspace));\n\n        print_primaries(w, frame->color_primaries);\n\n        if (frame->color_trc != AVCOL_TRC_UNSPECIFIED)\n            print_str(\"color_transfer\", av_color_transfer_name(frame->color_trc));\n        else\n            print_str_opt(\"color_transfer\", av_color_transfer_name(frame->color_trc));\n\n        if (frame->chroma_location != AVCHROMA_LOC_UNSPECIFIED)\n            print_str(\"chroma_location\", av_chroma_location_name(frame->chroma_location));\n        else\n            print_str_opt(\"chroma_location\", av_chroma_location_name(frame->chroma_location));\n        break;\n\n    case AVMEDIA_TYPE_AUDIO:\n        s = av_get_sample_fmt_name(frame->format);\n        if (s) print_str    (\"sample_fmt\", s);\n        else   print_str_opt(\"sample_fmt\", \"unknown\");\n        print_int(\"nb_samples\",         frame->nb_samples);\n        print_int(\"channels\", frame->channels);\n        if (frame->channel_layout) {\n            av_bprint_clear(&pbuf);\n            av_bprint_channel_layout(&pbuf, frame->channels,\n                                     frame->channel_layout);\n            print_str    (\"channel_layout\", pbuf.str);\n        } else\n            print_str_opt(\"channel_layout\", \"unknown\");\n        break;\n    }\n    if (do_show_frame_tags)\n        show_tags(w, frame->metadata, SECTION_ID_FRAME_TAGS);\n    if (do_show_log)\n        show_log(w, SECTION_ID_FRAME_LOGS, SECTION_ID_FRAME_LOG, do_show_log);\n    if (frame->nb_side_data) {\n        writer_print_section_header(w, SECTION_ID_FRAME_SIDE_DATA_LIST);\n        for (i = 0; i < frame->nb_side_data; i++) {\n            AVFrameSideData *sd = frame->side_data[i];\n            const char *name;\n\n            writer_print_section_header(w, SECTION_ID_FRAME_SIDE_DATA);\n            name = av_frame_side_data_name(sd->type);\n            print_str(\"side_data_type\", name ? name : \"unknown\");\n            if (sd->type == AV_FRAME_DATA_DISPLAYMATRIX && sd->size >= 9*4) {\n                writer_print_integers(w, \"displaymatrix\", sd->data, 9, \" %11d\", 3, 4, 1);\n                print_int(\"rotation\", av_display_rotation_get((int32_t *)sd->data));\n            } else if (sd->type == AV_FRAME_DATA_GOP_TIMECODE && sd->size >= 8) {\n                char tcbuf[AV_TIMECODE_STR_SIZE];\n                av_timecode_make_mpeg_tc_string(tcbuf, *(int64_t *)(sd->data));\n                print_str(\"timecode\", tcbuf);\n            } else if (sd->type == AV_FRAME_DATA_MASTERING_DISPLAY_METADATA) {\n                AVMasteringDisplayMetadata *metadata = (AVMasteringDisplayMetadata *)sd->data;\n\n                if (metadata->has_primaries) {\n                    print_q(\"red_x\", metadata->display_primaries[0][0], '/');\n                    print_q(\"red_y\", metadata->display_primaries[0][1], '/');\n                    print_q(\"green_x\", metadata->display_primaries[1][0], '/');\n                    print_q(\"green_y\", metadata->display_primaries[1][1], '/');\n                    print_q(\"blue_x\", metadata->display_primaries[2][0], '/');\n                    print_q(\"blue_y\", metadata->display_primaries[2][1], '/');\n\n                    print_q(\"white_point_x\", metadata->white_point[0], '/');\n                    print_q(\"white_point_y\", metadata->white_point[1], '/');\n                }\n\n                if (metadata->has_luminance) {\n                    print_q(\"min_luminance\", metadata->min_luminance, '/');\n                    print_q(\"max_luminance\", metadata->max_luminance, '/');\n                }\n            } else if (sd->type == AV_FRAME_DATA_CONTENT_LIGHT_LEVEL) {\n                AVContentLightMetadata *metadata = (AVContentLightMetadata *)sd->data;\n                print_int(\"max_content\", metadata->MaxCLL);\n                print_int(\"max_average\", metadata->MaxFALL);\n            } else if (sd->type == AV_FRAME_DATA_ICC_PROFILE) {\n                AVDictionaryEntry *tag = av_dict_get(sd->metadata, \"name\", NULL, AV_DICT_MATCH_CASE);\n                if (tag)\n                    print_str(tag->key, tag->value);\n                print_int(\"size\", sd->size);\n            }\n            writer_print_section_footer(w);\n        }\n        writer_print_section_footer(w);\n    }\n\n    writer_print_section_footer(w);\n\n    av_bprint_finalize(&pbuf, NULL);\n    fflush(stdout);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 2519,
    "critical_vars": [
      "par->color_primaries"
    ],
    "function": "show_stream",
    "filename": "FFmpeg/CVE-2017-14225/CVE-2017-14225_CWE-476_837cb4325b712ff1aab531bf41668933f61d75d2_ffprobe.c.diff",
    "function_code": "static int show_stream(WriterContext *w, AVFormatContext *fmt_ctx, int stream_idx, InputStream *ist, int in_program)\n{\n    AVStream *stream = ist->st;\n    AVCodecParameters *par;\n    AVCodecContext *dec_ctx;\n    char val_str[128];\n    const char *s;\n    AVRational sar, dar;\n    AVBPrint pbuf;\n    const AVCodecDescriptor *cd;\n    int ret = 0;\n    const char *profile = NULL;\n\n    av_bprint_init(&pbuf, 1, AV_BPRINT_SIZE_UNLIMITED);\n\n    writer_print_section_header(w, in_program ? SECTION_ID_PROGRAM_STREAM : SECTION_ID_STREAM);\n\n    print_int(\"index\", stream->index);\n\n    par     = stream->codecpar;\n    dec_ctx = ist->dec_ctx;\n    if (cd = avcodec_descriptor_get(par->codec_id)) {\n        print_str(\"codec_name\", cd->name);\n        if (!do_bitexact) {\n            print_str(\"codec_long_name\",\n                      cd->long_name ? cd->long_name : \"unknown\");\n        }\n    } else {\n        print_str_opt(\"codec_name\", \"unknown\");\n        if (!do_bitexact) {\n            print_str_opt(\"codec_long_name\", \"unknown\");\n        }\n    }\n\n    if (!do_bitexact && (profile = avcodec_profile_name(par->codec_id, par->profile)))\n        print_str(\"profile\", profile);\n    else {\n        if (par->profile != FF_PROFILE_UNKNOWN) {\n            char profile_num[12];\n            snprintf(profile_num, sizeof(profile_num), \"%d\", par->profile);\n            print_str(\"profile\", profile_num);\n        } else\n            print_str_opt(\"profile\", \"unknown\");\n    }\n\n    s = av_get_media_type_string(par->codec_type);\n    if (s) print_str    (\"codec_type\", s);\n    else   print_str_opt(\"codec_type\", \"unknown\");\n#if FF_API_LAVF_AVCTX\n    if (dec_ctx)\n        print_q(\"codec_time_base\", dec_ctx->time_base, '/');\n#endif\n\n    /* print AVI/FourCC tag */\n    print_str(\"codec_tag_string\",    av_fourcc2str(par->codec_tag));\n    print_fmt(\"codec_tag\", \"0x%04\"PRIx32, par->codec_tag);\n\n    switch (par->codec_type) {\n    case AVMEDIA_TYPE_VIDEO:\n        print_int(\"width\",        par->width);\n        print_int(\"height\",       par->height);\n        if (dec_ctx) {\n            print_int(\"coded_width\",  dec_ctx->coded_width);\n            print_int(\"coded_height\", dec_ctx->coded_height);\n        }\n        print_int(\"has_b_frames\", par->video_delay);\n        sar = av_guess_sample_aspect_ratio(fmt_ctx, stream, NULL);\n        if (sar.den) {\n            print_q(\"sample_aspect_ratio\", sar, ':');\n            av_reduce(&dar.num, &dar.den,\n                      par->width  * sar.num,\n                      par->height * sar.den,\n                      1024*1024);\n            print_q(\"display_aspect_ratio\", dar, ':');\n        } else {\n            print_str_opt(\"sample_aspect_ratio\", \"N/A\");\n            print_str_opt(\"display_aspect_ratio\", \"N/A\");\n        }\n        s = av_get_pix_fmt_name(par->format);\n        if (s) print_str    (\"pix_fmt\", s);\n        else   print_str_opt(\"pix_fmt\", \"unknown\");\n        print_int(\"level\",   par->level);\n        if (par->color_range != AVCOL_RANGE_UNSPECIFIED)\n            print_str    (\"color_range\", av_color_range_name(par->color_range));\n        else\n            print_str_opt(\"color_range\", \"N/A\");\n\n        if (par->color_space != AVCOL_SPC_UNSPECIFIED)\n            print_str(\"color_space\", av_color_space_name(par->color_space));\n        else\n            print_str_opt(\"color_space\", av_color_space_name(par->color_space));\n\n        if (par->color_trc != AVCOL_TRC_UNSPECIFIED)\n            print_str(\"color_transfer\", av_color_transfer_name(par->color_trc));\n        else\n            print_str_opt(\"color_transfer\", av_color_transfer_name(par->color_trc));\n\n        if (par->color_primaries != AVCOL_PRI_UNSPECIFIED)\n            print_str(\"color_primaries\", av_color_primaries_name(par->color_primaries));\n        else\n            print_str_opt(\"color_primaries\", av_color_primaries_name(par->color_primaries));\n\n        if (par->chroma_location != AVCHROMA_LOC_UNSPECIFIED)\n            print_str(\"chroma_location\", av_chroma_location_name(par->chroma_location));\n        else\n            print_str_opt(\"chroma_location\", av_chroma_location_name(par->chroma_location));\n\n        if (par->field_order == AV_FIELD_PROGRESSIVE)\n            print_str(\"field_order\", \"progressive\");\n        else if (par->field_order == AV_FIELD_TT)\n            print_str(\"field_order\", \"tt\");\n        else if (par->field_order == AV_FIELD_BB)\n            print_str(\"field_order\", \"bb\");\n        else if (par->field_order == AV_FIELD_TB)\n            print_str(\"field_order\", \"tb\");\n        else if (par->field_order == AV_FIELD_BT)\n            print_str(\"field_order\", \"bt\");\n        else\n            print_str_opt(\"field_order\", \"unknown\");\n\n#if FF_API_PRIVATE_OPT\n        if (dec_ctx && dec_ctx->timecode_frame_start >= 0) {\n            char tcbuf[AV_TIMECODE_STR_SIZE];\n            av_timecode_make_mpeg_tc_string(tcbuf, dec_ctx->timecode_frame_start);\n            print_str(\"timecode\", tcbuf);\n        } else {\n            print_str_opt(\"timecode\", \"N/A\");\n        }\n#endif\n        if (dec_ctx)\n            print_int(\"refs\", dec_ctx->refs);\n        break;\n\n    case AVMEDIA_TYPE_AUDIO:\n        s = av_get_sample_fmt_name(par->format);\n        if (s) print_str    (\"sample_fmt\", s);\n        else   print_str_opt(\"sample_fmt\", \"unknown\");\n        print_val(\"sample_rate\",     par->sample_rate, unit_hertz_str);\n        print_int(\"channels\",        par->channels);\n\n        if (par->channel_layout) {\n            av_bprint_clear(&pbuf);\n            av_bprint_channel_layout(&pbuf, par->channels, par->channel_layout);\n            print_str    (\"channel_layout\", pbuf.str);\n        } else {\n            print_str_opt(\"channel_layout\", \"unknown\");\n        }\n\n        print_int(\"bits_per_sample\", av_get_bits_per_sample(par->codec_id));\n        break;\n\n    case AVMEDIA_TYPE_SUBTITLE:\n        if (par->width)\n            print_int(\"width\",       par->width);\n        else\n            print_str_opt(\"width\",   \"N/A\");\n        if (par->height)\n            print_int(\"height\",      par->height);\n        else\n            print_str_opt(\"height\",  \"N/A\");\n        break;\n    }\n\n    if (dec_ctx && dec_ctx->codec && dec_ctx->codec->priv_class && show_private_data) {\n        const AVOption *opt = NULL;\n        while (opt = av_opt_next(dec_ctx->priv_data,opt)) {\n            uint8_t *str;\n            if (opt->flags) continue;\n            if (av_opt_get(dec_ctx->priv_data, opt->name, 0, &str) >= 0) {\n                print_str(opt->name, str);\n                av_free(str);\n            }\n        }\n    }\n\n    if (fmt_ctx->iformat->flags & AVFMT_SHOW_IDS) print_fmt    (\"id\", \"0x%x\", stream->id);\n    else                                          print_str_opt(\"id\", \"N/A\");\n    print_q(\"r_frame_rate\",   stream->r_frame_rate,   '/');\n    print_q(\"avg_frame_rate\", stream->avg_frame_rate, '/');\n    print_q(\"time_base\",      stream->time_base,      '/');\n    print_ts  (\"start_pts\",   stream->start_time);\n    print_time(\"start_time\",  stream->start_time, &stream->time_base);\n    print_ts  (\"duration_ts\", stream->duration);\n    print_time(\"duration\",    stream->duration, &stream->time_base);\n    if (par->bit_rate > 0)     print_val    (\"bit_rate\", par->bit_rate, unit_bit_per_second_str);\n    else                       print_str_opt(\"bit_rate\", \"N/A\");\n#if FF_API_LAVF_AVCTX\n    if (stream->codec->rc_max_rate > 0) print_val (\"max_bit_rate\", stream->codec->rc_max_rate, unit_bit_per_second_str);\n    else                                print_str_opt(\"max_bit_rate\", \"N/A\");\n#endif\n    if (dec_ctx && dec_ctx->bits_per_raw_sample > 0) print_fmt(\"bits_per_raw_sample\", \"%d\", dec_ctx->bits_per_raw_sample);\n    else                                             print_str_opt(\"bits_per_raw_sample\", \"N/A\");\n    if (stream->nb_frames) print_fmt    (\"nb_frames\", \"%\"PRId64, stream->nb_frames);\n    else                   print_str_opt(\"nb_frames\", \"N/A\");\n    if (nb_streams_frames[stream_idx])  print_fmt    (\"nb_read_frames\", \"%\"PRIu64, nb_streams_frames[stream_idx]);\n    else                                print_str_opt(\"nb_read_frames\", \"N/A\");\n    if (nb_streams_packets[stream_idx]) print_fmt    (\"nb_read_packets\", \"%\"PRIu64, nb_streams_packets[stream_idx]);\n    else                                print_str_opt(\"nb_read_packets\", \"N/A\");\n    if (do_show_data)\n        writer_print_data(w, \"extradata\", par->extradata,\n                                          par->extradata_size);\n    writer_print_data_hash(w, \"extradata_hash\", par->extradata,\n                                                par->extradata_size);\n\n    /* Print disposition information */\n#define PRINT_DISPOSITION(flagname, name) do {                                \\\n        print_int(name, !!(stream->disposition & AV_DISPOSITION_##flagname)); \\\n    } while (0)\n\n    if (do_show_stream_disposition) {\n    writer_print_section_header(w, in_program ? SECTION_ID_PROGRAM_STREAM_DISPOSITION : SECTION_ID_STREAM_DISPOSITION);\n    PRINT_DISPOSITION(DEFAULT,          \"default\");\n    PRINT_DISPOSITION(DUB,              \"dub\");\n    PRINT_DISPOSITION(ORIGINAL,         \"original\");\n    PRINT_DISPOSITION(COMMENT,          \"comment\");\n    PRINT_DISPOSITION(LYRICS,           \"lyrics\");\n    PRINT_DISPOSITION(KARAOKE,          \"karaoke\");\n    PRINT_DISPOSITION(FORCED,           \"forced\");\n    PRINT_DISPOSITION(HEARING_IMPAIRED, \"hearing_impaired\");\n    PRINT_DISPOSITION(VISUAL_IMPAIRED,  \"visual_impaired\");\n    PRINT_DISPOSITION(CLEAN_EFFECTS,    \"clean_effects\");\n    PRINT_DISPOSITION(ATTACHED_PIC,     \"attached_pic\");\n    PRINT_DISPOSITION(TIMED_THUMBNAILS, \"timed_thumbnails\");\n    writer_print_section_footer(w);\n    }\n\n    if (do_show_stream_tags)\n        ret = show_tags(w, stream->metadata, in_program ? SECTION_ID_PROGRAM_STREAM_TAGS : SECTION_ID_STREAM_TAGS);\n\n    if (stream->nb_side_data) {\n        print_pkt_side_data(w, stream->codecpar, stream->side_data, stream->nb_side_data,\n                            SECTION_ID_STREAM_SIDE_DATA_LIST,\n                            SECTION_ID_STREAM_SIDE_DATA);\n    }\n\n    writer_print_section_footer(w);\n    av_bprint_finalize(&pbuf, NULL);\n    fflush(stdout);\n\n    return ret;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 2526,
    "critical_vars": [
      "par->color_primaries",
      "w"
    ],
    "function": "show_stream",
    "filename": "FFmpeg/CVE-2017-14225/CVE-2017-14225_CWE-476_837cb4325b712ff1aab531bf41668933f61d75d2_ffprobe.c.diff",
    "function_code": "static int show_stream(WriterContext *w, AVFormatContext *fmt_ctx, int stream_idx, InputStream *ist, int in_program)\n{\n    AVStream *stream = ist->st;\n    AVCodecParameters *par;\n    AVCodecContext *dec_ctx;\n    char val_str[128];\n    const char *s;\n    AVRational sar, dar;\n    AVBPrint pbuf;\n    const AVCodecDescriptor *cd;\n    int ret = 0;\n    const char *profile = NULL;\n\n    av_bprint_init(&pbuf, 1, AV_BPRINT_SIZE_UNLIMITED);\n\n    writer_print_section_header(w, in_program ? SECTION_ID_PROGRAM_STREAM : SECTION_ID_STREAM);\n\n    print_int(\"index\", stream->index);\n\n    par     = stream->codecpar;\n    dec_ctx = ist->dec_ctx;\n    if (cd = avcodec_descriptor_get(par->codec_id)) {\n        print_str(\"codec_name\", cd->name);\n        if (!do_bitexact) {\n            print_str(\"codec_long_name\",\n                      cd->long_name ? cd->long_name : \"unknown\");\n        }\n    } else {\n        print_str_opt(\"codec_name\", \"unknown\");\n        if (!do_bitexact) {\n            print_str_opt(\"codec_long_name\", \"unknown\");\n        }\n    }\n\n    if (!do_bitexact && (profile = avcodec_profile_name(par->codec_id, par->profile)))\n        print_str(\"profile\", profile);\n    else {\n        if (par->profile != FF_PROFILE_UNKNOWN) {\n            char profile_num[12];\n            snprintf(profile_num, sizeof(profile_num), \"%d\", par->profile);\n            print_str(\"profile\", profile_num);\n        } else\n            print_str_opt(\"profile\", \"unknown\");\n    }\n\n    s = av_get_media_type_string(par->codec_type);\n    if (s) print_str    (\"codec_type\", s);\n    else   print_str_opt(\"codec_type\", \"unknown\");\n#if FF_API_LAVF_AVCTX\n    if (dec_ctx)\n        print_q(\"codec_time_base\", dec_ctx->time_base, '/');\n#endif\n\n    /* print AVI/FourCC tag */\n    print_str(\"codec_tag_string\",    av_fourcc2str(par->codec_tag));\n    print_fmt(\"codec_tag\", \"0x%04\"PRIx32, par->codec_tag);\n\n    switch (par->codec_type) {\n    case AVMEDIA_TYPE_VIDEO:\n        print_int(\"width\",        par->width);\n        print_int(\"height\",       par->height);\n        if (dec_ctx) {\n            print_int(\"coded_width\",  dec_ctx->coded_width);\n            print_int(\"coded_height\", dec_ctx->coded_height);\n        }\n        print_int(\"has_b_frames\", par->video_delay);\n        sar = av_guess_sample_aspect_ratio(fmt_ctx, stream, NULL);\n        if (sar.den) {\n            print_q(\"sample_aspect_ratio\", sar, ':');\n            av_reduce(&dar.num, &dar.den,\n                      par->width  * sar.num,\n                      par->height * sar.den,\n                      1024*1024);\n            print_q(\"display_aspect_ratio\", dar, ':');\n        } else {\n            print_str_opt(\"sample_aspect_ratio\", \"N/A\");\n            print_str_opt(\"display_aspect_ratio\", \"N/A\");\n        }\n        s = av_get_pix_fmt_name(par->format);\n        if (s) print_str    (\"pix_fmt\", s);\n        else   print_str_opt(\"pix_fmt\", \"unknown\");\n        print_int(\"level\",   par->level);\n        if (par->color_range != AVCOL_RANGE_UNSPECIFIED)\n            print_str    (\"color_range\", av_color_range_name(par->color_range));\n        else\n            print_str_opt(\"color_range\", \"N/A\");\n\n        if (par->color_space != AVCOL_SPC_UNSPECIFIED)\n            print_str(\"color_space\", av_color_space_name(par->color_space));\n        else\n            print_str_opt(\"color_space\", av_color_space_name(par->color_space));\n\n        if (par->color_trc != AVCOL_TRC_UNSPECIFIED)\n            print_str(\"color_transfer\", av_color_transfer_name(par->color_trc));\n        else\n            print_str_opt(\"color_transfer\", av_color_transfer_name(par->color_trc));\n\n        print_primaries(w, par->color_primaries);\n\n        if (par->chroma_location != AVCHROMA_LOC_UNSPECIFIED)\n            print_str(\"chroma_location\", av_chroma_location_name(par->chroma_location));\n        else\n            print_str_opt(\"chroma_location\", av_chroma_location_name(par->chroma_location));\n\n        if (par->field_order == AV_FIELD_PROGRESSIVE)\n            print_str(\"field_order\", \"progressive\");\n        else if (par->field_order == AV_FIELD_TT)\n            print_str(\"field_order\", \"tt\");\n        else if (par->field_order == AV_FIELD_BB)\n            print_str(\"field_order\", \"bb\");\n        else if (par->field_order == AV_FIELD_TB)\n            print_str(\"field_order\", \"tb\");\n        else if (par->field_order == AV_FIELD_BT)\n            print_str(\"field_order\", \"bt\");\n        else\n            print_str_opt(\"field_order\", \"unknown\");\n\n#if FF_API_PRIVATE_OPT\n        if (dec_ctx && dec_ctx->timecode_frame_start >= 0) {\n            char tcbuf[AV_TIMECODE_STR_SIZE];\n            av_timecode_make_mpeg_tc_string(tcbuf, dec_ctx->timecode_frame_start);\n            print_str(\"timecode\", tcbuf);\n        } else {\n            print_str_opt(\"timecode\", \"N/A\");\n        }\n#endif\n        if (dec_ctx)\n            print_int(\"refs\", dec_ctx->refs);\n        break;\n\n    case AVMEDIA_TYPE_AUDIO:\n        s = av_get_sample_fmt_name(par->format);\n        if (s) print_str    (\"sample_fmt\", s);\n        else   print_str_opt(\"sample_fmt\", \"unknown\");\n        print_val(\"sample_rate\",     par->sample_rate, unit_hertz_str);\n        print_int(\"channels\",        par->channels);\n\n        if (par->channel_layout) {\n            av_bprint_clear(&pbuf);\n            av_bprint_channel_layout(&pbuf, par->channels, par->channel_layout);\n            print_str    (\"channel_layout\", pbuf.str);\n        } else {\n            print_str_opt(\"channel_layout\", \"unknown\");\n        }\n\n        print_int(\"bits_per_sample\", av_get_bits_per_sample(par->codec_id));\n        break;\n\n    case AVMEDIA_TYPE_SUBTITLE:\n        if (par->width)\n            print_int(\"width\",       par->width);\n        else\n            print_str_opt(\"width\",   \"N/A\");\n        if (par->height)\n            print_int(\"height\",      par->height);\n        else\n            print_str_opt(\"height\",  \"N/A\");\n        break;\n    }\n\n    if (dec_ctx && dec_ctx->codec && dec_ctx->codec->priv_class && show_private_data) {\n        const AVOption *opt = NULL;\n        while (opt = av_opt_next(dec_ctx->priv_data,opt)) {\n            uint8_t *str;\n            if (opt->flags) continue;\n            if (av_opt_get(dec_ctx->priv_data, opt->name, 0, &str) >= 0) {\n                print_str(opt->name, str);\n                av_free(str);\n            }\n        }\n    }\n\n    if (fmt_ctx->iformat->flags & AVFMT_SHOW_IDS) print_fmt    (\"id\", \"0x%x\", stream->id);\n    else                                          print_str_opt(\"id\", \"N/A\");\n    print_q(\"r_frame_rate\",   stream->r_frame_rate,   '/');\n    print_q(\"avg_frame_rate\", stream->avg_frame_rate, '/');\n    print_q(\"time_base\",      stream->time_base,      '/');\n    print_ts  (\"start_pts\",   stream->start_time);\n    print_time(\"start_time\",  stream->start_time, &stream->time_base);\n    print_ts  (\"duration_ts\", stream->duration);\n    print_time(\"duration\",    stream->duration, &stream->time_base);\n    if (par->bit_rate > 0)     print_val    (\"bit_rate\", par->bit_rate, unit_bit_per_second_str);\n    else                       print_str_opt(\"bit_rate\", \"N/A\");\n#if FF_API_LAVF_AVCTX\n    if (stream->codec->rc_max_rate > 0) print_val (\"max_bit_rate\", stream->codec->rc_max_rate, unit_bit_per_second_str);\n    else                                print_str_opt(\"max_bit_rate\", \"N/A\");\n#endif\n    if (dec_ctx && dec_ctx->bits_per_raw_sample > 0) print_fmt(\"bits_per_raw_sample\", \"%d\", dec_ctx->bits_per_raw_sample);\n    else                                             print_str_opt(\"bits_per_raw_sample\", \"N/A\");\n    if (stream->nb_frames) print_fmt    (\"nb_frames\", \"%\"PRId64, stream->nb_frames);\n    else                   print_str_opt(\"nb_frames\", \"N/A\");\n    if (nb_streams_frames[stream_idx])  print_fmt    (\"nb_read_frames\", \"%\"PRIu64, nb_streams_frames[stream_idx]);\n    else                                print_str_opt(\"nb_read_frames\", \"N/A\");\n    if (nb_streams_packets[stream_idx]) print_fmt    (\"nb_read_packets\", \"%\"PRIu64, nb_streams_packets[stream_idx]);\n    else                                print_str_opt(\"nb_read_packets\", \"N/A\");\n    if (do_show_data)\n        writer_print_data(w, \"extradata\", par->extradata,\n                                          par->extradata_size);\n    writer_print_data_hash(w, \"extradata_hash\", par->extradata,\n                                                par->extradata_size);\n\n    /* Print disposition information */\n#define PRINT_DISPOSITION(flagname, name) do {                                \\\n        print_int(name, !!(stream->disposition & AV_DISPOSITION_##flagname)); \\\n    } while (0)\n\n    if (do_show_stream_disposition) {\n    writer_print_section_header(w, in_program ? SECTION_ID_PROGRAM_STREAM_DISPOSITION : SECTION_ID_STREAM_DISPOSITION);\n    PRINT_DISPOSITION(DEFAULT,          \"default\");\n    PRINT_DISPOSITION(DUB,              \"dub\");\n    PRINT_DISPOSITION(ORIGINAL,         \"original\");\n    PRINT_DISPOSITION(COMMENT,          \"comment\");\n    PRINT_DISPOSITION(LYRICS,           \"lyrics\");\n    PRINT_DISPOSITION(KARAOKE,          \"karaoke\");\n    PRINT_DISPOSITION(FORCED,           \"forced\");\n    PRINT_DISPOSITION(HEARING_IMPAIRED, \"hearing_impaired\");\n    PRINT_DISPOSITION(VISUAL_IMPAIRED,  \"visual_impaired\");\n    PRINT_DISPOSITION(CLEAN_EFFECTS,    \"clean_effects\");\n    PRINT_DISPOSITION(ATTACHED_PIC,     \"attached_pic\");\n    PRINT_DISPOSITION(TIMED_THUMBNAILS, \"timed_thumbnails\");\n    writer_print_section_footer(w);\n    }\n\n    if (do_show_stream_tags)\n        ret = show_tags(w, stream->metadata, in_program ? SECTION_ID_PROGRAM_STREAM_TAGS : SECTION_ID_STREAM_TAGS);\n\n    if (stream->nb_side_data) {\n        print_pkt_side_data(w, stream->codecpar, stream->side_data, stream->nb_side_data,\n                            SECTION_ID_STREAM_SIDE_DATA_LIST,\n                            SECTION_ID_STREAM_SIDE_DATA);\n    }\n\n    writer_print_section_footer(w);\n    av_bprint_finalize(&pbuf, NULL);\n    fflush(stdout);\n\n    return ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 2684,
    "critical_vars": [
      "s->edge_emu_buffer"
    ],
    "function": "vp3_decode_frame",
    "filename": "FFmpeg/CVE-2022-3109/CVE-2022-3109_CWE-476_656cb0450aeb73b25d7d26980af342b37ac4c568_vp3.c.diff",
    "function_code": "static int vp3_decode_frame(AVCodecContext *avctx,\n                            void *data, int *got_frame,\n                            AVPacket *avpkt)\n{\n    AVFrame     *frame  = data;\n    const uint8_t *buf  = avpkt->data;\n    int buf_size        = avpkt->size;\n    Vp3DecodeContext *s = avctx->priv_data;\n    GetBitContext gb;\n    int i, ret;\n\n    if ((ret = init_get_bits8(&gb, buf, buf_size)) < 0)\n        return ret;\n\n#if CONFIG_THEORA_DECODER\n    if (s->theora && get_bits1(&gb)) {\n        int type = get_bits(&gb, 7);\n        skip_bits_long(&gb, 6*8); /* \"theora\" */\n\n        if (s->avctx->active_thread_type&FF_THREAD_FRAME) {\n            av_log(avctx, AV_LOG_ERROR, \"midstream reconfiguration with multithreading is unsupported, try -threads 1\\n\");\n            return AVERROR_PATCHWELCOME;\n        }\n        if (type == 0) {\n            vp3_decode_end(avctx);\n            ret = theora_decode_header(avctx, &gb);\n\n            if (ret >= 0)\n                ret = vp3_decode_init(avctx);\n            if (ret < 0) {\n                vp3_decode_end(avctx);\n                return ret;\n            }\n            return buf_size;\n        } else if (type == 2) {\n            vp3_decode_end(avctx);\n            ret = theora_decode_tables(avctx, &gb);\n            if (ret >= 0)\n                ret = vp3_decode_init(avctx);\n            if (ret < 0) {\n                vp3_decode_end(avctx);\n                return ret;\n            }\n            return buf_size;\n        }\n\n        av_log(avctx, AV_LOG_ERROR,\n               \"Header packet passed to frame decoder, skipping\\n\");\n        return -1;\n    }\n#endif\n\n    s->keyframe = !get_bits1(&gb);\n    if (!s->all_fragments) {\n        av_log(avctx, AV_LOG_ERROR, \"Data packet without prior valid headers\\n\");\n        return -1;\n    }\n    if (!s->theora)\n        skip_bits(&gb, 1);\n    for (i = 0; i < 3; i++)\n        s->last_qps[i] = s->qps[i];\n\n    s->nqps = 0;\n    do {\n        s->qps[s->nqps++] = get_bits(&gb, 6);\n    } while (s->theora >= 0x030200 && s->nqps < 3 && get_bits1(&gb));\n    for (i = s->nqps; i < 3; i++)\n        s->qps[i] = -1;\n\n    if (s->avctx->debug & FF_DEBUG_PICT_INFO)\n        av_log(s->avctx, AV_LOG_INFO, \" VP3 %sframe #%d: Q index = %d\\n\",\n               s->keyframe ? \"key\" : \"\", avctx->frame_number + 1, s->qps[0]);\n\n    s->skip_loop_filter = !s->filter_limit_values[s->qps[0]] ||\n                          avctx->skip_loop_filter >= (s->keyframe ? AVDISCARD_ALL\n                                                                  : AVDISCARD_NONKEY);\n\n    if (s->qps[0] != s->last_qps[0])\n        init_loop_filter(s);\n\n    for (i = 0; i < s->nqps; i++)\n        // reinit all dequantizers if the first one changed, because\n        // the DC of the first quantizer must be used for all matrices\n        if (s->qps[i] != s->last_qps[i] || s->qps[0] != s->last_qps[0])\n            init_dequantizer(s, i);\n\n    if (avctx->skip_frame >= AVDISCARD_NONKEY && !s->keyframe)\n        return buf_size;\n\n    s->current_frame.f->pict_type = s->keyframe ? AV_PICTURE_TYPE_I\n                                                : AV_PICTURE_TYPE_P;\n    s->current_frame.f->key_frame = s->keyframe;\n    if ((ret = ff_thread_get_ext_buffer(avctx, &s->current_frame,\n                                        AV_GET_BUFFER_FLAG_REF)) < 0)\n        goto error;\n\n    if (!s->edge_emu_buffer) {\n        s->edge_emu_buffer = av_malloc(9 * FFABS(s->current_frame.f->linesize[0]));\n        if (!s->edge_emu_buffer) {\n            ret = AVERROR(ENOMEM);\n            goto error;\n        }\n    }\n\n    if (s->keyframe) {\n        if (!s->theora) {\n            skip_bits(&gb, 4); /* width code */\n            skip_bits(&gb, 4); /* height code */\n            if (s->version) {\n                int version = get_bits(&gb, 5);\n#if !CONFIG_VP4_DECODER\n                if (version >= 2) {\n                    av_log(avctx, AV_LOG_ERROR, \"This build does not support decoding VP4.\\n\");\n                    return AVERROR_DECODER_NOT_FOUND;\n                }\n#endif\n                s->version = version;\n                if (avctx->frame_number == 0)\n                    av_log(s->avctx, AV_LOG_DEBUG,\n                           \"VP version: %d\\n\", s->version);\n            }\n        }\n        if (s->version || s->theora) {\n            if (get_bits1(&gb))\n                av_log(s->avctx, AV_LOG_ERROR,\n                       \"Warning, unsupported keyframe coding type?!\\n\");\n            skip_bits(&gb, 2); /* reserved? */\n\n#if CONFIG_VP4_DECODER\n            if (s->version >= 2) {\n                int mb_height, mb_width;\n                int mb_width_mul, mb_width_div, mb_height_mul, mb_height_div;\n\n                mb_height = get_bits(&gb, 8);\n                mb_width  = get_bits(&gb, 8);\n                if (mb_height != s->macroblock_height ||\n                    mb_width != s->macroblock_width)\n                    avpriv_request_sample(s->avctx, \"macroblock dimension mismatch\");\n\n                mb_width_mul = get_bits(&gb, 5);\n                mb_width_div = get_bits(&gb, 3);\n                mb_height_mul = get_bits(&gb, 5);\n                mb_height_div = get_bits(&gb, 3);\n                if (mb_width_mul != 1 || mb_width_div != 1 || mb_height_mul != 1 || mb_height_div != 1)\n                    avpriv_request_sample(s->avctx, \"unexpected macroblock dimension multipler/divider\");\n\n                if (get_bits(&gb, 2))\n                    avpriv_request_sample(s->avctx, \"unknown bits\");\n            }\n#endif\n        }\n    } else {\n        if (!s->golden_frame.f->data[0]) {\n            av_log(s->avctx, AV_LOG_WARNING,\n                   \"vp3: first frame not a keyframe\\n\");\n\n            s->golden_frame.f->pict_type = AV_PICTURE_TYPE_I;\n            if ((ret = ff_thread_get_ext_buffer(avctx, &s->golden_frame,\n                                                AV_GET_BUFFER_FLAG_REF)) < 0)\n                goto error;\n            ff_thread_release_ext_buffer(avctx, &s->last_frame);\n            if ((ret = ff_thread_ref_frame(&s->last_frame,\n                                           &s->golden_frame)) < 0)\n                goto error;\n            ff_thread_report_progress(&s->last_frame, INT_MAX, 0);\n        }\n    }\n\n    memset(s->all_fragments, 0, s->fragment_count * sizeof(Vp3Fragment));\n    ff_thread_finish_setup(avctx);\n\n    if (s->version < 2) {\n        if ((ret = unpack_superblocks(s, &gb)) < 0) {\n            av_log(s->avctx, AV_LOG_ERROR, \"error in unpack_superblocks\\n\");\n            goto error;\n        }\n#if CONFIG_VP4_DECODER\n    } else {\n        if ((ret = vp4_unpack_macroblocks(s, &gb)) < 0) {\n            av_log(s->avctx, AV_LOG_ERROR, \"error in vp4_unpack_macroblocks\\n\");\n            goto error;\n    }\n#endif\n    }\n    if ((ret = unpack_modes(s, &gb)) < 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"error in unpack_modes\\n\");\n        goto error;\n    }\n    if (ret = unpack_vectors(s, &gb)) {\n        av_log(s->avctx, AV_LOG_ERROR, \"error in unpack_vectors\\n\");\n        goto error;\n    }\n    if ((ret = unpack_block_qpis(s, &gb)) < 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"error in unpack_block_qpis\\n\");\n        goto error;\n    }\n\n    if (s->version < 2) {\n        if ((ret = unpack_dct_coeffs(s, &gb)) < 0) {\n            av_log(s->avctx, AV_LOG_ERROR, \"error in unpack_dct_coeffs\\n\");\n            goto error;\n        }\n#if CONFIG_VP4_DECODER\n    } else {\n        if ((ret = vp4_unpack_dct_coeffs(s, &gb)) < 0) {\n            av_log(s->avctx, AV_LOG_ERROR, \"error in vp4_unpack_dct_coeffs\\n\");\n            goto error;\n        }\n#endif\n    }\n\n    for (i = 0; i < 3; i++) {\n        int height = s->height >> (i && s->chroma_y_shift);\n        if (s->flipped_image)\n            s->data_offset[i] = 0;\n        else\n            s->data_offset[i] = (height - 1) * s->current_frame.f->linesize[i];\n    }\n\n    s->last_slice_end = 0;\n    for (i = 0; i < s->c_superblock_height; i++)\n        render_slice(s, i);\n\n    // filter the last row\n    if (s->version < 2)\n        for (i = 0; i < 3; i++) {\n            int row = (s->height >> (3 + (i && s->chroma_y_shift))) - 1;\n            apply_loop_filter(s, i, row, row + 1);\n        }\n    vp3_draw_horiz_band(s, s->height);\n\n    /* output frame, offset as needed */\n    if ((ret = av_frame_ref(data, s->current_frame.f)) < 0)\n        return ret;\n\n    frame->crop_left   = s->offset_x;\n    frame->crop_right  = avctx->coded_width - avctx->width - s->offset_x;\n    frame->crop_top    = s->offset_y;\n    frame->crop_bottom = avctx->coded_height - avctx->height - s->offset_y;\n\n    *got_frame = 1;\n\n    if (!HAVE_THREADS || !(s->avctx->active_thread_type & FF_THREAD_FRAME)) {\n        ret = update_frames(avctx);\n        if (ret < 0)\n            return ret;\n    }\n\n    return buf_size;\n\nerror:\n    ff_thread_report_progress(&s->current_frame, INT_MAX, 0);\n\n    if (!HAVE_THREADS || !(s->avctx->active_thread_type & FF_THREAD_FRAME))\n        av_frame_unref(s->current_frame.f);\n\n    return ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1215,
    "critical_vars": [
      "pck->stream"
    ],
    "function": "m2tsdmx_on_event",
    "filename": "gpac/CVE-2024-6063/CVE-2024-6063_CWE-476_8767ed0a77c4b02287db3723e92c2169f67c85d5_dmx_m2ts.c.diff",
    "function_code": "\nstatic void m2tsdmx_on_event(GF_M2TS_Demuxer *ts, u32 evt_type, void *param)\n{\n\tu32 i, count;\n\tGF_Filter *filter = (GF_Filter *) ts->user;\n\tGF_M2TSDmxCtx *ctx = gf_filter_get_udta(filter);\n\n\tswitch (evt_type) {\n\tcase GF_M2TS_EVT_PAT_UPDATE:\n\t\tbreak;\n\tcase GF_M2TS_EVT_AIT_FOUND:\n\t\tbreak;\n\tcase GF_M2TS_EVT_PAT_FOUND:\n\t\tif (ctx->mux_tune_state==DMX_TUNE_INIT) {\n\t\t\tctx->mux_tune_state = DMX_TUNE_WAIT_PROGS;\n\t\t\tctx->wait_for_progs = gf_list_count(ts->programs);\n\t\t}\n\t\tbreak;\n\tcase GF_M2TS_EVT_DSMCC_FOUND:\n\t\tbreak;\n\tcase GF_M2TS_EVT_PMT_FOUND:\n\t\tm2tsdmx_setup_program(ctx, param);\n\t\tif (ctx->mux_tune_state == DMX_TUNE_WAIT_PROGS) {\n\t\t\tgf_assert(ctx->wait_for_progs);\n\t\t\tctx->wait_for_progs--;\n\t\t\tif (!ctx->wait_for_progs) {\n\t\t\t\tctx->mux_tune_state = DMX_TUNE_WAIT_SEEK;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase GF_M2TS_EVT_PMT_REPEAT:\n\t\tbreak;\n\tcase GF_M2TS_EVT_PMT_UPDATE:\n\t\tm2tsdmx_setup_program(ctx, param);\n\t\tbreak;\n\n\tcase GF_M2TS_EVT_SDT_FOUND:\n\tcase GF_M2TS_EVT_SDT_UPDATE:\n//\tcase GF_M2TS_EVT_SDT_REPEAT:\n\t\tm2tsdmx_update_sdt(ts, NULL);\n\t\tbreak;\n\tcase GF_M2TS_EVT_DVB_GENERAL:\n\t\tif (ctx->eit_pid) {\n\t\t\tGF_M2TS_SL_PCK *pck = (GF_M2TS_SL_PCK *)param;\n\t\t\tu8 *data;\n\t\t\tGF_FilterPacket *dst_pck = gf_filter_pck_new_alloc(ctx->eit_pid, pck->data_len, &data);\n\t\t\tif (dst_pck) {\n\t\t\t\tmemcpy(data, pck->data, pck->data_len);\n\t\t\t\tgf_filter_pck_send(dst_pck);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase GF_M2TS_EVT_PES_PCK:\n\t\tif (ctx->mux_tune_state) break;\n\t\tm2tsdmx_send_packet(ctx, param);\n\t\tbreak;\n\tcase GF_M2TS_EVT_SL_PCK: /* DMB specific */\n\t\tif (ctx->mux_tune_state) break;\n\t\tm2tsdmx_send_sl_packet(ctx, param);\n\t\tbreak;\n\tcase GF_M2TS_EVT_PES_PCR:\n\t\tif (ctx->mux_tune_state) break;\n\t{\n\t\tu64 pcr;\n\t\tBool map_time = GF_FALSE;\n\t\tGF_M2TS_PES_PCK *pck = ((GF_M2TS_PES_PCK *) param);\n\t\tBool discontinuity = ( ((GF_M2TS_PES_PCK *) param)->flags & GF_M2TS_PES_PCK_DISCONTINUITY) ? 1 : 0;\n\n\t\tgf_fatal_assert(pck->stream);\n\t\tif (!ctx->sigfrag && ctx->index) {\n\t\t\tm2tsdmx_estimate_duration(ctx, (GF_M2TS_ES *) pck->stream);\n\t\t}\n\n\t\tif (ctx->map_time_on_prog_id && (ctx->map_time_on_prog_id==pck->stream->program->number)) {\n\t\t\tmap_time = GF_TRUE;\n\t\t}\n\n\t\t//we forward the PCR on each pid\n\t\tpcr = ((GF_M2TS_PES_PCK *) param)->PTS;\n\t\tpcr /= 300;\n\t\tcount = gf_list_count(pck->stream->program->streams);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_FilterPacket *dst_pck;\n\t\t\tGF_M2TS_PES *stream = gf_list_get(pck->stream->program->streams, i);\n\t\t\tif (!stream->user) continue;\n\n\t\t\tdst_pck = gf_filter_pck_new_shared(stream->user, NULL, 0, NULL);\n\t\t\tif (!dst_pck) continue;\n\n\t\t\tgf_filter_pck_set_cts(dst_pck, pcr);\n\t\t\tgf_filter_pck_set_clock_type(dst_pck, discontinuity ? GF_FILTER_CLOCK_PCR_DISC : GF_FILTER_CLOCK_PCR);\n\t\t\tif (pck->stream->is_seg_start) {\n\t\t\t\tpck->stream->is_seg_start = GF_FALSE;\n\t\t\t\tgf_filter_pck_set_property(dst_pck, GF_PROP_PCK_CUE_START, &PROP_BOOL(GF_TRUE));\n\t\t\t}\n\t\t\tgf_filter_pck_send(dst_pck);\n\n\t\t\tif (map_time && (stream->flags & GF_M2TS_ES_IS_PES) ) {\n\t\t\t\t((GF_M2TS_PES*)stream)->map_pcr = pcr;\n\t\t\t}\n\t\t}\n\n\t\tif (map_time) {\n\t\t\tctx->map_time_on_prog_id = 0;\n\t\t}\n\t}\n\t\tbreak;\n\n\tcase GF_M2TS_EVT_TDT:\n\t\tif (ctx->mux_tune_state) break;\n\t{\n\t\tGF_M2TS_TDT_TOT *tdt = (GF_M2TS_TDT_TOT *)param;\n\t\tu64 utc_ts = gf_net_get_utc_ts(tdt->year, tdt->month, tdt->day, tdt->hour, tdt->minute, tdt->second);\n\t\tcount = gf_list_count(ts->programs );\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_M2TS_Program *prog = gf_list_get(ts->programs, i);\n\t\t\tu32 j, count2 = gf_list_count(prog->streams);\n\t\t\tfor (j=0; j<count2; j++) {\n\t\t\t\tGF_M2TS_ES * stream = gf_list_get(prog->streams, j);\n\t\t\t\tif (stream->user && (stream->flags & GF_M2TS_ES_IS_PES)) {\n\t\t\t\t\tGF_M2TS_PES*pes = (GF_M2TS_PES*)stream;\n\t\t\t\t\tpes->map_utc = utc_ts;\n\t\t\t\t\tpes->map_utc_pcr = prog->last_pcr_value/300;\n\t\t\t\t}\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[M2TS In] Mapping TDT Time %04d-%02d-%02dT%02d:%02d:%02d and PCR time \"LLD\" on program %d\\n\",\n\t\t\t\t                                       tdt->year, tdt->month+1, tdt->day, tdt->hour, tdt->minute, tdt->second, prog->last_pcr_value/300, prog->number));\n\t\t}\n\t}\n\t\tbreak;\n\tcase GF_M2TS_EVT_TOT:\n\t\tbreak;\n\n\tcase GF_M2TS_EVT_DURATION_ESTIMATED:\n\t{\n\t\tu64 duration = ((GF_M2TS_PES_PCK *) param)->PTS;\n\t\tcount = gf_list_count(ts->programs);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_M2TS_Program *prog = gf_list_get(ts->programs, i);\n\t\t\tu32 j, count2;\n\t\t\tcount2 = gf_list_count(prog->streams);\n\t\t\tfor (j=0; j<count2; j++) {\n\t\t\t\tGF_M2TS_ES * stream = gf_list_get(prog->streams, j);\n\t\t\t\tif (stream->user) {\n\t\t\t\t\tgf_filter_pid_set_property(stream->user, GF_PROP_PID_DURATION, & PROP_FRAC64_INT(duration, 1000) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tbreak;\n\n\tcase GF_M2TS_EVT_TEMI_LOCATION:\n\t{\n\t\tGF_M2TS_TemiLocationDescriptor *temi_l = (GF_M2TS_TemiLocationDescriptor *)param;\n\t\tconst char *url;\n\t\tu32 len;\n\t\tGF_BitStream *bs;\n\t\tGF_M2TS_ES *es=NULL;\n\t\tGF_M2TS_Prop_TEMIInfo *t;\n\t\tif ((temi_l->pid<8192) && (ctx->ts->ess[temi_l->pid])) {\n\t\t\tes = ctx->ts->ess[temi_l->pid];\n\t\t}\n\t\tif (!es || !es->user) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[M2TSDmx] TEMI location not assigned to a given PID, not supported\\n\"));\n\t\t\tbreak;\n\t\t}\n\t\tGF_SAFEALLOC(t, GF_M2TS_Prop_TEMIInfo);\n\t\tif (!t) break;\n\t\tt->timeline_id = temi_l->timeline_id;\n\t\tt->is_loc = GF_TRUE;\n\n\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tif (ctx->temi_url)\n\t\t\turl = ctx->temi_url;\n\t\telse\n\t\t\turl = temi_l->external_URL;\n\t\tlen = url ? (u32) strlen(url) : 0;\n\t\tgf_bs_write_data(bs, url, len);\n\t\tgf_bs_write_u8(bs, 0);\n\t\tgf_bs_write_int(bs, temi_l->is_announce, 1);\n\t\tgf_bs_write_int(bs, temi_l->is_splicing, 1);\n\t\tgf_bs_write_int(bs, temi_l->reload_external, 1);\n\t\tgf_bs_write_int(bs, 0, 5);\n\t\tif (temi_l->is_announce) {\n\t\t\tgf_bs_write_u32(bs, temi_l->activation_countdown.den);\n\t\t\tgf_bs_write_u32(bs, temi_l->activation_countdown.num);\n\t\t}\n\t\tgf_bs_get_content(bs, &t->data, &t->len);\n\t\tgf_bs_del(bs);\n\n\t\tif (!es->props) {\n\t\t\tes->props = gf_list_new();\n\t\t}\n\t\tgf_list_add(es->props, t);\n\t}\n\tbreak;\n\tcase GF_M2TS_EVT_TEMI_TIMECODE:\n\t{\n\t\tGF_M2TS_TemiTimecodeDescriptor *temi_t = (GF_M2TS_TemiTimecodeDescriptor*)param;\n\t\tGF_BitStream *bs;\n\t\tGF_M2TS_Prop_TEMIInfo *t;\n\t\tGF_M2TS_ES *es=NULL;\n\t\tif ((temi_t->pid<8192) && (ctx->ts->ess[temi_t->pid])) {\n\t\t\tes = ctx->ts->ess[temi_t->pid];\n\t\t}\n\t\tif (!es || !es->user) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[M2TSDmx] TEMI timing not assigned to a given PID, not supported\\n\"));\n\t\t\tbreak;\n\t\t}\n\t\tGF_SAFEALLOC(t, GF_M2TS_Prop_TEMIInfo);\n\t\tif (!t) break;\n\t\tt->type = M2TS_TEMI_INFO;\n\t\tt->timeline_id = temi_t->timeline_id;\n\n\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tgf_bs_write_u32(bs, temi_t->media_timescale);\n\t\tgf_bs_write_u64(bs, temi_t->media_timestamp);\n\t\tgf_bs_write_u64(bs, temi_t->pes_pts);\n\t\tgf_bs_write_int(bs, temi_t->force_reload, 1);\n\t\tgf_bs_write_int(bs, temi_t->is_paused, 1);\n\t\tgf_bs_write_int(bs, temi_t->is_discontinuity, 1);\n\t\tgf_bs_write_int(bs, temi_t->ntp ? 1 : 0, 1);\n\t\tgf_bs_write_int(bs, 0, 4);\n\t\tif (temi_t->ntp)\n\t\t\tgf_bs_write_u64(bs, temi_t->ntp);\n\n\t\tgf_bs_get_content(bs, &t->data, &t->len);\n\t\tgf_bs_del(bs);\n\n\t\tif (!es->props) {\n\t\t\tes->props = gf_list_new();\n\t\t}\n\t\tgf_list_add(es->props, t);\n\t}\n\tbreak;\n\tcase GF_M2TS_EVT_ID3:\n\t{\n\t\tGF_M2TS_PES_PCK *pck = (GF_M2TS_PES_PCK*)param;\n\t\tGF_BitStream *bs;\n\t\tGF_M2TS_Prop *t;\n\t\tu32 count = gf_list_count(pck->stream->program->streams);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_M2TS_PES *es = gf_list_get(pck->stream->program->streams, i);\n\t\t\tif (!es->user) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[M2TSDmx] ID3 metadata not assigned to a given PID, not supported\\n\"));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// attach ID3 markers to audio\n\t\t\tGF_FilterPid *opid = (GF_FilterPid *)es->user;\n\t\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property(opid, GF_PROP_PID_STREAM_TYPE);\n\t\t\tif (!p) return;\n\t\t\tif (p->value.uint != GF_STREAM_AUDIO)\n\t\t\t\tcontinue;\n\n\t\t\tGF_SAFEALLOC(t, GF_M2TS_Prop);\n\t\t\tif (!t) break;\n\t\t\tt->type = M2TS_ID3;\n\t\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\tgf_bs_write_u32(bs, 90000);                     // timescale\n\t\t\tgf_bs_write_u64(bs, pck->PTS);                  // pts\n\t\t\tgf_bs_write_u32(bs, pck->data_len);\t\t\t\t// data length (bytes)\n\t\t\tgf_bs_write_data(bs, pck->data, pck->data_len); // data\n\t\t\tgf_bs_get_content(bs, &t->data, &t->len);\n\t\t\tgf_bs_del(bs);\n\n\t\t\tif (!es->props) {\n\t\t\t\tes->props = gf_list_new();\n\t\t\t}\n\t\t\tgf_list_add(es->props, t);\n\t\t}\n\t}\n\tbreak;\n\tcase GF_M2TS_EVT_SCTE35_SPLICE_INFO:\n\t{\n\t\tGF_M2TS_SL_PCK *pck = (GF_M2TS_SL_PCK*)param;\n\t\tGF_BitStream *bs;\n\t\tGF_M2TS_Prop *t;\n\n\t\t//for now all SCTE35 must be associated with a stream\n\t\tif (!pck->stream) return;\n\n\t\t// convey SCTE35 splice info to all streams of the program\n\t\tu32 count = gf_list_count(pck->stream->program->streams);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_M2TS_PES *es = gf_list_get(pck->stream->program->streams, i);\n\t\t\tif (!es->user) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[M2TSDmx] SCTE35 section not assigned to a given PID, not supported\\n\"));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// attach SCTE35 info to video only\n\t\t\tGF_FilterPid *opid = (GF_FilterPid *)es->user;\n\t\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property(opid, GF_PROP_PID_STREAM_TYPE);\n\t\t\tif (!p) return;\n\t\t\tif (p->value.uint != GF_STREAM_VISUAL)\n\t\t\t\tcontinue;\n\n\t\t\tGF_SAFEALLOC(t, GF_M2TS_Prop);\n\t\t\tif (!t) break;\n\t\t\tt->type = M2TS_SCTE35;\n\t\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\t// ANSI/SCTE 67 2017 (13.1.1.3): \"the entire SCTE 35 splice_info_section starting at the table_id and ending with the CRC_32\"\n\t\t\tgf_bs_write_data(bs, pck->data, pck->data_len);\n\t\t\tgf_bs_get_content(bs, &t->data, &t->len);\n\t\t\tgf_bs_del(bs);\n\n\t\t\tif (!es->props) {\n\t\t\t\tes->props = gf_list_new();\n\t\t\t}\n\t\t\tgf_list_add(es->props, t);\n\n\t\t\t// send SCTE35 info only to the first video pid\n\t\t\tbreak;\n\t\t}\n\t}\n\tbreak;\n\tcase GF_M2TS_EVT_STREAM_REMOVED:\n\t{\n\t\tGF_M2TS_ES *es = (GF_M2TS_ES *)param;\n\t\tif (es && es->props) {\n\t\t\twhile (gf_list_count(es->props)) {\n\t\t\t\tGF_M2TS_Prop *t = gf_list_pop_back(es->props);\n\t\t\t\tgf_free(t->data);\n\t\t\t\tgf_free(t);\n\t\t\t}\n\t\t\tgf_list_del(es->props);\n\t\t}\n\t}\n\t\tbreak;\n\t}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 451,
    "critical_vars": [
      "*data",
      "*output"
    ],
    "function": "latm_dmx_process",
    "filename": "gpac/CVE-2021-30199/CVE-2021-30199_CWE-476_b2db2f99b4c30f96e17b9a14537c776da6cb5dca_reframe_latm.c.diff",
    "function_code": "GF_Err latm_dmx_process(GF_Filter *filter)\n{\n\tGF_LATMDmxCtx *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *pck, *dst_pck;\n\tu32 pos;\n\tu8 *data, *output;\n\tu32 pck_size, prev_pck_size;\n\tu64 cts = GF_FILTER_NO_TS;\n\n\tif (ctx->in_error)\n\t\treturn ctx->in_error;\n\n\t//always reparse duration\n\tif (!ctx->duration.num)\n\t\tlatm_dmx_check_dur(filter, ctx);\n\n\tif (ctx->opid && !ctx->is_playing)\n\t\treturn GF_OK;\n\n\tpck = gf_filter_pid_get_packet(ctx->ipid);\n\tif (!pck) {\n\t\tif (gf_filter_pid_is_eos(ctx->ipid)) {\n\t\t\tif (!ctx->latm_buffer_size) {\n\t\t\t\tif (ctx->opid)\n\t\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\t\tctx->src_pck = NULL;\n\t\t\t\treturn GF_EOS;\n\t\t\t}\n\t\t} else {\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\tdata = (char *) gf_filter_pck_get_data(pck, &pck_size);\n\n\t//input pid sets some timescale - we flushed pending data , update cts\n\tif (ctx->timescale && pck) {\n\t\tcts = gf_filter_pck_get_cts(pck);\n\t}\n\n\tprev_pck_size = ctx->latm_buffer_size;\n\n\tif (pck && !ctx->resume_from) {\n\t\tif (ctx->latm_buffer_size + pck_size > ctx->latm_buffer_alloc) {\n\t\t\tctx->latm_buffer_alloc = ctx->latm_buffer_size + pck_size;\n\t\t\tctx->latm_buffer = gf_realloc(ctx->latm_buffer, ctx->latm_buffer_alloc);\n\t\t}\n\t\tmemcpy(ctx->latm_buffer + ctx->latm_buffer_size, data, pck_size);\n\t\tctx->latm_buffer_size += pck_size;\n\t}\n\n\tif (!ctx->bs) ctx->bs = gf_bs_new(ctx->latm_buffer, ctx->latm_buffer_size, GF_BITSTREAM_READ);\n\telse gf_bs_reassign_buffer(ctx->bs, ctx->latm_buffer, ctx->latm_buffer_size);\n\n\tif (ctx->resume_from) {\n\t\tgf_bs_seek(ctx->bs, ctx->resume_from-1);\n\t\tctx->resume_from = 0;\n\t}\n\n\tif (cts == GF_FILTER_NO_TS)\n\t\tprev_pck_size = 0;\n\n\n\twhile (1) {\n\t\tpos = (u32) gf_bs_get_position(ctx->bs);\n\t\tu8 latm_buffer[4096];\n\t\tu32 latm_frame_size = 4096;\n\t\tif (!latm_dmx_sync_frame_bs(ctx->bs,&ctx->acfg, &latm_frame_size, latm_buffer, NULL)) break;\n\n\t\tif (ctx->in_seek) {\n\t\t\tu64 nb_samples_at_seek = (u64) (ctx->start_range * GF_M4ASampleRates[ctx->sr_idx]);\n\t\t\tif (ctx->cts + ctx->dts_inc >= nb_samples_at_seek) {\n\t\t\t\t//u32 samples_to_discard = (ctx->cts + ctx->dts_inc) - nb_samples_at_seek;\n\t\t\t\tctx->in_seek = GF_FALSE;\n\t\t\t}\n\t\t}\n\n\t\tlatm_dmx_check_pid(filter, ctx);\n\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->resume_from = pos+1;\n\t\t\treturn GF_OK;\n\t\t}\n\n\t\tif (!ctx->in_seek) {\n\t\t\tGF_FilterSAPType sap = GF_FILTER_SAP_1;\n\n\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, latm_frame_size, &output);\n\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\n\t\t\tmemcpy(output, latm_buffer, latm_frame_size);\n\n\t\t\tgf_filter_pck_set_cts(dst_pck, ctx->cts);\n\t\t\tgf_filter_pck_set_duration(dst_pck, ctx->dts_inc);\n\t\t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);\n\n\t\t\t/*xHE-AAC, check RAP*/\n\t\t\tif (ctx->acfg.base_object_type==GF_CODECID_USAC) {\n\t\t\t\tif (latm_frame_size && (output[0] & 0x80) && !ctx->prev_sap) {\n\t\t\t\t\tsap = GF_FILTER_SAP_1;\n\t\t\t\t\tctx->prev_sap = GF_TRUE;\n\t\t\t\t} else {\n\t\t\t\t\tsap = GF_FILTER_SAP_NONE;\n\t\t\t\t\tctx->prev_sap = GF_FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_filter_pck_set_sap(dst_pck, sap);\n\n\t\t\tgf_filter_pck_send(dst_pck);\n\t\t}\n\t\tlatm_dmx_update_cts(ctx);\n\n\t\tif (prev_pck_size) {\n\t\t\tpos = (u32) gf_bs_get_position(ctx->bs);\n\t\t\tif (prev_pck_size<=pos) {\n\t\t\t\tprev_pck_size=0;\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\t\tctx->src_pck = pck;\n\t\t\t\tif (pck)\n\t\t\t\t\tgf_filter_pck_ref_props(&ctx->src_pck);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pck) {\n\t\tpos = (u32) gf_bs_get_position(ctx->bs);\n\t\tassert(ctx->latm_buffer_size >= pos);\n\t\tmemmove(ctx->latm_buffer, ctx->latm_buffer+pos, ctx->latm_buffer_size - pos);\n\t\tctx->latm_buffer_size -= pos;\n\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\tassert(!ctx->resume_from);\n\t} else {\n\t\tctx->latm_buffer_size = 0;\n\t\treturn latm_dmx_process(filter);\n\t}\n\treturn GF_OK;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 451,
    "critical_vars": [
      "*data"
    ],
    "function": "latm_dmx_process",
    "filename": "gpac/CVE-2021-30199/CVE-2021-30199_CWE-476_b2db2f99b4c30f96e17b9a14537c776da6cb5dca_reframe_latm.c.diff",
    "function_code": "GF_Err latm_dmx_process(GF_Filter *filter)\n{\n\tGF_LATMDmxCtx *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *pck, *dst_pck;\n\tu32 pos;\n\tu8 *data=NULL, *output;\n\tu32 pck_size=0, prev_pck_size;\n\tu64 cts = GF_FILTER_NO_TS;\n\n\tif (ctx->in_error)\n\t\treturn ctx->in_error;\n\n\t//always reparse duration\n\tif (!ctx->duration.num)\n\t\tlatm_dmx_check_dur(filter, ctx);\n\n\tif (ctx->opid && !ctx->is_playing)\n\t\treturn GF_OK;\n\n\tpck = gf_filter_pid_get_packet(ctx->ipid);\n\tif (!pck) {\n\t\tif (gf_filter_pid_is_eos(ctx->ipid)) {\n\t\t\tif (!ctx->latm_buffer_size) {\n\t\t\t\tif (ctx->opid)\n\t\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\t\tctx->src_pck = NULL;\n\t\t\t\treturn GF_EOS;\n\t\t\t}\n\t\t} else {\n\t\t\treturn GF_OK;\n\t\t}\n\t} else {\n\t\tdata = (char *) gf_filter_pck_get_data(pck, &pck_size);\n\t}\n\n\t//input pid sets some timescale - we flushed pending data , update cts\n\tif (ctx->timescale && pck) {\n\t\tcts = gf_filter_pck_get_cts(pck);\n\t}\n\n\tprev_pck_size = ctx->latm_buffer_size;\n\n\tif (pck && !ctx->resume_from) {\n\t\tif (ctx->latm_buffer_size + pck_size > ctx->latm_buffer_alloc) {\n\t\t\tctx->latm_buffer_alloc = ctx->latm_buffer_size + pck_size;\n\t\t\tctx->latm_buffer = gf_realloc(ctx->latm_buffer, ctx->latm_buffer_alloc);\n\t\t}\n\t\tmemcpy(ctx->latm_buffer + ctx->latm_buffer_size, data, pck_size);\n\t\tctx->latm_buffer_size += pck_size;\n\t}\n\n\tif (!ctx->bs) ctx->bs = gf_bs_new(ctx->latm_buffer, ctx->latm_buffer_size, GF_BITSTREAM_READ);\n\telse gf_bs_reassign_buffer(ctx->bs, ctx->latm_buffer, ctx->latm_buffer_size);\n\n\tif (ctx->resume_from) {\n\t\tgf_bs_seek(ctx->bs, ctx->resume_from-1);\n\t\tctx->resume_from = 0;\n\t}\n\n\tif (cts == GF_FILTER_NO_TS)\n\t\tprev_pck_size = 0;\n\n\n\twhile (1) {\n\t\tpos = (u32) gf_bs_get_position(ctx->bs);\n\t\tu8 latm_buffer[4096];\n\t\tu32 latm_frame_size = 4096;\n\t\tif (!latm_dmx_sync_frame_bs(ctx->bs,&ctx->acfg, &latm_frame_size, latm_buffer, NULL)) break;\n\n\t\tif (ctx->in_seek) {\n\t\t\tu64 nb_samples_at_seek = (u64) (ctx->start_range * GF_M4ASampleRates[ctx->sr_idx]);\n\t\t\tif (ctx->cts + ctx->dts_inc >= nb_samples_at_seek) {\n\t\t\t\t//u32 samples_to_discard = (ctx->cts + ctx->dts_inc) - nb_samples_at_seek;\n\t\t\t\tctx->in_seek = GF_FALSE;\n\t\t\t}\n\t\t}\n\n\t\tlatm_dmx_check_pid(filter, ctx);\n\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->resume_from = pos+1;\n\t\t\treturn GF_OK;\n\t\t}\n\n\t\tif (!ctx->in_seek) {\n\t\t\tGF_FilterSAPType sap = GF_FILTER_SAP_1;\n\n\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, latm_frame_size, &output);\n\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\n\t\t\tmemcpy(output, latm_buffer, latm_frame_size);\n\n\t\t\tgf_filter_pck_set_cts(dst_pck, ctx->cts);\n\t\t\tgf_filter_pck_set_duration(dst_pck, ctx->dts_inc);\n\t\t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);\n\n\t\t\t/*xHE-AAC, check RAP*/\n\t\t\tif (ctx->acfg.base_object_type==GF_CODECID_USAC) {\n\t\t\t\tif (latm_frame_size && (output[0] & 0x80) && !ctx->prev_sap) {\n\t\t\t\t\tsap = GF_FILTER_SAP_1;\n\t\t\t\t\tctx->prev_sap = GF_TRUE;\n\t\t\t\t} else {\n\t\t\t\t\tsap = GF_FILTER_SAP_NONE;\n\t\t\t\t\tctx->prev_sap = GF_FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_filter_pck_set_sap(dst_pck, sap);\n\n\t\t\tgf_filter_pck_send(dst_pck);\n\t\t}\n\t\tlatm_dmx_update_cts(ctx);\n\n\t\tif (prev_pck_size) {\n\t\t\tpos = (u32) gf_bs_get_position(ctx->bs);\n\t\t\tif (prev_pck_size<=pos) {\n\t\t\t\tprev_pck_size=0;\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\t\tctx->src_pck = pck;\n\t\t\t\tif (pck)\n\t\t\t\t\tgf_filter_pck_ref_props(&ctx->src_pck);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pck) {\n\t\tpos = (u32) gf_bs_get_position(ctx->bs);\n\t\tassert(ctx->latm_buffer_size >= pos);\n\t\tmemmove(ctx->latm_buffer, ctx->latm_buffer+pos, ctx->latm_buffer_size - pos);\n\t\tctx->latm_buffer_size -= pos;\n\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\tassert(!ctx->resume_from);\n\t} else {\n\t\tctx->latm_buffer_size = 0;\n\t\treturn latm_dmx_process(filter);\n\t}\n\treturn GF_OK;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1111,
    "critical_vars": [
      "esd->decoderConfig"
    ],
    "function": "gf_media_export_filters",
    "filename": "gpac/CVE-2021-32438/CVE-2021-32438_CWE-476_00194f5fe462123f70b0bae7987317b52898b868_media_export.c.diff",
    "function_code": "static GF_Err gf_media_export_filters(GF_MediaExporter *dumper)\n{\n\tchar *args, szSubArgs[1024], szExt[30];\n\tGF_Filter *file_out, *reframer, *remux=NULL, *src_filter;\n\tGF_FilterSession *fsess;\n\tGF_Err e = GF_OK;\n\tu32 codec_id=0;\n\tu32 sample_count=0;\n\tBool skip_write_filter = GF_FALSE;\n\tBool ext_forced = GF_FALSE;\n\tBool use_dynext = GF_FALSE;\n\n\targs = NULL;\n\tstrcpy(szExt, \"\");\n\tif (dumper->trackID && dumper->file) {\n\t\tu32 msubtype = 0;\n\t\tu32 mtype = 0;\n\t\tu32 afmt = 0;\n\t\tGF_PixelFormat pfmt = 0;\n\t\tGF_ESD *esd;\n\t\tconst char *export_ext = dumper->out_name ? gf_file_ext_start(dumper->out_name) : NULL;\n\t\tu32 track_num = gf_isom_get_track_by_id(dumper->file, dumper->trackID);\n\t\tif (!track_num) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] No tracks with ID %d in file\\n\", dumper->trackID));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\tesd = gf_media_map_esd(dumper->file, track_num, 0);\n\t\tsample_count = gf_isom_get_sample_count(dumper->file, dumper->trackID);\n\t\tif (esd && esd->decoderConfig) {\n\t\t\tif (esd->decoderConfig->objectTypeIndication<GF_CODECID_LAST_MPEG4_MAPPING) {\n\t\t\t\tcodec_id = gf_codecid_from_oti(esd->decoderConfig->streamType, esd->decoderConfig->objectTypeIndication);\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\tif (esd->decoderConfig->decoderSpecificInfo && (codec_id==GF_CODECID_AAC_MPEG4)) {\n\t\t\t\t\tGF_M4ADecSpecInfo acfg;\n\t\t\t\t\tgf_m4a_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &acfg);\n\t\t\t\t\tif (acfg.base_object_type == GF_M4A_USAC)\n\t\t\t\t\t\tcodec_id = GF_CODECID_USAC;\n\t\t\t\t}\n#endif\n\t\t\t} else {\n\t\t\t\tcodec_id = esd->decoderConfig->objectTypeIndication;\n\t\t\t}\n\t\t}\n\t\tif (!codec_id) {\n\t\t\tmsubtype = gf_isom_get_media_subtype(dumper->file, track_num, 1);\n\t\t\tcodec_id = gf_codec_id_from_isobmf(msubtype);\n\t\t}\n\t\tmtype = gf_isom_get_media_type(dumper->file, track_num);\n\t\tif (!codec_id) {\n\t\t\tpfmt = gf_pixel_fmt_from_qt_type(msubtype);\n\t\t\tif (pfmt) codec_id = GF_CODECID_RAW;\n\t\t}\n\n\t\tif (!codec_id) {\n\t\t\tstrcpy(szExt, gf_4cc_to_str(msubtype));\n\t\t\text_forced = GF_TRUE;\n\t\t} else if (codec_id==GF_CODECID_RAW) {\n\t\t\tswitch (mtype) {\n\t\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\t\tcase GF_ISOM_MEDIA_AUXV:\n\t\t\tcase GF_ISOM_MEDIA_PICT:\n\t\t\t\tif (pfmt)\n\t\t\t\t\tstrcpy(szExt, gf_pixel_fmt_sname(pfmt));\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\t\tafmt = gf_audio_fmt_from_isobmf(msubtype);\n\t\t\t\tif (afmt)\n\t\t\t\t\tstrcpy(szExt, gf_audio_fmt_name(afmt));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstrcpy(szExt, gf_4cc_to_str(msubtype));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tconst char *sname = gf_codecid_file_ext(codec_id);\n\t\t\tif (export_ext && strstr(sname, export_ext+1)) {\n\t\t\t\tszExt[0]=0;\n\t\t\t} else {\n\t\t\t\tchar *sep;\n\t\t\t\tstrncpy(szExt, sname, 29);\n\t\t\t\tszExt[29]=0;\n\t\t\t\tsep = strchr(szExt, '|');\n\t\t\t\tif (sep) sep[0] = 0;\n\t\t\t}\n\t\t}\n\t\tswitch (mtype) {\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\tcase GF_ISOM_MEDIA_AUXV:\n\t\tcase GF_ISOM_MEDIA_PICT:\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\tskip_write_filter = codec_id ? GF_TRUE : GF_FALSE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tswitch (codec_id) {\n\t\t\tcase GF_CODECID_WEBVTT:\n\t\t\t\tskip_write_filter = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tcase GF_CODECID_META_TEXT:\n\t\t\tcase GF_CODECID_META_XML:\n\t\t\tcase GF_CODECID_SUBS_TEXT:\n\t\t\tcase GF_CODECID_SUBS_XML:\n\t\t\tcase GF_CODECID_SIMPLE_TEXT:\n\t\t\t\t//use dynamic extension\n\t\t\t\tszExt[0] = 0;\n\t\t\t\tuse_dynext = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t//TODO, move these two to filters one of these days\n\t\tif ((codec_id==GF_CODECID_VORBIS) || (codec_id==GF_CODECID_THEORA) || (codec_id==GF_CODECID_OPUS)) {\n\t\t\tchar *outname = dumper->out_name;\n\t\t\tif (outname && !strcmp(outname, \"std\")) outname=NULL;\n\t\t\tif (esd) gf_odf_desc_del((GF_Descriptor *) esd);\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\treturn gf_dump_to_ogg(dumper, outname, track_num);\n#else\n\t\t\treturn GF_NOT_SUPPORTED;\n#endif\n\n\t\t}\n\t\tif (codec_id==GF_CODECID_SUBPIC) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\tchar *dsi = NULL;\n\t\t\tu32 dsi_size = 0;\n\t\t\tif (esd && esd->decoderConfig && esd->decoderConfig->decoderSpecificInfo) {\n\t\t\t\tdsi = esd->decoderConfig->decoderSpecificInfo->data;\n\t\t\t\tdsi_size = esd->decoderConfig->decoderSpecificInfo->dataLength;\n\t\t\t}\n\t\t\te = gf_dump_to_vobsub(dumper, dumper->out_name, track_num, dsi, dsi_size);\n#else\n\t\t\te = GF_NOT_SUPPORTED;\n#endif\n\t\t\tif (esd) gf_odf_desc_del((GF_Descriptor *) esd);\n\t\t\treturn e;\n\t\t}\n\t\tif (esd) gf_odf_desc_del((GF_Descriptor *) esd);\n\t} else {\n\t\tconst char *export_ext = dumper->out_name ? gf_file_ext_start(dumper->out_name) : NULL;\n\t\tskip_write_filter = GF_TRUE;\n\t\tif (!export_ext)\n\t\t\tuse_dynext = GF_TRUE;\n\t}\n\n\tfsess = gf_fs_new_defaults(0);\n\tif (!fsess) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Failed to create filter session\\n\"));\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tfile_out = NULL;\n\targs = NULL;\n\n\tif (dumper->flags & GF_EXPORT_REMUX) {\n\t\tfile_out = gf_fs_load_destination(fsess, dumper->out_name, NULL, NULL, &e);\n\t\tif (!file_out) {\n\t\t\tgf_fs_del(fsess);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot open destination %s\\n\", dumper->out_name));\n\t\t\treturn e;\n\t\t}\n\t}\n\t//except in nhml inband file dump, create a sink filter\n\telse if (!dumper->dump_file) {\n\t\tBool no_ext = (dumper->flags & GF_EXPORT_NO_FILE_EXT) ? GF_TRUE : GF_FALSE;\n\t\tchar *ext = gf_file_ext_start(dumper->out_name);\n\t\t//mux args, for now we only dump to file\n\t\te = gf_dynstrcat(&args, \"fout:dst=\", NULL);\n\t\te |= gf_dynstrcat(&args, dumper->out_name, NULL);\n\n\t\tif (dumper->flags & GF_EXPORT_NHNT) {\n\t\t\tstrcpy(szExt, \"nhnt\");\n\t\t\te |= gf_dynstrcat(&args, \":clone\", NULL);\n\t\t\tno_ext = GF_TRUE;\n\t\t\tif (!ext)\n\t\t\t\te |= gf_dynstrcat(&args, \":dynext\", NULL);\n\t\t} else if (dumper->flags & GF_EXPORT_NHML) {\n\t\t\tstrcpy(szExt, \"nhml\");\n\t\t\te |= gf_dynstrcat(&args, \":clone\", NULL);\n\t\t\tno_ext = GF_TRUE;\n\t\t\tif (!ext)\n\t\t\t\te |= gf_dynstrcat(&args, \":dynext\", NULL);\n\t\t}\n\n\t\tif (dumper->flags & GF_EXPORT_RAW_SAMPLES) {\n\t\t\tif (!dumper->sample_num) {\n\n\t\t\t\text = gf_file_ext_start(args);\n\t\t\t\tif (ext) ext[0] = 0;\n\t\t\t\tif (sample_count>=1000) {\n\t\t\t\t\te |= gf_dynstrcat(&args, \"_$num%08d$\", NULL);\n\t\t\t\t} else if (sample_count) {\n\t\t\t\t\te |= gf_dynstrcat(&args, \"_$num%03d$\", NULL);\n\t\t\t\t} else {\n\t\t\t\t\te |= gf_dynstrcat(&args, \"_$num$\", NULL);\n\t\t\t\t}\n\t\t\t\text = gf_file_ext_start(dumper->out_name);\n\t\t\t\tif (ext) e |= gf_dynstrcat(&args, ext, NULL);\n\t\t\t}\n\t\t\te |= gf_dynstrcat(&args, \":dynext\", NULL);\n\t\t} else if (dumper->trackID && strlen(szExt) ) {\n\t\t\tif (!no_ext && !gf_file_ext_start(dumper->out_name)) {\n\t\t\t\tif (args) gf_free(args);\n\t\t\t\targs=NULL;\n\t\t\t\te = gf_dynstrcat(&args, \"fout:dst=\", NULL);\n\t\t\t\te |= gf_dynstrcat(&args, dumper->out_name, NULL);\n\t\t\t\te |= gf_dynstrcat(&args, szExt, \".\");\n\t\t\t} else {\n\t\t\t\te |= gf_dynstrcat(&args, \":ext=\", NULL);\n\t\t\t\te |= gf_dynstrcat(&args, szExt, NULL);\n\t\t\t}\n\t\t} else if ((dumper->trackID || dumper->track_type) && use_dynext) {\n\t\t\te |= gf_dynstrcat(&args, \":dynext\", NULL);\n\t\t}\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot load arguments for output file dumper\\n\"));\n\t\t\tif (args) gf_free(args);\n\t\t\tgf_fs_del(fsess);\n\t\t\treturn e;\n\t\t}\n\n\t\tfile_out = gf_fs_load_filter(fsess, args, &e);\n\t\tif (!file_out) {\n\t\t\tgf_fs_del(fsess);\n\t\t\tif (args) gf_free(args);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot load output file dumper\\n\"));\n\t\t\treturn e;\n\t\t}\n\t}\n\tif (args) gf_free(args);\n\targs = NULL;\n\n\t//raw sample frame, force loading filter generic write in frame mode\n\tif (dumper->flags & GF_EXPORT_RAW_SAMPLES) {\n\t\te = gf_dynstrcat(&args, \"writegen:frame\", NULL);\n\t\tif (dumper->sample_num) {\n\t\t\tsprintf(szSubArgs, \":sstart=%d:send=%d\", dumper->sample_num, dumper->sample_num);\n\t\t\te |= gf_dynstrcat(&args, szSubArgs, NULL);\n\t\t}\n\t\tremux = e ? NULL : gf_fs_load_filter(fsess, args, &e);\n\t\tif (!remux || e) {\n\t\t\tgf_fs_del(fsess);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot load stream->file filter\\n\"));\n\t\t\tif (args) gf_free(args);\n\t\t\treturn e ? e : GF_FILTER_NOT_FOUND;\n\t\t}\n\t}\n\telse if (dumper->flags & GF_EXPORT_NHNT) {\n\t\tremux = gf_fs_load_filter(fsess, \"nhntw:exporter\", &e);\n\t\tif (!remux) {\n\t\t\tgf_fs_del(fsess);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot load NHNT write filter\\n\"));\n\t\t\treturn e;\n\t\t}\n\t}\n\telse if (dumper->flags & GF_EXPORT_NHML) {\n\t\te = gf_dynstrcat(&args, \"nhmlw:exporter:name=\", NULL);\n\t\te |= gf_dynstrcat(&args, dumper->out_name, NULL);\n\t\tif (dumper->flags & GF_EXPORT_NHML_FULL)\n\t\t\te |= gf_dynstrcat(&args, \":pckp\", NULL);\n\t\tif (dumper->dump_file) {\n\t\t\tsprintf(szSubArgs, \":nhmlonly:filep=%p\", dumper->dump_file);\n\t\t\te |= gf_dynstrcat(&args, szSubArgs, NULL);\n\t\t}\n\t\tremux = e ? NULL : gf_fs_load_filter(fsess, args, &e);\n\t\tif (!remux || e) {\n\t\t\tgf_fs_del(fsess);\n\t\t\tif (args) gf_free(args);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot load NHML write filter\\n\"));\n\t\t\treturn e ? e : GF_FILTER_NOT_FOUND;\n\t\t}\n\t} else if (!skip_write_filter) {\n\t\te = gf_dynstrcat(&args, \"writegen:exporter\", NULL);\n\t\t//extension has been forced, override ext at output of writegen\n\t\tif (ext_forced) {\n\t\t\te |= gf_dynstrcat(&args, \":#Extension=\", NULL);\n\t\t\te |= gf_dynstrcat(&args, szExt, NULL);\n\t\t}\n\n\t\tremux = e ? NULL : gf_fs_load_filter(fsess, args, &e);\n\t\tif (!remux) {\n\t\t\tgf_fs_del(fsess);\n\t\t\tif (args) gf_free(args);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot load stream->file filter\\n\"));\n\t\t\treturn e;\n\t\t}\n\t}\n\tif (args) gf_free(args);\n\targs = NULL;\n\n\t//force a reframer filter, connected to our input\n\te = gf_dynstrcat(&args, \"reframer:SID=1\", NULL);\n\tif (dumper->trackID) {\n\t\tsprintf(szSubArgs, \"#PID=%d\", dumper->trackID);\n\t\te |= gf_dynstrcat(&args, szSubArgs, NULL);\n\t}\n\te |= gf_dynstrcat(&args, \":exporter\", NULL);\n\tif (dumper->flags & GF_EXPORT_SVC_LAYER)\n\t\te |= gf_dynstrcat(&args, \":extract=layer\", NULL);\n\tif (dumper->flags & GF_EXPORT_WEBVTT_NOMERGE)\n\t\te |= gf_dynstrcat(&args, \":merge\", NULL);\n\n\treframer = gf_fs_load_filter(fsess, args, &e);\n\tif (!reframer || e) {\n\t\tgf_fs_del(fsess);\n\t\tif (args) gf_free(args);\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot load reframer filter\\n\"));\n\t\treturn e ? e : GF_FILTER_NOT_FOUND;\n\t}\n\tif (args) gf_free(args);\n\targs = NULL;\n\n\t//we already have the file loaded, directly load the mp4dmx filter with this file\n\tif (dumper->file) {\n\t\t//we want to expose every track\n\t\te = gf_dynstrcat(&args, \"mp4dmx:FID=1:noedit:alltk:allt\", NULL);\n\t\tif (!e) {\n\t\t\tsprintf(szSubArgs, \":mov=%p\", dumper->file);\n\t\t\te = gf_dynstrcat(&args, szSubArgs, NULL);\n\t\t}\n\t\t\n\t\t//we want to expose every track\n\t\tsrc_filter = gf_fs_load_filter(fsess, args, &e);\n\n\t\tgf_free(args);\n\t\targs = NULL;\n\t} else {\n\t\t//we want to expose every track\n\t\tsrc_filter = gf_fs_load_source(fsess, dumper->in_name, \"FID=1:noedit:alltk:allt\", NULL, &e);\n\t}\n\n\tif (!src_filter || e) {\n\t\tgf_fs_del(fsess);\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot load filter for input file \\\"%s\\\": %s\\n\", dumper->in_name, gf_error_to_string(e) ));\n\t\treturn e;\n\t}\n\n\tif (dumper->track_type) {\n\t\tconst char *mtype = (dumper->track_type==1) ? \"video\" : \"audio\";\n\t\tif (dumper->trackID) {\n\t\t\tsprintf(szSubArgs, \"%s%d\", mtype, dumper->trackID);\n\t\t} else {\n\t\t\tsprintf(szSubArgs, \"%s\", mtype);\n\t\t}\n\t}\n\telse if (dumper->trackID) {\n\t\tsprintf(szSubArgs, \"PID=%d\", dumper->trackID);\n\t}\n\tif (remux) {\n\t\tgf_filter_set_source(file_out, remux, (dumper->trackID || dumper->track_type) ? szSubArgs : NULL);\n\t\tgf_filter_set_source(remux, reframer, (dumper->trackID || dumper->track_type) ? szSubArgs : NULL);\n\t} else {\n\t\tgf_filter_set_source(file_out, reframer, (dumper->trackID || dumper->track_type) ? szSubArgs : NULL);\n\t}\n\n\te = gf_fs_run(fsess);\n\tif (e>GF_OK) e = GF_OK;\n\tif (!e) e = gf_fs_get_last_connect_error(fsess);\n\tif (!e) e = gf_fs_get_last_process_error(fsess);\n\n\tif (!e) {\n\t\tif (dumper->file)\n\t\t\tgf_fs_print_unused_args(fsess, NULL);\n\t\telse\n\t\t\tgf_fs_print_unused_args(fsess, \"alltk,allt,noedit\");\n\t}\n\tgf_fs_print_non_connected(fsess);\n\tif (dumper->print_stats_graph & 1) gf_fs_print_stats(fsess);\n\tif (dumper->print_stats_graph & 2) gf_fs_print_connections(fsess);\n\tgf_fs_del(fsess);\n\treturn e;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 6746,
    "critical_vars": [
      "ptr->moov->mov",
      "ptr->moov->mov->movieFileMap",
      "ptr->moov"
    ],
    "function": "trak_box_size",
    "filename": "gpac/CVE-2021-32135/CVE-2021-32135_CWE-476_b8f8b202d4fc23eb0ab4ce71ae96536ca6f5d3f8_box_code_base.c.diff",
    "function_code": "\nGF_Err trak_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_TrackBox *ptr = (GF_TrackBox *)s;\n\n\tif (ptr->sample_encryption && ptr->sample_encryption->load_needed) {\n\t\tif (!ptr->moov || !!ptr->moov->mov || !ptr->moov->mov->movieFileMap)\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tGF_Err e = senc_Parse(ptr->moov->mov->movieFileMap->bs, ptr, NULL, ptr->sample_encryption);\n\t\tif (e) return e;\n\t}\n\n\tgf_isom_check_position(s, (GF_Box *)ptr->Header, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->Aperture, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->References, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->editBox, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->Media, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->meta, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->groups, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->udta, &pos);\n\treturn GF_OK;",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 2538,
    "critical_vars": [
      "length",
      "data"
    ],
    "function": "swf_svg_add_iso_sample",
    "filename": "gpac/CVE-2024-6062/CVE-2024-6062_CWE-476_31e499d310a48bd17c8b055a0bfe0fe35887a7cd_load_text.c.diff",
    "function_code": "\nstatic GF_Err swf_svg_add_iso_sample(void *user, const u8 *data, u32 length, u64 timestamp, Bool isRap)\n{\n\tGF_FilterPacket *pck;\n\tu8 *pck_data;\n\tGF_TXTIn *ctx = (GF_TXTIn *)user;\n\tif (!data || !length) return GF_BAD_PARAM;\n\n\tif (ctx->seek_state==2) {\n\t\tDouble ts = (Double) timestamp;\n\t\tts/=1000;\n\t\tif (ts<ctx->start_range) return GF_OK;\n\t\tctx->seek_state = 0;\n\t}\n\n\tpck = gf_filter_pck_new_alloc(ctx->opid, length, &pck_data);\n\tif (pck) {\n\t\tmemcpy(pck_data, data, length);\n\t\tgf_filter_pck_set_cts(pck, (u64) (ctx->timescale*timestamp/1000) );\n\t\tgf_filter_pck_set_sap(pck, isRap ? GF_FILTER_SAP_1 : GF_FILTER_SAP_NONE);\n\t\tgf_filter_pck_set_framing(pck, GF_TRUE, GF_FALSE);\n\n\t\tgf_filter_pck_send(pck);\n\t}\n\n\tif (txtin_check_blocking(ctx))\n\t\tctx->is_suspended = GF_TRUE;\n\treturn GF_OK;",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 707,
    "critical_vars": [
      "ent->value",
      "ent"
    ],
    "function": "xml_sax_parse_entity",
    "filename": "gpac/CVE-2023-3012/CVE-2023-3012_CWE-476_53387aa86c1af1228d0fa57c67f9c7330716d5a7_xml_parser.c.diff",
    "function_code": "static void xml_sax_parse_entity(GF_SAXParser *parser)\n{\n\tchar szC[2];\n\tchar *ent_name=NULL;\n\tu32 i = 0;\n\tXML_Entity *ent = (XML_Entity *)gf_list_last(parser->entities);\n\tchar *skip_chars = \" \\t\\n\\r\";\n\ti=0;\n\tif (ent && ent->value) ent = NULL;\n\tif (ent) skip_chars = NULL;\n\tszC[1]=0;\n\n\twhile (parser->current_pos+i < parser->line_size) {\n\t\tu8 c = parser->buffer[parser->current_pos+i];\n\t\tif (skip_chars && strchr(skip_chars, c)) {\n\t\t\tif (c=='\\n') parser->line++;\n\t\t\tparser->current_pos++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!ent && (c=='%')) {\n\t\t\tparser->current_pos+=i+1;\n\t\t\tparser->sax_state = SAX_STATE_SKIP_DOCTYPE;\n\t\t\tif (ent_name) gf_free(ent_name);\n\t\t\treturn;\n\t\t}\n\t\telse if (!ent && ((c=='\\\"') || (c=='\\'')) ) {\n\t\t\tGF_SAFEALLOC(ent, XML_Entity);\n\t\t\tif (!ent) {\n\t\t\t\tparser->sax_state = SAX_STATE_ALLOC_ERROR;\n\t\t\t\tif (ent_name) gf_free(ent_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!ent_name) gf_dynstrcat(&ent_name, \"\", NULL);\n\n\t\t\tent->name = ent_name;\n\t\t\tent_name=NULL;\n\t\t\tent->namelen = (u32) strlen(ent->name);\n\t\t\tent->sep = c;\n\t\t\tparser->current_pos += 1+i;\n\t\t\tassert(parser->current_pos < parser->line_size);\n\t\t\txml_sax_swap(parser);\n\t\t\ti=0;\n\t\t\tgf_list_add(parser->entities, ent);\n\t\t\tskip_chars = NULL;\n\t\t} else if (ent && c==ent->sep) {\n\t\t\tif (ent_name) gf_free(ent_name);\n\t\t\txml_sax_store_text(parser, i);\n\n\t\t\tent->value = xml_get_current_text(parser);\n\t\t\tif (!ent->value) ent->value = gf_strdup(\"\");\n\n\t\t\tparser->current_pos += 1;\n\t\t\tassert(parser->current_pos < parser->line_size);\n\t\t\txml_sax_swap(parser);\n\t\t\tparser->sax_state = SAX_STATE_SKIP_DOCTYPE;\n\t\t\treturn;\n\t\t} else if (!ent) {\n\t\t\tszC[0] = c;\n\t\t\tgf_dynstrcat(&ent_name, szC, NULL);\n\t\t\ti++;\n\t\t} else {\n\t\t\ti++;\n\t\t}\n\t}\n\tif (ent_name) gf_free(ent_name);\n\tif (ent && !ent->value)\n\t\tparser->sax_state = SAX_STATE_SYNTAX_ERROR;\n\txml_sax_store_text(parser, i);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 1038,
    "critical_vars": [
      "offset"
    ],
    "function": "MergeTrack",
    "filename": "gpac/CVE-2021-31260/CVE-2021-31260_CWE-476_df8fffd839fe5ae9acd82d26fd48280a397411d9_track.c.diff",
    "function_code": "GF_Err MergeTrack(GF_TrackBox *trak, GF_TrackFragmentBox *traf, GF_MovieFragmentBox *moof_box, u64 moof_offset, s32 compressed_diff, u64 *cumulated_offset, Bool is_first_merge)\n{\n\tu32 i, j, chunk_size, track_num;\n\tu64 base_offset, data_offset, traf_duration;\n\tu32 def_duration, DescIndex, def_size, def_flags;\n\tu32 duration, size, flags, prev_trun_data_offset, sample_index;\n\tu8 pad, sync;\n\tu16 degr;\n\tBool first_samp_in_traf=GF_TRUE;\n\tBool store_traf_map=GF_FALSE;\n\tu8 *moof_template=NULL;\n\tu32 moof_template_size=0;\n\tBool is_seg_start = GF_FALSE;\n\tu64 seg_start=0, sidx_start=0, sidx_end=0, frag_start=0, last_dts=0;\n\tGF_TrackFragmentRunBox *trun;\n\tGF_TrunEntry *ent;\n#ifdef GF_ENABLE_CTRN\n\tGF_TrackFragmentBox *traf_ref = NULL;\n#endif\n\n\tGF_Err stbl_AppendTime(GF_SampleTableBox *stbl, u32 duration, u32 nb_pack);\n\tGF_Err stbl_AppendSize(GF_SampleTableBox *stbl, u32 size, u32 nb_pack);\n\tGF_Err stbl_AppendChunk(GF_SampleTableBox *stbl, u64 offset);\n\tGF_Err stbl_AppendSampleToChunk(GF_SampleTableBox *stbl, u32 DescIndex, u32 samplesInChunk);\n\tGF_Err stbl_AppendCTSOffset(GF_SampleTableBox *stbl, s32 CTSOffset);\n\tGF_Err stbl_AppendRAP(GF_SampleTableBox *stbl, u8 isRap);\n\tGF_Err stbl_AppendPadding(GF_SampleTableBox *stbl, u8 padding);\n\tGF_Err stbl_AppendDegradation(GF_SampleTableBox *stbl, u16 DegradationPriority);\n\n\tif (trak->Header->trackID != traf->tfhd->trackID) return GF_OK;\n\tif (!trak->Media->information->sampleTable\n\t\t|| !trak->Media->information->sampleTable->SampleSize\n\t\t|| !trak->Media->information->sampleTable->TimeToSample\n\t\t|| !trak->Media->information->sampleTable->SampleToChunk\n\t\t|| !trak->Media->information->sampleTable->ChunkOffset\n\t) {\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tif (!traf->trex->track)\n\t\ttraf->trex->track = trak;\n\n\t//setup all our defaults\n\tDescIndex = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_DESC) ? traf->tfhd->sample_desc_index : traf->trex->def_sample_desc_index;\n\tif (!DescIndex) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] default sample description set to 0, likely broken ! Fixing to 1\\n\" ));\n\t\tDescIndex = 1;\n\t} else if (DescIndex > gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] default sample description set to %d but only %d sample description(s), likely broken ! Fixing to 1\\n\", DescIndex, gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes)));\n\t\tDescIndex = 1;\n\t}\n#ifdef GF_ENABLE_CTRN\n\tif (traf->trex->inherit_from_traf_id) {\n\t\tu32 traf_count = gf_list_count(moof_box->TrackList);\n\t\tfor (i=0; i<traf_count; i++) {\n\t\t\tGF_TrackFragmentBox *atraf = gf_list_get(moof_box->TrackList, i);\n\t\t\tif (atraf->tfhd && atraf->tfhd->trackID==traf->trex->inherit_from_traf_id) {\n\t\t\t\ttraf_ref = atraf;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tdef_duration = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_DUR) ? traf->tfhd->def_sample_duration : traf->trex->def_sample_duration;\n\tdef_size = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_SIZE) ? traf->tfhd->def_sample_size : traf->trex->def_sample_size;\n\tdef_flags = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_FLAGS) ? traf->tfhd->def_sample_flags : traf->trex->def_sample_flags;\n\n\t//locate base offset, by default use moof (dash-like)\n\tbase_offset = moof_offset;\n\t//explicit base offset, use it\n\tif (traf->tfhd->flags & GF_ISOM_TRAF_BASE_OFFSET)\n\t\tbase_offset = traf->tfhd->base_data_offset;\n\t//no moof offset and no explicit offset, the offset is the end of the last written chunk of\n\t//the previous traf. For the first traf, *cumulated_offset is actually moof offset\n\telse if (!(traf->tfhd->flags & GF_ISOM_MOOF_BASE_OFFSET))\n\t\tbase_offset = *cumulated_offset;\n\n\tchunk_size = 0;\n\tprev_trun_data_offset = 0;\n\tdata_offset = 0;\n\ttraf_duration = 0;\n\n\t/*in playback mode*/\n\tif (traf->tfdt && is_first_merge) {\n#ifndef GPAC_DISABLE_LOG\n\t\tif (trak->moov->mov->NextMoofNumber && trak->present_in_scalable_segment && trak->sample_count_at_seg_start && (trak->dts_at_seg_start != traf->tfdt->baseMediaDecodeTime)) {\n\t\t\ts32 drift = (s32) ((s64) traf->tfdt->baseMediaDecodeTime - (s64)trak->dts_at_seg_start);\n\t\t\tif (drift<0)  {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Warning: TFDT timing \"LLD\" less than cumulated timing \"LLD\" - using tfdt\\n\", traf->tfdt->baseMediaDecodeTime, trak->dts_at_seg_start ));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[iso file] TFDT timing \"LLD\" higher than cumulated timing \"LLD\" (last sample got extended in duration)\\n\", traf->tfdt->baseMediaDecodeTime, trak->dts_at_seg_start ));\n\t\t\t}\n\t\t}\n#endif\n\t\ttrak->dts_at_seg_start = traf->tfdt->baseMediaDecodeTime;\n\t}\n\telse if (traf->tfxd) {\n\t\ttrak->dts_at_seg_start = traf->tfxd->absolute_time_in_track_timescale;\n\t}\n\n\tif (traf->tfxd) {\n\t\ttrak->last_tfxd_value = traf->tfxd->absolute_time_in_track_timescale;\n\t\ttrak->last_tfxd_value += traf->tfxd->fragment_duration_in_track_timescale;\n\t}\n\tif (traf->tfrf) {\n\t\tif (trak->tfrf) gf_isom_box_del_parent(&trak->child_boxes, (GF_Box *)trak->tfrf);\n\t\ttrak->tfrf = traf->tfrf;\n\t\tgf_list_del_item(traf->child_boxes, traf->tfrf);\n\t\tgf_list_add(trak->child_boxes, trak->tfrf);\n\t}\n\n\tif (trak->moov->mov->signal_frag_bounds) {\n\t\tstore_traf_map = GF_TRUE;\n\t\tif (is_first_merge) {\n\t\t\tGF_MovieFragmentBox *moof_clone = NULL;\n\t\t\tgf_isom_box_freeze_order((GF_Box *)moof_box);\n\t\t\tgf_isom_clone_box((GF_Box *)moof_box, (GF_Box **)&moof_clone);\n\n\t\t\tif (moof_clone) {\n\t\t\t\tGF_BitStream *bs;\n\t\t\t\tfor (i=0; i<gf_list_count(moof_clone->TrackList); i++) {\n\t\t\t\t\tGF_TrackFragmentBox *traf_clone = gf_list_get(moof_clone->TrackList, i);\n\t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->TrackRuns);\n\t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sampleGroups);\n\t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sampleGroupsDescription);\n\t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sub_samples);\n\t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sai_offsets);\n\t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sai_sizes);\n\t\t\t\t\tif (traf_clone->sample_encryption) {\n\t\t\t\t\t\tgf_isom_box_del_parent(&traf_clone->child_boxes, (GF_Box *) traf_clone->sample_encryption);\n\t\t\t\t\t\ttraf_clone->sample_encryption = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif (traf_clone->sdtp) {\n\t\t\t\t\t\tgf_isom_box_del_parent(&traf_clone->child_boxes, (GF_Box *) traf_clone->sdtp);\n\t\t\t\t\t\ttraf_clone->sdtp = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_isom_box_size((GF_Box *)moof_clone);\n\t\t\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\t\t\t\tif (trak->moov->mov->seg_styp) {\n\t\t\t\t\tgf_isom_box_size(trak->moov->mov->seg_styp);\n\t\t\t\t\tgf_isom_box_write(trak->moov->mov->seg_styp, bs);\n\t\t\t\t}\n\t\t\t\tif (trak->moov->mov->root_sidx) {\n\t\t\t\t\tgf_isom_box_size((GF_Box *)trak->moov->mov->root_sidx);\n\t\t\t\t\tgf_isom_box_write((GF_Box *)trak->moov->mov->root_sidx, bs);\n\t\t\t\t}\n\t\t\t\tif (trak->moov->mov->seg_ssix) {\n\t\t\t\t\tgf_isom_box_size(trak->moov->mov->seg_ssix);\n\t\t\t\t\tgf_isom_box_write(trak->moov->mov->seg_ssix, bs);\n\t\t\t\t}\n\t\t\t\tgf_isom_box_write((GF_Box *)moof_clone, bs);\n\t\t\t\tgf_isom_box_del((GF_Box*)moof_clone);\n\n\t\t\t\tgf_bs_get_content(bs, &moof_template, &moof_template_size);\n\t\t\t\tgf_bs_del(bs);\n\t\t\t}\n\t\t}\n\t\tif (trak->moov->mov->seg_styp) {\n\t\t\tis_seg_start = GF_TRUE;\n\t\t\tseg_start = trak->moov->mov->styp_start_offset;\n\t\t}\n\t\tif (trak->moov->mov->root_sidx) {\n\t\t\tis_seg_start = GF_TRUE;\n\t\t\tsidx_start = trak->moov->mov->sidx_start_offset;\n\t\t\tsidx_end = trak->moov->mov->sidx_end_offset;\n\t\t\tif (! seg_start || (sidx_start<seg_start))\n\t\t\t\tseg_start = sidx_start;\n\t\t}\n\t\tfrag_start = trak->moov->mov->current_top_box_start;\n\t}\n\telse if (trak->moov->mov->store_traf_map) {\n\t\tstore_traf_map = GF_TRUE;\n\t}\n\n\n\tsample_index = 0;\n\ti=0;\n\twhile ((trun = (GF_TrackFragmentRunBox *)gf_list_enum(traf->TrackRuns, &i))) {\n\t\t//merge the run\n\t\tfor (j=0; j<trun->sample_count; j++) {\n\t\t\tGF_Err e;\n\t\t\ts32 cts_offset=0;\n\t\t\tif (j<trun->nb_samples) {\n\t\t\t\tent = &trun->samples[j];\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Track %d doesn't have enough trun entries (%d) compared to sample count (%d) in run\\n\", traf->trex->trackID, trun->nb_samples, trun->sample_count ));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsize = def_size;\n\t\t\tduration = def_duration;\n\t\t\tflags = def_flags;\n\n\t\t\t//CTS - if flag not set (trun or ctrn) defaults to 0 which is the base value after alloc\n\t\t\t//we just need to overrite its value if inherited\n\t\t\tcts_offset = ent->CTS_Offset;\n\n#ifdef GF_ENABLE_CTRN\n\t\t\tif (trun->use_ctrn) {\n\t\t\t\tif (!j && (trun->ctrn_flags & GF_ISOM_CTRN_FIRST_SAMPLE) ) {\n\t\t\t\t\tif (trun->ctrn_first_dur) duration = ent->Duration;\n\t\t\t\t\tif (trun->ctrn_first_size) size = ent->size;\n\t\t\t\t\tif (trun->ctrn_first_ctts) flags = ent->flags;\n\t\t\t\t} else {\n\t\t\t\t\tif (trun->ctrn_dur) duration = ent->Duration;\n\t\t\t\t\tif (trun->ctrn_size) size = ent->size;\n\t\t\t\t\tif (trun->ctrn_sample_flags) flags = ent->flags;\n\t\t\t\t}\n\t\t\t\t/*re-override*/\n\t\t\t\tif (trun->ctrn_flags & 0xF0) {\n\t\t\t\t\tGF_TrunEntry *ref_entry;\n\t\t\t\t\tif (!traf_ref) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Track %d use traf inheritance to track ID %d but reference traf not found\\n\", traf->trex->trackID, traf->trex->inherit_from_traf_id ));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tref_entry = traf_get_sample_entry(traf_ref, sample_index);\n\t\t\t\t\tif (!ref_entry) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Track %d use traf inheritance but sample %d not found in reference traf\\n\", traf->trex->trackID, sample_index+1 ));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_DUR)\n\t\t\t\t\t\tduration = ref_entry->Duration;\n\t\t\t\t\tif (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_SIZE)\n\t\t\t\t\t\tsize = ref_entry->size;\n\t\t\t\t\tif (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_FLAGS)\n\t\t\t\t\t\tflags = ref_entry->flags;\n\t\t\t\t\tif (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_CTSO)\n\t\t\t\t\t\tcts_offset = ref_entry->CTS_Offset;\n\t\t\t\t}\n\n\t\t\t} else\n#endif\n\t\t\t{\n\t\t\t\tif (trun->flags & GF_ISOM_TRUN_DURATION) duration = ent->Duration;\n\t\t\t\tif (trun->flags & GF_ISOM_TRUN_SIZE) size = ent->size;\n\t\t\t\tif (trun->flags & GF_ISOM_TRUN_FLAGS) {\n\t\t\t\t\tflags = ent->flags;\n\t\t\t\t} else if (!j && (trun->flags & GF_ISOM_TRUN_FIRST_FLAG)) {\n\t\t\t\t\tflags = trun->first_sample_flags;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsample_index++;\n\t\t\t/*store the resolved value in case we have inheritance*/\n\t\t\tent->size = size;\n\t\t\tent->Duration = duration;\n\t\t\tent->flags = flags;\n\t\t\tent->CTS_Offset = cts_offset;\n\n\t\t\tlast_dts += duration;\n\n\t\t\t//add size first\n\t\t\tif (!trak->Media->information->sampleTable->SampleSize) {\n\t\t\t\ttrak->Media->information->sampleTable->SampleSize = (GF_SampleSizeBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STSZ);\n\t\t\t\tif (!trak->Media->information->sampleTable->SampleSize)\n\t\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\te = stbl_AppendSize(trak->Media->information->sampleTable, size, ent->nb_pack);\n\t\t\tif (e) return e;\n\n\t\t\t//then TS\n\t\t\tif (!trak->Media->information->sampleTable->TimeToSample) {\n\t\t\t\ttrak->Media->information->sampleTable->TimeToSample = (GF_TimeToSampleBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STTS);\n\t\t\t\tif (!trak->Media->information->sampleTable->TimeToSample)\n\t\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\te = stbl_AppendTime(trak->Media->information->sampleTable, duration, ent->nb_pack);\n\t\t\tif (e) return e;\n\n\t\t\t//add chunk on first sample\n\t\t\tif (!j) {\n\t\t\t\tu64 final_offset;\n\t\t\t\tdata_offset = base_offset;\n\t\t\t\t//we have an explicit data offset for this trun\n\t\t\t\tif (trun->flags & GF_ISOM_TRUN_DATA_OFFSET) {\n\t\t\t\t\tdata_offset += trun->data_offset;\n\t\t\t\t\t/*reset chunk size since data is now relative to this trun*/\n\t\t\t\t\tchunk_size = 0;\n\t\t\t\t\t/*remember this data offset for following trun*/\n\t\t\t\t\tprev_trun_data_offset = trun->data_offset;\n\t\t\t\t\t/*if mdat is located after the moof, and the moof was compressed, adjust offset\n\t\t\t\t\totherwise the offset does not need adjustment*/\n\t\t\t\t\tif (trun->data_offset>=0) {\n\t\t\t\t\t\tdata_offset -= compressed_diff;\n\t\t\t\t\t\tprev_trun_data_offset -= compressed_diff;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//we had an explicit data offset for the previous trun, use it + chunk size\n\t\t\t\telse if (prev_trun_data_offset) {\n\t\t\t\t\t/*data offset is previous chunk size plus previous offset of the trun*/\n\t\t\t\t\tdata_offset += prev_trun_data_offset + chunk_size;\n\t\t\t\t}\n\t\t\t\t//no explicit data offset, continuous data after last data in previous chunk\n\t\t\t\telse {\n\t\t\t\t\tdata_offset += chunk_size;\n\t\t\t\t\t//data offset of first trun in first traf, adjust if compressed moof\n\t\t\t\t\tif ((i==1) && (trun->data_offset>=0)) {\n\t\t\t\t\t\tdata_offset -= compressed_diff;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfinal_offset = data_offset;\n\t\t\t\t//adjust offset if moov was also compressed and we are still in the same file\n\t\t\t\t//so that later call to gf_isom_get_sample properly adjust back the offset\n\t\t\t\tif (trak->moov->compressed_diff) {\n\t\t\t\t\tfinal_offset += trak->moov->compressed_diff;\n\t\t\t\t}\n\n\t\t\t\tif (!trak->Media->information->sampleTable->ChunkOffset) {\n\t\t\t\t\ttrak->Media->information->sampleTable->ChunkOffset = gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STCO);\n\t\t\t\t\tif (!trak->Media->information->sampleTable->ChunkOffset)\n\t\t\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t\te = stbl_AppendChunk(trak->Media->information->sampleTable, final_offset);\n\t\t\t\tif (e) return e;\n\t\t\t\t//then sampleToChunk\n\t\t\t\tif (!trak->Media->information->sampleTable->SampleToChunk) {\n\t\t\t\t\ttrak->Media->information->sampleTable->SampleToChunk = (GF_SampleToChunkBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STSC);\n\t\t\t\t\tif (!trak->Media->information->sampleTable->SampleToChunk)\n\t\t\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t\te = stbl_AppendSampleToChunk(trak->Media->information->sampleTable,\n\t\t\t\t                         DescIndex, trun->sample_count);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t\tchunk_size += size;\n\n\t\t\tif (store_traf_map && first_samp_in_traf) {\n\t\t\t\tfirst_samp_in_traf = GF_FALSE;\n\t\t\t\te = stbl_AppendTrafMap(trak->Media->information->sampleTable, is_seg_start, seg_start, frag_start, moof_template, moof_template_size, sidx_start, sidx_end);\n\t\t\t\tif (e) return e;\n\t\t\t\t//do not deallocate, the memory is now owned by traf map\n\t\t\t\tmoof_template = NULL;\n\t\t\t\tmoof_template_size = 0;\n\t\t\t}\n\t\t\tif (ent->nb_pack>1) {\n\t\t\t\tj+= ent->nb_pack-1;\n\t\t\t\ttraf_duration += ent->nb_pack*duration;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttraf_duration += duration;\n\n\t\t\te = stbl_AppendCTSOffset(trak->Media->information->sampleTable, cts_offset);\n\t\t\tif (e) return e;\n\t\t\t//flags\n\t\t\tsync = GF_ISOM_GET_FRAG_SYNC(flags);\n\t\t\tif (trak->Media->information->sampleTable->no_sync_found && sync) {\n\t\t\t\ttrak->Media->information->sampleTable->no_sync_found = 0;\n\t\t\t}\n\t\t\te = stbl_AppendRAP(trak->Media->information->sampleTable, sync);\n\t\t\tif (e) return e;\n\t\t\tpad = GF_ISOM_GET_FRAG_PAD(flags);\n\t\t\tif (pad) {\n\t\t\t\te = stbl_AppendPadding(trak->Media->information->sampleTable, pad);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t\tdegr = GF_ISOM_GET_FRAG_DEG(flags);\n\t\t\tif (degr) {\n\t\t\t\te = stbl_AppendDegradation(trak->Media->information->sampleTable, degr);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t\te = stbl_AppendDependencyType(trak->Media->information->sampleTable, GF_ISOM_GET_FRAG_LEAD(flags), GF_ISOM_GET_FRAG_DEPENDS(flags), GF_ISOM_GET_FRAG_DEPENDED(flags), GF_ISOM_GET_FRAG_REDUNDANT(flags));\n\t\t\tif (e) return e;\n\t\t}\n\t}\n\n\tif (trak->moov->mov->is_smooth && !traf->tfdt && !traf->tfxd) {\n\t\tif (is_first_merge)\n\t\t\ttrak->dts_at_seg_start = trak->dts_at_next_seg_start;\n\t\ttrak->dts_at_next_seg_start += last_dts;\n\t}\n\tif (traf_duration && trak->editBox && trak->editBox->editList) {\n\t\tfor (i=0; i<gf_list_count(trak->editBox->editList->entryList); i++) {\n\t\t\tGF_EdtsEntry *edts_e = gf_list_get(trak->editBox->editList->entryList, i);\n\t\t\tif (edts_e->was_empty_dur) {\n\t\t\t\tu64 extend_dur = traf_duration;\n\t\t\t\textend_dur *= trak->moov->mvhd->timeScale;\n\t\t\t\textend_dur /= trak->Media->mediaHeader->timeScale;\n\t\t\t\tedts_e->segmentDuration += extend_dur;\n\t\t\t}\n\t\t\telse if (!edts_e->segmentDuration) {\n\t\t\t\tedts_e->was_empty_dur = GF_TRUE;\n\t\t\t\tif ((s64) traf_duration > edts_e->mediaTime)\n\t\t\t\t\ttraf_duration -= edts_e->mediaTime;\n\t\t\t\telse\n\t\t\t\t\ttraf_duration = 0;\n\n\t\t\t\tedts_e->segmentDuration = traf_duration;\n\t\t\t\tedts_e->segmentDuration *= trak->moov->mvhd->timeScale;\n\t\t\t\tedts_e->segmentDuration /= trak->Media->mediaHeader->timeScale;\n\t\t\t}\n\n\t\t}\n\t}\n\n\t//in any case, update the cumulated offset\n\t//this will handle hypothetical files mixing MOOF offset and implicit non-moof offset\n\t*cumulated_offset = data_offset + chunk_size;\n\n\t/*merge sample groups*/\n\tif (traf->sampleGroups) {\n\t\tGF_List *groups;\n\t\tGF_List *groupDescs;\n\t\tBool is_identical_sgpd = GF_TRUE;\n\t\tu32 *new_idx = NULL, new_idx_count=0;\n\n\t\tif (!trak->Media->information->sampleTable->sampleGroups)\n\t\t\ttrak->Media->information->sampleTable->sampleGroups = gf_list_new();\n\n\t\tif (!trak->Media->information->sampleTable->sampleGroupsDescription)\n\t\t\ttrak->Media->information->sampleTable->sampleGroupsDescription = gf_list_new();\n\n\t\tgroupDescs = trak->Media->information->sampleTable->sampleGroupsDescription;\n\t\tfor (i=0; i<gf_list_count(traf->sampleGroupsDescription); i++) {\n\t\t\tGF_SampleGroupDescriptionBox *new_sgdesc = NULL;\n\t\t\tGF_SampleGroupDescriptionBox *sgdesc = gf_list_get(traf->sampleGroupsDescription, i);\n\t\t\tfor (j=0; j<gf_list_count(groupDescs); j++) {\n\t\t\t\tnew_sgdesc = gf_list_get(groupDescs, j);\n\t\t\t\tif (new_sgdesc->grouping_type==sgdesc->grouping_type) break;\n\t\t\t\tnew_sgdesc = NULL;\n\t\t\t}\n\t\t\t/*new description, move it to our sample table*/\n\t\t\tif (!new_sgdesc) {\n\t\t\t\tgf_list_add(groupDescs, sgdesc);\n\t\t\t\tgf_list_add(trak->Media->information->sampleTable->child_boxes, sgdesc);\n\t\t\t\tgf_list_rem(traf->sampleGroupsDescription, i);\n\t\t\t\tgf_list_del_item(traf->child_boxes, sgdesc);\n\t\t\t\ti--;\n\t\t\t}\n\t\t\t/*merge descriptions*/\n\t\t\telse {\n\t\t\t\tu32 count;\n\n\t\t\t\tis_identical_sgpd = gf_isom_is_identical_sgpd(new_sgdesc, sgdesc, 0);\n\t\t\t\tif (is_identical_sgpd)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tnew_idx_count = gf_list_count(sgdesc->group_descriptions);\n\t\t\t\tnew_idx = (u32 *)gf_malloc(new_idx_count * sizeof(u32));\n\t\t\t\tif (!new_idx) return GF_OUT_OF_MEM;\n\n\t\t\t\tcount = 0;\n\t\t\t\twhile (gf_list_count(sgdesc->group_descriptions)) {\n\t\t\t\t\tvoid *sgpd_entry = gf_list_get(sgdesc->group_descriptions, 0);\n\t\t\t\t\tBool new_entry = GF_TRUE;\n\n\t\t\t\t\tfor (j = 0; j < gf_list_count(new_sgdesc->group_descriptions); j++) {\n\t\t\t\t\t\tvoid *ptr = gf_list_get(new_sgdesc->group_descriptions, j);\n\t\t\t\t\t\tif (gf_isom_is_identical_sgpd(sgpd_entry, ptr, new_sgdesc->grouping_type)) {\n\t\t\t\t\t\t\tnew_idx[count] = j + 1;\n\t\t\t\t\t\t\tcount ++;\n\t\t\t\t\t\t\tnew_entry = GF_FALSE;\n\t\t\t\t\t\t\tgf_free(sgpd_entry);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (new_entry) {\n\t\t\t\t\t\tgf_list_add(new_sgdesc->group_descriptions, sgpd_entry);\n\t\t\t\t\t\tnew_idx[count] = gf_list_count(new_sgdesc->group_descriptions);\n\t\t\t\t\t\tcount ++;\n\t\t\t\t\t}\n\n\t\t\t\t\tgf_list_rem(sgdesc->group_descriptions, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tgroups = trak->Media->information->sampleTable->sampleGroups;\n\t\tfor (i=0; i<gf_list_count(traf->sampleGroups); i++) {\n\t\t\tGF_SampleGroupBox *stbl_group = NULL;\n\t\t\tGF_SampleGroupBox *frag_group = gf_list_get(traf->sampleGroups, i);\n\n\n\t\t\tfor (j=0; j<gf_list_count(groups); j++) {\n\t\t\t\tstbl_group = gf_list_get(groups, j);\n\t\t\t\tif ((frag_group->grouping_type==stbl_group->grouping_type) && (frag_group->grouping_type_parameter==stbl_group->grouping_type_parameter))\n\t\t\t\t\tbreak;\n\t\t\t\tstbl_group = NULL;\n\t\t\t}\n\t\t\tif (!stbl_group) {\n\t\t\t\tstbl_group = (GF_SampleGroupBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_SBGP);\n\t\t\t\tif (!stbl_group) return GF_OUT_OF_MEM;\n\t\t\t\tstbl_group->grouping_type = frag_group->grouping_type;\n\t\t\t\tstbl_group->grouping_type_parameter = frag_group->grouping_type_parameter;\n\t\t\t\tstbl_group->version = frag_group->version;\n\t\t\t\tgf_list_add(groups, stbl_group);\n\t\t\t}\n\n\t\t\tif (is_identical_sgpd) {\n\t\t\t\t//adjust sgpd index: in traf index start at 0x1001\n\t\t\t\tfor (j = 0; j < frag_group->entry_count; j++)\n\t\t\t\t\tfrag_group->sample_entries[j].group_description_index &= 0x0FFFF;\n\t\t\t\tif (frag_group->entry_count && stbl_group->entry_count &&\n\t\t\t\t        (frag_group->sample_entries[0].group_description_index==stbl_group->sample_entries[stbl_group->entry_count-1].group_description_index)\n\t\t\t\t   ) {\n\t\t\t\t\tstbl_group->sample_entries[stbl_group->entry_count - 1].sample_count += frag_group->sample_entries[0].sample_count;\n\t\t\t\t\tif (frag_group->entry_count>1) {\n\t\t\t\t\t\tstbl_group->sample_entries = gf_realloc(stbl_group->sample_entries, sizeof(GF_SampleGroupEntry) * (stbl_group->entry_count + frag_group->entry_count - 1));\n\t\t\t\t\t\tmemcpy(&stbl_group->sample_entries[stbl_group->entry_count], &frag_group->sample_entries[1], sizeof(GF_SampleGroupEntry) * (frag_group->entry_count - 1));\n\t\t\t\t\t\tstbl_group->entry_count += frag_group->entry_count - 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tstbl_group->sample_entries = gf_realloc(stbl_group->sample_entries, sizeof(GF_SampleGroupEntry) * (stbl_group->entry_count + frag_group->entry_count));\n\t\t\t\t\tmemcpy(&stbl_group->sample_entries[stbl_group->entry_count], &frag_group->sample_entries[0], sizeof(GF_SampleGroupEntry) * frag_group->entry_count);\n\t\t\t\t\tstbl_group->entry_count += frag_group->entry_count;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstbl_group->sample_entries = gf_realloc(stbl_group->sample_entries, sizeof(GF_SampleGroupEntry) * (stbl_group->entry_count + frag_group->entry_count));\n\t\t\t\t//adjust sgpd index\n\t\t\t\tfor (j = 0; j < frag_group->entry_count; j++) {\n\t\t\t\t\tu32 sgidx = frag_group->sample_entries[j].group_description_index;\n\t\t\t\t\tif (sgidx > 0x10000) {\n\t\t\t\t\t\tsgidx -= 0x10001;\n\t\t\t\t\t\tif (sgidx>=new_idx_count) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[isobmf] corrupted sample group index in fragment %d but only %d group descriptions in fragment\\n\", sgidx, new_idx_count));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfrag_group->sample_entries[j].group_description_index = new_idx[sgidx];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmemcpy(&stbl_group->sample_entries[stbl_group->entry_count], &frag_group->sample_entries[0], sizeof(GF_SampleGroupEntry) * frag_group->entry_count);\n\t\t\t\tstbl_group->entry_count += frag_group->entry_count;\n\t\t\t}\n\t\t}\n\n\t\tif (new_idx) gf_free(new_idx);\n\t}\n\n\t/*content is encrypted*/\n\ttrack_num = gf_isom_get_tracknum_from_id(trak->moov, trak->Header->trackID);\n\tif (gf_isom_is_cenc_media(trak->moov->mov, track_num, DescIndex)\n\t\t|| traf->sample_encryption) {\n\t\t/*Merge sample auxiliary encryption information*/\n\t\tGF_SampleEncryptionBox *senc = NULL;\n\t\tu32 scheme_type;\n\t\tgf_isom_get_cenc_info(trak->moov->mov, track_num, DescIndex, NULL, &scheme_type, NULL);\n\n\t\tif (traf->sample_encryption) {\n\t\t\tfor (i = 0; i < gf_list_count(trak->Media->information->sampleTable->child_boxes); i++) {\n\t\t\t\tGF_Box *a = (GF_Box *)gf_list_get(trak->Media->information->sampleTable->child_boxes, i);\n\t\t\t\tif (a->type != traf->sample_encryption->type) continue;\n\n\t\t\t\tif ((a->type ==GF_ISOM_BOX_TYPE_UUID) && (((GF_UUIDBox *)a)->internal_4cc == GF_ISOM_BOX_UUID_PSEC)) {\n\t\t\t\t\tsenc = (GF_SampleEncryptionBox *)a;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (a->type ==GF_ISOM_BOX_TYPE_SENC) {\n\t\t\t\t\tsenc = (GF_SampleEncryptionBox *)a;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!senc && trak->sample_encryption)\n\t\t\t\tsenc = trak->sample_encryption;\n\n\t\t\tif (!senc) {\n\t\t\t\tif (traf->sample_encryption->piff_type==1) {\n\t\t\t\t\tsenc = (GF_SampleEncryptionBox *)gf_isom_create_piff_psec_box(1, 0x2, 0, 0, NULL);\n\t\t\t\t} else {\n\t\t\t\t\tsenc = gf_isom_create_samp_enc_box(1, 0x2);\n\t\t\t\t}\n\n\t\t\t\tif (!trak->Media->information->sampleTable->child_boxes) trak->Media->information->sampleTable->child_boxes = gf_list_new();\n\n\t\t\t\ttrak->sample_encryption = senc;\n\t\t\t\tif (!trak->child_boxes) trak->child_boxes = gf_list_new();\n\t\t\t\tgf_list_add(trak->child_boxes, senc);\n\t\t\t}\n\t\t}\n\n\t\t/*get sample auxiliary information by saiz/saio rather than by parsing senc box*/\n\t\tif (gf_isom_cenc_has_saiz_saio_traf(traf, scheme_type)) {\n\t\t\tu32 nb_saio;\n\t\t\tu32 aux_info_type;\n\t\t\tu64 offset;\n\t\t\tGF_Err e;\n\t\t\tBool is_encrypted;\n\t\t\tGF_SampleAuxiliaryInfoOffsetBox *saio = NULL;\n\t\t\tGF_SampleAuxiliaryInfoSizeBox *saiz = NULL;\n\n\t\t\toffset = nb_saio = 0;\n\n\t\t\tfor (i = 0; i < gf_list_count(traf->sai_offsets); i++) {\n\t\t\t\tsaio = (GF_SampleAuxiliaryInfoOffsetBox *)gf_list_get(traf->sai_offsets, i);\n\t\t\t\taux_info_type = saio->aux_info_type;\n\t\t\t\tif (!aux_info_type) aux_info_type = scheme_type;\n\n\t\t\t\t/*if we have only 1 sai_offsets, assume that its type is cenc*/\n\t\t\t\tif ((aux_info_type == GF_ISOM_CENC_SCHEME) || (aux_info_type == GF_ISOM_CBC_SCHEME) ||\n\t\t\t\t\t(aux_info_type == GF_ISOM_CENS_SCHEME) || (aux_info_type == GF_ISOM_CBCS_SCHEME) ||\n\t\t\t\t\t(gf_list_count(traf->sai_offsets) == 1)) {\n\t\t\t\t\toffset = saio->offsets[0] + moof_offset;\n\t\t\t\t\tnb_saio = saio->entry_count;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < gf_list_count(traf->sai_sizes); i++) {\n\t\t\t\tsaiz = (GF_SampleAuxiliaryInfoSizeBox *)gf_list_get(traf->sai_sizes, i);\n\t\t\t\taux_info_type = saiz->aux_info_type;\n\t\t\t\tif (!aux_info_type) aux_info_type = scheme_type;\n\t\t\t\t/*if we have only 1 sai_sizes, assume that its type is cenc*/\n\t\t\t\tif ((aux_info_type == GF_ISOM_CENC_SCHEME) || (aux_info_type == GF_ISOM_CBC_SCHEME) ||\n\t\t\t\t\t(aux_info_type == GF_ISOM_CENS_SCHEME) || (aux_info_type == GF_ISOM_CBCS_SCHEME) ||\n\t\t\t\t\t(gf_list_count(traf->sai_sizes) == 1)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (saiz && saio && senc) {\n\t\t\t\tfor (i = 0; i < saiz->sample_count; i++) {\n\t\t\t\t\tGF_CENCSampleAuxInfo *sai;\n\t\t\t\t\tconst u8 *key_info=NULL;\n\t\t\t\t\tu32 key_info_size;\n\t\t\t\t\tu64 cur_position;\n\t\t\t\t\tif (nb_saio != 1)\n\t\t\t\t\t\toffset = saio->offsets[i] + moof_offset;\n\t\t\t\t\tsize = saiz->default_sample_info_size ? saiz->default_sample_info_size : saiz->sample_info_size[i];\n\n\t\t\t\t\tcur_position = gf_bs_get_position(trak->moov->mov->movieFileMap->bs);\n\t\t\t\t\tgf_bs_seek(trak->moov->mov->movieFileMap->bs, offset);\n\n\t\t\t\t\tGF_SAFEALLOC(sai, GF_CENCSampleAuxInfo);\n\t\t\t\t\tif (!sai) return GF_OUT_OF_MEM;\n\n\t\t\t\t\te = gf_isom_get_sample_cenc_info_internal(trak, traf, senc, i+1, &is_encrypted, NULL, NULL, &key_info, &key_info_size);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[isobmf] could not get cenc info for sample %d: %s\\n\", i+1, gf_error_to_string(e) ));\n\t\t\t\t\t\treturn e;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (is_encrypted) {\n\t\t\t\t\t\tsai->cenc_data_size = size;\n\t\t\t\t\t\tsai->cenc_data = gf_malloc(sizeof(u8)*size);\n\t\t\t\t\t\tif (!sai->cenc_data) return GF_OUT_OF_MEM;\n\t\t\t\t\t\tgf_bs_read_data(trak->moov->mov->movieFileMap->bs, sai->cenc_data, sai->cenc_data_size);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsai->isNotProtected=1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (key_info) {\n\t\t\t\t\t\t//not multikey\n\t\t\t\t\t\tif (!key_info[0]) {\n\t\t\t\t\t\t\t//size greater than IV\n\t\t\t\t\t\t\tif (size > key_info[3])\n\t\t\t\t\t\t\t\tsenc->flags = 0x00000002;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//multikey, always use subsamples\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tsenc->flags = 0x00000002;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\n\t\t\t\t\tgf_bs_seek(trak->moov->mov->movieFileMap->bs, cur_position);\n\n\t\t\t\t\tgf_list_add(senc->samp_aux_info, sai);\n\n\t\t\t\t\te = gf_isom_cenc_merge_saiz_saio(senc, trak->Media->information->sampleTable, offset, size);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t\tif (nb_saio == 1)\n\t\t\t\t\t\toffset += size;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (traf->sample_encryption) {\n\t\t\tsenc_Parse(trak->moov->mov->movieFileMap->bs, trak, traf, traf->sample_encryption);\n\t\t\ttrak->sample_encryption->AlgorithmID = traf->sample_encryption->AlgorithmID;\n\t\t\tif (!trak->sample_encryption->IV_size)\n\t\t\t\ttrak->sample_encryption->IV_size = traf->sample_encryption->IV_size;\n\t\t\tif (!trak->sample_encryption->samp_aux_info) trak->sample_encryption->samp_aux_info = gf_list_new();\n\t\t\tgf_list_transfer(trak->sample_encryption->samp_aux_info, traf->sample_encryption->samp_aux_info);\n\t\t\tif (traf->sample_encryption->flags & 0x00000002)\n\t\t\t\ttrak->sample_encryption->flags |= 0x00000002;\n\t\t}\n\t}\n\treturn GF_OK;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1038,
    "critical_vars": [
      "saio->offsets",
      "saio->entry_count"
    ],
    "function": "MergeTrack",
    "filename": "gpac/CVE-2021-31260/CVE-2021-31260_CWE-476_df8fffd839fe5ae9acd82d26fd48280a397411d9_track.c.diff",
    "function_code": "GF_Err MergeTrack(GF_TrackBox *trak, GF_TrackFragmentBox *traf, GF_MovieFragmentBox *moof_box, u64 moof_offset, s32 compressed_diff, u64 *cumulated_offset, Bool is_first_merge)\n{\n\tu32 i, j, chunk_size, track_num;\n\tu64 base_offset, data_offset, traf_duration;\n\tu32 def_duration, DescIndex, def_size, def_flags;\n\tu32 duration, size, flags, prev_trun_data_offset, sample_index;\n\tu8 pad, sync;\n\tu16 degr;\n\tBool first_samp_in_traf=GF_TRUE;\n\tBool store_traf_map=GF_FALSE;\n\tu8 *moof_template=NULL;\n\tu32 moof_template_size=0;\n\tBool is_seg_start = GF_FALSE;\n\tu64 seg_start=0, sidx_start=0, sidx_end=0, frag_start=0, last_dts=0;\n\tGF_TrackFragmentRunBox *trun;\n\tGF_TrunEntry *ent;\n#ifdef GF_ENABLE_CTRN\n\tGF_TrackFragmentBox *traf_ref = NULL;\n#endif\n\n\tGF_Err stbl_AppendTime(GF_SampleTableBox *stbl, u32 duration, u32 nb_pack);\n\tGF_Err stbl_AppendSize(GF_SampleTableBox *stbl, u32 size, u32 nb_pack);\n\tGF_Err stbl_AppendChunk(GF_SampleTableBox *stbl, u64 offset);\n\tGF_Err stbl_AppendSampleToChunk(GF_SampleTableBox *stbl, u32 DescIndex, u32 samplesInChunk);\n\tGF_Err stbl_AppendCTSOffset(GF_SampleTableBox *stbl, s32 CTSOffset);\n\tGF_Err stbl_AppendRAP(GF_SampleTableBox *stbl, u8 isRap);\n\tGF_Err stbl_AppendPadding(GF_SampleTableBox *stbl, u8 padding);\n\tGF_Err stbl_AppendDegradation(GF_SampleTableBox *stbl, u16 DegradationPriority);\n\n\tif (trak->Header->trackID != traf->tfhd->trackID) return GF_OK;\n\tif (!trak->Media->information->sampleTable\n\t\t|| !trak->Media->information->sampleTable->SampleSize\n\t\t|| !trak->Media->information->sampleTable->TimeToSample\n\t\t|| !trak->Media->information->sampleTable->SampleToChunk\n\t\t|| !trak->Media->information->sampleTable->ChunkOffset\n\t) {\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tif (!traf->trex->track)\n\t\ttraf->trex->track = trak;\n\n\t//setup all our defaults\n\tDescIndex = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_DESC) ? traf->tfhd->sample_desc_index : traf->trex->def_sample_desc_index;\n\tif (!DescIndex) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] default sample description set to 0, likely broken ! Fixing to 1\\n\" ));\n\t\tDescIndex = 1;\n\t} else if (DescIndex > gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] default sample description set to %d but only %d sample description(s), likely broken ! Fixing to 1\\n\", DescIndex, gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes)));\n\t\tDescIndex = 1;\n\t}\n#ifdef GF_ENABLE_CTRN\n\tif (traf->trex->inherit_from_traf_id) {\n\t\tu32 traf_count = gf_list_count(moof_box->TrackList);\n\t\tfor (i=0; i<traf_count; i++) {\n\t\t\tGF_TrackFragmentBox *atraf = gf_list_get(moof_box->TrackList, i);\n\t\t\tif (atraf->tfhd && atraf->tfhd->trackID==traf->trex->inherit_from_traf_id) {\n\t\t\t\ttraf_ref = atraf;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tdef_duration = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_DUR) ? traf->tfhd->def_sample_duration : traf->trex->def_sample_duration;\n\tdef_size = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_SIZE) ? traf->tfhd->def_sample_size : traf->trex->def_sample_size;\n\tdef_flags = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_FLAGS) ? traf->tfhd->def_sample_flags : traf->trex->def_sample_flags;\n\n\t//locate base offset, by default use moof (dash-like)\n\tbase_offset = moof_offset;\n\t//explicit base offset, use it\n\tif (traf->tfhd->flags & GF_ISOM_TRAF_BASE_OFFSET)\n\t\tbase_offset = traf->tfhd->base_data_offset;\n\t//no moof offset and no explicit offset, the offset is the end of the last written chunk of\n\t//the previous traf. For the first traf, *cumulated_offset is actually moof offset\n\telse if (!(traf->tfhd->flags & GF_ISOM_MOOF_BASE_OFFSET))\n\t\tbase_offset = *cumulated_offset;\n\n\tchunk_size = 0;\n\tprev_trun_data_offset = 0;\n\tdata_offset = 0;\n\ttraf_duration = 0;\n\n\t/*in playback mode*/\n\tif (traf->tfdt && is_first_merge) {\n#ifndef GPAC_DISABLE_LOG\n\t\tif (trak->moov->mov->NextMoofNumber && trak->present_in_scalable_segment && trak->sample_count_at_seg_start && (trak->dts_at_seg_start != traf->tfdt->baseMediaDecodeTime)) {\n\t\t\ts32 drift = (s32) ((s64) traf->tfdt->baseMediaDecodeTime - (s64)trak->dts_at_seg_start);\n\t\t\tif (drift<0)  {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Warning: TFDT timing \"LLD\" less than cumulated timing \"LLD\" - using tfdt\\n\", traf->tfdt->baseMediaDecodeTime, trak->dts_at_seg_start ));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[iso file] TFDT timing \"LLD\" higher than cumulated timing \"LLD\" (last sample got extended in duration)\\n\", traf->tfdt->baseMediaDecodeTime, trak->dts_at_seg_start ));\n\t\t\t}\n\t\t}\n#endif\n\t\ttrak->dts_at_seg_start = traf->tfdt->baseMediaDecodeTime;\n\t}\n\telse if (traf->tfxd) {\n\t\ttrak->dts_at_seg_start = traf->tfxd->absolute_time_in_track_timescale;\n\t}\n\n\tif (traf->tfxd) {\n\t\ttrak->last_tfxd_value = traf->tfxd->absolute_time_in_track_timescale;\n\t\ttrak->last_tfxd_value += traf->tfxd->fragment_duration_in_track_timescale;\n\t}\n\tif (traf->tfrf) {\n\t\tif (trak->tfrf) gf_isom_box_del_parent(&trak->child_boxes, (GF_Box *)trak->tfrf);\n\t\ttrak->tfrf = traf->tfrf;\n\t\tgf_list_del_item(traf->child_boxes, traf->tfrf);\n\t\tgf_list_add(trak->child_boxes, trak->tfrf);\n\t}\n\n\tif (trak->moov->mov->signal_frag_bounds) {\n\t\tstore_traf_map = GF_TRUE;\n\t\tif (is_first_merge) {\n\t\t\tGF_MovieFragmentBox *moof_clone = NULL;\n\t\t\tgf_isom_box_freeze_order((GF_Box *)moof_box);\n\t\t\tgf_isom_clone_box((GF_Box *)moof_box, (GF_Box **)&moof_clone);\n\n\t\t\tif (moof_clone) {\n\t\t\t\tGF_BitStream *bs;\n\t\t\t\tfor (i=0; i<gf_list_count(moof_clone->TrackList); i++) {\n\t\t\t\t\tGF_TrackFragmentBox *traf_clone = gf_list_get(moof_clone->TrackList, i);\n\t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->TrackRuns);\n\t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sampleGroups);\n\t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sampleGroupsDescription);\n\t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sub_samples);\n\t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sai_offsets);\n\t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sai_sizes);\n\t\t\t\t\tif (traf_clone->sample_encryption) {\n\t\t\t\t\t\tgf_isom_box_del_parent(&traf_clone->child_boxes, (GF_Box *) traf_clone->sample_encryption);\n\t\t\t\t\t\ttraf_clone->sample_encryption = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif (traf_clone->sdtp) {\n\t\t\t\t\t\tgf_isom_box_del_parent(&traf_clone->child_boxes, (GF_Box *) traf_clone->sdtp);\n\t\t\t\t\t\ttraf_clone->sdtp = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_isom_box_size((GF_Box *)moof_clone);\n\t\t\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\t\t\t\tif (trak->moov->mov->seg_styp) {\n\t\t\t\t\tgf_isom_box_size(trak->moov->mov->seg_styp);\n\t\t\t\t\tgf_isom_box_write(trak->moov->mov->seg_styp, bs);\n\t\t\t\t}\n\t\t\t\tif (trak->moov->mov->root_sidx) {\n\t\t\t\t\tgf_isom_box_size((GF_Box *)trak->moov->mov->root_sidx);\n\t\t\t\t\tgf_isom_box_write((GF_Box *)trak->moov->mov->root_sidx, bs);\n\t\t\t\t}\n\t\t\t\tif (trak->moov->mov->seg_ssix) {\n\t\t\t\t\tgf_isom_box_size(trak->moov->mov->seg_ssix);\n\t\t\t\t\tgf_isom_box_write(trak->moov->mov->seg_ssix, bs);\n\t\t\t\t}\n\t\t\t\tgf_isom_box_write((GF_Box *)moof_clone, bs);\n\t\t\t\tgf_isom_box_del((GF_Box*)moof_clone);\n\n\t\t\t\tgf_bs_get_content(bs, &moof_template, &moof_template_size);\n\t\t\t\tgf_bs_del(bs);\n\t\t\t}\n\t\t}\n\t\tif (trak->moov->mov->seg_styp) {\n\t\t\tis_seg_start = GF_TRUE;\n\t\t\tseg_start = trak->moov->mov->styp_start_offset;\n\t\t}\n\t\tif (trak->moov->mov->root_sidx) {\n\t\t\tis_seg_start = GF_TRUE;\n\t\t\tsidx_start = trak->moov->mov->sidx_start_offset;\n\t\t\tsidx_end = trak->moov->mov->sidx_end_offset;\n\t\t\tif (! seg_start || (sidx_start<seg_start))\n\t\t\t\tseg_start = sidx_start;\n\t\t}\n\t\tfrag_start = trak->moov->mov->current_top_box_start;\n\t}\n\telse if (trak->moov->mov->store_traf_map) {\n\t\tstore_traf_map = GF_TRUE;\n\t}\n\n\n\tsample_index = 0;\n\ti=0;\n\twhile ((trun = (GF_TrackFragmentRunBox *)gf_list_enum(traf->TrackRuns, &i))) {\n\t\t//merge the run\n\t\tfor (j=0; j<trun->sample_count; j++) {\n\t\t\tGF_Err e;\n\t\t\ts32 cts_offset=0;\n\t\t\tif (j<trun->nb_samples) {\n\t\t\t\tent = &trun->samples[j];\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Track %d doesn't have enough trun entries (%d) compared to sample count (%d) in run\\n\", traf->trex->trackID, trun->nb_samples, trun->sample_count ));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsize = def_size;\n\t\t\tduration = def_duration;\n\t\t\tflags = def_flags;\n\n\t\t\t//CTS - if flag not set (trun or ctrn) defaults to 0 which is the base value after alloc\n\t\t\t//we just need to overrite its value if inherited\n\t\t\tcts_offset = ent->CTS_Offset;\n\n#ifdef GF_ENABLE_CTRN\n\t\t\tif (trun->use_ctrn) {\n\t\t\t\tif (!j && (trun->ctrn_flags & GF_ISOM_CTRN_FIRST_SAMPLE) ) {\n\t\t\t\t\tif (trun->ctrn_first_dur) duration = ent->Duration;\n\t\t\t\t\tif (trun->ctrn_first_size) size = ent->size;\n\t\t\t\t\tif (trun->ctrn_first_ctts) flags = ent->flags;\n\t\t\t\t} else {\n\t\t\t\t\tif (trun->ctrn_dur) duration = ent->Duration;\n\t\t\t\t\tif (trun->ctrn_size) size = ent->size;\n\t\t\t\t\tif (trun->ctrn_sample_flags) flags = ent->flags;\n\t\t\t\t}\n\t\t\t\t/*re-override*/\n\t\t\t\tif (trun->ctrn_flags & 0xF0) {\n\t\t\t\t\tGF_TrunEntry *ref_entry;\n\t\t\t\t\tif (!traf_ref) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Track %d use traf inheritance to track ID %d but reference traf not found\\n\", traf->trex->trackID, traf->trex->inherit_from_traf_id ));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tref_entry = traf_get_sample_entry(traf_ref, sample_index);\n\t\t\t\t\tif (!ref_entry) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Track %d use traf inheritance but sample %d not found in reference traf\\n\", traf->trex->trackID, sample_index+1 ));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_DUR)\n\t\t\t\t\t\tduration = ref_entry->Duration;\n\t\t\t\t\tif (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_SIZE)\n\t\t\t\t\t\tsize = ref_entry->size;\n\t\t\t\t\tif (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_FLAGS)\n\t\t\t\t\t\tflags = ref_entry->flags;\n\t\t\t\t\tif (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_CTSO)\n\t\t\t\t\t\tcts_offset = ref_entry->CTS_Offset;\n\t\t\t\t}\n\n\t\t\t} else\n#endif\n\t\t\t{\n\t\t\t\tif (trun->flags & GF_ISOM_TRUN_DURATION) duration = ent->Duration;\n\t\t\t\tif (trun->flags & GF_ISOM_TRUN_SIZE) size = ent->size;\n\t\t\t\tif (trun->flags & GF_ISOM_TRUN_FLAGS) {\n\t\t\t\t\tflags = ent->flags;\n\t\t\t\t} else if (!j && (trun->flags & GF_ISOM_TRUN_FIRST_FLAG)) {\n\t\t\t\t\tflags = trun->first_sample_flags;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsample_index++;\n\t\t\t/*store the resolved value in case we have inheritance*/\n\t\t\tent->size = size;\n\t\t\tent->Duration = duration;\n\t\t\tent->flags = flags;\n\t\t\tent->CTS_Offset = cts_offset;\n\n\t\t\tlast_dts += duration;\n\n\t\t\t//add size first\n\t\t\tif (!trak->Media->information->sampleTable->SampleSize) {\n\t\t\t\ttrak->Media->information->sampleTable->SampleSize = (GF_SampleSizeBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STSZ);\n\t\t\t\tif (!trak->Media->information->sampleTable->SampleSize)\n\t\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\te = stbl_AppendSize(trak->Media->information->sampleTable, size, ent->nb_pack);\n\t\t\tif (e) return e;\n\n\t\t\t//then TS\n\t\t\tif (!trak->Media->information->sampleTable->TimeToSample) {\n\t\t\t\ttrak->Media->information->sampleTable->TimeToSample = (GF_TimeToSampleBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STTS);\n\t\t\t\tif (!trak->Media->information->sampleTable->TimeToSample)\n\t\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\te = stbl_AppendTime(trak->Media->information->sampleTable, duration, ent->nb_pack);\n\t\t\tif (e) return e;\n\n\t\t\t//add chunk on first sample\n\t\t\tif (!j) {\n\t\t\t\tu64 final_offset;\n\t\t\t\tdata_offset = base_offset;\n\t\t\t\t//we have an explicit data offset for this trun\n\t\t\t\tif (trun->flags & GF_ISOM_TRUN_DATA_OFFSET) {\n\t\t\t\t\tdata_offset += trun->data_offset;\n\t\t\t\t\t/*reset chunk size since data is now relative to this trun*/\n\t\t\t\t\tchunk_size = 0;\n\t\t\t\t\t/*remember this data offset for following trun*/\n\t\t\t\t\tprev_trun_data_offset = trun->data_offset;\n\t\t\t\t\t/*if mdat is located after the moof, and the moof was compressed, adjust offset\n\t\t\t\t\totherwise the offset does not need adjustment*/\n\t\t\t\t\tif (trun->data_offset>=0) {\n\t\t\t\t\t\tdata_offset -= compressed_diff;\n\t\t\t\t\t\tprev_trun_data_offset -= compressed_diff;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//we had an explicit data offset for the previous trun, use it + chunk size\n\t\t\t\telse if (prev_trun_data_offset) {\n\t\t\t\t\t/*data offset is previous chunk size plus previous offset of the trun*/\n\t\t\t\t\tdata_offset += prev_trun_data_offset + chunk_size;\n\t\t\t\t}\n\t\t\t\t//no explicit data offset, continuous data after last data in previous chunk\n\t\t\t\telse {\n\t\t\t\t\tdata_offset += chunk_size;\n\t\t\t\t\t//data offset of first trun in first traf, adjust if compressed moof\n\t\t\t\t\tif ((i==1) && (trun->data_offset>=0)) {\n\t\t\t\t\t\tdata_offset -= compressed_diff;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfinal_offset = data_offset;\n\t\t\t\t//adjust offset if moov was also compressed and we are still in the same file\n\t\t\t\t//so that later call to gf_isom_get_sample properly adjust back the offset\n\t\t\t\tif (trak->moov->compressed_diff) {\n\t\t\t\t\tfinal_offset += trak->moov->compressed_diff;\n\t\t\t\t}\n\n\t\t\t\tif (!trak->Media->information->sampleTable->ChunkOffset) {\n\t\t\t\t\ttrak->Media->information->sampleTable->ChunkOffset = gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STCO);\n\t\t\t\t\tif (!trak->Media->information->sampleTable->ChunkOffset)\n\t\t\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t\te = stbl_AppendChunk(trak->Media->information->sampleTable, final_offset);\n\t\t\t\tif (e) return e;\n\t\t\t\t//then sampleToChunk\n\t\t\t\tif (!trak->Media->information->sampleTable->SampleToChunk) {\n\t\t\t\t\ttrak->Media->information->sampleTable->SampleToChunk = (GF_SampleToChunkBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STSC);\n\t\t\t\t\tif (!trak->Media->information->sampleTable->SampleToChunk)\n\t\t\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t\te = stbl_AppendSampleToChunk(trak->Media->information->sampleTable,\n\t\t\t\t                         DescIndex, trun->sample_count);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t\tchunk_size += size;\n\n\t\t\tif (store_traf_map && first_samp_in_traf) {\n\t\t\t\tfirst_samp_in_traf = GF_FALSE;\n\t\t\t\te = stbl_AppendTrafMap(trak->Media->information->sampleTable, is_seg_start, seg_start, frag_start, moof_template, moof_template_size, sidx_start, sidx_end);\n\t\t\t\tif (e) return e;\n\t\t\t\t//do not deallocate, the memory is now owned by traf map\n\t\t\t\tmoof_template = NULL;\n\t\t\t\tmoof_template_size = 0;\n\t\t\t}\n\t\t\tif (ent->nb_pack>1) {\n\t\t\t\tj+= ent->nb_pack-1;\n\t\t\t\ttraf_duration += ent->nb_pack*duration;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttraf_duration += duration;\n\n\t\t\te = stbl_AppendCTSOffset(trak->Media->information->sampleTable, cts_offset);\n\t\t\tif (e) return e;\n\t\t\t//flags\n\t\t\tsync = GF_ISOM_GET_FRAG_SYNC(flags);\n\t\t\tif (trak->Media->information->sampleTable->no_sync_found && sync) {\n\t\t\t\ttrak->Media->information->sampleTable->no_sync_found = 0;\n\t\t\t}\n\t\t\te = stbl_AppendRAP(trak->Media->information->sampleTable, sync);\n\t\t\tif (e) return e;\n\t\t\tpad = GF_ISOM_GET_FRAG_PAD(flags);\n\t\t\tif (pad) {\n\t\t\t\te = stbl_AppendPadding(trak->Media->information->sampleTable, pad);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t\tdegr = GF_ISOM_GET_FRAG_DEG(flags);\n\t\t\tif (degr) {\n\t\t\t\te = stbl_AppendDegradation(trak->Media->information->sampleTable, degr);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t\te = stbl_AppendDependencyType(trak->Media->information->sampleTable, GF_ISOM_GET_FRAG_LEAD(flags), GF_ISOM_GET_FRAG_DEPENDS(flags), GF_ISOM_GET_FRAG_DEPENDED(flags), GF_ISOM_GET_FRAG_REDUNDANT(flags));\n\t\t\tif (e) return e;\n\t\t}\n\t}\n\n\tif (trak->moov->mov->is_smooth && !traf->tfdt && !traf->tfxd) {\n\t\tif (is_first_merge)\n\t\t\ttrak->dts_at_seg_start = trak->dts_at_next_seg_start;\n\t\ttrak->dts_at_next_seg_start += last_dts;\n\t}\n\tif (traf_duration && trak->editBox && trak->editBox->editList) {\n\t\tfor (i=0; i<gf_list_count(trak->editBox->editList->entryList); i++) {\n\t\t\tGF_EdtsEntry *edts_e = gf_list_get(trak->editBox->editList->entryList, i);\n\t\t\tif (edts_e->was_empty_dur) {\n\t\t\t\tu64 extend_dur = traf_duration;\n\t\t\t\textend_dur *= trak->moov->mvhd->timeScale;\n\t\t\t\textend_dur /= trak->Media->mediaHeader->timeScale;\n\t\t\t\tedts_e->segmentDuration += extend_dur;\n\t\t\t}\n\t\t\telse if (!edts_e->segmentDuration) {\n\t\t\t\tedts_e->was_empty_dur = GF_TRUE;\n\t\t\t\tif ((s64) traf_duration > edts_e->mediaTime)\n\t\t\t\t\ttraf_duration -= edts_e->mediaTime;\n\t\t\t\telse\n\t\t\t\t\ttraf_duration = 0;\n\n\t\t\t\tedts_e->segmentDuration = traf_duration;\n\t\t\t\tedts_e->segmentDuration *= trak->moov->mvhd->timeScale;\n\t\t\t\tedts_e->segmentDuration /= trak->Media->mediaHeader->timeScale;\n\t\t\t}\n\n\t\t}\n\t}\n\n\t//in any case, update the cumulated offset\n\t//this will handle hypothetical files mixing MOOF offset and implicit non-moof offset\n\t*cumulated_offset = data_offset + chunk_size;\n\n\t/*merge sample groups*/\n\tif (traf->sampleGroups) {\n\t\tGF_List *groups;\n\t\tGF_List *groupDescs;\n\t\tBool is_identical_sgpd = GF_TRUE;\n\t\tu32 *new_idx = NULL, new_idx_count=0;\n\n\t\tif (!trak->Media->information->sampleTable->sampleGroups)\n\t\t\ttrak->Media->information->sampleTable->sampleGroups = gf_list_new();\n\n\t\tif (!trak->Media->information->sampleTable->sampleGroupsDescription)\n\t\t\ttrak->Media->information->sampleTable->sampleGroupsDescription = gf_list_new();\n\n\t\tgroupDescs = trak->Media->information->sampleTable->sampleGroupsDescription;\n\t\tfor (i=0; i<gf_list_count(traf->sampleGroupsDescription); i++) {\n\t\t\tGF_SampleGroupDescriptionBox *new_sgdesc = NULL;\n\t\t\tGF_SampleGroupDescriptionBox *sgdesc = gf_list_get(traf->sampleGroupsDescription, i);\n\t\t\tfor (j=0; j<gf_list_count(groupDescs); j++) {\n\t\t\t\tnew_sgdesc = gf_list_get(groupDescs, j);\n\t\t\t\tif (new_sgdesc->grouping_type==sgdesc->grouping_type) break;\n\t\t\t\tnew_sgdesc = NULL;\n\t\t\t}\n\t\t\t/*new description, move it to our sample table*/\n\t\t\tif (!new_sgdesc) {\n\t\t\t\tgf_list_add(groupDescs, sgdesc);\n\t\t\t\tgf_list_add(trak->Media->information->sampleTable->child_boxes, sgdesc);\n\t\t\t\tgf_list_rem(traf->sampleGroupsDescription, i);\n\t\t\t\tgf_list_del_item(traf->child_boxes, sgdesc);\n\t\t\t\ti--;\n\t\t\t}\n\t\t\t/*merge descriptions*/\n\t\t\telse {\n\t\t\t\tu32 count;\n\n\t\t\t\tis_identical_sgpd = gf_isom_is_identical_sgpd(new_sgdesc, sgdesc, 0);\n\t\t\t\tif (is_identical_sgpd)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tnew_idx_count = gf_list_count(sgdesc->group_descriptions);\n\t\t\t\tnew_idx = (u32 *)gf_malloc(new_idx_count * sizeof(u32));\n\t\t\t\tif (!new_idx) return GF_OUT_OF_MEM;\n\n\t\t\t\tcount = 0;\n\t\t\t\twhile (gf_list_count(sgdesc->group_descriptions)) {\n\t\t\t\t\tvoid *sgpd_entry = gf_list_get(sgdesc->group_descriptions, 0);\n\t\t\t\t\tBool new_entry = GF_TRUE;\n\n\t\t\t\t\tfor (j = 0; j < gf_list_count(new_sgdesc->group_descriptions); j++) {\n\t\t\t\t\t\tvoid *ptr = gf_list_get(new_sgdesc->group_descriptions, j);\n\t\t\t\t\t\tif (gf_isom_is_identical_sgpd(sgpd_entry, ptr, new_sgdesc->grouping_type)) {\n\t\t\t\t\t\t\tnew_idx[count] = j + 1;\n\t\t\t\t\t\t\tcount ++;\n\t\t\t\t\t\t\tnew_entry = GF_FALSE;\n\t\t\t\t\t\t\tgf_free(sgpd_entry);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (new_entry) {\n\t\t\t\t\t\tgf_list_add(new_sgdesc->group_descriptions, sgpd_entry);\n\t\t\t\t\t\tnew_idx[count] = gf_list_count(new_sgdesc->group_descriptions);\n\t\t\t\t\t\tcount ++;\n\t\t\t\t\t}\n\n\t\t\t\t\tgf_list_rem(sgdesc->group_descriptions, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tgroups = trak->Media->information->sampleTable->sampleGroups;\n\t\tfor (i=0; i<gf_list_count(traf->sampleGroups); i++) {\n\t\t\tGF_SampleGroupBox *stbl_group = NULL;\n\t\t\tGF_SampleGroupBox *frag_group = gf_list_get(traf->sampleGroups, i);\n\n\n\t\t\tfor (j=0; j<gf_list_count(groups); j++) {\n\t\t\t\tstbl_group = gf_list_get(groups, j);\n\t\t\t\tif ((frag_group->grouping_type==stbl_group->grouping_type) && (frag_group->grouping_type_parameter==stbl_group->grouping_type_parameter))\n\t\t\t\t\tbreak;\n\t\t\t\tstbl_group = NULL;\n\t\t\t}\n\t\t\tif (!stbl_group) {\n\t\t\t\tstbl_group = (GF_SampleGroupBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_SBGP);\n\t\t\t\tif (!stbl_group) return GF_OUT_OF_MEM;\n\t\t\t\tstbl_group->grouping_type = frag_group->grouping_type;\n\t\t\t\tstbl_group->grouping_type_parameter = frag_group->grouping_type_parameter;\n\t\t\t\tstbl_group->version = frag_group->version;\n\t\t\t\tgf_list_add(groups, stbl_group);\n\t\t\t}\n\n\t\t\tif (is_identical_sgpd) {\n\t\t\t\t//adjust sgpd index: in traf index start at 0x1001\n\t\t\t\tfor (j = 0; j < frag_group->entry_count; j++)\n\t\t\t\t\tfrag_group->sample_entries[j].group_description_index &= 0x0FFFF;\n\t\t\t\tif (frag_group->entry_count && stbl_group->entry_count &&\n\t\t\t\t        (frag_group->sample_entries[0].group_description_index==stbl_group->sample_entries[stbl_group->entry_count-1].group_description_index)\n\t\t\t\t   ) {\n\t\t\t\t\tstbl_group->sample_entries[stbl_group->entry_count - 1].sample_count += frag_group->sample_entries[0].sample_count;\n\t\t\t\t\tif (frag_group->entry_count>1) {\n\t\t\t\t\t\tstbl_group->sample_entries = gf_realloc(stbl_group->sample_entries, sizeof(GF_SampleGroupEntry) * (stbl_group->entry_count + frag_group->entry_count - 1));\n\t\t\t\t\t\tmemcpy(&stbl_group->sample_entries[stbl_group->entry_count], &frag_group->sample_entries[1], sizeof(GF_SampleGroupEntry) * (frag_group->entry_count - 1));\n\t\t\t\t\t\tstbl_group->entry_count += frag_group->entry_count - 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tstbl_group->sample_entries = gf_realloc(stbl_group->sample_entries, sizeof(GF_SampleGroupEntry) * (stbl_group->entry_count + frag_group->entry_count));\n\t\t\t\t\tmemcpy(&stbl_group->sample_entries[stbl_group->entry_count], &frag_group->sample_entries[0], sizeof(GF_SampleGroupEntry) * frag_group->entry_count);\n\t\t\t\t\tstbl_group->entry_count += frag_group->entry_count;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstbl_group->sample_entries = gf_realloc(stbl_group->sample_entries, sizeof(GF_SampleGroupEntry) * (stbl_group->entry_count + frag_group->entry_count));\n\t\t\t\t//adjust sgpd index\n\t\t\t\tfor (j = 0; j < frag_group->entry_count; j++) {\n\t\t\t\t\tu32 sgidx = frag_group->sample_entries[j].group_description_index;\n\t\t\t\t\tif (sgidx > 0x10000) {\n\t\t\t\t\t\tsgidx -= 0x10001;\n\t\t\t\t\t\tif (sgidx>=new_idx_count) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[isobmf] corrupted sample group index in fragment %d but only %d group descriptions in fragment\\n\", sgidx, new_idx_count));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfrag_group->sample_entries[j].group_description_index = new_idx[sgidx];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmemcpy(&stbl_group->sample_entries[stbl_group->entry_count], &frag_group->sample_entries[0], sizeof(GF_SampleGroupEntry) * frag_group->entry_count);\n\t\t\t\tstbl_group->entry_count += frag_group->entry_count;\n\t\t\t}\n\t\t}\n\n\t\tif (new_idx) gf_free(new_idx);\n\t}\n\n\t/*content is encrypted*/\n\ttrack_num = gf_isom_get_tracknum_from_id(trak->moov, trak->Header->trackID);\n\tif (gf_isom_is_cenc_media(trak->moov->mov, track_num, DescIndex)\n\t\t|| traf->sample_encryption) {\n\t\t/*Merge sample auxiliary encryption information*/\n\t\tGF_SampleEncryptionBox *senc = NULL;\n\t\tu32 scheme_type;\n\t\tgf_isom_get_cenc_info(trak->moov->mov, track_num, DescIndex, NULL, &scheme_type, NULL);\n\n\t\tif (traf->sample_encryption) {\n\t\t\tfor (i = 0; i < gf_list_count(trak->Media->information->sampleTable->child_boxes); i++) {\n\t\t\t\tGF_Box *a = (GF_Box *)gf_list_get(trak->Media->information->sampleTable->child_boxes, i);\n\t\t\t\tif (a->type != traf->sample_encryption->type) continue;\n\n\t\t\t\tif ((a->type ==GF_ISOM_BOX_TYPE_UUID) && (((GF_UUIDBox *)a)->internal_4cc == GF_ISOM_BOX_UUID_PSEC)) {\n\t\t\t\t\tsenc = (GF_SampleEncryptionBox *)a;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (a->type ==GF_ISOM_BOX_TYPE_SENC) {\n\t\t\t\t\tsenc = (GF_SampleEncryptionBox *)a;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!senc && trak->sample_encryption)\n\t\t\t\tsenc = trak->sample_encryption;\n\n\t\t\tif (!senc) {\n\t\t\t\tif (traf->sample_encryption->piff_type==1) {\n\t\t\t\t\tsenc = (GF_SampleEncryptionBox *)gf_isom_create_piff_psec_box(1, 0x2, 0, 0, NULL);\n\t\t\t\t} else {\n\t\t\t\t\tsenc = gf_isom_create_samp_enc_box(1, 0x2);\n\t\t\t\t}\n\n\t\t\t\tif (!trak->Media->information->sampleTable->child_boxes) trak->Media->information->sampleTable->child_boxes = gf_list_new();\n\n\t\t\t\ttrak->sample_encryption = senc;\n\t\t\t\tif (!trak->child_boxes) trak->child_boxes = gf_list_new();\n\t\t\t\tgf_list_add(trak->child_boxes, senc);\n\t\t\t}\n\t\t}\n\n\t\t/*get sample auxiliary information by saiz/saio rather than by parsing senc box*/\n\t\tif (gf_isom_cenc_has_saiz_saio_traf(traf, scheme_type)) {\n\t\t\tu32 nb_saio;\n\t\t\tu32 aux_info_type;\n\t\t\tu64 offset;\n\t\t\tGF_Err e;\n\t\t\tBool is_encrypted;\n\t\t\tGF_SampleAuxiliaryInfoOffsetBox *saio = NULL;\n\t\t\tGF_SampleAuxiliaryInfoSizeBox *saiz = NULL;\n\n\t\t\toffset = nb_saio = 0;\n\n\t\t\tfor (i = 0; i < gf_list_count(traf->sai_offsets); i++) {\n\t\t\t\tsaio = (GF_SampleAuxiliaryInfoOffsetBox *)gf_list_get(traf->sai_offsets, i);\n\t\t\t\taux_info_type = saio->aux_info_type;\n\t\t\t\tif (!aux_info_type) aux_info_type = scheme_type;\n\n\t\t\t\t/*if we have only 1 sai_offsets, assume that its type is cenc*/\n\t\t\t\tif ((aux_info_type == GF_ISOM_CENC_SCHEME) || (aux_info_type == GF_ISOM_CBC_SCHEME) ||\n\t\t\t\t\t(aux_info_type == GF_ISOM_CENS_SCHEME) || (aux_info_type == GF_ISOM_CBCS_SCHEME) ||\n\t\t\t\t\t(gf_list_count(traf->sai_offsets) == 1)) {\n\t\t\t\t\tif (saio->offsets && saio->entry_count) {\n\t\t\t\t\t\toffset = saio->offsets[0] + moof_offset;\n\t\t\t\t\t\tnb_saio = saio->entry_count;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsaio = NULL;\n\t\t\t}\n\t\t\tfor (i = 0; i < gf_list_count(traf->sai_sizes); i++) {\n\t\t\t\tsaiz = (GF_SampleAuxiliaryInfoSizeBox *)gf_list_get(traf->sai_sizes, i);\n\t\t\t\taux_info_type = saiz->aux_info_type;\n\t\t\t\tif (!aux_info_type) aux_info_type = scheme_type;\n\t\t\t\t/*if we have only 1 sai_sizes, assume that its type is cenc*/\n\t\t\t\tif ((aux_info_type == GF_ISOM_CENC_SCHEME) || (aux_info_type == GF_ISOM_CBC_SCHEME) ||\n\t\t\t\t\t(aux_info_type == GF_ISOM_CENS_SCHEME) || (aux_info_type == GF_ISOM_CBCS_SCHEME) ||\n\t\t\t\t\t(gf_list_count(traf->sai_sizes) == 1)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsaiz = NULL;\n\t\t\t}\n\t\t\tif (saiz && saio && senc) {\n\t\t\t\tfor (i = 0; i < saiz->sample_count; i++) {\n\t\t\t\t\tGF_CENCSampleAuxInfo *sai;\n\t\t\t\t\tconst u8 *key_info=NULL;\n\t\t\t\t\tu32 key_info_size;\n\t\t\t\t\tu64 cur_position;\n\t\t\t\t\tif (nb_saio != 1)\n\t\t\t\t\t\toffset = saio->offsets[i] + moof_offset;\n\t\t\t\t\tsize = saiz->default_sample_info_size ? saiz->default_sample_info_size : saiz->sample_info_size[i];\n\n\t\t\t\t\tcur_position = gf_bs_get_position(trak->moov->mov->movieFileMap->bs);\n\t\t\t\t\tgf_bs_seek(trak->moov->mov->movieFileMap->bs, offset);\n\n\t\t\t\t\tGF_SAFEALLOC(sai, GF_CENCSampleAuxInfo);\n\t\t\t\t\tif (!sai) return GF_OUT_OF_MEM;\n\n\t\t\t\t\te = gf_isom_get_sample_cenc_info_internal(trak, traf, senc, i+1, &is_encrypted, NULL, NULL, &key_info, &key_info_size);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[isobmf] could not get cenc info for sample %d: %s\\n\", i+1, gf_error_to_string(e) ));\n\t\t\t\t\t\treturn e;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (is_encrypted) {\n\t\t\t\t\t\tsai->cenc_data_size = size;\n\t\t\t\t\t\tsai->cenc_data = gf_malloc(sizeof(u8)*size);\n\t\t\t\t\t\tif (!sai->cenc_data) return GF_OUT_OF_MEM;\n\t\t\t\t\t\tgf_bs_read_data(trak->moov->mov->movieFileMap->bs, sai->cenc_data, sai->cenc_data_size);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsai->isNotProtected=1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (key_info) {\n\t\t\t\t\t\t//not multikey\n\t\t\t\t\t\tif (!key_info[0]) {\n\t\t\t\t\t\t\t//size greater than IV\n\t\t\t\t\t\t\tif (size > key_info[3])\n\t\t\t\t\t\t\t\tsenc->flags = 0x00000002;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//multikey, always use subsamples\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tsenc->flags = 0x00000002;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\n\t\t\t\t\tgf_bs_seek(trak->moov->mov->movieFileMap->bs, cur_position);\n\n\t\t\t\t\tgf_list_add(senc->samp_aux_info, sai);\n\n\t\t\t\t\te = gf_isom_cenc_merge_saiz_saio(senc, trak->Media->information->sampleTable, offset, size);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t\tif (nb_saio == 1)\n\t\t\t\t\t\toffset += size;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (traf->sample_encryption) {\n\t\t\tsenc_Parse(trak->moov->mov->movieFileMap->bs, trak, traf, traf->sample_encryption);\n\t\t\ttrak->sample_encryption->AlgorithmID = traf->sample_encryption->AlgorithmID;\n\t\t\tif (!trak->sample_encryption->IV_size)\n\t\t\t\ttrak->sample_encryption->IV_size = traf->sample_encryption->IV_size;\n\t\t\tif (!trak->sample_encryption->samp_aux_info) trak->sample_encryption->samp_aux_info = gf_list_new();\n\t\t\tgf_list_transfer(trak->sample_encryption->samp_aux_info, traf->sample_encryption->samp_aux_info);\n\t\t\tif (traf->sample_encryption->flags & 0x00000002)\n\t\t\t\ttrak->sample_encryption->flags |= 0x00000002;\n\t\t}\n\t}\n\treturn GF_OK;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 4708,
    "critical_vars": [
      "leads"
    ],
    "function": "gf_bs_read_ue_log_idx3",
    "filename": "gpac/CVE-2021-40564/CVE-2021-40564_CWE-476_cf6771c857eb9a290e2c19ddacfdd3ed98b27618_av_parsers.c.diff",
    "function_code": "u32 gf_bs_read_ue_log_idx3(GF_BitStream *bs, const char *fname, s32 idx1, s32 idx2, s32 idx3)\n{\n\tu32 val=0, code;\n\ts32 nb_lead = -1;\n\tu32 bits = 0;\n\tfor (code=0; !code; nb_lead++) {\n\t\tif (nb_lead>=32) {\n\t\t\t//gf_bs_read_int keeps returning 0 on EOS, so if no more bits available, rbsp was truncated otherwise code is broken in rbsp)\n\t\t\t//we only test once nb_lead>=32 to avoid testing at each bit read\n\t\t\tif (!gf_bs_available(bs)) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[Core] exp-golomb read failed, not enough bits in bitstream !\\n\"));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[Core] corrupted exp-golomb code, %d leading zeros, max 31 allowed !\\n\", nb_lead));\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\tcode = gf_bs_read_int(bs, 1);\n\t\tbits++;\n\t}\n\n\tif (nb_lead) {\n\t\tu32 leads=1;\n\t\tval = gf_bs_read_int(bs, nb_lead);\n\t\tleads <<= nb_lead;\n\t\tleads -= 1;\n\t\tval += leads;\n//\t\tval += (1 << nb_lead) - 1;\n\t\tbits += nb_lead;\n\t}\n\n\tif (fname) {\n\t\tgf_bs_log_idx(bs, bits, fname, val, idx1, idx2, idx3);\n\t}\n\treturn val;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 4709,
    "critical_vars": [
      "val"
    ],
    "function": "gf_bs_read_ue_log_idx3",
    "filename": "gpac/CVE-2021-40564/CVE-2021-40564_CWE-476_cf6771c857eb9a290e2c19ddacfdd3ed98b27618_av_parsers.c.diff",
    "function_code": "u32 gf_bs_read_ue_log_idx3(GF_BitStream *bs, const char *fname, s32 idx1, s32 idx2, s32 idx3)\n{\n\tu32 val=0, code;\n\ts32 nb_lead = -1;\n\tu32 bits = 0;\n\tfor (code=0; !code; nb_lead++) {\n\t\tif (nb_lead>=32) {\n\t\t\t//gf_bs_read_int keeps returning 0 on EOS, so if no more bits available, rbsp was truncated otherwise code is broken in rbsp)\n\t\t\t//we only test once nb_lead>=32 to avoid testing at each bit read\n\t\t\tif (!gf_bs_available(bs)) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[Core] exp-golomb read failed, not enough bits in bitstream !\\n\"));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[Core] corrupted exp-golomb code, %d leading zeros, max 31 allowed !\\n\", nb_lead));\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\tcode = gf_bs_read_int(bs, 1);\n\t\tbits++;\n\t}\n\n\tif (nb_lead) {\n\t\tval = gf_bs_read_int(bs, nb_lead);\n\t\tval += (1 << nb_lead) - 1;\n\t\tbits += nb_lead;\n\t}\n\n\tif (fname) {\n\t\tgf_bs_log_idx(bs, bits, fname, val, idx1, idx2, idx3);\n\t}\n\treturn val;\n}",
    "label": "True"
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 5674,
    "line_new": 5678,
    "critical_vars": [
      "pps_id"
    ],
    "function": "avc_parse_slice",
    "filename": "gpac/CVE-2021-40564/CVE-2021-40564_CWE-476_cf6771c857eb9a290e2c19ddacfdd3ed98b27618_av_parsers.c.diff",
    "function_code": "static s32 avc_parse_slice(GF_BitStream *bs, AVCState *avc, Bool svc_idr_flag, AVCSliceInfo *si)\n{\n\ts32 pps_id, num_ref_idx_l0_active_minus1 = 0, num_ref_idx_l1_active_minus1 = 0;\n\n\t/*s->current_picture.reference= h->nal_ref_idc != 0;*/\n\tgf_bs_read_ue_log(bs, \"first_mb_in_slice\");\n\tsi->slice_type = gf_bs_read_ue_log(bs, \"slice_type\");\n\tif (si->slice_type > 9) return -1;\n\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\tif ((pps_id<0) || (pps_id > 255)) return -1;\n\tsi->pps = &avc->pps[pps_id];\n\tif (!si->pps->slice_group_count) return -2;\n\tsi->sps = &avc->sps[si->pps->sps_id];\n\tif (!si->sps->log2_max_frame_num) return -2;\n\tavc->sps_active_idx = si->pps->sps_id;\n\tavc->pps_active_idx = pps_id;\n\n\tsi->frame_num = gf_bs_read_int_log(bs, si->sps->log2_max_frame_num, \"frame_num\");\n\n\tsi->field_pic_flag = 0;\n\tsi->bottom_field_flag = 0;\n\tif (!si->sps->frame_mbs_only_flag) {\n\t\tsi->field_pic_flag = gf_bs_read_int_log(bs, 1, \"field_pic_flag\");\n\t\tif (si->field_pic_flag)\n\t\t\tsi->bottom_field_flag = gf_bs_read_int_log(bs, 1, \"bottom_field_flag\");\n\t}\n\n\tif ((si->nal_unit_type == GF_AVC_NALU_IDR_SLICE) || svc_idr_flag)\n\t\tsi->idr_pic_id = gf_bs_read_ue_log(bs, \"idr_pic_id\");\n\n\tif (si->sps->poc_type == 0) {\n\t\tsi->poc_lsb = gf_bs_read_int_log(bs, si->sps->log2_max_poc_lsb, \"poc_lsb\");\n\t\tif (si->pps->pic_order_present && !si->field_pic_flag) {\n\t\t\tsi->delta_poc_bottom = gf_bs_read_se_log(bs, \"poc_lsb\");\n\t\t}\n\t}\n\telse if ((si->sps->poc_type == 1) && !si->sps->delta_pic_order_always_zero_flag) {\n\t\tsi->delta_poc[0] = gf_bs_read_se_log(bs, \"delta_poc0\");\n\t\tif ((si->pps->pic_order_present == 1) && !si->field_pic_flag)\n\t\t\tsi->delta_poc[1] = gf_bs_read_se_log(bs, \"delta_poc1\");\n\t}\n\n\tif (si->pps->redundant_pic_cnt_present) {\n\t\tsi->redundant_pic_cnt = gf_bs_read_ue_log(bs, \"redundant_pic_cnt\");\n\t}\n\n\tif (si->slice_type % 5 == GF_AVC_TYPE_B) {\n\t\tgf_bs_read_int_log(bs, 1, \"direct_spatial_mv_pred_flag\");\n\t}\n\n\tnum_ref_idx_l0_active_minus1 = si->pps->num_ref_idx_l0_default_active_minus1;\n\tnum_ref_idx_l1_active_minus1 = si->pps->num_ref_idx_l1_default_active_minus1;\n\n\tif (si->slice_type % 5 == GF_AVC_TYPE_P || si->slice_type % 5 == GF_AVC_TYPE_SP || si->slice_type % 5 == GF_AVC_TYPE_B) {\n\t\tBool num_ref_idx_active_override_flag = gf_bs_read_int_log(bs, 1, \"num_ref_idx_active_override_flag\");\n\t\tif (num_ref_idx_active_override_flag) {\n\t\t\tnum_ref_idx_l0_active_minus1 = gf_bs_read_ue_log(bs, \"num_ref_idx_l0_active_minus1\");\n\t\t\tif (si->slice_type % 5 == GF_AVC_TYPE_B) {\n\t\t\t\tnum_ref_idx_l1_active_minus1 = gf_bs_read_ue_log(bs, \"num_ref_idx_l1_active_minus1\");\n\t\t\t}\n\t\t}\n\t}\n\n\tif (si->nal_unit_type == 20 || si->nal_unit_type == 21) {\n\t\t//ref_pic_list_mvc_modification(); /* specified in Annex H */\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[avc-h264] unimplemented ref_pic_list_mvc_modification() in slide header\\n\"));\n\t\tassert(0);\n\t\treturn -1;\n\t}\n\telse {\n\t\tref_pic_list_modification(bs, si->slice_type);\n\t}\n\n\tif ((si->pps->weighted_pred_flag && (si->slice_type % 5 == GF_AVC_TYPE_P || si->slice_type % 5 == GF_AVC_TYPE_SP))\n\t\t|| (si->pps->weighted_bipred_idc == 1 && si->slice_type % 5 == GF_AVC_TYPE_B)) {\n\t\tpred_weight_table(bs, si->slice_type, si->sps->ChromaArrayType, num_ref_idx_l0_active_minus1, num_ref_idx_l1_active_minus1);\n\t}\n\n\tif (si->nal_ref_idc != 0) {\n\t\tdec_ref_pic_marking(bs, (si->nal_unit_type == GF_AVC_NALU_IDR_SLICE));\n\t}\n\n\tif (si->pps->entropy_coding_mode_flag && si->slice_type % 5 != GF_AVC_TYPE_I && si->slice_type % 5 != GF_AVC_TYPE_SI) {\n\t\tgf_bs_read_ue_log(bs, \"cabac_init_idc\");\n\t}\n\n\t/*slice_qp_delta = */gf_bs_read_se(bs);\n\tif (si->slice_type % 5 == GF_AVC_TYPE_SP || si->slice_type % 5 == GF_AVC_TYPE_SI) {\n\t\tif (si->slice_type % 5 == GF_AVC_TYPE_SP) {\n\t\t\tgf_bs_read_int_log(bs, 1, \"sp_for_switch_flag\");\n\t\t}\n\t\tgf_bs_read_se_log(bs, \"slice_qs_delta\");\n\t}\n\n\tif (si->pps->deblocking_filter_control_present_flag) {\n\t\tif (gf_bs_read_ue_log(bs, \"disable_deblocking_filter_idc\") != 1) {\n\t\t\tgf_bs_read_se_log(bs, \"slice_alpha_c0_offset_div2\");\n\t\t\tgf_bs_read_se_log(bs, \"slice_beta_offset_div2\");\n\t\t}\n\t}\n\n\tif (si->pps->slice_group_count > 1 && si->pps->mb_slice_group_map_type >= 3 && si->pps->mb_slice_group_map_type <= 5) {\n\t\tgf_bs_read_int_log(bs, (u32)ceil(log1p((si->pps->pic_size_in_map_units_minus1 + 1) / (si->pps->slice_group_change_rate_minus1 + 1) ) / log(2)), \"slice_group_change_cycle\");\n\t}\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 115,
    "critical_vars": [
      "a"
    ],
    "function": "ilst_item_box_read",
    "filename": "gpac/CVE-2020-19488/CVE-2020-19488_CWE-476_6170024568f4dda310e98ef7508477b425c58d09_box_code_apple.c.diff",
    "function_code": "GF_Err ilst_item_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 sub_type;\n\tGF_Box *a = NULL;\n\tGF_ListItemBox *ptr = (GF_ListItemBox *)s;\n\t/*iTunes way: there's a data atom containing the data*/\n\tsub_type = gf_bs_peek_bits(bs, 32, 4);\n\tif (sub_type == GF_ISOM_BOX_TYPE_DATA ) {\n\t\te = gf_isom_box_parse(&a, bs);\n\n\t\tif (!e && a && (ptr->size < a->size)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[isom] not enough bytes in box %s: %d left, reading %d (file %s, line %d)\\n\", gf_4cc_to_str(ptr->type), ptr->size, a->size, __FILE__, __LINE__ )); \\\n\t\t\te = GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tif (e) {\n\t\t\tif (a) gf_isom_box_del(a);\n\t\t\treturn e;\n\t\t}\n\t\tif (!a) return GF_NON_COMPLIANT_BITSTREAM;\n\n\t\tISOM_DECREASE_SIZE(ptr, a->size);\n\n\t\tif (a && ptr->data) gf_isom_box_del_parent(&ptr->child_boxes, (GF_Box *) ptr->data);\n\n\t\t/* otherwise a->data will always overflow */\n\t\tif (a && a->size > 4 && a->type != GF_ISOM_BOX_TYPE_VOID) {\n\t\t\tptr->data = (GF_DataBox *)a;\n\t\t\tif (!ptr->child_boxes) ptr->child_boxes = gf_list_new();\n\t\t\tgf_list_add(ptr->child_boxes, ptr->data);\n\t\t} else {\n\t\t\tptr->data = NULL;\n\t\t\tgf_isom_box_del(a);\n\t\t}\n\t}\n\t/*QT way*/\n\telse {\n\t\tu64 pos = gf_bs_get_position(bs);\n\t\tu64 prev_size = s->size;\n\t\t/*try parsing as generic box list*/\n\t\te = gf_isom_box_array_read(s, bs, NULL);\n\t\tif (e==GF_OK) return GF_OK;\n\t\t//reset content and retry - this deletes ptr->data !!\n\t\tgf_isom_box_array_del(s->child_boxes);\n\t\ts->child_boxes=NULL;\n\t\tgf_bs_seek(bs, pos);\n\t\ts->size = prev_size;\n\n\t\tptr->data = (GF_DataBox *)gf_isom_box_new_parent(&ptr->child_boxes, GF_ISOM_BOX_TYPE_DATA);\n\t\t//nope, check qt-style\n\t\tptr->data->qt_style = GF_TRUE;\n\t\tISOM_DECREASE_SIZE(ptr, 2);\n\t\tptr->data->dataSize = gf_bs_read_u16(bs);\n\t\tgf_bs_read_u16(bs);\n\n\t\tptr->data->data = (char *) gf_malloc(sizeof(char)*(ptr->data->dataSize + 1));\n\t\tgf_bs_read_data(bs, ptr->data->data, ptr->data->dataSize);\n\t\tptr->data->data[ptr->data->dataSize] = 0;\n\t\tISOM_DECREASE_SIZE(ptr, ptr->data->dataSize);\n\t}\n\treturn GF_OK;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 153,
    "critical_vars": [
      "*stbl"
    ],
    "function": "SetupWriters",
    "filename": "gpac/CVE-2020-35981/CVE-2020-35981_CWE-476_dae9900580a8888969481cd72035408091edb11b_isom_store.c.diff",
    "function_code": "GF_Err SetupWriters(MovieWriter *mw, GF_List *writers, u8 interleaving)\n{\n\tu32 i, trackCount;\n\tTrackWriter *writer;\n\tGF_TrackBox *trak;\n\tGF_ISOFile *movie = mw->movie;\n\n\tmw->total_samples = mw->nb_done = 0;\n\tif (!movie->moov) return GF_OK;\n\n\ttrackCount = gf_list_count(movie->moov->trackList);\n\tfor (i = 0; i < trackCount; i++) {\n\t\tGF_SampleTableBox *stbl;\n\t\ttrak = gf_isom_get_track(movie->moov, i+1);\n\n\t\tstbl = (trak->Media && trak->Media->information) ? trak->Media->information->sampleTable : NULL;\n\t\tif (!stbl || !stbl->SampleSize || !stbl->ChunkOffset || !stbl->SampleToChunk) {\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\t\tGF_SAFEALLOC(writer, TrackWriter);\n\t\tif (!writer) goto exit;\n\t\twriter->sampleNumber = 1;\n\t\twriter->mdia = trak->Media;\n\t\twriter->stbl = trak->Media->information->sampleTable;\n\t\twriter->timeScale = trak->Media->mediaHeader->timeScale;\n\t\twriter->all_dref_mode = Media_SelfContainedType(writer->mdia);\n\n\t\tif (trak->sample_encryption)\n\t\t\twriter->prevent_dispatch = GF_TRUE;\n\n\t\twriter->isDone = 0;\n\t\twriter->DTSprev = 0;\n\t\twriter->chunkDur = 0;\n\t\twriter->chunkSize = 0;\n\t\twriter->constant_size = writer->constant_dur = 0;\n\t\tif (writer->stbl->SampleSize->sampleSize)\n\t\t\twriter->constant_size = writer->stbl->SampleSize->sampleSize;\n\t\tif (writer->stbl->TimeToSample->nb_entries==1) {\n\t\t\twriter->constant_dur = writer->stbl->TimeToSample->entries[0].sampleDelta;\n\t\t\tif (writer->constant_dur>1) writer->constant_dur = 0;\n\t\t}\n\t\tif (!writer->constant_dur || !writer->constant_size || (writer->constant_size>=10))\n\t\t\twriter->constant_size = writer->constant_dur = 0;\n\n\t\twriter->stsc = (GF_SampleToChunkBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_STSC);\n\t\tif (!writer->stsc) return GF_OUT_OF_MEM;\n\t\tif (writer->stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {\n\t\t\twriter->stco = gf_isom_box_new(GF_ISOM_BOX_TYPE_STCO);\n\t\t} else {\n\t\t\twriter->stco = gf_isom_box_new(GF_ISOM_BOX_TYPE_CO64);\n\t\t}\n\t\tif (!writer->stco) return GF_OUT_OF_MEM;\n\t\t/*stops from chunk escape*/\n\t\tif (interleaving) writer->stbl->MaxSamplePerChunk = 0;\n\t\t/*for progress, assume only one descIndex*/\n\t\tif (Media_IsSelfContained(writer->mdia, 1))\n\t\t\tmw->total_samples += writer->stbl->SampleSize->sampleCount;\n\t\t/*optimization for interleaving: put audio last (this can be overridden by priorities)*/\n\t\tif (movie->storageMode != GF_ISOM_STORE_INTERLEAVED) {\n\t\t\tgf_list_add(writers, writer);\n\t\t} else {\n\t\t\tif (writer->mdia->information->InfoHeader && writer->mdia->information->InfoHeader->type == GF_ISOM_BOX_TYPE_SMHD) {\n\t\t\t\tgf_list_add(writers, writer);\n\t\t\t} else {\n\t\t\t\tgf_list_insert(writers, writer, 0);\n\t\t\t}\n\t\t}\n\t\tif (movie->sample_groups_in_traf && trak->Media->information->sampleTable) {\n\t\t\tgf_isom_box_array_del_parent(&trak->Media->information->sampleTable->child_boxes, trak->Media->information->sampleTable->sampleGroupsDescription);\n\t\t\ttrak->Media->information->sampleTable->sampleGroupsDescription = NULL;\n\t\t}\n\t}\n\treturn GF_OK;\n\nexit:\n\tCleanWriters(writers);\n\treturn GF_OUT_OF_MEM;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "for-Condition",
    "line_new": 788,
    "critical_vars": [
      "mffield"
    ],
    "function": "gf_dump_vrml_simple_field",
    "filename": "gpac/CVE-2022-2549/CVE-2022-2549_CWE-476_0102c5d4db7fdbf08b5b591b2a6264de33867a07_scene_dump.c.diff",
    "function_code": "static void gf_dump_vrml_simple_field(GF_SceneDumper *sdump, GF_FieldInfo field, GF_Node *parent)\n{\n\tu32 i, sf_type;\n\tGF_ChildNodeItem *list;\n\tvoid *slot_ptr;\n\n\tswitch (field.fieldType) {\n\tcase GF_SG_VRML_SFNODE:\n\t\tgf_dump_vrml_node(sdump, field.far_ptr ? *(GF_Node **)field.far_ptr : NULL, 0, NULL);\n\t\treturn;\n\tcase GF_SG_VRML_MFNODE:\n\t\tlist = * ((GF_ChildNodeItem **) field.far_ptr);\n\t\tassert( list );\n\t\tsdump->indent++;\n\t\twhile (list) {\n\t\t\tgf_dump_vrml_node(sdump, list->node, 1, NULL);\n\t\t\tlist = list->next;\n\t\t}\n\t\tsdump->indent--;\n\t\treturn;\n\tcase GF_SG_VRML_SFCOMMANDBUFFER:\n\t\treturn;\n\t}\n\tif (gf_sg_vrml_is_sf_field(field.fieldType)) {\n\t\tif (sdump->XMLDump) StartAttribute(sdump, \"value\");\n\t\tgf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, parent);\n\t\tif (sdump->XMLDump) EndAttribute(sdump);\n\t} else {\n\t\tGenMFField *mffield;\n\t\tmffield = (GenMFField *) field.far_ptr;\n\t\tsf_type = gf_sg_vrml_get_sf_type(field.fieldType);\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"[\");\n\t\t} else if (sf_type==GF_SG_VRML_SFSTRING) {\n\t\t\tgf_fprintf(sdump->trace, \" value=\\'\");\n\t\t} else {\n\t\t\tStartAttribute(sdump, \"value\");\n\t\t}\n\t\tfor (i=0; i<mffield->count; i++) {\n\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\t/*this is to cope with single MFString which shall appear as SF in XMT*/\n\t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, parent);\n\t\t}\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"]\");\n\t\t} else if (sf_type==GF_SG_VRML_SFSTRING) {\n\t\t\tgf_fprintf(sdump->trace, \"\\'\");\n\t\t} else {\n\t\t\tEndAttribute(sdump);\n\t\t}\n\t}\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 941,
    "critical_vars": [
      "mffield"
    ],
    "function": "gf_dump_vrml_field",
    "filename": "gpac/CVE-2022-2549/CVE-2022-2549_CWE-476_0102c5d4db7fdbf08b5b591b2a6264de33867a07_scene_dump.c.diff",
    "function_code": "static void gf_dump_vrml_field(GF_SceneDumper *sdump, GF_Node *node, GF_FieldInfo field)\n{\n\tu32 i, sf_type;\n\tBool needs_field_container;\n\tGF_ChildNodeItem *list;\n\tvoid *slot_ptr;\n\n\tswitch (field.fieldType) {\n\tcase GF_SG_VRML_SFNODE:\n\t\tassert ( *(GF_Node **)field.far_ptr);\n\n\t\tif (sdump->XMLDump) {\n\t\t\tif (!sdump->X3DDump) {\n\t\t\t\tStartElement(sdump, (char *) field.name);\n\t\t\t\tEndElementHeader(sdump, 1);\n\t\t\t\tsdump->indent++;\n\t\t\t}\n\t\t} else {\n\t\t\tStartAttribute(sdump, field.name);\n\t\t}\n\t\tgf_dump_vrml_node(sdump, *(GF_Node **)field.far_ptr, 0, NULL);\n\n\t\tif (sdump->XMLDump) {\n\t\t\tif (!sdump->X3DDump) {\n\t\t\t\tsdump->indent--;\n\t\t\t\tEndElement(sdump, (char *) field.name, 1);\n\t\t\t}\n\t\t} else {\n\t\t\tEndAttribute(sdump);\n\t\t}\n\t\treturn;\n\tcase GF_SG_VRML_MFNODE:\n\t\tneeds_field_container = 0;\n\t\tif (sdump->XMLDump && sdump->X3DDump) {\n\t\t\tu32 count, nb_ndt;\n\t\t\tGF_FieldInfo info;\n\t\t\tif (!strcmp(field.name, \"children\")) {\n\t\t\t\tneeds_field_container = 0;\n\t\t\t} else {\n\t\t\t\tnb_ndt = 0;\n\t\t\t\tcount = gf_node_get_field_count(node);\n\t\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\t\tgf_node_get_field(node, i, &info);\n\t\t\t\t\tif ((info.eventType==GF_SG_EVENT_IN) || (info.eventType==GF_SG_EVENT_OUT)) continue;\n\t\t\t\t\tif (info.NDTtype==field.NDTtype) nb_ndt++;\n\t\t\t\t}\n\t\t\t\tneeds_field_container = (nb_ndt>1) ? 1 : 0;\n\t\t\t}\n\t\t}\n\n#ifndef GPAC_DISABLE_X3D\n\t\tif (!sdump->X3DDump) {\n\t\t\tif (gf_node_get_tag(node)==TAG_X3D_Switch) field.name = \"choice\";\n\t\t}\n#endif\n\t\tlist = * ((GF_ChildNodeItem **) field.far_ptr);\n\t\tassert(list);\n\t\tif (!sdump->XMLDump || !sdump->X3DDump) StartList(sdump, field.name);\n\t\tsdump->indent++;\n\t\twhile (list) {\n\t\t\tgf_dump_vrml_node(sdump, list->node, 1, needs_field_container ? (char *) field.name : NULL);\n\t\t\tlist = list->next;\n\t\t}\n\t\tsdump->indent--;\n\t\tif (!sdump->XMLDump || !sdump->X3DDump) EndList(sdump, field.name);\n\t\treturn;\n\tcase GF_SG_VRML_SFCOMMANDBUFFER:\n\t{\n\t\tSFCommandBuffer *cb = (SFCommandBuffer *)field.far_ptr;\n\t\tStartElement(sdump, (char *) field.name);\n\t\tEndElementHeader(sdump, 1);\n\t\tsdump->indent++;\n\t\tif (!gf_list_count(cb->commandList)) {\n\t\t\t/*the arch does not allow for that (we would need a codec and so on, or decompress the command list\n\t\t\tin all cases...)*/\n\t\t\tif (sdump->trace && cb->bufferSize) {\n\t\t\t\tif (sdump->XMLDump) gf_fprintf(sdump->trace, \"<!--SFCommandBuffer cannot be dumped while playing - use MP4Box instead-->\\n\");\n\t\t\t\telse gf_fprintf(sdump->trace, \"#SFCommandBuffer cannot be dumped while playing - use MP4Box instead\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tgf_sm_dump_command_list(sdump, cb->commandList, sdump->indent, 0);\n\t\t}\n\t\tsdump->indent--;\n\t\tEndElement(sdump, (char *) field.name, 1);\n\t}\n\treturn;\n\n\tcase GF_SG_VRML_MFATTRREF:\n\t\tif (sdump->XMLDump) {\n\t\t\tMFAttrRef *ar = (MFAttrRef *)field.far_ptr;\n\t\t\tStartElement(sdump, (char *) field.name);\n\t\t\tEndElementHeader(sdump, 1);\n\t\t\tsdump->indent++;\n\n\t\t\tfor (i=0; i<ar->count; i++) {\n\t\t\t\tif (ar->vals[i].node) {\n\t\t\t\t\tGF_FieldInfo pinfo;\n\t\t\t\t\tDUMP_IND(sdump);\n\t\t\t\t\tgf_node_get_field(ar->vals[i].node, ar->vals[i].fieldIndex, &pinfo);\n\t\t\t\t\tgf_fprintf(sdump->trace, \"<store node=\\\"\");\n\t\t\t\t\tscene_dump_vrml_id(sdump, ar->vals[i].node);\n\t\t\t\t\tgf_fprintf(sdump->trace, \"\\\" field=\\\"%s\\\"/>\\n\", pinfo.name);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsdump->indent--;\n\t\t\tEndElement(sdump, (char *) field.name, 1);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\t}\n\n\n\tif (gf_sg_vrml_is_sf_field(field.fieldType)) {\n\t\tStartAttribute(sdump, field.name);\n\t\tgf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, node);\n\t\tEndAttribute(sdump);\n\t} else {\n\t\tGenMFField *mffield = (GenMFField *) field.far_ptr;\n\t\tsf_type = gf_sg_vrml_get_sf_type(field.fieldType);\n\n\t\tif (sdump->XMLDump && sdump->X3DDump) {\n\t\t\tswitch (sf_type) {\n\t\t\tcase GF_SG_VRML_SFSTRING:\n\t\t\tcase GF_SG_VRML_SFSCRIPT:\n\t\t\tcase GF_SG_VRML_SFURL:\n\t\t\t\tgf_fprintf(sdump->trace, \" %s=\\'\", (char *) field.name);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tStartAttribute(sdump, field.name);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tStartAttribute(sdump, field.name);\n\t\t}\n\n\t\tif (!sdump->XMLDump) gf_fprintf(sdump->trace, \"[\");\n\t\tif (mffield) {\n\t\t\tfor (i=0; i<mffield->count; i++) {\n\t\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n\t\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, node);\n\t\t\t}\n\t\t}\n\t\tif (!sdump->XMLDump) gf_fprintf(sdump->trace, \"]\");\n\n\t\tif (sdump->XMLDump && sdump->X3DDump) {\n\t\t\tswitch (sf_type) {\n\t\t\tcase GF_SG_VRML_SFSTRING:\n\t\t\tcase GF_SG_VRML_SFSCRIPT:\n\t\t\tcase GF_SG_VRML_SFURL:\n\t\t\t\tgf_fprintf(sdump->trace, \"\\'\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tEndAttribute(sdump);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tEndAttribute(sdump);\n\t\t}\n\t}\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "for-Condition",
    "line_new": 941,
    "critical_vars": [
      "i",
      "mffield"
    ],
    "function": "gf_dump_vrml_field",
    "filename": "gpac/CVE-2022-2549/CVE-2022-2549_CWE-476_0102c5d4db7fdbf08b5b591b2a6264de33867a07_scene_dump.c.diff",
    "function_code": "static void gf_dump_vrml_field(GF_SceneDumper *sdump, GF_Node *node, GF_FieldInfo field)\n{\n\tu32 i, sf_type;\n\tBool needs_field_container;\n\tGF_ChildNodeItem *list;\n\tvoid *slot_ptr;\n\n\tswitch (field.fieldType) {\n\tcase GF_SG_VRML_SFNODE:\n\t\tassert ( *(GF_Node **)field.far_ptr);\n\n\t\tif (sdump->XMLDump) {\n\t\t\tif (!sdump->X3DDump) {\n\t\t\t\tStartElement(sdump, (char *) field.name);\n\t\t\t\tEndElementHeader(sdump, 1);\n\t\t\t\tsdump->indent++;\n\t\t\t}\n\t\t} else {\n\t\t\tStartAttribute(sdump, field.name);\n\t\t}\n\t\tgf_dump_vrml_node(sdump, *(GF_Node **)field.far_ptr, 0, NULL);\n\n\t\tif (sdump->XMLDump) {\n\t\t\tif (!sdump->X3DDump) {\n\t\t\t\tsdump->indent--;\n\t\t\t\tEndElement(sdump, (char *) field.name, 1);\n\t\t\t}\n\t\t} else {\n\t\t\tEndAttribute(sdump);\n\t\t}\n\t\treturn;\n\tcase GF_SG_VRML_MFNODE:\n\t\tneeds_field_container = 0;\n\t\tif (sdump->XMLDump && sdump->X3DDump) {\n\t\t\tu32 count, nb_ndt;\n\t\t\tGF_FieldInfo info;\n\t\t\tif (!strcmp(field.name, \"children\")) {\n\t\t\t\tneeds_field_container = 0;\n\t\t\t} else {\n\t\t\t\tnb_ndt = 0;\n\t\t\t\tcount = gf_node_get_field_count(node);\n\t\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\t\tgf_node_get_field(node, i, &info);\n\t\t\t\t\tif ((info.eventType==GF_SG_EVENT_IN) || (info.eventType==GF_SG_EVENT_OUT)) continue;\n\t\t\t\t\tif (info.NDTtype==field.NDTtype) nb_ndt++;\n\t\t\t\t}\n\t\t\t\tneeds_field_container = (nb_ndt>1) ? 1 : 0;\n\t\t\t}\n\t\t}\n\n#ifndef GPAC_DISABLE_X3D\n\t\tif (!sdump->X3DDump) {\n\t\t\tif (gf_node_get_tag(node)==TAG_X3D_Switch) field.name = \"choice\";\n\t\t}\n#endif\n\t\tlist = * ((GF_ChildNodeItem **) field.far_ptr);\n\t\tassert(list);\n\t\tif (!sdump->XMLDump || !sdump->X3DDump) StartList(sdump, field.name);\n\t\tsdump->indent++;\n\t\twhile (list) {\n\t\t\tgf_dump_vrml_node(sdump, list->node, 1, needs_field_container ? (char *) field.name : NULL);\n\t\t\tlist = list->next;\n\t\t}\n\t\tsdump->indent--;\n\t\tif (!sdump->XMLDump || !sdump->X3DDump) EndList(sdump, field.name);\n\t\treturn;\n\tcase GF_SG_VRML_SFCOMMANDBUFFER:\n\t{\n\t\tSFCommandBuffer *cb = (SFCommandBuffer *)field.far_ptr;\n\t\tStartElement(sdump, (char *) field.name);\n\t\tEndElementHeader(sdump, 1);\n\t\tsdump->indent++;\n\t\tif (!gf_list_count(cb->commandList)) {\n\t\t\t/*the arch does not allow for that (we would need a codec and so on, or decompress the command list\n\t\t\tin all cases...)*/\n\t\t\tif (sdump->trace && cb->bufferSize) {\n\t\t\t\tif (sdump->XMLDump) gf_fprintf(sdump->trace, \"<!--SFCommandBuffer cannot be dumped while playing - use MP4Box instead-->\\n\");\n\t\t\t\telse gf_fprintf(sdump->trace, \"#SFCommandBuffer cannot be dumped while playing - use MP4Box instead\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tgf_sm_dump_command_list(sdump, cb->commandList, sdump->indent, 0);\n\t\t}\n\t\tsdump->indent--;\n\t\tEndElement(sdump, (char *) field.name, 1);\n\t}\n\treturn;\n\n\tcase GF_SG_VRML_MFATTRREF:\n\t\tif (sdump->XMLDump) {\n\t\t\tMFAttrRef *ar = (MFAttrRef *)field.far_ptr;\n\t\t\tStartElement(sdump, (char *) field.name);\n\t\t\tEndElementHeader(sdump, 1);\n\t\t\tsdump->indent++;\n\n\t\t\tfor (i=0; i<ar->count; i++) {\n\t\t\t\tif (ar->vals[i].node) {\n\t\t\t\t\tGF_FieldInfo pinfo;\n\t\t\t\t\tDUMP_IND(sdump);\n\t\t\t\t\tgf_node_get_field(ar->vals[i].node, ar->vals[i].fieldIndex, &pinfo);\n\t\t\t\t\tgf_fprintf(sdump->trace, \"<store node=\\\"\");\n\t\t\t\t\tscene_dump_vrml_id(sdump, ar->vals[i].node);\n\t\t\t\t\tgf_fprintf(sdump->trace, \"\\\" field=\\\"%s\\\"/>\\n\", pinfo.name);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsdump->indent--;\n\t\t\tEndElement(sdump, (char *) field.name, 1);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\t}\n\n\n\tif (gf_sg_vrml_is_sf_field(field.fieldType)) {\n\t\tStartAttribute(sdump, field.name);\n\t\tgf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, node);\n\t\tEndAttribute(sdump);\n\t} else {\n\t\tGenMFField *mffield = (GenMFField *) field.far_ptr;\n\t\tsf_type = gf_sg_vrml_get_sf_type(field.fieldType);\n\n\t\tif (sdump->XMLDump && sdump->X3DDump) {\n\t\t\tswitch (sf_type) {\n\t\t\tcase GF_SG_VRML_SFSTRING:\n\t\t\tcase GF_SG_VRML_SFSCRIPT:\n\t\t\tcase GF_SG_VRML_SFURL:\n\t\t\t\tgf_fprintf(sdump->trace, \" %s=\\'\", (char *) field.name);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tStartAttribute(sdump, field.name);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tStartAttribute(sdump, field.name);\n\t\t}\n\n\t\tif (!sdump->XMLDump) gf_fprintf(sdump->trace, \"[\");\n\t\tfor (i=0; mffield && (i<mffield->count); i++) {\n\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, node);\n\t\t}\n\t\tif (!sdump->XMLDump) gf_fprintf(sdump->trace, \"]\");\n\n\t\tif (sdump->XMLDump && sdump->X3DDump) {\n\t\t\tswitch (sf_type) {\n\t\t\tcase GF_SG_VRML_SFSTRING:\n\t\t\tcase GF_SG_VRML_SFSCRIPT:\n\t\t\tcase GF_SG_VRML_SFURL:\n\t\t\t\tgf_fprintf(sdump->trace, \"\\'\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tEndAttribute(sdump);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tEndAttribute(sdump);\n\t\t}\n\t}\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "for-Condition",
    "line_new": 1151,
    "critical_vars": [
      "mffield"
    ],
    "function": "gf_dump_vrml_dyn_field",
    "filename": "gpac/CVE-2022-2549/CVE-2022-2549_CWE-476_0102c5d4db7fdbf08b5b591b2a6264de33867a07_scene_dump.c.diff",
    "function_code": "static void gf_dump_vrml_dyn_field(GF_SceneDumper *sdump, GF_Node *node, GF_FieldInfo field, Bool has_sublist)\n{\n\tu32 i, sf_type;\n\tvoid *slot_ptr;\n\n\tif (gf_sg_vrml_is_sf_field(field.fieldType)) {\n\t\tDUMP_IND(sdump);\n\t\tif (sdump->XMLDump) {\n\t\t\tif (sdump->X3DDump) {\n\t\t\t\tgf_fprintf(sdump->trace, \"<field name=\\\"%s\\\" type=\\\"%s\\\" accessType=\\\"%s\\\"\",\n\t\t\t\t        field.name, gf_sg_vrml_get_field_type_name(field.fieldType), gf_sg_vrml_get_event_type_name(field.eventType, 1));\n\t\t\t} else {\n\t\t\t\tgf_fprintf(sdump->trace, \"<field name=\\\"%s\\\" type=\\\"%s\\\" vrml97Hint=\\\"%s\\\"\",\n\t\t\t\t        field.name, GetXMTFieldTypeName(field.fieldType), gf_sg_vrml_get_event_type_name(field.eventType, 0));\n\t\t\t}\n\n\t\t\tif ((field.eventType == GF_SG_EVENT_FIELD) || (field.eventType == GF_SG_EVENT_EXPOSED_FIELD)) {\n\t\t\t\tif (field.fieldType == GF_SG_VRML_SFNODE) {\n\t\t\t\t\tif (!sdump->X3DDump) {\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \">\\n\");\n\t\t\t\t\t\tsdump->indent++;\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \"<node>\");\n\t\t\t\t\t\tgf_dump_vrml_node(sdump, field.far_ptr ? *(GF_Node **)field.far_ptr : NULL, 0, NULL);\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \"</node>\");\n\t\t\t\t\t\tsdump->indent--;\n\t\t\t\t\t\tif (!has_sublist)\n\t\t\t\t\t\t\tgf_fprintf(sdump->trace, \"</field>\\n\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (field.far_ptr) {\n\t\t\t\t\t\t\tgf_fprintf(sdump->trace, \">\\n\");\n\t\t\t\t\t\t\tgf_dump_vrml_node(sdump, *(GF_Node **)field.far_ptr, 0, NULL);\n\t\t\t\t\t\t\tgf_fprintf(sdump->trace, \"</field>\\n\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_fprintf(sdump->trace, \"/>\\n\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tDUMP_IND(sdump);\n\t\t\t\t} else {\n\t\t\t\t\tif (sdump->X3DDump) {\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \" value=\\\"\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \" %s=\\\"\", GetXMTFieldTypeValueName(field.fieldType));\n\t\t\t\t\t}\n\t\t\t\t\tif (field.far_ptr)\n\t\t\t\t\t\tgf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, node);\n\t\t\t\t\tif (has_sublist)\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \"\\\">\\n\");\n\t\t\t\t\telse\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \"\\\"/>\\n\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgf_fprintf(sdump->trace, \"/>\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tgf_fprintf(sdump->trace, \"%s %s %s\", gf_sg_vrml_get_event_type_name(field.eventType, sdump->X3DDump), gf_sg_vrml_get_field_type_name(field.fieldType), field.name);\n\t\t\tif ((field.eventType==GF_SG_EVENT_FIELD) || (field.eventType==GF_SG_EVENT_EXPOSED_FIELD)) {\n\t\t\t\tgf_fprintf(sdump->trace, \" \");\n\t\t\t\tif (field.fieldType == GF_SG_VRML_SFNODE) {\n\t\t\t\t\tgf_dump_vrml_node(sdump, field.far_ptr ? *(GF_Node **)field.far_ptr : NULL, 0, NULL);\n\t\t\t\t} else if (field.far_ptr) {\n\t\t\t\t\tgf_dump_vrml_simple_field(sdump, field, node);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_fprintf(sdump->trace, \"\\n\");\n\t\t}\n\t} else if (field.far_ptr) {\n\t\tGenMFField *mffield = (GenMFField *) field.far_ptr;\n\t\tsf_type = gf_sg_vrml_get_sf_type(field.fieldType);\n\n\t\tDUMP_IND(sdump);\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"%s %s %s\", gf_sg_vrml_get_event_type_name(field.eventType, sdump->X3DDump), gf_sg_vrml_get_field_type_name(field.fieldType), field.name);\n\t\t\tif ((field.eventType==GF_SG_EVENT_FIELD) || (field.eventType==GF_SG_EVENT_EXPOSED_FIELD)) {\n\t\t\t\tgf_fprintf(sdump->trace, \" [\");\n\n\t\t\t\tif (sf_type == GF_SG_VRML_SFNODE) {\n\t\t\t\t\tGF_ChildNodeItem *l = *(GF_ChildNodeItem **)field.far_ptr;\n\t\t\t\t\tgf_fprintf(sdump->trace, \"\\n\");\n\t\t\t\t\tsdump->indent++;\n\t\t\t\t\twhile (l) {\n\t\t\t\t\t\tgf_dump_vrml_node(sdump, l->node, 1, NULL);\n\t\t\t\t\t\tl = l->next;\n\t\t\t\t\t}\n\t\t\t\t\tsdump->indent--;\n\t\t\t\t\tDUMP_IND(sdump);\n\t\t\t\t} else {\n\t\t\t\t\tfor (i=0; mffield && (i<mffield->count); i++) {\n\t\t\t\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n\t\t\t\t\t\tif (field.fieldType != GF_SG_VRML_MFNODE) {\n\t\t\t\t\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\t\t\t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr, (mffield->count>1) ? 1 : 0, node);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_fprintf(sdump->trace, \"]\");\n\t\t\t}\n\t\t\tgf_fprintf(sdump->trace, \"\\n\");\n\t\t} else {\n\t\t\tif (sdump->X3DDump) {\n\t\t\t\tgf_fprintf(sdump->trace, \"<field name=\\\"%s\\\" type=\\\"%s\\\" accessType=\\\"%s\\\"\",\n\t\t\t\t        field.name, gf_sg_vrml_get_field_type_name(field.fieldType), gf_sg_vrml_get_event_type_name(field.eventType, 1));\n\t\t\t} else {\n\t\t\t\tgf_fprintf(sdump->trace, \"<field name=\\\"%s\\\" type=\\\"%s\\\" vrml97Hint=\\\"%s\\\"\",\n\t\t\t\t        field.name, GetXMTFieldTypeName(field.fieldType), gf_sg_vrml_get_event_type_name(field.eventType, 0));\n\t\t\t}\n\n\t\t\tif ((field.eventType==GF_SG_EVENT_FIELD) || (field.eventType==GF_SG_EVENT_EXPOSED_FIELD)) {\n\t\t\t\tif (sf_type == GF_SG_VRML_SFNODE) {\n\t\t\t\t\tGF_ChildNodeItem *list = *(GF_ChildNodeItem **)field.far_ptr;\n\t\t\t\t\tgf_fprintf(sdump->trace, \">\\n\");\n\t\t\t\t\tsdump->indent++;\n\t\t\t\t\tif (!sdump->X3DDump) gf_fprintf(sdump->trace, \"<nodes>\");\n\t\t\t\t\twhile (list) {\n\t\t\t\t\t\tgf_dump_vrml_node(sdump, list->node, 1, NULL);\n\t\t\t\t\t\tlist = list->next;\n\t\t\t\t\t}\n\t\t\t\t\tif (!sdump->X3DDump) gf_fprintf(sdump->trace, \"</nodes>\");\n\t\t\t\t\tsdump->indent++;\n\t\t\t\t\tDUMP_IND(sdump);\n\t\t\t\t\tif (!has_sublist)\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \"</field>\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tif (sdump->X3DDump) {\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \" value=\\\"\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \" %s=\\\"\", GetXMTFieldTypeValueName(field.fieldType));\n\t\t\t\t\t}\n\t\t\t\t\tfor (i=0; mffield && (i<mffield->count); i++) {\n\t\t\t\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n\t\t\t\t\t\tif (field.fieldType != GF_SG_VRML_MFNODE) {\n\t\t\t\t\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\t\t\t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr, (mffield->count>1) ? 1 : 0, node);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (has_sublist)\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \"\\\">\\n\");\n\t\t\t\t\telse\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \"\\\"/>\\n\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgf_fprintf(sdump->trace, \"/>\\n\");\n\t\t\t}\n\t\t}\n\t}\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 1265,
    "critical_vars": [
      "mffield"
    ],
    "function": "gf_dump_vrml_proto_field",
    "filename": "gpac/CVE-2022-2549/CVE-2022-2549_CWE-476_0102c5d4db7fdbf08b5b591b2a6264de33867a07_scene_dump.c.diff",
    "function_code": "static void gf_dump_vrml_proto_field(GF_SceneDumper *sdump, GF_Node *node, GF_FieldInfo field)\n{\n\tu32 i, sf_type;\n\tvoid *slot_ptr;\n\n\tDUMP_IND(sdump);\n\tgf_fprintf(sdump->trace, \"<fieldValue name=\\\"%s\\\" \", field.name);\n\tif (gf_sg_vrml_is_sf_field(field.fieldType)) {\n\t\tif (field.fieldType == GF_SG_VRML_SFNODE) {\n\t\t\tgf_fprintf(sdump->trace, \">\\n\");\n\t\t\tsdump->indent++;\n\t\t\tif (!sdump->X3DDump) gf_fprintf(sdump->trace, \"<node>\");\n\t\t\tgf_dump_vrml_node(sdump, field.far_ptr ? *(GF_Node **)field.far_ptr : NULL, 0, NULL);\n\t\t\tif (!sdump->X3DDump) gf_fprintf(sdump->trace, \"</node>\");\n\t\t\tsdump->indent--;\n\t\t\tDUMP_IND(sdump);\n\t\t\tgf_fprintf(sdump->trace, \"</fieldValue>\\n\");\n\t\t} else {\n\t\t\tif (sdump->X3DDump) {\n\t\t\t\tgf_fprintf(sdump->trace, \" value=\\\"\");\n\t\t\t} else {\n\t\t\t\tgf_fprintf(sdump->trace, \" %s=\\\"\", GetXMTFieldTypeValueName(field.fieldType));\n\t\t\t}\n\t\t\tgf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, node);\n\t\t\tgf_fprintf(sdump->trace, \"\\\"/>\\n\");\n\t\t}\n\t} else {\n\t\tGenMFField *mffield = (GenMFField *) field.far_ptr;\n\t\tsf_type = gf_sg_vrml_get_sf_type(field.fieldType);\n\n\t\tif ((field.eventType==GF_SG_EVENT_FIELD) || (field.eventType==GF_SG_EVENT_EXPOSED_FIELD)) {\n\t\t\tif (sf_type == GF_SG_VRML_SFNODE) {\n\t\t\t\tGF_ChildNodeItem *list = *(GF_ChildNodeItem **)field.far_ptr;\n\t\t\t\tgf_fprintf(sdump->trace, \">\\n\");\n\t\t\t\tsdump->indent++;\n\t\t\t\tif (!sdump->X3DDump) gf_fprintf(sdump->trace, \"<nodes>\");\n\t\t\t\twhile (list) {\n\t\t\t\t\tgf_dump_vrml_node(sdump, list->node, 1, NULL);\n\t\t\t\t\tlist = list->next;\n\t\t\t\t}\n\t\t\t\tif (!sdump->X3DDump) gf_fprintf(sdump->trace, \"</nodes>\");\n\t\t\t\tsdump->indent--;\n\t\t\t\tDUMP_IND(sdump);\n\t\t\t\tgf_fprintf(sdump->trace, \"</fieldValue>\\n\");\n\t\t\t} else {\n\t\t\t\tif (sdump->X3DDump) {\n\t\t\t\t\tgf_fprintf(sdump->trace, \" value=\\\"\");\n\t\t\t\t} else {\n\t\t\t\t\tgf_fprintf(sdump->trace, \" %s=\\\"\", GetXMTFieldTypeValueName(field.fieldType));\n\t\t\t\t}\n\t\t\t\tif (mffield) {\n\t\t\t\t\tfor (i=0; i<mffield->count; i++) {\n\t\t\t\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n\t\t\t\t\t\tif (field.fieldType != GF_SG_VRML_MFNODE) {\n\t\t\t\t\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\t\t\t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr, (mffield->count>1) ? 1 : 0, node);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_fprintf(sdump->trace, \"\\\"/>\\n\");\n\t\t\t}\n\t\t}\n\t}\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "for-Condition",
    "line_new": 1263,
    "critical_vars": [
      "i",
      "mffield"
    ],
    "function": "gf_dump_vrml_proto_field",
    "filename": "gpac/CVE-2022-2549/CVE-2022-2549_CWE-476_0102c5d4db7fdbf08b5b591b2a6264de33867a07_scene_dump.c.diff",
    "function_code": "static void gf_dump_vrml_proto_field(GF_SceneDumper *sdump, GF_Node *node, GF_FieldInfo field)\n{\n\tu32 i, sf_type;\n\tvoid *slot_ptr;\n\n\tDUMP_IND(sdump);\n\tgf_fprintf(sdump->trace, \"<fieldValue name=\\\"%s\\\" \", field.name);\n\tif (gf_sg_vrml_is_sf_field(field.fieldType)) {\n\t\tif (field.fieldType == GF_SG_VRML_SFNODE) {\n\t\t\tgf_fprintf(sdump->trace, \">\\n\");\n\t\t\tsdump->indent++;\n\t\t\tif (!sdump->X3DDump) gf_fprintf(sdump->trace, \"<node>\");\n\t\t\tgf_dump_vrml_node(sdump, field.far_ptr ? *(GF_Node **)field.far_ptr : NULL, 0, NULL);\n\t\t\tif (!sdump->X3DDump) gf_fprintf(sdump->trace, \"</node>\");\n\t\t\tsdump->indent--;\n\t\t\tDUMP_IND(sdump);\n\t\t\tgf_fprintf(sdump->trace, \"</fieldValue>\\n\");\n\t\t} else {\n\t\t\tif (sdump->X3DDump) {\n\t\t\t\tgf_fprintf(sdump->trace, \" value=\\\"\");\n\t\t\t} else {\n\t\t\t\tgf_fprintf(sdump->trace, \" %s=\\\"\", GetXMTFieldTypeValueName(field.fieldType));\n\t\t\t}\n\t\t\tgf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, node);\n\t\t\tgf_fprintf(sdump->trace, \"\\\"/>\\n\");\n\t\t}\n\t} else {\n\t\tGenMFField *mffield = (GenMFField *) field.far_ptr;\n\t\tsf_type = gf_sg_vrml_get_sf_type(field.fieldType);\n\n\t\tif ((field.eventType==GF_SG_EVENT_FIELD) || (field.eventType==GF_SG_EVENT_EXPOSED_FIELD)) {\n\t\t\tif (sf_type == GF_SG_VRML_SFNODE) {\n\t\t\t\tGF_ChildNodeItem *list = *(GF_ChildNodeItem **)field.far_ptr;\n\t\t\t\tgf_fprintf(sdump->trace, \">\\n\");\n\t\t\t\tsdump->indent++;\n\t\t\t\tif (!sdump->X3DDump) gf_fprintf(sdump->trace, \"<nodes>\");\n\t\t\t\twhile (list) {\n\t\t\t\t\tgf_dump_vrml_node(sdump, list->node, 1, NULL);\n\t\t\t\t\tlist = list->next;\n\t\t\t\t}\n\t\t\t\tif (!sdump->X3DDump) gf_fprintf(sdump->trace, \"</nodes>\");\n\t\t\t\tsdump->indent--;\n\t\t\t\tDUMP_IND(sdump);\n\t\t\t\tgf_fprintf(sdump->trace, \"</fieldValue>\\n\");\n\t\t\t} else {\n\t\t\t\tif (sdump->X3DDump) {\n\t\t\t\t\tgf_fprintf(sdump->trace, \" value=\\\"\");\n\t\t\t\t} else {\n\t\t\t\t\tgf_fprintf(sdump->trace, \" %s=\\\"\", GetXMTFieldTypeValueName(field.fieldType));\n\t\t\t\t}\n\t\t\t\tfor (i=0; mffield && (i<mffield->count); i++) {\n\t\t\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n\t\t\t\t\tif (field.fieldType != GF_SG_VRML_MFNODE) {\n\t\t\t\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\t\t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr, (mffield->count>1) ? 1 : 0, node);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_fprintf(sdump->trace, \"\\\"/>\\n\");\n\t\t\t}\n\t\t}\n\t}\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 363,
    "critical_vars": [
      "ctx->ch"
    ],
    "function": "pcmreframe_process",
    "filename": "gpac/CVE-2023-5586/CVE-2023-5586_CWE-476_ca1b48f0abe71bf81a58995d7d75dc27f5a17ddc_reframe_rawpcm.c.diff",
    "function_code": "GF_Err pcmreframe_process(GF_Filter *filter)\n{\n\tGF_PCMReframeCtx *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *pck;\n\tu64 byte_offset;\n\tu8 *data;\n\tu32 pck_size;\n\n\tif (ctx->done) return GF_EOS;\n\n\tif (!ctx->is_playing && ctx->opid) return GF_OK;\n\n\tpck = gf_filter_pid_get_packet(ctx->ipid);\n\tif (!pck) {\n\t\tif (gf_filter_pid_is_eos(ctx->ipid) && !ctx->reverse_play) {\n\t\t\tif (ctx->out_pck) {\n\t\t\t\tgf_filter_pck_truncate(ctx->out_pck, ctx->nb_bytes_in_frame);\n\t\t\t\tgf_filter_pck_set_duration(ctx->out_pck, ctx->nb_bytes_in_frame/ctx->Bps/ctx->ch);\n\t\t\t\tpcmreframe_flush_packet(ctx);\n\t\t\t}\n\t\t\tif (ctx->opid)\n\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\treturn GF_EOS;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\tdata = (char *) gf_filter_pck_get_data(pck, &pck_size);\n\tbyte_offset = gf_filter_pck_get_byte_offset(pck);\n\n\tif (ctx->probe_wave==1) {\n\t\tBool wav_ok = GF_TRUE;\n\t\tBool hdr_found = GF_FALSE;\n\t\tGF_BitStream *bs;\n\t\tif (ctx->probe_data) {\n\t\t\tctx->probe_data = gf_realloc(ctx->probe_data, ctx->probe_data_size+pck_size);\n\t\t\tmemcpy(ctx->probe_data + ctx->probe_data_size, data, pck_size);\n\t\t\tctx->probe_data_size += pck_size;\n\t\t\tbs = gf_bs_new(ctx->probe_data, ctx->probe_data_size, GF_BITSTREAM_READ);\n\t\t} else {\n\t\t\tbs = gf_bs_new(data, pck_size, GF_BITSTREAM_READ);\n\t\t}\n\t\tu32 type = gf_bs_read_u32(bs);\n\t\tif (type!=GF_4CC('R', 'I', 'F', 'F')) {\n\t\t\twav_ok = GF_FALSE;\n\t\t}\n\t\tgf_bs_read_u32(bs);\n\t\tu32 wtype = gf_bs_read_u32(bs);\n\t\tif (wtype!=GF_4CC('W', 'A', 'V', 'E')) {\n\t\t\twav_ok = GF_FALSE;\n\t\t}\n\t\twhile (gf_bs_available(bs)) {\n\t\t\ttype = gf_bs_read_u32(bs);\n\t\t\tu32 csize = gf_bs_read_u32_le(bs); //subchunk size\n\t\t\tif (type==GF_4CC('d', 'a', 't', 'a')) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (type!=GF_4CC('f', 'm', 't', ' ')) {\n\t\t\t\tgf_bs_skip_bytes(bs, csize);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//parse fmt\n\t\t\thdr_found = GF_TRUE;\n\t\t\tu16 atype = gf_bs_read_u16_le(bs);\n\t\t\tctx->ch = gf_bs_read_u16_le(bs);\n\t\t\tctx->sr = gf_bs_read_u32_le(bs);\n\t\t\tgf_bs_read_u32_le(bs); //byte rate\n\t\t\tgf_bs_read_u16_le(bs); // block align\n\t\t\tu32 bps = gf_bs_read_u16_le(bs);\n\t\t\tcsize-=16;\n\t\t\tif (ctx->ch==1) ctx->layout = GF_AUDIO_CH_FRONT_CENTER;\n\t\t\telse if (ctx->ch==2) ctx->layout = GF_AUDIO_CH_FRONT_LEFT|GF_AUDIO_CH_FRONT_RIGHT;\n\t\t\telse ctx->layout = 0;\n\n\t\t\tif (atype==3) {\n\t\t\t\tif (bps==32) {\n\t\t\t\t\tctx->safmt = GF_AUDIO_FMT_FLT;\n\t\t\t\t} else if (bps==64) {\n\t\t\t\t\tctx->safmt = GF_AUDIO_FMT_DBL;\n\t\t\t\t} else {\n\t\t\t\t\twav_ok = GF_FALSE;\n\t\t\t\t}\n\t\t\t} else if ((atype==1) || (atype==0xFFFE))  {\n\t\t\t\tif (bps==32) {\n\t\t\t\t\tctx->safmt = GF_AUDIO_FMT_S32;\n\t\t\t\t} else if (bps==24) {\n\t\t\t\t\tctx->safmt = GF_AUDIO_FMT_S24;\n\t\t\t\t} else if (bps==16) {\n\t\t\t\t\tctx->safmt = GF_AUDIO_FMT_S16;\n\t\t\t\t} else if (bps==8) {\n\t\t\t\t\tctx->safmt = GF_AUDIO_FMT_U8;\n\t\t\t\t} else {\n\t\t\t\t\twav_ok = GF_FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (atype==0xFFFE) {\n\t\t\t\tgf_bs_read_u16_le(bs); //cbSize\n\t\t\t\tgf_bs_read_u16_le(bs); //Samples\n\t\t\t\tu32 ch_mask = gf_bs_read_u32_le(bs); //channel mask\n\t\t\t\tcsize-=8;\n\t\t\t\tctx->layout = 0;\n\t\t\t\tif (ch_mask & 0x1) ctx->layout |= GF_AUDIO_CH_FRONT_LEFT;\n\t\t\t\tif (ch_mask & 0x2) ctx->layout |= GF_AUDIO_CH_FRONT_RIGHT;\n\t\t\t\tif (ch_mask & 0x4) ctx->layout |= GF_AUDIO_CH_FRONT_CENTER;\n\t\t\t\tif (ch_mask & 0x8) ctx->layout |= GF_AUDIO_CH_LFE;\n\t\t\t\tif (ch_mask & 0x10) ctx->layout |= GF_AUDIO_CH_REAR_SURROUND_LEFT;\n\t\t\t\tif (ch_mask & 0x20) ctx->layout |= GF_AUDIO_CH_REAR_SURROUND_RIGHT;\n\t\t\t\tif (ch_mask & 0x40) ctx->layout |= GF_AUDIO_CH_FRONT_CENTER_LEFT;\n\t\t\t\tif (ch_mask & 0x80) ctx->layout |= GF_AUDIO_CH_FRONT_CENTER_RIGHT;\n\t\t\t\tif (ch_mask & 0x100) ctx->layout |= GF_AUDIO_CH_REAR_CENTER;\n\t\t\t\tif (ch_mask & 0x200) ctx->layout |= GF_AUDIO_CH_SIDE_SURROUND_LEFT;\n\t\t\t\tif (ch_mask & 0x400) ctx->layout |= GF_AUDIO_CH_SIDE_SURROUND_RIGHT;\n\t\t\t\tif (ch_mask & 0x800) ctx->layout |= GF_AUDIO_CH_CENTER_SURROUND_TOP;\n\t\t\t\tif (ch_mask & 0x1000) ctx->layout |= GF_AUDIO_CH_FRONT_TOP_LEFT;\n\t\t\t\tif (ch_mask & 0x2000) ctx->layout |= GF_AUDIO_CH_FRONT_TOP_CENTER;\n\t\t\t\tif (ch_mask & 0x4000) ctx->layout |= GF_AUDIO_CH_FRONT_TOP_RIGHT;\n\t\t\t\tif (ch_mask & 0x8000) ctx->layout |= GF_AUDIO_CH_SURROUND_TOP_LEFT;\n\t\t\t\tif (ch_mask & 0x10000) ctx->layout |= GF_AUDIO_CH_REAR_CENTER_TOP;\n\t\t\t\tif (ch_mask & 0x20000) ctx->layout |= GF_AUDIO_CH_SURROUND_TOP_RIGHT;\n\t\t\t}\n\t\t\tgf_bs_skip_bytes(bs, csize);\n\t\t}\n\t\tif (gf_bs_is_overflow(bs)) {\n\t\t\tif (!ctx->probe_data) {\n\t\t\t\tctx->probe_data = gf_malloc(pck_size);\n\t\t\t\tmemcpy(ctx->probe_data, data, pck_size);\n\t\t\t\tctx->probe_data_size = pck_size;\n\t\t\t}\n\t\t\tif (!hdr_found) {\n\t\t\t\tif (ctx->probe_data_size<=10000) {\n\t\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[PCMReframe] Cannot find wave data chunk after %d bytes, aborting\\n\", ctx->probe_data_size));\n\t\t\t}\n\t\t\twav_ok = GF_FALSE;\n\t\t}\n\t\tif (!ctx->ch) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[PCMReframe] Channel count %d invalid in wave\\n\", ctx->ch));\n\t\t\twav_ok = GF_FALSE;\n\t\t}\n\t\tif (!ctx->sr) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[PCMReframe] Samplerate %d invalid in wave\\n\", ctx->sr));\n\t\t\twav_ok = GF_FALSE;\n\t\t}\n\n\t\tctx->wav_hdr_size = (u32) gf_bs_get_position(bs);\n\n\t\tgf_bs_del(bs);\n\t\tif (!wav_ok) {\n\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\tif (ctx->opid)\n\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\tgf_filter_pid_set_discard(ctx->ipid, GF_TRUE);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[PCMReframe] Invalid or unsupported WAVE header, aborting\\n\", ctx->probe_data_size));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\n\t\tctx->probe_wave = 2;\n\t\tpcmreframe_configure_pid(filter, ctx->ipid, GF_FALSE);\n\t\tif (ctx->probe_data) {\n\t\t\tpck_size = ctx->probe_data_size;\n\t\t\tdata = ctx->probe_data;\n\t\t}\n\t\tctx->init_skip = GF_TRUE;\n\t\tbyte_offset = 0;\n\t\tif (!ctx->is_playing) {\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\tif (ctx->init_skip) {\n\t\tdata+=ctx->wav_hdr_size;\n\t\tpck_size-=ctx->wav_hdr_size;\n\t\tbyte_offset = 0;\n\t\tctx->init_skip = GF_FALSE;\n\t}\n\n\tbyte_offset+= ctx->wav_hdr_size;\n\n\twhile (pck_size) {\n\t\tif (!ctx->out_pck) {\n\t\t\tctx->out_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->frame_size, &ctx->out_data);\n\t\t\tif (!ctx->out_pck) return GF_OUT_OF_MEM;\n\n\t\t\tgf_filter_pck_set_cts(ctx->out_pck, ctx->cts);\n\t\t\tgf_filter_pck_set_sap(ctx->out_pck, GF_FILTER_SAP_1);\n\t\t\tgf_filter_pck_set_duration(ctx->out_pck, ctx->framelen);\n\t\t\tgf_filter_pck_set_byte_offset(ctx->out_pck, byte_offset);\n\t\t}\n\n\t\tif (pck_size + ctx->nb_bytes_in_frame < ctx->frame_size) {\n\t\t\tmemcpy(ctx->out_data + ctx->nb_bytes_in_frame, data, pck_size);\n\t\t\tctx->nb_bytes_in_frame += pck_size;\n\t\t\tpck_size = 0;\n\t\t} else {\n\t\t\tu32 remain = ctx->frame_size - ctx->nb_bytes_in_frame;\n\t\t\tmemcpy(ctx->out_data + ctx->nb_bytes_in_frame, data, remain);\n\t\t\tctx->nb_bytes_in_frame = ctx->frame_size;\n\t\t\tpcmreframe_flush_packet(ctx);\n\n\t\t\tpck_size -= remain;\n\t\t\tdata += remain;\n\t\t\tbyte_offset += remain;\n\t\t\tctx->out_pck = NULL;\n\t\t\tctx->nb_bytes_in_frame = 0;\n\n\t\t\t//reverse playback, the remaining data is for the next frame, we want the previous one.\n\t\t\t//Trash packet and seek to previous frame\n\t\t\tif (ctx->reverse_play) {\n\t\t\t\tGF_FilterEvent fevt;\n\t\t\t\tif (!ctx->cts) {\n\t\t\t\t\tif (ctx->opid)\n\t\t\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\t\t\tGF_FEVT_INIT(fevt, GF_FEVT_STOP, ctx->ipid);\n\t\t\t\t\tgf_filter_pid_send_event(ctx->ipid, &fevt);\n\t\t\t\t\tctx->done = GF_TRUE;\n\t\t\t\t\treturn GF_EOS;\n\t\t\t\t}\n\t\t\t\tctx->cts -= ctx->framelen;\n\t\t\t\tctx->filepos -= ctx->frame_size;\n\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\t\t//post a seek, this will trash remaining packets in buffers\n\t\t\t\tGF_FEVT_INIT(fevt, GF_FEVT_SOURCE_SEEK, ctx->ipid);\n\t\t\t\tfevt.seek.start_offset = ctx->filepos + ctx->wav_hdr_size;\n\t\t\t\tgf_filter_pid_send_event(ctx->ipid, &fevt);\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tctx->cts += ctx->framelen;\n\t\t}\n\t}\n\tgf_filter_pid_drop_packet(ctx->ipid);\n\n\tif (ctx->probe_data) {\n\t\tgf_free(ctx->probe_data);\n\t\tctx->probe_data = NULL;\n\t\tctx->probe_data_size = 0;\n\t}\n\treturn GF_OK;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 3294,
    "critical_vars": [
      "str"
    ],
    "function": "gf_bt_loader_run_intern",
    "filename": "gpac/CVE-2023-4683/CVE-2023-4683_CWE-476_112767e8b178fc82dec3cf82a1ca14d802cdb8ec_loader_bt.c.diff",
    "function_code": "\nGF_Err gf_bt_loader_run_intern(GF_BTParser *parser, GF_Command *init_com, Bool initial_run)\n{\n\tchar *str;\n\tGF_Node *node, *vrml_root_node;\n\tBool force_new_com;\n\tGF_Route *r;\n\tBool has_id;\n\tchar szDEFName[1000];\n\n\tvrml_root_node = NULL;\n\thas_id = 0;\n\n\tif (init_com)\n\t\tparser->in_com = 0 ;\n\n\tparser->cur_com = init_com;\n\n\tforce_new_com = (parser->load->flags & GF_SM_LOAD_CONTEXT_READY) ? 1 : 0;\n\n\n\t/*create a default root node for all VRML nodes*/\n\tif (parser->is_wrl && !parser->top_nodes) {\n\t\tif (initial_run ) {\n#ifndef GPAC_DISABLE_X3D\n\t\t\tvrml_root_node = gf_node_new(parser->load->scene_graph, (parser->load->flags & GF_SM_LOAD_MPEG4_STRICT) ? TAG_MPEG4_Group : TAG_X3D_Group);\n#else\n\t\t\tvrml_root_node = gf_node_new(parser->load->scene_graph, TAG_MPEG4_Group);\n#endif\n\t\t\tgf_node_register(vrml_root_node, NULL);\n\t\t\tgf_node_init(vrml_root_node);\n\t\t\tgf_sg_set_root_node(parser->load->scene_graph, vrml_root_node);\n\t\t} else {\n\t\t\tvrml_root_node = gf_sg_get_root_node(parser->load->scene_graph);\n\t\t}\n\t}\n\n\tif (!parser->in_com)\n\t\tparser->stream_id = parser->load->force_es_id;\n\n\t/*parse all top-level items*/\n\twhile (!parser->last_error) {\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tif (parser->done) break;\n\n\t\tif (!strcmp(str, \"\")) {\n\t\t\t//empty string, force moving to next char\n\t\t\tif (parser->line_pos<parser->line_size) parser->line_pos++;\n\t\t}\n\t\t/*X3D specific things (ignored for now)*/\n\t\telse if (!strcmp(str, \"PROFILE\")) gf_bt_force_line(parser);\n\t\telse if (!strcmp(str, \"COMPONENT\")) gf_bt_force_line(parser);\n\t\telse if (!strcmp(str, \"META\")) gf_bt_force_line(parser);\n\t\telse if (!strcmp(str, \"IMPORT\") || !strcmp(str, \"EXPORT\")) {\n\t\t\tgf_bt_report(parser, GF_NOT_SUPPORTED, \"X3D IMPORT/EXPORT not implemented\");\n\t\t\tbreak;\n\t\t}\n\n\t\t/*IOD*/\n\t\telse if (!strcmp(str, \"InitialObjectDescriptor\") || !strcmp(str, \"ObjectDescriptor\")) {\n\t\t\tparser->load->ctx->root_od = (GF_ObjectDescriptor *) gf_bt_parse_descriptor(parser, str);\n\t\t}\n\t\t/*explicit command*/\n\t\telse if (!strcmp(str, \"AT\") || !strcmp(str, \"RAP\")) {\n\t\t\tparser->au_is_rap = 0;\n\t\t\tif (!strcmp(str, \"RAP\")) {\n\t\t\t\tparser->au_is_rap = 1;\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tif (strcmp(str, \"AT\")) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"AT expected got %s\", str);\n\t\t\t\t\tparser->last_error = GF_BAD_PARAM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tforce_new_com = 0;\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tif (str[0] == 'D') {\n\t\t\t\tparser->au_time += atoi(&str[1]);\n\t\t\t} else {\n\t\t\t\tif (sscanf(str, \"%u\", &parser->au_time) != 1) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Number expected got %s\", str);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (parser->last_error) break;\n\t\t\t/*reset all contexts*/\n\t\t\tif (parser->od_au && (parser->od_au->timing != parser->au_time)) parser->od_au = NULL;\n\t\t\tif (parser->bifs_au && (parser->bifs_au->timing != parser->au_time)) {\n\t\t\t\tgf_bt_check_unresolved_nodes(parser);\n\t\t\t\tparser->bifs_au = NULL;\n\t\t\t}\n\n\t\t\tparser->stream_id = 0;\n\t\t\t/*fix for mp4tool bt which doesn't support RAP signaling: assume the first AU\n\t\t\tis always RAP*/\n\t\t\tif (!parser->au_time) parser->au_is_rap = 1;\n\n\t\t\tparser->in_com = 1;\n\n\t\t\tif (!gf_bt_check_code(parser, '{')) {\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tif (!strcmp(str, \"IN\")) {\n\t\t\t\t\tgf_bt_parse_int(parser, \"IN\", (SFInt32*)&parser->stream_id);\n\t\t\t\t\tif (parser->last_error) break;\n\t\t\t\t}\n\t\t\t\tif (!gf_bt_check_code(parser, '{')) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"{ expected\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*done loading init frame*/\n\t\t\tif (init_com && parser->au_time) break;\n\t\t}\n\t\telse if (!strcmp(str, \"PROTO\") || !strcmp(str, \"EXTERNPROTO\")) {\n\t\t\tgf_bt_parse_proto(parser, str, init_com ? init_com->new_proto_list : NULL);\n\t\t}\n\t\t/*compatibility for old bt (mp4tool) in ProtoLibs*/\n\t\telse if (!strcmp(str, \"NULL\")) {\n\t\t}\n\t\telse if (!strcmp(str, \"DEF\")) {\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tstrcpy(szDEFName, str);\n\t\t\thas_id = 1;\n\t\t}\n\t\telse if (!strcmp(str, \"ROUTE\")) {\n\t\t\tGF_Command *com = NULL;\n\t\t\tif (!parser->top_nodes && parser->bifs_au && !parser->is_wrl) {\n\t\t\t\t/*if doing a scene replace, we need route insert stuff*/\n\t\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_ROUTE_INSERT);\n\t\t\t\tgf_list_add(parser->bifs_au->commands, com);\n\t\t\t\tgf_list_add(parser->inserted_routes, com);\n\t\t\t}\n\n\t\t\tr = gf_bt_parse_route(parser, 1, 0, com);\n\t\t\tif (has_id) {\n\t\t\t\tu32 rID = gf_bt_get_route(parser, szDEFName);\n\t\t\t\tif (!rID) rID = gf_bt_get_next_route_id(parser);\n\t\t\t\tif (com) {\n\t\t\t\t\tcom->RouteID = rID;\n\t\t\t\t\tcom->def_name = gf_strdup(szDEFName);\n\t\t\t\t\tgf_sg_set_max_defined_route_id(parser->load->scene_graph, rID);\n\t\t\t\t} else if (r) {\n\t\t\t\t\tgf_sg_route_set_id(r, rID);\n\t\t\t\t\tgf_sg_route_set_name(r, szDEFName);\n\t\t\t\t}\n\t\t\t\thas_id = 0;\n\t\t\t}\n\t\t}\n\t\t/*OD commands*/\n\t\telse if (!strcmp(str, \"UPDATE\") || !strcmp(str, \"REMOVE\")) {\n\t\t\tBool is_base_stream = parser->stream_id ? 0 : 1;\n\t\t\tif (!parser->stream_id || parser->stream_id==parser->bifs_es->ESID) parser->stream_id = parser->base_od_id;\n\n\t\t\tif (parser->od_es && (parser->od_es->ESID != parser->stream_id)) {\n\t\t\t\tGF_StreamContext *prev = parser->od_es;\n\t\t\t\tparser->od_es = gf_sm_stream_new(parser->load->ctx, (u16) parser->stream_id, GF_STREAM_OD, GF_CODECID_OD_V1);\n\t\t\t\t/*force new AU if stream changed*/\n\t\t\t\tif (parser->od_es != prev) {\n\t\t\t\t\tparser->bifs_au = NULL;\n\t\t\t\t\tparser->od_au = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!parser->od_es) parser->od_es = gf_sm_stream_new(parser->load->ctx, (u16) parser->stream_id, GF_STREAM_OD, GF_CODECID_OD_V1);\n\t\t\tif (!parser->od_au) parser->od_au = gf_sm_stream_au_new(parser->od_es, parser->au_time, 0, parser->au_is_rap);\n\t\t\tgf_bt_parse_od_command(parser, str);\n\t\t\tif (is_base_stream) parser->stream_id= 0;\n\t\t}\n\t\t/*BIFS commands*/\n\t\telse if (!strcmp(str, \"REPLACE\") || !strcmp(str, \"INSERT\") || !strcmp(str, \"APPEND\") || !strcmp(str, \"DELETE\")\n\t\t         /*BIFS extended commands*/\n\t\t         || !strcmp(str, \"GLOBALQP\") || !strcmp(str, \"MULTIPLEREPLACE\") || !strcmp(str, \"MULTIPLEINDREPLACE\") || !strcmp(str, \"XDELETE\") || !strcmp(str, \"DELETEPROTO\") || !strcmp(str, \"INSERTPROTO\")\n\t\t         || !strcmp(str, \"XREPLACE\")\n\t\t        ) {\n\t\t\tBool is_base_stream = parser->stream_id ? 0 : 1;\n\n\t\t\tif (!parser->stream_id) parser->stream_id = parser->base_bifs_id;\n\t\t\tif (!parser->stream_id || (parser->od_es && (parser->stream_id==parser->od_es->ESID)) ) parser->stream_id = parser->base_bifs_id;\n\n\t\t\tif (parser->bifs_es->ESID != parser->stream_id) {\n\t\t\t\tGF_StreamContext *prev = parser->bifs_es;\n\t\t\t\tparser->bifs_es = gf_sm_stream_new(parser->load->ctx, (u16) parser->stream_id, GF_STREAM_SCENE, GF_CODECID_BIFS);\n\t\t\t\t/*force new AU if stream changed*/\n\t\t\t\tif (parser->bifs_es != prev) {\n\t\t\t\t\tgf_bt_check_unresolved_nodes(parser);\n\t\t\t\t\tparser->bifs_au = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (force_new_com) {\n\t\t\t\tforce_new_com = 0;\n\t\t\t\tparser->bifs_au = gf_list_last(parser->bifs_es->AUs);\n\t\t\t\tparser->au_time = (u32) (parser->bifs_au ? parser->bifs_au->timing : 0) + 1;\n\t\t\t\tparser->bifs_au = NULL;\n\t\t\t}\n\n\t\t\tif (!parser->bifs_au) parser->bifs_au = gf_sm_stream_au_new(parser->bifs_es, parser->au_time, 0, parser->au_is_rap);\n\t\t\tgf_bt_parse_bifs_command(parser, str, parser->bifs_au->commands);\n\t\t\tif (is_base_stream) parser->stream_id= 0;\n\t\t}\n\t\t/*implicit BIFS command on SFTopNodes only*/\n\t\telse if (!strcmp(str, \"OrderedGroup\")\n\t\t         || !strcmp(str, \"Group\")\n\t\t         || !strcmp(str, \"Layer2D\")\n\t\t         || !strcmp(str, \"Layer3D\")\n\t\t         /* VRML parsing: all nodes are allowed*/\n\t\t         || parser->is_wrl\n\t\t        )\n\t\t{\n\n\t\t\tnode = gf_bt_sf_node(parser, str, vrml_root_node, has_id ? szDEFName : NULL);\n\t\t\thas_id = 0;\n\t\t\tif (!node) break;\n\t\t\tif (parser->top_nodes) {\n\t\t\t\tgf_list_add(parser->top_nodes, node);\n\t\t\t} else if (!vrml_root_node) {\n\t\t\t\tif (init_com) init_com->node = node;\n\t\t\t\telse if (parser->load->flags & GF_SM_LOAD_CONTEXT_READY) {\n\t\t\t\t\tGF_Command *com = gf_sg_command_new(parser->load->scene_graph, GF_SG_SCENE_REPLACE);\n\t\t\t\t\tassert(!parser->bifs_au);\n\t\t\t\t\tassert(parser->bifs_es);\n\t\t\t\t\tparser->bifs_au = gf_sm_stream_au_new(parser->bifs_es, 0, 0, 1);\n\t\t\t\t\tgf_list_add(parser->bifs_au->commands, com);\n\t\t\t\t\tcom->node = node;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgf_node_insert_child(vrml_root_node, node, -1);\n\t\t\t}\n\n\t\t\t/*\n\t\t\tif (!gf_sg_get_root_node(parser->load->scene_graph)) {\n\t\t\t\tgf_node_register(node, NULL);\n\t\t\t\tgf_sg_set_root_node(parser->load->scene_graph, node);\n\t\t\t}\n\t\t\t*/\n\t\t}\n\n\t\t/*if in command, check command end*/\n\t\telse {\n\t\t\t/*check command end*/\n\t\t\tif (/*in_com && */gf_bt_check_code(parser, '}')) parser->in_com = 0;\n\t\t\telse if (strlen(str)) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown top-level element\", str);\n\t\t\t}\n\t\t\tparser->au_is_rap = 0;\n\t\t}\n\t}\n\tgf_bt_resolve_routes(parser, 0);\n\tgf_bt_check_unresolved_nodes(parser);\n\n\t/*load scripts*/\n\twhile (gf_list_count(parser->scripts)) {\n\t\tGF_Node *n = (GF_Node *)gf_list_get(parser->scripts, 0);\n\t\tgf_list_rem(parser->scripts, 0);\n\t\tgf_sg_script_load(n);\n\t}\n\treturn parser->last_error;",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 1051,
    "critical_vars": [
      "parser->in_entity"
    ],
    "function": "gf_xml_sax_parse_intern",
    "filename": "gpac/CVE-2023-4683/CVE-2023-4683_CWE-476_112767e8b178fc82dec3cf82a1ca14d802cdb8ec_xml_parser.c.diff",
    "function_code": "static GF_Err gf_xml_sax_parse_intern(GF_SAXParser *parser, char *current)\n{\n\tu32 count;\n\t/*solve entities*/\n\tcount = gf_list_count(parser->entities);\n\twhile (count) {\n\t\tchar *entityEnd;\n\t\tXML_Entity *ent;\n\t\tchar *entityStart = strstr(current, \"&\");\n\t\tBool needs_text;\n\t\tu32 line_num;\n\n\t\t/*if in entity, the start of the entity is in the buffer !!*/\n\t\tif (parser->in_entity) {\n\t\t\tu32 len;\n\t\t\tchar *name;\n\t\t\tentityEnd = strstr(current, \";\");\n\t\t\tif (!entityEnd) return xml_sax_append_string(parser, current);\n\t\t\tentityStart = strrchr(parser->buffer, '&');\n\n\t\t\tentityEnd[0] = 0;\n\t\t\tlen = (u32) strlen(entityStart) + (u32) strlen(current) + 1;\n\t\t\tname = (char*)gf_malloc(sizeof(char)*len);\n\t\t\tsprintf(name, \"%s%s;\", entityStart+1, current);\n\n\t\t\tent = gf_xml_locate_entity(parser, name, &needs_text);\n\t\t\tgf_free(name);\n\n\t\t\t//entity not found, parse as regular string\n\t\t\tif (!ent && !needs_text) {\n\t\t\t\txml_sax_append_string(parser, current);\n\t\t\t\txml_sax_parse(parser, GF_TRUE);\n\t\t\t\tentityEnd[0] = ';';\n\t\t\t\tcurrent = entityEnd;\n\t\t\t\tparser->in_entity = GF_FALSE;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tassert(ent);\n\t\t\t/*truncate input buffer*/\n\t\t\tparser->line_size -= (u32) strlen(entityStart);\n\t\t\tentityStart[0] = 0;\n\n\t\t\tparser->in_entity = GF_FALSE;\n\t\t\tentityEnd[0] = ';';\n\t\t\tcurrent = entityEnd+1;\n\t\t} else {\n\t\t\tif (!entityStart) break;\n\n\t\t\tent = gf_xml_locate_entity(parser, entityStart+1, &needs_text);\n\n\t\t\t/*store current string before entity start*/\n\t\t\tentityStart[0] = 0;\n\t\t\txml_sax_append_string(parser, current);\n\t\t\txml_sax_parse(parser, GF_TRUE);\n\t\t\tentityStart[0] = '&';\n\n\t\t\t/*this is not an entitiy*/\n\t\t\tif (!ent && !needs_text) {\n\t\t\t\txml_sax_append_string(parser, \"&\");\n\t\t\t\tcurrent = entityStart+1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!ent) {\n\t\t\t\tparser->in_entity = GF_TRUE;\n\t\t\t\t/*store entity start*/\n\t\t\t\treturn xml_sax_append_string(parser, entityStart);\n\t\t\t}\n\t\t\tcurrent = entityStart + ent->namelen + 2;\n\t\t}\n\t\t/*append entity*/\n\t\tline_num = parser->line;\n\t\txml_sax_append_string(parser, ent->value);\n\t\tGF_Err e = xml_sax_parse(parser, GF_TRUE);\n\t\tparser->line = line_num;\n\t\tif (e) return e;\n\n\t}\n\txml_sax_append_string(parser, current);\n\treturn xml_sax_parse(parser, GF_FALSE);\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Fun-Call",
    "line_old": 5598,
    "line_new": 5598,
    "critical_vars": [
      "inName",
      "stderr"
    ],
    "function": "mp4boxMain",
    "filename": "gpac/CVE-2020-23930/CVE-2020-23930_CWE-476_9eeac00b38348c664dfeae2525bba0cf1bc32349_main.c.diff",
    "function_code": "int mp4boxMain(int argc, char **argv)\n{\n\tu32 i, j;\n\tconst char *gpac_profile = \"0\";\n\tGF_Err e = GF_OK;\n\tnb_tsel_acts = nb_add = nb_cat = nb_track_act = nb_sdp_ex = max_ptime = nb_meta_act = rtp_rate = major_brand = nb_alt_brand_add = nb_alt_brand_rem = car_dur = minor_version = 0;\n\n\tsplit_duration = 0.0;\n\tsplit_start = -1.0;\n\tinterleaving_time = 0;\n\tdash_duration = dash_subduration = 0.0;\n\timport_fps.num = import_fps.den = 0;\n\timport_flags = 0;\n\tsplit_size = 0;\n\tmovie_time = 0;\n\tdump_nal = dump_saps = dump_saps_mode = force_new = 0;\n\tFullInter = HintInter = encode = do_scene_log = old_interleave = do_saf = do_hash = verbose = do_mpd_rip = merge_vtt_cues = get_nb_tracks = GF_FALSE;\n#ifndef GPAC_DISABLE_SCENE_DUMP\n\tdump_mode = GF_SM_DUMP_NONE;\n#endif\n\tFrag = force_ocr = remove_sys_tracks = agg_samples = remove_hint = keep_sys_tracks = remove_root_od = single_group = clean_groups = compress_moov = GF_FALSE;\n\tconv_type = HintIt = needSave = print_sdp = regular_iod = dump_std = open_edit = dump_rtp = dump_cr = dump_srt = dump_ttxt = dump_m2ts = dump_cart = import_subtitle = force_cat = pack_wgt = dash_live = GF_FALSE;\n\tno_fragments_defaults = GF_FALSE;\n\tsingle_traf_per_moof = hls_clock = GF_FALSE;\n    tfdt_per_traf = GF_FALSE;\n\tdump_nal_type = 0;\n\tdump_isom = 0;\n\tprint_info = 0;\n\t/*align cat is the new default behaviour for -cat*/\n\talign_cat = GF_TRUE;\n\tsubsegs_per_sidx = 0;\n\ttrack_dump_type = 0;\n\tcrypt = 0;\n\ttime_shift_depth = 0;\n\tfile = NULL;\n\titunes_tags = pes_dump = NULL;\n\tseg_name = dash_ctx_file = NULL;\n\tcompress_top_boxes = NULL;\n\tinitial_moof_sn = 0;\n\tinitial_tfdt = 0;\n\n#ifndef GPAC_DISABLE_SCENE_ENCODER\n\tmemset(&smenc_opts, 0, sizeof(smenc_opts));\n#endif\n\n\ttrackID = stat_level = hint_flags = 0;\n\tprogram_number = 0;\n\tinfo_track_id = 0;\n\tdo_flat = 0;\n\tinName = outName = mediaSource = input_ctx = output_ctx = drm_file = avi2raw = cprt = chap_file = pack_file = raw_cat = high_dynamc_range_filename = use_init_seg = box_patch_filename = NULL;\n\n#ifndef GPAC_DISABLE_SWF_IMPORT\n\tswf_flags = GF_SM_SWF_SPLIT_TIMELINE;\n#endif\n\tswf_flatten_angle = 0.0f;\n\ttmpdir = NULL;\n\n\tfor (i = 1; i < (u32) argc ; i++) {\n\t\tif (!strcmp(argv[i], \"-mem-track\") || !strcmp(argv[i], \"-mem-track-stack\")) {\n#ifdef GPAC_MEMORY_TRACKING\n            mem_track = !strcmp(argv[i], \"-mem-track-stack\") ? GF_MemTrackerBackTrace : GF_MemTrackerSimple;\n#else\n\t\t\tfprintf(stderr, \"WARNING - GPAC not compiled with Memory Tracker - ignoring \\\"%s\\\"\\n\", argv[i]);\n#endif\n\t\t\tbreak;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"-p\")) {\n\t\t\tif (i+1<(u32) argc)\n\t\t\t\tgpac_profile = argv[i+1];\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"Bad argument for -p, expecting profile name but no more args\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\telse if (!strncmp(argv[i], \"-p=\", 3))\n\t\t\tgpac_profile = argv[i]+3;\n\t}\n\n#ifdef _TWO_DIGIT_EXPONENT\n\t_set_output_format(_TWO_DIGIT_EXPONENT);\n#endif\n\n\t/*init libgpac*/\n\tgf_sys_init(mem_track, gpac_profile);\n\tif (argc < 2) {\n\t\tfprintf(stderr, \"Not enough arguments - check usage with -h\\n\"\n\t\t\t\"MP4Box - GPAC version %s\\n\"\n\t        \"%s\\n\", gf_gpac_version(), gf_gpac_copyright());\n\t\tgf_sys_close();\n\t\treturn 0;\n\t}\n\n\thelpout = stdout;\n\n\ti = mp4box_parse_args(argc, argv);\n\tif (i) {\n\t\treturn mp4box_cleanup(i - 1);\n\t}\n\n\tif (!inName && dump_std)\n\t\tinName = \"std\";\n\n\tif (!inName) {\n\t\tif (has_next_arg) {\n\t\t\tfprintf(stderr, \"Broken argument specifier or file name missing - check usage with -h\\n\");\n\t\t} else {\n\t\t\tPrintUsage();\n\t\t}\n\t\treturn mp4box_cleanup(1);\n\t}\n\tif (!strcmp(inName, \"std\")) dump_std = 2;\n\tif (!strcmp(inName, \"stdb\")) {\n\t\tinName = \"std\";\n\t\tdump_std = 1;\n\t}\n\n\tif (!interleaving_time) {\n\t\t/*by default use single fragment per dash segment*/\n\t\tif (dash_duration)\n\t\t\tinterleaving_time = dash_duration;\n\t\telse if (!do_flat) {\n\t\t\tinterleaving_time = DEFAULT_INTERLEAVING_IN_SEC;\n\t\t}\n\t}\n\n\tif (dump_std)\n\t\toutName = \"std\";\n\n\tif (dump_std==2) {\n#ifdef WIN32\n\t\tif ( _setmode(_fileno(stdout), _O_BINARY) == -1 )\n#else\n\t\tif ( freopen(NULL, \"wb\", stdout) == NULL)\n#endif\n\t\t{\n\t\t\tfprintf(stderr, \"Fatal error: cannot reopen stdout in binary mode.\\n\");\n\t\t\treturn mp4box_cleanup(1);\n\t\t}\n\t}\n\n#if !defined(GPAC_DISABLE_STREAMING) && !defined(GPAC_DISABLE_SENG)\n\tif (live_scene) {\n\t\tint ret = live_session(argc, argv);\n\t\treturn mp4box_cleanup(ret);\n\t}\n#endif\n\n\tGF_LOG_Level level = verbose ? GF_LOG_DEBUG : GF_LOG_INFO;\n\tgf_log_set_tool_level(GF_LOG_CONTAINER, level);\n\tgf_log_set_tool_level(GF_LOG_SCENE, level);\n\tgf_log_set_tool_level(GF_LOG_PARSER, level);\n\tgf_log_set_tool_level(GF_LOG_AUTHOR, level);\n\tgf_log_set_tool_level(GF_LOG_CODING, level);\n\tgf_log_set_tool_level(GF_LOG_DASH, level);\n#ifdef GPAC_MEMORY_TRACKING\n\tif (mem_track)\n\t\tgf_log_set_tool_level(GF_LOG_MEMORY, level);\n#endif\n\n\te = gf_sys_set_args(argc, (const char **) argv);\n\tif (e) {\n\t\tfprintf(stderr, \"Error assigning libgpac arguments: %s\\n\", gf_error_to_string(e) );\n\t\treturn mp4box_cleanup(1);\n\t}\n\n\tif (raw_cat) {\n\t\tchar chunk[4096];\n\t\tFILE *fin, *fout;\n\t\ts64 to_copy, done;\n\t\tfin = gf_fopen(raw_cat, \"rb\");\n\t\tif (!fin) return mp4box_cleanup(1);\n\n\t\tfout = gf_fopen(inName, \"a+b\");\n\t\tif (!fout) {\n\t\t\tgf_fclose(fin);\n\t\t\treturn mp4box_cleanup(1);\n\t\t}\n\t\tgf_fseek(fin, 0, SEEK_END);\n\t\tto_copy = gf_ftell(fin);\n\t\tgf_fseek(fin, 0, SEEK_SET);\n\t\tdone = 0;\n\t\twhile (1) {\n\t\t\tu32 nb_bytes = (u32) gf_fread(chunk, 4096, fin);\n\t\t\tgf_fwrite(chunk, nb_bytes, fout);\n\t\t\tdone += nb_bytes;\n\t\t\tfprintf(stderr, \"Appending file %s - %02.2f done\\r\", raw_cat, 100.0*done/to_copy);\n\t\t\tif (done >= to_copy) break;\n\t\t}\n\t\tgf_fclose(fin);\n\t\tgf_fclose(fout);\n\t\treturn mp4box_cleanup(0);\n\t}\n\tif (compress_top_boxes) {\n\t\tif (size_top_box) {\n\t\t\tu64 top_size = do_size_top_boxes(inName, compress_top_boxes, size_top_box);\n\t\t\tfprintf(stdout, LLU\"\\n\", top_size);\n\t\t\treturn mp4box_cleanup(e ? 1 : 0);\n\t\t} else {\n\t\t\te = do_compress_top_boxes(inName, outName, compress_top_boxes, comp_top_box_version, comp_lzma);\n\t\t\treturn mp4box_cleanup(e ? 1 : 0);\n\t\t}\n\t}\n\n\tif (do_mpd_rip) {\n\t\te = rip_mpd(inName, outName);\n\t\treturn mp4box_cleanup(e ? 1 : 0);\n\t}\n\n#ifndef GPAC_DISABLE_CORE_TOOLS\n\tif (do_wget != NULL) {\n\t\te = gf_dm_wget(do_wget, inName, 0, 0, NULL);\n\t\tif (e != GF_OK) {\n\t\t\tfprintf(stderr, \"Cannot retrieve %s: %s\\n\", do_wget, gf_error_to_string(e) );\n\t\t\treturn mp4box_cleanup(1);\n\t\t}\n\t\treturn mp4box_cleanup(0);\n\t}\n#endif\n\n\tif (udp_dest) {\n\t\tGF_Socket *sock = gf_sk_new(GF_SOCK_TYPE_UDP);\n\t\tu16 port = 2345;\n\t\tchar *sep = strrchr(udp_dest, ':');\n\t\tif (sep) {\n\t\t\tsep[0] = 0;\n\t\t\tport = atoi(sep+1);\n\t\t}\n\t\te = gf_sk_bind( sock, \"127.0.0.1\", 0, udp_dest, port, 0);\n\t\tif (sep) sep[0] = ':';\n\t\tif (e) fprintf(stderr, \"Failed to bind socket to %s: %s\\n\", udp_dest, gf_error_to_string(e) );\n\t\telse {\n\t\t\te = gf_sk_send(sock, (u8 *) inName, (u32)strlen(inName));\n\t\t\tif (e) fprintf(stderr, \"Failed to send datagram: %s\\n\", gf_error_to_string(e) );\n\t\t}\n\t\tgf_sk_del(sock);\n\t\treturn 0;\n\t}\n\n#ifndef GPAC_DISABLE_MPD\n\tif (do_mpd) {\n\t\tBool remote = GF_FALSE;\n\t\tGF_MPD *mpd;\n\t\tchar *mpd_base_url = NULL;\n\t\tif (!strnicmp(inName, \"http://\", 7) || !strnicmp(inName, \"https://\", 8)) {\n#if !defined(GPAC_DISABLE_CORE_TOOLS)\n\t\t\te = gf_dm_wget(inName, \"tmp_main.m3u8\", 0, 0, &mpd_base_url);\n\t\t\tif (e != GF_OK) {\n\t\t\t\tfprintf(stderr, \"Cannot retrieve M3U8 (%s): %s\\n\", inName, gf_error_to_string(e));\n\t\t\t\tif (mpd_base_url) gf_free(mpd_base_url);\n\t\t\t\treturn mp4box_cleanup(1);\n\t\t\t}\n\t\t\tremote = GF_TRUE;\n#else\n\t\t\tgf_free(mpd_base_url);\n\t\t\tfprintf(stderr, \"HTTP Downloader disabled in this build\\n\");\n\t\t\treturn mp4box_cleanup(1);\n#endif\n\n\t\t\tif (outName)\n\t\t\t\tstrcpy(outfile, outName);\n\t\t\telse {\n\t\t\t\tconst char *sep = gf_file_basename(inName);\n\t\t\t\tchar *ext = gf_file_ext_start(sep);\n\t\t\t\tif (ext) ext[0] = 0;\n\t\t\t\tsprintf(outfile, \"%s.mpd\", sep);\n\t\t\t\tif (ext) ext[0] = '.';\n\t\t\t}\n\t\t} else {\n\t\t\tif (outName)\n\t\t\t\tstrcpy(outfile, outName);\n\t\t\telse {\n\t\t\t\tchar *dst = strdup(inName);\n\t\t\t\tchar *ext = strstr(dst, \".m3u8\");\n\t\t\t\tif (ext) ext[0] = 0;\n\t\t\t\tsprintf(outfile, \"%s.mpd\", dst);\n\t\t\t\tgf_free(dst);\n\t\t\t}\n\t\t}\n\n\t\tmpd = gf_mpd_new();\n\t\tif (!mpd) {\n\t\t\te = GF_OUT_OF_MEM;\n\t\t\tfprintf(stderr, \"[DASH] Error: MPD creation problem %s\\n\", gf_error_to_string(e));\n\t\t\tmp4box_cleanup(1);\n\t\t}\n\t\tFILE *f = gf_fopen(remote ? \"tmp_main.m3u8\" : inName, \"r\");\n\t\tu32 manif_type = 0;\n\t\tif (f) {\n\t\t\tchar szDATA[1000];\n\t\t\ts32 read;\n\t\t\tszDATA[999]=0;\n\t\t\tread = (s32) gf_fread(szDATA, 999, f);\n\t\t\tif (read<0) read = 0;\n\t\t\tszDATA[read]=0;\n\t\t\tgf_fclose(f);\n\t\t\tif (strstr(szDATA, \"SmoothStreamingMedia\"))\n\t\t\t\tmanif_type = 2;\n\t\t\telse if (strstr(szDATA, \"#EXTM3U\"))\n\t\t\t\tmanif_type = 1;\n\t\t}\n\n\t\tif (manif_type==1) {\n\t\t\te = gf_m3u8_to_mpd(remote ? \"tmp_main.m3u8\" : inName, mpd_base_url ? mpd_base_url : inName, outfile, 0, \"video/mp2t\", GF_TRUE, use_url_template, segment_timeline, NULL, mpd, GF_TRUE, GF_TRUE);\n\t\t} else if (manif_type==2) {\n\t\t\te = gf_mpd_smooth_to_mpd(remote ? \"tmp_main.m3u8\" : inName, mpd, mpd_base_url ? mpd_base_url : inName);\n\t\t} else {\n\t\t\te = GF_NOT_SUPPORTED;\n\t\t}\n\t\tif (!e)\n\t\t\tgf_mpd_write_file(mpd, outfile);\n\n\t\tif (mpd)\n\t\t\tgf_mpd_del(mpd);\n\t\tif (mpd_base_url)\n\t\t\tgf_free(mpd_base_url);\n\n\t\tif (remote) {\n\t\t\tgf_file_delete(\"tmp_main.m3u8\");\n\t\t}\n\t\tif (e != GF_OK) {\n\t\t\tfprintf(stderr, \"Error converting %s (%s) to MPD (%s): %s\\n\", (manif_type==1) ? \"HLS\" : \"Smooth\",  inName, outfile, gf_error_to_string(e));\n\t\t\treturn mp4box_cleanup(1);\n\t\t} else {\n\t\t\tfprintf(stderr, \"Done converting %s (%s) to MPD (%s)\\n\", (manif_type==1) ? \"HLS\" : \"Smooth\",  inName, outfile);\n\t\t\treturn mp4box_cleanup(0);\n\t\t}\n\t}\n#endif\n\tif (dash_duration && !nb_dash_inputs) {\n\t\tdash_inputs = set_dash_input(dash_inputs, inName, &nb_dash_inputs);\n\t}\n\n\n\tif (do_saf && !encode) {\n\t\tswitch (get_file_type_by_ext(inName)) {\n\t\tcase GF_FILE_TYPE_BT_WRL_X3DV:\n\t\tcase GF_FILE_TYPE_XMT_X3D:\n\t\tcase GF_FILE_TYPE_SVG:\n\t\t\tencode = GF_TRUE;\n\t\t\tbreak;\n\t\tcase GF_FILE_TYPE_NOT_SUPPORTED:\n\t\tcase GF_FILE_TYPE_ISO_MEDIA:\n\t\tcase GF_FILE_TYPE_SWF:\n\t\tcase GF_FILE_TYPE_LSR_SAF:\n\t\t\tbreak;\n\t\t}\n\t}\n\n#ifndef GPAC_DISABLE_SCENE_DUMP\n\tif (dump_mode == GF_SM_DUMP_SVG) {\n\t\tif (strstr(inName, \".srt\") || strstr(inName, \".ttxt\")) import_subtitle = 2;\n\t}\n#endif\n\n\n\tif (import_subtitle && !trackID) {\n\t\t/* We import the subtitle file,\n\t\t   i.e. we parse it and store the content as samples of a 3GPP Timed Text track in an ISO file,\n\t\t   possibly for later export (e.g. when converting SRT to TTXT, ...) */\n#ifndef GPAC_DISABLE_MEDIA_IMPORT\n\t\tGF_MediaImporter import;\n\t\t/* Prepare the importer */\n\t\tfile = gf_isom_open(\"ttxt_convert\", GF_ISOM_OPEN_WRITE, NULL);\n\t\tif (timescale && file) gf_isom_set_timescale(file, timescale);\n\n\t\tmemset(&import, 0, sizeof(GF_MediaImporter));\n\t\timport.dest = file;\n\t\timport.in_name = inName;\n\t\t/* Start the import */\n\t\te = gf_media_import(&import);\n\t\tif (e) {\n\t\t\tfprintf(stderr, \"Error importing %s: %s\\n\", inName, gf_error_to_string(e));\n\t\t\tgf_isom_delete(file);\n\t\t\tgf_file_delete(\"ttxt_convert\");\n\t\t\treturn mp4box_cleanup(1);\n\t\t}\n\t\t/* Prepare the export */\n\t\tstrcpy(outfile, inName);\n\t\tif (strchr(outfile, '.')) {\n\t\t\twhile (outfile[strlen(outfile)-1] != '.') outfile[strlen(outfile)-1] = 0;\n\t\t\toutfile[strlen(outfile)-1] = 0;\n\t\t}\n#ifndef GPAC_DISABLE_ISOM_DUMP\n\t\t/* Start the export of the track #1, in the appropriate dump type, indicating it's a conversion */\n\t\tdump_isom_timed_text(file, gf_isom_get_track_id(file, 1),\n\t\t\t\t\t\t\t  dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE,\n\t\t                      GF_TRUE,\n\t\t                      (import_subtitle==2) ? GF_TEXTDUMPTYPE_SVG : (dump_srt ? GF_TEXTDUMPTYPE_SRT : GF_TEXTDUMPTYPE_TTXT));\n#endif\n\t\t/* Clean the importer */\n\t\tgf_isom_delete(file);\n\t\tgf_file_delete(\"ttxt_convert\");\n\t\tif (e) {\n\t\t\tfprintf(stderr, \"Error converting %s: %s\\n\", inName, gf_error_to_string(e));\n\t\t\treturn mp4box_cleanup(1);\n\t\t}\n\t\treturn mp4box_cleanup(0);\n#else\n\t\tfprintf(stderr, \"Feature not supported\\n\");\n\t\treturn mp4box_cleanup(1);\n#endif\n\t}\n\n#if !defined(GPAC_DISABLE_MEDIA_IMPORT) && !defined(GPAC_DISABLE_ISOM_WRITE)\n\tif (nb_add || nb_cat) {\n\t\tu32 ipass, nb_pass = 1;\n\t\tchar *mux_args=NULL;\n\t\tGF_FilterSession *fs = NULL;\n\t\tif (nb_add) {\n\n\t\t\tGF_ISOOpenMode open_mode = GF_ISOM_OPEN_EDIT;\n\t\t\tif (force_new) {\n\t\t\t\topen_mode = (do_flat || (force_new==2)) ? GF_ISOM_OPEN_WRITE : GF_ISOM_WRITE_EDIT;\n\t\t\t} else {\n\t\t\t\tFILE *test = gf_fopen(inName, \"rb\");\n\t\t\t\tif (!test) {\n\t\t\t\t\topen_mode = (do_flat) ? GF_ISOM_OPEN_WRITE : GF_ISOM_WRITE_EDIT;\n\t\t\t\t\tif (!outName) outName = inName;\n\t\t\t\t} else {\n\t\t\t\t\tgf_fclose(test);\n\t\t\t\t\tif (! gf_isom_probe_file(inName) ) {\n\t\t\t\t\t\topen_mode = (do_flat) ? GF_ISOM_OPEN_WRITE : GF_ISOM_WRITE_EDIT;\n\t\t\t\t\t\tif (!outName) outName = inName;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\topen_edit = do_flat ? GF_FALSE : GF_TRUE;\n\t\t\tfile = gf_isom_open(inName, open_mode, tmpdir);\n\t\t\tif (!file) {\n\t\t\t\tfprintf(stderr, \"Cannot open destination file %s: %s\\n\", inName, gf_error_to_string(gf_isom_last_error(NULL)) );\n\t\t\t\treturn mp4box_cleanup(1);\n\t\t\t}\n\n\t\t\tif (freeze_box_order)\n\t\t\t\tgf_isom_freeze_order(file);\n\t\t}\n\n\t\tif (do_flat && interleaving_time) {\n\t\t\tchar szSubArg[100];\n\t\t\tgf_isom_set_storage_mode(file, GF_ISOM_STORE_FASTSTART);\n\t\t\tdo_flat = 2;\n\t\t\tnb_pass = 2;\n\t\t\tfs = gf_fs_new_defaults(0);\n\t\t\tif (!fs) {\n\t\t\t\tfprintf(stderr, \"Error creating filter session\\n\");\n\t\t\t\tgf_isom_delete(file);\n\t\t\t\treturn mp4box_cleanup(1);\n\t\t\t}\n\n\t\t\t//mux args\n\t\t\tgf_dynstrcat(&mux_args, \"mp4mx:importer:store=fstart\", \":\");\n\n\t\t\tsprintf(szSubArg, \"file=%p\", file);\n\t\t\tgf_dynstrcat(&mux_args, szSubArg, \":\");\n\t\t\tsprintf(szSubArg, \"cdur=%g\", interleaving_time);\n\t\t\tgf_dynstrcat(&mux_args, szSubArg, \":\");\n\t\t}\n\n\t\tfor (ipass=0; ipass<nb_pass; ipass++) {\n\t\t\tu32 tk_idx = 1;\n\t\t\tfor (i=0; i<(u32) argc; i++) {\n\t\t\t\tchar *margs=NULL;\n\t\t\t\tif (!strcmp(argv[i], \"-add\")) {\n\t\t\t\t\tchar *src = argv[i+1];\n\n\t\t\t\t\twhile (src) {\n\t\t\t\t\t\tchar *loc_src = src;\n\t\t\t\t\t\tchar *sep = NULL;\n\t\t\t\t\t\twhile (1) {\n\t\t\t\t\t\t\tchar *opt_sep;\n\t\t\t\t\t\t\tsep = strchr(loc_src, '+');\n\t\t\t\t\t\t\tif (!sep) break;\n\n\t\t\t\t\t\t\tsep[0] = 0;\n\t\t\t\t\t\t\tif (strstr(src, \"://\"))\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\topt_sep = gf_url_colon_suffix(src);\n\t\t\t\t\t\t\tif (opt_sep)\n\t\t\t\t\t\t\t\topt_sep[0] = 0;\n\t\t\t\t\t\t\tif (gf_file_exists(src)) {\n\t\t\t\t\t\t\t\tif (opt_sep)\n\t\t\t\t\t\t\t\t\topt_sep[0] = ':';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (opt_sep)\n\t\t\t\t\t\t\t\topt_sep[0] = ':';\n\n\t\t\t\t\t\t\tsep[0] = '+';\n\t\t\t\t\t\t\tloc_src = sep+1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\te = import_file(file, src, import_flags, import_fps, agg_samples, fs, (fs && (ipass==0)) ? &margs : NULL, tk_idx);\n\t\t\t\t\t\ttk_idx++;\n\n\t\t\t\t\t\tif (margs) {\n\t\t\t\t\t\t\tgf_dynstrcat(&mux_args, margs, \":\");\n\t\t\t\t\t\t\tgf_free(margs);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (e) {\n\t\t\t\t\t\t\tfprintf(stderr, \"Error importing %s: %s\\n\", argv[i+1], gf_error_to_string(e));\n\t\t\t\t\t\t\tgf_isom_delete(file);\n\t\t\t\t\t\t\tif (fs)\n\t\t\t\t\t\t\t\tgf_fs_del(fs);\n\t\t\t\t\t\t\treturn mp4box_cleanup(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (sep) {\n\t\t\t\t\t\t\tsep[0] = '+';\n\t\t\t\t\t\t\tsrc = sep+1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t} else if (!strcmp(argv[i], \"-cat\") || !strcmp(argv[i], \"-catx\") || !strcmp(argv[i], \"-catpl\")) {\n\t\t\t\t\tif (nb_pass == 2) {\n\t\t\t\t\t\tfprintf(stderr, \"Cannot cat files when using -newfs mode\\n\");\n\t\t\t\t\t\treturn mp4box_cleanup(1);\n\t\t\t\t\t}\n\t\t\t\t\tif (!file) {\n\t\t\t\t\t\tu8 open_mode = GF_ISOM_OPEN_EDIT;\n\t\t\t\t\t\tif (force_new) {\n\t\t\t\t\t\t\topen_mode = (do_flat) ? GF_ISOM_OPEN_WRITE : GF_ISOM_WRITE_EDIT;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tFILE *test = gf_fopen(inName, \"rb\");\n\t\t\t\t\t\t\tif (!test) {\n\t\t\t\t\t\t\t\topen_mode = (do_flat) ? GF_ISOM_OPEN_WRITE : GF_ISOM_WRITE_EDIT;\n\t\t\t\t\t\t\t\tif (!outName) outName = inName;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse gf_fclose(test);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\topen_edit = GF_TRUE;\n\t\t\t\t\t\tfile = gf_isom_open(inName, open_mode, tmpdir);\n\t\t\t\t\t\tif (!file) {\n\t\t\t\t\t\t\tfprintf(stderr, \"Cannot open destination file %s: %s\\n\", inName, gf_error_to_string(gf_isom_last_error(NULL)) );\n\t\t\t\t\t\t\treturn mp4box_cleanup(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\te = cat_isomedia_file(file, argv[i+1], import_flags, import_fps, agg_samples, tmpdir, force_cat, align_cat, !strcmp(argv[i], \"-catx\") ? GF_TRUE : GF_FALSE, !strcmp(argv[i], \"-catpl\") ? GF_TRUE : GF_FALSE);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tfprintf(stderr, \"Error appending %s: %s\\n\", argv[i+1], gf_error_to_string(e));\n\t\t\t\t\t\tgf_isom_delete(file);\n\t\t\t\t\t\treturn mp4box_cleanup(1);\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((nb_pass == 2) && !ipass) {\n\t\t\t\tGF_Filter *mux_filter = gf_fs_load_filter(fs, mux_args, NULL);\n\t\t\t\tgf_free(mux_args);\n\t\t\t\tif (!mux_filter) {\n\t\t\t\t\tfprintf(stderr, \"Error loadin isobmff mux filter\\n\");\n\t\t\t\t\tgf_isom_delete(file);\n\t\t\t\t\tgf_fs_del(fs);\n\t\t\t\t\treturn mp4box_cleanup(1);\n\t\t\t\t}\n\n\t\t\t\te = gf_fs_run(fs);\n\t\t\t\tif (e==GF_EOS) e = GF_OK;\n\n\t\t\t\tif (!e) e = gf_fs_get_last_connect_error(fs);\n\t\t\t\tif (!e) e = gf_fs_get_last_process_error(fs);\n\n\t\t\t\tif (e) {\n\t\t\t\t\tfprintf(stderr, \"Error importing sources: %s\\n\", gf_error_to_string(e));\n\t\t\t\t\tgf_isom_delete(file);\n\t\t\t\t\tgf_fs_del(fs);\n\t\t\t\t\treturn mp4box_cleanup(1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (fs) {\n\t\t\tif (fs_dump_flags & 1) gf_fs_print_stats(fs);\n\t\t\tif (fs_dump_flags & 2) gf_fs_print_connections(fs);\n\t\t\tgf_fs_del(fs);\n\t\t}\n\n\t\t/*unless explicitly asked, remove all systems tracks*/\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tif (!keep_sys_tracks) remove_systems_tracks(file);\n#endif\n\t\tneedSave = GF_TRUE;\n\t}\n#endif /*!GPAC_DISABLE_MEDIA_IMPORT && !GPAC_DISABLE_ISOM_WRITE*/\n\n#if !defined(GPAC_DISABLE_ISOM_WRITE) && !defined(GPAC_DISABLE_SCENE_ENCODER) && !defined(GPAC_DISABLE_MEDIA_IMPORT)\n\telse if (chunk_mode) {\n\t\tif (!inName) {\n\t\t\tfprintf(stderr, \"chunk encoding syntax: [-outctx outDump] -inctx inScene auFile\\n\");\n\t\t\treturn mp4box_cleanup(1);\n\t\t}\n\t\te = EncodeFileChunk(inName, outName ? outName : inName, input_ctx, output_ctx, tmpdir);\n\t\tif (e) {\n\t\t\tfprintf(stderr, \"Error encoding chunk file %s\\n\", gf_error_to_string(e));\n\t\t\treturn mp4box_cleanup(1);\n\t\t}\n\t\tgoto exit;\n\t}\n#endif // !defined(GPAC_DISABLE_ISOM_WRITE) && !defined(GPAC_DISABLE_SCENE_ENCODER) && !defined(GPAC_DISABLE_MEDIA_IMPORT)\n\telse if (encode) {\n#if !defined(GPAC_DISABLE_ISOM_WRITE) && !defined(GPAC_DISABLE_SCENE_ENCODER) && !defined(GPAC_DISABLE_MEDIA_IMPORT)\n\t\tFILE *logs = NULL;\n\t\tif (do_scene_log) {\n\t\t\tchar alogfile[GF_MAX_PATH];\n\t\t\tstrcpy(alogfile, inName);\n\t\t\tif (strchr(alogfile, '.')) {\n\t\t\t\twhile (alogfile[strlen(alogfile)-1] != '.') alogfile[strlen(alogfile)-1] = 0;\n\t\t\t\talogfile[strlen(alogfile)-1] = 0;\n\t\t\t}\n\t\t\tstrcat(alogfile, \"_enc.logs\");\n\t\t\tlogs = gf_fopen(alogfile, \"wt\");\n\t\t}\n\t\tstrcpy(outfile, outName ? outName : inName);\n\t\tif (strchr(outfile, '.')) {\n\t\t\twhile (outfile[strlen(outfile)-1] != '.') outfile[strlen(outfile)-1] = 0;\n\t\t\toutfile[strlen(outfile)-1] = 0;\n\t\t}\n\t\tstrcat(outfile, \".mp4\");\n\t\tfile = gf_isom_open(outfile, GF_ISOM_WRITE_EDIT, tmpdir);\n\t\tsmenc_opts.mediaSource = mediaSource ? mediaSource : outfile;\n\t\te = EncodeFile(inName, file, &smenc_opts, logs);\n\t\tif (logs) gf_fclose(logs);\n\t\tif (e) goto err_exit;\n\t\tneedSave = GF_TRUE;\n\t\tif (do_saf) {\n\t\t\tneedSave = GF_FALSE;\n\t\t\topen_edit = GF_FALSE;\n\t\t}\n#endif //!defined(GPAC_DISABLE_ISOM_WRITE) && !defined(GPAC_DISABLE_SCENE_ENCODER) && !defined(GPAC_DISABLE_MEDIA_IMPORT)\n\t}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\telse if (pack_file) {\n\t\tchar *fileName = gf_url_colon_suffix(pack_file);\n\t\tif (fileName && ((fileName - pack_file)==4)) {\n\t\t\tfileName[0] = 0;\n\t\t\tfile = package_file(fileName + 1, pack_file, tmpdir, pack_wgt);\n\t\t\tfileName[0] = ':';\n\t\t} else {\n\t\t\tfile = package_file(pack_file, NULL, tmpdir, pack_wgt);\n\t\t\tif (!file) {\n\t\t\t\tfprintf(stderr, \"Failed to package file\\n\");\n\t\t\t\treturn mp4box_cleanup(1);\n\t\t\t}\n\t\t}\n\t\tif (!outName) outName = inName;\n\t\tneedSave = GF_TRUE;\n\t\topen_edit = GF_TRUE;\n\t}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\n\tif (dash_duration) {\n\t\tBool del_file = GF_FALSE;\n\t\tchar szMPD[GF_MAX_PATH], *sep;\n\t\tchar szStateFile[GF_MAX_PATH];\n\t\tBool dyn_state_file = GF_FALSE;\n\t\tu32 do_abort = 0;\n\t\tGF_DASHSegmenter *dasher=NULL;\n\n\t\tif (crypt) {\n\t\t\tfprintf(stderr, \"MP4Box cannot crypt and DASH on the same pass. Please encrypt your content first.\\n\");\n\t\t\treturn mp4box_cleanup(1);\n\t\t}\n\n\t\tstrcpy(outfile, outName ? outName : gf_url_get_resource_name(inName) );\n\t\tsep = strrchr(outfile, '.');\n\t\tif (sep) sep[0] = 0;\n\t\tif (!outName) strcat(outfile, \"_dash\");\n\t\tstrcpy(szMPD, outfile);\n\t\tif (outName && sep) {\n\t\t\tsep[0] = '.';\n\t\t\tstrcat(szMPD, sep);\n\t\t} else {\n\t\t\tstrcat(szMPD, \".mpd\");\n\t\t}\n\t\t\n\t\tif ((dash_subduration>0) && (dash_duration > dash_subduration)) {\n\t\t\tfprintf(stderr, \"Warning: -subdur parameter (%g s) should be greater than segment duration (%g s), using segment duration instead\\n\", dash_subduration, dash_duration);\n\t\t\tdash_subduration = dash_duration;\n\t\t}\n\n\t\tif (dash_mode && dash_live)\n\t\t\tfprintf(stderr, \"Live DASH-ing - press 'q' to quit, 's' to save context and quit\\n\");\n\n\t\tif (!dash_ctx_file && dash_live) {\n\t\t\tu32 r1;\n\t\t\tu64 add = (u64) (intptr_t) &dasher;\n\t\t\tadd ^= gf_net_get_utc();\n\t\t\tr1 = (u32) add ^ (u32) (add/0xFFFFFFFF);\n\t\t\tr1 ^= gf_rand();\n \t\t\tsprintf(szStateFile, \"%s/dasher_%X.xml\", gf_get_default_cache_directory(), r1 );\n\t\t\tdash_ctx_file = szStateFile;\n\t\t\tdyn_state_file = GF_TRUE;\n\t\t} else if (dash_ctx_file) {\n\t\t\tif (force_new)\n\t\t\t\tgf_file_delete(dash_ctx_file);\n\t\t}\n\n\t\tif (dash_profile==GF_DASH_PROFILE_AUTO)\n\t\t\tdash_profile = dash_mode ? GF_DASH_PROFILE_LIVE : GF_DASH_PROFILE_FULL;\n\n\t\tif (!dash_mode) {\n\t\t\ttime_shift_depth = 0;\n\t\t\tmpd_update_time = 0;\n\t\t} else if ((dash_profile>=GF_DASH_PROFILE_MAIN) && !use_url_template && !mpd_update_time) {\n\t\t\t/*use a default MPD update of dash_duration sec*/\n\t\t\tmpd_update_time = (Double) (dash_subduration ? dash_subduration : dash_duration);\n\t\t\tfprintf(stderr, \"Using default MPD refresh of %g seconds\\n\", mpd_update_time);\n\t\t}\n\n\t\tif (file && needSave) {\n\t\t\tgf_isom_close(file);\n\t\t\tfile = NULL;\n\t\t\tdel_file = GF_TRUE;\n\t\t}\n\n\t\t/*setup dash*/\n\t\tdasher = gf_dasher_new(szMPD, dash_profile, tmpdir, dash_scale, dash_ctx_file);\n\t\tif (!dasher) {\n\t\t\treturn mp4box_cleanup(1);\n\t\t}\n\t\te = gf_dasher_set_info(dasher, dash_title, cprt, dash_more_info, dash_source, NULL);\n\t\tif (e) {\n\t\t\tfprintf(stderr, \"DASH Error: %s\\n\", gf_error_to_string(e));\n\t\t\tgf_dasher_del(dasher);\n\t\t\treturn mp4box_cleanup(1);\n\t\t}\n\n\t\tgf_dasher_set_start_date(dasher, dash_start_date);\n\t\tgf_dasher_set_location(dasher, dash_source);\n\t\tfor (i=0; i < nb_mpd_base_urls; i++) {\n\t\t\te = gf_dasher_add_base_url(dasher, mpd_base_urls[i]);\n\t\t\tif (e) {\n\t\t\t\tfprintf(stderr, \"DASH Error: %s\\n\", gf_error_to_string(e));\n\t\t\t\tgf_dasher_del(dasher);\n\t\t\t\treturn mp4box_cleanup(1);\n\t\t\t}\n\t\t}\n\n\t\tif (segment_timeline && !use_url_template) {\n\t\t\tfprintf(stderr, \"DASH Warning: using -segment-timeline with no -url-template. Forcing URL template.\\n\");\n\t\t\tuse_url_template = GF_TRUE;\n\t\t}\n\n\t\te = gf_dasher_enable_url_template(dasher, (Bool) use_url_template, seg_name, seg_ext, init_seg_ext);\n\t\tif (!e) e = gf_dasher_enable_segment_timeline(dasher, segment_timeline);\n\t\tif (!e) e = gf_dasher_enable_single_segment(dasher, single_segment);\n\t\tif (!e) e = gf_dasher_enable_single_file(dasher, single_file);\n\t\tif (!e) e = gf_dasher_set_switch_mode(dasher, bitstream_switching_mode);\n\t\tif (!e) e = gf_dasher_set_durations(dasher, dash_duration, interleaving_time, dash_subduration);\n\t\tif (!e) e = gf_dasher_enable_rap_splitting(dasher, seg_at_rap, frag_at_rap);\n\t\tif (!e) e = gf_dasher_set_segment_marker(dasher, segment_marker);\n\t\tif (!e) e = gf_dasher_enable_sidx(dasher, (subsegs_per_sidx>=0) ? 1 : 0, (u32) subsegs_per_sidx, daisy_chain_sidx, use_ssix);\n\t\tif (!e) e = gf_dasher_set_dynamic_mode(dasher, dash_mode, mpd_update_time, time_shift_depth, mpd_live_duration);\n\t\tif (!e) e = gf_dasher_set_min_buffer(dasher, min_buffer);\n\t\tif (!e) e = gf_dasher_set_ast_offset(dasher, ast_offset_ms);\n\t\tif (!e) e = gf_dasher_enable_memory_fragmenting(dasher, memory_frags);\n\t\tif (!e) e = gf_dasher_set_initial_isobmf(dasher, initial_moof_sn, initial_tfdt);\n\t\tif (!e) e = gf_dasher_configure_isobmf_default(dasher, no_fragments_defaults, pssh_mode, samplegroups_in_traf, single_traf_per_moof, tfdt_per_traf, mvex_after_traks, sdtp_in_traf);\n\t\tif (!e) e = gf_dasher_enable_utc_ref(dasher, insert_utc);\n\t\tif (!e) e = gf_dasher_enable_real_time(dasher, frag_real_time);\n\t\tif (!e) e = gf_dasher_set_content_protection_location_mode(dasher, cp_location_mode);\n\t\tif (!e) e = gf_dasher_set_profile_extension(dasher, dash_profile_extension);\n\t\tif (!e) e = gf_dasher_enable_cached_inputs(dasher, no_cache);\n\t\tif (!e) e = gf_dasher_enable_loop_inputs(dasher, ! no_loop);\n\t\tif (!e) e = gf_dasher_set_split_mode(dasher, dash_split_mode);\n\t\tif (!e) e = gf_dasher_set_hls_clock(dasher, hls_clock);\n\t\tif (!e && dash_cues) e = gf_dasher_set_cues(dasher, dash_cues, strict_cues);\n\t\tif (!e && fs_dump_flags) e = gf_dasher_print_session_info(dasher, fs_dump_flags);\n\n\t\tfor (i=0; i < nb_dash_inputs; i++) {\n\t\t\tif (!e) e = gf_dasher_add_input(dasher, &dash_inputs[i]);\n\t\t}\n\t\tif (e) {\n\t\t\tfprintf(stderr, \"DASH Setup Error: %s\\n\", gf_error_to_string(e));\n\t\t\tgf_dasher_del(dasher);\n\t\t\treturn mp4box_cleanup(1);\n\t\t}\n\n\t\tdash_cumulated_time=0;\n\n\t\twhile (1) {\n\t\t\tif (run_for && (dash_cumulated_time >= run_for)) {\n\t\t\t\tfprintf(stderr, \"Done running, computing static MPD\\n\");\n\t\t\t\tdo_abort = 3;\n\t\t\t}\n\n\t\t\tdash_prev_time=gf_sys_clock();\n\t\t\tif (do_abort>=2) {\n\t\t\t\te = gf_dasher_set_dynamic_mode(dasher, GF_DASH_DYNAMIC_LAST, 0, time_shift_depth, mpd_live_duration);\n\t\t\t}\n\n\t\t\tif (!e) e = gf_dasher_process(dasher);\n\t\t\tif (!dash_live && (e==GF_EOS) ) {\n\t\t\t\tfprintf(stderr, \"Nothing to dash, too early ...\\n\");\n\t\t\t\te = GF_OK;\n\t\t\t}\n\n\t\t\tif (do_abort)\n\t\t\t\tbreak;\n\n\t\t\t//this happens when reading file while writing them (local playback of the live session ...)\n\t\t\tif (dash_live && (e==GF_IO_ERR) ) {\n\t\t\t\tfprintf(stderr, \"Error dashing file (%s) but continuing ...\\n\", gf_error_to_string(e) );\n\t\t\t\te = GF_OK;\n\t\t\t}\n\n\t\t\tif (e) break;\n\n\t\t\tif (dash_live) {\n\t\t\t\tu64 ms_in_session=0;\n\t\t\t\tu32 slept = gf_sys_clock();\n\t\t\t\tu32 sleep_for = gf_dasher_next_update_time(dasher, &ms_in_session);\n\t\t\t\tfprintf(stderr, \"Next generation scheduled in %u ms (DASH time \"LLU\" ms)\\r\", sleep_for, ms_in_session);\n\t\t\t\tif (run_for && (ms_in_session>=run_for)) {\n\t\t\t\t\tdash_cumulated_time = 1+run_for;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\twhile (1) {\n\t\t\t\t\tif (gf_prompt_has_input()) {\n\t\t\t\t\t\tchar c = (char) gf_prompt_get_char();\n\t\t\t\t\t\tif (c=='X') {\n\t\t\t\t\t\t\tdo_abort = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (c=='q') {\n\t\t\t\t\t\t\tdo_abort = 2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (c=='s') {\n\t\t\t\t\t\t\tdo_abort = 3;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (dash_mode == GF_DASH_DYNAMIC_DEBUG) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (!sleep_for) break;\n\n\t\t\t\t\tgf_sleep(sleep_for/10);\n\t\t\t\t\tsleep_for = gf_dasher_next_update_time(dasher, NULL);\n\t\t\t\t\tif (sleep_for<=1) {\n\t\t\t\t\t\tdash_now_time=gf_sys_clock();\n\t\t\t\t\t\tdash_cumulated_time+=(dash_now_time-dash_prev_time);\n\t\t\t\t\t\tfprintf(stderr, \"Slept for %d ms before generation, dash cumulated time %d\\n\", dash_now_time - slept, dash_cumulated_time);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tgf_dasher_del(dasher);\n\n\t\tif (!run_for && dash_ctx_file && (do_abort==3) && (dyn_state_file) && !gf_sys_is_test_mode() ) {\n\t\t\tchar szName[1024];\n\t\t\tfprintf(stderr, \"Enter file name to save dash context:\\n\");\n\t\t\tif (scanf(\"%1023s\", szName) == 1) {\n\t\t\t\tgf_file_move(dash_ctx_file, szName);\n\t\t\t}\n\t\t}\n\t\tif (e) fprintf(stderr, \"Error DASHing file: %s\\n\", gf_error_to_string(e));\n\t\tif (file) gf_isom_delete(file);\n\t\tif (del_file)\n\t\t\tgf_file_delete(inName);\n\n\t\tif (e) return mp4box_cleanup(1);\n\t\tgoto exit;\n\t}\n\n\telse if (!file && !do_hash\n#ifndef GPAC_DISABLE_MEDIA_EXPORT\n\t         && !(track_dump_type & GF_EXPORT_AVI_NATIVE)\n#endif\n\t        ) {\n\t\tFILE *st = gf_fopen(inName, \"rb\");\n\t\tBool file_exists = 0;\n\t\tGF_ISOOpenMode omode;\n\t\tif (st) {\n\t\t\tfile_exists = 1;\n\t\t\tgf_fclose(st);\n\t\t}\n\t\tswitch (get_file_type_by_ext(inName)) {\n\t\tcase 1:\n\t\t\tomode =  (u8) (force_new ? GF_ISOM_WRITE_EDIT : (open_edit ? GF_ISOM_OPEN_EDIT : ( ((dump_isom>0) || print_info) ? GF_ISOM_OPEN_READ_DUMP : GF_ISOM_OPEN_READ) ) );\n\n\t\t\tif (crypt) {\n\t\t\t\t//keep fragment signaling in moov\n\t\t\t\tomode = GF_ISOM_OPEN_READ;\n\t\t\t\tif (use_init_seg)\n\t\t\t\t\tfile = gf_isom_open(use_init_seg, GF_ISOM_OPEN_READ, tmpdir);\n\t\t\t}\n\t\t\tif (!crypt && use_init_seg) {\n\t\t\t\tfile = gf_isom_open(use_init_seg, GF_ISOM_OPEN_READ_DUMP, tmpdir);\n\t\t\t\tif (file) {\n\t\t\t\t\te = gf_isom_open_segment(file, inName, 0, 0, 0);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tfprintf(stderr, \"Error opening segment %s: %s\\n\", inName, gf_error_to_string(e) );\n\t\t\t\t\t\tgf_isom_delete(file);\n\t\t\t\t\t\tfile = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!file)\n\t\t\t\tfile = gf_isom_open(inName, omode, tmpdir);\n\n\t\t\tif (!file && (gf_isom_last_error(NULL) == GF_ISOM_INCOMPLETE_FILE) && !open_edit) {\n\t\t\t\tu64 missing_bytes;\n\t\t\t\te = gf_isom_open_progressive(inName, 0, 0, GF_FALSE, &file, &missing_bytes);\n\t\t\t\tfprintf(stderr, \"Truncated file - missing \"LLD\" bytes\\n\", missing_bytes);\n\t\t\t}\n\n\t\t\tif (!file) {\n\t\t\t\tif (open_edit && nb_meta_act) {\n\t\t\t\t\tfile = gf_isom_open(inName, GF_ISOM_WRITE_EDIT, tmpdir);\n\t\t\t\t\tif (!outName && file) outName = inName;\n\t\t\t\t}\n\n\t\t\t\tif (!file) {\n\t\t\t\t\tfprintf(stderr, \"Error opening file %s: %s\\n\", inName, gf_error_to_string(gf_isom_last_error(NULL)));\n\t\t\t\t\treturn mp4box_cleanup(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (freeze_box_order)\n\t\t\t\tgf_isom_freeze_order(file);\n\t\t\tbreak;\n\t\t/*allowed for bt<->xmt*/\n\t\tcase 2:\n\t\tcase 3:\n\t\t/*allowed for svg->lsr**/\n\t\tcase 4:\n\t\t/*allowed for swf->bt, swf->xmt, swf->svg*/\n\t\tcase 5:\n\t\t\tbreak;\n\t\t/*used for .saf / .lsr dump*/\n\t\tcase 6:\n#ifndef GPAC_DISABLE_SCENE_DUMP\n\t\t\tif ((dump_mode==GF_SM_DUMP_LASER) || (dump_mode==GF_SM_DUMP_SVG)) {\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\n\t\tdefault:\n\t\t\tif (!open_edit && file_exists && !gf_isom_probe_file(inName) && track_dump_type) {\n\t\t\t}\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t\t\telse if (!open_edit && file_exists /* && !gf_isom_probe_file(inName) */\n#ifndef GPAC_DISABLE_SCENE_DUMP\n\t\t\t         && dump_mode == GF_SM_DUMP_NONE\n#endif //GPAC_DISABLE_SCENE_DUMP\n\t\t\t        ) {\n\t\t\t\t/*************************************************************************************************/\n#ifndef GPAC_DISABLE_MEDIA_IMPORT\n\t\t\t\tif(dvbhdemux)\n\t\t\t\t{\n\t\t\t\t\tGF_MediaImporter import;\n\t\t\t\t\tfile = gf_isom_open(\"ttxt_convert\", GF_ISOM_OPEN_WRITE, NULL);\n\t\t\t\t\tmemset(&import, 0, sizeof(GF_MediaImporter));\n\t\t\t\t\timport.dest = file;\n\t\t\t\t\timport.in_name = inName;\n\t\t\t\t\timport.flags = GF_IMPORT_MPE_DEMUX;\n\t\t\t\t\te = gf_media_import(&import);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tfprintf(stderr, \"Error importing %s: %s\\n\", inName, gf_error_to_string(e));\n\t\t\t\t\t\tgf_isom_delete(file);\n\t\t\t\t\t\tgf_file_delete(\"ttxt_convert\");\n\t\t\t\t\t\treturn mp4box_cleanup(1);\n\t\t\t\t\t}\n\t\t\t\t}\n#endif /*GPAC_DISABLE_MEDIA_IMPORT*/\n\n\t\t\t\tif (dump_m2ts) {\n#ifndef GPAC_DISABLE_MPEG2TS\n\t\t\t\t\tdump_mpeg2_ts(inName, pes_dump, program_number);\n#endif\n\t\t\t\t} else if (dump_timestamps) {\n#ifndef GPAC_DISABLE_MPEG2TS\n\t\t\t\t\tdump_mpeg2_ts(inName, pes_dump, program_number);\n#endif\n#ifndef GPAC_DISABLE_CORE_TOOLS\n\t\t\t\t} else if (do_bin_xml) {\n\t\t\t\t\txml_bs_to_bin(inName, outName, dump_std);\n#endif\n\t\t\t\t} else if (do_hash) {\n\t\t\t\t\thash_file(inName, dump_std);\n\t\t\t\t} else if (print_info) {\n#ifndef GPAC_DISABLE_MEDIA_IMPORT\n\t\t\t\t\tconvert_file_info(inName, info_track_id);\n#endif\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"Input %s is not an MP4 file, operation not allowed\\n\", inName);\n\t\t\t\t\treturn mp4box_cleanup(1);\n\t\t\t\t}\n\t\t\t\tgoto exit;\n\t\t\t}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\t\t\telse if (open_edit) {\n\t\t\t\tfile = gf_isom_open(inName, GF_ISOM_WRITE_EDIT, tmpdir);\n\t\t\t\tif (!outName && file) outName = inName;\n\t\t\t} else if (!file_exists) {\n\t\t\t\tfprintf(stderr, \"Error creating file %s: %s\\n\", inName, gf_error_to_string(GF_URL_ERROR));\n\t\t\t\treturn mp4box_cleanup(1);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"Cannot open %s - extension not supported\\n\", inName);\n\t\t\t\treturn mp4box_cleanup(1);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (high_dynamc_range_filename) {\n\t\te = parse_high_dynamc_range_xml_desc(file, high_dynamc_range_filename);\n\t\tif (e) goto err_exit;\n\t}\n\n\tif (file && keep_utc && open_edit) {\n\t\tgf_isom_keep_utc_times(file, 1);\n\t}\n\n\tstrcpy(outfile, outName ? outName : inName);\n\t{\n\n\t\tchar *szExt = gf_file_ext_start(outfile);\n\n\t\tif (szExt)\n\t\t{\n\t\t\t/*turn on 3GP saving*/\n\t\t\tif (!stricmp(szExt, \".3gp\") || !stricmp(szExt, \".3gpp\") || !stricmp(szExt, \".3g2\"))\n\t\t\t\tconv_type = GF_ISOM_CONV_TYPE_3GPP;\n\t\t\telse if (!stricmp(szExt, \".m4a\") || !stricmp(szExt, \".m4v\"))\n\t\t\t\tconv_type = GF_ISOM_CONV_TYPE_IPOD;\n\t\t\telse if (!stricmp(szExt, \".psp\"))\n\t\t\t\tconv_type = GF_ISOM_CONV_TYPE_PSP;\n\t\t\telse if (!stricmp(szExt, \".mov\") || !stricmp(szExt, \".qt\"))\n\t\t\t\tconv_type = GF_ISOM_CONV_TYPE_MOV;\n\n\t\t\t//remove extension from outfile\n\t\t\t*szExt = 0;\n\t\t}\n\t}\n\n#ifndef GPAC_DISABLE_MEDIA_EXPORT\n\tif (track_dump_type & GF_EXPORT_AVI_NATIVE) {\n\t\tchar szFile[GF_MAX_PATH+24];\n\t\tGF_MediaExporter mdump;\n\t\tmemset(&mdump, 0, sizeof(mdump));\n\t\tmdump.in_name = inName;\n\t\tmdump.flags = GF_EXPORT_AVI_NATIVE;\n\t\tmdump.trackID = trackID;\n\t\tif (dump_std) {\n\t\t\tmdump.out_name = \"std\";\n\t\t} else if (outName) {\n\t\t\tmdump.out_name = outName;\n\t\t} else if (trackID>2) {\n\t\t\tsprintf(szFile, \"%s_audio%d\", outfile, trackID-1);\n\t\t\tmdump.out_name = szFile;\n\t\t} else {\n\t\t\tsprintf(szFile, \"%s_%s\", outfile, (trackID==1) ? \"video\" : \"audio\");\n\t\t\tmdump.out_name = szFile;\n\t\t}\n\n\t\tmdump.print_stats_graph = fs_dump_flags;\n\t\te = gf_media_export(&mdump);\n\t\tif (e) goto err_exit;\n\t\tgoto exit;\n\t}\n\tif (!open_edit && track_dump_type && !gf_isom_probe_file(inName)) {\n\t\tGF_MediaExporter mdump;\n\t\tchar szFile[GF_MAX_PATH+24];\n\t\tfor (i=0; i<nb_track_act; i++) {\n\t\t\tTrackAction *tka = &tracks[i];\n\t\t\tif (tka->act_type != TRAC_ACTION_RAW_EXTRACT) continue;\n\t\t\tmemset(&mdump, 0, sizeof(mdump));\n\t\t\tmdump.in_name = inName;\n\t\t\tmdump.flags = tka->dump_type;\n\t\t\tmdump.trackID = tka->trackID;\n\t\t\tmdump.sample_num = tka->sample_num;\n\t\t\tif (outName) {\n\t\t\t\tmdump.out_name = outName;\n\t\t\t\tmdump.flags |= GF_EXPORT_MERGE;\n\t\t\t} else if (nb_track_act>1) {\n\t\t\t\tsprintf(szFile, \"%s_track%d\", outfile, mdump.trackID);\n\t\t\t\tmdump.out_name = szFile;\n\t\t\t} else {\n\t\t\t\tmdump.out_name = outfile;\n\t\t\t}\n\t\t\tmdump.print_stats_graph = fs_dump_flags;\n\t\t\te = gf_media_export(&mdump);\n\t\t\tif (e) goto err_exit;\n\t\t}\n\t\tgoto exit;\n\t}\n\n#endif /*GPAC_DISABLE_MEDIA_EXPORT*/\n\n#ifndef GPAC_DISABLE_SCENE_DUMP\n\tif (dump_mode != GF_SM_DUMP_NONE) {\n\t\te = dump_isom_scene(inName, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE, dump_mode, do_scene_log, no_odf_conf);\n\t\tif (e) goto err_exit;\n\t}\n#endif\n\n#ifndef GPAC_DISABLE_SCENE_STATS\n\tif (stat_level) dump_isom_scene_stats(inName, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE, stat_level);\n#endif\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\tif (!HintIt && print_sdp) dump_isom_sdp(file, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE);\n#endif\n\tif (get_nb_tracks) {\n\t\tfprintf(stdout, \"%d\\n\", gf_isom_get_track_count(file));\n\t}\n\tif (print_info) {\n\t\tif (!file) {\n\t\t\tfprintf(stderr, \"Cannot print info on a non ISOM file (%s)\\n\", inName);\n\t\t} else {\n\t\t\tif (info_track_id) DumpTrackInfo(file, info_track_id, 1, (print_info==2) ? GF_TRUE : GF_FALSE);\n\t\t\telse DumpMovieInfo(file);\n\t\t}\n\t}\n#ifndef GPAC_DISABLE_ISOM_DUMP\n\tif (dump_isom) {\n\t\te = dump_isom_xml(file, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE, (dump_isom==2) ? GF_TRUE : GF_FALSE, merge_vtt_cues, use_init_seg ? GF_TRUE : GF_FALSE, (dump_isom==3) ? GF_TRUE : GF_FALSE);\n\t\tif (e) goto err_exit;\n\t}\n\tif (dump_cr) dump_isom_ismacryp(file, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE);\n\tif ((dump_ttxt || dump_srt) && trackID) {\n\n\t\tif (trackID == (u32)-1) {\n\t\t\tfor (j=0; j<gf_isom_get_track_count(file); j++) {\n\t\t\t\ttrackID = gf_isom_get_track_id(file, j+1);\n\t\t\t\tdump_isom_timed_text(file, trackID, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE,\n\t\t\t\t\t\t\t\t\tGF_FALSE, dump_srt ? GF_TEXTDUMPTYPE_SRT : GF_TEXTDUMPTYPE_TTXT);\n\t\t\t}\n\n\t\t}\n\t\telse {\n\t\t\tdump_isom_timed_text(file, trackID, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE,\n\t\t\t\t\t\t\t\tGF_FALSE, dump_srt ? GF_TEXTDUMPTYPE_SRT : GF_TEXTDUMPTYPE_TTXT);\n\t\t}\n\t}\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\tif (dump_rtp) dump_isom_rtp(file, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE);\n#endif\n\n#endif\n\n\tif (dump_timestamps) dump_isom_timestamps(file, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE, dump_timestamps);\n\tif (dump_nal) dump_isom_nal(file, dump_nal, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE, dump_nal_type);\n\tif (dump_saps) dump_isom_saps(file, dump_saps, dump_saps_mode, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE);\n\n\tif (do_hash) {\n\t\te = hash_file(inName, dump_std);\n\t\tif (e) goto err_exit;\n\t}\n#ifndef GPAC_DISABLE_CORE_TOOLS\n\tif (do_bin_xml) {\n\t\te = xml_bs_to_bin(inName, outName, dump_std);\n\t\tif (e) goto err_exit;\n\t}\n#endif\n\n\tif (dump_cart) dump_isom_cover_art(file, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE);\n\tif (dump_chap) dump_isom_chapters(file, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE, dump_chap);\n\tif (dump_udta_type) dump_isom_udta(file, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE, dump_udta_type, dump_udta_track);\n\n\tif (dump_iod) {\n\t\tGF_InitialObjectDescriptor *iod = (GF_InitialObjectDescriptor *)gf_isom_get_root_od(file);\n\t\tif (!iod) {\n\t\t\tfprintf(stderr, \"File %s has no IOD\\n\", inName);\n\t\t} else {\n\t\t\tchar szName[GF_MAX_PATH+10];\n\t\t\tFILE *iodf;\n\t\t\tsprintf(szName, \"%s.iod\", outfile);\n\t\t\tiodf = gf_fopen(szName, \"wb\");\n\t\t\tif (!iodf) {\n\t\t\t\tfprintf(stderr, \"Cannot open destination %s\\n\", szName);\n\t\t\t} else {\n\t\t\t\tu8 *desc;\n\t\t\t\tu32 size;\n\t\t\t\tGF_BitStream *bs = gf_bs_from_file(iodf, GF_BITSTREAM_WRITE);\n\t\t\t\tif (gf_odf_desc_write((GF_Descriptor *)iod, &desc, &size)==GF_OK) {\n\t\t\t\t\tgf_fwrite(desc, size, iodf);\n\t\t\t\t\tgf_free(desc);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"Error writing IOD %s\\n\", szName);\n\t\t\t\t}\n\t\t\t\tgf_fclose(iodf);\n\t\t\t\tgf_bs_del(bs);\n\t\t\t}\n\t\t\tgf_odf_desc_del((GF_Descriptor*)iod);\n\t\t}\n\t}\n\n#if !defined(GPAC_DISABLE_ISOM_WRITE) && !defined(GPAC_DISABLE_MEDIA_IMPORT)\n\tif (split_duration || split_size || split_range_str) {\n\t\tsplit_isomedia_file(file, split_duration, split_size, inName, interleaving_time, split_start, adjust_split_end, outName, tmpdir, seg_at_rap, split_range_str);\n\t\t/*never save file when splitting is desired*/\n\t\topen_edit = GF_FALSE;\n\t\tneedSave = GF_FALSE;\n\t}\n#endif // !defined(GPAC_DISABLE_ISOM_WRITE) && !defined(GPAC_DISABLE_MEDIA_IMPORT)\n\n#ifndef GPAC_DISABLE_MEDIA_EXPORT\n\tif (track_dump_type) {\n\t\tchar szFile[GF_MAX_PATH+24];\n\t\tGF_MediaExporter mdump;\n\t\tfor (i=0; i<nb_track_act; i++) {\n\t\t\tTrackAction *tka = &tracks[i];\n\t\t\tif (tka->act_type != TRAC_ACTION_RAW_EXTRACT) continue;\n\t\t\tmemset(&mdump, 0, sizeof(mdump));\n\t\t\tmdump.file = file;\n\t\t\tmdump.flags = tka->dump_type;\n\t\t\tmdump.trackID = tka->trackID;\n\t\t\tmdump.sample_num = tka->sample_num;\n\t\t\tif (tka->out_name) {\n\t\t\t\tmdump.out_name = tka->out_name;\n\t\t\t} else if (outName) {\n\t\t\t\tmdump.out_name = outName;\n\t\t\t\tmdump.flags |= GF_EXPORT_MERGE;\n\t\t\t\t/*don't infer extension on user-given filename*/\n\t\t\t\tmdump.flags |= GF_EXPORT_NO_FILE_EXT;\n\t\t\t} else if (mdump.trackID) {\n\t\t\t\tsprintf(szFile, \"%s_track%d\", outfile, mdump.trackID);\n\t\t\t\tmdump.out_name = szFile;\n\t\t\t} else {\n\t\t\t\tsprintf(szFile, \"%s_export\", outfile);\n\t\t\t\tmdump.out_name = szFile;\n\t\t\t}\n\t\t\tif (tka->trackID==(u32) -1) {\n\t\t\t\tfor (j=0; j<gf_isom_get_track_count(file); j++) {\n\t\t\t\t\tmdump.trackID = gf_isom_get_track_id(file, j+1);\n\t\t\t\t\tsprintf(szFile, \"%s_track%d\", outfile, mdump.trackID);\n\t\t\t\t\tmdump.out_name = szFile;\n\t\t\t\t\tmdump.print_stats_graph = fs_dump_flags;\n\t\t\t\t\te = gf_media_export(&mdump);\n\t\t\t\t\tif (e) goto err_exit;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmdump.print_stats_graph = fs_dump_flags;\n\t\t\t\te = gf_media_export(&mdump);\n\t\t\t\tif (e) goto err_exit;\n\t\t\t}\n\t\t}\n\t} else if (do_saf) {\n\t\tGF_MediaExporter mdump;\n\t\tmemset(&mdump, 0, sizeof(mdump));\n\t\tmdump.file = file;\n\t\tmdump.flags = GF_EXPORT_SAF;\n\t\tmdump.out_name = outfile;\n\t\tmdump.print_stats_graph = fs_dump_flags;\n\t\te = gf_media_export(&mdump);\n\t\tif (e) goto err_exit;\n\t}\n#endif\n\n\tfor (i=0; i<nb_meta_act; i++) {\n\t\tu32 tk = 0;\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t\tBool self_ref;\n#endif\n\t\tMetaAction *meta = &metas[i];\n\n\t\tif (meta->trackID) tk = gf_isom_get_track_by_id(file, meta->trackID);\n\n\t\tswitch (meta->act_type) {\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t\tcase META_ACTION_SET_TYPE:\n\t\t\t/*note: we don't handle file brand modification, this is an author stuff and cannot be guessed from meta type*/\n\t\t\te = gf_isom_set_meta_type(file, meta->root_meta, tk, meta->meta_4cc);\n\t\t\tgf_isom_modify_alternate_brand(file, GF_ISOM_BRAND_ISO2, GF_TRUE);\n\t\t\tneedSave = GF_TRUE;\n\t\t\tbreak;\n\t\tcase META_ACTION_ADD_ITEM:\n\t\t\tself_ref = !stricmp(meta->szPath, \"NULL\") || !stricmp(meta->szPath, \"this\") || !stricmp(meta->szPath, \"self\");\n\t\t\te = gf_isom_add_meta_item(file, meta->root_meta, tk, self_ref, self_ref ? NULL : meta->szPath,\n\t\t\t                          meta->szName,\n\t\t\t                          meta->item_id,\n\t\t\t\t\t\t\t\t\t  meta->item_type,\n\t\t\t                          meta->mime_type,\n\t\t\t                          meta->enc_type,\n\t\t\t                          meta->use_dref ? meta->szPath : NULL,  NULL,\n\t\t\t                          meta->image_props);\n\t\t\tif (meta->ref_type) {\n\t\t\t\te = gf_isom_meta_add_item_ref(file, meta->root_meta, tk, meta->item_id, meta->ref_item_id, meta->ref_type, NULL);\n\t\t\t}\n\t\t\tneedSave = GF_TRUE;\n\t\t\tbreak;\n\t\tcase META_ACTION_ADD_IMAGE_ITEM:\n\t\t{\n\t\t\tu32 old_tk_count = gf_isom_get_track_count(file);\n\t\t\tGF_Fraction _frac = {0,0};\n\t\t\te = import_file(file, meta->szPath, 0, _frac, 0, NULL, NULL, 0);\n\t\t\tif (e == GF_OK) {\n\t\t\t\tu32 meta_type = gf_isom_get_meta_type(file, meta->root_meta, tk);\n\t\t\t\tif (!meta_type) {\n\t\t\t\t\te = gf_isom_set_meta_type(file, meta->root_meta, tk, GF_META_ITEM_TYPE_PICT);\n\t\t\t\t} else {\n\t\t\t\t\tif (meta_type != GF_META_ITEM_TYPE_PICT) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Warning: file already has a root 'meta' box of type %s\\n\", gf_4cc_to_str(meta_type)));\n\t\t\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (e == GF_OK) {\n\t\t\t\t\tif (!meta->item_id) {\n\t\t\t\t\t\te = gf_isom_meta_get_next_item_id(file, meta->root_meta, tk, &meta->item_id);\n\t\t\t\t\t}\n\t\t\t\t\tif (e == GF_OK) {\n\t\t\t\t\t\te = gf_isom_iff_create_image_item_from_track(file, meta->root_meta, tk, 1,\n\t\t\t\t\t\t\t\tmeta->szName,\n\t\t\t\t\t\t\t\tmeta->item_id,\n\t\t\t\t\t\t\t\tmeta->image_props, NULL);\n\t\t\t\t\t\tif (e == GF_OK && meta->primary) {\n\t\t\t\t\t\t\te = gf_isom_set_meta_primary_item(file, meta->root_meta, tk, meta->item_id);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (e == GF_OK && meta->ref_type) {\n\t\t\t\t\t\t\te = gf_isom_meta_add_item_ref(file, meta->root_meta, tk, meta->item_id, meta->ref_item_id, meta->ref_type, NULL);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_isom_remove_track(file, old_tk_count+1);\n\t\t\tneedSave = GF_TRUE;\n\t\t}\n\t\t\tbreak;\n\t\tcase META_ACTION_REM_ITEM:\n\t\t\te = gf_isom_remove_meta_item(file, meta->root_meta, tk, meta->item_id);\n\t\t\tneedSave = GF_TRUE;\n\t\t\tbreak;\n\t\tcase META_ACTION_SET_PRIMARY_ITEM:\n\t\t\te = gf_isom_set_meta_primary_item(file, meta->root_meta, tk, meta->item_id);\n\t\t\tneedSave = GF_TRUE;\n\t\t\tbreak;\n\t\tcase META_ACTION_SET_XML:\n\t\tcase META_ACTION_SET_BINARY_XML:\n\t\t\te = gf_isom_set_meta_xml(file, meta->root_meta, tk, meta->szPath, NULL, 0, (meta->act_type==META_ACTION_SET_BINARY_XML) ? 1 : 0);\n\t\t\tneedSave = GF_TRUE;\n\t\t\tbreak;\n\t\tcase META_ACTION_REM_XML:\n\t\t\tif (gf_isom_get_meta_item_count(file, meta->root_meta, tk)) {\n\t\t\t\te = gf_isom_remove_meta_xml(file, meta->root_meta, tk);\n\t\t\t\tneedSave = GF_TRUE;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"No meta box in input file\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase META_ACTION_DUMP_ITEM:\n\t\t\tif (gf_isom_get_meta_item_count(file, meta->root_meta, tk)) {\n\t\t\t\te = gf_isom_extract_meta_item(file, meta->root_meta, tk, meta->item_id, strlen(meta->szPath) ? meta->szPath : NULL);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"No meta box in input file\\n\");\n\t\t\t}\n\t\t\tbreak;\n#endif // GPAC_DISABLE_ISOM_WRITE\n\n\t\tcase META_ACTION_DUMP_XML:\n\t\t\tif (gf_isom_has_meta_xml(file, meta->root_meta, tk)) {\n\t\t\t\te = gf_isom_extract_meta_xml(file, meta->root_meta, tk, meta->szPath, NULL);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"No meta box in input file\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (meta->image_props) {\n\t\t\tgf_free(meta->image_props);\n\t\t\tmeta->image_props = NULL;\n\t\t}\n\t\tif (e) goto err_exit;\n\t}\n\tif (!open_edit && !needSave) {\n\t\tif (file) gf_isom_delete(file);\n\t\tgoto exit;\n\t}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tif (clean_groups) {\n\t\te = gf_isom_reset_switch_parameters(file);\n\t\tif (e) goto err_exit;\n\t\tneedSave = GF_TRUE;\n\t}\n\n\tfor (i=0; i<nb_tsel_acts; i++) {\n\t\tswitch (tsel_acts[i].act_type) {\n\t\tcase TSEL_ACTION_SET_PARAM:\n\t\t\te = gf_isom_set_track_switch_parameter(file,\n\t\t\t                                       gf_isom_get_track_by_id(file, tsel_acts[i].trackID),\n\t\t\t                                       tsel_acts[i].refTrackID ? gf_isom_get_track_by_id(file, tsel_acts[i].refTrackID) : 0,\n\t\t\t                                       tsel_acts[i].is_switchGroup ? 1 : 0,\n\t\t\t                                       &tsel_acts[i].switchGroupID,\n\t\t\t                                       tsel_acts[i].criteria, tsel_acts[i].nb_criteria);\n\t\t\tif (e == GF_BAD_PARAM) {\n\t\t\t\tu32 alternateGroupID, nb_groups;\n\t\t\t\tgf_isom_get_track_switch_group_count(file, gf_isom_get_track_by_id(file, tsel_acts[i].trackID), &alternateGroupID, &nb_groups);\n\t\t\t\tif (alternateGroupID)\n\t\t\t\t\tfprintf(stderr, \"Hint: for adding more tracks to group, using: -group-add -refTrack=ID1:[criteria:]trackID=ID2\\n\");\n\t\t\t\telse\n\t\t\t\t\tfprintf(stderr, \"Hint: for creates a new grouping information, using -group-add -trackID=ID1:[criteria:]trackID=ID2\\n\");\n\t\t\t}\n\t\t\tif (e) goto err_exit;\n\t\t\tneedSave = GF_TRUE;\n\t\t\tbreak;\n\t\tcase TSEL_ACTION_REMOVE_TSEL:\n\t\t\te = gf_isom_reset_track_switch_parameter(file, gf_isom_get_track_by_id(file, tsel_acts[i].trackID), 0);\n\t\t\tif (e) goto err_exit;\n\t\t\tneedSave = GF_TRUE;\n\t\t\tbreak;\n\t\tcase TSEL_ACTION_REMOVE_ALL_TSEL_IN_GROUP:\n\t\t\te = gf_isom_reset_track_switch_parameter(file, gf_isom_get_track_by_id(file, tsel_acts[i].trackID), 1);\n\t\t\tif (e) goto err_exit;\n\t\t\tneedSave = GF_TRUE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (remove_sys_tracks) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tremove_systems_tracks(file);\n#endif\n\t\tneedSave = GF_TRUE;\n\t\tif (conv_type < GF_ISOM_CONV_TYPE_ISMA_EX) conv_type = 0;\n\t}\n\tif (remove_root_od) {\n\t\tgf_isom_remove_root_od(file);\n\t\tneedSave = GF_TRUE;\n\t}\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\tif (remove_hint) {\n\t\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\t\tif (gf_isom_get_media_type(file, i+1) == GF_ISOM_MEDIA_HINT) {\n\t\t\t\tfprintf(stderr, \"Removing hint track ID %d\\n\", gf_isom_get_track_id(file, i+1));\n\t\t\t\tgf_isom_remove_track(file, i+1);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t\tgf_isom_sdp_clean(file);\n\t\tneedSave = GF_TRUE;\n\t}\n#endif // GPAC_DISABLE_ISOM_HINTING\n\n\tif (timescale && (timescale != gf_isom_get_timescale(file))) {\n\t\tgf_isom_set_timescale(file, timescale);\n\t\tneedSave = GF_TRUE;\n\t}\n\n\tif (!encode) {\n\t\tif (!file) {\n\t\t\tfprintf(stderr, \"Nothing to do - exiting\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t\tif (outName) {\n\t\t\tstrcpy(outfile, outName);\n\t\t} else {\n\t\t\tchar *rel_name = strrchr(inName, GF_PATH_SEPARATOR);\n\t\t\tif (!rel_name) rel_name = strrchr(inName, '/');\n\n\t\t\tstrcpy(outfile, \"\");\n\t\t\tif (tmpdir) {\n\t\t\t\tstrcpy(outfile, tmpdir);\n\t\t\t\tif (!strchr(\"\\\\/\", tmpdir[strlen(tmpdir)-1])) strcat(outfile, \"/\");\n\t\t\t}\n\t\t\tif (!pack_file) strcat(outfile, \"out_\");\n\t\t\tstrcat(outfile, rel_name ? rel_name + 1 : inName);\n\n\t\t\tif (pack_file) {\n\t\t\t\tstrcpy(outfile, rel_name ? rel_name + 1 : inName);\n\t\t\t\trel_name = strrchr(outfile, '.');\n\t\t\t\tif (rel_name) rel_name[0] = 0;\n\t\t\t\tstrcat(outfile, \".m21\");\n\t\t\t}\n\t\t}\n#ifndef GPAC_DISABLE_MEDIA_IMPORT\n\t\tif ((conv_type == GF_ISOM_CONV_TYPE_ISMA) || (conv_type == GF_ISOM_CONV_TYPE_ISMA_EX)) {\n\t\t\tfprintf(stderr, \"Converting to ISMA Audio-Video MP4 file...\\n\");\n\t\t\t/*keep ESIDs when doing ISMACryp*/\n\t\t\te = gf_media_make_isma(file, crypt ? 1 : 0, GF_FALSE, (conv_type==GF_ISOM_CONV_TYPE_ISMA_EX) ? 1 : 0);\n\t\t\tif (e) goto err_exit;\n\t\t\tneedSave = GF_TRUE;\n\t\t}\n\t\tif (conv_type == GF_ISOM_CONV_TYPE_3GPP) {\n\t\t\tfprintf(stderr, \"Converting to 3GP file...\\n\");\n\t\t\te = gf_media_make_3gpp(file);\n\t\t\tif (e) goto err_exit;\n\t\t\tneedSave = GF_TRUE;\n\t\t}\n\t\tif (conv_type == GF_ISOM_CONV_TYPE_PSP) {\n\t\t\tfprintf(stderr, \"Converting to PSP file...\\n\");\n\t\t\te = gf_media_make_psp(file);\n\t\t\tif (e) goto err_exit;\n\t\t\tneedSave = GF_TRUE;\n\t\t}\n\t\tif (conv_type == GF_ISOM_CONV_TYPE_MOV) {\n\t\t\te = gf_media_check_qt_prores(file);\n\t\t\tif (e) goto err_exit;\n\t\t\tneedSave = GF_TRUE;\n\t\t\tif (interleaving_time) interleaving_time = 0.5;\n\t\t}\n#endif /*GPAC_DISABLE_MEDIA_IMPORT*/\n\t\tif (conv_type == GF_ISOM_CONV_TYPE_IPOD) {\n\t\t\tu32 ipod_major_brand = 0;\n\t\t\tfprintf(stderr, \"Setting up iTunes/iPod file...\\n\");\n\n\t\t\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\t\t\tu32 mType = gf_isom_get_media_type(file, i+1);\n\t\t\t\tswitch (mType) {\n\t\t\t\tcase GF_ISOM_MEDIA_VISUAL:\n                case GF_ISOM_MEDIA_AUXV:\n                case GF_ISOM_MEDIA_PICT:\n\t\t\t\t\tipod_major_brand = GF_ISOM_BRAND_M4V;\n\t\t\t\t\tgf_isom_set_ipod_compatible(file, i+1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\t\t\tif (!ipod_major_brand) ipod_major_brand = GF_ISOM_BRAND_M4A;\n\t\t\t\t\telse gf_isom_modify_alternate_brand(file, GF_ISOM_BRAND_M4A, GF_TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_ISOM_MEDIA_TEXT:\n\t\t\t\t\t/*this is a text track track*/\n\t\t\t\t\tif (gf_isom_get_media_subtype(file, i+1, 1) == GF_ISOM_SUBTYPE_TX3G) {\n\t\t\t\t\t\tBool is_chap = 0;\n\t\t\t\t\t\tfor (j=0; j<gf_isom_get_track_count(file); j++) {\n\t\t\t\t\t\t\ts32 count = gf_isom_get_reference_count(file, j+1, GF_ISOM_REF_CHAP);\n\t\t\t\t\t\t\tif (count>0) {\n\t\t\t\t\t\t\t\tu32 tk, k;\n\t\t\t\t\t\t\t\tfor (k=0; k<(u32) count; k++) {\n\t\t\t\t\t\t\t\t\tgf_isom_get_reference(file, j+1, GF_ISOM_REF_CHAP, k+1, &tk);\n\t\t\t\t\t\t\t\t\tif (tk==i+1) {\n\t\t\t\t\t\t\t\t\t\tis_chap = 1;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (is_chap) break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (is_chap) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/*this is a subtitle track*/\n\t\t\t\t\t\tif (!is_chap)\n\t\t\t\t\t\t\tgf_isom_set_media_type(file, i+1, GF_ISOM_MEDIA_SUBT);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_isom_set_brand_info(file, ipod_major_brand, 1);\n\t\t\tgf_isom_modify_alternate_brand(file, GF_ISOM_BRAND_MP42, GF_TRUE);\n\t\t\tneedSave = GF_TRUE;\n\t\t}\n\n\t} else if (outName) {\n\t\tstrcpy(outfile, outName);\n\t}\n\n\tfor (j=0; j<nb_track_act; j++) {\n\t\tTrackAction *tka = &tracks[j];\n\t\tu32 track = tka->trackID ? gf_isom_get_track_by_id(file, tka->trackID) : 0;\n\n\t\ttimescale = gf_isom_get_timescale(file);\n\t\tswitch (tka->act_type) {\n\t\tcase TRAC_ACTION_REM_TRACK:\n\t\t\te = gf_isom_remove_track(file, track);\n\t\t\tif (e) {\n\t\t\t\tfprintf(stderr, \"Error Removing track ID %d: %s\\n\", tka->trackID, gf_error_to_string(e));\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"Removing track ID %d\\n\", tka->trackID);\n\t\t\t}\n\t\t\tneedSave = GF_TRUE;\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_SET_LANGUAGE:\n\t\t\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\t\t\tif (track && (track != i+1)) continue;\n\t\t\t\te = gf_isom_set_media_language(file, i+1, tka->lang);\n\t\t\t\tif (e) goto err_exit;\n\t\t\t\tneedSave = GF_TRUE;\n\t\t\t}\n\t\t\tneedSave = GF_TRUE;\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_SET_KIND:\n\t\t\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\t\t\tif (track && (track != i+1)) continue;\n\t\t\t\te = gf_isom_add_track_kind(file, i+1, tka->kind_scheme, tka->kind_value);\n\t\t\t\tif (e) goto err_exit;\n\t\t\t\tneedSave = GF_TRUE;\n\t\t\t}\n\t\t\tneedSave = GF_TRUE;\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_REM_KIND:\n\t\t\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\t\t\tif (track && (track != i+1)) continue;\n\t\t\t\te = gf_isom_remove_track_kind(file, i+1, tka->kind_scheme, tka->kind_value);\n\t\t\t\tif (e) goto err_exit;\n\t\t\t\tneedSave = GF_TRUE;\n\t\t\t}\n\t\t\tneedSave = GF_TRUE;\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_SET_DELAY:\n\t\t\tif (tka->delay_ms) {\n\t\t\t\tu64 tk_dur;\n\n\t\t\t\tgf_isom_remove_edits(file, track);\n\t\t\t\ttk_dur = gf_isom_get_track_duration(file, track);\n\t\t\t\tif (gf_isom_get_edits_count(file, track))\n\t\t\t\t\tneedSave = GF_TRUE;\n\t\t\t\tif (tka->delay_ms>0) {\n\t\t\t\t\tgf_isom_append_edit(file, track, (timescale*tka->delay_ms)/1000, 0, GF_ISOM_EDIT_EMPTY);\n\t\t\t\t\tgf_isom_append_edit(file, track, tk_dur, 0, GF_ISOM_EDIT_NORMAL);\n\t\t\t\t\tneedSave = GF_TRUE;\n\t\t\t\t} else {\n\t\t\t\t\tu64 to_skip = (timescale*(-tka->delay_ms))/1000;\n\t\t\t\t\tif (to_skip<tk_dur) {\n\t\t\t\t\t\tu64 media_time = (-tka->delay_ms)*gf_isom_get_media_timescale(file, track) / 1000;\n\t\t\t\t\t\tgf_isom_append_edit(file, track, tk_dur-to_skip, media_time, GF_ISOM_EDIT_NORMAL);\n\t\t\t\t\t\tneedSave = GF_TRUE;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfprintf(stderr, \"Warning: request negative delay longer than track duration - ignoring\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (gf_isom_get_edits_count(file, track)) {\n\t\t\t\tgf_isom_remove_edits(file, track);\n\t\t\t\tneedSave = GF_TRUE;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_SET_KMS_URI:\n\t\t\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\t\t\tif (track && (track != i+1)) continue;\n\t\t\t\tif (!gf_isom_is_media_encrypted(file, i+1, 1)) continue;\n\t\t\t\tif (!gf_isom_is_ismacryp_media(file, i+1, 1)) continue;\n\t\t\t\te = gf_isom_change_ismacryp_protection(file, i+1, 1, NULL, (char *) tka->kms);\n\t\t\t\tif (e) goto err_exit;\n\t\t\t\tneedSave = GF_TRUE;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_SET_ID:\n\t\t\tif (!tka->trackID && (gf_isom_get_track_count(file) == 1)) {\n\t\t\t\tfprintf(stderr, \"Warning: track id is not specified, but file has only one track - assume that you want to change id for this track\\n\");\n\t\t\t\ttrack = 1;\n\t\t\t}\n\t\t\tif (track) {\n\t\t\t\tu32 newTrack;\n\t\t\t\tnewTrack = gf_isom_get_track_by_id(file, tka->newTrackID);\n\t\t\t\tif (newTrack != 0) {\n\t\t\t\t\tfprintf(stderr, \"Error: Cannot set track id with value %d because a track already exists - ignoring\", tka->newTrackID);\n\t\t\t\t} else {\n\t\t\t\t\te = gf_isom_set_track_id(file, track, tka->newTrackID);\n\t\t\t\t\tneedSave = GF_TRUE;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"Error: Cannot change id for track %d because it does not exist - ignoring\", tka->trackID);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_SWAP_ID:\n\t\t\tif (track) {\n\t\t\t\tu32 tk1, tk2;\n\t\t\t\ttk1 = gf_isom_get_track_by_id(file, tka->trackID);\n\t\t\t\ttk2 = gf_isom_get_track_by_id(file, tka->newTrackID);\n\t\t\t\tif (!tk1 || !tk2) {\n\t\t\t\t\tfprintf(stderr, \"Error: Cannot swap track IDs because not existing - ignoring\");\n\t\t\t\t} else {\n\t\t\t\t\te = gf_isom_set_track_id(file, tk2, 0);\n\t\t\t\t\tif (!e) e = gf_isom_set_track_id(file, tk1, tka->newTrackID);\n\t\t\t\t\tif (!e) e = gf_isom_set_track_id(file, tk2, tka->trackID);\n\t\t\t\t\tneedSave = GF_TRUE;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"Error: Cannot change id for track %d because it does not exist - ignoring\", tka->trackID);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_SET_PAR:\n\t\t\te = gf_media_change_par(file, track, tka->par_num, tka->par_den, tka->force_par, tka->rewrite_bs);\n\t\t\tneedSave = GF_TRUE;\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_SET_CLAP:\n\t\t\te = gf_isom_set_clean_aperture(file, track, 1, tka->clap_wnum, tka->clap_wden, tka->clap_hnum, tka->clap_hden, tka->clap_honum, tka->clap_hoden, tka->clap_vonum, tka->clap_voden);\n\t\t\tneedSave = GF_TRUE;\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_SET_MX:\n\t\t\te = gf_isom_set_track_matrix(file, track, tka->mx);\n\t\t\tneedSave = GF_TRUE;\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_SET_HANDLER_NAME:\n\t\t\te = gf_isom_set_handler_name(file, track, tka->hdl_name);\n\t\t\tneedSave = GF_TRUE;\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_ENABLE:\n\t\t\tif (!gf_isom_is_track_enabled(file, track)) {\n\t\t\t\te = gf_isom_set_track_enabled(file, track, GF_TRUE);\n\t\t\t\tneedSave = GF_TRUE;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_DISABLE:\n\t\t\tif (gf_isom_is_track_enabled(file, track)) {\n\t\t\t\te = gf_isom_set_track_enabled(file, track, GF_FALSE);\n\t\t\t\tneedSave = GF_TRUE;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_REFERENCE:\n\t\t\te = gf_isom_set_track_reference(file, track, GF_4CC(tka->lang[0], tka->lang[1], tka->lang[2], tka->lang[3]), (u32) tka->delay_ms);\n\t\t\tneedSave = GF_TRUE;\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_REM_NON_RAP:\n\t\t\tfprintf(stderr, \"Removing non-rap samples from track %d\\n\", tka->trackID);\n\t\t\te = gf_media_remove_non_rap(file, track, GF_FALSE);\n\t\t\tneedSave = GF_TRUE;\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_REM_NON_REFS:\n\t\t\tfprintf(stderr, \"Removing non-reference samples from track %d\\n\", tka->trackID);\n\t\t\te = gf_media_remove_non_rap(file, track, GF_TRUE);\n\t\t\tneedSave = GF_TRUE;\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_SET_UDTA:\n\t\t\tfprintf(stderr, \"Assigning udta box\\n\");\n\t\t\te = set_file_udta(file, track, tka->udta_type, tka->src_name, tka->sample_num ? GF_TRUE : GF_FALSE);\n\t\t\tif (e) goto err_exit;\n\t\t\tneedSave = GF_TRUE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (e) goto err_exit;\n\t}\n\n\tif (itunes_tags) {\n\t\tchar *tags = itunes_tags;\n\n\t\twhile (tags) {\n\t\t\tchar *val;\n\t\t\tchar *sep = gf_url_colon_suffix(tags);\n\t\t\tu32 tlen, itag = 0;\n\t\t\tif (sep) {\n\t\t\t\twhile (sep) {\n\t\t\t\t\tfor (itag=0; itag<nb_itunes_tags; itag++) {\n\t\t\t\t\t\tif (!strnicmp(sep+1, itags[itag].name, strlen(itags[itag].name))) break;\n\t\t\t\t\t}\n\t\t\t\t\tif (itag<nb_itunes_tags) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsep = gf_url_colon_suffix(sep+1);\n\t\t\t\t}\n\t\t\t\tif (sep) sep[0] = 0;\n\t\t\t}\n\t\t\tfor (itag=0; itag<nb_itunes_tags; itag++) {\n\t\t\t\tif (!strnicmp(tags, itags[itag].name, strlen(itags[itag].name))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (itag==nb_itunes_tags) {\n\t\t\t\tfprintf(stderr, \"Invalid iTune tag format \\\"%s\\\" - ignoring\\n\", tags);\n\t\t\t\ttags = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\titag = itags[itag].code;\n\n\t\t\tval = strchr(tags, '=');\n\t\t\tif (!val) {\n\t\t\t\tfprintf(stderr, \"Invalid iTune tag format \\\"%s\\\" (expecting '=') - ignoring\\n\", tags);\n\t\t\t\ttags = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tval ++;\n\t\t\tif ((val[0]==':') || !val[0] || !stricmp(val, \"NULL\") ) val = NULL;\n\n\t\t\ttlen = val ? (u32) strlen(val) : 0;\n\t\t\tswitch (itag) {\n\t\t\tcase GF_ISOM_ITUNE_COVER_ART:\n\t\t\t{\n\t\t\t\tu8 *d=NULL;\n\t\t\t\te = GF_OK;\n\t\t\t\tif (val) {\n\t\t\t\t\tchar *ext;\n\t\t\t\t\te = gf_file_load_data(val, (u8 **) &d, &tlen);\n\n\t\t\t\t\text = strrchr(val, '.');\n\t\t\t\t\tif (!stricmp(ext, \".png\")) tlen |= 0x80000000;\n\t\t\t\t}\n\t\t\t\tif (!e)\n\t\t\t\t\te = gf_isom_apple_set_tag(file, GF_ISOM_ITUNE_COVER_ART, d, tlen);\n\n\t\t\t\tif (d) gf_free(d);\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase GF_ISOM_ITUNE_TEMPO:\n\t\t\t\tgf_isom_apple_set_tag(file, itag, NULL, val ? atoi(val) : 0);\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_ITUNE_GENRE:\n\t\t\t{\n\t\t\t\tu8 _v = gf_id3_get_genre_tag(val);\n\t\t\t\tif (_v) {\n\t\t\t\t\tgf_isom_apple_set_tag(file, itag, NULL, _v);\n\t\t\t\t} else {\n\t\t\t\t\tif (!val) val=\"\";\n\t\t\t\t\tgf_isom_apple_set_tag(file, itag, (u8 *) val, (u32) strlen(val) );\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase GF_ISOM_ITUNE_DISK:\n\t\t\tcase GF_ISOM_ITUNE_TRACKNUMBER:\n\t\t\t{\n\t\t\t\tu32 n, t;\n\t\t\t\tchar _t[8];\n\t\t\t\tn = t = 0;\n\t\t\t\tif (val) {\n\t\t\t\t\tmemset(_t, 0, sizeof(char) * 8);\n\t\t\t\t\ttlen = (itag == GF_ISOM_ITUNE_DISK) ? 6 : 8;\n\t\t\t\t\tif (sscanf(val, \"%u/%u\", &n, &t) == 2) {\n\t\t\t\t\t\t_t[3] = n;\n\t\t\t\t\t\t_t[2] = n >> 8;\n\t\t\t\t\t\t_t[5] = t;\n\t\t\t\t\t\t_t[4] = t >> 8;\n\t\t\t\t\t}\n\t\t\t\t\telse if (sscanf(val, \"%u\", &n) == 1) {\n\t\t\t\t\t\t_t[3] = n;\n\t\t\t\t\t\t_t[2] = n >> 8;\n\t\t\t\t\t}\n\t\t\t\t\telse tlen = 0;\n\t\t\t\t}\n\t\t\t\tif (!val || tlen) gf_isom_apple_set_tag(file, itag, val ? (u8 *)_t : NULL, tlen);\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase GF_ISOM_ITUNE_GAPLESS:\n\t\t\tcase GF_ISOM_ITUNE_COMPILATION:\n\t\t\t{\n\t\t\t\tu8 _t[1];\n\t\t\t\tif (val && !stricmp(val, \"yes\")) _t[0] = 1;\n\t\t\t\telse  _t[0] = 0;\n\t\t\t\tgf_isom_apple_set_tag(file, itag, _t, 1);\n\t\t\t}\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgf_isom_apple_set_tag(file, itag, (u8 *)val, tlen);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tneedSave = GF_TRUE;\n\n\t\t\tif (sep) {\n\t\t\t\tsep[0] = ':';\n\t\t\t\ttags = sep+1;\n\t\t\t} else {\n\t\t\t\ttags = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (movie_time) {\n\t\tgf_isom_set_creation_time(file, movie_time);\n\t\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\t\tgf_isom_set_track_creation_time(file, i+1, movie_time);\n\t\t}\n\t\tneedSave = GF_TRUE;\n\t}\n\n\tif (cprt) {\n\t\te = gf_isom_set_copyright(file, \"und\", cprt);\n\t\tneedSave = GF_TRUE;\n\t\tif (e) goto err_exit;\n\t}\n\tif (chap_file) {\n#ifndef GPAC_DISABLE_MEDIA_IMPORT\n\t\te = gf_media_import_chapters(file, chap_file, import_fps, chap_qt);\n\t\tneedSave = GF_TRUE;\n#else\n\t\tfprintf(stderr, \"Warning: GPAC compiled without Media Import, chapters can't be imported\\n\");\n\t\te = GF_NOT_SUPPORTED;\n#endif\n\t\tif (e) goto err_exit;\n\t}\n\n\tif (major_brand) {\n\t\tgf_isom_set_brand_info(file, major_brand, minor_version);\n\t\tneedSave = GF_TRUE;\n\t}\n\tfor (i=0; i<nb_alt_brand_add; i++) {\n\t\tgf_isom_modify_alternate_brand(file, brand_add[i], GF_TRUE);\n\t\tneedSave = GF_TRUE;\n\t}\n\tfor (i=0; i<nb_alt_brand_rem; i++) {\n\t\tgf_isom_modify_alternate_brand(file, brand_rem[i], GF_FALSE);\n\t\tneedSave = GF_TRUE;\n\t}\n\tif (box_patch_filename) {\n\t\te = gf_isom_apply_box_patch(file, box_patch_trackID, box_patch_filename, GF_FALSE);\n\t\tif (e) {\n\t\t\tfprintf(stderr, \"Failed to apply box patch %s: %s\\n\", box_patch_filename, gf_error_to_string(e) );\n\t\t\tgoto err_exit;\n\t\t}\n\t\tneedSave = GF_TRUE;\n\t}\n\n#ifndef GPAC_DISABLE_CRYPTO\n\tif (crypt) {\n\t\tif (!drm_file) {\n\t\t\tfprintf(stderr, \"Missing DRM file location - usage '-%s drm_file input_file\\n\", (crypt==1) ? \"crypt\" : \"decrypt\");\n\t\t\te = GF_BAD_PARAM;\n\t\t\tgoto err_exit;\n\t\t}\n\t\tif (get_file_type_by_ext(inName) != GF_FILE_TYPE_ISO_MEDIA) {\n\t\t\tfprintf(stderr, \"MP4Box can crypt only ISOMedia File\\n\");\n\t\t\te = GF_BAD_PARAM;\n\t\t\tgoto err_exit;\n\t\t}\n\t\tif (crypt == 1) {\n\t\t\tif (use_init_seg) {\n\t\t\t\te = gf_crypt_fragment(file, drm_file, outfile, inName, fs_dump_flags);\n\t\t\t} else {\n\t\t\t\te = gf_crypt_file(file, drm_file, outfile, interleaving_time, fs_dump_flags);\n\t\t\t}\n\t\t} else if (crypt ==2) {\n\t\t\tif (use_init_seg) {\n\t\t\t\te = gf_decrypt_fragment(file, drm_file, outfile, inName, fs_dump_flags);\n\t\t\t} else {\n\t\t\t\te = gf_decrypt_file(file, drm_file, outfile, interleaving_time, fs_dump_flags);\n\t\t\t}\n\t\t}\n\t\tif (e) goto err_exit;\n\t\tneedSave = outName ? GF_FALSE : GF_TRUE;\n\n\t\tif (!Frag && !HintIt && !FullInter && !force_co64) {\n\t\t\tchar szName[GF_MAX_PATH];\n\t\t\tstrcpy(szName, gf_isom_get_filename(file) );\n\t\t\tgf_isom_delete(file);\n\t\t\tfile = NULL;\n\t\t\tif (!outName) {\n\t\t\t\te = gf_file_move(outfile, szName);\n\t\t\t\tif (e) goto err_exit;\n\t\t\t}\n\t\t\tgoto exit;\n\t\t}\n\t}\n#endif /*GPAC_DISABLE_CRYPTO*/\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (Frag) {\n\t\tif (!interleaving_time) interleaving_time = DEFAULT_INTERLEAVING_IN_SEC;\n\t\tif (HintIt) fprintf(stderr, \"Warning: cannot hint and fragment - ignoring hint\\n\");\n\t\tfprintf(stderr, \"Fragmenting file (%.3f seconds fragments)\\n\", interleaving_time);\n\t\te = gf_media_fragment_file(file, outfile, interleaving_time, use_mfra);\n\t\tif (e) fprintf(stderr, \"Error while fragmenting file: %s\\n\", gf_error_to_string(e));\n\t\tif (!e && !outName) {\n\t\t\tif (gf_file_exists(inName) && gf_file_delete(inName)) fprintf(stderr, \"Error removing file %s\\n\", inName);\n\t\t\telse if (gf_file_move(outfile, inName)) fprintf(stderr, \"Error renaming file %s to %s\\n\", outfile, inName);\n\t\t}\n\t\tif (e) goto err_exit;\n\t\tgf_isom_delete(file);\n\t\tgoto exit;\n\t}\n#endif\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\tif (HintIt) {\n\t\tif (force_ocr) SetupClockReferences(file);\n\t\tfprintf(stderr, \"Hinting file with Path-MTU %d Bytes\\n\", MTUSize);\n\t\tMTUSize -= 12;\n\t\te = HintFile(file, MTUSize, max_ptime, rtp_rate, hint_flags, HintCopy, HintInter, regular_iod, single_group, hint_no_offset);\n\t\tif (e) goto err_exit;\n\t\tneedSave = GF_TRUE;\n\t\tif (print_sdp) dump_isom_sdp(file, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE);\n\t}\n#endif\n\n#if !defined(GPAC_DISABLE_ISOM_HINTING) && !defined(GPAC_DISABLE_SENG)\n\tfor (i=0; i<nb_sdp_ex; i++) {\n\t\tif (sdp_lines[i].trackID) {\n\t\t\tu32 track = gf_isom_get_track_by_id(file, sdp_lines[i].trackID);\n\t\t\tif (gf_isom_get_media_type(file, track)!=GF_ISOM_MEDIA_HINT) {\n\t\t\t\ts32 ref_count;\n\t\t\t\tu32 k, count = gf_isom_get_track_count(file);\n\t\t\t\tfor (j=0; j<count; j++) {\n\t\t\t\t\tif (gf_isom_get_media_type(file, j+1)!=GF_ISOM_MEDIA_HINT) continue;\n\t\t\t\t\tref_count = gf_isom_get_reference_count(file, j+1, GF_ISOM_REF_HINT);\n\t\t\t\t\tif (ref_count<0) continue;\n\t\t\t\t\tfor (k=0; k<(u32) ref_count; k++) {\n\t\t\t\t\t\tu32 refTk;\n\t\t\t\t\t\tif (gf_isom_get_reference(file, j+1, GF_ISOM_REF_HINT, k+1, &refTk)) continue;\n\t\t\t\t\t\tif (refTk==track) {\n\t\t\t\t\t\t\ttrack = j+1;\n\t\t\t\t\t\t\tj=count;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_isom_sdp_add_track_line(file, track, sdp_lines[i].line);\n\t\t\tneedSave = GF_TRUE;\n\t\t} else {\n\t\t\tgf_isom_sdp_add_line(file, sdp_lines[i].line);\n\t\t\tneedSave = GF_TRUE;\n\t\t}\n\t}\n#endif /*!defined(GPAC_DISABLE_ISOM_HINTING) && !defined(GPAC_DISABLE_SENG)*/\n\n\t/*full interleave (sample-based) if just hinted*/\n\tif (FullInter) {\n\t\te = gf_isom_set_storage_mode(file, GF_ISOM_STORE_TIGHT);\n\t} else if (do_flat) {\n\t\te = gf_isom_set_storage_mode(file, (do_flat==1) ? GF_ISOM_STORE_FLAT : GF_ISOM_STORE_STREAMABLE);\n\t\tneedSave = GF_TRUE;\n\t} else {\n\t\te = gf_isom_make_interleave(file, interleaving_time);\n\t\tif (!e && old_interleave) e = gf_isom_set_storage_mode(file, GF_ISOM_STORE_INTERLEAVED);\n\t}\n\tif (force_co64)\n\t\tgf_isom_force_64bit_chunk_offset(file, GF_TRUE);\n\n\tif (compress_moov)\n\t\tgf_isom_enable_compression(file, GF_ISO_COMP_MOOV, GF_FALSE);\n\n\tif (e) goto err_exit;\n\n\tif (!encode && !force_new) gf_isom_set_final_name(file, outfile);\n\tif (needSave) {\n\n\t\tif (!gf_sys_is_quiet()) {\n\t\t\tif (outName) {\n\t\t\t\tgf_isom_set_final_name(file, outfile);\n\t\t\t} else if (encode || pack_file) {\n\t\t\t\tfprintf(stderr, \"Saving to %s: \", gf_isom_get_filename(file) );\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"Saving %s: \", inName);\n\t\t\t}\n\t\t\tif (HintIt && FullInter) fprintf(stderr, \"Hinted file - Full Interleaving\\n\");\n\t\t\telse if (FullInter) fprintf(stderr, \"Full Interleaving\\n\");\n\t\t\telse if ((force_new==2) && interleaving_time) fprintf(stderr, \"Fast-start interleaved storage\\n\");\n\t\t\telse if (do_flat || !interleaving_time) fprintf(stderr, \"Flat storage\\n\");\n\t\t\telse fprintf(stderr, \"%.3f secs Interleaving%s\\n\", interleaving_time, old_interleave ? \" - no drift control\" : \"\");\n\t\t} else {\n\t\t\tif (outName)\n\t\t\t\tgf_isom_set_final_name(file, outfile);\n\t\t}\n\n\t\te = gf_isom_close(file);\n\t\tfile = NULL;\n\n\t\tif (!e && !outName && !encode && !force_new && !pack_file) {\n\t\t\tif (gf_file_exists(inName)) {\n\t\t\t\te = gf_file_delete(inName);\n\t\t\t\tif (e) {\n\t\t\t\t\tfprintf(stderr, \"Error removing file %s\\n\", inName);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\te = gf_file_move(outfile, inName);\n\t\t\tif (e) {\n\t\t\t\tfprintf(stderr, \"Error renaming file %s to %s\\n\", outfile, inName);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tgf_isom_delete(file);\n\t}\n\n\tif (e) {\n\t\tfprintf(stderr, \"Error: %s\\n\", gf_error_to_string(e));\n\t\tgoto err_exit;\n\t}\n\tgoto exit;\n\n#else\n\t/*close libgpac*/\n\tgf_isom_delete(file);\n\tfprintf(stderr, \"Error: Read-only version of MP4Box.\\n\");\n\treturn mp4box_cleanup(1);\n#endif //GPAC_DISABLE_ISOM_WRITE\n\n\nerr_exit:\n\t/*close libgpac*/\n\tif (file) gf_isom_delete(file);\n\tfprintf(stderr, \"\\n\\tError: %s\\n\", gf_error_to_string(e));\n\treturn mp4box_cleanup(1);\n\nexit:\n\tmp4box_cleanup(0);\n\n#ifdef GPAC_MEMORY_TRACKING\n\tif (mem_track && (gf_memory_size() || gf_file_handles_count() )) {\n\t\tgf_log_set_tool_level(GF_LOG_MEMORY, GF_LOG_INFO);\n\t\tgf_memory_print();\n\t\treturn 2;\n\t}\n#endif\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 401,
    "critical_vars": [
      "%d\\",
      "nhml",
      "p->value.uint"
    ],
    "function": "nhmldump_send_header",
    "filename": "gpac/CVE-2020-23930/CVE-2020-23930_CWE-476_9eeac00b38348c664dfeae2525bba0cf1bc32349_write_nhml.c.diff",
    "function_code": "static void nhmldump_send_header(GF_NHMLDumpCtx *ctx)\n{\n\tGF_FilterPacket *dst_pck;\n\tchar nhml[1024];\n\tu32 size;\n\tu8 *output;\n\tconst GF_PropertyValue *p;\n\n\tctx->szRootName = \"NHNTStream\";\n\tif (ctx->dims) {\n\t\tctx->szRootName = \"DIMSStream\";\n\t}\n\n\tif (!ctx->filep) {\n\t\tsprintf(nhml, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n\");\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t}\n\n\t/*write header*/\n\tsprintf(nhml, \"<%s version=\\\"1.0\\\" \", ctx->szRootName);\n\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\n\n\tNHML_PRINT_UINT(GF_PROP_PID_ID, NULL, \"trackID\")\n\tNHML_PRINT_UINT(GF_PROP_PID_TIMESCALE, NULL, \"timeScale\")\n\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_IN_IOD);\n\tif (p && p->value.boolean) {\n\t\tsprintf(nhml, \"inRootOD=\\\"yes\\\" \");\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t}\n\n\tif (ctx->oti && (ctx->oti<GF_CODECID_LAST_MPEG4_MAPPING)) {\n\t\tsprintf(nhml, \"streamType=\\\"%d\\\" objectTypeIndication=\\\"%d\\\" \", ctx->streamtype, ctx->oti);\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32)strlen(nhml));\n\t} else {\n\t\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_SUBTYPE);\n\t\tif (p) {\n\t\t\tsprintf(nhml, \"%s=\\\"%s\\\" \", \"mediaType\", gf_4cc_to_str(p->value.uint));\n\t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\n\t\t\tNHML_PRINT_4CC(GF_PROP_PID_ISOM_SUBTYPE, \"mediaSubType\", \"mediaSubType\")\n\t\t} else {\n\t\t\tNHML_PRINT_4CC(GF_PROP_PID_CODECID, NULL, \"codecID\")\n\t\t}\n\t}\n\n\tif (ctx->w && ctx->h) {\n\t\t//compatibility with old arch, we might want to remove this\n\t\tswitch (ctx->streamtype) {\n\t\tcase GF_STREAM_VISUAL:\n\t\tcase GF_STREAM_SCENE:\n\t\t\tsprintf(nhml, \"width=\\\"%d\\\" height=\\\"%d\\\" \", ctx->w, ctx->h);\n\t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\telse if (ctx->sr && ctx->chan) {\n\t\tsprintf(nhml, \"sampleRate=\\\"%d\\\" numChannels=\\\"%d\\\" \", ctx->sr, ctx->chan);\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\tsprintf(nhml, \"sampleRate=\\\"%d\\\" numChannels=\\\"%d\\\" \", ctx->sr, ctx->chan);\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_AUDIO_FORMAT);\n\t\tsprintf(nhml, \"bitsPerSample=\\\"%d\\\" \", gf_audio_fmt_bit_depth(p->value.uint));\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t}\n\n\tNHML_PRINT_4CC(0, \"codec_vendor\", \"codecVendor\")\n\tNHML_PRINT_UINT(0, \"codec_version\", \"codecVersion\")\n\tNHML_PRINT_UINT(0, \"codec_revision\", \"codecRevision\")\n\tNHML_PRINT_STRING(0, \"compressor_name\", \"compressorName\")\n\tNHML_PRINT_UINT(0, \"temporal_quality\", \"temporalQuality\")\n\tNHML_PRINT_UINT(0, \"spatial_quality\", \"spatialQuality\")\n\tNHML_PRINT_UINT(0, \"hres\", \"horizontalResolution\")\n\tNHML_PRINT_UINT(0, \"vres\", \"verticalResolution\")\n\tNHML_PRINT_UINT(GF_PROP_PID_BIT_DEPTH_Y, NULL, \"bitDepth\")\n\n\tNHML_PRINT_STRING(0, \"meta:xmlns\", \"xml_namespace\")\n\tNHML_PRINT_STRING(0, \"meta:schemaloc\", \"xml_schema_location\")\n\tNHML_PRINT_STRING(0, \"meta:mime\", \"mime_type\")\n\n\tNHML_PRINT_STRING(0, \"meta:config\", \"config\")\n\tNHML_PRINT_STRING(0, \"meta:aux_mimes\", \"aux_mime_type\")\n\n\tif (ctx->codecid == GF_CODECID_DIMS) {\n\t\tif (gf_filter_pid_get_property_str(ctx->ipid, \"meta:xmlns\")==NULL) {\n\t\t\tsprintf(nhml, \"xmlns=\\\"http://www.3gpp.org/richmedia\\\" \");\n\t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\t}\n\n\t\tNHML_PRINT_UINT(0, \"dims:profile\", \"profile\")\n\t\tNHML_PRINT_UINT(0, \"dims:level\", \"level\")\n\t\tNHML_PRINT_UINT(0, \"dims:pathComponents\", \"pathComponents\")\n\n\t\tp = gf_filter_pid_get_property_str(ctx->ipid, \"dims:fullRequestHost\");\n\t\tif (p) {\n\t\t\tsprintf(nhml, \"useFullRequestHost=\\\"%s\\\" \", p->value.boolean ? \"yes\" : \"no\");\n\t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\t}\n\t\tp = gf_filter_pid_get_property_str(ctx->ipid, \"dims:streamType\");\n\t\tif (p) {\n\t\t\tsprintf(nhml, \"stream_type=\\\"%s\\\" \", p->value.boolean ? \"primary\" : \"secondary\");\n\t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\t}\n\t\tp = gf_filter_pid_get_property_str(ctx->ipid, \"dims:redundant\");\n\t\tif (p) {\n\t\t\tsprintf(nhml, \"contains_redundant=\\\"%s\\\" \", (p->value.uint==1) ? \"main\" : ((p->value.uint==1) ? \"redundant\" : \"main+redundant\") );\n\t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\t}\n\t\tNHML_PRINT_UINT(0, \"dims:scriptTypes\", \"scriptTypes\")\n\t}\n\n\t//send DCD\n\tif (ctx->opid_info) {\n\t\tsprintf(nhml, \"specificInfoFile=\\\"%s\\\" \", gf_file_basename(ctx->info_file) );\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\n\t\tdst_pck = gf_filter_pck_new_shared(ctx->opid_info, ctx->dcfg, ctx->dcfg_size, NULL);\n\t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);\n\t\tgf_filter_pck_set_readonly(dst_pck);\n\t\tgf_filter_pck_send(dst_pck);\n\t}\n\n\tNHML_PRINT_STRING(0, \"meta:encoding\", \"encoding\")\n\tNHML_PRINT_STRING(0, \"meta:contentEncoding\", \"content_encoding\")\n\tctx->uncompress = GF_FALSE;\n\tif (p) {\n\t\tif (!strcmp(p->value.string, \"deflate\")) ctx->uncompress = GF_TRUE;\n\t\telse {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[NHMLMx] content_encoding %s not supported\\n\", p->value.string ));\n\t\t}\n\t}\n\n\tif (ctx->opid_mdia) {\n\t\tsprintf(nhml, \"baseMediaFile=\\\"%s\\\" \", gf_file_basename(ctx->media_file) );\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t}\n\tsprintf(nhml, \">\\n\");\n\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\n\tgf_bs_get_content_no_truncate(ctx->bs_w, &ctx->nhml_buffer, &size, &ctx->nhml_buffer_size);\n\n\tif (ctx->filep) {\n\t\tgf_fwrite(ctx->nhml_buffer, size, ctx->filep);\n\t\treturn;\n\t}\n\n\tdst_pck = gf_filter_pck_new_alloc(ctx->opid_nhml, size, &output);\n\tmemcpy(output, ctx->nhml_buffer, size);\n\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_FALSE);\n\tgf_filter_pck_send(dst_pck);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 401,
    "critical_vars": [
      "p"
    ],
    "function": "nhmldump_send_header",
    "filename": "gpac/CVE-2020-23930/CVE-2020-23930_CWE-476_9eeac00b38348c664dfeae2525bba0cf1bc32349_write_nhml.c.diff",
    "function_code": "static void nhmldump_send_header(GF_NHMLDumpCtx *ctx)\n{\n\tGF_FilterPacket *dst_pck;\n\tchar nhml[1024];\n\tu32 size;\n\tu8 *output;\n\tconst GF_PropertyValue *p;\n\n\tctx->szRootName = \"NHNTStream\";\n\tif (ctx->dims) {\n\t\tctx->szRootName = \"DIMSStream\";\n\t}\n\n\tif (!ctx->filep) {\n\t\tsprintf(nhml, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n\");\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t}\n\n\t/*write header*/\n\tsprintf(nhml, \"<%s version=\\\"1.0\\\" \", ctx->szRootName);\n\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\n\n\tNHML_PRINT_UINT(GF_PROP_PID_ID, NULL, \"trackID\")\n\tNHML_PRINT_UINT(GF_PROP_PID_TIMESCALE, NULL, \"timeScale\")\n\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_IN_IOD);\n\tif (p && p->value.boolean) {\n\t\tsprintf(nhml, \"inRootOD=\\\"yes\\\" \");\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t}\n\n\tif (ctx->oti && (ctx->oti<GF_CODECID_LAST_MPEG4_MAPPING)) {\n\t\tsprintf(nhml, \"streamType=\\\"%d\\\" objectTypeIndication=\\\"%d\\\" \", ctx->streamtype, ctx->oti);\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32)strlen(nhml));\n\t} else {\n\t\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_SUBTYPE);\n\t\tif (p) {\n\t\t\tsprintf(nhml, \"%s=\\\"%s\\\" \", \"mediaType\", gf_4cc_to_str(p->value.uint));\n\t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\n\t\t\tNHML_PRINT_4CC(GF_PROP_PID_ISOM_SUBTYPE, \"mediaSubType\", \"mediaSubType\")\n\t\t} else {\n\t\t\tNHML_PRINT_4CC(GF_PROP_PID_CODECID, NULL, \"codecID\")\n\t\t}\n\t}\n\n\tif (ctx->w && ctx->h) {\n\t\t//compatibility with old arch, we might want to remove this\n\t\tswitch (ctx->streamtype) {\n\t\tcase GF_STREAM_VISUAL:\n\t\tcase GF_STREAM_SCENE:\n\t\t\tsprintf(nhml, \"width=\\\"%d\\\" height=\\\"%d\\\" \", ctx->w, ctx->h);\n\t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\telse if (ctx->sr && ctx->chan) {\n\t\tsprintf(nhml, \"sampleRate=\\\"%d\\\" numChannels=\\\"%d\\\" \", ctx->sr, ctx->chan);\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\tsprintf(nhml, \"sampleRate=\\\"%d\\\" numChannels=\\\"%d\\\" \", ctx->sr, ctx->chan);\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_AUDIO_FORMAT);\n\t\tif (p)\n\t\t\tsprintf(nhml, \"bitsPerSample=\\\"%d\\\" \", gf_audio_fmt_bit_depth(p->value.uint));\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t}\n\n\tNHML_PRINT_4CC(0, \"codec_vendor\", \"codecVendor\")\n\tNHML_PRINT_UINT(0, \"codec_version\", \"codecVersion\")\n\tNHML_PRINT_UINT(0, \"codec_revision\", \"codecRevision\")\n\tNHML_PRINT_STRING(0, \"compressor_name\", \"compressorName\")\n\tNHML_PRINT_UINT(0, \"temporal_quality\", \"temporalQuality\")\n\tNHML_PRINT_UINT(0, \"spatial_quality\", \"spatialQuality\")\n\tNHML_PRINT_UINT(0, \"hres\", \"horizontalResolution\")\n\tNHML_PRINT_UINT(0, \"vres\", \"verticalResolution\")\n\tNHML_PRINT_UINT(GF_PROP_PID_BIT_DEPTH_Y, NULL, \"bitDepth\")\n\n\tNHML_PRINT_STRING(0, \"meta:xmlns\", \"xml_namespace\")\n\tNHML_PRINT_STRING(0, \"meta:schemaloc\", \"xml_schema_location\")\n\tNHML_PRINT_STRING(0, \"meta:mime\", \"mime_type\")\n\n\tNHML_PRINT_STRING(0, \"meta:config\", \"config\")\n\tNHML_PRINT_STRING(0, \"meta:aux_mimes\", \"aux_mime_type\")\n\n\tif (ctx->codecid == GF_CODECID_DIMS) {\n\t\tif (gf_filter_pid_get_property_str(ctx->ipid, \"meta:xmlns\")==NULL) {\n\t\t\tsprintf(nhml, \"xmlns=\\\"http://www.3gpp.org/richmedia\\\" \");\n\t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\t}\n\n\t\tNHML_PRINT_UINT(0, \"dims:profile\", \"profile\")\n\t\tNHML_PRINT_UINT(0, \"dims:level\", \"level\")\n\t\tNHML_PRINT_UINT(0, \"dims:pathComponents\", \"pathComponents\")\n\n\t\tp = gf_filter_pid_get_property_str(ctx->ipid, \"dims:fullRequestHost\");\n\t\tif (p) {\n\t\t\tsprintf(nhml, \"useFullRequestHost=\\\"%s\\\" \", p->value.boolean ? \"yes\" : \"no\");\n\t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\t}\n\t\tp = gf_filter_pid_get_property_str(ctx->ipid, \"dims:streamType\");\n\t\tif (p) {\n\t\t\tsprintf(nhml, \"stream_type=\\\"%s\\\" \", p->value.boolean ? \"primary\" : \"secondary\");\n\t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\t}\n\t\tp = gf_filter_pid_get_property_str(ctx->ipid, \"dims:redundant\");\n\t\tif (p) {\n\t\t\tsprintf(nhml, \"contains_redundant=\\\"%s\\\" \", (p->value.uint==1) ? \"main\" : ((p->value.uint==1) ? \"redundant\" : \"main+redundant\") );\n\t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\t}\n\t\tNHML_PRINT_UINT(0, \"dims:scriptTypes\", \"scriptTypes\")\n\t}\n\n\t//send DCD\n\tif (ctx->opid_info) {\n\t\tsprintf(nhml, \"specificInfoFile=\\\"%s\\\" \", gf_file_basename(ctx->info_file) );\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\n\t\tdst_pck = gf_filter_pck_new_shared(ctx->opid_info, ctx->dcfg, ctx->dcfg_size, NULL);\n\t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);\n\t\tgf_filter_pck_set_readonly(dst_pck);\n\t\tgf_filter_pck_send(dst_pck);\n\t}\n\n\tNHML_PRINT_STRING(0, \"meta:encoding\", \"encoding\")\n\tNHML_PRINT_STRING(0, \"meta:contentEncoding\", \"content_encoding\")\n\tctx->uncompress = GF_FALSE;\n\tif (p) {\n\t\tif (!strcmp(p->value.string, \"deflate\")) ctx->uncompress = GF_TRUE;\n\t\telse {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[NHMLMx] content_encoding %s not supported\\n\", p->value.string ));\n\t\t}\n\t}\n\n\tif (ctx->opid_mdia) {\n\t\tsprintf(nhml, \"baseMediaFile=\\\"%s\\\" \", gf_file_basename(ctx->media_file) );\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t}\n\tsprintf(nhml, \">\\n\");\n\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\n\tgf_bs_get_content_no_truncate(ctx->bs_w, &ctx->nhml_buffer, &size, &ctx->nhml_buffer_size);\n\n\tif (ctx->filep) {\n\t\tgf_fwrite(ctx->nhml_buffer, size, ctx->filep);\n\t\treturn;\n\t}\n\n\tdst_pck = gf_filter_pck_new_alloc(ctx->opid_nhml, size, &output);\n\tmemcpy(output, ctx->nhml_buffer, size);\n\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_FALSE);\n\tgf_filter_pck_send(dst_pck);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 58,
    "critical_vars": [
      "is_qt_text"
    ],
    "function": "gf_isom_get_text_description",
    "filename": "gpac/CVE-2021-32139/CVE-2021-32139_CWE-476_d527325a9b72218612455a534a508f9e1753f76e_tx3g.c.diff",
    "function_code": "GF_Err gf_isom_get_text_description(GF_ISOFile *movie, u32 trackNumber, u32 descriptionIndex, GF_TextSampleDescriptor **out_desc)\n{\n\tGF_TrackBox *trak;\n\tu32 i;\n\tBool is_qt_text = GF_FALSE;\n\tGF_Tx3gSampleEntryBox *txt;\n\n\tif (!descriptionIndex || !out_desc) return GF_BAD_PARAM;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\n\tswitch (trak->Media->handler->handlerType) {\n\tcase GF_ISOM_MEDIA_TEXT:\n\tcase GF_ISOM_MEDIA_SUBT:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\ttxt = (GF_Tx3gSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, descriptionIndex - 1);\n\tif (!txt) return GF_BAD_PARAM;\n\tswitch (txt->type) {\n\tcase GF_ISOM_BOX_TYPE_TX3G:\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_TEXT:\n\t\tis_qt_text = GF_TRUE;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\t(*out_desc) = (GF_TextSampleDescriptor *) gf_odf_desc_new(GF_ODF_TX3G_TAG);\n\tif (! (*out_desc) ) return GF_OUT_OF_MEM;\n\t(*out_desc)->back_color = txt->back_color;\n\t(*out_desc)->default_pos = txt->default_box;\n\t(*out_desc)->default_style = txt->default_style;\n\t(*out_desc)->displayFlags = txt->displayFlags;\n\t(*out_desc)->vert_justif = txt->vertical_justification;\n\t(*out_desc)->horiz_justif = txt->horizontal_justification;\n\tif (is_qt_text) {\n\t\tGF_TextSampleEntryBox *qt_txt = (GF_TextSampleEntryBox *) txt;\n\t\tif (qt_txt->textName) {\n\t\t\t(*out_desc)->font_count = 1;\n\t\t\t(*out_desc)->fonts = (GF_FontRecord *) gf_malloc(sizeof(GF_FontRecord));\n\t\t\t(*out_desc)->fonts[0].fontName = gf_strdup(qt_txt->textName);\n\t\t}\n\t} else {\n\t\t(*out_desc)->font_count = txt->font_table->entry_count;\n\t\t(*out_desc)->fonts = (GF_FontRecord *) gf_malloc(sizeof(GF_FontRecord) * txt->font_table->entry_count);\n\t\tfor (i=0; i<txt->font_table->entry_count; i++) {\n\t\t\t(*out_desc)->fonts[i].fontID = txt->font_table->fonts[i].fontID;\n\t\t\tif (txt->font_table->fonts[i].fontName)\n\t\t\t\t(*out_desc)->fonts[i].fontName = gf_strdup(txt->font_table->fonts[i].fontName);\n\t\t}\n\t}\n\treturn GF_OK;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 73,
    "critical_vars": [
      "qt_txt"
    ],
    "function": "gf_isom_get_text_description",
    "filename": "gpac/CVE-2021-32139/CVE-2021-32139_CWE-476_d527325a9b72218612455a534a508f9e1753f76e_tx3g.c.diff",
    "function_code": "GF_Err gf_isom_get_text_description(GF_ISOFile *movie, u32 trackNumber, u32 descriptionIndex, GF_TextSampleDescriptor **out_desc)\n{\n\tGF_TrackBox *trak;\n\tu32 i;\n\tGF_Tx3gSampleEntryBox *txt = NULL;\n\tGF_TextSampleEntryBox *qt_txt = NULL;\n\tif (!descriptionIndex || !out_desc) return GF_BAD_PARAM;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\n\tswitch (trak->Media->handler->handlerType) {\n\tcase GF_ISOM_MEDIA_TEXT:\n\tcase GF_ISOM_MEDIA_SUBT:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\ttxt = (GF_Tx3gSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, descriptionIndex - 1);\n\tif (!txt) return GF_BAD_PARAM;\n\tswitch (txt->type) {\n\tcase GF_ISOM_BOX_TYPE_TX3G:\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_TEXT:\n\t\tqt_txt = (GF_TextSampleEntryBox *)txt;\n\t\ttxt = NULL;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\t(*out_desc) = (GF_TextSampleDescriptor *) gf_odf_desc_new(GF_ODF_TX3G_TAG);\n\tif (! (*out_desc) ) return GF_OUT_OF_MEM;\n\n\tif (qt_txt) {\n\t\t(*out_desc)->back_color = rgb_48_to_32(qt_txt->background_color);\n\t\t(*out_desc)->default_pos = qt_txt->default_box;\n\t\t(*out_desc)->default_style.style_flags = qt_txt->fontFace;\n\t\t(*out_desc)->default_style.text_color = rgb_48_to_32(qt_txt->foreground_color);\n\t\t(*out_desc)->displayFlags = qt_txt->displayFlags;\n\t\t(*out_desc)->vert_justif = -1;\n\t\t(*out_desc)->horiz_justif = qt_txt->textJustification;\n\t\tif (qt_txt->textName) {\n\t\t\t(*out_desc)->font_count = 1;\n\t\t\t(*out_desc)->fonts = (GF_FontRecord *) gf_malloc(sizeof(GF_FontRecord));\n\t\t\t(*out_desc)->fonts[0].fontName = gf_strdup(qt_txt->textName);\n\t\t}\n\t} else {\n\t\t(*out_desc)->back_color = txt->back_color;\n\t\t(*out_desc)->default_pos = txt->default_box;\n\t\t(*out_desc)->default_style = txt->default_style;\n\t\t(*out_desc)->displayFlags = txt->displayFlags;\n\t\t(*out_desc)->vert_justif = txt->vertical_justification;\n\t\t(*out_desc)->horiz_justif = txt->horizontal_justification;\n\t\t(*out_desc)->font_count = txt->font_table->entry_count;\n\t\t(*out_desc)->fonts = (GF_FontRecord *) gf_malloc(sizeof(GF_FontRecord) * txt->font_table->entry_count);\n\t\tfor (i=0; i<txt->font_table->entry_count; i++) {\n\t\t\t(*out_desc)->fonts[i].fontID = txt->font_table->fonts[i].fontID;\n\t\t\tif (txt->font_table->fonts[i].fontName)\n\t\t\t\t(*out_desc)->fonts[i].fontName = gf_strdup(txt->font_table->fonts[i].fontName);\n\t\t}\n\t}\n\treturn GF_OK;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 714,
    "critical_vars": [
      "is_qt_text"
    ],
    "function": "gf_isom_write_tx3g",
    "filename": "gpac/CVE-2021-32139/CVE-2021-32139_CWE-476_d527325a9b72218612455a534a508f9e1753f76e_tx3g.c.diff",
    "function_code": "static void gf_isom_write_tx3g(GF_Tx3gSampleEntryBox *a, GF_BitStream *bs, u32 sidx, u32 sidx_offset)\n{\n\tu32 size, j, fount_count;\n\tBool is_qt_text = (a->type==GF_ISOM_BOX_TYPE_TEXT) ? GF_TRUE : GF_FALSE;\n\tconst char *qt_fontname = NULL;\n\tvoid gpp_write_rgba(GF_BitStream *bs, u32 col);\n\tvoid gpp_write_box(GF_BitStream *bs, GF_BoxRecord *rec);\n\tvoid gpp_write_style(GF_BitStream *bs, GF_StyleRecord *rec);\n\n\n\tif (sidx_offset) gf_bs_write_u8(bs, sidx + sidx_offset);\n\n\t/*SINCE WINCE HAS A READONLY VERSION OF MP4 WE MUST DO IT BY HAND*/\n\tsize = 8 + 18 + 8 + 12;\n\tsize += 8 + 2;\n\tfount_count = 0;\n\tif (is_qt_text) {\n\t\tGF_TextSampleEntryBox *qt = (GF_TextSampleEntryBox *)a;\n\t\tif (qt->textName) {\n\t\t\tqt_fontname = qt->textName;\n\t\t\tfount_count = 1;\n\t\t}\n\t} else {\n\t\tif (a->font_table) {\n\t\t\tfount_count = a->font_table->entry_count;\n\t\t\tfor (j=0; j<fount_count; j++) {\n\t\t\t\tsize += 3;\n\t\t\t\tif (a->font_table->fonts[j].fontName) size += (u32) strlen(a->font_table->fonts[j].fontName);\n\t\t\t}\n\t\t}\n\t}\n\t/*write TextSampleEntry box*/\n\tgf_bs_write_u32(bs, size);\n\tgf_bs_write_u32(bs, a->type);\n\tgf_bs_write_data(bs, a->reserved, 6);\n\tgf_bs_write_u16(bs, a->dataReferenceIndex);\n\tgf_bs_write_u32(bs, a->displayFlags);\n\tgf_bs_write_u8(bs, a->horizontal_justification);\n\tgf_bs_write_u8(bs, a->vertical_justification);\n\tgpp_write_rgba(bs, a->back_color);\n\tgpp_write_box(bs, &a->default_box);\n\tgpp_write_style(bs, &a->default_style);\n\t/*write font table box*/\n\tsize -= (8 + 18 + 8 + 12);\n\tgf_bs_write_u32(bs, size);\n\tgf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_FTAB);\n\n\tgf_bs_write_u16(bs, fount_count);\n\tfor (j=0; j<fount_count; j++) {\n\t\tif (is_qt_text) {\n\t\t\tgf_bs_write_u16(bs, 0);\n\t\t\tif (qt_fontname) {\n\t\t\t\tu32 len = (u32) strlen(qt_fontname);\n\t\t\t\tgf_bs_write_u8(bs, len);\n\t\t\t\tgf_bs_write_data(bs, qt_fontname, len);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u8(bs, 0);\n\t\t\t}\n\t\t} else {\n\t\t\tgf_bs_write_u16(bs, a->font_table->fonts[j].fontID);\n\t\t\tif (a->font_table->fonts[j].fontName) {\n\t\t\t\tu32 len = (u32) strlen(a->font_table->fonts[j].fontName);\n\t\t\t\tgf_bs_write_u8(bs, len);\n\t\t\t\tgf_bs_write_data(bs, a->font_table->fonts[j].fontName, len);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u8(bs, 0);\n\t\t\t}\n\t\t}\n\t}\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 738,
    "critical_vars": [
      "qt->textName",
      "qt"
    ],
    "function": "gf_isom_write_tx3g",
    "filename": "gpac/CVE-2021-32139/CVE-2021-32139_CWE-476_d527325a9b72218612455a534a508f9e1753f76e_tx3g.c.diff",
    "function_code": "static void gf_isom_write_tx3g(GF_Tx3gSampleEntryBox *_a, GF_BitStream *bs, u32 sidx, u32 sidx_offset)\n{\n\tu32 size, j, fount_count;\n\tconst char *qt_fontname = NULL;\n\tvoid gpp_write_rgba(GF_BitStream *bs, u32 col);\n\tvoid gpp_write_box(GF_BitStream *bs, GF_BoxRecord *rec);\n\tvoid gpp_write_style(GF_BitStream *bs, GF_StyleRecord *rec);\n\n\tGF_TextSampleEntryBox *qt = (_a->type==GF_ISOM_BOX_TYPE_TEXT) ? (GF_TextSampleEntryBox *)_a : NULL;\n\tGF_Tx3gSampleEntryBox *ttxt = (_a->type!=GF_ISOM_BOX_TYPE_TEXT) ? (GF_Tx3gSampleEntryBox *)_a : NULL;\n\n\tif (sidx_offset) gf_bs_write_u8(bs, sidx + sidx_offset);\n\n\t/*SINCE WINCE HAS A READONLY VERSION OF MP4 WE MUST DO IT BY HAND*/\n\tsize = 8 + 18 + 8 + 12;\n\tsize += 8 + 2;\n\tfount_count = 0;\n\tif (qt && qt->textName) {\n\t\tqt_fontname = qt->textName;\n\t\tfount_count = 1;\n\t} else if (ttxt && ttxt->font_table) {\n\t\tfount_count = ttxt->font_table->entry_count;\n\t\tfor (j=0; j<fount_count; j++) {\n\t\t\tsize += 3;\n\t\t\tif (ttxt->font_table->fonts[j].fontName)\n\t\t\t\tsize += (u32) strlen(ttxt->font_table->fonts[j].fontName);\n\t\t}\n\t}\n\t/*write TextSampleEntry box*/\n\tgf_bs_write_u32(bs, size);\n\tgf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_TX3G);\n\tgf_bs_write_data(bs, _a->reserved, 6);\n\tgf_bs_write_u16(bs, _a->dataReferenceIndex);\n\tgf_bs_write_u32(bs, _a->displayFlags);\n\tif (qt) {\n\t\tGF_StyleRecord sr;\n\t\tmemset(&sr, 0, sizeof(GF_StyleRecord));\n\t\tgf_bs_write_u8(bs, qt->textJustification);\n\t\tgf_bs_write_u8(bs, (u8) -1);\n\t\tgpp_write_rgba(bs, rgb_48_to_32(qt->background_color) );\n\t\tgpp_write_box(bs, &qt->default_box);\n\t\tsr.text_color = rgb_48_to_32(qt->foreground_color);\n\t\tsr.style_flags = qt->fontFace;\n\t\tgpp_write_style(bs, &sr);\n\t} else {\n\t\tgf_bs_write_u8(bs, ttxt->horizontal_justification);\n\t\tgf_bs_write_u8(bs, ttxt->vertical_justification);\n\t\tgpp_write_rgba(bs, ttxt->back_color);\n\t\tgpp_write_box(bs, &ttxt->default_box);\n\t\tgpp_write_style(bs, &ttxt->default_style);\n\t}\n\t/*write font table box*/\n\tsize -= (8 + 18 + 8 + 12);\n\tgf_bs_write_u32(bs, size);\n\tgf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_FTAB);\n\n\tgf_bs_write_u16(bs, fount_count);\n\tfor (j=0; j<fount_count; j++) {\n\t\tif (qt) {\n\t\t\tgf_bs_write_u16(bs, 0);\n\t\t\tif (qt_fontname) {\n\t\t\t\tu32 len = (u32) strlen(qt_fontname);\n\t\t\t\tgf_bs_write_u8(bs, len);\n\t\t\t\tgf_bs_write_data(bs, qt_fontname, len);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u8(bs, 0);\n\t\t\t}\n\t\t} else {\n\t\t\tgf_bs_write_u16(bs, ttxt->font_table->fonts[j].fontID);\n\t\t\tif (ttxt->font_table->fonts[j].fontName) {\n\t\t\t\tu32 len = (u32) strlen(ttxt->font_table->fonts[j].fontName);\n\t\t\t\tgf_bs_write_u8(bs, len);\n\t\t\t\tgf_bs_write_data(bs, ttxt->font_table->fonts[j].fontName, len);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u8(bs, 0);\n\t\t\t}\n\t\t}\n\t}\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Fun-Call",
    "line_old": 350,
    "line_new": 350,
    "critical_vars": [
      "ptr"
    ],
    "function": "text_box_read",
    "filename": "gpac/CVE-2021-32139/CVE-2021-32139_CWE-476_d527325a9b72218612455a534a508f9e1753f76e_box_code_3gpp.c.diff",
    "function_code": "GF_Err text_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu16 pSize;\n\tGF_TextSampleEntryBox *ptr = (GF_TextSampleEntryBox*)s;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\te = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)ptr, bs);\n\tif (e) return e;\n\t//some weird text entries are not QT text nor 3gpp, cf issue #1030\n\tif (!ptr->size) {\n\t\tptr->textJustification = 1;\n\t\treturn GF_OK;\n\t}\n\tISOM_DECREASE_SIZE(ptr, 43);\n\n\n\tptr->displayFlags = gf_bs_read_u32(bs);\t\t\t/*Display flags*/\n\tptr->textJustification = gf_bs_read_u32(bs);\t/*Text justification*/\n\tgf_bs_read_data(bs, ptr->background_color, 6);\t/*Background color*/\n\tgpp_read_box(bs, &ptr->default_box);\t\t\t/*Default text box*/\n\tgf_bs_read_data(bs, ptr->reserved1, 8);\t\t\t/*Reserved*/\n\tptr->fontNumber = gf_bs_read_u16(bs);\t\t\t/*Font number*/\n\tptr->fontFace   = gf_bs_read_u16(bs);\t\t\t/*Font face*/\n\tptr->reserved2  = gf_bs_read_u8(bs);\t\t\t/*Reserved*/\n\tptr->reserved3  = gf_bs_read_u16(bs);\t\t\t/*Reserved*/\n\tgf_bs_read_data(bs, ptr->foreground_color, 6);\t/*Foreground color*/\n\n\t/*ffmpeg compatibility with iPod streams: no pascal string*/\n\tif (!ptr->size)\n\t\treturn GF_OK;\n\n\tISOM_DECREASE_SIZE(ptr, 1);\n\tpSize = gf_bs_read_u8(bs); /*a Pascal string begins with its size: get textName size*/\n\n\tif (ptr->size < pSize) {\n\t\tu32 b_size = pSize;\n\t\tsize_t i = 0;\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] text box doesn't use a Pascal string: trying to decode anyway.\\n\"));\n\t\tptr->textName = (char*)gf_malloc((size_t)ptr->size + 1 + 1);\n\t\tif (!ptr->textName) return GF_OUT_OF_MEM;\n\n\t\tdo {\n\t\t\tchar c = (char)b_size;\n\t\t\tif (c == '\\0') {\n\t\t\t\tbreak;\n\t\t\t} else if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {\n\t\t\t\tptr->textName[i] = c;\n\t\t\t} else {\n\t\t\t\tgf_free(ptr->textName);\n\t\t\t\tptr->textName = NULL;\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] text box doesn't use a Pascal string and contains non-chars. Abort.\\n\"));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\ti++;\n\t\t\tif (!ptr->size)\n\t\t\t\tbreak;\n\t\t\tptr->size--;\n\t\t\tb_size = gf_bs_read_u8(bs);\n\t\t} while (b_size);\n\n\t\tptr->textName[i] = '\\0';\t\t\t\t/*Font name*/\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] text box doesn't use a Pascal string: \\\"%s\\\" detected.\\n\", ptr->textName));\n\t\treturn GF_OK;\n\t}\n\tif (pSize) {\n\t\tptr->textName = (char*) gf_malloc(pSize+1 * sizeof(char));\n\t\tif (!ptr->textName) return GF_OUT_OF_MEM;\n\n\t\tif (gf_bs_read_data(bs, ptr->textName, pSize) != pSize) {\n\t\t\tgf_free(ptr->textName);\n\t\t\tptr->textName = NULL;\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tptr->textName[pSize] = '\\0';\t\t\t\t/*Font name*/\n\t}\n\tISOM_DECREASE_SIZE(ptr, pSize);\n\treturn gf_isom_box_array_read(s, bs);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 513,
    "critical_vars": [
      "s->size"
    ],
    "function": "text_box_size",
    "filename": "gpac/CVE-2021-32139/CVE-2021-32139_CWE-476_d527325a9b72218612455a534a508f9e1753f76e_box_code_3gpp.c.diff",
    "function_code": "GF_Err text_box_size(GF_Box *s)\n{\n\tGF_TextSampleEntryBox *ptr = (GF_TextSampleEntryBox*)s;\n\n\ts->size += 8;\n\t/*base + this + string length*/\n\ts->size += 43 + 1;\n\tif (ptr->textName)\n\t\ts->size += strlen(ptr->textName);\n\treturn GF_OK;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 2879,
    "critical_vars": [
      "traf->trex->track->Media",
      "sample",
      "&od_sample"
    ],
    "function": "gf_isom_fragment_add_sample_ex",
    "filename": "gpac/CVE-2023-2840/CVE-2023-2840_CWE-476_ba59206b3225f0e8e95a27eff41cb1c49ddf9a37_movie_fragments.c.diff",
    "function_code": "GF_Err gf_isom_fragment_add_sample_ex(GF_ISOFile *movie, GF_ISOTrackID TrackID, const GF_ISOSample *sample, u32 DescIndex,\n                                   u32 Duration, u8 PaddingBits, u16 DegradationPriority, Bool redundant_coding, void **ref, u32 ref_offset)\n{\n\tu32 count, buffer_size;\n\tu8 *buffer;\n\tu64 pos;\n\tGF_ISOSample *od_sample = NULL;\n\tGF_TrunEntry ent, *prev_ent;\n\tGF_TrackFragmentBox *traf, *traf_2;\n\tGF_TrackFragmentRunBox *trun;\n\n\tif (!movie->moof || !(movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) || !sample)\n\t\treturn GF_BAD_PARAM;\n\n\ttraf = gf_isom_get_traf(movie, TrackID);\n\tif (!traf)\n\t\treturn GF_BAD_PARAM;\n\n\tif (!traf->tfhd->sample_desc_index)\n\t\ttraf->tfhd->sample_desc_index = DescIndex ? DescIndex : traf->trex->def_sample_desc_index;\n\n\tpos = gf_bs_get_position(movie->editFileMap->bs);\n\n\n\t//WARNING: we change stream description, create a new TRAF\n\tif ( DescIndex && (traf->tfhd->sample_desc_index != DescIndex)) {\n\t\t//if we're caching flush the current run\n\t\tif (traf->DataCache && !traf->use_sample_interleave) {\n\t\t\tcount = gf_list_count(traf->TrackRuns);\n\t\t\tif (count) {\n\t\t\t\ttrun = (GF_TrackFragmentRunBox *)gf_list_get(traf->TrackRuns, count-1);\n\t\t\t\ttrun->data_offset = (u32) (pos - movie->moof->fragment_offset - 8);\n\t\t\t\tgf_bs_get_content(trun->cache, &buffer, &buffer_size);\n\t\t\t\tgf_bs_write_data(movie->editFileMap->bs, buffer, buffer_size);\n\t\t\t\tgf_bs_del(trun->cache);\n\t\t\t\ttrun->cache = NULL;\n\t\t\t\tgf_free(buffer);\n\t\t\t}\n\t\t}\n\t\ttraf_2 = (GF_TrackFragmentBox *) gf_isom_box_new_parent(&movie->moof->child_boxes, GF_ISOM_BOX_TYPE_TRAF);\n\t\tif (!traf_2) return GF_OUT_OF_MEM;\n\t\ttraf_2->trex = traf->trex;\n\t\ttraf_2->tfhd = (GF_TrackFragmentHeaderBox *) gf_isom_box_new_parent(&traf_2->child_boxes, GF_ISOM_BOX_TYPE_TFHD);\n\t\tif (!traf_2->tfhd) return GF_OUT_OF_MEM;\n\t\ttraf_2->tfhd->trackID = traf->tfhd->trackID;\n\t\t//keep the same offset\n\t\ttraf_2->tfhd->base_data_offset = movie->moof->fragment_offset + 8;\n\t\tgf_list_add(movie->moof->TrackList, traf_2);\n\n\t\t//duplicate infos\n\t\ttraf_2->IFrameSwitching = traf->IFrameSwitching;\n\t\ttraf_2->use_sample_interleave = traf->use_sample_interleave;\n\t\ttraf_2->interleave_id = traf->interleave_id;\n\t\ttraf_2->truns_first = traf->truns_first;\n\t\ttraf_2->truns_v1 = traf->truns_v1;\n\t\ttraf_2->large_tfdt = traf->large_tfdt;\n\t\ttraf_2->DataCache  = traf->DataCache;\n\t\ttraf_2->tfhd->sample_desc_index  = DescIndex;\n\n\t\t//switch them ...\n\t\ttraf = traf_2;\n\t}\n\n\tpos = movie->moof->trun_ref_size ? (8+movie->moof->trun_ref_size) : gf_bs_get_position(movie->editFileMap->bs);\n\n\t//check if we need a new trun entry\n\tcount = (traf->use_sample_interleave && traf->force_new_trun) ? 0 : gf_list_count(traf->TrackRuns);\n\tif (count) {\n\t\ttrun = (GF_TrackFragmentRunBox *)gf_list_get(traf->TrackRuns, count-1);\n\t\t//check data offset when no caching as trun entries shall ALWAYS be contiguous samples\n\t\tif (!traf->DataCache && (movie->moof->fragment_offset + 8 + trun->data_offset + trun->run_size != pos) )\n\t\t\tcount = 0;\n\n\t\t//check I-frame detection\n\t\tif (traf->IFrameSwitching && sample->IsRAP)\n\t\t\tcount = 0;\n\n\t\tif (traf->DataCache && (traf->DataCache==trun->sample_count) && !traf->use_sample_interleave)\n\t\t\tcount = 0;\n\n\t\tif (traf->force_new_trun)\n\t\t\tcount = 0;\n\n\t\t//if data cache is on and we're changing TRUN, store the cache and update data offset\n\t\tif (!count && traf->DataCache && !traf->use_sample_interleave) {\n\t\t\ttrun->data_offset = (u32) (pos - movie->moof->fragment_offset - 8);\n\t\t\tgf_bs_get_content(trun->cache, &buffer, &buffer_size);\n\t\t\tgf_bs_write_data(movie->editFileMap->bs, buffer, buffer_size);\n\t\t\tgf_bs_del(trun->cache);\n\t\t\ttrun->cache = NULL;\n\t\t\tgf_free(buffer);\n\t\t}\n\t}\n\ttraf->force_new_trun = 0;\n\n\t//new run\n\tif (!count) {\n\t\ttrun = (GF_TrackFragmentRunBox *) gf_isom_box_new_parent(&traf->child_boxes, GF_ISOM_BOX_TYPE_TRUN);\n\t\tif (!trun) return GF_OUT_OF_MEM;\n\t\t//store data offset (we have the 8 btyes offset of the MDAT)\n\t\ttrun->data_offset = (u32) (pos - movie->moof->fragment_offset - 8);\n\t\tgf_list_add(traf->TrackRuns, trun);\n#ifdef GF_ENABLE_CTRN\n\t\ttrun->use_ctrn = traf->use_ctrn;\n\t\ttrun->use_inherit = traf->use_inherit;\n\t\ttrun->ctso_multiplier = traf->trex->def_sample_duration;\n#endif\n\t\ttrun->interleave_id = traf->interleave_id;\n\t\tif (traf->truns_v1)\n\t\t\ttrun->version = 1;\n\n\t\t//if we use data caching, create a bitstream\n\t\tif (traf->DataCache)\n\t\t\ttrun->cache = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t}\n\n\tmemset(&ent, 0, sizeof(GF_TrunEntry));\n\tent.CTS_Offset = sample->CTS_Offset;\n\tent.Duration = Duration;\n\tent.dts = sample->DTS;\n\tent.nb_pack = sample->nb_pack;\n\tent.flags = GF_ISOM_FORMAT_FRAG_FLAGS(PaddingBits, sample->IsRAP, DegradationPriority);\n\tif (sample->IsRAP) {\n\t\tent.flags |= GF_ISOM_GET_FRAG_DEPEND_FLAGS(0, 2, 0, (redundant_coding ? 1 : 0) );\n\t\tent.SAP_type = sample->IsRAP;\n\t}\n\tif (trun->nb_samples) {\n\t\tprev_ent = &trun->samples[trun->nb_samples-1];\n\t} else {\n\t\tprev_ent = NULL;\n\t}\n\n\tif (prev_ent && (prev_ent->dts || !prev_ent->Duration) && sample->DTS) {\n\t\tu32 nsamp = prev_ent->nb_pack ? prev_ent->nb_pack : 1;\n\t\tif (nsamp*prev_ent->Duration != sample->DTS - prev_ent->dts)\n\t\t\tprev_ent->Duration = (u32) (sample->DTS - prev_ent->dts) / nsamp;\n\t}\n\tif (trun->nb_samples >= trun->sample_alloc) {\n\t\ttrun->sample_alloc += 50;\n\t\tif (trun->nb_samples >= trun->sample_alloc) trun->sample_alloc = trun->nb_samples+1;\n\t\ttrun->samples = gf_realloc(trun->samples, sizeof(GF_TrunEntry)*trun->sample_alloc);\n\t\tif (!trun->samples) return GF_OUT_OF_MEM;\n\t}\n\n\t//rewrite OD frames\n\tif (traf->trex->track->Media->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\t//this may fail if dependencies are not well done ...\n\t\tMedia_ParseODFrame(traf->trex->track->Media, sample, &od_sample);\n\t\tsample = od_sample;\n\t}\n\n\tent.size = sample->dataLength;\n\ttrun->samples[trun->nb_samples] = ent;\n\ttrun->nb_samples ++;\n\ttrun->run_size += ent.size;\n\n\tif (sample->CTS_Offset<0) {\n\t\ttrun->version = 1;\n\t}\n\ttrun->sample_count += sample->nb_pack ? sample->nb_pack : 1;\n\n\t//finally write the data\n\tif (sample->dataLength) {\n\t\tu32 res = 0;\n\t\tif (!traf->DataCache) {\n\t\t\tif (movie->moof_first && movie->on_block_out && (ref || trun->sample_refs)) {\n\t\t\t\tGF_TrafSampleRef *sref;\n\t\t\t\tif (!trun->sample_refs) trun->sample_refs = gf_list_new();\n\t\t\t\tGF_SAFEALLOC(sref, GF_TrafSampleRef);\n\t\t\t\tif (!sref) return GF_OUT_OF_MEM;\n\t\t\t\tif (ref && *ref && !od_sample) {\n\t\t\t\t\tsref->data = sample->data;\n\t\t\t\t\tsref->len = sample->dataLength;\n\t\t\t\t\tsref->ref = *ref;\n\t\t\t\t\tsref->ref_offset = ref_offset;\n\t\t\t\t\t*ref = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tsref->data = gf_malloc(sample->dataLength);\n\t\t\t\t\tif (!sref->data) {\n\t\t\t\t\t\tgf_free(sref);\n\t\t\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(sref->data, sample->data, sample->dataLength);\n\t\t\t\t\tsref->len = sample->dataLength;\n\t\t\t\t}\n\t\t\t\tres = sref->len;\n\t\t\t\ttraf->trun_ref_size += res;\n\t\t\t\tmovie->moof->trun_ref_size += res;\n\t\t\t\tgf_list_add(trun->sample_refs, sref);\n\t\t\t} else {\n\t\t\t\tres = gf_bs_write_data(movie->editFileMap->bs, sample->data, sample->dataLength);\n\t\t\t}\n\t\t} else if (trun->cache) {\n\t\t\tres = gf_bs_write_data(trun->cache, sample->data, sample->dataLength);\n\t\t} else {\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\tif (res!=sample->dataLength) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso fragment] Could not add a sample with a size of %u bytes\\n\", sample->dataLength));\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\n\t}\n\tif (od_sample) gf_isom_sample_del(&od_sample);\n\n\tif (traf->trex->tfra) {\n\t\tGF_RandomAccessEntry *raf;\n\t\traf = &traf->trex->tfra->entries[traf->trex->tfra->nb_entries-1];\n\t\t//if sample is sync, store its time and trun number\n\t\tif (!raf->trun_number && sample->IsRAP) {\n\t\t\traf->time = sample->DTS + sample->CTS_Offset;\n\t\t\traf->trun_number = gf_list_count(traf->TrackRuns);\n\t\t\traf->sample_number = trun->sample_count;\n\t\t}\n\t}\n\treturn GF_OK;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 2879,
    "critical_vars": [
      "e"
    ],
    "function": "gf_isom_fragment_add_sample_ex",
    "filename": "gpac/CVE-2023-2840/CVE-2023-2840_CWE-476_ba59206b3225f0e8e95a27eff41cb1c49ddf9a37_movie_fragments.c.diff",
    "function_code": "GF_Err gf_isom_fragment_add_sample_ex(GF_ISOFile *movie, GF_ISOTrackID TrackID, const GF_ISOSample *sample, u32 DescIndex,\n                                   u32 Duration, u8 PaddingBits, u16 DegradationPriority, Bool redundant_coding, void **ref, u32 ref_offset)\n{\n\tu32 count, buffer_size;\n\tu8 *buffer;\n\tu64 pos;\n\tGF_ISOSample *od_sample = NULL;\n\tGF_TrunEntry ent, *prev_ent;\n\tGF_TrackFragmentBox *traf, *traf_2;\n\tGF_TrackFragmentRunBox *trun;\n\n\tif (!movie->moof || !(movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) || !sample)\n\t\treturn GF_BAD_PARAM;\n\n\ttraf = gf_isom_get_traf(movie, TrackID);\n\tif (!traf)\n\t\treturn GF_BAD_PARAM;\n\n\tif (!traf->tfhd->sample_desc_index)\n\t\ttraf->tfhd->sample_desc_index = DescIndex ? DescIndex : traf->trex->def_sample_desc_index;\n\n\tpos = gf_bs_get_position(movie->editFileMap->bs);\n\n\n\t//WARNING: we change stream description, create a new TRAF\n\tif ( DescIndex && (traf->tfhd->sample_desc_index != DescIndex)) {\n\t\t//if we're caching flush the current run\n\t\tif (traf->DataCache && !traf->use_sample_interleave) {\n\t\t\tcount = gf_list_count(traf->TrackRuns);\n\t\t\tif (count) {\n\t\t\t\ttrun = (GF_TrackFragmentRunBox *)gf_list_get(traf->TrackRuns, count-1);\n\t\t\t\ttrun->data_offset = (u32) (pos - movie->moof->fragment_offset - 8);\n\t\t\t\tgf_bs_get_content(trun->cache, &buffer, &buffer_size);\n\t\t\t\tgf_bs_write_data(movie->editFileMap->bs, buffer, buffer_size);\n\t\t\t\tgf_bs_del(trun->cache);\n\t\t\t\ttrun->cache = NULL;\n\t\t\t\tgf_free(buffer);\n\t\t\t}\n\t\t}\n\t\ttraf_2 = (GF_TrackFragmentBox *) gf_isom_box_new_parent(&movie->moof->child_boxes, GF_ISOM_BOX_TYPE_TRAF);\n\t\tif (!traf_2) return GF_OUT_OF_MEM;\n\t\ttraf_2->trex = traf->trex;\n\t\ttraf_2->tfhd = (GF_TrackFragmentHeaderBox *) gf_isom_box_new_parent(&traf_2->child_boxes, GF_ISOM_BOX_TYPE_TFHD);\n\t\tif (!traf_2->tfhd) return GF_OUT_OF_MEM;\n\t\ttraf_2->tfhd->trackID = traf->tfhd->trackID;\n\t\t//keep the same offset\n\t\ttraf_2->tfhd->base_data_offset = movie->moof->fragment_offset + 8;\n\t\tgf_list_add(movie->moof->TrackList, traf_2);\n\n\t\t//duplicate infos\n\t\ttraf_2->IFrameSwitching = traf->IFrameSwitching;\n\t\ttraf_2->use_sample_interleave = traf->use_sample_interleave;\n\t\ttraf_2->interleave_id = traf->interleave_id;\n\t\ttraf_2->truns_first = traf->truns_first;\n\t\ttraf_2->truns_v1 = traf->truns_v1;\n\t\ttraf_2->large_tfdt = traf->large_tfdt;\n\t\ttraf_2->DataCache  = traf->DataCache;\n\t\ttraf_2->tfhd->sample_desc_index  = DescIndex;\n\n\t\t//switch them ...\n\t\ttraf = traf_2;\n\t}\n\n\tpos = movie->moof->trun_ref_size ? (8+movie->moof->trun_ref_size) : gf_bs_get_position(movie->editFileMap->bs);\n\n\t//check if we need a new trun entry\n\tcount = (traf->use_sample_interleave && traf->force_new_trun) ? 0 : gf_list_count(traf->TrackRuns);\n\tif (count) {\n\t\ttrun = (GF_TrackFragmentRunBox *)gf_list_get(traf->TrackRuns, count-1);\n\t\t//check data offset when no caching as trun entries shall ALWAYS be contiguous samples\n\t\tif (!traf->DataCache && (movie->moof->fragment_offset + 8 + trun->data_offset + trun->run_size != pos) )\n\t\t\tcount = 0;\n\n\t\t//check I-frame detection\n\t\tif (traf->IFrameSwitching && sample->IsRAP)\n\t\t\tcount = 0;\n\n\t\tif (traf->DataCache && (traf->DataCache==trun->sample_count) && !traf->use_sample_interleave)\n\t\t\tcount = 0;\n\n\t\tif (traf->force_new_trun)\n\t\t\tcount = 0;\n\n\t\t//if data cache is on and we're changing TRUN, store the cache and update data offset\n\t\tif (!count && traf->DataCache && !traf->use_sample_interleave) {\n\t\t\ttrun->data_offset = (u32) (pos - movie->moof->fragment_offset - 8);\n\t\t\tgf_bs_get_content(trun->cache, &buffer, &buffer_size);\n\t\t\tgf_bs_write_data(movie->editFileMap->bs, buffer, buffer_size);\n\t\t\tgf_bs_del(trun->cache);\n\t\t\ttrun->cache = NULL;\n\t\t\tgf_free(buffer);\n\t\t}\n\t}\n\ttraf->force_new_trun = 0;\n\n\t//new run\n\tif (!count) {\n\t\ttrun = (GF_TrackFragmentRunBox *) gf_isom_box_new_parent(&traf->child_boxes, GF_ISOM_BOX_TYPE_TRUN);\n\t\tif (!trun) return GF_OUT_OF_MEM;\n\t\t//store data offset (we have the 8 btyes offset of the MDAT)\n\t\ttrun->data_offset = (u32) (pos - movie->moof->fragment_offset - 8);\n\t\tgf_list_add(traf->TrackRuns, trun);\n#ifdef GF_ENABLE_CTRN\n\t\ttrun->use_ctrn = traf->use_ctrn;\n\t\ttrun->use_inherit = traf->use_inherit;\n\t\ttrun->ctso_multiplier = traf->trex->def_sample_duration;\n#endif\n\t\ttrun->interleave_id = traf->interleave_id;\n\t\tif (traf->truns_v1)\n\t\t\ttrun->version = 1;\n\n\t\t//if we use data caching, create a bitstream\n\t\tif (traf->DataCache)\n\t\t\ttrun->cache = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t}\n\n\tmemset(&ent, 0, sizeof(GF_TrunEntry));\n\tent.CTS_Offset = sample->CTS_Offset;\n\tent.Duration = Duration;\n\tent.dts = sample->DTS;\n\tent.nb_pack = sample->nb_pack;\n\tent.flags = GF_ISOM_FORMAT_FRAG_FLAGS(PaddingBits, sample->IsRAP, DegradationPriority);\n\tif (sample->IsRAP) {\n\t\tent.flags |= GF_ISOM_GET_FRAG_DEPEND_FLAGS(0, 2, 0, (redundant_coding ? 1 : 0) );\n\t\tent.SAP_type = sample->IsRAP;\n\t}\n\tif (trun->nb_samples) {\n\t\tprev_ent = &trun->samples[trun->nb_samples-1];\n\t} else {\n\t\tprev_ent = NULL;\n\t}\n\n\tif (prev_ent && (prev_ent->dts || !prev_ent->Duration) && sample->DTS) {\n\t\tu32 nsamp = prev_ent->nb_pack ? prev_ent->nb_pack : 1;\n\t\tif (nsamp*prev_ent->Duration != sample->DTS - prev_ent->dts)\n\t\t\tprev_ent->Duration = (u32) (sample->DTS - prev_ent->dts) / nsamp;\n\t}\n\tif (trun->nb_samples >= trun->sample_alloc) {\n\t\ttrun->sample_alloc += 50;\n\t\tif (trun->nb_samples >= trun->sample_alloc) trun->sample_alloc = trun->nb_samples+1;\n\t\ttrun->samples = gf_realloc(trun->samples, sizeof(GF_TrunEntry)*trun->sample_alloc);\n\t\tif (!trun->samples) return GF_OUT_OF_MEM;\n\t}\n\n\t//rewrite OD frames\n\tif (traf->trex->track->Media->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\t//this may fail if dependencies are not well done ...\n\t\tGF_Err e = Media_ParseODFrame(traf->trex->track->Media, sample, &od_sample);\n\t\tif (!od_sample) return e;\n\t\tsample = od_sample;\n\t}\n\n\tent.size = sample->dataLength;\n\ttrun->samples[trun->nb_samples] = ent;\n\ttrun->nb_samples ++;\n\ttrun->run_size += ent.size;\n\n\tif (sample->CTS_Offset<0) {\n\t\ttrun->version = 1;\n\t}\n\ttrun->sample_count += sample->nb_pack ? sample->nb_pack : 1;\n\n\t//finally write the data\n\tif (sample->dataLength) {\n\t\tu32 res = 0;\n\t\tif (!traf->DataCache) {\n\t\t\tif (movie->moof_first && movie->on_block_out && (ref || trun->sample_refs)) {\n\t\t\t\tGF_TrafSampleRef *sref;\n\t\t\t\tif (!trun->sample_refs) trun->sample_refs = gf_list_new();\n\t\t\t\tGF_SAFEALLOC(sref, GF_TrafSampleRef);\n\t\t\t\tif (!sref) return GF_OUT_OF_MEM;\n\t\t\t\tif (ref && *ref && !od_sample) {\n\t\t\t\t\tsref->data = sample->data;\n\t\t\t\t\tsref->len = sample->dataLength;\n\t\t\t\t\tsref->ref = *ref;\n\t\t\t\t\tsref->ref_offset = ref_offset;\n\t\t\t\t\t*ref = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tsref->data = gf_malloc(sample->dataLength);\n\t\t\t\t\tif (!sref->data) {\n\t\t\t\t\t\tgf_free(sref);\n\t\t\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(sref->data, sample->data, sample->dataLength);\n\t\t\t\t\tsref->len = sample->dataLength;\n\t\t\t\t}\n\t\t\t\tres = sref->len;\n\t\t\t\ttraf->trun_ref_size += res;\n\t\t\t\tmovie->moof->trun_ref_size += res;\n\t\t\t\tgf_list_add(trun->sample_refs, sref);\n\t\t\t} else {\n\t\t\t\tres = gf_bs_write_data(movie->editFileMap->bs, sample->data, sample->dataLength);\n\t\t\t}\n\t\t} else if (trun->cache) {\n\t\t\tres = gf_bs_write_data(trun->cache, sample->data, sample->dataLength);\n\t\t} else {\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\tif (res!=sample->dataLength) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso fragment] Could not add a sample with a size of %u bytes\\n\", sample->dataLength));\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\n\t}\n\tif (od_sample) gf_isom_sample_del(&od_sample);\n\n\tif (traf->trex->tfra) {\n\t\tGF_RandomAccessEntry *raf;\n\t\traf = &traf->trex->tfra->entries[traf->trex->tfra->nb_entries-1];\n\t\t//if sample is sync, store its time and trun number\n\t\tif (!raf->trun_number && sample->IsRAP) {\n\t\t\traf->time = sample->DTS + sample->CTS_Offset;\n\t\t\traf->trun_number = gf_list_count(traf->TrackRuns);\n\t\t\traf->sample_number = trun->sample_count;\n\t\t}\n\t}\n\treturn GF_OK;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 83,
    "critical_vars": [
      "e"
    ],
    "function": "abst_box_read",
    "filename": "gpac/CVE-2021-32132/CVE-2021-32132_CWE-476_e74be5976a6fee059c638050a237893f7e9a3b23_box_code_adobe.c.diff",
    "function_code": "GF_Err abst_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;\n\tint i;\n\tu32 tmp_strsize;\n\tchar *tmp_str;\n\tBool zfound=GF_FALSE;\n\tGF_Err e;\n\n\tISOM_DECREASE_SIZE(ptr, 25)\n\tptr->bootstrapinfo_version = gf_bs_read_u32(bs);\n\tptr->profile = gf_bs_read_int(bs, 2);\n\tptr->live = gf_bs_read_int(bs, 1);\n\tptr->update = gf_bs_read_int(bs, 1);\n\tptr->reserved = gf_bs_read_int(bs, 4);\n\tptr->time_scale = gf_bs_read_u32(bs);\n\tptr->current_media_time = gf_bs_read_u64(bs);\n\tptr->smpte_time_code_offset = gf_bs_read_u64(bs);\n\n\ti=0;\n\tif (ptr->size<8) return GF_ISOM_INVALID_FILE;\n\ttmp_strsize =(u32)ptr->size;\n\ttmp_str = gf_malloc(sizeof(char)*tmp_strsize);\n\tif (!tmp_str) return GF_OUT_OF_MEM;\n\tmemset(tmp_str, 0, sizeof(char)*tmp_strsize);\n\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i]) {\n\t\t\tzfound = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (!zfound)\n\t\treturn GF_ISOM_INVALID_FILE;\n\tif (i) {\n\t\tptr->movie_identifier = gf_strdup(tmp_str);\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->server_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->server_entry_count; i++) {\n\t\tint j=0;\n\t\tzfound = GF_FALSE;\n\t\ttmp_strsize=(u32)ptr->size;\n\t\twhile (tmp_strsize) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j]) {\n\t\t\t\tzfound = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\tif (!zfound)\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tif (j) {\n\t\t\tgf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);\n\t\t}\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->quality_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tint j=0;\n\t\tzfound = GF_FALSE;\n\t\ttmp_strsize=(u32)ptr->size;\n\t\twhile (tmp_strsize) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j]) {\n\t\t\t\tzfound = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\n\t\tif (!zfound)\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tif (j) {\n\t\t\tgf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);\n\t\t}\n\t}\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size;\n\tzfound = GF_FALSE;\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i]) {\n\t\t\tzfound = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (!zfound)\n\t\treturn GF_ISOM_INVALID_FILE;\n\tif (i) {\n\t\tptr->drm_data = gf_strdup(tmp_str);\n\t}\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size;\n\tzfound = GF_FALSE;\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i]) {\n\t\t\tzfound = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (!zfound)\n\t\treturn GF_ISOM_INVALID_FILE;\n\tif (i) {\n\t\tptr->meta_data = gf_strdup(tmp_str);\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->segment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->segment_run_table_count; i++) {\n\t\tGF_AdobeSegmentRunTableBox *asrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&asrt, bs);\n\t\tif (e) {\n\t\t\tif (asrt) gf_isom_box_del((GF_Box*)asrt);\n\t\t\tgf_free(tmp_str);\n\t\t\treturn e;\n\t\t}\n\t\tgf_list_add(ptr->segment_run_table_entries, asrt);\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->fragment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->fragment_run_table_count; i++) {\n\t\tGF_AdobeFragmentRunTableBox *afrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&afrt, bs);\n\t\tif (e) {\n\t\t\tif (afrt) gf_isom_box_del((GF_Box*)afrt);\n\t\t\tgf_free(tmp_str);\n\t\t\treturn e;\n\t\t}\n\t\tgf_list_add(ptr->fragment_run_table_entries, afrt);\n\t}\n\n\tgf_free(tmp_str);\n\n\treturn GF_OK;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 83,
    "critical_vars": [
      "e"
    ],
    "function": "abst_box_read",
    "filename": "gpac/CVE-2021-32132/CVE-2021-32132_CWE-476_e74be5976a6fee059c638050a237893f7e9a3b23_box_code_adobe.c.diff",
    "function_code": "GF_Err abst_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;\n\tint i;\n\tu32 tmp_strsize;\n\tchar *tmp_str;\n\tBool zfound=GF_FALSE;\n\tGF_Err e = GF_OK;\n\n\tISOM_DECREASE_SIZE(ptr, 25)\n\tptr->bootstrapinfo_version = gf_bs_read_u32(bs);\n\tptr->profile = gf_bs_read_int(bs, 2);\n\tptr->live = gf_bs_read_int(bs, 1);\n\tptr->update = gf_bs_read_int(bs, 1);\n\tptr->reserved = gf_bs_read_int(bs, 4);\n\tptr->time_scale = gf_bs_read_u32(bs);\n\tptr->current_media_time = gf_bs_read_u64(bs);\n\tptr->smpte_time_code_offset = gf_bs_read_u64(bs);\n\n\ti=0;\n\tif (ptr->size<8) return GF_ISOM_INVALID_FILE;\n\ttmp_strsize =(u32)ptr->size;\n\ttmp_str = gf_malloc(sizeof(char)*tmp_strsize);\n\tif (!tmp_str) return GF_OUT_OF_MEM;\n\tmemset(tmp_str, 0, sizeof(char)*tmp_strsize);\n\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i]) {\n\t\t\tzfound = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (!zfound) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\tif (i) {\n\t\tptr->movie_identifier = gf_strdup(tmp_str);\n\t}\n\n\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\tptr->server_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->server_entry_count; i++) {\n\t\tint j=0;\n\t\tzfound = GF_FALSE;\n\t\ttmp_strsize=(u32)ptr->size;\n\t\twhile (tmp_strsize) {\n\t\t\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j]) {\n\t\t\t\tzfound = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\tif (!zfound) {\n\t\t\te = GF_ISOM_INVALID_FILE;\n\t\t\tgoto exit;\n\t\t}\n\t\tif (j) {\n\t\t\tgf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);\n\t\t}\n\t}\n\tif (ptr->server_entry_count != gf_list_count(ptr->server_entry_table)) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\n\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\tptr->quality_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tint j=0;\n\t\tzfound = GF_FALSE;\n\t\ttmp_strsize=(u32)ptr->size;\n\t\twhile (tmp_strsize) {\n\t\t\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j]) {\n\t\t\t\tzfound = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\n\t\tif (!zfound) {\n\t\t\te = GF_ISOM_INVALID_FILE;\n\t\t\tgoto exit;\n\t\t}\n\t\tif (j) {\n\t\t\tgf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);\n\t\t}\n\t}\n\tif (ptr->quality_entry_count != gf_list_count(ptr->quality_entry_table)) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size;\n\tzfound = GF_FALSE;\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i]) {\n\t\t\tzfound = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (!zfound) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\n\tif (i) {\n\t\tptr->drm_data = gf_strdup(tmp_str);\n\t}\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size;\n\tzfound = GF_FALSE;\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i]) {\n\t\t\tzfound = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (!zfound) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\n\tif (i) {\n\t\tptr->meta_data = gf_strdup(tmp_str);\n\t}\n\n\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\tptr->segment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->segment_run_table_count; i++) {\n\t\tGF_AdobeSegmentRunTableBox *asrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&asrt, bs);\n\t\tif (e) {\n\t\t\tif (asrt) gf_isom_box_del((GF_Box*)asrt);\n\t\t\tgoto exit;\n\t\t}\n\t\tgf_list_add(ptr->segment_run_table_entries, asrt);\n\t}\n\tif (ptr->segment_run_table_count != gf_list_count(ptr->segment_run_table_entries)) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\n\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\tptr->fragment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->fragment_run_table_count; i++) {\n\t\tGF_AdobeFragmentRunTableBox *afrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&afrt, bs);\n\t\tif (e) {\n\t\t\tif (afrt) gf_isom_box_del((GF_Box*)afrt);\n\t\t\tgoto exit;\n\t\t}\n\t\tgf_list_add(ptr->fragment_run_table_entries, afrt);\n\t}\n\tif (ptr->fragment_run_table_count != gf_list_count(ptr->fragment_run_table_entries)) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\nexit:\n\tgf_free(tmp_str);\n\treturn e;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 1236,
    "critical_vars": [
      "samp->data",
      "samp->dataLength"
    ],
    "function": "gf_hinter_finalize",
    "filename": "gpac/CVE-2021-32437/CVE-2021-32437_CWE-476_1653f31cf874eb6df964bea88d58d8e9b98b485e_isom_hinter.c.diff",
    "function_code": "GF_Err gf_hinter_finalize(GF_ISOFile *file, GF_SDP_IODProfile IOD_Profile, u32 bandwidth)\n{\n\tu32 i, sceneT, odT, descIndex, size, size64;\n\tGF_InitialObjectDescriptor *iod;\n\tGF_SLConfig slc;\n\tGF_ISOSample *samp;\n\tBool remove_ocr;\n\tu8 *buffer;\n\tchar buf64[5000], sdpLine[5100];\n\n\n\tgf_isom_sdp_clean(file);\n\n\tif (bandwidth) {\n\t\tsprintf(buf64, \"b=AS:%d\", bandwidth);\n\t\tgf_isom_sdp_add_line(file, buf64);\n\t}\n    //xtended attribute for copyright\n    if (gf_sys_is_test_mode()) {\n        sprintf(buf64, \"a=x-copyright: %s\", \"MP4/3GP File hinted with GPAC - (c) Telecom ParisTech (http://gpac.io)\");\n    } else {\n        sprintf(buf64, \"a=x-copyright: MP4/3GP File hinted with GPAC %s - %s\", gf_gpac_version(), gf_gpac_copyright() );\n    }\n\tgf_isom_sdp_add_line(file, buf64);\n\n\tif (IOD_Profile == GF_SDP_IOD_NONE) return GF_OK;\n\n\todT = sceneT = 0;\n\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\tif (!gf_isom_is_track_in_root_od(file, i+1)) continue;\n\t\tswitch (gf_isom_get_media_type(file,i+1)) {\n\t\tcase GF_ISOM_MEDIA_OD:\n\t\t\todT = i+1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\t\tsceneT = i+1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tremove_ocr = 0;\n\tif (IOD_Profile == GF_SDP_IOD_ISMA_STRICT) {\n\t\tIOD_Profile = GF_SDP_IOD_ISMA;\n\t\tremove_ocr = 1;\n\t}\n\n\t/*if we want ISMA like iods, we need at least BIFS */\n\tif ( (IOD_Profile == GF_SDP_IOD_ISMA) && !sceneT ) return GF_BAD_PARAM;\n\n\t/*do NOT change PLs, we assume they are correct*/\n\tiod = (GF_InitialObjectDescriptor *) gf_isom_get_root_od(file);\n\tif (!iod) return GF_NOT_SUPPORTED;\n\n\t/*rewrite an IOD with good SL config - embbed data if possible*/\n\tif (IOD_Profile == GF_SDP_IOD_ISMA) {\n\t\tGF_ESD *esd;\n\t\tBool is_ok = 1;\n\t\twhile (gf_list_count(iod->ESDescriptors)) {\n\t\t\tesd = (GF_ESD*)gf_list_get(iod->ESDescriptors, 0);\n\t\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\t\t\tgf_list_rem(iod->ESDescriptors, 0);\n\t\t}\n\n\n\t\t/*get OD esd, and embbed stream data if possible*/\n\t\tif (odT) {\n\t\t\tesd = gf_isom_get_esd(file, odT, 1);\n\t\t\tif (gf_isom_get_sample_count(file, odT)==1) {\n\t\t\t\tsamp = gf_isom_get_sample(file, odT, 1, &descIndex);\n\t\t\t\tif (samp && gf_hinter_can_embbed_data(samp->data, samp->dataLength, GF_STREAM_OD)) {\n\t\t\t\t\tInitSL_NULL(&slc);\n\t\t\t\t\tslc.predefined = 0;\n\t\t\t\t\tslc.hasRandomAccessUnitsOnlyFlag = 1;\n\t\t\t\t\tslc.timeScale = slc.timestampResolution = gf_isom_get_media_timescale(file, odT);\n\t\t\t\t\tslc.OCRResolution = 1000;\n\t\t\t\t\tslc.startCTS = samp->DTS+samp->CTS_Offset;\n\t\t\t\t\tslc.startDTS = samp->DTS;\n\t\t\t\t\t//set the SL for future extraction\n\t\t\t\t\tgf_isom_set_extraction_slc(file, odT, 1, &slc);\n\n\t\t\t\t\tsize64 = gf_base64_encode(samp->data, samp->dataLength, buf64, 2000);\n\t\t\t\t\tbuf64[size64] = 0;\n\t\t\t\t\tsprintf(sdpLine, \"data:application/mpeg4-od-au;base64,%s\", buf64);\n\n\t\t\t\t\tesd->decoderConfig->avgBitrate = 0;\n\t\t\t\t\tesd->decoderConfig->bufferSizeDB = samp->dataLength;\n\t\t\t\t\tesd->decoderConfig->maxBitrate = 0;\n\t\t\t\t\tsize64 = (u32) strlen(sdpLine)+1;\n\t\t\t\t\tesd->URLString = (char*)gf_malloc(sizeof(char) * size64);\n\t\t\t\t\tstrcpy(esd->URLString, sdpLine);\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_RTP, (\"[rtp hinter] OD sample too large to be embedded in IOD - ISMA disabled\\n\"));\n\t\t\t\t\tis_ok = 0;\n\t\t\t\t}\n\t\t\t\tgf_isom_sample_del(&samp);\n\t\t\t}\n\t\t\tif (remove_ocr) esd->OCRESID = 0;\n\t\t\telse if (esd->OCRESID == esd->ESID) esd->OCRESID = 0;\n\n\t\t\t//OK, add this to our IOD\n\t\t\tgf_list_add(iod->ESDescriptors, esd);\n\t\t}\n\n\t\tesd = gf_isom_get_esd(file, sceneT, 1);\n\t\tif (gf_isom_get_sample_count(file, sceneT)==1) {\n\t\t\tsamp = gf_isom_get_sample(file, sceneT, 1, &descIndex);\n\t\t\tif (gf_hinter_can_embbed_data(samp->data, samp->dataLength, GF_STREAM_SCENE)) {\n\n\t\t\t\tslc.timeScale = slc.timestampResolution = gf_isom_get_media_timescale(file, sceneT);\n\t\t\t\tslc.OCRResolution = 1000;\n\t\t\t\tslc.startCTS = samp->DTS+samp->CTS_Offset;\n\t\t\t\tslc.startDTS = samp->DTS;\n\t\t\t\t//set the SL for future extraction\n\t\t\t\tgf_isom_set_extraction_slc(file, sceneT, 1, &slc);\n\t\t\t\t//encode in Base64 the sample\n\t\t\t\tsize64 = gf_base64_encode(samp->data, samp->dataLength, buf64, 2000);\n\t\t\t\tbuf64[size64] = 0;\n\t\t\t\tsprintf(sdpLine, \"data:application/mpeg4-bifs-au;base64,%s\", buf64);\n\n\t\t\t\tesd->decoderConfig->avgBitrate = 0;\n\t\t\t\tesd->decoderConfig->bufferSizeDB = samp->dataLength;\n\t\t\t\tesd->decoderConfig->maxBitrate = 0;\n\t\t\t\tesd->URLString = (char*)gf_malloc(sizeof(char) * (strlen(sdpLine)+1));\n\t\t\t\tstrcpy(esd->URLString, sdpLine);\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[rtp hinter] Scene description sample too large to be embedded in IOD - ISMA disabled\\n\"));\n\t\t\t\tis_ok = 0;\n\t\t\t}\n\t\t\tgf_isom_sample_del(&samp);\n\t\t}\n\t\tif (remove_ocr) esd->OCRESID = 0;\n\t\telse if (esd->OCRESID == esd->ESID) esd->OCRESID = 0;\n\n\t\tgf_list_add(iod->ESDescriptors, esd);\n\n\t\tif (is_ok) {\n\t\t\tu32 has_a, has_v, has_i_a, has_i_v;\n\t\t\thas_a = has_v = has_i_a = has_i_v = 0;\n\t\t\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\t\t\tesd = gf_isom_get_esd(file, i+1, 1);\n\t\t\t\tif (!esd) continue;\n\t\t\t\tif (esd->decoderConfig->streamType==GF_STREAM_VISUAL) {\n\t\t\t\t\tif (esd->decoderConfig->objectTypeIndication==GF_CODECID_MPEG4_PART2) has_i_v ++;\n\t\t\t\t\telse has_v++;\n\t\t\t\t} else if (esd->decoderConfig->streamType==GF_STREAM_AUDIO) {\n\t\t\t\t\tif (esd->decoderConfig->objectTypeIndication==GF_CODECID_AAC_MPEG4) has_i_a ++;\n\t\t\t\t\telse has_a++;\n\t\t\t\t}\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *)esd);\n\t\t\t}\n\t\t\t/*only 1 MPEG-4 visual max and 1 MPEG-4 audio max for ISMA compliancy*/\n\t\t\tif (!has_v && !has_a && (has_i_v<=1) && (has_i_a<=1)) {\n\t\t\t\tsprintf(sdpLine, \"a=isma-compliance:1,1.0,1\");\n\t\t\t\tgf_isom_sdp_add_line(file, sdpLine);\n\t\t\t}\n\t\t}\n\t}\n\n\t//encode the IOD\n\tbuffer = NULL;\n\tsize = 0;\n\tgf_odf_desc_write((GF_Descriptor *) iod, &buffer, &size);\n\tgf_odf_desc_del((GF_Descriptor *)iod);\n\n\t//encode in Base64 the iod\n\tsize64 = gf_base64_encode(buffer, size, buf64, 2000);\n\tbuf64[size64] = 0;\n\tgf_free(buffer);\n\n\tsprintf(sdpLine, \"a=mpeg4-iod:\\\"data:application/mpeg4-iod;base64,%s\\\"\", buf64);\n\tgf_isom_sdp_add_line(file, sdpLine);\n\n\treturn GF_OK;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1236,
    "critical_vars": [
      "samp",
      "samp->data",
      "samp->dataLength"
    ],
    "function": "gf_hinter_finalize",
    "filename": "gpac/CVE-2021-32437/CVE-2021-32437_CWE-476_1653f31cf874eb6df964bea88d58d8e9b98b485e_isom_hinter.c.diff",
    "function_code": "GF_Err gf_hinter_finalize(GF_ISOFile *file, GF_SDP_IODProfile IOD_Profile, u32 bandwidth)\n{\n\tu32 i, sceneT, odT, descIndex, size, size64;\n\tGF_InitialObjectDescriptor *iod;\n\tGF_SLConfig slc;\n\tGF_ISOSample *samp;\n\tBool remove_ocr;\n\tu8 *buffer;\n\tchar buf64[5000], sdpLine[5100];\n\n\n\tgf_isom_sdp_clean(file);\n\n\tif (bandwidth) {\n\t\tsprintf(buf64, \"b=AS:%d\", bandwidth);\n\t\tgf_isom_sdp_add_line(file, buf64);\n\t}\n    //xtended attribute for copyright\n    if (gf_sys_is_test_mode()) {\n        sprintf(buf64, \"a=x-copyright: %s\", \"MP4/3GP File hinted with GPAC - (c) Telecom ParisTech (http://gpac.io)\");\n    } else {\n        sprintf(buf64, \"a=x-copyright: MP4/3GP File hinted with GPAC %s - %s\", gf_gpac_version(), gf_gpac_copyright() );\n    }\n\tgf_isom_sdp_add_line(file, buf64);\n\n\tif (IOD_Profile == GF_SDP_IOD_NONE) return GF_OK;\n\n\todT = sceneT = 0;\n\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\tif (!gf_isom_is_track_in_root_od(file, i+1)) continue;\n\t\tswitch (gf_isom_get_media_type(file,i+1)) {\n\t\tcase GF_ISOM_MEDIA_OD:\n\t\t\todT = i+1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\t\tsceneT = i+1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tremove_ocr = 0;\n\tif (IOD_Profile == GF_SDP_IOD_ISMA_STRICT) {\n\t\tIOD_Profile = GF_SDP_IOD_ISMA;\n\t\tremove_ocr = 1;\n\t}\n\n\t/*if we want ISMA like iods, we need at least BIFS */\n\tif ( (IOD_Profile == GF_SDP_IOD_ISMA) && !sceneT ) return GF_BAD_PARAM;\n\n\t/*do NOT change PLs, we assume they are correct*/\n\tiod = (GF_InitialObjectDescriptor *) gf_isom_get_root_od(file);\n\tif (!iod) return GF_NOT_SUPPORTED;\n\n\t/*rewrite an IOD with good SL config - embbed data if possible*/\n\tif (IOD_Profile == GF_SDP_IOD_ISMA) {\n\t\tGF_ESD *esd;\n\t\tBool is_ok = 1;\n\t\twhile (gf_list_count(iod->ESDescriptors)) {\n\t\t\tesd = (GF_ESD*)gf_list_get(iod->ESDescriptors, 0);\n\t\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\t\t\tgf_list_rem(iod->ESDescriptors, 0);\n\t\t}\n\n\n\t\t/*get OD esd, and embbed stream data if possible*/\n\t\tif (odT) {\n\t\t\tesd = gf_isom_get_esd(file, odT, 1);\n\t\t\tif (gf_isom_get_sample_count(file, odT)==1) {\n\t\t\t\tsamp = gf_isom_get_sample(file, odT, 1, &descIndex);\n\t\t\t\tif (samp && gf_hinter_can_embbed_data(samp->data, samp->dataLength, GF_STREAM_OD)) {\n\t\t\t\t\tInitSL_NULL(&slc);\n\t\t\t\t\tslc.predefined = 0;\n\t\t\t\t\tslc.hasRandomAccessUnitsOnlyFlag = 1;\n\t\t\t\t\tslc.timeScale = slc.timestampResolution = gf_isom_get_media_timescale(file, odT);\n\t\t\t\t\tslc.OCRResolution = 1000;\n\t\t\t\t\tslc.startCTS = samp->DTS+samp->CTS_Offset;\n\t\t\t\t\tslc.startDTS = samp->DTS;\n\t\t\t\t\t//set the SL for future extraction\n\t\t\t\t\tgf_isom_set_extraction_slc(file, odT, 1, &slc);\n\n\t\t\t\t\tsize64 = gf_base64_encode(samp->data, samp->dataLength, buf64, 2000);\n\t\t\t\t\tbuf64[size64] = 0;\n\t\t\t\t\tsprintf(sdpLine, \"data:application/mpeg4-od-au;base64,%s\", buf64);\n\n\t\t\t\t\tesd->decoderConfig->avgBitrate = 0;\n\t\t\t\t\tesd->decoderConfig->bufferSizeDB = samp->dataLength;\n\t\t\t\t\tesd->decoderConfig->maxBitrate = 0;\n\t\t\t\t\tsize64 = (u32) strlen(sdpLine)+1;\n\t\t\t\t\tesd->URLString = (char*)gf_malloc(sizeof(char) * size64);\n\t\t\t\t\tstrcpy(esd->URLString, sdpLine);\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_RTP, (\"[rtp hinter] OD sample too large to be embedded in IOD - ISMA disabled\\n\"));\n\t\t\t\t\tis_ok = 0;\n\t\t\t\t}\n\t\t\t\tgf_isom_sample_del(&samp);\n\t\t\t}\n\t\t\tif (remove_ocr) esd->OCRESID = 0;\n\t\t\telse if (esd->OCRESID == esd->ESID) esd->OCRESID = 0;\n\n\t\t\t//OK, add this to our IOD\n\t\t\tgf_list_add(iod->ESDescriptors, esd);\n\t\t}\n\n\t\tesd = gf_isom_get_esd(file, sceneT, 1);\n\t\tif (gf_isom_get_sample_count(file, sceneT)==1) {\n\t\t\tsamp = gf_isom_get_sample(file, sceneT, 1, &descIndex);\n\t\t\tif (samp && gf_hinter_can_embbed_data(samp->data, samp->dataLength, GF_STREAM_SCENE)) {\n\n\t\t\t\tslc.timeScale = slc.timestampResolution = gf_isom_get_media_timescale(file, sceneT);\n\t\t\t\tslc.OCRResolution = 1000;\n\t\t\t\tslc.startCTS = samp->DTS+samp->CTS_Offset;\n\t\t\t\tslc.startDTS = samp->DTS;\n\t\t\t\t//set the SL for future extraction\n\t\t\t\tgf_isom_set_extraction_slc(file, sceneT, 1, &slc);\n\t\t\t\t//encode in Base64 the sample\n\t\t\t\tsize64 = gf_base64_encode(samp->data, samp->dataLength, buf64, 2000);\n\t\t\t\tbuf64[size64] = 0;\n\t\t\t\tsprintf(sdpLine, \"data:application/mpeg4-bifs-au;base64,%s\", buf64);\n\n\t\t\t\tesd->decoderConfig->avgBitrate = 0;\n\t\t\t\tesd->decoderConfig->bufferSizeDB = samp->dataLength;\n\t\t\t\tesd->decoderConfig->maxBitrate = 0;\n\t\t\t\tesd->URLString = (char*)gf_malloc(sizeof(char) * (strlen(sdpLine)+1));\n\t\t\t\tstrcpy(esd->URLString, sdpLine);\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[rtp hinter] Scene description sample too large to be embedded in IOD - ISMA disabled\\n\"));\n\t\t\t\tis_ok = 0;\n\t\t\t}\n\t\t\tgf_isom_sample_del(&samp);\n\t\t}\n\t\tif (remove_ocr) esd->OCRESID = 0;\n\t\telse if (esd->OCRESID == esd->ESID) esd->OCRESID = 0;\n\n\t\tgf_list_add(iod->ESDescriptors, esd);\n\n\t\tif (is_ok) {\n\t\t\tu32 has_a, has_v, has_i_a, has_i_v;\n\t\t\thas_a = has_v = has_i_a = has_i_v = 0;\n\t\t\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\t\t\tesd = gf_isom_get_esd(file, i+1, 1);\n\t\t\t\tif (!esd) continue;\n\t\t\t\tif (esd->decoderConfig->streamType==GF_STREAM_VISUAL) {\n\t\t\t\t\tif (esd->decoderConfig->objectTypeIndication==GF_CODECID_MPEG4_PART2) has_i_v ++;\n\t\t\t\t\telse has_v++;\n\t\t\t\t} else if (esd->decoderConfig->streamType==GF_STREAM_AUDIO) {\n\t\t\t\t\tif (esd->decoderConfig->objectTypeIndication==GF_CODECID_AAC_MPEG4) has_i_a ++;\n\t\t\t\t\telse has_a++;\n\t\t\t\t}\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *)esd);\n\t\t\t}\n\t\t\t/*only 1 MPEG-4 visual max and 1 MPEG-4 audio max for ISMA compliancy*/\n\t\t\tif (!has_v && !has_a && (has_i_v<=1) && (has_i_a<=1)) {\n\t\t\t\tsprintf(sdpLine, \"a=isma-compliance:1,1.0,1\");\n\t\t\t\tgf_isom_sdp_add_line(file, sdpLine);\n\t\t\t}\n\t\t}\n\t}\n\n\t//encode the IOD\n\tbuffer = NULL;\n\tsize = 0;\n\tgf_odf_desc_write((GF_Descriptor *) iod, &buffer, &size);\n\tgf_odf_desc_del((GF_Descriptor *)iod);\n\n\t//encode in Base64 the iod\n\tsize64 = gf_base64_encode(buffer, size, buf64, 2000);\n\tbuf64[size64] = 0;\n\tgf_free(buffer);\n\n\tsprintf(sdpLine, \"a=mpeg4-iod:\\\"data:application/mpeg4-iod;base64,%s\\\"\", buf64);\n\tgf_isom_sdp_add_line(file, sdpLine);\n\n\treturn GF_OK;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 1627,
    "critical_vars": [
      "dump",
      "sdp"
    ],
    "function": "dump_isom_sdp",
    "filename": "gpac/CVE-2020-23932/CVE-2020-23932_CWE-476_ce01bd15f711d4575b7424b54b3a395ec64c1784_filedump.c.diff",
    "function_code": "#ifndef GPAC_DISABLE_ISOM_HINTING\n\nvoid dump_isom_sdp(GF_ISOFile *file, char *inName, Bool is_final_name)\n{\n\tconst char *sdp;\n\tu32 size, i;\n\tFILE *dump;\n\n\tif (inName) {\n\t\tchar szBuf[1024];\n\t\tstrcpy(szBuf, inName);\n\t\tif (!is_final_name) {\n\t\t\tchar *ext = strchr(szBuf, '.');\n\t\t\tif (ext) ext[0] = 0;\n\t\t\tstrcat(szBuf, \"_sdp.txt\");\n\t\t}\n\t\tdump = gf_fopen(szBuf, \"wt\");\n\t\tif (!dump) {\n\t\t\tfprintf(stderr, \"Failed to open %s for dumping\\n\", szBuf);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tdump = stdout;\n\t\tfprintf(dump, \"* File SDP content *\\n\\n\");\n\t}\n\t//get the movie SDP\n\tgf_isom_sdp_get(file, &sdp, &size);\n\tfprintf(dump, \"%s\", sdp);\n\tfprintf(dump, \"\\r\\n\");\n\n\t//then tracks\n\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\tif (gf_isom_get_media_type(file, i+1) != GF_ISOM_MEDIA_HINT) continue;\n\t\tgf_isom_sdp_track_get(file, i+1, &sdp, &size);\n\t\tfprintf(dump, \"%s\", sdp);\n\t}\n\tfprintf(dump, \"\\n\\n\");",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1627,
    "critical_vars": [
      "sdp",
      "size"
    ],
    "function": "dump_isom_sdp",
    "filename": "gpac/CVE-2020-23932/CVE-2020-23932_CWE-476_ce01bd15f711d4575b7424b54b3a395ec64c1784_filedump.c.diff",
    "function_code": "#ifndef GPAC_DISABLE_ISOM_HINTING\n\nvoid dump_isom_sdp(GF_ISOFile *file, char *inName, Bool is_final_name)\n{\n\tconst char *sdp;\n\tu32 size, i;\n\tFILE *dump;\n\n\tif (inName) {\n\t\tchar szBuf[1024];\n\t\tstrcpy(szBuf, inName);\n\t\tif (!is_final_name) {\n\t\t\tchar *ext = strchr(szBuf, '.');\n\t\t\tif (ext) ext[0] = 0;\n\t\t\tstrcat(szBuf, \"_sdp.txt\");\n\t\t}\n\t\tdump = gf_fopen(szBuf, \"wt\");\n\t\tif (!dump) {\n\t\t\tfprintf(stderr, \"Failed to open %s for dumping\\n\", szBuf);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tdump = stdout;\n\t\tfprintf(dump, \"* File SDP content *\\n\\n\");\n\t}\n\t//get the movie SDP\n\tgf_isom_sdp_get(file, &sdp, &size);\n\tif (sdp && size)\n\t\tfprintf(dump, \"%s\", sdp);\n\tfprintf(dump, \"\\r\\n\");\n\n\t//then tracks\n\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\tif (gf_isom_get_media_type(file, i+1) != GF_ISOM_MEDIA_HINT) continue;\n\t\tgf_isom_sdp_track_get(file, i+1, &sdp, &size);\n\t\tfprintf(dump, \"%s\", sdp);\n\t}\n\tfprintf(dump, \"\\n\\n\");",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1689,
    "critical_vars": [
      "seig_entry"
    ],
    "function": "gf_isom_cenc_get_default_info_internal",
    "filename": "gpac/CVE-2021-31259/CVE-2021-31259_CWE-476_3b84ffcbacf144ce35650df958432f472b6483f8_drm_sample.c.diff",
    "function_code": "void gf_isom_cenc_get_default_info_internal(GF_TrackBox *trak, u32 sampleDescriptionIndex, u32 *container_type, Bool *default_IsEncrypted, u8 *crypt_byte_block, u8 *skip_byte_block, const u8 **key_info, u32 *key_info_size)\n{\n\tGF_ProtectionSchemeInfoBox *sinf;\n\n\n\t//setup all default as not encrypted\n\tif (default_IsEncrypted) *default_IsEncrypted = GF_FALSE;\n\tif (crypt_byte_block) *crypt_byte_block = 0;\n\tif (skip_byte_block) *skip_byte_block = 0;\n\tif (container_type) *container_type = 0;\n\tif (key_info) *key_info = NULL;\n\tif (key_info_size) *key_info_size = 0;\n\n\tsinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CENC_SCHEME, NULL);\n\tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CBC_SCHEME, NULL);\n\tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CENS_SCHEME, NULL);\n\tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CBCS_SCHEME, NULL);\n\tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_PIFF_SCHEME, NULL);\n\n\tif (!sinf) {\n\t\tu32 i, nb_stsd = gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n\t\tfor (i=0; i<nb_stsd; i++) {\n\t\t\tGF_ProtectionSchemeInfoBox *a_sinf;\n\t\t\tGF_SampleEntryBox *sentry=NULL;\n\t\t\tif (i+1==sampleDescriptionIndex) continue;\n\t\t\tsentry = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, i);\n\t\t\ta_sinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(sentry->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\t\t\tif (!a_sinf) continue;\n\t\t\t//signal default (not encrypted)\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (sinf && sinf->info && sinf->info->tenc) {\n\t\tif (default_IsEncrypted) *default_IsEncrypted = sinf->info->tenc->isProtected;\n\t\tif (crypt_byte_block) *crypt_byte_block = sinf->info->tenc->crypt_byte_block;\n\t\tif (skip_byte_block) *skip_byte_block = sinf->info->tenc->skip_byte_block;\n\t\tif (key_info) *key_info = sinf->info->tenc->key_info;\n\t\tif (key_info_size) {\n\t\t\t*key_info_size = 20;\n\t\t\tif (!sinf->info->tenc->key_info[3])\n\t\t\t\t*key_info_size += 1 + sinf->info->tenc->key_info[20];\n\t\t}\n\n\t\t//set default value, overwritten below\n\t\tif (container_type) *container_type = GF_ISOM_BOX_TYPE_SENC;\n\t} else if (sinf && sinf->info && sinf->info->piff_tenc) {\n\t\tif (default_IsEncrypted) *default_IsEncrypted = GF_TRUE;\n\t\tif (key_info) *key_info = sinf->info->piff_tenc->key_info;\n\t\tif (key_info_size) *key_info_size = 19;\n\t\t//set default value, overwritten below\n\t\tif (container_type) *container_type = GF_ISOM_BOX_UUID_PSEC;\n\t} else {\n\t\tu32 i, count = 0;\n\t\tGF_CENCSampleEncryptionGroupEntry *seig_entry = NULL;\n\n\t\tif (!trak->moov->mov->is_smooth)\n\t\t\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription);\n\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_SampleGroupDescriptionBox *sgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, i);\n\t\t\tif (sgdesc->grouping_type!=GF_ISOM_SAMPLE_GROUP_SEIG) continue;\n\t\t\tif (sgdesc->default_description_index)\n\t\t\t\tseig_entry = gf_list_get(sgdesc->group_descriptions, sgdesc->default_description_index-1);\n\t\t\telse\n\t\t\t\tseig_entry = gf_list_get(sgdesc->group_descriptions, 0);\n\t\t\tif (seig_entry && !seig_entry->key_info[0])\n\t\t\t\tseig_entry = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (seig_entry) {\n\t\t\tif (default_IsEncrypted) *default_IsEncrypted = seig_entry->IsProtected;\n\t\t\tif (crypt_byte_block) *crypt_byte_block = seig_entry->crypt_byte_block;\n\t\t\tif (skip_byte_block) *skip_byte_block = seig_entry->skip_byte_block;\n\t\t\tif (key_info) *key_info = seig_entry->key_info;\n\t\t\tif (key_info_size) *key_info_size = seig_entry->key_info_size;\n\t\t\tif (container_type) *container_type = GF_ISOM_BOX_TYPE_SENC;\n\t\t} else {\n\t\t\tif (! trak->moov->mov->is_smooth ) {\n\t\t\t\ttrak->moov->mov->is_smooth = GF_TRUE;\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] senc box without tenc, assuming MS smooth+piff\\n\"));\n\t\t\t}\n\t\t\tif (default_IsEncrypted) *default_IsEncrypted = GF_TRUE;\n\t\t\t//set default value, overwritten below\n\t\t\tif (container_type) *container_type = GF_ISOM_BOX_UUID_PSEC;\n\t\t}\n\t}\n\n\tif (container_type && trak->sample_encryption) {\n\t\tif (trak->sample_encryption->type == GF_ISOM_BOX_TYPE_SENC) *container_type = GF_ISOM_BOX_TYPE_SENC;\n\t\telse if (trak->sample_encryption->type == GF_ISOM_BOX_TYPE_UUID) *container_type = ((GF_UUIDBox*)trak->sample_encryption)->internal_4cc;\n\t}\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 759,
    "critical_vars": [
      "field.far_ptr",
      "sdump"
    ],
    "function": "gf_dump_vrml_simple_field",
    "filename": "gpac/CVE-2022-1035/CVE-2022-1035_CWE-476_3718d583c6ade191dc7979c64f48c001ca6f0243_scene_dump.c.diff",
    "function_code": "static void gf_dump_vrml_simple_field(GF_SceneDumper *sdump, GF_FieldInfo field, GF_Node *parent)\n{\n\tu32 i, sf_type;\n\tGF_ChildNodeItem *list;\n\tvoid *slot_ptr;\n\n\tswitch (field.fieldType) {\n\tcase GF_SG_VRML_SFNODE:\n\t\tassert ( *(GF_Node **)field.far_ptr);\n\t\tgf_dump_vrml_node(sdump, *(GF_Node **)field.far_ptr, 0, NULL);\n\t\treturn;\n\tcase GF_SG_VRML_MFNODE:\n\t\tlist = * ((GF_ChildNodeItem **) field.far_ptr);\n\t\tassert( list );\n\t\tsdump->indent++;\n\t\twhile (list) {\n\t\t\tgf_dump_vrml_node(sdump, list->node, 1, NULL);\n\t\t\tlist = list->next;\n\t\t}\n\t\tsdump->indent--;\n\t\treturn;\n\tcase GF_SG_VRML_SFCOMMANDBUFFER:\n\t\treturn;\n\t}\n\tif (gf_sg_vrml_is_sf_field(field.fieldType)) {\n\t\tif (sdump->XMLDump) StartAttribute(sdump, \"value\");\n\t\tgf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, parent);\n\t\tif (sdump->XMLDump) EndAttribute(sdump);\n\t} else {\n\t\tGenMFField *mffield;\n\t\tmffield = (GenMFField *) field.far_ptr;\n\t\tsf_type = gf_sg_vrml_get_sf_type(field.fieldType);\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"[\");\n\t\t} else if (sf_type==GF_SG_VRML_SFSTRING) {\n\t\t\tgf_fprintf(sdump->trace, \" value=\\'\");\n\t\t} else {\n\t\t\tStartAttribute(sdump, \"value\");\n\t\t}\n\t\tfor (i=0; i<mffield->count; i++) {\n\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\t/*this is to cope with single MFString which shall appear as SF in XMT*/\n\t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, parent);\n\t\t}\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"]\");\n\t\t} else if (sf_type==GF_SG_VRML_SFSTRING) {\n\t\t\tgf_fprintf(sdump->trace, \"\\'\");\n\t\t} else {\n\t\t\tEndAttribute(sdump);\n\t\t}\n\t}\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 208,
    "critical_vars": [
      "sfcb->bufferSize"
    ],
    "function": "gf_bifs_dec_sf_field",
    "filename": "gpac/CVE-2022-1172/CVE-2022-1172_CWE-476_55a183e6b8602369c04ea3836e05436a79fbc7f8_field_decode.c.diff",
    "function_code": "GF_Err gf_bifs_dec_sf_field(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *node, GF_FieldInfo *field, Bool is_mem_com)\n{\n\tGF_Err e;\n\tGF_Node *new_node;\n\tu32 size, length, w, h, i;\n\tchar *buffer;\n\n\t//blindly call unquantize. return is OK, error or GF_EOS\n\tif (codec->ActiveQP && node) {\n\t\te = gf_bifs_dec_unquant_field(codec, bs, node, field);\n\t\tif (e != GF_EOS) return e;\n\t}\n\t//not quantized, use normal scheme\n\tswitch (field->fieldType) {\n\tcase GF_SG_VRML_SFBOOL:\n\t\t* ((SFBool *) field->far_ptr) = (SFBool) gf_bs_read_int(bs, 1);\n\t\tbreak;\n\tcase GF_SG_VRML_SFCOLOR:\n\t\t((SFColor *)field->far_ptr)->red = BD_ReadSFFloat(codec, bs);\n\t\t((SFColor *)field->far_ptr)->green = BD_ReadSFFloat(codec, bs);\n\t\t((SFColor *)field->far_ptr)->blue = BD_ReadSFFloat(codec, bs);\n\t\tbreak;\n\tcase GF_SG_VRML_SFFLOAT:\n\t\t*((SFFloat *)field->far_ptr) = BD_ReadSFFloat(codec, bs);\n\t\tbreak;\n\tcase GF_SG_VRML_SFINT32:\n\t\t*((SFInt32 *)field->far_ptr) = (s32) gf_bs_read_int(bs, 32);\n\t\tbreak;\n\tcase GF_SG_VRML_SFTIME:\n\t\t*((SFTime *)field->far_ptr) = gf_bs_read_double(bs);\n\t\tif (node) BD_CheckSFTimeOffset(codec, node, field);\n\t\tbreak;\n\tcase GF_SG_VRML_SFVEC2F:\n\t\t((SFVec2f *)field->far_ptr)->x = BD_ReadSFFloat(codec, bs);\n\t\t((SFVec2f *)field->far_ptr)->y = BD_ReadSFFloat(codec, bs);\n\t\tbreak;\n\tcase GF_SG_VRML_SFVEC3F:\n\t\t((SFVec3f *)field->far_ptr)->x = BD_ReadSFFloat(codec, bs);\n\t\t((SFVec3f *)field->far_ptr)->y = BD_ReadSFFloat(codec, bs);\n\t\t((SFVec3f *)field->far_ptr)->z = BD_ReadSFFloat(codec, bs);\n\t\tbreak;\n\tcase GF_SG_VRML_SFROTATION:\n\t\t((SFRotation *)field->far_ptr)->x = BD_ReadSFFloat(codec, bs);\n\t\t((SFRotation *)field->far_ptr)->y = BD_ReadSFFloat(codec, bs);\n\t\t((SFRotation *)field->far_ptr)->z = BD_ReadSFFloat(codec, bs);\n\t\t((SFRotation *)field->far_ptr)->q = BD_ReadSFFloat(codec, bs);\n\t\tbreak;\n\tcase GF_SG_VRML_SFSTRING:\n\t\tsize = gf_bs_read_int(bs, 5);\n\t\tlength = gf_bs_read_int(bs, size);\n\t\tif (gf_bs_available(bs) < length) return GF_NON_COMPLIANT_BITSTREAM;\n\n\t\tif (node && (node->sgprivate->tag==TAG_MPEG4_CacheTexture) && (field->fieldIndex<=2)) {\n\t\t\tM_CacheTexture *ct = (M_CacheTexture *) node;\n\t\t\tct->data_len = length;\n\t\t\tif (ct->data) gf_free(ct->data);\n\t\t\tct->data = (u8*)gf_malloc(sizeof(char)*length);\n\t\t\tgf_bs_read_data(bs, (char*)ct->data, length);\n\t\t} else if (node && (node->sgprivate->tag==TAG_MPEG4_BitWrapper) ) {\n\t\t\tM_BitWrapper *bw = (M_BitWrapper*) node;\n\t\t\tif (bw->buffer.buffer) gf_free(bw->buffer.buffer);\n\t\t\tbw->buffer_len = length;\n\t\t\tbw->buffer.buffer = (char*)gf_malloc(sizeof(char)*length);\n\t\t\tgf_bs_read_data(bs, (char*)bw->buffer.buffer, length);\n\t\t} else {\n\t\t\tif ( ((SFString *)field->far_ptr)->buffer ) gf_free( ((SFString *)field->far_ptr)->buffer);\n\t\t\t((SFString *)field->far_ptr)->buffer = (char *)gf_malloc(sizeof(char)*(length+1));\n\t\t\tmemset(((SFString *)field->far_ptr)->buffer , 0, length+1);\n\t\t\tfor (i=0; i<length; i++) {\n\t\t\t\t((SFString *)field->far_ptr)->buffer[i] = gf_bs_read_int(bs, 8);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase GF_SG_VRML_SFURL:\n\t{\n\t\tSFURL *url = (SFURL *) field->far_ptr;\n\t\tsize = gf_bs_read_int(bs, 1);\n\t\tif (size) {\n\t\t\tif (url->url) gf_free(url->url );\n\t\t\turl->url = NULL;\n\t\t\tlength = gf_bs_read_int(bs, 10);\n\t\t\turl->OD_ID = length;\n\t\t} else {\n\t\t\tif ( url->OD_ID ) url->OD_ID = (u32) -1;\n\t\t\tsize = gf_bs_read_int(bs, 5);\n\t\t\tlength = gf_bs_read_int(bs, size);\n\t\t\tif (gf_bs_available(bs) < length) return GF_NON_COMPLIANT_BITSTREAM;\n\t\t\tbuffer = NULL;\n\t\t\tif (length) {\n\t\t\t\tbuffer = (char *)gf_malloc(sizeof(char)*(length+1));\n\t\t\t\tmemset(buffer, 0, length+1);\n\t\t\t\tfor (i=0; i<length; i++) buffer[i] = gf_bs_read_int(bs, 8);\n\t\t\t}\n\t\t\tif (url->url) gf_free( url->url);\n\t\t\t/*if URL is empty set it to NULL*/\n\t\t\tif (buffer && strlen(buffer)) {\n\t\t\t\turl->url = buffer;\n\t\t\t} else {\n\t\t\t\tgf_free(buffer);\n\t\t\t\turl->url = NULL;\n\t\t\t}\n\t\t}\n\t}\n\tbreak;\n\tcase GF_SG_VRML_SFIMAGE:\n\t\tif (((SFImage *)field->far_ptr)->pixels) {\n\t\t\tgf_free(((SFImage *)field->far_ptr)->pixels);\n\t\t\t((SFImage *)field->far_ptr)->pixels = NULL;\n\t\t}\n\t\tw = gf_bs_read_int(bs, 12);\n\t\th = gf_bs_read_int(bs, 12);\n\t\tlength = gf_bs_read_int(bs, 2);\n\n\t\tif (length > 3) length = 3;\n\t\tlength += 1;\n\t\tsize = w * h * length;\n\t\tif (gf_bs_available(bs) < size) return GF_NON_COMPLIANT_BITSTREAM;\n\t\t((SFImage *)field->far_ptr)->width = w;\n\t\t((SFImage *)field->far_ptr)->height = h;\n\t\t((SFImage *)field->far_ptr)->numComponents = length;\n\t\t((SFImage *)field->far_ptr)->pixels = (unsigned char *)gf_malloc(sizeof(char)*size);\n\t\t//WARNING: Buffers are NOT ALIGNED IN THE BITSTREAM\n\t\tfor (i=0; i<size; i++) {\n\t\t\t((SFImage *)field->far_ptr)->pixels[i] = gf_bs_read_int(bs, 8);\n\t\t}\n\t\tbreak;\n\tcase GF_SG_VRML_SFCOMMANDBUFFER:\n\t{\n\t\tSFCommandBuffer *sfcb = (SFCommandBuffer *)field->far_ptr;\n\t\tif (!node) return GF_BAD_PARAM;\n\t\tif (sfcb->buffer) {\n\t\t\tgf_free(sfcb->buffer);\n\t\t\tsfcb->buffer = NULL;\n\t\t\tsfcb->bufferSize = 0;\n\t\t}\n\t\twhile (gf_list_count(sfcb->commandList)) {\n\t\t\tGF_Command *com = (GF_Command*)gf_list_get(sfcb->commandList, 0);\n\t\t\tgf_list_rem(sfcb->commandList, 0);\n\t\t\tgf_sg_command_del(com);\n\t\t}\n\n\t\tsize = gf_bs_read_int(bs, 5);\n\t\tlength = gf_bs_read_int(bs, size);\n\t\tif (gf_bs_available(bs) < length) return GF_NON_COMPLIANT_BITSTREAM;\n\n\t\tsfcb->bufferSize = length;\n\t\tif (length) {\n\t\t\tsfcb->buffer = (unsigned char *)gf_malloc(sizeof(char)*(length));\n\t\t\t//WARNING Buffers are NOT ALIGNED IN THE BITSTREAM\n\t\t\tfor (i=0; i<length; i++) {\n\t\t\t\tsfcb->buffer[i] = gf_bs_read_int(bs, 8);\n\t\t\t}\n\t\t}\n\t\t//notify the node - this is needed in case an enhencement layer replaces the buffer, in which case\n\t\t//the # ID Bits may change\n\t\tSFCommandBufferChanged(codec, node);\n\n\t\t/*\n\t\t 1 - memory mode, register command buffer for later parsing\n\t\t 2 - InputSensor only works on decompressed commands\n\t\t*/\n\t\tif (codec->dec_memory_mode || (node->sgprivate->tag==TAG_MPEG4_InputSensor)) {\n\t\t\tCommandBufferItem *cbi = (CommandBufferItem *)gf_malloc(sizeof(CommandBufferItem));\n\t\t\tcbi->node = node;\n\t\t\tgf_node_register(cbi->node, NULL);\n\t\t\tcbi->cb = sfcb;\n\t\t\tgf_list_add(codec->command_buffers, cbi);\n\t\t}\n\t}\n\tbreak;\n\tcase GF_SG_VRML_SFNODE:\n\t\t//if not memory dec mode, unregister previous node\n\t\t//otherwise the field points to the memory command internal field\n\t\tif (!is_mem_com) {\n\t\t\tGF_Node *old_node = *((GF_Node **) field->far_ptr);\n\t\t\tif (old_node != NULL) {\n\t\t\t\tu32 i, count = gf_list_count(codec->command_buffers);\n\t\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\t\tCommandBufferItem *cbi = (CommandBufferItem*) gf_list_get(codec->command_buffers, i);\n\t\t\t\t\tif (cbi->node == old_node) {\n\t\t\t\t\t\tgf_list_rem(codec->command_buffers, i);\n\t\t\t\t\t\ti--;\n\t\t\t\t\t\tcount--;\n\t\t\t\t\t\tgf_node_unregister(cbi->node, NULL);\n\t\t\t\t\t\tgf_free(cbi);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_node_unregister(old_node, node);\n\t\t\t\t *((GF_Node **) field->far_ptr) = NULL;\n\t\t\t}\n\t\t}\n\t\t//for nodes the field ptr is a ptr to the field, which is a node ptr ;)\n\t\tnew_node = gf_bifs_dec_node(codec, bs, field->NDTtype);\n\t\tif (new_node) {\n\t\t\te = gf_node_register(new_node, is_mem_com ? NULL : node);\n\t\t\tif (e) return e;\n\t\t}\n\t\t//it may happen that new_node is NULL (this is valid for a proto declaration)\n\t\t*((GF_Node **) field->far_ptr) = new_node;\n\t\tbreak;\n\tcase GF_SG_VRML_SFSCRIPT:\n#ifdef GPAC_HAS_QJS\n\t\tcodec->LastError = node ? SFScript_Parse(codec, (SFScript*)field->far_ptr, bs, node) : GF_NON_COMPLIANT_BITSTREAM;\n#else\n\t\treturn GF_NOT_SUPPORTED;\n#endif\n\t\tbreak;\n\tcase GF_SG_VRML_SFATTRREF:\n\t{\n\t\tSFAttrRef *ar = (SFAttrRef *)field->far_ptr;\n\t\tu32 nodeID = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\t\tar->node = gf_sg_find_node(codec->current_graph, nodeID);\n\t\tif (!ar->node) {\n\n\t\t} else {\n\t\t\tu32 nbBitsDEF = gf_get_bit_size(gf_node_get_num_fields_in_mode(ar->node, GF_SG_FIELD_CODING_DEF) - 1);\n\t\t\tu32 field_ref = gf_bs_read_int(bs, nbBitsDEF);\n\t\t\tcodec->LastError = gf_bifs_get_field_index(ar->node, field_ref, GF_SG_FIELD_CODING_DEF, &ar->fieldIndex);\n\t\t}\n\t}\n\tbreak;\n\tdefault:\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\treturn codec->LastError;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1386,
    "critical_vars": [
      "av1->av1_config->config"
    ],
    "function": "AV1_RewriteESDescriptorEx",
    "filename": "gpac/CVE-2021-31262/CVE-2021-31262_CWE-476_b2eab95e07cb5819375a50358d4806a8813b6e50_avc_ext.c.diff",
    "function_code": "void AV1_RewriteESDescriptorEx(GF_MPEGVisualSampleEntryBox *av1, GF_MediaBox *mdia)\n{\n\tGF_BitRateBox *btrt = gf_isom_sample_entry_get_bitrate((GF_SampleEntryBox *)av1, GF_FALSE);\n\n\tif (av1->emul_esd) gf_odf_desc_del((GF_Descriptor *)av1->emul_esd);\n\tav1->emul_esd = gf_odf_desc_esd_new(2);\n\tav1->emul_esd->decoderConfig->streamType = GF_STREAM_VISUAL;\n\tav1->emul_esd->decoderConfig->objectTypeIndication = GF_CODECID_AV1;\n\n\tif (btrt) {\n\t\tav1->emul_esd->decoderConfig->bufferSizeDB = btrt->bufferSizeDB;\n\t\tav1->emul_esd->decoderConfig->avgBitrate = btrt->avgBitrate;\n\t\tav1->emul_esd->decoderConfig->maxBitrate = btrt->maxBitrate;\n\t}\n\tif (av1->av1_config && av1->av1_config->config) {\n\t\tGF_AV1Config *av1_cfg = AV1_DuplicateConfig(av1->av1_config->config);\n\t\tif (av1_cfg) {\n\t\t\tgf_odf_av1_cfg_write(av1_cfg, &av1->emul_esd->decoderConfig->decoderSpecificInfo->data, &av1->emul_esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\tgf_odf_av1_cfg_del(av1_cfg);\n\t\t}\n\t}\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 2410,
    "critical_vars": [
      "entry->av1_config->config"
    ],
    "function": "*gf_isom_av1_config_get",
    "filename": "gpac/CVE-2021-31262/CVE-2021-31262_CWE-476_b2eab95e07cb5819375a50358d4806a8813b6e50_avc_ext.c.diff",
    "function_code": "GF_AV1Config *gf_isom_av1_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tif (gf_isom_get_reference_count(the_file, trackNumber, GF_ISOM_REF_TBAS)) {\n\t\tu32 ref_track;\n\t\tGF_Err e = gf_isom_get_reference(the_file, trackNumber, GF_ISOM_REF_TBAS, 1, &ref_track);\n\t\tif (e == GF_OK) {\n\t\t\ttrackNumber = ref_track;\n\t\t}\n\t}\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex - 1);\n\tif (!entry || !entry->av1_config|| !entry->av1_config->config) return NULL;\n\treturn AV1_DuplicateConfig(entry->av1_config->config);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 742,
    "critical_vars": [
      "ctx->opid"
    ],
    "function": "av1dmx_parse_flush_sample",
    "filename": "gpac/CVE-2021-30015/CVE-2021-30015_CWE-476_13dad7d5ef74ca2e6fe4010f5b03eb12e9bbe0ec_reframe_av1.c.diff",
    "function_code": "static GF_Err av1dmx_parse_flush_sample(GF_Filter *filter, GF_AV1DmxCtx *ctx)\n{\n\tu32 pck_size;\n\tGF_FilterPacket *pck;\n\tu8 *output;\n\n\tif (!ctx->opid)\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\n\tgf_bs_get_content_no_truncate(ctx->state.bs, &ctx->state.frame_obus, &pck_size, &ctx->state.frame_obus_alloc);\n\n\tif (!pck_size) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1Dmx] no frame OBU, skipping OBU\\n\"));\n\t\treturn GF_OK;\n\t}\n\n\tpck = gf_filter_pck_new_alloc(ctx->opid, pck_size, &output);\n\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, pck);\n\n\tgf_filter_pck_set_cts(pck, ctx->cts);\n\tgf_filter_pck_set_sap(pck, ctx->state.frame_state.key_frame ? GF_FILTER_SAP_1 : 0);\n\n\tmemcpy(output, ctx->state.frame_obus, pck_size);\n\n\tif (ctx->deps) {\n\t\tu8 flags = 0;\n\t\t//dependsOn\n\t\tflags = ( ctx->state.frame_state.key_frame) ? 2 : 1;\n\t\tflags <<= 2;\n\t\t//dependedOn\n\t \tflags |= ctx->state.frame_state.refresh_frame_flags ? 1 : 2;\n\t\tflags <<= 2;\n\t\t//hasRedundant\n\t \t//flags |= ctx->has_redundant ? 1 : 2;\n\t \tgf_filter_pck_set_dependency_flags(pck, flags);\n\t}\n\n\tgf_filter_pck_send(pck);\n\n\tav1dmx_update_cts(ctx);\n\tgf_av1_reset_state(&ctx->state, GF_FALSE);\n\n\treturn GF_OK;\n\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "for-Condition",
    "line_old": 11086,
    "critical_vars": [
      "i"
    ],
    "function": "gitn_box_del",
    "filename": "gpac/CVE-2021-4043/CVE-2021-4043_CWE-476_64a2e1b799352ac7d7aad1989bc06e7b0f2b01db_box_code_base.c.diff",
    "function_code": "\nvoid gitn_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *)s;\n\tif (ptr == NULL) return;\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tif (ptr->entries[i].name) gf_free(ptr->entries[i].name);\n\t}\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 11086,
    "critical_vars": [
      "ptr->entries"
    ],
    "function": "gitn_box_del",
    "filename": "gpac/CVE-2021-4043/CVE-2021-4043_CWE-476_64a2e1b799352ac7d7aad1989bc06e7b0f2b01db_box_code_base.c.diff",
    "function_code": "\nvoid gitn_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->entries) {\n\t\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\t\tif (ptr->entries[i].name) gf_free(ptr->entries[i].name);\n\t\t}\n\t\tgf_free(ptr->entries);\n\t}\n\tgf_free(ptr);",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 643,
    "critical_vars": [
      "&my_sl",
      "file",
      "TrackNum"
    ],
    "function": "*gf_hinter_track_new",
    "filename": "gpac/CVE-2021-31258/CVE-2021-31258_CWE-476_ebfa346eff05049718f7b80041093b4c5581c24e_isom_hinter.c.diff",
    "function_code": "GF_RTPHinter *gf_hinter_track_new(GF_ISOFile *file, u32 TrackNum,\n                                  u32 Path_MTU, u32 max_ptime, u32 default_rtp_rate, u32 flags, u8 PayloadID,\n                                  Bool copy_media, u32 InterleaveGroupID, u8 InterleaveGroupPriority, GF_Err *e)\n{\n\n\tGF_SLConfig my_sl;\n\tu32 descIndex, MinSize, MaxSize, avgTS, streamType, codecid, const_dur, nb_ch, maxDTSDelta;\n\tu8 OfficialPayloadID;\n\tu32 TrackMediaSubType, TrackMediaType, hintType, nbEdts, required_rate, force_dts_delta, avc_nalu_size, PL_ID, bandwidth, IV_length, KI_length;\n\tconst char *url, *urn;\n\tchar *mpeg4mode;\n\tBool is_crypted, has_mpeg4_mapping;\n\tGF_RTPHinter *tmp;\n\tGF_ESD *esd;\n\n\t*e = GF_BAD_PARAM;\n\tif (!file || !TrackNum || !gf_isom_get_track_id(file, TrackNum)) return NULL;\n\n\tif (!gf_isom_get_sample_count(file, TrackNum)) {\n\t\t*e = GF_OK;\n\t\treturn NULL;\n\t}\n\t*e = GF_NOT_SUPPORTED;\n\tnbEdts = gf_isom_get_edits_count(file, TrackNum);\n\tif (nbEdts>1) {\n\t\tu64 et, sd, mt;\n\t\tGF_ISOEditType em;\n\t\tgf_isom_get_edit(file, TrackNum, 1, &et, &sd, &mt, &em);\n\t\tif ((nbEdts>2) || (em!=GF_ISOM_EDIT_EMPTY)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[rtp hinter] Cannot hint track whith EditList\\n\"));\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (nbEdts) gf_isom_remove_edits(file, TrackNum);\n\n\tif (!gf_isom_is_track_enabled(file, TrackNum)) return NULL;\n\n\t/*by default NO PL signaled*/\n\tPL_ID = 0;\n\tOfficialPayloadID = 0;\n\tforce_dts_delta = 0;\n\tstreamType = 0;\n\tmpeg4mode = NULL;\n\trequired_rate = 0;\n\tis_crypted = 0;\n\tIV_length = KI_length = 0;\n\tcodecid = 0;\n\tnb_ch = 0;\n\tavc_nalu_size = 0;\n\thas_mpeg4_mapping = 1;\n\tconst_dur = 0;\n\tbandwidth=0;\n\tTrackMediaType = gf_isom_get_media_type(file, TrackNum);\n\n\t/*for max compatibility with QT*/\n\tif (!default_rtp_rate) default_rtp_rate = 90000;\n\n\t/*timed-text is a bit special, we support multiple stream descriptions & co*/\n\tif ( (TrackMediaType==GF_ISOM_MEDIA_TEXT) || (TrackMediaType==GF_ISOM_MEDIA_SUBT)) {\n\t\thintType = GF_RTP_PAYT_3GPP_TEXT;\n\t\tcodecid = GF_CODECID_TEXT_MPEG4;\n\t\tstreamType = GF_STREAM_TEXT;\n\t\t/*fixme - this works cos there's only one PL for text in mpeg4 at the current time*/\n\t\tPL_ID = 0x10;\n\t} else {\n\t\tif (gf_isom_get_sample_description_count(file, TrackNum) > 1) return NULL;\n\n\t\tTrackMediaSubType = gf_isom_get_media_subtype(file, TrackNum, 1);\n\t\tswitch (TrackMediaSubType) {\n\t\tcase GF_ISOM_SUBTYPE_MPEG4_CRYP:\n\t\t\tis_crypted = 1;\n\t\tcase GF_ISOM_SUBTYPE_MPEG4:\n\t\t\tesd = gf_isom_get_esd(file, TrackNum, 1);\n\t\t\thintType = GF_RTP_PAYT_MPEG4;\n\t\t\tif (esd && esd->decoderConfig) {\n\t\t\t\tstreamType = esd->decoderConfig->streamType;\n\t\t\t\tcodecid = esd->decoderConfig->objectTypeIndication;\n\t\t\t\tif (esd->URLString) hintType = 0;\n\t\t\t\t/*AAC*/\n\t\t\t\tif ((streamType==GF_STREAM_AUDIO)\n\t\t\t\t\t&& esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->data\n\t\t\t\t        /*(nb: we use mpeg4 for MPEG-2 AAC)*/\n\t\t\t\t        && ((codecid==GF_CODECID_AAC_MPEG4) || (codecid==GF_CODECID_AAC_MPEG2_MP) || (codecid==GF_CODECID_AAC_MPEG2_LCP) || (codecid==GF_CODECID_AAC_MPEG2_SSRP)) ) {\n\n\t\t\t\t\tu32 sample_rate;\n\t\t\t\t\tGF_M4ADecSpecInfo a_cfg;\n\t\t\t\t\tgf_m4a_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &a_cfg);\n\t\t\t\t\tnb_ch = a_cfg.nb_chan;\n\t\t\t\t\tsample_rate = a_cfg.base_sr;\n\t\t\t\t\tPL_ID = a_cfg.audioPL;\n\t\t\t\t\tswitch (a_cfg.base_object_type) {\n\t\t\t\t\tcase GF_M4A_AAC_MAIN:\n\t\t\t\t\tcase GF_M4A_AAC_LC:\n\t\t\t\t\t\tif (flags & GP_RTP_PCK_USE_LATM_AAC) {\n\t\t\t\t\t\t\thintType = GF_RTP_PAYT_LATM;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tcase GF_M4A_AAC_SBR:\n\t\t\t\t\tcase GF_M4A_AAC_PS:\n\t\t\t\t\tcase GF_M4A_AAC_LTP:\n\t\t\t\t\tcase GF_M4A_AAC_SCALABLE:\n\t\t\t\t\tcase GF_M4A_ER_AAC_LC:\n\t\t\t\t\tcase GF_M4A_ER_AAC_LTP:\n\t\t\t\t\tcase GF_M4A_ER_AAC_SCALABLE:\n\t\t\t\t\t\tmpeg4mode = \"AAC\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_M4A_CELP:\n\t\t\t\t\tcase GF_M4A_ER_CELP:\n\t\t\t\t\t\tmpeg4mode = \"CELP\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\trequired_rate = sample_rate;\n\t\t\t\t}\n\t\t\t\t/*MPEG1/2 audio*/\n\t\t\t\telse if ((streamType==GF_STREAM_AUDIO) && ((codecid==GF_CODECID_MPEG2_PART3) || (codecid==GF_CODECID_MPEG_AUDIO))) {\n\t\t\t\t\tGF_ISOSample *samp = NULL;\n\t\t\t\t\tif (!is_crypted)\n\t\t\t\t\t\t samp = gf_isom_get_sample(file, TrackNum, 1, NULL);\n\n\t\t\t\t\tif (samp && (samp->dataLength>3)) {\n\t\t\t\t\t\tu32 hdr = GF_4CC((u32)samp->data[0], (u8)samp->data[1], (u8)samp->data[2], (u8)samp->data[3]);\n\t\t\t\t\t\tnb_ch = gf_mp3_num_channels(hdr);\n\t\t\t\t\t\thintType = GF_RTP_PAYT_MPEG12_AUDIO;\n\t\t\t\t\t\t/*use official RTP/AVP payload type*/\n\t\t\t\t\t\tOfficialPayloadID = 14;\n\t\t\t\t\t\trequired_rate = 90000;\n\t\t\t\t\t}\n\t\t\t\t\t/*encrypted MP3 must be sent through MPEG-4 generic to signal all ISMACryp stuff*/\n\t\t\t\t\telse {\n\t\t\t\t\t\tu32 sample_rate;\n\t\t\t\t\t\tgf_isom_get_audio_info(file, TrackNum, 1, &sample_rate, &nb_ch, NULL);\n\t\t\t\t\t\trequired_rate = sample_rate;\n\t\t\t\t\t}\n\t\t\t\t\tif (samp)\n\t\t\t\t\t\tgf_isom_sample_del(&samp);\n\n\t\t\t\t}\n\t\t\t\t/*QCELP audio*/\n\t\t\t\telse if ((streamType==GF_STREAM_AUDIO) && (codecid==GF_CODECID_QCELP)) {\n\t\t\t\t\thintType = GF_RTP_PAYT_QCELP;\n\t\t\t\t\tOfficialPayloadID = 12;\n\t\t\t\t\trequired_rate = 8000;\n\t\t\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\t\t\tnb_ch = 1;\n\t\t\t\t}\n\t\t\t\t/*EVRC/SVM audio*/\n\t\t\t\telse if ((streamType==GF_STREAM_AUDIO) && ((codecid==GF_CODECID_EVRC) || (codecid==GF_CODECID_SMV)) ) {\n\t\t\t\t\thintType = GF_RTP_PAYT_EVRC_SMV;\n\t\t\t\t\trequired_rate = 8000;\n\t\t\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\t\t\tnb_ch = 1;\n\t\t\t\t}\n\t\t\t\t/*visual streams*/\n\t\t\t\telse if (streamType==GF_STREAM_VISUAL) {\n\t\t\t\t\tif ((codecid==GF_CODECID_MPEG4_PART2) && esd->decoderConfig->decoderSpecificInfo) {\n\t\t\t\t\t\tGF_M4VDecSpecInfo dsi;\n\t\t\t\t\t\tgf_m4v_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &dsi);\n\t\t\t\t\t\tPL_ID = dsi.VideoPL;\n\t\t\t\t\t}\n\t\t\t\t\t/*MPEG1/2 video*/\n\t\t\t\t\tif ( ((codecid>=GF_CODECID_MPEG2_SIMPLE) && (codecid<=GF_CODECID_MPEG2_422)) || (codecid==GF_CODECID_MPEG1)) {\n\t\t\t\t\t\tif (!is_crypted) {\n\t\t\t\t\t\t\thintType = GF_RTP_PAYT_MPEG12_VIDEO;\n\t\t\t\t\t\t\tOfficialPayloadID = 32;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/*for ISMA*/\n\t\t\t\t\tif (is_crypted) {\n\t\t\t\t\t\t/*that's another pain with ISMACryp, even if no B-frames the DTS is signaled...*/\n\t\t\t\t\t\tif (codecid==GF_CODECID_MPEG4_PART2) force_dts_delta = 22;\n\t\t\t\t\t\telse if ((codecid==GF_CODECID_AVC) || (codecid==GF_CODECID_SVC)) {\n\t\t\t\t\t\t\tflags &= ~GP_RTP_PCK_USE_MULTI;\n\t\t\t\t\t\t\tforce_dts_delta = 22;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tflags |= GP_RTP_PCK_SIGNAL_RAP | GP_RTP_PCK_SIGNAL_TS;\n\t\t\t\t\t}\n\n\t\t\t\t\trequired_rate = default_rtp_rate;\n\t\t\t\t}\n\t\t\t\t/*systems streams*/\n\t\t\t\telse if (gf_isom_has_sync_shadows(file, TrackNum) || gf_isom_has_sample_dependency(file, TrackNum)) {\n\t\t\t\t\tflags |= GP_RTP_PCK_SYSTEMS_CAROUSEL;\n\t\t\t\t}\n\t\t\t\tgf_odf_desc_del((GF_Descriptor*)esd);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\t\thintType = GF_RTP_PAYT_H263;\n\t\t\trequired_rate = 90000;\n\t\t\tstreamType = GF_STREAM_VISUAL;\n\t\t\tOfficialPayloadID = 34;\n\t\t\t/*not 100% compliant (short header is missing) but should still work*/\n\t\t\tcodecid = GF_CODECID_MPEG4_PART2;\n\t\t\tPL_ID = 0x01;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\t\t\trequired_rate = 8000;\n\t\t\thintType = GF_RTP_PAYT_AMR;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\thas_mpeg4_mapping = 0;\n\t\t\tnb_ch = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\t\trequired_rate = 16000;\n\t\t\thintType = GF_RTP_PAYT_AMR_WB;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\thas_mpeg4_mapping = 0;\n\t\t\tnb_ch = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_AVC_H264:\n\t\tcase GF_ISOM_SUBTYPE_AVC2_H264:\n\t\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\t\tcase GF_ISOM_SUBTYPE_AVC4_H264:\n\t\tcase GF_ISOM_SUBTYPE_SVC_H264:\n\t\tcase GF_ISOM_SUBTYPE_MVC_H264:\n\t\t{\n\t\t\tGF_AVCConfig *avcc = gf_isom_avc_config_get(file, TrackNum, 1);\n\t\t\tGF_AVCConfig *svcc = gf_isom_svc_config_get(file, TrackNum, 1);\n\t\t\tGF_AVCConfig *mvcc = gf_isom_mvc_config_get(file, TrackNum, 1);\n\n\t\t\tif (!avcc && !svcc && !mvcc) {\n\t\t\t\t*e = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\trequired_rate = 90000;\t/* \"90 kHz clock rate MUST be used\"*/\n\t\t\thintType = GF_RTP_PAYT_H264_AVC;\n\t\t\tif (TrackMediaSubType==GF_ISOM_SUBTYPE_SVC_H264)\n\t\t\t\thintType = GF_RTP_PAYT_H264_SVC;\n\t\t\telse if (TrackMediaSubType==GF_ISOM_SUBTYPE_MVC_H264)\n\t\t\t\thintType = GF_RTP_PAYT_H264_SVC;\n\t\t\tstreamType = GF_STREAM_VISUAL;\n\t\t\tavc_nalu_size = avcc ? avcc->nal_unit_size : svcc ? svcc->nal_unit_size : mvcc->nal_unit_size;\n\t\t\tcodecid = GF_CODECID_AVC;\n\t\t\tPL_ID = 0x0F;\n\t\t\tgf_odf_avc_cfg_del(avcc);\n\t\t\tgf_odf_avc_cfg_del(svcc);\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_HVC1:\n\t\tcase GF_ISOM_SUBTYPE_HEV1:\n\t\tcase GF_ISOM_SUBTYPE_HVC2:\n\t\tcase GF_ISOM_SUBTYPE_HEV2:\n\t\t{\n\t\t\tGF_HEVCConfig *hevcc = gf_isom_hevc_config_get(file, TrackNum, 1);\n\t\t\tif (!hevcc) {\n\t\t\t\t*e = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\trequired_rate = 90000;\t/* \"90 kHz clock rate MUST be used\"*/\n\t\t\thintType = GF_RTP_PAYT_HEVC;\n\t\t\tstreamType = GF_STREAM_VISUAL;\n\t\t\tavc_nalu_size = hevcc->nal_unit_size;\n\t\t\tcodecid = GF_CODECID_HEVC;\n\t\t\tPL_ID = 0x0F;\n\t\t\tflags |= GP_RTP_PCK_USE_MULTI;\n\t\t\tgf_odf_hevc_cfg_del(hevcc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t\t\trequired_rate = 8000;\n\t\t\thintType = GF_RTP_PAYT_QCELP;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\tcodecid = GF_CODECID_QCELP;\n\t\t\tOfficialPayloadID = 12;\n\t\t\tnb_ch = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\t\trequired_rate = 8000;\n\t\t\thintType = GF_RTP_PAYT_EVRC_SMV;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\tcodecid = (TrackMediaSubType==GF_ISOM_SUBTYPE_3GP_EVRC) ? GF_CODECID_EVRC : GF_CODECID_SMV;\n\t\t\tnb_ch = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_DIMS:\n#if GPAC_ENABLE_3GPP_DIMS_RTP\n\t\t\thintType = GF_RTP_PAYT_3GPP_DIMS;\n\t\t\tstreamType = GF_STREAM_SCENE;\n#else\n\t\t\thintType = 0;\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[RTP Packetizer] 3GPP DIMS over RTP disabled in build\\n\", streamType));\n#endif\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_AC3:\n\t\t\thintType = GF_RTP_PAYT_AC3;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\tgf_isom_get_audio_info(file, TrackNum, 1, NULL, &nb_ch, NULL);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_MP3:\n\t\t{\n\t\t\tGF_ISOSample *samp = gf_isom_get_sample(file, TrackNum, 1, NULL);\n\t\t\tif (samp && (samp->dataLength>3)) {\n\t\t\t\tu32 hdr = GF_4CC((u32)samp->data[0], (u8)samp->data[1], (u8)samp->data[2], (u8)samp->data[3]);\n\t\t\t\tnb_ch = gf_mp3_num_channels(hdr);\n\t\t\t} else {\n\t\t\t\tu32 bps;\n\t\t\t\tgf_isom_get_audio_info(file, TrackNum, 1, &required_rate, &nb_ch, &bps);\n\t\t\t}\n\t\t\thintType = GF_RTP_PAYT_MPEG12_AUDIO;\n\t\t\t/*use official RTP/AVP payload type*/\n\t\t\tOfficialPayloadID = 14;\n\t\t\trequired_rate = 90000;\n\n\t\t\tif (samp)\n\t\t\t\tgf_isom_sample_del(&samp);\n\t\t}\n\t\tbreak;\n\t\tdefault:\n\t\t\t/*ERROR*/\n\t\t\thintType = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*not hintable*/\n\tif (!hintType) return NULL;\n\t/*we only support self-contained files for hinting*/\n\tgf_isom_get_data_reference(file, TrackNum, 1, &url, &urn);\n\tif (url || urn) return NULL;\n\n\t*e = GF_OUT_OF_MEM;\n\tGF_SAFEALLOC(tmp, GF_RTPHinter);\n\tif (!tmp) return NULL;\n\n\t/*override hinter type if requested and possible*/\n\tif (has_mpeg4_mapping && (flags & GP_RTP_PCK_FORCE_MPEG4)) {\n\t\thintType = GF_RTP_PAYT_MPEG4;\n\t\tavc_nalu_size = 0;\n\t}\n\t/*use static payload ID if enabled*/\n\telse if (OfficialPayloadID && (flags & GP_RTP_PCK_USE_STATIC_ID) ) {\n\t\tPayloadID = OfficialPayloadID;\n\t}\n\n\ttmp->file = file;\n\ttmp->TrackNum = TrackNum;\n\ttmp->avc_nalu_size = avc_nalu_size;\n\ttmp->nb_chan = nb_ch;\n\n\t/*spatial scalability check*/\n\ttmp->has_ctts = gf_isom_has_time_offset(file, TrackNum);\n\n\t/*get sample info*/\n\tgf_media_get_sample_average_infos(file, TrackNum, &MinSize, &MaxSize, &avgTS, &maxDTSDelta, &const_dur, &bandwidth);\n\n\t/*systems carousel: we need at least IDX and RAP signaling*/\n\tif (flags & GP_RTP_PCK_SYSTEMS_CAROUSEL) {\n\t\tflags |= GP_RTP_PCK_SIGNAL_RAP;\n\t}\n\n\t/*update flags in MultiSL*/\n\tif (flags & GP_RTP_PCK_USE_MULTI) {\n\t\tif (MinSize != MaxSize) flags |= GP_RTP_PCK_SIGNAL_SIZE;\n\t\tif (!const_dur) flags |= GP_RTP_PCK_SIGNAL_TS;\n\t}\n\tif (tmp->has_ctts) flags |= GP_RTP_PCK_SIGNAL_TS;\n\n\t/*default SL for RTP */\n\tInitSL_RTP(&my_sl);\n\n\tmy_sl.timestampResolution = gf_isom_get_media_timescale(file, TrackNum);\n\t/*override clockrate if set*/\n\tif (required_rate) {\n\t\tDouble sc = required_rate;\n\t\tsc /= my_sl.timestampResolution;\n\t\tmaxDTSDelta = (u32) (maxDTSDelta*sc);\n\t\tmy_sl.timestampResolution = required_rate;\n\t}\n\t/*switch to RTP TS*/\n\tmax_ptime = (u32) (max_ptime * my_sl.timestampResolution / 1000);\n\n\tmy_sl.AUSeqNumLength = gf_get_bit_size(gf_isom_get_sample_count(file, TrackNum));\n\tif (my_sl.AUSeqNumLength>16) my_sl.AUSeqNumLength=16;\n\n\tmy_sl.CUDuration = const_dur;\n\n\tif (gf_isom_has_sync_points(file, TrackNum)) {\n\t\tmy_sl.useRandomAccessPointFlag = 1;\n\t} else {\n\t\tmy_sl.useRandomAccessPointFlag = 0;\n\t\tmy_sl.hasRandomAccessUnitsOnlyFlag = 1;\n\t}\n\n\tif (is_crypted) {\n\t\tBool use_sel_enc;\n\t\tgf_isom_get_ismacryp_info(file, TrackNum, 1, NULL, NULL, NULL, NULL, NULL, &use_sel_enc, &IV_length, &KI_length);\n\t\tif (use_sel_enc) flags |= GP_RTP_PCK_SELECTIVE_ENCRYPTION;\n\t}\n\n\t// in case a different timescale was provided\n\ttmp->OrigTimeScale = gf_isom_get_media_timescale(file, TrackNum);\n\ttmp->rtp_p = gf_rtp_builder_new(hintType, &my_sl, flags, tmp,\n\t                                MP4T_OnNewPacket, MP4T_OnPacketDone,\n\t                                /*if copy, no data ref*/\n\t                                copy_media ? NULL : MP4T_OnDataRef,\n\t                                MP4T_OnData);\n\n\t//init the builder\n\tgf_rtp_builder_init(tmp->rtp_p, PayloadID, Path_MTU, max_ptime,\n\t                    streamType, codecid, PL_ID, MinSize, MaxSize, avgTS, maxDTSDelta, IV_length, KI_length, mpeg4mode);\n\n\t/*ISMA compliance is a pain...*/\n\tif (force_dts_delta) tmp->rtp_p->slMap.DTSDeltaLength = force_dts_delta;\n\n\n\t/*\t\tHint Track Setup\t*/\n\ttmp->TrackID = gf_isom_get_track_id(file, TrackNum);\n\ttmp->HintID = tmp->TrackID + 65535;\n\twhile (gf_isom_get_track_by_id(file, tmp->HintID)) tmp->HintID++;\n\n\ttmp->HintTrack = gf_isom_new_track(file, tmp->HintID, GF_ISOM_MEDIA_HINT, my_sl.timestampResolution);\n\tgf_isom_setup_hint_track(file, tmp->HintTrack, GF_ISOM_HINT_RTP);\n\t/*create a hint description*/\n\tgf_isom_new_hint_description(file, tmp->HintTrack, -1, -1, 0, &descIndex);\n\tgf_isom_rtp_set_timescale(file, tmp->HintTrack, descIndex, my_sl.timestampResolution);\n\n\tif (hintType==GF_RTP_PAYT_MPEG4) {\n\t\ttmp->rtp_p->slMap.CodecID = codecid;\n\t\t/*set this SL for extraction.*/\n\t\tgf_isom_set_extraction_slc(file, TrackNum, 1, &my_sl);\n\t}\n\ttmp->bandwidth = bandwidth;\n\n\t/*set interleaving*/\n\tgf_isom_set_track_interleaving_group(file, TrackNum, InterleaveGroupID);\n\tif (!copy_media) {\n\t\t/*if we don't copy data set hint track and media track in the same group*/\n\t\tgf_isom_set_track_interleaving_group(file, tmp->HintTrack, InterleaveGroupID);\n\t} else {\n\t\tgf_isom_set_track_interleaving_group(file, tmp->HintTrack, InterleaveGroupID + OFFSET_HINT_GROUP_ID);\n\t}\n\t/*use user-secified priority*/\n\tInterleaveGroupPriority*=2;\n\tgf_isom_set_track_priority_in_group(file, TrackNum, InterleaveGroupPriority+1);\n\tgf_isom_set_track_priority_in_group(file, tmp->HintTrack, InterleaveGroupPriority);\n\n#if 0\n#endif\n\t*e = GF_OK;\n\treturn tmp;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 643,
    "critical_vars": [
      "*e"
    ],
    "function": "*gf_hinter_track_new",
    "filename": "gpac/CVE-2021-31258/CVE-2021-31258_CWE-476_ebfa346eff05049718f7b80041093b4c5581c24e_isom_hinter.c.diff",
    "function_code": "GF_RTPHinter *gf_hinter_track_new(GF_ISOFile *file, u32 TrackNum,\n                                  u32 Path_MTU, u32 max_ptime, u32 default_rtp_rate, u32 flags, u8 PayloadID,\n                                  Bool copy_media, u32 InterleaveGroupID, u8 InterleaveGroupPriority, GF_Err *e)\n{\n\n\tGF_SLConfig my_sl;\n\tu32 descIndex, MinSize, MaxSize, avgTS, streamType, codecid, const_dur, nb_ch, maxDTSDelta;\n\tu8 OfficialPayloadID;\n\tu32 TrackMediaSubType, TrackMediaType, hintType, nbEdts, required_rate, force_dts_delta, avc_nalu_size, PL_ID, bandwidth, IV_length, KI_length;\n\tconst char *url, *urn;\n\tchar *mpeg4mode;\n\tBool is_crypted, has_mpeg4_mapping;\n\tGF_RTPHinter *tmp;\n\tGF_ESD *esd;\n\n\t*e = GF_BAD_PARAM;\n\tif (!file || !TrackNum || !gf_isom_get_track_id(file, TrackNum)) return NULL;\n\n\tif (!gf_isom_get_sample_count(file, TrackNum)) {\n\t\t*e = GF_OK;\n\t\treturn NULL;\n\t}\n\t*e = GF_NOT_SUPPORTED;\n\tnbEdts = gf_isom_get_edits_count(file, TrackNum);\n\tif (nbEdts>1) {\n\t\tu64 et, sd, mt;\n\t\tGF_ISOEditType em;\n\t\tgf_isom_get_edit(file, TrackNum, 1, &et, &sd, &mt, &em);\n\t\tif ((nbEdts>2) || (em!=GF_ISOM_EDIT_EMPTY)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[rtp hinter] Cannot hint track whith EditList\\n\"));\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (nbEdts) gf_isom_remove_edits(file, TrackNum);\n\n\tif (!gf_isom_is_track_enabled(file, TrackNum)) return NULL;\n\n\t/*by default NO PL signaled*/\n\tPL_ID = 0;\n\tOfficialPayloadID = 0;\n\tforce_dts_delta = 0;\n\tstreamType = 0;\n\tmpeg4mode = NULL;\n\trequired_rate = 0;\n\tis_crypted = 0;\n\tIV_length = KI_length = 0;\n\tcodecid = 0;\n\tnb_ch = 0;\n\tavc_nalu_size = 0;\n\thas_mpeg4_mapping = 1;\n\tconst_dur = 0;\n\tbandwidth=0;\n\tTrackMediaType = gf_isom_get_media_type(file, TrackNum);\n\n\t/*for max compatibility with QT*/\n\tif (!default_rtp_rate) default_rtp_rate = 90000;\n\n\t/*timed-text is a bit special, we support multiple stream descriptions & co*/\n\tif ( (TrackMediaType==GF_ISOM_MEDIA_TEXT) || (TrackMediaType==GF_ISOM_MEDIA_SUBT)) {\n\t\thintType = GF_RTP_PAYT_3GPP_TEXT;\n\t\tcodecid = GF_CODECID_TEXT_MPEG4;\n\t\tstreamType = GF_STREAM_TEXT;\n\t\t/*fixme - this works cos there's only one PL for text in mpeg4 at the current time*/\n\t\tPL_ID = 0x10;\n\t} else {\n\t\tif (gf_isom_get_sample_description_count(file, TrackNum) > 1) return NULL;\n\n\t\tTrackMediaSubType = gf_isom_get_media_subtype(file, TrackNum, 1);\n\t\tswitch (TrackMediaSubType) {\n\t\tcase GF_ISOM_SUBTYPE_MPEG4_CRYP:\n\t\t\tis_crypted = 1;\n\t\tcase GF_ISOM_SUBTYPE_MPEG4:\n\t\t\tesd = gf_isom_get_esd(file, TrackNum, 1);\n\t\t\thintType = GF_RTP_PAYT_MPEG4;\n\t\t\tif (esd && esd->decoderConfig) {\n\t\t\t\tstreamType = esd->decoderConfig->streamType;\n\t\t\t\tcodecid = esd->decoderConfig->objectTypeIndication;\n\t\t\t\tif (esd->URLString) hintType = 0;\n\t\t\t\t/*AAC*/\n\t\t\t\tif ((streamType==GF_STREAM_AUDIO)\n\t\t\t\t\t&& esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->data\n\t\t\t\t        /*(nb: we use mpeg4 for MPEG-2 AAC)*/\n\t\t\t\t        && ((codecid==GF_CODECID_AAC_MPEG4) || (codecid==GF_CODECID_AAC_MPEG2_MP) || (codecid==GF_CODECID_AAC_MPEG2_LCP) || (codecid==GF_CODECID_AAC_MPEG2_SSRP)) ) {\n\n\t\t\t\t\tu32 sample_rate;\n\t\t\t\t\tGF_M4ADecSpecInfo a_cfg;\n\t\t\t\t\tgf_m4a_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &a_cfg);\n\t\t\t\t\tnb_ch = a_cfg.nb_chan;\n\t\t\t\t\tsample_rate = a_cfg.base_sr;\n\t\t\t\t\tPL_ID = a_cfg.audioPL;\n\t\t\t\t\tswitch (a_cfg.base_object_type) {\n\t\t\t\t\tcase GF_M4A_AAC_MAIN:\n\t\t\t\t\tcase GF_M4A_AAC_LC:\n\t\t\t\t\t\tif (flags & GP_RTP_PCK_USE_LATM_AAC) {\n\t\t\t\t\t\t\thintType = GF_RTP_PAYT_LATM;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tcase GF_M4A_AAC_SBR:\n\t\t\t\t\tcase GF_M4A_AAC_PS:\n\t\t\t\t\tcase GF_M4A_AAC_LTP:\n\t\t\t\t\tcase GF_M4A_AAC_SCALABLE:\n\t\t\t\t\tcase GF_M4A_ER_AAC_LC:\n\t\t\t\t\tcase GF_M4A_ER_AAC_LTP:\n\t\t\t\t\tcase GF_M4A_ER_AAC_SCALABLE:\n\t\t\t\t\t\tmpeg4mode = \"AAC\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_M4A_CELP:\n\t\t\t\t\tcase GF_M4A_ER_CELP:\n\t\t\t\t\t\tmpeg4mode = \"CELP\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\trequired_rate = sample_rate;\n\t\t\t\t}\n\t\t\t\t/*MPEG1/2 audio*/\n\t\t\t\telse if ((streamType==GF_STREAM_AUDIO) && ((codecid==GF_CODECID_MPEG2_PART3) || (codecid==GF_CODECID_MPEG_AUDIO))) {\n\t\t\t\t\tGF_ISOSample *samp = NULL;\n\t\t\t\t\tif (!is_crypted)\n\t\t\t\t\t\t samp = gf_isom_get_sample(file, TrackNum, 1, NULL);\n\n\t\t\t\t\tif (samp && (samp->dataLength>3)) {\n\t\t\t\t\t\tu32 hdr = GF_4CC((u32)samp->data[0], (u8)samp->data[1], (u8)samp->data[2], (u8)samp->data[3]);\n\t\t\t\t\t\tnb_ch = gf_mp3_num_channels(hdr);\n\t\t\t\t\t\thintType = GF_RTP_PAYT_MPEG12_AUDIO;\n\t\t\t\t\t\t/*use official RTP/AVP payload type*/\n\t\t\t\t\t\tOfficialPayloadID = 14;\n\t\t\t\t\t\trequired_rate = 90000;\n\t\t\t\t\t}\n\t\t\t\t\t/*encrypted MP3 must be sent through MPEG-4 generic to signal all ISMACryp stuff*/\n\t\t\t\t\telse {\n\t\t\t\t\t\tu32 sample_rate;\n\t\t\t\t\t\tgf_isom_get_audio_info(file, TrackNum, 1, &sample_rate, &nb_ch, NULL);\n\t\t\t\t\t\trequired_rate = sample_rate;\n\t\t\t\t\t}\n\t\t\t\t\tif (samp)\n\t\t\t\t\t\tgf_isom_sample_del(&samp);\n\n\t\t\t\t}\n\t\t\t\t/*QCELP audio*/\n\t\t\t\telse if ((streamType==GF_STREAM_AUDIO) && (codecid==GF_CODECID_QCELP)) {\n\t\t\t\t\thintType = GF_RTP_PAYT_QCELP;\n\t\t\t\t\tOfficialPayloadID = 12;\n\t\t\t\t\trequired_rate = 8000;\n\t\t\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\t\t\tnb_ch = 1;\n\t\t\t\t}\n\t\t\t\t/*EVRC/SVM audio*/\n\t\t\t\telse if ((streamType==GF_STREAM_AUDIO) && ((codecid==GF_CODECID_EVRC) || (codecid==GF_CODECID_SMV)) ) {\n\t\t\t\t\thintType = GF_RTP_PAYT_EVRC_SMV;\n\t\t\t\t\trequired_rate = 8000;\n\t\t\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\t\t\tnb_ch = 1;\n\t\t\t\t}\n\t\t\t\t/*visual streams*/\n\t\t\t\telse if (streamType==GF_STREAM_VISUAL) {\n\t\t\t\t\tif ((codecid==GF_CODECID_MPEG4_PART2) && esd->decoderConfig->decoderSpecificInfo) {\n\t\t\t\t\t\tGF_M4VDecSpecInfo dsi;\n\t\t\t\t\t\tgf_m4v_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &dsi);\n\t\t\t\t\t\tPL_ID = dsi.VideoPL;\n\t\t\t\t\t}\n\t\t\t\t\t/*MPEG1/2 video*/\n\t\t\t\t\tif ( ((codecid>=GF_CODECID_MPEG2_SIMPLE) && (codecid<=GF_CODECID_MPEG2_422)) || (codecid==GF_CODECID_MPEG1)) {\n\t\t\t\t\t\tif (!is_crypted) {\n\t\t\t\t\t\t\thintType = GF_RTP_PAYT_MPEG12_VIDEO;\n\t\t\t\t\t\t\tOfficialPayloadID = 32;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/*for ISMA*/\n\t\t\t\t\tif (is_crypted) {\n\t\t\t\t\t\t/*that's another pain with ISMACryp, even if no B-frames the DTS is signaled...*/\n\t\t\t\t\t\tif (codecid==GF_CODECID_MPEG4_PART2) force_dts_delta = 22;\n\t\t\t\t\t\telse if ((codecid==GF_CODECID_AVC) || (codecid==GF_CODECID_SVC)) {\n\t\t\t\t\t\t\tflags &= ~GP_RTP_PCK_USE_MULTI;\n\t\t\t\t\t\t\tforce_dts_delta = 22;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tflags |= GP_RTP_PCK_SIGNAL_RAP | GP_RTP_PCK_SIGNAL_TS;\n\t\t\t\t\t}\n\n\t\t\t\t\trequired_rate = default_rtp_rate;\n\t\t\t\t}\n\t\t\t\t/*systems streams*/\n\t\t\t\telse if (gf_isom_has_sync_shadows(file, TrackNum) || gf_isom_has_sample_dependency(file, TrackNum)) {\n\t\t\t\t\tflags |= GP_RTP_PCK_SYSTEMS_CAROUSEL;\n\t\t\t\t}\n\t\t\t\tgf_odf_desc_del((GF_Descriptor*)esd);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\t\thintType = GF_RTP_PAYT_H263;\n\t\t\trequired_rate = 90000;\n\t\t\tstreamType = GF_STREAM_VISUAL;\n\t\t\tOfficialPayloadID = 34;\n\t\t\t/*not 100% compliant (short header is missing) but should still work*/\n\t\t\tcodecid = GF_CODECID_MPEG4_PART2;\n\t\t\tPL_ID = 0x01;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\t\t\trequired_rate = 8000;\n\t\t\thintType = GF_RTP_PAYT_AMR;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\thas_mpeg4_mapping = 0;\n\t\t\tnb_ch = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\t\trequired_rate = 16000;\n\t\t\thintType = GF_RTP_PAYT_AMR_WB;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\thas_mpeg4_mapping = 0;\n\t\t\tnb_ch = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_AVC_H264:\n\t\tcase GF_ISOM_SUBTYPE_AVC2_H264:\n\t\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\t\tcase GF_ISOM_SUBTYPE_AVC4_H264:\n\t\tcase GF_ISOM_SUBTYPE_SVC_H264:\n\t\tcase GF_ISOM_SUBTYPE_MVC_H264:\n\t\t{\n\t\t\tGF_AVCConfig *avcc = gf_isom_avc_config_get(file, TrackNum, 1);\n\t\t\tGF_AVCConfig *svcc = gf_isom_svc_config_get(file, TrackNum, 1);\n\t\t\tGF_AVCConfig *mvcc = gf_isom_mvc_config_get(file, TrackNum, 1);\n\n\t\t\tif (!avcc && !svcc && !mvcc) {\n\t\t\t\t*e = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\trequired_rate = 90000;\t/* \"90 kHz clock rate MUST be used\"*/\n\t\t\thintType = GF_RTP_PAYT_H264_AVC;\n\t\t\tif (TrackMediaSubType==GF_ISOM_SUBTYPE_SVC_H264)\n\t\t\t\thintType = GF_RTP_PAYT_H264_SVC;\n\t\t\telse if (TrackMediaSubType==GF_ISOM_SUBTYPE_MVC_H264)\n\t\t\t\thintType = GF_RTP_PAYT_H264_SVC;\n\t\t\tstreamType = GF_STREAM_VISUAL;\n\t\t\tavc_nalu_size = avcc ? avcc->nal_unit_size : svcc ? svcc->nal_unit_size : mvcc->nal_unit_size;\n\t\t\tcodecid = GF_CODECID_AVC;\n\t\t\tPL_ID = 0x0F;\n\t\t\tgf_odf_avc_cfg_del(avcc);\n\t\t\tgf_odf_avc_cfg_del(svcc);\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_HVC1:\n\t\tcase GF_ISOM_SUBTYPE_HEV1:\n\t\tcase GF_ISOM_SUBTYPE_HVC2:\n\t\tcase GF_ISOM_SUBTYPE_HEV2:\n\t\t{\n\t\t\tGF_HEVCConfig *hevcc = gf_isom_hevc_config_get(file, TrackNum, 1);\n\t\t\tif (!hevcc) {\n\t\t\t\t*e = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\trequired_rate = 90000;\t/* \"90 kHz clock rate MUST be used\"*/\n\t\t\thintType = GF_RTP_PAYT_HEVC;\n\t\t\tstreamType = GF_STREAM_VISUAL;\n\t\t\tavc_nalu_size = hevcc->nal_unit_size;\n\t\t\tcodecid = GF_CODECID_HEVC;\n\t\t\tPL_ID = 0x0F;\n\t\t\tflags |= GP_RTP_PCK_USE_MULTI;\n\t\t\tgf_odf_hevc_cfg_del(hevcc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t\t\trequired_rate = 8000;\n\t\t\thintType = GF_RTP_PAYT_QCELP;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\tcodecid = GF_CODECID_QCELP;\n\t\t\tOfficialPayloadID = 12;\n\t\t\tnb_ch = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\t\trequired_rate = 8000;\n\t\t\thintType = GF_RTP_PAYT_EVRC_SMV;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\tcodecid = (TrackMediaSubType==GF_ISOM_SUBTYPE_3GP_EVRC) ? GF_CODECID_EVRC : GF_CODECID_SMV;\n\t\t\tnb_ch = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_DIMS:\n#if GPAC_ENABLE_3GPP_DIMS_RTP\n\t\t\thintType = GF_RTP_PAYT_3GPP_DIMS;\n\t\t\tstreamType = GF_STREAM_SCENE;\n#else\n\t\t\thintType = 0;\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[RTP Packetizer] 3GPP DIMS over RTP disabled in build\\n\", streamType));\n#endif\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_AC3:\n\t\t\thintType = GF_RTP_PAYT_AC3;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\tgf_isom_get_audio_info(file, TrackNum, 1, NULL, &nb_ch, NULL);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_MP3:\n\t\t{\n\t\t\tGF_ISOSample *samp = gf_isom_get_sample(file, TrackNum, 1, NULL);\n\t\t\tif (samp && (samp->dataLength>3)) {\n\t\t\t\tu32 hdr = GF_4CC((u32)samp->data[0], (u8)samp->data[1], (u8)samp->data[2], (u8)samp->data[3]);\n\t\t\t\tnb_ch = gf_mp3_num_channels(hdr);\n\t\t\t} else {\n\t\t\t\tu32 bps;\n\t\t\t\tgf_isom_get_audio_info(file, TrackNum, 1, &required_rate, &nb_ch, &bps);\n\t\t\t}\n\t\t\thintType = GF_RTP_PAYT_MPEG12_AUDIO;\n\t\t\t/*use official RTP/AVP payload type*/\n\t\t\tOfficialPayloadID = 14;\n\t\t\trequired_rate = 90000;\n\n\t\t\tif (samp)\n\t\t\t\tgf_isom_sample_del(&samp);\n\t\t}\n\t\tbreak;\n\t\tdefault:\n\t\t\t/*ERROR*/\n\t\t\thintType = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*not hintable*/\n\tif (!hintType) return NULL;\n\t/*we only support self-contained files for hinting*/\n\tgf_isom_get_data_reference(file, TrackNum, 1, &url, &urn);\n\tif (url || urn) return NULL;\n\n\t*e = GF_OUT_OF_MEM;\n\tGF_SAFEALLOC(tmp, GF_RTPHinter);\n\tif (!tmp) return NULL;\n\n\t/*override hinter type if requested and possible*/\n\tif (has_mpeg4_mapping && (flags & GP_RTP_PCK_FORCE_MPEG4)) {\n\t\thintType = GF_RTP_PAYT_MPEG4;\n\t\tavc_nalu_size = 0;\n\t}\n\t/*use static payload ID if enabled*/\n\telse if (OfficialPayloadID && (flags & GP_RTP_PCK_USE_STATIC_ID) ) {\n\t\tPayloadID = OfficialPayloadID;\n\t}\n\n\ttmp->file = file;\n\ttmp->TrackNum = TrackNum;\n\ttmp->avc_nalu_size = avc_nalu_size;\n\ttmp->nb_chan = nb_ch;\n\n\t/*spatial scalability check*/\n\ttmp->has_ctts = gf_isom_has_time_offset(file, TrackNum);\n\n\t/*get sample info*/\n\tgf_media_get_sample_average_infos(file, TrackNum, &MinSize, &MaxSize, &avgTS, &maxDTSDelta, &const_dur, &bandwidth);\n\n\t/*systems carousel: we need at least IDX and RAP signaling*/\n\tif (flags & GP_RTP_PCK_SYSTEMS_CAROUSEL) {\n\t\tflags |= GP_RTP_PCK_SIGNAL_RAP;\n\t}\n\n\t/*update flags in MultiSL*/\n\tif (flags & GP_RTP_PCK_USE_MULTI) {\n\t\tif (MinSize != MaxSize) flags |= GP_RTP_PCK_SIGNAL_SIZE;\n\t\tif (!const_dur) flags |= GP_RTP_PCK_SIGNAL_TS;\n\t}\n\tif (tmp->has_ctts) flags |= GP_RTP_PCK_SIGNAL_TS;\n\n\t/*default SL for RTP */\n\tInitSL_RTP(&my_sl);\n\n\tmy_sl.timestampResolution = gf_isom_get_media_timescale(file, TrackNum);\n\t/*override clockrate if set*/\n\tif (required_rate) {\n\t\tDouble sc = required_rate;\n\t\tsc /= my_sl.timestampResolution;\n\t\tmaxDTSDelta = (u32) (maxDTSDelta*sc);\n\t\tmy_sl.timestampResolution = required_rate;\n\t}\n\t/*switch to RTP TS*/\n\tmax_ptime = (u32) (max_ptime * my_sl.timestampResolution / 1000);\n\n\tmy_sl.AUSeqNumLength = gf_get_bit_size(gf_isom_get_sample_count(file, TrackNum));\n\tif (my_sl.AUSeqNumLength>16) my_sl.AUSeqNumLength=16;\n\n\tmy_sl.CUDuration = const_dur;\n\n\tif (gf_isom_has_sync_points(file, TrackNum)) {\n\t\tmy_sl.useRandomAccessPointFlag = 1;\n\t} else {\n\t\tmy_sl.useRandomAccessPointFlag = 0;\n\t\tmy_sl.hasRandomAccessUnitsOnlyFlag = 1;\n\t}\n\n\tif (is_crypted) {\n\t\tBool use_sel_enc;\n\t\tgf_isom_get_ismacryp_info(file, TrackNum, 1, NULL, NULL, NULL, NULL, NULL, &use_sel_enc, &IV_length, &KI_length);\n\t\tif (use_sel_enc) flags |= GP_RTP_PCK_SELECTIVE_ENCRYPTION;\n\t}\n\n\t// in case a different timescale was provided\n\ttmp->OrigTimeScale = gf_isom_get_media_timescale(file, TrackNum);\n\ttmp->rtp_p = gf_rtp_builder_new(hintType, &my_sl, flags, tmp,\n\t                                MP4T_OnNewPacket, MP4T_OnPacketDone,\n\t                                /*if copy, no data ref*/\n\t                                copy_media ? NULL : MP4T_OnDataRef,\n\t                                MP4T_OnData);\n\n\t//init the builder\n\tgf_rtp_builder_init(tmp->rtp_p, PayloadID, Path_MTU, max_ptime,\n\t                    streamType, codecid, PL_ID, MinSize, MaxSize, avgTS, maxDTSDelta, IV_length, KI_length, mpeg4mode);\n\n\t/*ISMA compliance is a pain...*/\n\tif (force_dts_delta) tmp->rtp_p->slMap.DTSDeltaLength = force_dts_delta;\n\n\n\t/*\t\tHint Track Setup\t*/\n\ttmp->TrackID = gf_isom_get_track_id(file, TrackNum);\n\ttmp->HintID = tmp->TrackID + 65535;\n\twhile (gf_isom_get_track_by_id(file, tmp->HintID)) tmp->HintID++;\n\n\ttmp->HintTrack = gf_isom_new_track(file, tmp->HintID, GF_ISOM_MEDIA_HINT, my_sl.timestampResolution);\n\tgf_isom_setup_hint_track(file, tmp->HintTrack, GF_ISOM_HINT_RTP);\n\t/*create a hint description*/\n\tgf_isom_new_hint_description(file, tmp->HintTrack, -1, -1, 0, &descIndex);\n\tgf_isom_rtp_set_timescale(file, tmp->HintTrack, descIndex, my_sl.timestampResolution);\n\n\tif (hintType==GF_RTP_PAYT_MPEG4) {\n\t\ttmp->rtp_p->slMap.CodecID = codecid;\n\t\t/*set this SL for extraction.*/\n\t\t*e = gf_isom_set_extraction_slc(file, TrackNum, 1, &my_sl);\n\t\tif (*e) {\n\t\t\tgf_hinter_track_del(tmp);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\ttmp->bandwidth = bandwidth;\n\n\t/*set interleaving*/\n\tgf_isom_set_track_interleaving_group(file, TrackNum, InterleaveGroupID);\n\tif (!copy_media) {\n\t\t/*if we don't copy data set hint track and media track in the same group*/\n\t\tgf_isom_set_track_interleaving_group(file, tmp->HintTrack, InterleaveGroupID);\n\t} else {\n\t\tgf_isom_set_track_interleaving_group(file, tmp->HintTrack, InterleaveGroupID + OFFSET_HINT_GROUP_ID);\n\t}\n\t/*use user-secified priority*/\n\tInterleaveGroupPriority*=2;\n\tgf_isom_set_track_priority_in_group(file, TrackNum, InterleaveGroupPriority+1);\n\tgf_isom_set_track_priority_in_group(file, tmp->HintTrack, InterleaveGroupPriority);\n\n#if 0\n#endif\n\t*e = GF_OK;\n\treturn tmp;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 5355,
    "critical_vars": [
      "*esds"
    ],
    "function": "gf_isom_set_extraction_slc",
    "filename": "gpac/CVE-2021-31258/CVE-2021-31258_CWE-476_ebfa346eff05049718f7b80041093b4c5581c24e_isom_write.c.diff",
    "function_code": "GF_Err gf_isom_set_extraction_slc(GF_ISOFile *the_file, u32 trackNumber, u32 StreamDescriptionIndex, const GF_SLConfig *slConfig)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_Err e;\n\tGF_SLConfig **slc;\n\tGF_ESDBox *esds;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, StreamDescriptionIndex, &entry, NULL);\n\tif (e) return e;\n\n\t//we must be sure we are not using a remote ESD\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\tesds = ((GF_MPEGSampleEntryBox *)entry)->esd;\n\t\tif (!esds || !esds->desc || !esds->desc->slConfig || (esds->desc->slConfig->predefined != SLPredef_MP4))\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tslc = & ((GF_MPEGSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tesds = ((GF_MPEGAudioSampleEntryBox *)entry)->esd;\n\t\tif (!esds || !esds->desc || !esds->desc->slConfig || (esds->desc->slConfig->predefined != SLPredef_MP4))\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tslc = & ((GF_MPEGAudioSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tesds = ((GF_MPEGVisualSampleEntryBox *)entry)->esd;\n\t\tif (!esds || !esds->desc || !esds->desc->slConfig || (esds->desc->slConfig->predefined != SLPredef_MP4))\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tslc = & ((GF_MPEGVisualSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tif (*slc) {\n\t\tgf_odf_desc_del((GF_Descriptor *)*slc);\n\t\t*slc = NULL;\n\t}\n\tif (!slConfig) return GF_OK;\n\t//finally duplicate the SL\n\treturn gf_odf_desc_copy((GF_Descriptor *) slConfig, (GF_Descriptor **) slc);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 5365,
    "critical_vars": [
      "GF_MPEGSampleEntryBox"
    ],
    "function": "gf_isom_set_extraction_slc",
    "filename": "gpac/CVE-2021-31258/CVE-2021-31258_CWE-476_ebfa346eff05049718f7b80041093b4c5581c24e_isom_write.c.diff",
    "function_code": "GF_Err gf_isom_set_extraction_slc(GF_ISOFile *the_file, u32 trackNumber, u32 StreamDescriptionIndex, const GF_SLConfig *slConfig)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_Err e;\n\tGF_SLConfig **slc;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, StreamDescriptionIndex, &entry, NULL);\n\tif (e) return e;\n\n\t//we must be sure we are not using a remote ESD\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\tif (((GF_MPEGSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = & ((GF_MPEGSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tif (((GF_MPEGAudioSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = & ((GF_MPEGAudioSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tif (((GF_MPEGVisualSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = & ((GF_MPEGVisualSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tif (*slc) {\n\t\tgf_odf_desc_del((GF_Descriptor *)*slc);\n\t\t*slc = NULL;\n\t}\n\tif (!slConfig) return GF_OK;\n\t//finally duplicate the SL\n\treturn gf_odf_desc_copy((GF_Descriptor *) slConfig, (GF_Descriptor **) slc);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 3906,
    "critical_vars": [
      "dcd"
    ],
    "function": "gf_isom_guess_specification",
    "filename": "gpac/CVE-2021-31258/CVE-2021-31258_CWE-476_ebfa346eff05049718f7b80041093b4c5581c24e_isom_read.c.diff",
    "function_code": "GF_EXPORT\nu32 gf_isom_guess_specification(GF_ISOFile *file)\n{\n\tu32 count, i, nb_any, nb_m4s, nb_a, nb_v, nb_auxv,nb_scene, nb_od, nb_mp3, nb_aac, nb_m4v, nb_avc, nb_amr, nb_h263, nb_qcelp, nb_evrc, nb_smv, nb_text, nb_pict;\n\n\tnb_m4s = nb_a = nb_v = nb_auxv = nb_any = nb_scene = nb_od = nb_mp3 = nb_aac = nb_m4v = nb_avc = nb_amr = nb_h263 = nb_qcelp = nb_evrc = nb_smv = nb_text = nb_pict = 0;\n\n\tif (file->is_jp2) {\n\t\tif (file->moov) return GF_ISOM_BRAND_MJP2;\n\t\treturn GF_ISOM_BRAND_JP2;\n\t}\n\tif (!file->moov) {\n\t\tif (!file->meta || !file->meta->handler) return 0;\n\t\treturn file->meta->handler->handlerType;\n\t}\n\n\tcount = gf_isom_get_track_count(file);\n\tfor (i=0; i<count; i++) {\n\t\tu32 mtype = gf_isom_get_media_type(file, i+1);\n\t\tu32 mstype = gf_isom_get_media_subtype(file, i+1, 1);\n\n\t\tif (mtype==GF_ISOM_MEDIA_SCENE) {\n\t\t\tnb_scene++;\n\t\t\t/*forces non-isma*/\n\t\t\tif (gf_isom_get_sample_count(file, i+1)>1) nb_m4s++;\n\t\t} else if (mtype==GF_ISOM_MEDIA_OD) {\n\t\t\tnb_od++;\n\t\t\t/*forces non-isma*/\n\t\t\tif (gf_isom_get_sample_count(file, i+1)>1) nb_m4s++;\n\t\t}\n\t\telse if ((mtype==GF_ISOM_MEDIA_TEXT) || (mtype==GF_ISOM_MEDIA_SUBT)) nb_text++;\n\t\telse if ((mtype==GF_ISOM_MEDIA_AUDIO) || gf_isom_is_video_handler_type(mtype) ) {\n\t\t\tswitch (mstype) {\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\t\t\tnb_amr++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\t\t\tnb_h263++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\t\t\tnb_evrc++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t\t\t\tnb_qcelp++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\t\t\tnb_smv++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_AVC_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_AVC2_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_AVC4_H264:\n\t\t\t\tnb_avc++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_SVC_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_MVC_H264:\n\t\t\t\tnb_avc++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_MPEG4:\n\t\t\tcase GF_ISOM_SUBTYPE_MPEG4_CRYP:\n\t\t\t{\n\t\t\t\tGF_DecoderConfig *dcd = gf_isom_get_decoder_config(file, i+1, 1);\n\t\t\t\tif (!dcd) break;\n\t\t\t\tswitch (dcd->streamType) {\n\t\t\t\tcase GF_STREAM_VISUAL:\n\t\t\t\t\tif (dcd->objectTypeIndication==GF_CODECID_MPEG4_PART2) nb_m4v++;\n\t\t\t\t\telse if ((dcd->objectTypeIndication==GF_CODECID_AVC) || (dcd->objectTypeIndication==GF_CODECID_SVC) || (dcd->objectTypeIndication==GF_CODECID_MVC)) nb_avc++;\n\t\t\t\t\telse nb_v++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_STREAM_AUDIO:\n\t\t\t\t\tswitch (dcd->objectTypeIndication) {\n\t\t\t\t\tcase GF_CODECID_AAC_MPEG2_MP:\n\t\t\t\t\tcase GF_CODECID_AAC_MPEG2_LCP:\n\t\t\t\t\tcase GF_CODECID_AAC_MPEG2_SSRP:\n\t\t\t\t\tcase GF_CODECID_AAC_MPEG4:\n\t\t\t\t\t\tnb_aac++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_CODECID_MPEG2_PART3:\n\t\t\t\t\tcase GF_CODECID_MPEG_AUDIO:\n\t\t\t\t\t\tnb_mp3++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_CODECID_EVRC:\n\t\t\t\t\t\tnb_evrc++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_CODECID_SMV:\n\t\t\t\t\t\tnb_smv++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_CODECID_QCELP:\n\t\t\t\t\t\tnb_qcelp++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tnb_a++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t/*SHOULD NEVER HAPPEN - IF SO, BROKEN MPEG4 FILE*/\n\t\t\t\tdefault:\n\t\t\t\t\tnb_any++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *)dcd);\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (mtype==GF_ISOM_MEDIA_VISUAL) nb_v++;\n\t\t\t\telse if (mtype==GF_ISOM_MEDIA_AUXV) nb_auxv++;\n\t\t\t\telse if (mtype==GF_ISOM_MEDIA_PICT) nb_pict++;\n\t\t\t\telse nb_a++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if ((mtype==GF_ISOM_SUBTYPE_MPEG4) || (mtype==GF_ISOM_SUBTYPE_MPEG4_CRYP)) nb_m4s++;\n\t\telse nb_any++;\n\t}\n\tif (nb_any) return GF_ISOM_BRAND_ISOM;\n\tif (nb_qcelp || nb_evrc || nb_smv) {\n\t\t/*non std mix of streams*/\n\t\tif (nb_m4s || nb_avc || nb_scene || nb_od || nb_mp3 || nb_a || nb_v) return GF_ISOM_BRAND_ISOM;\n\t\treturn GF_ISOM_BRAND_3G2A;\n\t}\n\t/*other a/v/s streams*/\n\tif (nb_v || nb_a || nb_m4s) return GF_ISOM_BRAND_MP42;\n\n\tnb_v = nb_m4v + nb_avc + nb_h263;\n\tnb_a = nb_mp3 + nb_aac + nb_amr;\n\n\t/*avc file: whatever has AVC and no systems*/\n\tif (nb_avc) {\n\t\tif (!nb_scene && !nb_od) return GF_ISOM_BRAND_AVC1;\n\t\treturn GF_ISOM_BRAND_MP42;\n\t}\n\t/*MP3: ISMA and MPEG4*/\n\tif (nb_mp3) {\n\t\tif (!nb_text && (nb_v<=1) && (nb_a<=1) && (nb_scene==1) && (nb_od==1))\n\t\t\treturn GF_ISOM_BRAND_ISMA;\n\t\treturn GF_ISOM_BRAND_MP42;\n\t}\n\t/*MP4*/\n\tif (nb_scene || nb_od) {\n\t\t/*issue with AMR and H263 which don't have MPEG mapping: non compliant file*/\n\t\tif (nb_amr || nb_h263) return GF_ISOM_BRAND_ISOM;\n\t\treturn GF_ISOM_BRAND_MP42;\n\t}\n\t/*use ISMA (3GP fine too)*/\n\tif (!nb_amr && !nb_h263 && !nb_text) {\n\t\tif ((nb_v<=1) && (nb_a<=1)) return GF_ISOM_BRAND_ISMA;\n\t\treturn GF_ISOM_BRAND_MP42;\n\t}\n\n\tif ((nb_v<=1) && (nb_a<=1) && (nb_text<=1)) return nb_text ? GF_ISOM_BRAND_3GP6 : GF_ISOM_BRAND_3GP5;\n\treturn GF_ISOM_BRAND_3GG6;",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 134,
    "critical_vars": [
      "ref->trackRef",
      "mpod->trackIDs"
    ],
    "function": "Media_RewriteODFrame",
    "filename": "gpac/CVE-2021-32440/CVE-2021-32440_CWE-476_f0ba83717b6e4d7a15a1676d1fe06152e199b011_media_odf.c.diff",
    "function_code": "GF_Err Media_RewriteODFrame(GF_MediaBox *mdia, GF_ISOSample *sample)\n{\n\tGF_Err e;\n\tGF_ODCodec *ODdecode;\n\tGF_ODCodec *ODencode;\n\tGF_ODCom *com;\n\n\t//the commands we proceed\n\tGF_ESDUpdate *esdU, *esdU2;\n\tGF_ESDRemove *esdR, *esdR2;\n\tGF_ODUpdate *odU, *odU2;\n\n\t//the desc they contain\n\tGF_ObjectDescriptor *od;\n\tGF_IsomObjectDescriptor *isom_od;\n\tGF_ESD *esd;\n\tGF_ES_ID_Ref *ref;\n\tGF_Descriptor *desc;\n\tGF_TrackReferenceTypeBox *mpod;\n\tu32 i, j, skipped;\n\n\tif (!mdia || !sample || !sample->data || !sample->dataLength) return GF_BAD_PARAM;\n\n\tmpod = NULL;\n\te = Track_FindRef(mdia->mediaTrack, GF_ISOM_BOX_TYPE_MPOD, &mpod);\n\tif (e) return e;\n\t//no references, nothing to do...\n\tif (!mpod || !mpod->trackIDs) return GF_OK;\n\n\tODdecode = gf_odf_codec_new();\n\tif (!ODdecode) return GF_OUT_OF_MEM;\n\tODencode = gf_odf_codec_new();\n\tif (!ODencode) {\n\t\tgf_odf_codec_del(ODdecode);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\te = gf_odf_codec_set_au(ODdecode, sample->data, sample->dataLength);\n\tif (e) goto err_exit;\n\te = gf_odf_codec_decode(ODdecode);\n\tif (e) goto err_exit;\n\n\twhile (1) {\n\t\tcom = gf_odf_codec_get_com(ODdecode);\n\t\tif (!com) break;\n\n\t\t//we only need to rewrite commands with ESDs inside: ESDUpdate and ODUpdate\n\t\tswitch (com->tag) {\n\t\tcase GF_ODF_OD_UPDATE_TAG:\n\t\t\todU = (GF_ODUpdate *) com;\n\t\t\todU2 = (GF_ODUpdate *) gf_odf_com_new(GF_ODF_OD_UPDATE_TAG);\n\n\t\t\ti=0;\n\t\t\twhile ((desc = (GF_Descriptor*)gf_list_enum(odU->objectDescriptors, &i))) {\n\t\t\t\tswitch (desc->tag) {\n\t\t\t\tcase GF_ODF_OD_TAG:\n\t\t\t\tcase GF_ODF_ISOM_OD_TAG:\n\t\t\t\t//IOD can be used in OD streams\n\t\t\t\tcase GF_ODF_ISOM_IOD_TAG:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t\t}\n\t\t\t\te = gf_odf_desc_copy(desc, (GF_Descriptor **)&isom_od);\n\t\t\t\tif (e) goto err_exit;\n\n\t\t\t\t//create our OD...\n\t\t\t\tif (desc->tag == GF_ODF_ISOM_IOD_TAG) {\n\t\t\t\t\tod = (GF_ObjectDescriptor *) gf_malloc(sizeof(GF_InitialObjectDescriptor));\n\t\t\t\t} else {\n\t\t\t\t\tod = (GF_ObjectDescriptor *) gf_malloc(sizeof(GF_ObjectDescriptor));\n\t\t\t\t}\n\t\t\t\tif (!od) {\n\t\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\t\tgoto err_exit;\n\t\t\t\t}\n\t\t\t\tod->ESDescriptors = gf_list_new();\n\t\t\t\t//and duplicate...\n\t\t\t\tod->objectDescriptorID = isom_od->objectDescriptorID;\n\t\t\t\tod->tag = GF_ODF_OD_TAG;\n\t\t\t\tod->URLString = isom_od->URLString;\n\t\t\t\tisom_od->URLString = NULL;\n\t\t\t\tod->extensionDescriptors = isom_od->extensionDescriptors;\n\t\t\t\tisom_od->extensionDescriptors = NULL;\n\t\t\t\tod->IPMP_Descriptors = isom_od->IPMP_Descriptors;\n\t\t\t\tisom_od->IPMP_Descriptors = NULL;\n\t\t\t\tod->OCIDescriptors = isom_od->OCIDescriptors;\n\t\t\t\tisom_od->OCIDescriptors = NULL;\n\n\t\t\t\t//init as IOD\n\t\t\t\tif (isom_od->tag == GF_ODF_ISOM_IOD_TAG) {\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->audio_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->audio_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->inlineProfileFlag = ((GF_IsomInitialObjectDescriptor *)isom_od)->inlineProfileFlag;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->graphics_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->graphics_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->OD_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->OD_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->scene_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->scene_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->visual_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->visual_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->IPMPToolList = ((GF_IsomInitialObjectDescriptor *)isom_od)->IPMPToolList;\n\t\t\t\t\t((GF_IsomInitialObjectDescriptor *)isom_od)->IPMPToolList = NULL;\n\t\t\t\t}\n\n\t\t\t\t//then rewrite the ESDesc\n\t\t\t\tj=0;\n\t\t\t\twhile ((ref = (GF_ES_ID_Ref*)gf_list_enum(isom_od->ES_ID_RefDescriptors, &j))) {\n\t\t\t\t\tif (!mpod->trackIDs || !ref->trackRef || (ref->trackRef>mpod->trackIDCount)) continue;\n\t\t\t\t\t//if the ref index is not valid, skip this desc...\n\t\t\t\t\tif (gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1]) == NULL) continue;\n\t\t\t\t\t//OK, get the esd\n\t\t\t\t\te = GetESDForTime(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1], sample->DTS, &esd);\n\t\t\t\t\tif (!e) e = gf_odf_desc_add_desc((GF_Descriptor *) od, (GF_Descriptor *) esd);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tgf_odf_desc_del((GF_Descriptor *)od);\n\t\t\t\t\t\tgf_odf_com_del((GF_ODCom **)&odU2);\n\t\t\t\t\t\tgf_odf_desc_del((GF_Descriptor *)isom_od);\n\t\t\t\t\t\tgf_odf_com_del((GF_ODCom **)&odU);\n\t\t\t\t\t\tgoto err_exit;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t//delete our desc\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *)isom_od);\n\t\t\t\tgf_list_add(odU2->objectDescriptors, od);\n\t\t\t}\n\t\t\t//clean a bit\n\t\t\tgf_odf_com_del((GF_ODCom **)&odU);\n\t\t\tgf_odf_codec_add_com(ODencode, (GF_ODCom *)odU2);\n\t\t\tbreak;\n\n\t\tcase GF_ODF_ESD_UPDATE_TAG:\n\t\t\tesdU = (GF_ESDUpdate *) com;\n\t\t\tesdU2 = (GF_ESDUpdate *) gf_odf_com_new(GF_ODF_ESD_UPDATE_TAG);\n\t\t\tesdU2->ODID = esdU->ODID;\n\t\t\ti=0;\n\t\t\twhile ((ref = (GF_ES_ID_Ref*)gf_list_enum(esdU->ESDescriptors, &i))) {\n\t\t\t\tif (!mpod->trackIDs || !ref->trackRef || (ref->trackRef>mpod->trackIDCount)) continue;\n\t\t\t\t//if the ref index is not valid, skip this desc...\n\t\t\t\tif (gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1]) == NULL) continue;\n\t\t\t\t//OK, get the esd\n\t\t\t\te = GetESDForTime(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1], sample->DTS, &esd);\n\t\t\t\tif (e) goto err_exit;\n\t\t\t\tgf_list_add(esdU2->ESDescriptors, esd);\n\t\t\t}\n\t\t\tgf_odf_com_del((GF_ODCom **)&esdU);\n\t\t\tgf_odf_codec_add_com(ODencode, (GF_ODCom *)esdU2);\n\t\t\tbreak;\n\n\t\t//brand new case: the ESRemove follows the same principle according to the spec...\n\t\tcase GF_ODF_ESD_REMOVE_REF_TAG:\n\t\t\t//both commands have the same structure, only the tags change\n\t\t\tesdR = (GF_ESDRemove *) com;\n\t\t\tesdR2 = (GF_ESDRemove *) gf_odf_com_new(GF_ODF_ESD_REMOVE_TAG);\n\t\t\tesdR2->ODID = esdR->ODID;\n\t\t\tesdR2->NbESDs = esdR->NbESDs;\n\t\t\t//alloc our stuff\n\t\t\tesdR2->ES_ID = (unsigned short*)gf_malloc(sizeof(u32) * esdR->NbESDs);\n\t\t\tif (!esdR2->ES_ID) {\n\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\t\t\tskipped = 0;\n\t\t\t//get the ES_ID in the mpod indicated in the ES_ID[]\n\t\t\tfor (i = 0; i < esdR->NbESDs; i++) {\n\t\t\t\tif (!mpod->trackIDs || !esdR->ES_ID[i] || (esdR->ES_ID[i]>mpod->trackIDCount)) continue;\n\t\t\t\t//if the ref index is not valid, remove this desc...\n\t\t\t\tif (gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[esdR->ES_ID[i] - 1]) == NULL) {\n\t\t\t\t\tskipped ++;\n\t\t\t\t} else {\n\t\t\t\t\t//the command in the file has the ref index of the trackID in the mpod\n\t\t\t\t\tesdR2->ES_ID[i - skipped] = mpod->trackIDs[esdR->ES_ID[i] - 1];\n\t\t\t\t}\n\t\t\t}\n\t\t\t//gf_realloc...\n\t\t\tif (skipped && (skipped != esdR2->NbESDs) ) {\n\t\t\t\tesdR2->NbESDs -= skipped;\n\t\t\t\tesdR2->ES_ID = (unsigned short*)gf_realloc(esdR2->ES_ID, sizeof(u32) * esdR2->NbESDs);\n\t\t\t}\n\t\t\tgf_odf_com_del((GF_ODCom **)&esdR);\n\t\t\tgf_odf_codec_add_com(ODencode, (GF_ODCom *)esdR2);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\te = gf_odf_codec_add_com(ODencode, com);\n\t\t\tif (e) goto err_exit;\n\t\t}\n\t}\n\t//encode our new AU\n\te = gf_odf_codec_encode(ODencode, 1);\n\tif (e) goto err_exit;\n\n\t//and set the buffer in the sample\n\tgf_free(sample->data);\n\tsample->data = NULL;\n\tsample->dataLength = 0;\n\te = gf_odf_codec_get_au(ODencode, &sample->data, &sample->dataLength);\n\nerr_exit:\n\tgf_odf_codec_del(ODdecode);\n\tgf_odf_codec_del(ODencode);\n\treturn e;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 135,
    "critical_vars": [
      "mpod->trackIDs",
      "mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1]"
    ],
    "function": "Media_RewriteODFrame",
    "filename": "gpac/CVE-2021-32440/CVE-2021-32440_CWE-476_f0ba83717b6e4d7a15a1676d1fe06152e199b011_media_odf.c.diff",
    "function_code": "GF_Err Media_RewriteODFrame(GF_MediaBox *mdia, GF_ISOSample *sample)\n{\n\tGF_Err e;\n\tGF_ODCodec *ODdecode;\n\tGF_ODCodec *ODencode;\n\tGF_ODCom *com;\n\n\t//the commands we proceed\n\tGF_ESDUpdate *esdU, *esdU2;\n\tGF_ESDRemove *esdR, *esdR2;\n\tGF_ODUpdate *odU, *odU2;\n\n\t//the desc they contain\n\tGF_ObjectDescriptor *od;\n\tGF_IsomObjectDescriptor *isom_od;\n\tGF_ESD *esd;\n\tGF_ES_ID_Ref *ref;\n\tGF_Descriptor *desc;\n\tGF_TrackReferenceTypeBox *mpod;\n\tu32 i, j, skipped;\n\n\tif (!mdia || !sample || !sample->data || !sample->dataLength) return GF_BAD_PARAM;\n\n\tmpod = NULL;\n\te = Track_FindRef(mdia->mediaTrack, GF_ISOM_BOX_TYPE_MPOD, &mpod);\n\tif (e) return e;\n\t//no references, nothing to do...\n\tif (!mpod || !mpod->trackIDs) return GF_OK;\n\n\tODdecode = gf_odf_codec_new();\n\tif (!ODdecode) return GF_OUT_OF_MEM;\n\tODencode = gf_odf_codec_new();\n\tif (!ODencode) {\n\t\tgf_odf_codec_del(ODdecode);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\te = gf_odf_codec_set_au(ODdecode, sample->data, sample->dataLength);\n\tif (e) goto err_exit;\n\te = gf_odf_codec_decode(ODdecode);\n\tif (e) goto err_exit;\n\n\twhile (1) {\n\t\tcom = gf_odf_codec_get_com(ODdecode);\n\t\tif (!com) break;\n\n\t\t//we only need to rewrite commands with ESDs inside: ESDUpdate and ODUpdate\n\t\tswitch (com->tag) {\n\t\tcase GF_ODF_OD_UPDATE_TAG:\n\t\t\todU = (GF_ODUpdate *) com;\n\t\t\todU2 = (GF_ODUpdate *) gf_odf_com_new(GF_ODF_OD_UPDATE_TAG);\n\n\t\t\ti=0;\n\t\t\twhile ((desc = (GF_Descriptor*)gf_list_enum(odU->objectDescriptors, &i))) {\n\t\t\t\tswitch (desc->tag) {\n\t\t\t\tcase GF_ODF_OD_TAG:\n\t\t\t\tcase GF_ODF_ISOM_OD_TAG:\n\t\t\t\t//IOD can be used in OD streams\n\t\t\t\tcase GF_ODF_ISOM_IOD_TAG:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t\t}\n\t\t\t\te = gf_odf_desc_copy(desc, (GF_Descriptor **)&isom_od);\n\t\t\t\tif (e) goto err_exit;\n\n\t\t\t\t//create our OD...\n\t\t\t\tif (desc->tag == GF_ODF_ISOM_IOD_TAG) {\n\t\t\t\t\tod = (GF_ObjectDescriptor *) gf_malloc(sizeof(GF_InitialObjectDescriptor));\n\t\t\t\t} else {\n\t\t\t\t\tod = (GF_ObjectDescriptor *) gf_malloc(sizeof(GF_ObjectDescriptor));\n\t\t\t\t}\n\t\t\t\tif (!od) {\n\t\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\t\tgoto err_exit;\n\t\t\t\t}\n\t\t\t\tod->ESDescriptors = gf_list_new();\n\t\t\t\t//and duplicate...\n\t\t\t\tod->objectDescriptorID = isom_od->objectDescriptorID;\n\t\t\t\tod->tag = GF_ODF_OD_TAG;\n\t\t\t\tod->URLString = isom_od->URLString;\n\t\t\t\tisom_od->URLString = NULL;\n\t\t\t\tod->extensionDescriptors = isom_od->extensionDescriptors;\n\t\t\t\tisom_od->extensionDescriptors = NULL;\n\t\t\t\tod->IPMP_Descriptors = isom_od->IPMP_Descriptors;\n\t\t\t\tisom_od->IPMP_Descriptors = NULL;\n\t\t\t\tod->OCIDescriptors = isom_od->OCIDescriptors;\n\t\t\t\tisom_od->OCIDescriptors = NULL;\n\n\t\t\t\t//init as IOD\n\t\t\t\tif (isom_od->tag == GF_ODF_ISOM_IOD_TAG) {\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->audio_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->audio_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->inlineProfileFlag = ((GF_IsomInitialObjectDescriptor *)isom_od)->inlineProfileFlag;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->graphics_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->graphics_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->OD_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->OD_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->scene_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->scene_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->visual_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->visual_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->IPMPToolList = ((GF_IsomInitialObjectDescriptor *)isom_od)->IPMPToolList;\n\t\t\t\t\t((GF_IsomInitialObjectDescriptor *)isom_od)->IPMPToolList = NULL;\n\t\t\t\t}\n\n\t\t\t\t//then rewrite the ESDesc\n\t\t\t\tj=0;\n\t\t\t\twhile ((ref = (GF_ES_ID_Ref*)gf_list_enum(isom_od->ES_ID_RefDescriptors, &j))) {\n\t\t\t\t\t//if the ref index is not valid, skip this desc...\n\t\t\t\t\tif (!mpod->trackIDs || gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1]) == NULL) continue;\n\t\t\t\t\t//OK, get the esd\n\t\t\t\t\te = GetESDForTime(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1], sample->DTS, &esd);\n\t\t\t\t\tif (!e) e = gf_odf_desc_add_desc((GF_Descriptor *) od, (GF_Descriptor *) esd);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tgf_odf_desc_del((GF_Descriptor *)od);\n\t\t\t\t\t\tgf_odf_com_del((GF_ODCom **)&odU2);\n\t\t\t\t\t\tgf_odf_desc_del((GF_Descriptor *)isom_od);\n\t\t\t\t\t\tgf_odf_com_del((GF_ODCom **)&odU);\n\t\t\t\t\t\tgoto err_exit;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t//delete our desc\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *)isom_od);\n\t\t\t\tgf_list_add(odU2->objectDescriptors, od);\n\t\t\t}\n\t\t\t//clean a bit\n\t\t\tgf_odf_com_del((GF_ODCom **)&odU);\n\t\t\tgf_odf_codec_add_com(ODencode, (GF_ODCom *)odU2);\n\t\t\tbreak;\n\n\t\tcase GF_ODF_ESD_UPDATE_TAG:\n\t\t\tesdU = (GF_ESDUpdate *) com;\n\t\t\tesdU2 = (GF_ESDUpdate *) gf_odf_com_new(GF_ODF_ESD_UPDATE_TAG);\n\t\t\tesdU2->ODID = esdU->ODID;\n\t\t\ti=0;\n\t\t\twhile ((ref = (GF_ES_ID_Ref*)gf_list_enum(esdU->ESDescriptors, &i))) {\n\t\t\t\t//if the ref index is not valid, skip this desc...\n\t\t\t\tif (gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1]) == NULL) continue;\n\t\t\t\t//OK, get the esd\n\t\t\t\te = GetESDForTime(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1], sample->DTS, &esd);\n\t\t\t\tif (e) goto err_exit;\n\t\t\t\tgf_list_add(esdU2->ESDescriptors, esd);\n\t\t\t}\n\t\t\tgf_odf_com_del((GF_ODCom **)&esdU);\n\t\t\tgf_odf_codec_add_com(ODencode, (GF_ODCom *)esdU2);\n\t\t\tbreak;\n\n\t\t//brand new case: the ESRemove follows the same principle according to the spec...\n\t\tcase GF_ODF_ESD_REMOVE_REF_TAG:\n\t\t\t//both commands have the same structure, only the tags change\n\t\t\tesdR = (GF_ESDRemove *) com;\n\t\t\tesdR2 = (GF_ESDRemove *) gf_odf_com_new(GF_ODF_ESD_REMOVE_TAG);\n\t\t\tesdR2->ODID = esdR->ODID;\n\t\t\tesdR2->NbESDs = esdR->NbESDs;\n\t\t\t//alloc our stuff\n\t\t\tesdR2->ES_ID = (unsigned short*)gf_malloc(sizeof(u32) * esdR->NbESDs);\n\t\t\tif (!esdR2->ES_ID) {\n\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\t\t\tskipped = 0;\n\t\t\t//get the ES_ID in the mpod indicated in the ES_ID[]\n\t\t\tfor (i = 0; i < esdR->NbESDs; i++) {\n\t\t\t\t//if the ref index is not valid, remove this desc...\n\t\t\t\tif (gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[esdR->ES_ID[i] - 1]) == NULL) {\n\t\t\t\t\tskipped ++;\n\t\t\t\t} else {\n\t\t\t\t\t//the command in the file has the ref index of the trackID in the mpod\n\t\t\t\t\tesdR2->ES_ID[i - skipped] = mpod->trackIDs[esdR->ES_ID[i] - 1];\n\t\t\t\t}\n\t\t\t}\n\t\t\t//gf_realloc...\n\t\t\tif (skipped && (skipped != esdR2->NbESDs) ) {\n\t\t\t\tesdR2->NbESDs -= skipped;\n\t\t\t\tesdR2->ES_ID = (unsigned short*)gf_realloc(esdR2->ES_ID, sizeof(u32) * esdR2->NbESDs);\n\t\t\t}\n\t\t\tgf_odf_com_del((GF_ODCom **)&esdR);\n\t\t\tgf_odf_codec_add_com(ODencode, (GF_ODCom *)esdR2);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\te = gf_odf_codec_add_com(ODencode, com);\n\t\t\tif (e) goto err_exit;\n\t\t}\n\t}\n\t//encode our new AU\n\te = gf_odf_codec_encode(ODencode, 1);\n\tif (e) goto err_exit;\n\n\t//and set the buffer in the sample\n\tgf_free(sample->data);\n\tsample->data = NULL;\n\tsample->dataLength = 0;\n\te = gf_odf_codec_get_au(ODencode, &sample->data, &sample->dataLength);\n\nerr_exit:\n\tgf_odf_codec_del(ODdecode);\n\tgf_odf_codec_del(ODencode);\n\treturn e;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 4114,
    "critical_vars": [
      "tmp->internal_type"
    ],
    "function": "*mp4s_box_new",
    "filename": "gpac/CVE-2021-32134/CVE-2021-32134_CWE-476_328c6d682698fdb9878dbb4f282963d42c538c01_box_code_base.c.diff",
    "function_code": "GF_Box *mp4s_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGSampleEntryBox, GF_ISOM_BOX_TYPE_MP4S);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\ttmp->internal_type = GF_ISOM_SAMPLE_ENTRY_MP4S;\n\treturn (GF_Box *)tmp;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 4122,
    "critical_vars": [
      "tmp->internal_type"
    ],
    "function": "*encs_box_new",
    "filename": "gpac/CVE-2021-32134/CVE-2021-32134_CWE-476_328c6d682698fdb9878dbb4f282963d42c538c01_box_code_base.c.diff",
    "function_code": "GF_Box *encs_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGSampleEntryBox, GF_ISOM_BOX_TYPE_ENCS);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\ttmp->internal_type = GF_ISOM_SAMPLE_ENTRY_MP4S;\n\treturn (GF_Box *)tmp;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 187,
    "critical_vars": [
      "entry->internal_type"
    ],
    "function": "Media_GetESD",
    "filename": "gpac/CVE-2021-32134/CVE-2021-32134_CWE-476_328c6d682698fdb9878dbb4f282963d42c538c01_media.c.diff",
    "function_code": "GF_Err Media_GetESD(GF_MediaBox *mdia, u32 sampleDescIndex, GF_ESD **out_esd, Bool true_desc_only)\n{\n\tu32 type;\n\tGF_ESD *esd;\n\tGF_MPEGSampleEntryBox *entry = NULL;\n\tGF_ESDBox *ESDa;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\tGF_SampleDescriptionBox *stsd = mdia->information->sampleTable->SampleDescription;\n\n\t*out_esd = NULL;\n\tif (!stsd || !stsd->child_boxes || !sampleDescIndex || (sampleDescIndex > gf_list_count(stsd->child_boxes)) )\n\t\treturn GF_BAD_PARAM;\n\n\tesd = NULL;\n\tentry = (GF_MPEGSampleEntryBox*)gf_list_get(stsd->child_boxes, sampleDescIndex - 1);\n\tif (! entry) return GF_ISOM_INVALID_MEDIA;\n\n\t*out_esd = NULL;\n\tESDa = NULL;\n\ttype = entry->type;\n\tswitch (type) {\n\tcase GF_ISOM_BOX_TYPE_ENCV:\n\tcase GF_ISOM_BOX_TYPE_ENCA:\n\tcase GF_ISOM_BOX_TYPE_ENCS:\n\tcase GF_ISOM_BOX_TYPE_ENCF:\n\tcase GF_ISOM_BOX_TYPE_ENCM:\n\tcase GF_ISOM_BOX_TYPE_ENCT:\n\t\tsinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\t\tif (sinf && sinf->original_format) {\n\t\t\ttype = sinf->original_format->data_format;\n\t\t}\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_RESV:\n\t\tsinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_RINF);\n\t\tif (sinf && sinf->original_format) {\n\t\t\ttype = sinf->original_format->data_format;\n\t\t}\n\t\tbreak;\n\t}\n\n\n\tswitch (type) {\n\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tESDa = ((GF_MPEGVisualSampleEntryBox*)entry)->esd;\n\t\tif (ESDa) esd = (GF_ESD *) ESDa->desc;\n\t\t/*avc1 encrypted*/\n\t\telse esd = ((GF_MPEGVisualSampleEntryBox*) entry)->emul_esd;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_AVC1:\n\tcase GF_ISOM_BOX_TYPE_AVC2:\n\tcase GF_ISOM_BOX_TYPE_AVC3:\n\tcase GF_ISOM_BOX_TYPE_AVC4:\n\tcase GF_ISOM_BOX_TYPE_HVC1:\n\tcase GF_ISOM_BOX_TYPE_HEV1:\n\tcase GF_ISOM_BOX_TYPE_HVC2:\n\tcase GF_ISOM_BOX_TYPE_HEV2:\n\tcase GF_ISOM_BOX_TYPE_HVT1:\n\tcase GF_ISOM_BOX_TYPE_264B:\n\tcase GF_ISOM_BOX_TYPE_265B:\n\tcase GF_ISOM_BOX_TYPE_DVHE:\n\tcase GF_ISOM_BOX_TYPE_VVC1:\n\tcase GF_ISOM_BOX_TYPE_VVI1:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tesd = ((GF_MPEGVisualSampleEntryBox*) entry)->emul_esd;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SVC1:\n\tcase GF_ISOM_BOX_TYPE_MVC1:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tif ((mdia->mediaTrack->extractor_mode & 0x0000FFFF) != GF_ISOM_NALU_EXTRACT_INSPECT)\n\t\t\tAVC_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*) entry, mdia);\n\t\telse\n\t\t\tAVC_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*) entry, NULL);\n\t\tesd = ((GF_MPEGVisualSampleEntryBox*) entry)->emul_esd;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_LHE1:\n\tcase GF_ISOM_BOX_TYPE_LHV1:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tif ((mdia->mediaTrack->extractor_mode & 0x0000FFFF) != GF_ISOM_NALU_EXTRACT_INSPECT)\n\t\t\tHEVC_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*) entry, mdia);\n\t\telse\n\t\t\tHEVC_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*) entry, NULL);\n\t\tesd = ((GF_MPEGVisualSampleEntryBox*) entry)->emul_esd;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_AV01:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tAV1_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*)entry, mdia);\n\t\tesd = ((GF_MPEGVisualSampleEntryBox*)entry)->emul_esd;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_VP08:\n\tcase GF_ISOM_BOX_TYPE_VP09:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tVP9_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*)entry, mdia);\n\t\tesd = ((GF_MPEGVisualSampleEntryBox*)entry)->emul_esd;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n        {\n            GF_MPEGAudioSampleEntryBox *ase = (GF_MPEGAudioSampleEntryBox*)entry;\n            ESDa = ase->esd;\n            if (ESDa) {\n\t\t\t\tesd = (GF_ESD *) ESDa->desc;\n            } else if (!true_desc_only) {\n\t\t\t\tBool make_mp4a = GF_FALSE;\n\t\t\t\tsinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\n\t\t\t\tif (sinf && sinf->original_format) {\n\t\t\t\t\tif (sinf->original_format->data_format==GF_ISOM_BOX_TYPE_MP4A) {\n\t\t\t\t\t\tmake_mp4a = GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Assuming that if no ESD is provided the stream is Basic MPEG-4 AAC LC\n\t\t\t\t\tmake_mp4a = GF_TRUE;\n\t\t\t\t}\n\t\t\t\tif (make_mp4a) {\n\t\t\t\t\tGF_M4ADecSpecInfo aacinfo;\n\t\t\t\t\tmemset(&aacinfo, 0, sizeof(GF_M4ADecSpecInfo));\n\t\t\t\t\taacinfo.nb_chan = ase->channel_count;\n\t\t\t\t\taacinfo.base_object_type = GF_M4A_AAC_LC;\n\t\t\t\t\taacinfo.base_sr = ase->samplerate_hi;\n\t\t\t\t\t*out_esd = gf_odf_desc_esd_new(0);\n\t\t\t\t\t(*out_esd)->decoderConfig->streamType = GF_STREAM_AUDIO;\n\t\t\t\t\t(*out_esd)->decoderConfig->objectTypeIndication = GF_CODECID_AAC_MPEG4;\n\t\t\t\t\tgf_m4a_write_config(&aacinfo, &(*out_esd)->decoderConfig->decoderSpecificInfo->data, &(*out_esd)->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\t\t}\n            }\n        }\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\tif (entry->internal_type==GF_ISOM_SAMPLE_ENTRY_MP4S) {\n\t\t\tESDa = entry->esd;\n\t\t\tif (ESDa) esd = (GF_ESD *) ESDa->desc;\n\t\t}\n\t\tbreak;\n#ifndef GPAC_DISABLE_TTXT\n\tcase GF_ISOM_BOX_TYPE_TX3G:\n\tcase GF_ISOM_BOX_TYPE_TEXT:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_MP4S)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\n\t\tif (!true_desc_only && mdia->mediaTrack->moov->mov->convert_streaming_text) {\n\t\t\tGF_Err e = gf_isom_get_ttxt_esd(mdia, out_esd);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n#endif\n#ifndef GPAC_DISABLE_VTT\n\tcase GF_ISOM_BOX_TYPE_WVTT:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_MP4S)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t{\n\t\tGF_WebVTTSampleEntryBox*vtte = (GF_WebVTTSampleEntryBox*)entry;\n\t\tesd =  gf_odf_desc_esd_new(2);\n\t\t*out_esd = esd;\n\t\tesd->decoderConfig->streamType = GF_STREAM_TEXT;\n\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_WEBVTT;\n\t\tif (vtte->config) {\n\t\t\tesd->decoderConfig->decoderSpecificInfo->dataLength = (u32) strlen(vtte->config->string);\n\t\t\tesd->decoderConfig->decoderSpecificInfo->data = gf_malloc(sizeof(char)*esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\tmemcpy(esd->decoderConfig->decoderSpecificInfo->data, vtte->config->string, esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t}\n\t}\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STPP:\n\tcase GF_ISOM_BOX_TYPE_SBTT:\n\tcase GF_ISOM_BOX_TYPE_STXT:\n\t\tbreak;\n#endif\n\n\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tif (!true_desc_only) {\n\t\t\tGF_Err e = gf_isom_get_3gpp_audio_esd(mdia->information->sampleTable, type, (GF_GenericAudioSampleEntryBox*)entry, out_esd);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\t\t} else return GF_ISOM_INVALID_MEDIA;\n\n\tcase GF_ISOM_SUBTYPE_OPUS:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t{\n\t\tGF_OpusSpecificBox *e = ((GF_MPEGAudioSampleEntryBox*)entry)->cfg_opus;\n\t\tGF_BitStream *bs_out;\n\t\tif (!e) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"ESD not found for Opus\\n)\"));\n\t\t\tbreak;\n\t\t}\n\n\t\t*out_esd = gf_odf_desc_esd_new(2);\n\t\t(*out_esd)->decoderConfig->streamType = GF_STREAM_AUDIO;\n\t\t(*out_esd)->decoderConfig->objectTypeIndication = GF_CODECID_OPUS;\n\n\t\t//serialize box with header - compatibility with ffmpeg\n\t\tbs_out = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tgf_isom_box_size((GF_Box *) e);\n\t\tgf_isom_box_write((GF_Box *) e, bs_out);\n\t\tgf_bs_get_content(bs_out, & (*out_esd)->decoderConfig->decoderSpecificInfo->data, & (*out_esd)->decoderConfig->decoderSpecificInfo->dataLength);\n\t\tgf_bs_del(bs_out);\n\t\tbreak;\n\t}\n\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tif (true_desc_only) {\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\t} else {\n\t\t\tesd =  gf_odf_desc_esd_new(2);\n\t\t\t*out_esd = esd;\n\t\t\tesd->decoderConfig->streamType = GF_STREAM_VISUAL;\n\t\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_H263;\n\t\t\tbreak;\n\t\t}\n\n\tcase GF_ISOM_SUBTYPE_MP3:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tif (true_desc_only) {\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\t} else {\n\t\t\tesd =  gf_odf_desc_esd_new(2);\n\t\t\t*out_esd = esd;\n\t\t\tesd->decoderConfig->streamType = GF_STREAM_AUDIO;\n\t\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_MPEG_AUDIO;\n\t\t\tbreak;\n\t\t}\n\n\tcase GF_ISOM_SUBTYPE_LSR1:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_MP4S)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tif (true_desc_only) {\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\t} else {\n\t\t\tGF_LASeRSampleEntryBox*ptr = (GF_LASeRSampleEntryBox*)entry;\n\t\t\tesd =  gf_odf_desc_esd_new(2);\n\t\t\t*out_esd = esd;\n\t\t\tesd->decoderConfig->streamType = GF_STREAM_SCENE;\n\t\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_LASER;\n\t\t\tesd->decoderConfig->decoderSpecificInfo->dataLength = ptr->lsr_config->hdr_size;\n\t\t\tesd->decoderConfig->decoderSpecificInfo->data = gf_malloc(sizeof(char)*ptr->lsr_config->hdr_size);\n\t\t\tif (!esd->decoderConfig->decoderSpecificInfo->data) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(esd->decoderConfig->decoderSpecificInfo->data, ptr->lsr_config->hdr, sizeof(char)*ptr->lsr_config->hdr_size);\n\t\t\tbreak;\n\t\t}\n\tcase GF_ISOM_SUBTYPE_MH3D_MHA1:\n\tcase GF_ISOM_SUBTYPE_MH3D_MHA2:\n\tcase GF_ISOM_SUBTYPE_MH3D_MHM1:\n\tcase GF_ISOM_SUBTYPE_MH3D_MHM2:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\n\t\tif (true_desc_only) {\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\t} else {\n\t\t\tGF_MPEGAudioSampleEntryBox*ptr = (GF_MPEGAudioSampleEntryBox*)entry;\n\t\t\tesd = gf_odf_desc_esd_new(2);\n\t\t\t*out_esd = esd;\n\t\t\tesd->decoderConfig->streamType = GF_STREAM_AUDIO;\n\t\t\tif ((type==GF_ISOM_SUBTYPE_MH3D_MHA1) || (type==GF_ISOM_SUBTYPE_MH3D_MHA2))\n\t\t\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_MPHA;\n\t\t\telse\n\t\t\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_MHAS;\n\t\t\tif (ptr->cfg_mha) {\n\t\t\t\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\t\t\t\tgf_bs_write_u8(bs, ptr->cfg_mha->configuration_version);\n\t\t\t\tgf_bs_write_u8(bs, ptr->cfg_mha->mha_pl_indication);\n\t\t\t\tgf_bs_write_u8(bs, ptr->cfg_mha->reference_channel_layout);\n\t\t\t\tgf_bs_write_u16(bs, ptr->cfg_mha->mha_config ? ptr->cfg_mha->mha_config_size : 0);\n\t\t\t\tif (ptr->cfg_mha->mha_config && ptr->cfg_mha->mha_config_size)\n\t\t\t\t\tgf_bs_write_data(bs, ptr->cfg_mha->mha_config, ptr->cfg_mha->mha_config_size);\n\n\t\t\t\tgf_bs_get_content(bs, &esd->decoderConfig->decoderSpecificInfo->data, &esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\t\tgf_bs_del(bs);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn GF_ISOM_INVALID_MEDIA;\n\t}\n\n\tif (true_desc_only) {\n\t\tif (!esd) return GF_ISOM_INVALID_MEDIA;\n\t\t*out_esd = esd;\n\t\treturn GF_OK;\n\t} else {\n\t\tif (!esd && !*out_esd) return GF_ISOM_INVALID_MEDIA;\n\t\tif (*out_esd == NULL) return gf_odf_desc_copy((GF_Descriptor *)esd, (GF_Descriptor **)out_esd);\n\t}\n\treturn GF_OK;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 6116,
    "critical_vars": [
      "avc->s_info.sps"
    ],
    "function": "gf_avc_parse_nalu",
    "filename": "gpac/CVE-2021-40565/CVE-2021-40565_CWE-476_893fb99b606eebfae46cde151846a980e689039b_av_parsers.c.diff",
    "function_code": "s32 gf_avc_parse_nalu(GF_BitStream *bs, AVCState *avc)\n{\n\tu8 idr_flag;\n\ts32 slice, ret;\n\tu32 nal_hdr;\n\tAVCSliceInfo n_state;\n\n\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\n\tnal_hdr = gf_bs_read_u8(bs);\n\n\tslice = 0;\n\tmemcpy(&n_state, &avc->s_info, sizeof(AVCSliceInfo));\n\tavc->last_nal_type_parsed = n_state.nal_unit_type = nal_hdr & 0x1F;\n\tn_state.nal_ref_idc = (nal_hdr >> 5) & 0x3;\n\n\tidr_flag = 0;\n\n\tswitch (n_state.nal_unit_type) {\n\tcase GF_AVC_NALU_ACCESS_UNIT:\n\tcase GF_AVC_NALU_END_OF_SEQ:\n\tcase GF_AVC_NALU_END_OF_STREAM:\n\t\tret = 1;\n\t\tbreak;\n\n\tcase GF_AVC_NALU_SVC_SLICE:\n\t\tSVC_ReadNal_header_extension(bs, &n_state.NalHeader);\n\t\t// slice buffer - read the info and compare.\n\t\t/*ret = */svc_parse_slice(bs, avc, &n_state);\n\t\tif (avc->s_info.nal_ref_idc) {\n\t\t\tn_state.poc_lsb_prev = avc->s_info.poc_lsb;\n\t\t\tn_state.poc_msb_prev = avc->s_info.poc_msb;\n\t\t}\n\t\tavc_compute_poc(&n_state);\n\n\t\tif (avc->s_info.poc != n_state.poc) {\n\t\t\tmemcpy(&avc->s_info, &n_state, sizeof(AVCSliceInfo));\n\t\t\treturn 1;\n\t\t}\n\t\tmemcpy(&avc->s_info, &n_state, sizeof(AVCSliceInfo));\n\t\treturn 0;\n\n\tcase GF_AVC_NALU_SVC_PREFIX_NALU:\n\t\tSVC_ReadNal_header_extension(bs, &n_state.NalHeader);\n\t\treturn 0;\n\n\tcase GF_AVC_NALU_IDR_SLICE:\n\tcase GF_AVC_NALU_NON_IDR_SLICE:\n\tcase GF_AVC_NALU_DP_A_SLICE:\n\tcase GF_AVC_NALU_DP_B_SLICE:\n\tcase GF_AVC_NALU_DP_C_SLICE:\n\t\tslice = 1;\n\t\t/* slice buffer - read the info and compare.*/\n\t\tret = avc_parse_slice(bs, avc, idr_flag, &n_state);\n\t\tif (ret < 0) return ret;\n\t\tret = 0;\n\t\tif (\n\t\t\t((avc->s_info.nal_unit_type > GF_AVC_NALU_IDR_SLICE) || (avc->s_info.nal_unit_type < GF_AVC_NALU_NON_IDR_SLICE))\n\t\t\t&& (avc->s_info.nal_unit_type != GF_AVC_NALU_SVC_SLICE)\n\t\t\t) {\n\t\t\tbreak;\n\t\t}\n\t\tif (avc->s_info.frame_num != n_state.frame_num) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (avc->s_info.field_pic_flag != n_state.field_pic_flag) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif ((avc->s_info.nal_ref_idc != n_state.nal_ref_idc) &&\n\t\t\t(!avc->s_info.nal_ref_idc || !n_state.nal_ref_idc)) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (!avc->s_info.sps)\n\t\t\treturn -1;\n\n\t\tif (avc->s_info.sps->poc_type == n_state.sps->poc_type) {\n\t\t\tif (!avc->s_info.sps->poc_type) {\n\t\t\t\tif (!n_state.bottom_field_flag && (avc->s_info.poc_lsb != n_state.poc_lsb)) {\n\t\t\t\t\tret = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (avc->s_info.delta_poc_bottom != n_state.delta_poc_bottom) {\n\t\t\t\t\tret = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (avc->s_info.sps->poc_type == 1) {\n\t\t\t\tif (avc->s_info.delta_poc[0] != n_state.delta_poc[0]) {\n\t\t\t\t\tret = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (avc->s_info.delta_poc[1] != n_state.delta_poc[1]) {\n\t\t\t\t\tret = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (n_state.nal_unit_type == GF_AVC_NALU_IDR_SLICE) {\n\t\t\tif (avc->s_info.nal_unit_type != GF_AVC_NALU_IDR_SLICE) { /*IdrPicFlag differs in value*/\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (avc->s_info.idr_pic_id != n_state.idr_pic_id) { /*both IDR and idr_pic_id differs*/\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase GF_AVC_NALU_SEQ_PARAM:\n\t\tavc->last_ps_idx = gf_avc_read_sps_bs_internal(bs, avc, 0, NULL, nal_hdr);\n\t\tif (avc->last_ps_idx < 0) return -1;\n\t\treturn 0;\n\n\tcase GF_AVC_NALU_PIC_PARAM:\n\t\tavc->last_ps_idx = gf_avc_read_pps_bs_internal(bs, avc, nal_hdr);\n\t\tif (avc->last_ps_idx < 0) return -1;\n\t\treturn 0;\n\tcase GF_AVC_NALU_SVC_SUBSEQ_PARAM:\n\t\tavc->last_ps_idx = gf_avc_read_sps_bs_internal(bs, avc, 1, NULL, nal_hdr);\n\t\tif (avc->last_ps_idx < 0) return -1;\n\t\treturn 0;\n\tcase GF_AVC_NALU_SEQ_PARAM_EXT:\n\t\tavc->last_ps_idx = (s32) gf_bs_read_ue(bs);\n\t\tif (avc->last_ps_idx < 0) return -1;\n\t\treturn 0;\n\n\tcase GF_AVC_NALU_SEI:\n\tcase GF_AVC_NALU_FILLER_DATA:\n\t\treturn 0;\n\n\tdefault:\n\t\tif (avc->s_info.nal_unit_type <= GF_AVC_NALU_IDR_SLICE) ret = 1;\n\t\t//To detect change of AU when multiple sps and pps in stream\n\t\telse if ((nal_hdr & 0x1F) == GF_AVC_NALU_SEI && avc->s_info.nal_unit_type == GF_AVC_NALU_SVC_SLICE)\n\t\t\tret = 1;\n\t\telse if ((nal_hdr & 0x1F) == GF_AVC_NALU_SEQ_PARAM && avc->s_info.nal_unit_type == GF_AVC_NALU_SVC_SLICE)\n\t\t\tret = 1;\n\t\telse\n\t\t\tret = 0;\n\t\tbreak;\n\t}\n\n\t/* save _prev values */\n\tif (ret && avc->s_info.sps) {\n\t\tn_state.frame_num_offset_prev = avc->s_info.frame_num_offset;\n\t\tif ((avc->s_info.sps->poc_type != 2) || (avc->s_info.nal_ref_idc != 0))\n\t\t\tn_state.frame_num_prev = avc->s_info.frame_num;\n\t\tif (avc->s_info.nal_ref_idc) {\n\t\t\tn_state.poc_lsb_prev = avc->s_info.poc_lsb;\n\t\t\tn_state.poc_msb_prev = avc->s_info.poc_msb;\n\t\t}\n\t}\n\tif (slice)\n\t\tavc_compute_poc(&n_state);\n\tmemcpy(&avc->s_info, &n_state, sizeof(AVCSliceInfo));\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 313,
    "critical_vars": [
      "e",
      "is_root_box"
    ],
    "function": "gf_isom_box_parse_ex",
    "filename": "gpac/CVE-2022-29340/CVE-2022-29340_CWE-476_37592ad86c6ca934d34740012213e467acc4a3b0_box_funcs.c.diff",
    "function_code": "GF_Err gf_isom_box_parse_ex(GF_Box **outBox, GF_BitStream *bs, u32 parent_type, Bool is_root_box, u64 parent_size)\n{\n\tu32 type, uuid_type, hdr_size, restore_type;\n\tu64 size, start, comp_start, end;\n\tchar uuid[16];\n\tGF_Err e;\n\tGF_BitStream *uncomp_bs = NULL;\n\tu8 *uncomp_data = NULL;\n\tu32 compressed_size=0;\n\tGF_Box *newBox;\n\tBool skip_logs = (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_NO_LOGS ) ? GF_TRUE : GF_FALSE;\n\tBool is_special = GF_TRUE;\n\t\n\tif ((bs == NULL) || (outBox == NULL) ) return GF_BAD_PARAM;\n\t*outBox = NULL;\n\tif (gf_bs_available(bs) < 8) {\n\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t}\n\n\tcomp_start = start = gf_bs_get_position(bs);\n\n\tuuid_type = 0;\n\tsize = (u64) gf_bs_read_u32(bs);\n\thdr_size = 4;\n\t/*fix for some boxes found in some old hinted files*/\n\tif ((size >= 2) && (size <= 4)) {\n\t\tsize = 4;\n\t\ttype = GF_ISOM_BOX_TYPE_VOID;\n\t} else {\n\t\ttype = gf_bs_read_u32(bs);\n\t\thdr_size += 4;\n\t\t/*no size means till end of file - EXCEPT FOR some old QuickTime boxes...*/\n\t\tif (type == GF_ISOM_BOX_TYPE_TOTL)\n\t\t\tsize = 12;\n\t\tif (!size) {\n\t\t\tif (is_root_box) {\n\t\t\t\tif (!skip_logs) {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Warning Read Box type %s (0x%08X) size 0 reading till the end of file\\n\", gf_4cc_to_str(type), type));\n\t\t\t\t}\n\t\t\t\tsize = gf_bs_available(bs) + 8;\n\t\t\t} else {\n\t\t\t\tif (!skip_logs) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Read Box type %s (0x%08X) at position \"LLU\" has size 0 but is not at root/file level. Forbidden, skipping end of parent box !\\n\", gf_4cc_to_str(type), type, start));\n\t\t\t\t\treturn GF_SKIP_BOX;\n\t\t\t\t}\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t}\n\t\tif (is_root_box && (size>=8)) {\n\t\t\tBool do_uncompress = GF_FALSE;\n\t\t\tu8 *compb = NULL;\n\t\t\tu32 osize = 0;\n\t\t\tu32 otype = type;\n\t\t\tif (type==GF_4CC('!', 'm', 'o', 'f')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_MOOF;\n\t\t\t}\n\t\t\telse if (type==GF_4CC('!', 'm', 'o', 'v')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_MOOV;\n\t\t\t}\n\t\t\telse if (type==GF_4CC('!', 's', 'i', 'x')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_SIDX;\n\t\t\t}\n\t\t\telse if (type==GF_4CC('!', 's', 's', 'x')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_SSIX;\n\t\t\t}\n\n\t\t\tif (do_uncompress) {\n\t\t\t\tcompb = gf_malloc((u32) (size-8));\n\n\t\t\t\tcompressed_size = (u32) (size - 8);\n\t\t\t\tgf_bs_read_data(bs, compb, compressed_size);\n\t\t\t\te = gf_gz_decompress_payload(compb, compressed_size, &uncomp_data, &osize);\n\t\t\t\tif (e) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Failed to uncompress payload for box type %s (0x%08X)\\n\", gf_4cc_to_str(otype), otype));\n\t\t\t\t\treturn e;\n\t\t\t\t}\n\n\t\t\t\t//keep size as complete box size for tests below\n\t\t\t\tsize = osize + 8;\n\t\t\t\tuncomp_bs = gf_bs_new(uncomp_data, osize, GF_BITSTREAM_READ);\n\t\t\t\tbs = uncomp_bs;\n\t\t\t\tstart = 0;\n\t\t\t\tgf_free(compb);\n\t\t\t}\n\t\t}\n\t}\n\t/*handle uuid*/\n\tmemset(uuid, 0, 16);\n\tif (type == GF_ISOM_BOX_TYPE_UUID ) {\n\t\tif (gf_bs_available(bs) < 16) {\n\t\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t\t}\n\t\tgf_bs_read_data(bs, uuid, 16);\n\t\thdr_size += 16;\n\t\tuuid_type = gf_isom_solve_uuid_box(uuid);\n\t}\n\n\t//handle large box\n\tif (size == 1) {\n\t\tif (gf_bs_available(bs) < 8) {\n\t\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t\t}\n\t\tsize = gf_bs_read_u64(bs);\n\t\thdr_size += 8;\n\t}\n\tif (!skip_logs)\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Read Box type %s size \"LLD\" start \"LLD\"\\n\", gf_4cc_to_str(type), size,  start));\n\n\tif ( size < hdr_size ) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Box %s size \"LLD\" less than box header size %d\\n\", gf_4cc_to_str(type), size, hdr_size));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\t//if parent size is given, make sure box fits within parent\n\tif (parent_size && (parent_size<size)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Box %s size \"LLU\" is larger than remaining parent size \"LLU\"\\n\", gf_4cc_to_str(type), size, parent_size ));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\trestore_type = 0;\n\tif ((parent_type==GF_ISOM_BOX_TYPE_STSD) && (type==GF_QT_SUBTYPE_RAW) ) {\n\t\tu64 cookie = gf_bs_get_cookie(bs);\n\t\trestore_type = type;\n\t\tif (cookie & GF_ISOM_BS_COOKIE_VISUAL_TRACK)\n\t\t\ttype = GF_QT_SUBTYPE_RAW_VID;\n\t\telse\n\t\t\ttype = GF_QT_SUBTYPE_RAW_AUD;\n\n\t}\n\n\t//some special boxes (references and track groups) are handled by a single generic box with an associated ref/group type\n\tif (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TREF)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFT);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t\t((GF_TrackReferenceTypeBox*)newBox)->reference_type = type;\n\t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_IREF)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFI);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t\t((GF_ItemReferenceTypeBox*)newBox)->reference_type = type;\n\t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TRGR)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_TRGT);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t\t((GF_TrackGroupTypeBox*)newBox)->group_type = type;\n\t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_GRPL)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_GRPT);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t\t((GF_EntityToGroupTypeBox*)newBox)->grouping_type = type;\n\t} else {\n\t\t//OK, create the box based on the type\n\t\tis_special = GF_FALSE;\n\t\tnewBox = gf_isom_box_new_ex(uuid_type ? uuid_type : type, parent_type, skip_logs, is_root_box);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t}\n\n\t//OK, init and read this box\n\tif (type==GF_ISOM_BOX_TYPE_UUID && !is_special) {\n\t\tmemcpy(((GF_UUIDBox *)newBox)->uuid, uuid, 16);\n\t\t((GF_UUIDBox *)newBox)->internal_4cc = uuid_type;\n\t}\n\n\tif (!newBox->type) newBox->type = type;\n\tif (restore_type)\n\t\tnewBox->type = restore_type;\n\n\tend = gf_bs_available(bs);\n\tif (size - hdr_size > end ) {\n\t\tnewBox->size = size - hdr_size - end;\n\t\t*outBox = newBox;\n\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t}\n\n\tnewBox->size = size - hdr_size;\n\n\te = gf_isom_full_box_read(newBox, bs);\n\tif (!e) e = gf_isom_box_read(newBox, bs);\n\tif (e) {\n\t\tif (gf_opts_get_bool(\"core\", \"no-check\"))\n\t\t\te = GF_OK;\n\t}\n\tnewBox->size = size;\n\tend = gf_bs_get_position(bs);\n\n\tif (uncomp_bs) {\n\t\tgf_free(uncomp_data);\n\t\tgf_bs_del(uncomp_bs);\n\t\tif (e) {\n\t\t\tgf_isom_box_del(newBox);\n\t\t\t*outBox = NULL;\n\t\t\treturn e;\n\t\t}\n\t\t//move size to real bitstream offsets for tests below\n\t\tsize -= 8;\n\t\t//remember compressed vs real size info for moof in order to properly recompute data_offset/base_data_offset\n\t\tif (type==GF_ISOM_BOX_TYPE_MOOF) {\n\t\t\t((GF_MovieFragmentBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t}\n\t\t//remember compressed vs real size info for moov in order to properly recompute chunk offset\n\t\telse if (type==GF_ISOM_BOX_TYPE_MOOV) {\n\t\t\t((GF_MovieBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t\t((GF_MovieBox *)newBox)->file_offset = comp_start;\n\t\t}\n\t\t//remember compressed vs real size info for dump\n\t\telse if (type==GF_ISOM_BOX_TYPE_SIDX) {\n\t\t\t((GF_SegmentIndexBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t}\n\t\t//remember compressed vs real size info for dump\n\t\telse if (type==GF_ISOM_BOX_TYPE_SSIX) {\n\t\t\t((GF_SubsegmentIndexBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t}\n\t\tnewBox->internal_flags = GF_ISOM_BOX_COMPRESSED;\n\t}\n\n\n\tif (e && (e != GF_ISOM_INCOMPLETE_FILE)) {\n\t\tgf_isom_box_del(newBox);\n\t\t*outBox = NULL;\n\t\tif (is_root_box && (e==GF_SKIP_BOX))\n\t\t\te = GF_ISOM_INVALID_FILE;\n\n\t\tif (!skip_logs && (e!=GF_SKIP_BOX)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Read Box \\\"%s\\\" (start \"LLU\") failed (%s) - skipping\\n\", gf_4cc_to_str(type), start, gf_error_to_string(e)));\n\t\t}\n\t\t//we don't try to reparse known boxes that have been failing (too dangerous)\n\t\treturn e;\n\t}\n\n\tif (end-start > size) {\n\t\tif (!skip_logs) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" size \"LLU\" (start \"LLU\") invalid (read \"LLU\")\\n\", gf_4cc_to_str(type), size, start, (end-start) ));\n\t\t}\n\t\t/*let's still try to load the file since no error was notified*/\n\t\tgf_bs_seek(bs, start+size);\n\t} else if (end-start < size) {\n\t\tu32 to_skip = (u32) (size-(end-start));\n\t\tif (!skip_logs) {\n\t\t\tif ((to_skip!=4) || gf_bs_peek_bits(bs, 32, 0)) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" (start \"LLU\") has %u extra bytes\\n\", gf_4cc_to_str(type), start, to_skip));\n\t\t\t\tunused_bytes += to_skip;\n\t\t\t}\n\t\t}\n\t\tgf_bs_skip_bytes(bs, to_skip);\n\t}\n\t*outBox = newBox;\n\n\treturn e;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 970,
    "critical_vars": [
      "svcc"
    ],
    "function": "gf_hinter_track_finalize",
    "filename": "gpac/CVE-2020-35982/CVE-2020-35982_CWE-476_a4eb327049132359cae54b59faec9e2f14c5a619_isom_hinter.c.diff",
    "function_code": "GF_Err gf_hinter_track_finalize(GF_RTPHinter *tkHint, Bool AddSystemInfo)\n{\n\tu32 Width, Height;\n\tGF_ESD *esd;\n\tchar sdpLine[20000];\n\tchar mediaName[30], payloadName[30];\n    u32 mtype;\n\n\tWidth = Height = 0;\n\tgf_isom_sdp_clean_track(tkHint->file, tkHint->TrackNum);\n    mtype = gf_isom_get_media_type(tkHint->file, tkHint->TrackNum);\n    if (gf_isom_is_video_handler_type(mtype))\n\t\tgf_isom_get_visual_info(tkHint->file, tkHint->TrackNum, 1, &Width, &Height);\n\n\tgf_rtp_builder_get_payload_name(tkHint->rtp_p, payloadName, mediaName);\n\n\t/*TODO- extract out of rtp_p for future live tools*/\n\tsprintf(sdpLine, \"m=%s 0 RTP/%s %d\", mediaName, tkHint->rtp_p->slMap.IV_length ? \"SAVP\" : \"AVP\", tkHint->rtp_p->PayloadType);\n\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\tif (tkHint->bandwidth) {\n\t\tsprintf(sdpLine, \"b=AS:%d\", tkHint->bandwidth);\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n\tif (tkHint->nb_chan) {\n\t\tsprintf(sdpLine, \"a=rtpmap:%d %s/%d/%d\", tkHint->rtp_p->PayloadType, payloadName, tkHint->rtp_p->sl_config.timestampResolution, tkHint->nb_chan);\n\t} else {\n\t\tsprintf(sdpLine, \"a=rtpmap:%d %s/%d\", tkHint->rtp_p->PayloadType, payloadName, tkHint->rtp_p->sl_config.timestampResolution);\n\t}\n\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t/*control for MPEG-4*/\n\tif (AddSystemInfo) {\n\t\tsprintf(sdpLine, \"a=mpeg4-esid:%d\", gf_isom_get_track_id(tkHint->file, tkHint->TrackNum));\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n\t/*control for QTSS/DSS*/\n\tsprintf(sdpLine, \"a=control:trackID=%d\", gf_isom_get_track_id(tkHint->file, tkHint->HintTrack));\n\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\n\t/*H263 extensions*/\n\tif (tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_H263) {\n\t\tsprintf(sdpLine, \"a=cliprect:0,0,%d,%d\", Height, Width);\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n\t/*AMR*/\n\telse if ((tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_AMR) || (tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_AMR_WB)) {\n\t\tsprintf(sdpLine, \"a=fmtp:%d octet-align=1\", tkHint->rtp_p->PayloadType);\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n\t/*Text*/\n\telse if (tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_3GPP_TEXT) {\n\t\tu32 w, h, i, m_w, m_h;\n\t\ts32 tx, ty;\n\t\ts16 l;\n\n\t\tgf_isom_get_track_layout_info(tkHint->file, tkHint->TrackNum, &w, &h, &tx, &ty, &l);\n\t\tm_w = w;\n\t\tm_h = h;\n\t\tfor (i=0; i<gf_isom_get_track_count(tkHint->file); i++) {\n\t\t\tswitch (gf_isom_get_media_type(tkHint->file, i+1)) {\n\t\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\t\tcase GF_ISOM_MEDIA_AUXV:\n\t\t\tcase GF_ISOM_MEDIA_PICT:\n\t\t\t\tgf_isom_get_track_layout_info(tkHint->file, i+1, &w, &h, &tx, &ty, &l);\n\t\t\t\tif (w>m_w) m_w = w;\n\t\t\t\tif (h>m_h) m_h = h;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tgf_media_format_ttxt_sdp(tkHint->rtp_p, payloadName, sdpLine, w, h, tx, ty, l, m_w, m_h, NULL);\n\n\t\tstrcat(sdpLine, \"; tx3g=\");\n\t\tfor (i=0; i<gf_isom_get_sample_description_count(tkHint->file, tkHint->TrackNum); i++) {\n\t\t\tu8 *tx3g;\n\t\t\tchar buffer[2000];\n\t\t\tu32 tx3g_len, len;\n\t\t\tgf_isom_text_get_encoded_tx3g(tkHint->file, tkHint->TrackNum, i+1, GF_RTP_TX3G_SIDX_OFFSET, &tx3g, &tx3g_len);\n\t\t\tlen = gf_base64_encode(tx3g, tx3g_len, buffer, 2000);\n\t\t\tgf_free(tx3g);\n\t\t\tbuffer[len] = 0;\n\t\t\tif (i) strcat(sdpLine, \", \");\n\t\t\tstrcat(sdpLine, buffer);\n\t\t}\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n\t/*EVRC/SMV in non header-free mode*/\n\telse if ((tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_EVRC_SMV) && (tkHint->rtp_p->auh_size>1)) {\n\t\tsprintf(sdpLine, \"a=fmtp:%d maxptime=%d\", tkHint->rtp_p->PayloadType, tkHint->rtp_p->auh_size*20);\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n\t/*H264/AVC*/\n\telse if ((tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_H264_AVC) || (tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_H264_SVC))  {\n\t\tGF_AVCConfig *avcc = gf_isom_avc_config_get(tkHint->file, tkHint->TrackNum, 1);\n\t\tGF_AVCConfig *svcc = gf_isom_svc_config_get(tkHint->file, tkHint->TrackNum, 1);\n\t\t/*TODO - check syntax for SVC (might be some extra signaling)*/\n\n\t\tif (avcc) {\n\t\t\tsprintf(sdpLine, \"a=fmtp:%d profile-level-id=%02X%02X%02X; packetization-mode=1\", tkHint->rtp_p->PayloadType, avcc->AVCProfileIndication, avcc->profile_compatibility, avcc->AVCLevelIndication);\n\t\t} else {\n\t\t\tif (!svcc)\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\tsprintf(sdpLine, \"a=fmtp:%d profile-level-id=%02X%02X%02X; packetization-mode=1\", tkHint->rtp_p->PayloadType, svcc->AVCProfileIndication, svcc->profile_compatibility, svcc->AVCLevelIndication);\n\t\t}\n\n\t\twrite_avc_config(sdpLine, avcc, svcc);\n\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t\tgf_odf_avc_cfg_del(avcc);\n\t\tgf_odf_avc_cfg_del(svcc);\n\t}\n\t/*MPEG-4 decoder config*/\n\telse if (tkHint->rtp_p->rtp_payt==GF_RTP_PAYT_MPEG4) {\n\t\tesd = gf_isom_get_esd(tkHint->file, tkHint->TrackNum, 1);\n\n\t\tif (esd && esd->decoderConfig && esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->data) {\n\t\t\tgf_rtp_builder_format_sdp(tkHint->rtp_p, payloadName, sdpLine, esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t} else {\n\t\t\tgf_rtp_builder_format_sdp(tkHint->rtp_p, payloadName, sdpLine, NULL, 0);\n\t\t}\n\t\tif (esd) gf_odf_desc_del((GF_Descriptor *)esd);\n\n\t\tif (tkHint->rtp_p->slMap.IV_length) {\n\t\t\tconst char *kms;\n\t\t\tgf_isom_get_ismacryp_info(tkHint->file, tkHint->TrackNum, 1, NULL, NULL, NULL, NULL, &kms, NULL, NULL, NULL);\n\t\t\tif (!strnicmp(kms, \"(key)\", 5) || !strnicmp(kms, \"(ipmp)\", 6) || !strnicmp(kms, \"(uri)\", 5)) {\n\t\t\t\tstrcat(sdpLine, \"; ISMACrypKey=\");\n\t\t\t} else {\n\t\t\t\tstrcat(sdpLine, \"; ISMACrypKey=(uri)\");\n\t\t\t}\n\t\t\tstrcat(sdpLine, kms);\n\t\t}\n\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n\t/*MPEG-4 Audio LATM*/\n\telse if (tkHint->rtp_p->rtp_payt==GF_RTP_PAYT_LATM) {\n\t\tGF_BitStream *bs;\n\t\tu8 *config_bytes;\n\t\tu32 config_size;\n\n\t\t/* form config string */\n\t\tbs = gf_bs_new(NULL, 32, GF_BITSTREAM_WRITE);\n\t\tgf_bs_write_int(bs, 0, 1); /* AudioMuxVersion */\n\t\tgf_bs_write_int(bs, 1, 1); /* all streams same time */\n\t\tgf_bs_write_int(bs, 0, 6); /* numSubFrames */\n\t\tgf_bs_write_int(bs, 0, 4); /* numPrograms */\n\t\tgf_bs_write_int(bs, 0, 3); /* numLayer */\n\n\t\t/* audio-specific config */\n\t\tesd = gf_isom_get_esd(tkHint->file, tkHint->TrackNum, 1);\n\t\tif (esd && esd->decoderConfig && esd->decoderConfig->decoderSpecificInfo) {\n\t\t\t/*PacketVideo patch: don't signal SBR and PS stuff, not allowed in LATM with audioMuxVersion=0*/\n\t\t\tgf_bs_write_data(bs, esd->decoderConfig->decoderSpecificInfo->data, MIN(esd->decoderConfig->decoderSpecificInfo->dataLength, 2) );\n\t\t}\n\t\tif (esd) gf_odf_desc_del((GF_Descriptor *)esd);\n\n\t\t/* other data */\n\t\tgf_bs_write_int(bs, 0, 3); /* frameLengthType */\n\t\tgf_bs_write_int(bs, 0xff, 8); /* latmBufferFullness */\n\t\tgf_bs_write_int(bs, 0, 1); /* otherDataPresent */\n\t\tgf_bs_write_int(bs, 0, 1); /* crcCheckPresent */\n\t\tgf_bs_get_content(bs, &config_bytes, &config_size);\n\t\tgf_bs_del(bs);\n\n\t\tgf_rtp_builder_format_sdp(tkHint->rtp_p, payloadName, sdpLine, config_bytes, config_size);\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t\tgf_free(config_bytes);\n\t}\n#if GPAC_ENABLE_3GPP_DIMS_RTP\n\t/*3GPP DIMS*/\n\telse if (tkHint->rtp_p->rtp_payt==GF_RTP_PAYT_3GPP_DIMS) {\n\t\tGF_DIMSDescription dims;\n\t\tgf_isom_get_visual_info(tkHint->file, tkHint->TrackNum, 1, &Width, &Height);\n\n\t\tgf_isom_get_dims_description(tkHint->file, tkHint->TrackNum, 1, &dims);\n\t\tsprintf(sdpLine, \"a=fmtp:%d Version-profile=%d\", tkHint->rtp_p->PayloadType, dims.profile);\n\t\tif (! dims.fullRequestHost) {\n\t\t\tchar fmt[200];\n\t\t\tstrcat(sdpLine, \";useFullRequestHost=0\");\n\t\t\tsprintf(fmt, \";pathComponents=%d\", dims.pathComponents);\n\t\t\tstrcat(sdpLine, fmt);\n\t\t}\n\t\tif (!dims.streamType) strcat(sdpLine, \";stream-type=secondary\");\n\t\tif (dims.containsRedundant == 1) strcat(sdpLine, \";contains-redundant=main\");\n\t\telse if (dims.containsRedundant == 2) strcat(sdpLine, \";contains-redundant=redundant\");\n\n\t\tif (dims.textEncoding && strlen(dims.textEncoding)) {\n\t\t\tstrcat(sdpLine, \";text-encoding=\");\n\t\t\tstrcat(sdpLine, dims.textEncoding);\n\t\t}\n\t\tif (dims.contentEncoding && strlen(dims.contentEncoding)) {\n\t\t\tstrcat(sdpLine, \";content-coding=\");\n\t\t\tstrcat(sdpLine, dims.contentEncoding);\n\t\t}\n\t\tif (dims.contentEncoding && dims.content_script_types && strlen(dims.content_script_types) ) {\n\t\t\tstrcat(sdpLine, \";content-script-types=\");\n\t\t\tstrcat(sdpLine, dims.contentEncoding);\n\t\t}\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n#endif\n\t/*extensions for some mobile phones*/\n\tif (Width && Height) {\n\t\tsprintf(sdpLine, \"a=framesize:%d %d-%d\", tkHint->rtp_p->PayloadType, Width, Height);\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n\n\tesd = gf_isom_get_esd(tkHint->file, tkHint->TrackNum, 1);\n\tif (esd && esd->decoderConfig && (esd->decoderConfig->rvc_config || esd->decoderConfig->predefined_rvc_config)) {\n\t\tif (esd->decoderConfig->predefined_rvc_config) {\n\t\t\tsprintf(sdpLine, \"a=rvc-config-predef:%d\", esd->decoderConfig->predefined_rvc_config);\n\t\t} else {\n\t\t\t/*temporary ...*/\n\t\t\tif ((esd->decoderConfig->objectTypeIndication==GF_CODECID_AVC) || (esd->decoderConfig->objectTypeIndication==GF_CODECID_SVC)) {\n\t\t\t\tsprintf(sdpLine, \"a=rvc-config:%s\", \"http://download.tsi.telecom-paristech.fr/gpac/RVC/rvc_config_avc.xml\");\n\t\t\t} else {\n\t\t\t\tsprintf(sdpLine, \"a=rvc-config:%s\", \"http://download.tsi.telecom-paristech.fr/gpac/RVC/rvc_config_sp.xml\");\n\t\t\t}\n\t\t}\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n\tif (esd) gf_odf_desc_del((GF_Descriptor *)esd);\n\n\tgf_isom_set_track_enabled(tkHint->file, tkHint->HintTrack, GF_TRUE);\n\treturn GF_OK;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 1683,
    "critical_vars": [
      "crc"
    ],
    "function": "naludmx_queue_param_set",
    "filename": "gpac/CVE-2021-40563/CVE-2021-40563_CWE-476_5ce0c906ed8599d218036b18b78e8126a496f137_reframe_nalu.c.diff",
    "function_code": "static void naludmx_queue_param_set(GF_NALUDmxCtx *ctx, char *data, u32 size, u32 ps_type, s32 ps_id)\n{\n\tGF_List *list = NULL, *alt_list = NULL;\n\tGF_NALUFFParam *sl;\n\tu32 i, count, crc;\n\n\tif (!size) return;\n\tcrc = gf_crc_32(data, size);\n\n\tif (ctx->codecid==GF_CODECID_HEVC) {\n\t\tswitch (ps_type) {\n\t\tcase GF_HEVC_NALU_VID_PARAM:\n\t\t\tif (!ctx->vps) ctx->vps = gf_list_new();\n\t\t\tlist = ctx->vps;\n\t\t\tbreak;\n\t\tcase GF_HEVC_NALU_SEQ_PARAM:\n\t\t\tlist = ctx->sps;\n\t\t\tbreak;\n\t\tcase GF_HEVC_NALU_PIC_PARAM:\n\t\t\tlist = ctx->pps;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(0);\n\t\t\treturn;\n\t\t}\n\t} else if (ctx->codecid==GF_CODECID_VVC) {\n\t\tswitch (ps_type) {\n\t\tcase GF_VVC_NALU_VID_PARAM:\n\t\t\tif (!ctx->vps) ctx->vps = gf_list_new();\n\t\t\tlist = ctx->vps;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_SEQ_PARAM:\n\t\t\tlist = ctx->sps;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_PIC_PARAM:\n\t\t\tlist = ctx->pps;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_DEC_PARAM:\n\t\t\tif (!ctx->vvc_dci) ctx->vvc_dci = gf_list_new();\n\t\t\tlist = ctx->vvc_dci;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_APS_PREFIX:\n\t\t\tif (!ctx->vvc_aps_pre) ctx->vvc_aps_pre = gf_list_new();\n\t\t\tlist = ctx->vvc_aps_pre;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(0);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tswitch (ps_type) {\n\t\tcase GF_AVC_NALU_SVC_SUBSEQ_PARAM:\n\t\tcase GF_AVC_NALU_SEQ_PARAM:\n\t\t\tlist = ctx->sps;\n\t\t\tbreak;\n\t\tcase GF_AVC_NALU_PIC_PARAM:\n\t\t\tlist = ctx->pps;\n\t\t\talt_list = ctx->pps_svc;\n\t\t\tbreak;\n\t\tcase GF_AVC_NALU_SEQ_PARAM_EXT:\n\t\t\tif (!ctx->sps_ext) ctx->sps_ext = gf_list_new();\n\t\t\tlist = ctx->sps_ext;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(0);\n\t\t\treturn;\n\t\t}\n\t}\n\tsl = NULL;\n\tcount = gf_list_count(list);\n\tfor (i=0; i<count; i++) {\n\t\tsl = gf_list_get(list, i);\n\t\tif (sl->id != ps_id) {\n\t\t\tsl = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\t//same ID, same CRC, we don't change our state\n\t\tif (sl->crc == crc) return;\n\t\tbreak;\n\t}\n\t//handle alt PPS list for SVC\n\tif (!sl && alt_list) {\n\t\tcount = gf_list_count(alt_list);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tsl = gf_list_get(alt_list, i);\n\t\t\tif (sl->id != ps_id) {\n\t\t\t\tsl = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//same ID, same CRC, we don't change our state\n\t\t\tif (sl->crc == crc) return;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (sl) {\n\t\t//otherwise we keep this new param set\n\t\tsl->data = gf_realloc(sl->data, size);\n\t\tmemcpy(sl->data, data, size);\n\t\tsl->size = size;\n\t\tsl->crc = crc;\n\t\tctx->ps_modified = GF_TRUE;\n\t\treturn;\n\t}\n\t//TODO we might want to purge the list after a while !!\n\n\tGF_SAFEALLOC(sl, GF_NALUFFParam);\n\tif (!sl) return;\n\tsl->data = gf_malloc(sizeof(char) * size);\n\tif (!sl->data) {\n\t\tgf_free(sl);\n\t\treturn;\n\t}\n\tmemcpy(sl->data, data, size);\n\tsl->size = size;\n\tsl->id = ps_id;\n\tsl->crc = crc;\n\n\tctx->ps_modified = GF_TRUE;\n\tgf_list_add(list, sl);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 1684,
    "critical_vars": [
      "crc"
    ],
    "function": "naludmx_queue_param_set",
    "filename": "gpac/CVE-2021-40563/CVE-2021-40563_CWE-476_5ce0c906ed8599d218036b18b78e8126a496f137_reframe_nalu.c.diff",
    "function_code": "static void naludmx_queue_param_set(GF_NALUDmxCtx *ctx, char *data, u32 size, u32 ps_type, s32 ps_id)\n{\n\tGF_List *list = NULL, *alt_list = NULL;\n\tGF_NALUFFParam *sl;\n\tu32 i, count;\n\tu32 crc = gf_crc_32(data, size);\n\n\tif (ctx->codecid==GF_CODECID_HEVC) {\n\t\tswitch (ps_type) {\n\t\tcase GF_HEVC_NALU_VID_PARAM:\n\t\t\tif (!ctx->vps) ctx->vps = gf_list_new();\n\t\t\tlist = ctx->vps;\n\t\t\tbreak;\n\t\tcase GF_HEVC_NALU_SEQ_PARAM:\n\t\t\tlist = ctx->sps;\n\t\t\tbreak;\n\t\tcase GF_HEVC_NALU_PIC_PARAM:\n\t\t\tlist = ctx->pps;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(0);\n\t\t\treturn;\n\t\t}\n\t} else if (ctx->codecid==GF_CODECID_VVC) {\n\t\tswitch (ps_type) {\n\t\tcase GF_VVC_NALU_VID_PARAM:\n\t\t\tif (!ctx->vps) ctx->vps = gf_list_new();\n\t\t\tlist = ctx->vps;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_SEQ_PARAM:\n\t\t\tlist = ctx->sps;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_PIC_PARAM:\n\t\t\tlist = ctx->pps;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_DEC_PARAM:\n\t\t\tif (!ctx->vvc_dci) ctx->vvc_dci = gf_list_new();\n\t\t\tlist = ctx->vvc_dci;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_APS_PREFIX:\n\t\t\tif (!ctx->vvc_aps_pre) ctx->vvc_aps_pre = gf_list_new();\n\t\t\tlist = ctx->vvc_aps_pre;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(0);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tswitch (ps_type) {\n\t\tcase GF_AVC_NALU_SVC_SUBSEQ_PARAM:\n\t\tcase GF_AVC_NALU_SEQ_PARAM:\n\t\t\tlist = ctx->sps;\n\t\t\tbreak;\n\t\tcase GF_AVC_NALU_PIC_PARAM:\n\t\t\tlist = ctx->pps;\n\t\t\talt_list = ctx->pps_svc;\n\t\t\tbreak;\n\t\tcase GF_AVC_NALU_SEQ_PARAM_EXT:\n\t\t\tif (!ctx->sps_ext) ctx->sps_ext = gf_list_new();\n\t\t\tlist = ctx->sps_ext;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(0);\n\t\t\treturn;\n\t\t}\n\t}\n\tsl = NULL;\n\tcount = gf_list_count(list);\n\tfor (i=0; i<count; i++) {\n\t\tsl = gf_list_get(list, i);\n\t\tif (sl->id != ps_id) {\n\t\t\tsl = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\t//same ID, same CRC, we don't change our state\n\t\tif (sl->crc == crc) return;\n\t\tbreak;\n\t}\n\t//handle alt PPS list for SVC\n\tif (!sl && alt_list) {\n\t\tcount = gf_list_count(alt_list);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tsl = gf_list_get(alt_list, i);\n\t\t\tif (sl->id != ps_id) {\n\t\t\t\tsl = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//same ID, same CRC, we don't change our state\n\t\t\tif (sl->crc == crc) return;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (sl) {\n\t\t//otherwise we keep this new param set\n\t\tsl->data = gf_realloc(sl->data, size);\n\t\tmemcpy(sl->data, data, size);\n\t\tsl->size = size;\n\t\tsl->crc = crc;\n\t\tctx->ps_modified = GF_TRUE;\n\t\treturn;\n\t}\n\t//TODO we might want to purge the list after a while !!\n\n\tGF_SAFEALLOC(sl, GF_NALUFFParam);\n\tif (!sl) return;\n\tsl->data = gf_malloc(sizeof(char) * size);\n\tif (!sl->data) {\n\t\tgf_free(sl);\n\t\treturn;\n\t}\n\tmemcpy(sl->data, data, size);\n\tsl->size = size;\n\tsl->id = ps_id;\n\tsl->crc = crc;\n\n\tctx->ps_modified = GF_TRUE;\n\tgf_list_add(list, sl);\n}",
    "label": "True"
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 1951,
    "line_new": 1951,
    "critical_vars": [
      "n",
      "AVI->fdes",
      "u32"
    ],
    "function": "avi_parse_input_file",
    "filename": "gpac/CVE-2023-4681/CVE-2023-4681_CWE-476_4bac19ad854159b21ba70d8ab7c4e1cd1db8ea1c_avilib.c.diff",
    "function_code": "int avi_parse_input_file(avi_t *AVI, int getIndex)\n{\n\tint rate, scale, idx_type;\n\ts64 n, i;\n\tunsigned char *hdrl_data;\n\tu64 header_offset=0;\n\tint hdrl_len=0;\n\tint nvi, nai[AVI_MAX_TRACKS], ioff;\n\tu64 tot[AVI_MAX_TRACKS];\n\tu32 j;\n\tint lasttag = 0;\n\tint vids_strh_seen = 0;\n\tint vids_strf_seen = 0;\n\tint auds_strh_seen = 0;\n\t//  int auds_strf_seen = 0;\n\tint num_stream = 0;\n\tchar data[256];\n\ts64 oldpos=-1, newpos=-1;\n\n\tint aud_chunks = 0;\n\tif (!AVI) {\n\t   AVI_errno = AVI_ERR_OPEN;\n\t   return 0;\n\t}\n\n\t/* Read first 12 bytes and check that this is an AVI file */\n\tif (avi_read(AVI->fdes,data,12) != 12 )\n\t\tERR_EXIT(AVI_ERR_READ)\n\n\tif (strnicmp(data  ,\"RIFF\",4) !=0 || strnicmp(data+8,\"AVI \",4) !=0 )\n\t\tERR_EXIT(AVI_ERR_NO_AVI)\n\n\t/* Go through the AVI file and extract the header list,\n\t   the start position of the 'movi' list and an optionally\n\t   present idx1 tag */\n\n\thdrl_data = 0;\n\n\twhile(1)\n\t{\n\t\tif( avi_read(AVI->fdes,data,8) != 8 ) break; /* We assume it's EOF */\n\t\tnewpos = gf_ftell(AVI->fdes);\n\t\tif(oldpos==newpos) {\n\t\t\t/* This is a broken AVI stream... */\n\t\t\treturn -1;\n\t\t}\n\t\toldpos=newpos;\n\n\t\tn = str2ulong((unsigned char *)data+4);\n\t\tn = PAD_EVEN(n);\n\n\t\tif(strnicmp(data,\"LIST\",4) == 0)\n\t\t{\n\t\t\tif( avi_read(AVI->fdes,data,4) != 4 ) ERR_EXIT(AVI_ERR_READ)\n\t\t\t\tn -= 4;\n\t\t\tif(strnicmp(data,\"hdrl\",4) == 0)\n\t\t\t{\n\t\t\t\tif (n>0xFFFFFFFF) ERR_EXIT(AVI_ERR_READ)\n\t\t\t\thdrl_len = (u32) n;\n\t\t\t\thdrl_data = (unsigned char *) gf_malloc((u32)n);\n\t\t\t\tif(hdrl_data==0) ERR_EXIT(AVI_ERR_NO_MEM);\n\n\t\t\t\t// offset of header\n\n\t\t\t\theader_offset = gf_ftell(AVI->fdes);\n\n\t\t\t\tif( avi_read(AVI->fdes,(char *)hdrl_data, (u32) n) != n ) {\n\t\t\t\t\tif (hdrl_data) gf_free(hdrl_data);\n\t\t\t\t\tERR_EXIT(AVI_ERR_READ)\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(strnicmp(data,\"movi\",4) == 0)\n\t\t\t{\n\t\t\t\tAVI->movi_start = gf_ftell(AVI->fdes);\n\t\t\t\tif (gf_fseek(AVI->fdes,n,SEEK_CUR)==(u64)-1) break;\n\t\t\t}\n\t\t\telse if (gf_fseek(AVI->fdes,n,SEEK_CUR)==(u64)-1) break;\n\t\t}\n\t\telse if(strnicmp(data,\"idx1\",4) == 0)\n\t\t{\n\t\t\t/* n must be a multiple of 16, but the reading does not\n\t\t\t   break if this is not the case */\n\n\t\t\tAVI->n_idx = AVI->max_idx = (u32) (n/16);\n\t\t\tAVI->idx = (unsigned  char((*)[16]) ) gf_malloc((u32)n);\n\t\t\tif(AVI->idx==0) {\n\t\t\t\tif (hdrl_data) gf_free(hdrl_data);\n\t\t\t\tERR_EXIT(AVI_ERR_NO_MEM)\n\t\t\t}\n\t\t\tif(avi_read(AVI->fdes, (char *) AVI->idx, (u32) n) != n ) {\n\t\t\t\tgf_free( AVI->idx);\n\t\t\t\tAVI->idx=NULL;\n\t\t\t\tAVI->n_idx = 0;\n\t\t\t\tif (hdrl_data) gf_free(hdrl_data);\n\t\t\t\tERR_EXIT(AVI_ERR_READ)\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tgf_fseek(AVI->fdes,n,SEEK_CUR);\n\t}\n\n\tif(!hdrl_data) ERR_EXIT(AVI_ERR_NO_HDRL)\n\tif(!AVI->movi_start) ERR_EXIT(AVI_ERR_NO_MOVI)\n\n\t\t\t/* Interpret the header list */\n\n\t\t\tfor(i=0; i<hdrl_len;)\n\t\t\t{\n\t\t\t\t/* List tags are completly ignored */\n\n#ifdef DEBUG_ODML\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] TAG %c%c%c%c\\n\", (hdrl_data+i)[0], (hdrl_data+i)[1], (hdrl_data+i)[2], (hdrl_data+i)[3]));\n#endif\n\n\t\t\t\tif(strnicmp((char *)hdrl_data+i,\"LIST\",4)==0) {\n\t\t\t\t\ti+= 12;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tn = str2ulong(hdrl_data+i+4);\n\t\t\t\tn = PAD_EVEN(n);\n\t\t\t\tif (i+n>hdrl_len) ERR_EXIT(AVI_ERR_READ)\n\n\n\t\t\t\t/* Interpret the tag and its args */\n\n\t\t\t\tif(strnicmp((char *)hdrl_data+i,\"strh\",4)==0)\n\t\t\t\t{\n\t\t\t\t\ti += 8;\n#ifdef DEBUG_ODML\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] TAG   %c%c%c%c\\n\", (hdrl_data+i)[0], (hdrl_data+i)[1], (hdrl_data+i)[2], (hdrl_data+i)[3]));\n#endif\n\t\t\t\t\tif(strnicmp((char *)hdrl_data+i,\"vids\",4) == 0 && !vids_strh_seen)\n\t\t\t\t\t{\n\t\t\t\t\t\tmemcpy(AVI->compressor,hdrl_data+i+4,4);\n\t\t\t\t\t\tAVI->compressor[4] = 0;\n\n\t\t\t\t\t\t// ThOe\n\t\t\t\t\t\tAVI->v_codech_off = header_offset + i+4;\n\n\t\t\t\t\t\tscale = str2ulong(hdrl_data+i+20);\n\t\t\t\t\t\trate  = str2ulong(hdrl_data+i+24);\n\t\t\t\t\t\tif(scale!=0) AVI->fps = (double)rate/(double)scale;\n\t\t\t\t\t\tAVI->video_frames = str2ulong(hdrl_data+i+32);\n\t\t\t\t\t\tAVI->video_strn = num_stream;\n\t\t\t\t\t\tAVI->max_len = 0;\n\t\t\t\t\t\tvids_strh_seen = 1;\n\t\t\t\t\t\tlasttag = 1; /* vids */\n\t\t\t\t\t\tmemcpy(&AVI->video_stream_header, hdrl_data + i,\n\t\t\t\t\t\t       sizeof(alAVISTREAMHEADER));\n\t\t\t\t\t}\n\t\t\t\t\telse if (strnicmp ((char *)hdrl_data+i,\"auds\",4) ==0 && ! auds_strh_seen)\n\t\t\t\t\t{\n\n\t\t\t\t\t\t//inc audio tracks\n\t\t\t\t\t\tAVI->aptr=AVI->anum;\n\t\t\t\t\t\t++AVI->anum;\n\n\t\t\t\t\t\tif(AVI->anum > AVI_MAX_TRACKS) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] error - only %d audio tracks supported\\n\", AVI_MAX_TRACKS));\n\t\t\t\t\t\t\treturn(-1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_bytes = str2ulong(hdrl_data+i+32)*avi_sampsize(AVI, 0);\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_strn = num_stream;\n\n\t\t\t\t\t\t// if samplesize==0 -> vbr\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_vbr = !str2ulong(hdrl_data+i+44);\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].padrate = str2ulong(hdrl_data+i+24);\n\t\t\t\t\t\tmemcpy(&AVI->stream_headers[AVI->aptr], hdrl_data + i,\n\t\t\t\t\t\t       sizeof(alAVISTREAMHEADER));\n\n\t\t\t\t\t\t//\t   auds_strh_seen = 1;\n\t\t\t\t\t\tlasttag = 2; /* auds */\n\n\t\t\t\t\t\t// ThOe\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_codech_off = header_offset + i;\n\n\t\t\t\t\t}\n\t\t\t\t\telse if (strnicmp ((char*)hdrl_data+i,\"iavs\",4) ==0 && ! auds_strh_seen) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] AVILIB: error - DV AVI Type 1 no supported\\n\"));\n\t\t\t\t\t\treturn (-1);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tlasttag = 0;\n\t\t\t\t\tnum_stream++;\n\t\t\t\t}\n\t\t\t\telse if(strnicmp((char*)hdrl_data+i,\"dmlh\",4) == 0) {\n\t\t\t\t\tAVI->total_frames = str2ulong(hdrl_data+i+8);\n#ifdef DEBUG_ODML\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] real number of frames %d\\n\", AVI->total_frames));\n#endif\n\t\t\t\t\ti += 8;\n\t\t\t\t}\n\t\t\t\telse if(strnicmp((char *)hdrl_data+i,\"strf\",4)==0)\n\t\t\t\t{\n\t\t\t\t\ti += 8;\n\t\t\t\t\tif(lasttag == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\talBITMAPINFOHEADER bih;\n\n\t\t\t\t\t\tmemcpy(&bih, hdrl_data + i, sizeof(alBITMAPINFOHEADER));\n\t\t\t\t\t\tbih.bi_size = str2ulong((unsigned char *)&bih.bi_size);\n\n\t\t\t\t\t\tif (i + bih.bi_size > hdrl_len) ERR_EXIT(AVI_ERR_READ)\n\n\t\t\t\t\t\tAVI->bitmap_info_header = (alBITMAPINFOHEADER *) gf_malloc(bih.bi_size);\n\t\t\t\t\t\tif (AVI->bitmap_info_header != NULL)\n\t\t\t\t\t\t\tmemcpy(AVI->bitmap_info_header, hdrl_data + i, bih.bi_size);\n\n\t\t\t\t\t\tAVI->width  = str2ulong(hdrl_data+i+4);\n\t\t\t\t\t\tAVI->height = str2ulong(hdrl_data+i+8);\n\t\t\t\t\t\tvids_strf_seen = 1;\n\t\t\t\t\t\t//ThOe\n\t\t\t\t\t\tAVI->v_codecf_off = header_offset + i+16;\n\n\t\t\t\t\t\tmemcpy(AVI->compressor2, hdrl_data+i+16, 4);\n\t\t\t\t\t\tAVI->compressor2[4] = 0;\n\n\t\t\t\t\t\tif (n>40) {\n\t\t\t\t\t\t\tif (n>0xFFFFFFFF) ERR_EXIT(AVI_ERR_READ)\n\t\t\t\t\t\t\tAVI->extradata_size = (u32) (n - 40);\n\t\t\t\t\t\t\tAVI->extradata = gf_malloc(sizeof(u8)* AVI->extradata_size);\n\t\t\t\t\t\t\tif (!AVI->extradata) ERR_EXIT(AVI_ERR_NO_MEM)\n\t\t\t\t\t\t\tmemcpy(AVI->extradata, hdrl_data + i + 40, AVI->extradata_size);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\telse if(lasttag == 2)\n\t\t\t\t\t{\n\t\t\t\t\t\talWAVEFORMATEX *wfe;\n\t\t\t\t\t\tchar *nwfe;\n\t\t\t\t\t\tint wfes;\n\n\t\t\t\t\t\tif ((u32) (hdrl_len - i) < sizeof(alWAVEFORMATEX))\n\t\t\t\t\t\t\twfes = (int) (hdrl_len - i);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\twfes = sizeof(alWAVEFORMATEX);\n\t\t\t\t\t\twfe = (alWAVEFORMATEX *)gf_malloc(sizeof(alWAVEFORMATEX));\n\t\t\t\t\t\tif (wfe != NULL) {\n\t\t\t\t\t\t\tmemset(wfe, 0, sizeof(alWAVEFORMATEX));\n\t\t\t\t\t\t\tmemcpy(wfe, hdrl_data + i, wfes);\n\t\t\t\t\t\t\tif (str2ushort((unsigned char *)&wfe->cb_size) != 0) {\n\t\t\t\t\t\t\t\tnwfe = (char *)\n\t\t\t\t\t\t\t\t       gf_realloc(wfe, sizeof(alWAVEFORMATEX) +\n\t\t\t\t\t\t\t\t                  str2ushort((unsigned char *)&wfe->cb_size));\n\t\t\t\t\t\t\t\tif (nwfe != 0) {\n\t\t\t\t\t\t\t\t\ts64 lpos = gf_ftell(AVI->fdes);\n\t\t\t\t\t\t\t\t\tgf_fseek(AVI->fdes, header_offset + i + sizeof(alWAVEFORMATEX),\n\t\t\t\t\t\t\t\t\t         SEEK_SET);\n\t\t\t\t\t\t\t\t\twfe = (alWAVEFORMATEX *)nwfe;\n\t\t\t\t\t\t\t\t\tnwfe = &nwfe[sizeof(alWAVEFORMATEX)];\n\t\t\t\t\t\t\t\t\tavi_read(AVI->fdes, nwfe,\n\t\t\t\t\t\t\t\t\t         str2ushort((unsigned char *)&wfe->cb_size));\n\t\t\t\t\t\t\t\t\tgf_fseek(AVI->fdes, lpos, SEEK_SET);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tAVI->wave_format_ex[AVI->aptr] = wfe;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_fmt   = str2ushort(hdrl_data+i  );\n\n\t\t\t\t\t\t//ThOe\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_codecf_off = header_offset + i;\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_chans = str2ushort(hdrl_data+i+2);\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_rate  = str2ulong (hdrl_data+i+4);\n\t\t\t\t\t\t//ThOe: read mp3bitrate\n\t\t\t\t\t\tAVI->track[AVI->aptr].mp3rate = 8*str2ulong(hdrl_data+i+8)/1000;\n\t\t\t\t\t\t//:ThOe\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_bits  = str2ushort(hdrl_data+i+14);\n\t\t\t\t\t\t//            auds_strf_seen = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(strnicmp((char*)hdrl_data+i,\"indx\",4) == 0) {\n\t\t\t\t\tchar *a;\n\n\t\t\t\t\tif(lasttag == 1) // V I D E O\n\t\t\t\t\t{\n\n\t\t\t\t\t\ta = (char*)hdrl_data+i;\n\t\t\t\t\t\tint avail = hdrl_len-i;\n\t\t\t\t\t\tif (avail<32) ERR_EXIT(AVI_ERR_READ)\n\n\t\t\t\t\t\tAVI->video_superindex = (avisuperindex_chunk *) gf_malloc (sizeof (avisuperindex_chunk));\n\t\t\t\t\t\tmemset(AVI->video_superindex, 0, sizeof (avisuperindex_chunk));\n\t\t\t\t\t\tmemcpy (AVI->video_superindex->fcc, a, 4);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->video_superindex->dwSize = str2ulong((unsigned char *)a);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->video_superindex->wLongsPerEntry = str2ushort((unsigned char *)a);\n\t\t\t\t\t\ta += 2;\n\t\t\t\t\t\tAVI->video_superindex->bIndexSubType = *a;\n\t\t\t\t\t\ta += 1;\n\t\t\t\t\t\tAVI->video_superindex->bIndexType = *a;\n\t\t\t\t\t\ta += 1;\n\t\t\t\t\t\tAVI->video_superindex->nEntriesInUse = str2ulong((unsigned char *)a);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tmemcpy (AVI->video_superindex->dwChunkId, a, 4);\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\t// 3 * reserved\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\tif (AVI->video_superindex->bIndexSubType != 0) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] Invalid Header, bIndexSubType != 0\\n\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tavail -= 32;\n\t\t\t\t\t\tif (avail < AVI->video_superindex->nEntriesInUse*16) ERR_EXIT(AVI_ERR_READ)\n\n\t\t\t\t\t\tAVI->video_superindex->aIndex = (avisuperindex_entry*)\n\t\t\t\t\t\t                                gf_malloc (AVI->video_superindex->wLongsPerEntry * AVI->video_superindex->nEntriesInUse * sizeof (u32));\n\n\t\t\t\t\t\t// position of ix## chunks\n\t\t\t\t\t\tfor (j=0; j<AVI->video_superindex->nEntriesInUse; ++j) {\n\t\t\t\t\t\t\tAVI->video_superindex->aIndex[j].qwOffset = str2ullong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 8;\n\t\t\t\t\t\t\tAVI->video_superindex->aIndex[j].dwSize = str2ulong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\t\tAVI->video_superindex->aIndex[j].dwDuration = str2ulong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 4;\n\n#ifdef DEBUG_ODML\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d] 0x%llx 0x%lx %lu\\n\", j,\n\t\t\t\t\t\t\t                                        (unsigned int long)AVI->video_superindex->aIndex[j].qwOffset,\n\t\t\t\t\t\t\t                                        (unsigned long)AVI->video_superindex->aIndex[j].dwSize,\n\t\t\t\t\t\t\t                                        (unsigned long)AVI->video_superindex->aIndex[j].dwDuration));\n#endif\n\t\t\t\t\t\t}\n\n\n#ifdef DEBUG_ODML\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] FOURCC \\\"%c%c%c%c\\\"\\n\", AVI->video_superindex->fcc[0], AVI->video_superindex->fcc[1],\n\t\t\t\t\t\t                                        AVI->video_superindex->fcc[2], AVI->video_superindex->fcc[3]));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] LEN \\\"%ld\\\"\\n\", (long)AVI->video_superindex->dwSize));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] wLongsPerEntry \\\"%d\\\"\\n\", AVI->video_superindex->wLongsPerEntry));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] bIndexSubType \\\"%d\\\"\\n\", AVI->video_superindex->bIndexSubType));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] bIndexType \\\"%d\\\"\\n\", AVI->video_superindex->bIndexType));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] nEntriesInUse \\\"%ld\\\"\\n\", (long)AVI->video_superindex->nEntriesInUse));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] dwChunkId \\\"%c%c%c%c\\\"\\n\", AVI->video_superindex->dwChunkId[0], AVI->video_superindex->dwChunkId[1],\n\t\t\t\t\t\t                                        AVI->video_superindex->dwChunkId[2], AVI->video_superindex->dwChunkId[3]));\n#endif\n\n\t\t\t\t\t\tAVI->is_opendml = 1;\n\n\t\t\t\t\t}\n\t\t\t\t\telse if(lasttag == 2) // A U D I O\n\t\t\t\t\t{\n\n\t\t\t\t\t\ta = (char*) hdrl_data+i;\n\t\t\t\t\t\tint avail = hdrl_len-i;\n\t\t\t\t\t\tif (avail<32) ERR_EXIT(AVI_ERR_READ)\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex = (avisuperindex_chunk *) gf_malloc (sizeof (avisuperindex_chunk));\n\t\t\t\t\t\tmemcpy (AVI->track[AVI->aptr].audio_superindex->fcc, a, 4);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->dwSize = str2ulong((unsigned char*)a);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->wLongsPerEntry = str2ushort((unsigned char*)a);\n\t\t\t\t\t\ta += 2;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->bIndexSubType = *a;\n\t\t\t\t\t\ta += 1;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->bIndexType = *a;\n\t\t\t\t\t\ta += 1;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->nEntriesInUse = str2ulong((unsigned char*)a);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tmemcpy (AVI->track[AVI->aptr].audio_superindex->dwChunkId, a, 4);\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\t// 3 * reserved\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\tif (AVI->track[AVI->aptr].audio_superindex->bIndexSubType != 0) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] Invalid Header, bIndexSubType != 0\\n\"));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tavail -= 32;\n\t\t\t\t\t\tif (avail < AVI->track[AVI->aptr].audio_superindex->nEntriesInUse*16) ERR_EXIT(AVI_ERR_READ)\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->aIndex = (avisuperindex_entry*)\n\t\t\t\t\t\t        gf_malloc (AVI->track[AVI->aptr].audio_superindex->wLongsPerEntry *\n\t\t\t\t\t\t                   AVI->track[AVI->aptr].audio_superindex->nEntriesInUse * sizeof (u32));\n\n\t\t\t\t\t\t// position of ix## chunks\n\t\t\t\t\t\tfor (j=0; j<AVI->track[AVI->aptr].audio_superindex->nEntriesInUse; ++j) {\n\t\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->aIndex[j].qwOffset = str2ullong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 8;\n\t\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->aIndex[j].dwSize = str2ulong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->aIndex[j].dwDuration = str2ulong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 4;\n\n#ifdef DEBUG_ODML\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d] 0x%llx 0x%lx %lu\\n\", j,\n\t\t\t\t\t\t\t                                        (unsigned int long)AVI->track[AVI->aptr].audio_superindex->aIndex[j].qwOffset,\n\t\t\t\t\t\t\t                                        (unsigned long)AVI->track[AVI->aptr].audio_superindex->aIndex[j].dwSize,\n\t\t\t\t\t\t\t                                        (unsigned long)AVI->track[AVI->aptr].audio_superindex->aIndex[j].dwDuration));\n#endif\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->stdindex = NULL;\n\n#ifdef DEBUG_ODML\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] FOURCC \\\"%.4s\\\"\\n\", AVI->track[AVI->aptr].audio_superindex->fcc));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] LEN \\\"%ld\\\"\\n\", (long)AVI->track[AVI->aptr].audio_superindex->dwSize));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] wLongsPerEntry \\\"%d\\\"\\n\", AVI->track[AVI->aptr].audio_superindex->wLongsPerEntry));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] bIndexSubType \\\"%d\\\"\\n\", AVI->track[AVI->aptr].audio_superindex->bIndexSubType));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] bIndexType \\\"%d\\\"\\n\", AVI->track[AVI->aptr].audio_superindex->bIndexType));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] nEntriesInUse \\\"%ld\\\"\\n\", (long)AVI->track[AVI->aptr].audio_superindex->nEntriesInUse));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] dwChunkId \\\"%.4s\\\"\\n\", AVI->track[AVI->aptr].audio_superindex->dwChunkId[0]));\n#endif\n\n\t\t\t\t\t}\n\t\t\t\t\ti += 8;\n\t\t\t\t}\n\t\t\t\telse if((strnicmp((char*)hdrl_data+i,\"JUNK\",4) == 0) ||\n\t\t\t\t        (strnicmp((char*)hdrl_data+i,\"strn\",4) == 0) ||\n\t\t\t\t        (strnicmp((char*)hdrl_data+i,\"vprp\",4) == 0)) {\n\t\t\t\t\ti += 8;\n\t\t\t\t\t// do not reset lasttag\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\ti += 8;\n\t\t\t\t\tlasttag = 0;\n\t\t\t\t}\n\t\t\t\t//GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] adding %ld bytes\\n\", (int int)n));\n\n\t\t\t\ti += (u32) n;\n\t\t\t}\n\n\tgf_free(hdrl_data);\n\n\tif(!vids_strh_seen || !vids_strf_seen) ERR_EXIT(AVI_ERR_NO_VIDS)\n\n\t\tAVI->video_tag[0] = AVI->video_strn/10 + '0';\n\tAVI->video_tag[1] = AVI->video_strn%10 + '0';\n\tAVI->video_tag[2] = 'd';\n\tAVI->video_tag[3] = 'b';\n\n\t/* Audio tag is set to \"99wb\" if no audio present */\n\tif(!AVI->track[0].a_chans) AVI->track[0].audio_strn = 99;\n\n\t{\n\t\tint tk=0;\n\t\tfor(j=0; j<AVI->anum+1; ++j) {\n\t\t\tif (j == AVI->video_strn) continue;\n\t\t\tAVI->track[tk].audio_tag[0] = j/10 + '0';\n\t\t\tAVI->track[tk].audio_tag[1] = j%10 + '0';\n\t\t\tAVI->track[tk].audio_tag[2] = 'w';\n\t\t\tAVI->track[tk].audio_tag[3] = 'b';\n\t\t\t++tk;\n\t\t}\n\t}\n\n\tgf_fseek(AVI->fdes,AVI->movi_start,SEEK_SET);\n\n\tif(!getIndex) return(0);\n\n\t/* if the file has an idx1, check if this is relative\n\t   to the start of the file or to the start of the movi list */\n\n\tidx_type = 0;\n\n\tif(AVI->idx)\n\t{\n\t\ts64 pos, len;\n\n\t\t/* Search the first videoframe in the idx1 and look where\n\t\t   it is in the file */\n\n\t\tfor(i=0; i<AVI->n_idx; i++)\n\t\t\tif( strnicmp((char *)AVI->idx[i],(char *)AVI->video_tag,3)==0 ) break;\n\t\tif(i>=AVI->n_idx) ERR_EXIT(AVI_ERR_NO_VIDS)\n\n\t\t\tpos = str2ulong(AVI->idx[i]+ 8);\n\t\tlen = str2ulong(AVI->idx[i]+12);\n\n\t\tgf_fseek(AVI->fdes,pos,SEEK_SET);\n\t\tif(avi_read(AVI->fdes,data,8)!=8) ERR_EXIT(AVI_ERR_READ)\n\t\t\tif( strnicmp(data,(char *)AVI->idx[i],4)==0 && str2ulong((unsigned char *)data+4)==len )\n\t\t\t{\n\t\t\t\tidx_type = 1; /* Index from start of file */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tgf_fseek(AVI->fdes,pos+AVI->movi_start-4,SEEK_SET);\n\t\t\t\tif(avi_read(AVI->fdes,data,8)!=8) ERR_EXIT(AVI_ERR_READ)\n\t\t\t\t\tif( strnicmp(data,(char *)AVI->idx[i],4)==0 && str2ulong((unsigned char *)data+4)==len )\n\t\t\t\t\t{\n\t\t\t\t\t\tidx_type = 2; /* Index from start of movi list */\n\t\t\t\t\t}\n\t\t\t}\n\t\t/* idx_type remains 0 if neither of the two tests above succeeds */\n\t}\n\n\n\tif(idx_type == 0 && !AVI->is_opendml && !AVI->total_frames)\n\t{\n\t\t/* we must search through the file to get the index */\n\n\t\tgf_fseek(AVI->fdes, AVI->movi_start, SEEK_SET);\n\n\t\tAVI->n_idx = 0;\n\n\t\twhile(1)\n\t\t{\n\t\t\tif( avi_read(AVI->fdes,data,8) != 8 ) break;\n\t\t\tn = str2ulong((unsigned char *)data+4);\n\n\t\t\t/* The movi list may contain sub-lists, ignore them */\n\n\t\t\tif(strnicmp(data,\"LIST\",4)==0)\n\t\t\t{\n\t\t\t\tgf_fseek(AVI->fdes,4,SEEK_CUR);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Check if we got a tag ##db, ##dc or ##wb */\n\n\t\t\tif( ( (data[2]=='d' || data[2]=='D') &&\n\t\t\t        (data[3]=='b' || data[3]=='B' || data[3]=='c' || data[3]=='C') )\n\t\t\t        || ( (data[2]=='w' || data[2]=='W') &&\n\t\t\t             (data[3]=='b' || data[3]=='B') ) )\n\t\t\t{\n\t\t\t\tu64 __pos = gf_ftell(AVI->fdes) - 8;\n\t\t\t\tavi_add_index_entry(AVI,(unsigned char *)data,0,__pos,n);\n\t\t\t}\n\n\t\t\tgf_fseek(AVI->fdes,PAD_EVEN(n),SEEK_CUR);\n\t\t}\n\t\tidx_type = 1;\n\t}\n\n\t// ************************\n\t// OPENDML\n\t// ************************\n\n\t// read extended index chunks\n\tif (AVI->is_opendml) {\n\t\tu64 offset = 0;\n\t\thdrl_len = 4+4+2+1+1+4+4+8+4;\n\t\tchar *en, *chunk_start;\n\t\tint k = 0;\n\t\tu32 audtr = 0;\n\t\tu32 nrEntries = 0;\n\n\t\tAVI->video_index = NULL;\n\n\t\tnvi = 0;\n\t\tfor(audtr=0; audtr<AVI->anum; ++audtr) {\n\t\t\tnai[audtr] = 0;\n\t\t\ttot[audtr] = 0;\n\t\t}\n\n\t\t// ************************\n\t\t// VIDEO\n\t\t// ************************\n\n\t\tfor (j=0; j<AVI->video_superindex->nEntriesInUse; j++) {\n\n\t\t\t// read from file\n\t\t\tchunk_start = en = (char*) gf_malloc ((u32) (AVI->video_superindex->aIndex[j].dwSize+hdrl_len) );\n\n\t\t\tif (gf_fseek(AVI->fdes, AVI->video_superindex->aIndex[j].qwOffset, SEEK_SET) == (u64)-1) {\n\t\t\t\tgf_free(chunk_start);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (avi_read(AVI->fdes, en, (u32) (AVI->video_superindex->aIndex[j].dwSize+hdrl_len) ) <= 0) {\n\t\t\t\tgf_free(chunk_start);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnrEntries = str2ulong((unsigned char*)en + 12);\n#ifdef DEBUG_ODML\n\t\t\t//GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d:0] Video nrEntries %ld\\n\", j, nrEntries));\n#endif\n\t\t\toffset = str2ullong((unsigned char*)en + 20);\n\n\t\t\t// skip header\n\t\t\ten += hdrl_len;\n\t\t\tnvi += nrEntries;\n\t\t\tAVI->video_index = (video_index_entry *) gf_realloc (AVI->video_index, nvi * sizeof (video_index_entry));\n\t\t\tif (!AVI->video_index) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] out of mem (size = %ld)\\n\", nvi * sizeof (video_index_entry)));\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\twhile (k < nvi) {\n\n\t\t\t\tAVI->video_index[k].pos = offset + str2ulong((unsigned char*)en);\n\t\t\t\ten += 4;\n\t\t\t\tAVI->video_index[k].len = str2ulong_len((unsigned char*)en);\n\t\t\t\tAVI->video_index[k].key = str2ulong_key((unsigned char*)en);\n\t\t\t\ten += 4;\n\n\t\t\t\t// completely empty chunk\n\t\t\t\tif (AVI->video_index[k].pos-offset == 0 && AVI->video_index[k].len == 0) {\n\t\t\t\t\tk--;\n\t\t\t\t\tnvi--;\n\t\t\t\t}\n\n#ifdef DEBUG_ODML\n\t\t\t\t/*\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d] POS 0x%llX len=%d key=%s offset (%llx) (%ld)\\n\", k,\n\t\t\t\t  AVI->video_index[k].pos,\n\t\t\t\t  (int)AVI->video_index[k].len,\n\t\t\t\t  AVI->video_index[k].key?\"yes\":\"no \", offset,\n\t\t\t\t  AVI->video_superindex->aIndex[j].dwSize));\n\t\t\t\t  */\n#endif\n\n\t\t\t\tk++;\n\t\t\t}\n\n\t\t\tgf_free(chunk_start);\n\t\t}\n\n\t\tAVI->video_frames = nvi;\n\t\t// this should deal with broken 'rec ' odml files.\n\t\tif (AVI->video_frames == 0) {\n\t\t\tAVI->is_opendml=0;\n\t\t\tgoto multiple_riff;\n\t\t}\n\n\t\t// ************************\n\t\t// AUDIO\n\t\t// ************************\n\n\t\tfor(audtr=0; audtr<AVI->anum; ++audtr) {\n\n\t\t\tk = 0;\n\t\t\tif (!AVI->track[audtr].audio_superindex) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] (%s) cannot read audio index for track %d\\n\", __FILE__, audtr));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (j=0; j<AVI->track[audtr].audio_superindex->nEntriesInUse; j++) {\n\n\t\t\t\t// read from file\n\t\t\t\tchunk_start = en = (char*)gf_malloc ((u32) (AVI->track[audtr].audio_superindex->aIndex[j].dwSize+hdrl_len));\n\n\t\t\t\tif (gf_fseek(AVI->fdes, AVI->track[audtr].audio_superindex->aIndex[j].qwOffset, SEEK_SET) == (u64)-1) {\n\t\t\t\t\tgf_free(chunk_start);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (avi_read(AVI->fdes, en, (u32) (AVI->track[audtr].audio_superindex->aIndex[j].dwSize+hdrl_len)) <= 0) {\n\t\t\t\t\tgf_free(chunk_start);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tnrEntries = str2ulong((unsigned char*)en + 12);\n\t\t\t\t//if (nrEntries > 50) nrEntries = 2; // XXX\n#ifdef DEBUG_ODML\n\t\t\t\t//GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d:%d] Audio nrEntries %ld\\n\", j, audtr, nrEntries));\n#endif\n\t\t\t\toffset = str2ullong((unsigned char*)en + 20);\n\n\t\t\t\t// skip header\n\t\t\t\ten += hdrl_len;\n\t\t\t\tnai[audtr] += nrEntries;\n\t\t\t\tAVI->track[audtr].audio_index = (audio_index_entry *) gf_realloc (AVI->track[audtr].audio_index, nai[audtr] * sizeof (audio_index_entry));\n\n\t\t\t\twhile (k < nai[audtr]) {\n\n\t\t\t\t\tAVI->track[audtr].audio_index[k].pos = offset + str2ulong((unsigned char*)en);\n\t\t\t\t\ten += 4;\n\t\t\t\t\tAVI->track[audtr].audio_index[k].len = str2ulong_len((unsigned char*)en);\n\t\t\t\t\ten += 4;\n\t\t\t\t\tAVI->track[audtr].audio_index[k].tot = tot[audtr];\n\t\t\t\t\ttot[audtr] += AVI->track[audtr].audio_index[k].len;\n\n#ifdef DEBUG_ODML\n\t\t\t\t\t/*\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d:%d] POS 0x%llX len=%d offset (%llx) (%ld)\\n\", k, audtr,\n\t\t\t\t\t  AVI->track[audtr].audio_index[k].pos,\n\t\t\t\t\t  (int)AVI->track[audtr].audio_index[k].len,\n\t\t\t\t\t  offset, AVI->track[audtr].audio_superindex->aIndex[j].dwSize));\n\t\t\t\t\t  */\n#endif\n\n\t\t\t\t\t++k;\n\t\t\t\t}\n\n\t\t\t\tgf_free(chunk_start);\n\t\t\t}\n\n\t\t\tAVI->track[audtr].audio_chunks = nai[audtr];\n\t\t\tAVI->track[audtr].audio_bytes = tot[audtr];\n\t\t}\n\t} // is opendml\n\n\telse if (AVI->total_frames && !AVI->is_opendml && idx_type==0) {\n\n\t\t// *********************\n\t\t// MULTIPLE RIFF CHUNKS (and no index)\n\t\t// *********************\n\nmultiple_riff:\n\n\t\tgf_fseek(AVI->fdes, AVI->movi_start, SEEK_SET);\n\n\t\tAVI->n_idx = 0;\n\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] Reconstructing index...\"));\n\n\t\t// Number of frames; only one audio track supported\n\t\tnvi = AVI->video_frames = AVI->total_frames;\n\t\tnai[0] = AVI->track[0].audio_chunks = AVI->total_frames;\n\t\tfor(j=1; j<AVI->anum; ++j) AVI->track[j].audio_chunks = 0;\n\n\t\tAVI->video_index = (video_index_entry *) gf_malloc(nvi*sizeof(video_index_entry));\n\n\t\tif(AVI->video_index==0) ERR_EXIT(AVI_ERR_NO_MEM);\n\n\t\tfor(j=0; j<AVI->anum; ++j) {\n\t\t\tif(AVI->track[j].audio_chunks) {\n\t\t\t\tAVI->track[j].audio_index = (audio_index_entry *) gf_malloc((nai[j]+1)*sizeof(audio_index_entry));\n\t\t\t\tmemset(AVI->track[j].audio_index, 0, (nai[j]+1)*(sizeof(audio_index_entry)));\n\t\t\t\tif(AVI->track[j].audio_index==0) ERR_EXIT(AVI_ERR_NO_MEM);\n\t\t\t}\n\t\t}\n\n\t\tnvi = 0;\n\t\tfor(j=0; j<AVI->anum; ++j) {\n\t\t\tnai[j] = 0;\n\t\t\ttot[j] = 0;\n\t\t}\n\n\t\taud_chunks = AVI->total_frames;\n\n\t\twhile(1)\n\t\t{\n\t\t\tif (nvi >= AVI->total_frames) break;\n\n\t\t\tif( avi_read(AVI->fdes,data,8) != 8 ) break;\n\t\t\tn = str2ulong((unsigned char *)data+4);\n\n\n\t\t\tj=0;\n\n\t\t\tif (aud_chunks - nai[j] -1 <= 0) {\n\t\t\t\taud_chunks += AVI->total_frames;\n\t\t\t\tAVI->track[j].audio_index = (audio_index_entry *)\n\t\t\t\t                            gf_realloc( AVI->track[j].audio_index, (aud_chunks+1)*sizeof(audio_index_entry));\n\t\t\t\tif (!AVI->track[j].audio_index) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] Internal error in avilib -- no mem\\n\"));\n\t\t\t\t\tAVI_errno = AVI_ERR_NO_MEM;\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Check if we got a tag ##db, ##dc or ##wb */\n\n\t\t\t// VIDEO\n\t\t\tif(\n\t\t\t    (data[0]=='0' || data[1]=='0') &&\n\t\t\t    (data[2]=='d' || data[2]=='D') &&\n\t\t\t    (data[3]=='b' || data[3]=='B' || data[3]=='c' || data[3]=='C') ) {\n\n\t\t\t\tAVI->video_index[nvi].key = 0x0;\n\t\t\t\tAVI->video_index[nvi].pos = gf_ftell(AVI->fdes);\n\t\t\t\tAVI->video_index[nvi].len = (u32) n;\n\n\t\t\t\t/*\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] Frame %ld pos %\"LLD\" len %\"LLD\" key %ld\\n\",\n\t\t\t\t    nvi, AVI->video_index[nvi].pos,  AVI->video_index[nvi].len, (long)AVI->video_index[nvi].key));\n\t\t\t\t    */\n\t\t\t\tnvi++;\n\t\t\t\tgf_fseek(AVI->fdes,PAD_EVEN(n),SEEK_CUR);\n\t\t\t}\n\n\t\t\t//AUDIO\n\t\t\telse if(\n\t\t\t    (data[0]=='0' || data[1]=='1') &&\n\t\t\t    (data[2]=='w' || data[2]=='W') &&\n\t\t\t    (data[3]=='b' || data[3]=='B') ) {\n\n\n\t\t\t\tAVI->track[j].audio_index[nai[j]].pos = gf_ftell(AVI->fdes);\n\t\t\t\tAVI->track[j].audio_index[nai[j]].len = (u32) n;\n\t\t\t\tAVI->track[j].audio_index[nai[j]].tot = tot[j];\n\t\t\t\ttot[j] += AVI->track[j].audio_index[nai[j]].len;\n\t\t\t\tnai[j]++;\n\n\t\t\t\tgf_fseek(AVI->fdes,PAD_EVEN(n),SEEK_CUR);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgf_fseek(AVI->fdes,-4,SEEK_CUR);\n\t\t\t}\n\n\t\t}\n\t\tif (nvi < AVI->total_frames) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[avilib] Uh? Some frames seems missing (%ld/%d)\\n\",\n\t\t\t        nvi,  AVI->total_frames));\n\t\t}\n\n\n\t\tAVI->video_frames = nvi;\n\t\tAVI->track[0].audio_chunks = nai[0];\n\n\t\tfor(j=0; j<AVI->anum; ++j) AVI->track[j].audio_bytes = tot[j];\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] done. nvi=%ld nai=%ld tot=%ld\\n\", nvi, nai[0], tot[0]));\n\n\t} // total_frames but no indx chunk (xawtv does this)\n\n\telse\n\n\t{\n\t\t// ******************\n\t\t// NO OPENDML\n\t\t// ******************\n\n\t\t/* Now generate the video index and audio index arrays */\n\n\t\tnvi = 0;\n\t\tfor(j=0; j<AVI->anum; ++j) nai[j] = 0;\n\n\t\tfor(i=0; i<AVI->n_idx; i++) {\n\n\t\t\tif(strnicmp((char *)AVI->idx[i],AVI->video_tag,3) == 0) nvi++;\n\n\t\t\tfor(j=0; j<AVI->anum; ++j) if(strnicmp((char *)AVI->idx[i], AVI->track[j].audio_tag,4) == 0) nai[j]++;\n\t\t}\n\n\t\tAVI->video_frames = nvi;\n\t\tfor(j=0; j<AVI->anum; ++j) AVI->track[j].audio_chunks = nai[j];\n\n\n\t\tif(AVI->video_frames==0) ERR_EXIT(AVI_ERR_NO_VIDS);\n\t\tAVI->video_index = (video_index_entry *) gf_malloc(nvi*sizeof(video_index_entry));\n\t\tif(AVI->video_index==0) ERR_EXIT(AVI_ERR_NO_MEM);\n\n\t\tfor(j=0; j<AVI->anum; ++j) {\n\t\t\tif(AVI->track[j].audio_chunks) {\n\t\t\t\tAVI->track[j].audio_index = (audio_index_entry *) gf_malloc((nai[j]+1)*sizeof(audio_index_entry));\n\t\t\t\tmemset(AVI->track[j].audio_index, 0, (nai[j]+1)*(sizeof(audio_index_entry)));\n\t\t\t\tif(AVI->track[j].audio_index==0) ERR_EXIT(AVI_ERR_NO_MEM);\n\t\t\t}\n\t\t}\n\n\t\tnvi = 0;\n\t\tfor(j=0; j<AVI->anum; ++j) {\n\t\t\tnai[j] = 0;\n\t\t\ttot[j] = 0;\n\t\t}\n\n\t\tioff = idx_type == 1 ? 8 : (u32)AVI->movi_start+4;\n\n\t\tfor(i=0; i<AVI->n_idx; i++) {\n\n\t\t\t//video\n\t\t\tif(strnicmp((char *)AVI->idx[i],AVI->video_tag,3) == 0) {\n\t\t\t\tAVI->video_index[nvi].key = str2ulong(AVI->idx[i]+ 4);\n\t\t\t\tAVI->video_index[nvi].pos = str2ulong(AVI->idx[i]+ 8)+ioff;\n\t\t\t\tAVI->video_index[nvi].len = str2ulong(AVI->idx[i]+12);\n\t\t\t\tnvi++;\n\t\t\t}\n\n\t\t\t//audio\n\t\t\tfor(j=0; j<AVI->anum; ++j) {\n\n\t\t\t\tif(strnicmp((char *)AVI->idx[i],AVI->track[j].audio_tag,4) == 0) {\n\t\t\t\t\tAVI->track[j].audio_index[nai[j]].pos = str2ulong(AVI->idx[i]+ 8)+ioff;\n\t\t\t\t\tAVI->track[j].audio_index[nai[j]].len = str2ulong(AVI->idx[i]+12);\n\t\t\t\t\tAVI->track[j].audio_index[nai[j]].tot = tot[j];\n\t\t\t\t\ttot[j] += AVI->track[j].audio_index[nai[j]].len;\n\t\t\t\t\tnai[j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tfor(j=0; j<AVI->anum; ++j) AVI->track[j].audio_bytes = tot[j];\n\n\t} // is no opendml\n\n\t/* Reposition the file */\n\n\tgf_fseek(AVI->fdes,AVI->movi_start,SEEK_SET);\n\tAVI->video_pos = 0;\n\n\treturn(0);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 1968,
    "critical_vars": [
      "n",
      "AVI->fdes",
      "u32",
      "AVI->idx"
    ],
    "function": "avi_parse_input_file",
    "filename": "gpac/CVE-2023-4681/CVE-2023-4681_CWE-476_4bac19ad854159b21ba70d8ab7c4e1cd1db8ea1c_avilib.c.diff",
    "function_code": "int avi_parse_input_file(avi_t *AVI, int getIndex)\n{\n\tint rate, scale, idx_type;\n\ts64 n, i;\n\tunsigned char *hdrl_data;\n\tu64 header_offset=0;\n\tint hdrl_len=0;\n\tint nvi, nai[AVI_MAX_TRACKS], ioff;\n\tu64 tot[AVI_MAX_TRACKS];\n\tu32 j;\n\tint lasttag = 0;\n\tint vids_strh_seen = 0;\n\tint vids_strf_seen = 0;\n\tint auds_strh_seen = 0;\n\t//  int auds_strf_seen = 0;\n\tint num_stream = 0;\n\tchar data[256];\n\ts64 oldpos=-1, newpos=-1;\n\n\tint aud_chunks = 0;\n\tif (!AVI) {\n\t   AVI_errno = AVI_ERR_OPEN;\n\t   return 0;\n\t}\n\n\t/* Read first 12 bytes and check that this is an AVI file */\n\tif (avi_read(AVI->fdes,data,12) != 12 )\n\t\tERR_EXIT(AVI_ERR_READ)\n\n\tif (strnicmp(data  ,\"RIFF\",4) !=0 || strnicmp(data+8,\"AVI \",4) !=0 )\n\t\tERR_EXIT(AVI_ERR_NO_AVI)\n\n\t/* Go through the AVI file and extract the header list,\n\t   the start position of the 'movi' list and an optionally\n\t   present idx1 tag */\n\n\thdrl_data = 0;\n\n\twhile(1)\n\t{\n\t\tif( avi_read(AVI->fdes,data,8) != 8 ) break; /* We assume it's EOF */\n\t\tnewpos = gf_ftell(AVI->fdes);\n\t\tif(oldpos==newpos) {\n\t\t\t/* This is a broken AVI stream... */\n\t\t\treturn -1;\n\t\t}\n\t\toldpos=newpos;\n\n\t\tn = str2ulong((unsigned char *)data+4);\n\t\tn = PAD_EVEN(n);\n\n\t\tif(strnicmp(data,\"LIST\",4) == 0)\n\t\t{\n\t\t\tif( avi_read(AVI->fdes,data,4) != 4 ) ERR_EXIT(AVI_ERR_READ)\n\t\t\t\tn -= 4;\n\t\t\tif(strnicmp(data,\"hdrl\",4) == 0)\n\t\t\t{\n\t\t\t\tif (n>0xFFFFFFFF) ERR_EXIT(AVI_ERR_READ)\n\t\t\t\thdrl_len = (u32) n;\n\t\t\t\thdrl_data = (unsigned char *) gf_malloc((u32)n);\n\t\t\t\tif(hdrl_data==0) ERR_EXIT(AVI_ERR_NO_MEM);\n\n\t\t\t\t// offset of header\n\n\t\t\t\theader_offset = gf_ftell(AVI->fdes);\n\n\t\t\t\tif( avi_read(AVI->fdes,(char *)hdrl_data, (u32) n) != n ) ERR_EXIT(AVI_ERR_READ)\n\t\t\t\t}\n\t\t\telse if(strnicmp(data,\"movi\",4) == 0)\n\t\t\t{\n\t\t\t\tAVI->movi_start = gf_ftell(AVI->fdes);\n\t\t\t\tif (gf_fseek(AVI->fdes,n,SEEK_CUR)==(u64)-1) break;\n\t\t\t}\n\t\t\telse if (gf_fseek(AVI->fdes,n,SEEK_CUR)==(u64)-1) break;\n\t\t}\n\t\telse if(strnicmp(data,\"idx1\",4) == 0)\n\t\t{\n\t\t\t/* n must be a multiple of 16, but the reading does not\n\t\t\t   break if this is not the case */\n\n\t\t\tAVI->n_idx = AVI->max_idx = (u32) (n/16);\n\t\t\tAVI->idx = (unsigned  char((*)[16]) ) gf_malloc((u32)n);\n\t\t\tif(AVI->idx==0) ERR_EXIT(AVI_ERR_NO_MEM)\n\t\t\t\tif(avi_read(AVI->fdes, (char *) AVI->idx, (u32) n) != n ) {\n\t\t\t\t\tgf_free( AVI->idx);\n\t\t\t\t\tAVI->idx=NULL;\n\t\t\t\t\tAVI->n_idx = 0;\n\t\t\t\t}\n\t\t}\n\t\telse\n\t\t\tgf_fseek(AVI->fdes,n,SEEK_CUR);\n\t}\n\n\tif(!hdrl_data      ) ERR_EXIT(AVI_ERR_NO_HDRL)\n\t\tif(!AVI->movi_start) ERR_EXIT(AVI_ERR_NO_MOVI)\n\n\t\t\t/* Interpret the header list */\n\n\t\t\tfor(i=0; i<hdrl_len;)\n\t\t\t{\n\t\t\t\t/* List tags are completly ignored */\n\n#ifdef DEBUG_ODML\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] TAG %c%c%c%c\\n\", (hdrl_data+i)[0], (hdrl_data+i)[1], (hdrl_data+i)[2], (hdrl_data+i)[3]));\n#endif\n\n\t\t\t\tif(strnicmp((char *)hdrl_data+i,\"LIST\",4)==0) {\n\t\t\t\t\ti+= 12;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tn = str2ulong(hdrl_data+i+4);\n\t\t\t\tn = PAD_EVEN(n);\n\t\t\t\tif (i+n>hdrl_len) ERR_EXIT(AVI_ERR_READ)\n\n\n\t\t\t\t/* Interpret the tag and its args */\n\n\t\t\t\tif(strnicmp((char *)hdrl_data+i,\"strh\",4)==0)\n\t\t\t\t{\n\t\t\t\t\ti += 8;\n#ifdef DEBUG_ODML\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] TAG   %c%c%c%c\\n\", (hdrl_data+i)[0], (hdrl_data+i)[1], (hdrl_data+i)[2], (hdrl_data+i)[3]));\n#endif\n\t\t\t\t\tif(strnicmp((char *)hdrl_data+i,\"vids\",4) == 0 && !vids_strh_seen)\n\t\t\t\t\t{\n\t\t\t\t\t\tmemcpy(AVI->compressor,hdrl_data+i+4,4);\n\t\t\t\t\t\tAVI->compressor[4] = 0;\n\n\t\t\t\t\t\t// ThOe\n\t\t\t\t\t\tAVI->v_codech_off = header_offset + i+4;\n\n\t\t\t\t\t\tscale = str2ulong(hdrl_data+i+20);\n\t\t\t\t\t\trate  = str2ulong(hdrl_data+i+24);\n\t\t\t\t\t\tif(scale!=0) AVI->fps = (double)rate/(double)scale;\n\t\t\t\t\t\tAVI->video_frames = str2ulong(hdrl_data+i+32);\n\t\t\t\t\t\tAVI->video_strn = num_stream;\n\t\t\t\t\t\tAVI->max_len = 0;\n\t\t\t\t\t\tvids_strh_seen = 1;\n\t\t\t\t\t\tlasttag = 1; /* vids */\n\t\t\t\t\t\tmemcpy(&AVI->video_stream_header, hdrl_data + i,\n\t\t\t\t\t\t       sizeof(alAVISTREAMHEADER));\n\t\t\t\t\t}\n\t\t\t\t\telse if (strnicmp ((char *)hdrl_data+i,\"auds\",4) ==0 && ! auds_strh_seen)\n\t\t\t\t\t{\n\n\t\t\t\t\t\t//inc audio tracks\n\t\t\t\t\t\tAVI->aptr=AVI->anum;\n\t\t\t\t\t\t++AVI->anum;\n\n\t\t\t\t\t\tif(AVI->anum > AVI_MAX_TRACKS) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] error - only %d audio tracks supported\\n\", AVI_MAX_TRACKS));\n\t\t\t\t\t\t\treturn(-1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_bytes = str2ulong(hdrl_data+i+32)*avi_sampsize(AVI, 0);\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_strn = num_stream;\n\n\t\t\t\t\t\t// if samplesize==0 -> vbr\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_vbr = !str2ulong(hdrl_data+i+44);\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].padrate = str2ulong(hdrl_data+i+24);\n\t\t\t\t\t\tmemcpy(&AVI->stream_headers[AVI->aptr], hdrl_data + i,\n\t\t\t\t\t\t       sizeof(alAVISTREAMHEADER));\n\n\t\t\t\t\t\t//\t   auds_strh_seen = 1;\n\t\t\t\t\t\tlasttag = 2; /* auds */\n\n\t\t\t\t\t\t// ThOe\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_codech_off = header_offset + i;\n\n\t\t\t\t\t}\n\t\t\t\t\telse if (strnicmp ((char*)hdrl_data+i,\"iavs\",4) ==0 && ! auds_strh_seen) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] AVILIB: error - DV AVI Type 1 no supported\\n\"));\n\t\t\t\t\t\treturn (-1);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tlasttag = 0;\n\t\t\t\t\tnum_stream++;\n\t\t\t\t}\n\t\t\t\telse if(strnicmp((char*)hdrl_data+i,\"dmlh\",4) == 0) {\n\t\t\t\t\tAVI->total_frames = str2ulong(hdrl_data+i+8);\n#ifdef DEBUG_ODML\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] real number of frames %d\\n\", AVI->total_frames));\n#endif\n\t\t\t\t\ti += 8;\n\t\t\t\t}\n\t\t\t\telse if(strnicmp((char *)hdrl_data+i,\"strf\",4)==0)\n\t\t\t\t{\n\t\t\t\t\ti += 8;\n\t\t\t\t\tif(lasttag == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\talBITMAPINFOHEADER bih;\n\n\t\t\t\t\t\tmemcpy(&bih, hdrl_data + i, sizeof(alBITMAPINFOHEADER));\n\t\t\t\t\t\tbih.bi_size = str2ulong((unsigned char *)&bih.bi_size);\n\n\t\t\t\t\t\tif (i + bih.bi_size > hdrl_len) ERR_EXIT(AVI_ERR_READ)\n\n\t\t\t\t\t\tAVI->bitmap_info_header = (alBITMAPINFOHEADER *) gf_malloc(bih.bi_size);\n\t\t\t\t\t\tif (AVI->bitmap_info_header != NULL)\n\t\t\t\t\t\t\tmemcpy(AVI->bitmap_info_header, hdrl_data + i, bih.bi_size);\n\n\t\t\t\t\t\tAVI->width  = str2ulong(hdrl_data+i+4);\n\t\t\t\t\t\tAVI->height = str2ulong(hdrl_data+i+8);\n\t\t\t\t\t\tvids_strf_seen = 1;\n\t\t\t\t\t\t//ThOe\n\t\t\t\t\t\tAVI->v_codecf_off = header_offset + i+16;\n\n\t\t\t\t\t\tmemcpy(AVI->compressor2, hdrl_data+i+16, 4);\n\t\t\t\t\t\tAVI->compressor2[4] = 0;\n\n\t\t\t\t\t\tif (n>40) {\n\t\t\t\t\t\t\tif (n>0xFFFFFFFF) ERR_EXIT(AVI_ERR_READ)\n\t\t\t\t\t\t\tAVI->extradata_size = (u32) (n - 40);\n\t\t\t\t\t\t\tAVI->extradata = gf_malloc(sizeof(u8)* AVI->extradata_size);\n\t\t\t\t\t\t\tif (!AVI->extradata) ERR_EXIT(AVI_ERR_NO_MEM)\n\t\t\t\t\t\t\tmemcpy(AVI->extradata, hdrl_data + i + 40, AVI->extradata_size);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\telse if(lasttag == 2)\n\t\t\t\t\t{\n\t\t\t\t\t\talWAVEFORMATEX *wfe;\n\t\t\t\t\t\tchar *nwfe;\n\t\t\t\t\t\tint wfes;\n\n\t\t\t\t\t\tif ((u32) (hdrl_len - i) < sizeof(alWAVEFORMATEX))\n\t\t\t\t\t\t\twfes = (int) (hdrl_len - i);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\twfes = sizeof(alWAVEFORMATEX);\n\t\t\t\t\t\twfe = (alWAVEFORMATEX *)gf_malloc(sizeof(alWAVEFORMATEX));\n\t\t\t\t\t\tif (wfe != NULL) {\n\t\t\t\t\t\t\tmemset(wfe, 0, sizeof(alWAVEFORMATEX));\n\t\t\t\t\t\t\tmemcpy(wfe, hdrl_data + i, wfes);\n\t\t\t\t\t\t\tif (str2ushort((unsigned char *)&wfe->cb_size) != 0) {\n\t\t\t\t\t\t\t\tnwfe = (char *)\n\t\t\t\t\t\t\t\t       gf_realloc(wfe, sizeof(alWAVEFORMATEX) +\n\t\t\t\t\t\t\t\t                  str2ushort((unsigned char *)&wfe->cb_size));\n\t\t\t\t\t\t\t\tif (nwfe != 0) {\n\t\t\t\t\t\t\t\t\ts64 lpos = gf_ftell(AVI->fdes);\n\t\t\t\t\t\t\t\t\tgf_fseek(AVI->fdes, header_offset + i + sizeof(alWAVEFORMATEX),\n\t\t\t\t\t\t\t\t\t         SEEK_SET);\n\t\t\t\t\t\t\t\t\twfe = (alWAVEFORMATEX *)nwfe;\n\t\t\t\t\t\t\t\t\tnwfe = &nwfe[sizeof(alWAVEFORMATEX)];\n\t\t\t\t\t\t\t\t\tavi_read(AVI->fdes, nwfe,\n\t\t\t\t\t\t\t\t\t         str2ushort((unsigned char *)&wfe->cb_size));\n\t\t\t\t\t\t\t\t\tgf_fseek(AVI->fdes, lpos, SEEK_SET);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tAVI->wave_format_ex[AVI->aptr] = wfe;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_fmt   = str2ushort(hdrl_data+i  );\n\n\t\t\t\t\t\t//ThOe\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_codecf_off = header_offset + i;\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_chans = str2ushort(hdrl_data+i+2);\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_rate  = str2ulong (hdrl_data+i+4);\n\t\t\t\t\t\t//ThOe: read mp3bitrate\n\t\t\t\t\t\tAVI->track[AVI->aptr].mp3rate = 8*str2ulong(hdrl_data+i+8)/1000;\n\t\t\t\t\t\t//:ThOe\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_bits  = str2ushort(hdrl_data+i+14);\n\t\t\t\t\t\t//            auds_strf_seen = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(strnicmp((char*)hdrl_data+i,\"indx\",4) == 0) {\n\t\t\t\t\tchar *a;\n\n\t\t\t\t\tif(lasttag == 1) // V I D E O\n\t\t\t\t\t{\n\n\t\t\t\t\t\ta = (char*)hdrl_data+i;\n\t\t\t\t\t\tint avail = hdrl_len-i;\n\t\t\t\t\t\tif (avail<32) ERR_EXIT(AVI_ERR_READ)\n\n\t\t\t\t\t\tAVI->video_superindex = (avisuperindex_chunk *) gf_malloc (sizeof (avisuperindex_chunk));\n\t\t\t\t\t\tmemset(AVI->video_superindex, 0, sizeof (avisuperindex_chunk));\n\t\t\t\t\t\tmemcpy (AVI->video_superindex->fcc, a, 4);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->video_superindex->dwSize = str2ulong((unsigned char *)a);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->video_superindex->wLongsPerEntry = str2ushort((unsigned char *)a);\n\t\t\t\t\t\ta += 2;\n\t\t\t\t\t\tAVI->video_superindex->bIndexSubType = *a;\n\t\t\t\t\t\ta += 1;\n\t\t\t\t\t\tAVI->video_superindex->bIndexType = *a;\n\t\t\t\t\t\ta += 1;\n\t\t\t\t\t\tAVI->video_superindex->nEntriesInUse = str2ulong((unsigned char *)a);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tmemcpy (AVI->video_superindex->dwChunkId, a, 4);\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\t// 3 * reserved\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\tif (AVI->video_superindex->bIndexSubType != 0) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] Invalid Header, bIndexSubType != 0\\n\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tavail -= 32;\n\t\t\t\t\t\tif (avail < AVI->video_superindex->nEntriesInUse*16) ERR_EXIT(AVI_ERR_READ)\n\n\t\t\t\t\t\tAVI->video_superindex->aIndex = (avisuperindex_entry*)\n\t\t\t\t\t\t                                gf_malloc (AVI->video_superindex->wLongsPerEntry * AVI->video_superindex->nEntriesInUse * sizeof (u32));\n\n\t\t\t\t\t\t// position of ix## chunks\n\t\t\t\t\t\tfor (j=0; j<AVI->video_superindex->nEntriesInUse; ++j) {\n\t\t\t\t\t\t\tAVI->video_superindex->aIndex[j].qwOffset = str2ullong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 8;\n\t\t\t\t\t\t\tAVI->video_superindex->aIndex[j].dwSize = str2ulong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\t\tAVI->video_superindex->aIndex[j].dwDuration = str2ulong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 4;\n\n#ifdef DEBUG_ODML\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d] 0x%llx 0x%lx %lu\\n\", j,\n\t\t\t\t\t\t\t                                        (unsigned int long)AVI->video_superindex->aIndex[j].qwOffset,\n\t\t\t\t\t\t\t                                        (unsigned long)AVI->video_superindex->aIndex[j].dwSize,\n\t\t\t\t\t\t\t                                        (unsigned long)AVI->video_superindex->aIndex[j].dwDuration));\n#endif\n\t\t\t\t\t\t}\n\n\n#ifdef DEBUG_ODML\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] FOURCC \\\"%c%c%c%c\\\"\\n\", AVI->video_superindex->fcc[0], AVI->video_superindex->fcc[1],\n\t\t\t\t\t\t                                        AVI->video_superindex->fcc[2], AVI->video_superindex->fcc[3]));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] LEN \\\"%ld\\\"\\n\", (long)AVI->video_superindex->dwSize));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] wLongsPerEntry \\\"%d\\\"\\n\", AVI->video_superindex->wLongsPerEntry));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] bIndexSubType \\\"%d\\\"\\n\", AVI->video_superindex->bIndexSubType));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] bIndexType \\\"%d\\\"\\n\", AVI->video_superindex->bIndexType));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] nEntriesInUse \\\"%ld\\\"\\n\", (long)AVI->video_superindex->nEntriesInUse));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] dwChunkId \\\"%c%c%c%c\\\"\\n\", AVI->video_superindex->dwChunkId[0], AVI->video_superindex->dwChunkId[1],\n\t\t\t\t\t\t                                        AVI->video_superindex->dwChunkId[2], AVI->video_superindex->dwChunkId[3]));\n#endif\n\n\t\t\t\t\t\tAVI->is_opendml = 1;\n\n\t\t\t\t\t}\n\t\t\t\t\telse if(lasttag == 2) // A U D I O\n\t\t\t\t\t{\n\n\t\t\t\t\t\ta = (char*) hdrl_data+i;\n\t\t\t\t\t\tint avail = hdrl_len-i;\n\t\t\t\t\t\tif (avail<32) ERR_EXIT(AVI_ERR_READ)\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex = (avisuperindex_chunk *) gf_malloc (sizeof (avisuperindex_chunk));\n\t\t\t\t\t\tmemcpy (AVI->track[AVI->aptr].audio_superindex->fcc, a, 4);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->dwSize = str2ulong((unsigned char*)a);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->wLongsPerEntry = str2ushort((unsigned char*)a);\n\t\t\t\t\t\ta += 2;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->bIndexSubType = *a;\n\t\t\t\t\t\ta += 1;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->bIndexType = *a;\n\t\t\t\t\t\ta += 1;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->nEntriesInUse = str2ulong((unsigned char*)a);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tmemcpy (AVI->track[AVI->aptr].audio_superindex->dwChunkId, a, 4);\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\t// 3 * reserved\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\tif (AVI->track[AVI->aptr].audio_superindex->bIndexSubType != 0) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] Invalid Header, bIndexSubType != 0\\n\"));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tavail -= 32;\n\t\t\t\t\t\tif (avail < AVI->track[AVI->aptr].audio_superindex->nEntriesInUse*16) ERR_EXIT(AVI_ERR_READ)\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->aIndex = (avisuperindex_entry*)\n\t\t\t\t\t\t        gf_malloc (AVI->track[AVI->aptr].audio_superindex->wLongsPerEntry *\n\t\t\t\t\t\t                   AVI->track[AVI->aptr].audio_superindex->nEntriesInUse * sizeof (u32));\n\n\t\t\t\t\t\t// position of ix## chunks\n\t\t\t\t\t\tfor (j=0; j<AVI->track[AVI->aptr].audio_superindex->nEntriesInUse; ++j) {\n\t\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->aIndex[j].qwOffset = str2ullong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 8;\n\t\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->aIndex[j].dwSize = str2ulong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->aIndex[j].dwDuration = str2ulong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 4;\n\n#ifdef DEBUG_ODML\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d] 0x%llx 0x%lx %lu\\n\", j,\n\t\t\t\t\t\t\t                                        (unsigned int long)AVI->track[AVI->aptr].audio_superindex->aIndex[j].qwOffset,\n\t\t\t\t\t\t\t                                        (unsigned long)AVI->track[AVI->aptr].audio_superindex->aIndex[j].dwSize,\n\t\t\t\t\t\t\t                                        (unsigned long)AVI->track[AVI->aptr].audio_superindex->aIndex[j].dwDuration));\n#endif\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->stdindex = NULL;\n\n#ifdef DEBUG_ODML\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] FOURCC \\\"%.4s\\\"\\n\", AVI->track[AVI->aptr].audio_superindex->fcc));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] LEN \\\"%ld\\\"\\n\", (long)AVI->track[AVI->aptr].audio_superindex->dwSize));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] wLongsPerEntry \\\"%d\\\"\\n\", AVI->track[AVI->aptr].audio_superindex->wLongsPerEntry));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] bIndexSubType \\\"%d\\\"\\n\", AVI->track[AVI->aptr].audio_superindex->bIndexSubType));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] bIndexType \\\"%d\\\"\\n\", AVI->track[AVI->aptr].audio_superindex->bIndexType));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] nEntriesInUse \\\"%ld\\\"\\n\", (long)AVI->track[AVI->aptr].audio_superindex->nEntriesInUse));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] dwChunkId \\\"%.4s\\\"\\n\", AVI->track[AVI->aptr].audio_superindex->dwChunkId[0]));\n#endif\n\n\t\t\t\t\t}\n\t\t\t\t\ti += 8;\n\t\t\t\t}\n\t\t\t\telse if((strnicmp((char*)hdrl_data+i,\"JUNK\",4) == 0) ||\n\t\t\t\t        (strnicmp((char*)hdrl_data+i,\"strn\",4) == 0) ||\n\t\t\t\t        (strnicmp((char*)hdrl_data+i,\"vprp\",4) == 0)) {\n\t\t\t\t\ti += 8;\n\t\t\t\t\t// do not reset lasttag\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\ti += 8;\n\t\t\t\t\tlasttag = 0;\n\t\t\t\t}\n\t\t\t\t//GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] adding %ld bytes\\n\", (int int)n));\n\n\t\t\t\ti += (u32) n;\n\t\t\t}\n\n\tgf_free(hdrl_data);\n\n\tif(!vids_strh_seen || !vids_strf_seen) ERR_EXIT(AVI_ERR_NO_VIDS)\n\n\t\tAVI->video_tag[0] = AVI->video_strn/10 + '0';\n\tAVI->video_tag[1] = AVI->video_strn%10 + '0';\n\tAVI->video_tag[2] = 'd';\n\tAVI->video_tag[3] = 'b';\n\n\t/* Audio tag is set to \"99wb\" if no audio present */\n\tif(!AVI->track[0].a_chans) AVI->track[0].audio_strn = 99;\n\n\t{\n\t\tint tk=0;\n\t\tfor(j=0; j<AVI->anum+1; ++j) {\n\t\t\tif (j == AVI->video_strn) continue;\n\t\t\tAVI->track[tk].audio_tag[0] = j/10 + '0';\n\t\t\tAVI->track[tk].audio_tag[1] = j%10 + '0';\n\t\t\tAVI->track[tk].audio_tag[2] = 'w';\n\t\t\tAVI->track[tk].audio_tag[3] = 'b';\n\t\t\t++tk;\n\t\t}\n\t}\n\n\tgf_fseek(AVI->fdes,AVI->movi_start,SEEK_SET);\n\n\tif(!getIndex) return(0);\n\n\t/* if the file has an idx1, check if this is relative\n\t   to the start of the file or to the start of the movi list */\n\n\tidx_type = 0;\n\n\tif(AVI->idx)\n\t{\n\t\ts64 pos, len;\n\n\t\t/* Search the first videoframe in the idx1 and look where\n\t\t   it is in the file */\n\n\t\tfor(i=0; i<AVI->n_idx; i++)\n\t\t\tif( strnicmp((char *)AVI->idx[i],(char *)AVI->video_tag,3)==0 ) break;\n\t\tif(i>=AVI->n_idx) ERR_EXIT(AVI_ERR_NO_VIDS)\n\n\t\t\tpos = str2ulong(AVI->idx[i]+ 8);\n\t\tlen = str2ulong(AVI->idx[i]+12);\n\n\t\tgf_fseek(AVI->fdes,pos,SEEK_SET);\n\t\tif(avi_read(AVI->fdes,data,8)!=8) ERR_EXIT(AVI_ERR_READ)\n\t\t\tif( strnicmp(data,(char *)AVI->idx[i],4)==0 && str2ulong((unsigned char *)data+4)==len )\n\t\t\t{\n\t\t\t\tidx_type = 1; /* Index from start of file */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tgf_fseek(AVI->fdes,pos+AVI->movi_start-4,SEEK_SET);\n\t\t\t\tif(avi_read(AVI->fdes,data,8)!=8) ERR_EXIT(AVI_ERR_READ)\n\t\t\t\t\tif( strnicmp(data,(char *)AVI->idx[i],4)==0 && str2ulong((unsigned char *)data+4)==len )\n\t\t\t\t\t{\n\t\t\t\t\t\tidx_type = 2; /* Index from start of movi list */\n\t\t\t\t\t}\n\t\t\t}\n\t\t/* idx_type remains 0 if neither of the two tests above succeeds */\n\t}\n\n\n\tif(idx_type == 0 && !AVI->is_opendml && !AVI->total_frames)\n\t{\n\t\t/* we must search through the file to get the index */\n\n\t\tgf_fseek(AVI->fdes, AVI->movi_start, SEEK_SET);\n\n\t\tAVI->n_idx = 0;\n\n\t\twhile(1)\n\t\t{\n\t\t\tif( avi_read(AVI->fdes,data,8) != 8 ) break;\n\t\t\tn = str2ulong((unsigned char *)data+4);\n\n\t\t\t/* The movi list may contain sub-lists, ignore them */\n\n\t\t\tif(strnicmp(data,\"LIST\",4)==0)\n\t\t\t{\n\t\t\t\tgf_fseek(AVI->fdes,4,SEEK_CUR);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Check if we got a tag ##db, ##dc or ##wb */\n\n\t\t\tif( ( (data[2]=='d' || data[2]=='D') &&\n\t\t\t        (data[3]=='b' || data[3]=='B' || data[3]=='c' || data[3]=='C') )\n\t\t\t        || ( (data[2]=='w' || data[2]=='W') &&\n\t\t\t             (data[3]=='b' || data[3]=='B') ) )\n\t\t\t{\n\t\t\t\tu64 __pos = gf_ftell(AVI->fdes) - 8;\n\t\t\t\tavi_add_index_entry(AVI,(unsigned char *)data,0,__pos,n);\n\t\t\t}\n\n\t\t\tgf_fseek(AVI->fdes,PAD_EVEN(n),SEEK_CUR);\n\t\t}\n\t\tidx_type = 1;\n\t}\n\n\t// ************************\n\t// OPENDML\n\t// ************************\n\n\t// read extended index chunks\n\tif (AVI->is_opendml) {\n\t\tu64 offset = 0;\n\t\thdrl_len = 4+4+2+1+1+4+4+8+4;\n\t\tchar *en, *chunk_start;\n\t\tint k = 0;\n\t\tu32 audtr = 0;\n\t\tu32 nrEntries = 0;\n\n\t\tAVI->video_index = NULL;\n\n\t\tnvi = 0;\n\t\tfor(audtr=0; audtr<AVI->anum; ++audtr) {\n\t\t\tnai[audtr] = 0;\n\t\t\ttot[audtr] = 0;\n\t\t}\n\n\t\t// ************************\n\t\t// VIDEO\n\t\t// ************************\n\n\t\tfor (j=0; j<AVI->video_superindex->nEntriesInUse; j++) {\n\n\t\t\t// read from file\n\t\t\tchunk_start = en = (char*) gf_malloc ((u32) (AVI->video_superindex->aIndex[j].dwSize+hdrl_len) );\n\n\t\t\tif (gf_fseek(AVI->fdes, AVI->video_superindex->aIndex[j].qwOffset, SEEK_SET) == (u64)-1) {\n\t\t\t\tgf_free(chunk_start);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (avi_read(AVI->fdes, en, (u32) (AVI->video_superindex->aIndex[j].dwSize+hdrl_len) ) <= 0) {\n\t\t\t\tgf_free(chunk_start);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnrEntries = str2ulong((unsigned char*)en + 12);\n#ifdef DEBUG_ODML\n\t\t\t//GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d:0] Video nrEntries %ld\\n\", j, nrEntries));\n#endif\n\t\t\toffset = str2ullong((unsigned char*)en + 20);\n\n\t\t\t// skip header\n\t\t\ten += hdrl_len;\n\t\t\tnvi += nrEntries;\n\t\t\tAVI->video_index = (video_index_entry *) gf_realloc (AVI->video_index, nvi * sizeof (video_index_entry));\n\t\t\tif (!AVI->video_index) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] out of mem (size = %ld)\\n\", nvi * sizeof (video_index_entry)));\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\twhile (k < nvi) {\n\n\t\t\t\tAVI->video_index[k].pos = offset + str2ulong((unsigned char*)en);\n\t\t\t\ten += 4;\n\t\t\t\tAVI->video_index[k].len = str2ulong_len((unsigned char*)en);\n\t\t\t\tAVI->video_index[k].key = str2ulong_key((unsigned char*)en);\n\t\t\t\ten += 4;\n\n\t\t\t\t// completely empty chunk\n\t\t\t\tif (AVI->video_index[k].pos-offset == 0 && AVI->video_index[k].len == 0) {\n\t\t\t\t\tk--;\n\t\t\t\t\tnvi--;\n\t\t\t\t}\n\n#ifdef DEBUG_ODML\n\t\t\t\t/*\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d] POS 0x%llX len=%d key=%s offset (%llx) (%ld)\\n\", k,\n\t\t\t\t  AVI->video_index[k].pos,\n\t\t\t\t  (int)AVI->video_index[k].len,\n\t\t\t\t  AVI->video_index[k].key?\"yes\":\"no \", offset,\n\t\t\t\t  AVI->video_superindex->aIndex[j].dwSize));\n\t\t\t\t  */\n#endif\n\n\t\t\t\tk++;\n\t\t\t}\n\n\t\t\tgf_free(chunk_start);\n\t\t}\n\n\t\tAVI->video_frames = nvi;\n\t\t// this should deal with broken 'rec ' odml files.\n\t\tif (AVI->video_frames == 0) {\n\t\t\tAVI->is_opendml=0;\n\t\t\tgoto multiple_riff;\n\t\t}\n\n\t\t// ************************\n\t\t// AUDIO\n\t\t// ************************\n\n\t\tfor(audtr=0; audtr<AVI->anum; ++audtr) {\n\n\t\t\tk = 0;\n\t\t\tif (!AVI->track[audtr].audio_superindex) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] (%s) cannot read audio index for track %d\\n\", __FILE__, audtr));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (j=0; j<AVI->track[audtr].audio_superindex->nEntriesInUse; j++) {\n\n\t\t\t\t// read from file\n\t\t\t\tchunk_start = en = (char*)gf_malloc ((u32) (AVI->track[audtr].audio_superindex->aIndex[j].dwSize+hdrl_len));\n\n\t\t\t\tif (gf_fseek(AVI->fdes, AVI->track[audtr].audio_superindex->aIndex[j].qwOffset, SEEK_SET) == (u64)-1) {\n\t\t\t\t\tgf_free(chunk_start);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (avi_read(AVI->fdes, en, (u32) (AVI->track[audtr].audio_superindex->aIndex[j].dwSize+hdrl_len)) <= 0) {\n\t\t\t\t\tgf_free(chunk_start);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tnrEntries = str2ulong((unsigned char*)en + 12);\n\t\t\t\t//if (nrEntries > 50) nrEntries = 2; // XXX\n#ifdef DEBUG_ODML\n\t\t\t\t//GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d:%d] Audio nrEntries %ld\\n\", j, audtr, nrEntries));\n#endif\n\t\t\t\toffset = str2ullong((unsigned char*)en + 20);\n\n\t\t\t\t// skip header\n\t\t\t\ten += hdrl_len;\n\t\t\t\tnai[audtr] += nrEntries;\n\t\t\t\tAVI->track[audtr].audio_index = (audio_index_entry *) gf_realloc (AVI->track[audtr].audio_index, nai[audtr] * sizeof (audio_index_entry));\n\n\t\t\t\twhile (k < nai[audtr]) {\n\n\t\t\t\t\tAVI->track[audtr].audio_index[k].pos = offset + str2ulong((unsigned char*)en);\n\t\t\t\t\ten += 4;\n\t\t\t\t\tAVI->track[audtr].audio_index[k].len = str2ulong_len((unsigned char*)en);\n\t\t\t\t\ten += 4;\n\t\t\t\t\tAVI->track[audtr].audio_index[k].tot = tot[audtr];\n\t\t\t\t\ttot[audtr] += AVI->track[audtr].audio_index[k].len;\n\n#ifdef DEBUG_ODML\n\t\t\t\t\t/*\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d:%d] POS 0x%llX len=%d offset (%llx) (%ld)\\n\", k, audtr,\n\t\t\t\t\t  AVI->track[audtr].audio_index[k].pos,\n\t\t\t\t\t  (int)AVI->track[audtr].audio_index[k].len,\n\t\t\t\t\t  offset, AVI->track[audtr].audio_superindex->aIndex[j].dwSize));\n\t\t\t\t\t  */\n#endif\n\n\t\t\t\t\t++k;\n\t\t\t\t}\n\n\t\t\t\tgf_free(chunk_start);\n\t\t\t}\n\n\t\t\tAVI->track[audtr].audio_chunks = nai[audtr];\n\t\t\tAVI->track[audtr].audio_bytes = tot[audtr];\n\t\t}\n\t} // is opendml\n\n\telse if (AVI->total_frames && !AVI->is_opendml && idx_type==0) {\n\n\t\t// *********************\n\t\t// MULTIPLE RIFF CHUNKS (and no index)\n\t\t// *********************\n\nmultiple_riff:\n\n\t\tgf_fseek(AVI->fdes, AVI->movi_start, SEEK_SET);\n\n\t\tAVI->n_idx = 0;\n\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] Reconstructing index...\"));\n\n\t\t// Number of frames; only one audio track supported\n\t\tnvi = AVI->video_frames = AVI->total_frames;\n\t\tnai[0] = AVI->track[0].audio_chunks = AVI->total_frames;\n\t\tfor(j=1; j<AVI->anum; ++j) AVI->track[j].audio_chunks = 0;\n\n\t\tAVI->video_index = (video_index_entry *) gf_malloc(nvi*sizeof(video_index_entry));\n\n\t\tif(AVI->video_index==0) ERR_EXIT(AVI_ERR_NO_MEM);\n\n\t\tfor(j=0; j<AVI->anum; ++j) {\n\t\t\tif(AVI->track[j].audio_chunks) {\n\t\t\t\tAVI->track[j].audio_index = (audio_index_entry *) gf_malloc((nai[j]+1)*sizeof(audio_index_entry));\n\t\t\t\tmemset(AVI->track[j].audio_index, 0, (nai[j]+1)*(sizeof(audio_index_entry)));\n\t\t\t\tif(AVI->track[j].audio_index==0) ERR_EXIT(AVI_ERR_NO_MEM);\n\t\t\t}\n\t\t}\n\n\t\tnvi = 0;\n\t\tfor(j=0; j<AVI->anum; ++j) {\n\t\t\tnai[j] = 0;\n\t\t\ttot[j] = 0;\n\t\t}\n\n\t\taud_chunks = AVI->total_frames;\n\n\t\twhile(1)\n\t\t{\n\t\t\tif (nvi >= AVI->total_frames) break;\n\n\t\t\tif( avi_read(AVI->fdes,data,8) != 8 ) break;\n\t\t\tn = str2ulong((unsigned char *)data+4);\n\n\n\t\t\tj=0;\n\n\t\t\tif (aud_chunks - nai[j] -1 <= 0) {\n\t\t\t\taud_chunks += AVI->total_frames;\n\t\t\t\tAVI->track[j].audio_index = (audio_index_entry *)\n\t\t\t\t                            gf_realloc( AVI->track[j].audio_index, (aud_chunks+1)*sizeof(audio_index_entry));\n\t\t\t\tif (!AVI->track[j].audio_index) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] Internal error in avilib -- no mem\\n\"));\n\t\t\t\t\tAVI_errno = AVI_ERR_NO_MEM;\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Check if we got a tag ##db, ##dc or ##wb */\n\n\t\t\t// VIDEO\n\t\t\tif(\n\t\t\t    (data[0]=='0' || data[1]=='0') &&\n\t\t\t    (data[2]=='d' || data[2]=='D') &&\n\t\t\t    (data[3]=='b' || data[3]=='B' || data[3]=='c' || data[3]=='C') ) {\n\n\t\t\t\tAVI->video_index[nvi].key = 0x0;\n\t\t\t\tAVI->video_index[nvi].pos = gf_ftell(AVI->fdes);\n\t\t\t\tAVI->video_index[nvi].len = (u32) n;\n\n\t\t\t\t/*\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] Frame %ld pos %\"LLD\" len %\"LLD\" key %ld\\n\",\n\t\t\t\t    nvi, AVI->video_index[nvi].pos,  AVI->video_index[nvi].len, (long)AVI->video_index[nvi].key));\n\t\t\t\t    */\n\t\t\t\tnvi++;\n\t\t\t\tgf_fseek(AVI->fdes,PAD_EVEN(n),SEEK_CUR);\n\t\t\t}\n\n\t\t\t//AUDIO\n\t\t\telse if(\n\t\t\t    (data[0]=='0' || data[1]=='1') &&\n\t\t\t    (data[2]=='w' || data[2]=='W') &&\n\t\t\t    (data[3]=='b' || data[3]=='B') ) {\n\n\n\t\t\t\tAVI->track[j].audio_index[nai[j]].pos = gf_ftell(AVI->fdes);\n\t\t\t\tAVI->track[j].audio_index[nai[j]].len = (u32) n;\n\t\t\t\tAVI->track[j].audio_index[nai[j]].tot = tot[j];\n\t\t\t\ttot[j] += AVI->track[j].audio_index[nai[j]].len;\n\t\t\t\tnai[j]++;\n\n\t\t\t\tgf_fseek(AVI->fdes,PAD_EVEN(n),SEEK_CUR);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgf_fseek(AVI->fdes,-4,SEEK_CUR);\n\t\t\t}\n\n\t\t}\n\t\tif (nvi < AVI->total_frames) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[avilib] Uh? Some frames seems missing (%ld/%d)\\n\",\n\t\t\t        nvi,  AVI->total_frames));\n\t\t}\n\n\n\t\tAVI->video_frames = nvi;\n\t\tAVI->track[0].audio_chunks = nai[0];\n\n\t\tfor(j=0; j<AVI->anum; ++j) AVI->track[j].audio_bytes = tot[j];\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] done. nvi=%ld nai=%ld tot=%ld\\n\", nvi, nai[0], tot[0]));\n\n\t} // total_frames but no indx chunk (xawtv does this)\n\n\telse\n\n\t{\n\t\t// ******************\n\t\t// NO OPENDML\n\t\t// ******************\n\n\t\t/* Now generate the video index and audio index arrays */\n\n\t\tnvi = 0;\n\t\tfor(j=0; j<AVI->anum; ++j) nai[j] = 0;\n\n\t\tfor(i=0; i<AVI->n_idx; i++) {\n\n\t\t\tif(strnicmp((char *)AVI->idx[i],AVI->video_tag,3) == 0) nvi++;\n\n\t\t\tfor(j=0; j<AVI->anum; ++j) if(strnicmp((char *)AVI->idx[i], AVI->track[j].audio_tag,4) == 0) nai[j]++;\n\t\t}\n\n\t\tAVI->video_frames = nvi;\n\t\tfor(j=0; j<AVI->anum; ++j) AVI->track[j].audio_chunks = nai[j];\n\n\n\t\tif(AVI->video_frames==0) ERR_EXIT(AVI_ERR_NO_VIDS);\n\t\tAVI->video_index = (video_index_entry *) gf_malloc(nvi*sizeof(video_index_entry));\n\t\tif(AVI->video_index==0) ERR_EXIT(AVI_ERR_NO_MEM);\n\n\t\tfor(j=0; j<AVI->anum; ++j) {\n\t\t\tif(AVI->track[j].audio_chunks) {\n\t\t\t\tAVI->track[j].audio_index = (audio_index_entry *) gf_malloc((nai[j]+1)*sizeof(audio_index_entry));\n\t\t\t\tmemset(AVI->track[j].audio_index, 0, (nai[j]+1)*(sizeof(audio_index_entry)));\n\t\t\t\tif(AVI->track[j].audio_index==0) ERR_EXIT(AVI_ERR_NO_MEM);\n\t\t\t}\n\t\t}\n\n\t\tnvi = 0;\n\t\tfor(j=0; j<AVI->anum; ++j) {\n\t\t\tnai[j] = 0;\n\t\t\ttot[j] = 0;\n\t\t}\n\n\t\tioff = idx_type == 1 ? 8 : (u32)AVI->movi_start+4;\n\n\t\tfor(i=0; i<AVI->n_idx; i++) {\n\n\t\t\t//video\n\t\t\tif(strnicmp((char *)AVI->idx[i],AVI->video_tag,3) == 0) {\n\t\t\t\tAVI->video_index[nvi].key = str2ulong(AVI->idx[i]+ 4);\n\t\t\t\tAVI->video_index[nvi].pos = str2ulong(AVI->idx[i]+ 8)+ioff;\n\t\t\t\tAVI->video_index[nvi].len = str2ulong(AVI->idx[i]+12);\n\t\t\t\tnvi++;\n\t\t\t}\n\n\t\t\t//audio\n\t\t\tfor(j=0; j<AVI->anum; ++j) {\n\n\t\t\t\tif(strnicmp((char *)AVI->idx[i],AVI->track[j].audio_tag,4) == 0) {\n\t\t\t\t\tAVI->track[j].audio_index[nai[j]].pos = str2ulong(AVI->idx[i]+ 8)+ioff;\n\t\t\t\t\tAVI->track[j].audio_index[nai[j]].len = str2ulong(AVI->idx[i]+12);\n\t\t\t\t\tAVI->track[j].audio_index[nai[j]].tot = tot[j];\n\t\t\t\t\ttot[j] += AVI->track[j].audio_index[nai[j]].len;\n\t\t\t\t\tnai[j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tfor(j=0; j<AVI->anum; ++j) AVI->track[j].audio_bytes = tot[j];\n\n\t} // is no opendml\n\n\t/* Reposition the file */\n\n\tgf_fseek(AVI->fdes,AVI->movi_start,SEEK_SET);\n\tAVI->video_pos = 0;\n\n\treturn(0);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 8390,
    "critical_vars": [
      "ctx->force_period_switch"
    ],
    "function": "dasher_process",
    "filename": "gpac/CVE-2023-4681/CVE-2023-4681_CWE-476_4bac19ad854159b21ba70d8ab7c4e1cd1db8ea1c_dasher.c.diff",
    "function_code": "\n\tds->first_cts_in_next_seg = ds->first_cts_in_seg + gf_timestamp_rescale(ds->dash_dur.num, ds->dash_dur.den, ds->timescale);\n\tds->est_first_cts_in_next_seg = ds->first_cts_in_next_seg;\n}\n\n\n\nstatic GF_Err dasher_process(GF_Filter *filter)\n{\n\tu32 i, count, nb_init, has_init, nb_reg_done;\n\tGF_DasherCtx *ctx = gf_filter_get_udta(filter);\n\tGF_Err e;\n\tBool seg_done = GF_FALSE;\n\tu32 nb_seg_waiting = 0;\n\tu32 nb_seg_active = 0;\n\n\tif (ctx->in_error) {\n\t\tgf_filter_abort(filter);\n\t\treturn GF_SERVICE_ERROR;\n\t}\n\tif (!ctx->utc_initialized) {\n\t\tdasher_init_utc(filter, ctx);\n\t\tif (!ctx->utc_initialized) return GF_OK;\n\t}\n\n\t//session regulation is on and we have a an MPD (setup done) and a next time (first seg processed)\n\t//check if we have reached the next time\n\tif (ctx->sreg && !ctx->state && ctx->mpd && ctx->mpd->gpac_next_ntp_ms) {\n\t\ts64 diff = (s64) ctx->mpd->gpac_next_ntp_ms;\n\t\tdiff -= (s64) gf_net_get_ntp_ms();\n\t\tif (diff>100) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[Dasher] Next generation scheduled in %d ms, nothing to do\\n\", diff));\n\t\t\tgf_filter_ask_rt_reschedule(filter, (u32) (diff*1000));\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\t//streams in period are not all ready, wait for them\n\tif (ctx->period_not_ready) {\n\t\tBool is_eos;\n\t\t//potpone until no pending connections, otherwise we may add input streams in the wrong period\n\t\tif (gf_filter_connections_pending(filter))\n\t\t\treturn GF_OK;\n\n\t\tis_eos = gf_filter_end_of_session(filter);\n\t\tif (! dasher_check_period_ready(ctx, is_eos)) {\n\t\t\treturn is_eos ? GF_SERVICE_ERROR : GF_OK;\n\t\t}\n\t\te = dasher_setup_period(filter, ctx, NULL);\n\t\tif (e) return e;\n\t}\n\tif (ctx->check_connections) {\n\t\tif (gf_filter_connections_pending(filter))\n\t\t\treturn GF_OK;\n\t\tctx->check_connections = GF_FALSE;\n\t}\n\n\tif (ctx->is_eos)\n\t\treturn GF_EOS;\n\tif (ctx->setup_failure) return ctx->setup_failure;\n\n\tcount = gf_list_count(ctx->current_period->streams);\n\tif (!ctx->min_cts_period.den) {\n\t\tu64 min_ts=0, min_timescale = 0;\n\t\tu32 num_ready=0, num_blocked=0;\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\t\tif (ctx->force_period_switch) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tGF_FilterPacket *pck = gf_filter_pid_get_packet(ds->ipid);\n\t\t\tif (!pck) continue;\n\t\t\tu64 ts = gf_filter_pck_get_cts(pck);\n\t\t\t//only adjust if delay is negative (skip), otherwise (delay) keep mints as is.\n\t\t\t//Not doing so will set the rep PTO to the delay, canceling the delay ...\n\t\t\tif (ds->pts_minus_cts<0)\n\t\t\t\tts = ts + ds->pts_minus_cts;\n\t\t\tif (!min_ts || gf_timestamp_less(ts, ds->timescale, min_ts, min_timescale)) {\n\t\t\t\tmin_ts = ts;\n\t\t\t\tmin_timescale = ds->timescale;\n\t\t\t}\n\t\t\tnum_ready++;\n\t\t\tif (gf_filter_pid_would_block(ds->ipid)) num_blocked++;\n\t\t}\n\t\tif (count) {\n\t\t\tif (num_ready < num_blocked) return GF_OK;\n\t\t}\n\t\tctx->min_cts_period.num = min_ts;\n\t\tctx->min_cts_period.den = min_timescale;\n\n\t\tif (ctx->force_period_switch)\n\t\t\tcount = gf_list_count(ctx->current_period->streams);\n\t}\n\n\tnb_init = has_init = nb_reg_done = 0;\n\n\tfor (i=0; i<count; i++) {\n\t\tGF_DashStream *base_ds;\n\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\tassert(ds);\n\t\tif (ds->done) continue;\n\t\tbase_ds = ds->muxed_base ? ds->muxed_base : ds;\n\t\t//subdur mode abort, don't process\n\t\tif (ds->subdur_done) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (ds->seg_done) continue;\n\n\t\tif (ctx->dmode == GF_MPD_TYPE_DYNAMIC_LAST) {\n\t\t\tif (!ds->done && ds->opid) gf_filter_pid_set_eos(ds->opid);\n\t\t\tds->done = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t//flush as much as possible\n\t\twhile (1) {\n\t\t\tu32 sap_type, dur, o_dur, split_dur;\n\t\t\ts32 check_dur;\n\t\t\tu64 cts, orig_cts, dts, split_dur_next, pcont_cts;\n\t\t\tBool seg_over = GF_FALSE;\n\t\t\tBool is_packet_split = GF_FALSE;\n\t\t\tBool is_queue_flush = GF_FALSE;\n\t\t\tGF_FilterPacket *dst;\n\t\t\tGF_FilterPacket *pck = NULL;\n\n\t\t\tif (!ds->request_period_switch) {\n\t\t\t\tassert(ds->period == ctx->current_period);\n\t\t\t\tpck = gf_filter_pid_get_packet(ds->ipid);\n\t\t\t\t//we may change period after a packet fetch (reconfigure of input pid)\n\t\t\t\tif ((ds->period != ctx->current_period) || ds->request_period_switch) {\n\t\t\t\t\t//in closest mode, flush queue\n\t\t\t\t\tif (!ds->sbound || !gf_list_count(ds->packet_queue)) {\n\t\t\t\t\t\tassert(gf_list_find(ctx->current_period->streams, ds)<0);\n\t\t\t\t\t\tcount = gf_list_count(ctx->current_period->streams);\n\t\t\t\t\t\ti--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tis_queue_flush = GF_TRUE;\n\t\t\t\t}\n\n\t\t\t\t/*text streams, insert an empty segment if we are one segment behind last produced segment on other pids\n\t\t\t\t- we don't generate if behind this last time in case a next packet comes in\n\t\t\t\t- we only insert an empty segment if PID is done (eos) or if we generate for real-time\n\n\t\t\t\tWe cannot apply this in non real-time before end of stream, as we would end up starting a segment while next packet could be in the past (previous seg)\n\n\t\t\t\tTODO: extend this to send empty segments for other streams (audio, video) in case of signal loss ??\n\t\t\t\t*/\n\t\t\t\tif (!pck\n\t\t\t\t\t&& (ds->stream_type==GF_STREAM_TEXT)\n\t\t\t\t\t&& !ds->muxed_base\n\t\t\t\t\t&& (gf_filter_pid_is_eos(ds->ipid) || (ctx->dmode==GF_MPD_TYPE_DYNAMIC))\n\t\t\t\t) {\n\t\t\t\t\tu64 ddur_ms = (1000*ds->dash_dur.num)/ds->dash_dur.den;\n\t\t\t\t\twhile (ds->last_min_segment_start_time + ddur_ms < ctx->last_min_segment_start_time) {\n\t\t\t\t\t\tdasher_send_empty_segment(ctx, ds);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tis_queue_flush = GF_TRUE;\n\t\t\t}\n\t\t\tif (ds->sbound && pck && gf_filter_pck_is_blocking_ref(pck)) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Cannot use `sbound` with blocking input packet references, disabling packet buffering for PID %s\\n\", gf_filter_pid_get_name(ds->ipid) ));\n\t\t\t\tds->sbound = DASHER_BOUNDS_OUT;\n\t\t\t}\n\n\t\t\t//skipped merged tile base\n\t\t\tif (ds->merged_tile_dep) {\n\t\t\t\tif (pck) gf_filter_pid_drop_packet(ds->ipid);\n\t\t\t\tpck = NULL;\n\t\t\t}\n\t\t\t//queue mode\n\t\t\telse if (ds->sbound) {\n\t\t\t\tif (!is_queue_flush && pck) {\n\t\t\t\t\tgf_filter_pck_ref(&pck);\n\t\t\t\t\tgf_filter_pid_drop_packet(ds->ipid);\n\t\t\t\t\tgf_list_add(ds->packet_queue, pck);\n\t\t\t\t\tif (gf_filter_pck_get_sap(pck))\n\t\t\t\t\t\tds->nb_sap_in_queue ++;\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\t//we are flushing due to period switch\n\t\t\t\t\tis_queue_flush\n\t\t\t\t\t//we are flushing due to end of stream\n\t\t\t\t\t|| gf_filter_pid_is_eos(ds->ipid) || ds->clamp_done\n\t\t\t\t) {\n\t\t\t\t\tpck = gf_list_get(ds->packet_queue, 0);\n\t\t\t\t\tis_queue_flush = GF_TRUE;\n\t\t\t\t} else if (\n\t\t\t\t\t//if current segment is not started, always get packet from queue\n\t\t\t\t\t!ds->segment_started\n\t\t\t\t\t//wait until we have more than 2 saps to get packet from queue, to check if next sap will be closer or not\n\t\t\t\t\t|| (ds->nb_sap_in_queue>=2)\n\t\t\t\t) {\n\t\t\t\t\tpck = gf_list_get(ds->packet_queue, 0);\n\t\t\t\t} else {\n\t\t\t\t\tpck = NULL;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tif (!pck) {\n\t\t\t\tBool ds_is_done=GF_FALSE;\n\t\t\t\tif (ds->request_period_switch) {\n\t\t\t\t\te = dasher_stream_period_changed(filter, ctx, ds, (ds->request_period_switch==2) ? GF_TRUE : GF_FALSE);\n\t\t\t\t\tif (e < 0) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Period switch request failed.\\n\"));\n\t\t\t\t\t\ti--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tassert(gf_list_find(ctx->current_period->streams, ds)<0);\n\t\t\t\t\tcount = gf_list_count(ctx->current_period->streams);\n\t\t\t\t\ti--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (ds->clamp_done) ds_is_done=GF_TRUE;\n\t\t\t\telse if (gf_filter_pid_is_eos(ds->ipid)) {\n\t\t\t\t\tif (gf_filter_pid_is_flush_eos(ds->ipid)) {\n\t\t\t\t\t\tif (ds->segment_started && !ds->seg_done) {\n\t\t\t\t\t\t\tds->seg_done = GF_TRUE;\n\t\t\t\t\t\t\tds->first_cts_in_next_seg = ds->est_first_cts_in_next_seg;\n\t\t\t\t\t\t\tds->est_first_cts_in_next_seg = 0;\n\t\t\t\t\t\t\tassert(base_ds->nb_comp_done < base_ds->nb_comp);\n\t\t\t\t\t\t\tbase_ds->nb_comp_done ++;\n\t\t\t\t\t\t\tif (base_ds->nb_comp_done == base_ds->nb_comp) {\n\t\t\t\t\t\t\t\tdasher_flush_segment(ctx, base_ds, GF_FALSE);\n\t\t\t\t\t\t\t\tdasher_inject_eods(ctx, base_ds, GF_TRUE);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n \t\t\t\t\t} else {\n\t\t\t\t\t\tds_is_done=GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ds_is_done) {\n\t\t\t\t\tu32 ds_done = 1;\n\n\t\t\t\t\tif (!ds->clamp_done && !ds->muxed_base && (ds->stream_type==GF_STREAM_TEXT)) {\n\t\t\t\t\t\tu32 s_idx;\n\t\t\t\t\t\tu64 ddur_ms;\n\t\t\t\t\t\tBool over = GF_TRUE;\n\t\t\t\t\t\tfor (s_idx=0; s_idx<count; s_idx++) {\n\t\t\t\t\t\t\tGF_DashStream *a_ds = gf_list_get(ctx->current_period->streams, s_idx);\n\t\t\t\t\t\t\tif (a_ds == ds) continue;\n\t\t\t\t\t\t\tif (a_ds->stream_type==GF_STREAM_TEXT) continue;\n\t\t\t\t\t\t\tif (!a_ds->done) {\n\t\t\t\t\t\t\t\tover = GF_FALSE;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!over)\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t//text streams, insert empty segments if we are one segment behind (and including) last produced segment on other pids\n\t\t\t\t\t\tddur_ms = (1000*ds->dash_dur.num)/ds->dash_dur.den;\n\t\t\t\t\t\twhile (ds->last_min_segment_start_time + ddur_ms <= ctx->min_segment_start_time) {\n\t\t\t\t\t\t\tdasher_send_empty_segment(ctx, ds);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\n\t\t\t\t\tif (ctx->loop && dasher_check_loop(ctx, ds)) {\n\t\t\t\t\t\tif (ctx->subdur)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t//loop on the entire source, consider the stream not done for segment flush\n\t\t\t\t\t\tds_done = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tds->clamp_done = GF_FALSE;\n\n\t\t\t\t\tctx->update_report = -1;\n\t\t\t\t\t//opid may be NULL for skipped tile rep\n\t\t\t\t\tif (!ctx->sigfrag && ds->opid)\n\t\t\t\t\t\tgf_filter_pid_set_eos(ds->opid);\n\n\t\t\t\t\tif (!ds->done) ds->done = ds_done;\n\t\t\t\t\tds->seg_done = GF_TRUE;\n\t\t\t\t\tseg_done = GF_TRUE;\n\t\t\t\t\tds->first_cts_in_next_seg = ds->est_first_cts_in_next_seg;\n\t\t\t\t\tds->est_first_cts_in_next_seg = 0;\n\t\t\t\t\tassert(base_ds->nb_comp_done < base_ds->nb_comp);\n\t\t\t\t\tbase_ds->nb_comp_done ++;\n\t\t\t\t\tif (base_ds->nb_comp_done == base_ds->nb_comp) {\n\t\t\t\t\t\tdasher_flush_segment(ctx, base_ds, GF_FALSE);\n\t\t\t\t\t}\n\t\t\t\t\t//loop on the entire source, mark as done for subdur and check if all other streams are done\n\t\t\t\t\tif (!ds->done) {\n\t\t\t\t\t\tu32 j;\n\t\t\t\t\t\tds->done = 2;\n\t\t\t\t\t\tds->subdur_done = GF_TRUE;\n\t\t\t\t\t\tu32 nb_sub_done=0;\n\t\t\t\t\t\tfor (j=0; j<count; j++) {\n\t\t\t\t\t\t\tGF_DashStream *a_ds = gf_list_get(ctx->current_period->streams, j);\n\t\t\t\t\t\t\tif (a_ds->muxed_base) a_ds = a_ds->muxed_base;\n\t\t\t\t\t\t\tif (a_ds->subdur_done) {\n\t\t\t\t\t\t\t\tnb_sub_done++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (nb_sub_done==count)\n\t\t\t\t\t\t\tctx->subdur_done = GF_TRUE;\n\t\t\t\t\t} else if (ctx->reschedule && !ctx->loop && (ctx->dmode==GF_MPD_TYPE_DYNAMIC) && !strcmp(ds->period_id, DEFAULT_PERIOD_ID) ) {\n\t\t\t\t\t\tif (gf_list_find(ctx->next_period->streams, ds)<0) {\n\t\t\t\t\t\t\tgf_list_add(ctx->next_period->streams, ds);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tctx->post_play_events = GF_TRUE;\n\t\t\t\t\t\tds->nb_repeat++;\n\t\t\t\t\t\tds->reschedule = GF_TRUE;\n\t\t\t\t\t\tgf_filter_pid_discard_block(ds->opid);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//no packet, muxed rep and base DS done, flush - required if no packet is present for the segment\n\t\t\t\t//typically for subs\n\t\t\t\telse if (ds->muxed_base && base_ds->seg_done && !ds->seg_done && !ds->is_av) {\n\t\t\t\t\tds->seg_done = GF_TRUE;\n\t\t\t\t\tds->first_cts_in_next_seg = ds->est_first_cts_in_next_seg;\n\t\t\t\t\tds->est_first_cts_in_next_seg = 0;\n\t\t\t\t\tassert(base_ds->nb_comp_done < base_ds->nb_comp);\n\t\t\t\t\tbase_ds->nb_comp_done ++;\n\t\t\t\t\tif (base_ds->nb_comp_done == base_ds->nb_comp) {\n\t\t\t\t\t\tdasher_flush_segment(ctx, base_ds, GF_FALSE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ds->seek_to_pck) {\n\t\t\t\tu32 sn = gf_filter_pck_get_seq_num(pck);\n\t\t\t\tif (sn) {\n\t\t\t\t\tif (sn <= ds->seek_to_pck) {\n\t\t\t\t\t\tdasher_drop_input(ctx, ds, GF_FALSE);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tds->nb_pck = sn-1;\n\t\t\t\t} else {\n\t\t\t\t\t//no sn signaled, this implies we played from the beginning\n\t\t\t\t\tif (ds->nb_pck < ds->seek_to_pck) {\n\t\t\t\t\t\tds->nb_pck ++;\n\t\t\t\t\t\tdasher_drop_input(ctx, ds, GF_FALSE);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsap_type = gf_filter_pck_get_sap(pck);\n\t\t\tds->loop_state = 0;\n\n\t\t\tcts = gf_filter_pck_get_cts(pck);\n\t\t\tdts = gf_filter_pck_get_dts(pck);\n\t\t\tif (dts==GF_FILTER_NO_TS) dts = cts;\n\n\t\t\tif (!sap_type && (ds->sync_points_type != DASHER_SYNC_PRESENT)) {\n\t\t\t\tds->sync_points_type = DASHER_SYNC_PRESENT;\n\t\t\t\t//cf setup_period: in sbound=0 mode, if stream has sync and non-sync and uses skip samples, allow spliting\n\t\t\t\t//slightly before - typically needed for audio with sync points (usac, mpegh) where the segment duration is set\n\t\t\t\t//to the intra interval, we need to take into account the skip samples\n\t\t\t\tif (!ctx->sbound && !ds->cues\n\t\t\t\t\t&& (ds->pts_minus_cts<0) && (ds->next_seg_start> (u32) -ds->pts_minus_cts)\n\t\t\t\t) {\n\t\t\t\t\tds->next_seg_start -= (u32) -ds->pts_minus_cts;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((ctx->strict_sap==DASHER_SAP_INTRA_ONLY) && (sap_type>=4))\n\t\t\t\tsap_type = 0;\n\n\t\t\tpcont_cts = cts;\n\n\t\t\tif (!ds->rep_init) {\n\t\t\t\tu32 set_start_with_sap;\n\t\t\t\t//for video, resync on sap 1 or 2 if not full profile\n\t\t\t\tif ((ds->stream_type==GF_STREAM_VISUAL) && (ctx->profile != GF_DASH_PROFILE_FULL)) {\n\t\t\t\t\tif ((sap_type!=GF_FILTER_SAP_1) && (sap_type!=GF_FILTER_SAP_2))\n\t\t\t\t\t\tsap_type = 0;\n\t\t\t\t}\n\t\t\t\tif (!sap_type) {\n\t\t\t\t\t//remember our timing\n\t\t\t\t\tif (!ds->presentation_time_offset)\n\t\t\t\t\t\tds->presentation_time_offset = cts + 1;\n\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Representation not initialized, dropping non-SAP1/2 packet CTS \"LLU\"/%d\\n\", cts, ds->timescale));\n\t\t\t\t\tdasher_drop_input(ctx, ds, GF_FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tset_start_with_sap = ctx->sseg ? base_ds->set->subsegment_starts_with_sap : base_ds->set->starts_with_sap;\n\t\t\t\tif (!ds->muxed_base) {\n\t\t\t\t\tu64 check_ts;\n\t\t\t\t\t//force sap type to 1 for non-visual streams if strict_sap is set to off\n\t\t\t\t\tif ((ds->stream_type!=GF_STREAM_VISUAL) && (ctx->strict_sap==DASHER_SAP_OFF) ) {\n\t\t\t\t\t\tswitch (ds->codec_id) {\n\t\t\t\t\t\t//MPEG-H requires saps\n\t\t\t\t\t\tcase GF_CODECID_MPHA:\n\t\t\t\t\t\tcase GF_CODECID_MHAS:\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tsap_type = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//set AS sap type\n\t\t\t\t\tif (!set_start_with_sap) {\n\t\t\t\t\t\t//don't set SAP type if not a base rep - could be further checked\n\t\t\t\t\t\t//if (!gf_list_count(ds->complementary_streams) )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (ctx->sseg) {\n\t\t\t\t\t\t\t\tds->set->subsegment_starts_with_sap = sap_type;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tds->set->starts_with_sap = sap_type;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (set_start_with_sap != sap_type) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Segments do not start with the same SAP types: set initialized with %d but first packet got %d - bitstream will not be compliant\\n\", set_start_with_sap, sap_type));\n\t\t\t\t\t}\n\n\t\t\t\t\tcheck_ts = cts;\n\t\t\t\t\t//in case we droped frames\n\t\t\t\t\tif (ds->presentation_time_offset)\n\t\t\t\t\t\tcheck_ts = ds->presentation_time_offset - 1;\n\t\t\t\t\tds->presentation_time_offset = 0;\n\t\t\t\t\t//The code below assumes that the first frame in the stream has a presentation time of 0\n\t\t\t\t\tif ((s64) check_ts + ds->pts_minus_cts > 0) {\n\t\t\t\t\t\tu64 pto = check_ts + ds->pts_minus_cts;\n\t\t\t\t\t\tu64 pto_adj = pto;\n\t\t\t\t\t\tif (ds->timescale != ds->mpd_timescale) {\n\t\t\t\t\t\t\tpto_adj = gf_timestamp_rescale(pto_adj, ds->timescale, ds->mpd_timescale);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ctx->min_cts_period.den) {\n\t\t\t\t\t\t\tu64 diff = gf_timestamp_rescale(ctx->min_cts_period.num, ctx->min_cts_period.den, ds->mpd_timescale);\n\t\t\t\t\t\t\tpto_adj = diff;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (ds->rep->segment_list)\n\t\t\t\t\t\t\tds->rep->segment_list->presentation_time_offset = pto_adj;\n\t\t\t\t\t\telse if (ds->rep->segment_template)\n\t\t\t\t\t\t\tds->rep->segment_template->presentation_time_offset = pto_adj;\n\t\t\t\t\t\telse if (ds->set->segment_template)\n\t\t\t\t\t\t\tds->set->segment_template->presentation_time_offset = pto_adj;\n\t\t\t\t\t\telse if (ds->set->segment_list)\n\t\t\t\t\t\t\tds->set->segment_list->presentation_time_offset = pto_adj;\n\t\t\t\t\t\telse if (ds->rep->segment_base) {\n\t\t\t\t\t\t\tds->rep->segment_base->presentation_time_offset = pto_adj;\n\t\t\t\t\t\t\tds->rep->segment_base->timescale = ds->mpd_timescale;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tds->presentation_time_offset = pto;\n\t\t\t\t\t}\n\t\t\t\t\t//period continuity, skip priming in new periods\n\t\t\t\t\tif (ds->period_continuity_id)\n\t\t\t\t\t\tds->pts_minus_cts = 0;\n\t\t\t\t}\n\n\t\t\t\tds->first_cts = cts;\n\t\t\t\tds->first_dts = dts;\n\t\t\t\tif (ctx->do_index) {\n\t\t\t\t\tds->rep->segment_list->first_cts_offset = (s32) ((s64) ds->first_cts - (s64) ds->first_dts);\n\t\t\t\t}\n\t\t\t\tds->rep_init++;\n\t\t\t\thas_init++;\n\t\t\t}\n\n\t\t\tnb_init++;\n\n\t\t\tif (ds->ts_offset) {\n\t\t\t\tcts += ds->ts_offset;\n\t\t\t\tdts += ds->ts_offset;\n\t\t\t}\n\n\t\t\t//ready to write MPD for the first time in dynamic mode with template\n\t\t\tif (has_init && (nb_init==count) && (ctx->dmode==GF_MPD_TYPE_DYNAMIC) && ctx->tpl && ctx->do_mpd && !ctx->dyn_rate) {\n\t\t\t\te = dasher_send_manifest(filter, ctx, GF_TRUE);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\n\t\t\tcts = dasher_translate_cts(ds, cts);\n\t\t\tdts -= ds->first_dts;\n\n\t\t\tif (ctx->sreg && ctx->mpd->gpac_mpd_time && gf_timestamp_greater(dts, ds->timescale, ctx->mpd->gpac_mpd_time, 1000)) {\n\t\t\t\tnb_reg_done++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdur = o_dur = gf_filter_pck_get_duration(pck);\n\t\t\tpcont_cts += dur;\n\t\t\tif (ds->period_continuity_next_cts < pcont_cts)\n\t\t\t\tds->period_continuity_next_cts = pcont_cts;\n\n\t\t\tsplit_dur = 0;\n\t\t\tsplit_dur_next = 0;\n\n\t\t\t//patch to align old arch with new\n\t\t\tcheck_dur = 0;\n\t\t\tif (ds->stream_type==GF_STREAM_AUDIO)\n\t\t\t\tcheck_dur = dur;\n\n\t\t\t//perform regulation of inputs to avoid dashing one stream faster than the others\n\t\t\t//this is needed when inputs are not realtime and we have text streams for which we must decide\n\t\t\t//if we insert empty segments\n\t\t\tif (!base_ds->segment_started && ctx->min_segment_start_time) {\n\t\t\t\torig_cts = cts;\n\t\t\t\tif (ds->split_dur_next)\n\t\t\t\t\tcts += ds->split_dur_next;\n\n\t\t\t\tif (gf_timestamp_greater(cts, ds->timescale, ctx->min_segment_start_time, 1000)) {\n\t\t\t\t\tnb_seg_waiting++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcts = orig_cts;\n\t\t\t}\n\t\t\tnb_seg_active++;\n\n\t\t\t//adjust duration and cts\n\t\t\torig_cts = cts;\n\t\t\tif (ds->split_dur_next) {\n\t\t\t\tcts += ds->split_dur_next;\n\t\t\t\tassert(dur > ds->split_dur_next);\n\t\t\t\tdur -= ds->split_dur_next;\n\t\t\t\tsplit_dur_next = ds->split_dur_next;\n\t\t\t\tds->split_dur_next = 0;\n\t\t\t\tis_packet_split = GF_TRUE;\n\t\t\t}\n\n\t\t\tif (ds->splitable && !ds->split_dur_next && !ds->cues && !ds->inband_cues) {\n\t\t\t\tBool do_split = GF_FALSE;\n\t\t\t\t//adding this sample would exceed the segment duration\n\t\t\t\tif (gf_sys_old_arch_compat()) {\n\t\t\t\t\tif (gf_timestamp_greater_or_equal(cts + dur, ds->timescale, base_ds->adjusted_next_seg_start, base_ds->timescale))\n\t\t\t\t\t\tdo_split = GF_TRUE;\n\t\t\t\t} else {\n\t\t\t\t\tif ( gf_timestamp_greater(cts + dur, ds->timescale, base_ds->adjusted_next_seg_start, base_ds->timescale))\n\t\t\t\t\t\tdo_split = GF_TRUE;\n\t\t\t\t}\n\t\t\t\tif (do_split) {\n\t\t\t\t\t//this sample starts in the current segment - split it\n\t\t\t\t\tif (gf_timestamp_less(cts, ds->timescale, base_ds->adjusted_next_seg_start, base_ds->timescale) ) {\n\t\t\t\t\t\tsplit_dur = (u32) (gf_timestamp_rescale(base_ds->adjusted_next_seg_start, base_ds->timescale, ds->timescale) - ds->last_cts);\n\n\t\t\t\t\t\tif (gf_sys_old_arch_compat() && (split_dur==dur))\n\t\t\t\t\t\t\tsplit_dur=0;\n\n\t\t\t\t\t\tif (split_dur>=dur)\n\t\t\t\t\t\t\tsplit_dur=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//mux rep, wait for a CTS more than our base if base not yet over\n\t\t\tif ((base_ds != ds) && !base_ds->seg_done && gf_timestamp_greater(cts, ds->timescale, base_ds->last_cts, base_ds->timescale) )\n\t\t\t\tbreak;\n\n\t\t\tif (ds->seek_to_pck) {\n\t\t\t\tds->seek_to_pck = 0;\n\t\t\t}\n\t\t\t//base rep has been forced to another period, we switch asap\n\t\t\telse if (base_ds->forced_period_switch) {\n\t\t\t\tds->seg_done = GF_TRUE;\n\t\t\t\tdasher_inject_eods(ctx, ds, GF_FALSE);\n\t\t\t\tseg_done = GF_TRUE;\n\t\t\t\tdasher_stream_period_changed(filter, ctx, ds, GF_FALSE);\n\t\t\t\ti--;\n\t\t\t\tcount--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//force flush mode, segment is done upon eos\n\t\t\telse if (ctx->force_flush) {\n\t\t\t}\n\t\t\t//source-driven fragmentation check for segment start\n\t\t\telse if (ctx->sigfrag) {\n\t\t\t\tconst GF_PropertyValue *p = gf_filter_pck_get_property(pck, GF_PROP_PCK_FRAG_START);\n\t\t\t\tif (p && (p->value.uint>=1) && base_ds->segment_started) {\n\t\t\t\t\tseg_over = GF_TRUE;\n\t\t\t\t\tif (ds == base_ds) {\n\t\t\t\t\t\tbase_ds->adjusted_next_seg_start = cts;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//inband-cue based segmentation\n\t\t\telse if (ds->inband_cues) {\n\t\t\t\tconst GF_PropertyValue *p = gf_filter_pck_get_property(pck, GF_PROP_PCK_CUE_START);\n\t\t\t\tif (p && p->value.boolean) {\n\t\t\t\t\tu32 size;\n\t\t\t\t\tgf_filter_pck_get_data(pck, &size);\n\t\t\t\t\tif (base_ds->segment_started) {\n\t\t\t\t\t\tseg_over = GF_TRUE;\n\t\t\t\t\t\tif (ds == base_ds) {\n\t\t\t\t\t\t\tbase_ds->adjusted_next_seg_start = cts;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//packet with no size, used by GHI demuxer:\n\t\t\t\t\t//- if seek flag is set, this is a dummy packet sent to generate segment timeline / child HLS\n\t\t\t\t\t//- if seek flag is not set, this is an empty segment for sparse streams\n\t\t\t\t\telse if (!size) {\n\t\t\t\t\t\tif (!gf_filter_pck_get_seek_flag(pck) ) {\n\t\t\t\t\t\t\tds->first_cts_in_seg = gf_filter_pck_get_cts(pck);\n\t\t\t\t\t\t\tdasher_send_empty_segment(ctx, ds);\n\t\t\t\t\t\t\tdasher_drop_input(ctx, ds, GF_TRUE);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_SPLIT_START);\n\t\t\t\t\tif (p) {\n\t\t\t\t\t\tcts += p->value.uint;\n\t\t\t\t\t\tassert(dur > p->value.uint);\n\t\t\t\t\t\tdur -= p->value.uint;\n\t\t\t\t\t\tsplit_dur_next = p->value.uint;\n\t\t\t\t\t\tds->split_dur_next = 0;\n\t\t\t\t\t\tis_packet_split = GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_SPLIT_END);\n\t\t\t\tif (p) {\n\t\t\t\t\tassert(dur > p->value.uint);\n\t\t\t\t\tdur -= p->value.uint;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cue-list based segmentation\n\t\t\telse if (ds->cues) {\n\t\t\t\tu32 cidx;\n\t\t\t\tGF_DASHCueInfo *cue=NULL;\n\t\t\t\tBool is_cue_split = GF_FALSE;\n\t\t\t\ts32 has_mismatch = -1;\n\n\t\t\t\tfor (cidx=0;cidx<ds->nb_cues; cidx++) {\n\t\t\t\t\tcue = &ds->cues[cidx];\n\t\t\t\t\tif (cue->sample_num) {\n\t\t\t\t\t\tif (cue->sample_num == ds->nb_pck + 1) {\n\t\t\t\t\t\t\tis_cue_split = GF_TRUE;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (cue->sample_num < ds->nb_pck) {\n\t\t\t\t\t\t\thas_mismatch = cidx;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (cue->dts) {\n\t\t\t\t\t\tu64 ts = (cue->dts - ds->cues_ts_offset) * ds->timescale;\n\t\t\t\t\t\tu64 ts2 = dts * ds->cues_timescale;\n\t\t\t\t\t\tif (ts == ts2) {\n\t\t\t\t\t\t\tis_cue_split = GF_TRUE;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (ts < ts2) {\n\t\t\t\t\t\t\thas_mismatch = cidx;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (cue->cts) {\n\t\t\t\t\t\ts64 ts = (cue->cts - ds->cues_ts_offset) * ds->timescale;\n\t\t\t\t\t\ts64 ts2 = (cts + ds->first_cts) * ds->cues_timescale;\n\n\t\t\t\t\t\t//cues are given in track timeline (presentation time), subtract the media time to pres time offset\n\t\t\t\t\t\tif (ds->cues_use_edits) {\n\t\t\t\t\t\t\tts2 += (s64) (ds->pts_minus_cts) * ds->cues_timescale;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ts == ts2) {\n\t\t\t\t\t\t\tis_cue_split = GF_TRUE;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (ts < ts2) {\n\t\t\t\t\t\t\thas_mismatch = cidx;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//start of first segment\n\t\t\t\tif (is_cue_split && !ds->segment_started) {\n\t\t\t\t\tmemmove(ds->cues, &ds->cues[cidx+1], (ds->nb_cues-cidx-1) * sizeof(GF_DASHCueInfo));\n\t\t\t\t\tds->nb_cues -= cidx+1;\n\t\t\t\t\tis_cue_split = 0;\n\t\t\t\t}\n\n\t\t\t\tif (is_cue_split) {\n\t\t\t\t\tif (!sap_type) {\n\t\t\t\t\t\tGF_LOG(ctx->strict_cues ?  GF_LOG_ERROR : GF_LOG_WARNING, GF_LOG_DASH, (\"[DASH] cue found (sn %d - dts \"LLD\" - cts \"LLD\") for PID %s but packet %d is not RAP !\\n\", cue->sample_num, cue->dts, cue->cts, gf_filter_pid_get_name(ds->ipid), ds->nb_pck));\n\t\t\t\t\t\tif (ctx->strict_cues) {\n\t\t\t\t\t\t\tgf_filter_pid_drop_packet(ds->ipid);\n\t\t\t\t\t\t\tgf_filter_pid_set_discard(ds->ipid, GF_TRUE);\n\t\t\t\t\t\t\treturn GF_BAD_PARAM;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmemmove(ds->cues, &ds->cues[cidx+1], (ds->nb_cues-cidx-1) * sizeof(GF_DASHCueInfo));\n\t\t\t\t\tds->nb_cues -= cidx+1;\n\n\t\t\t\t\tif (sap_type==3)\n\t\t\t\t\t\tds->nb_sap_3 ++;\n\t\t\t\t\telse if (sap_type>3)\n\t\t\t\t\t\tds->nb_sap_4 ++;\n\n\t\t\t\t\t/*check requested profiles can be generated, or adjust them*/\n\t\t\t\t\tif (\n\t\t\t\t\t\t(ds->nb_sap_4 || (ds->nb_sap_3 > 1))\n\t\t\t\t\t\t&& (ctx->profile != GF_DASH_PROFILE_FULL)\n\t\t\t\t\t\t/*TODO: store at DS level whether the usage of sap4 is ok or not (eg roll info for AAC is OK, not for xHEAAC-v2)\n\t\t\t\t\t\tfor now we only complain for video*/\n\t\t\t\t\t\t&& ((ds->stream_type==GF_STREAM_VISUAL) || (ctx->strict_sap==DASHER_SAP_ON) )\n\t\t\t\t\t) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] WARNING! Max SAP type %d detected - switching to FULL profile\\n\", ds->nb_sap_4 ? 4 : 3));\n\t\t\t\t\t\tctx->profile = GF_DASH_PROFILE_FULL;\n\t\t\t\t\t\tif (ctx->sseg)\n\t\t\t\t\t\t\tds->set->subsegment_starts_with_sap = sap_type;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tds->set->starts_with_sap = sap_type;\n\t\t\t\t\t}\n\n\n\t\t\t\t\tseg_over = GF_TRUE;\n\t\t\t\t\tif (ds == base_ds) {\n\t\t\t\t\t\tbase_ds->adjusted_next_seg_start = cts;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (has_mismatch>=0) {\n\t\t\t\t\tcue = &ds->cues[has_mismatch];\n\t\t\t\t\tGF_LOG(ctx->strict_cues ?  GF_LOG_ERROR : GF_LOG_WARNING, GF_LOG_DASH, (\"[DASH] found cue (sn %d - dts \"LLD\" - cts \"LLD\") in stream %s before current packet (sn %d - dts \"LLD\" - cts \"LLD\") , buggy source cues ?\\n\", cue->sample_num, cue->dts, cue->cts, gf_filter_pid_get_name(ds->ipid), ds->nb_pck+1, dts + ds->first_cts, cts + ds->first_cts));\n\t\t\t\t\tif (ctx->strict_cues) {\n\t\t\t\t\t\tgf_filter_pid_drop_packet(ds->ipid);\n\t\t\t\t\t\tgf_filter_pid_set_discard(ds->ipid, GF_TRUE);\n\t\t\t\t\t\treturn GF_BAD_PARAM;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//forcing max time\n\t\t\telse if (\n\t\t\t\t(base_ds->force_rep_end && gf_timestamp_greater_or_equal(cts, ds->timescale, base_ds->force_rep_end, base_ds->timescale) )\n\t\t\t\t|| (base_ds->clamped_dur.num && (cts + o_dur > ds->ts_offset + base_ds->clamped_dur.num * ds->timescale / base_ds->clamped_dur.den))\n\t\t\t) {\n\t\t\t\tif (!base_ds->period->period->duration && base_ds->force_rep_end) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Inputs duration do not match, %s truncated to %g duration\\n\", ds->src_url, ((Double)base_ds->force_rep_end)/base_ds->timescale ));\n\t\t\t\t}\n\t\t\t\tdasher_drop_input(ctx, ds, GF_TRUE);\n\t\t\t\tds->clamp_done = GF_TRUE;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//we have a SAP and we work in closest mode: check the next SAP in the queue, and decide if we\n\t\t\t//split the segment at this SAP or wait for the next one\n\t\t\telse if (ds->segment_started && ds->sbound && sap_type) {\n\t\t\t\tu32 idx, nb_queued, nb_pck = gf_list_count(ds->packet_queue);\n\t\t\t\tnb_queued = nb_pck;\n\t\t\t\tif (is_queue_flush) nb_queued += 1;\n\t\t\t\t\n\t\t\t\tfor (idx=1; idx<nb_queued; idx++) {\n\t\t\t\t\tGF_FilterPacket *next;\n\t\t\t\t\tif (idx==nb_pck) {\n\t\t\t\t\t\tnext = gf_list_last(ds->packet_queue);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnext = gf_list_get(ds->packet_queue, idx);\n\t\t\t\t\t\tu32 sap_next = gf_filter_pck_get_sap(next);\n\t\t\t\t\t\tif (!sap_next) continue;\n\t\t\t\t\t}\n\t\t\t\t\tu32 next_dur = gf_filter_pck_get_duration(next);\n\t\t\t\t\t//compute cts next\n\t\t\t\t\tu64 cts_next = gf_filter_pck_get_cts(next);\n\t\t\t\t\tif (ds->ts_offset) {\n\t\t\t\t\t\tcts_next += ds->ts_offset;\n\t\t\t\t\t}\n\t\t\t\t\tcts_next = dasher_translate_cts(ds, cts_next);\n\n\t\t\t\t\tif ((idx==nb_pck) && ctx->last_seg_merge) {\n\t\t\t\t\t\tu64 next_seg_dur = (cts_next + next_dur - cts);\n\t\t\t\t\t\tif (next_seg_dur * ds->dash_dur.den < (u64) ds->dash_dur.num * ds->timescale / 2)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t//same rule as above\n\t\t\t\t\tif (gf_timestamp_greater_or_equal(cts_next + next_dur, ds->timescale, base_ds->adjusted_next_seg_start, base_ds->timescale)) {\n\t\t\t\t\t\tBool force_seg_flush = GF_FALSE;\n\t\t\t\t\t\ts64 diff_next = gf_timestamp_rescale(cts_next, ds->timescale, base_ds->timescale);\n\t\t\t\t\t\tdiff_next -= base_ds->adjusted_next_seg_start;\n\t\t\t\t\t\t//bounds at closest: if this SAP is closer to the target next segment start than the next SAP, split at this packet\n\t\t\t\t\t\tif (ds->sbound==DASHER_BOUNDS_CLOSEST) {\n\t\t\t\t\t\t\ts64 diff = gf_timestamp_rescale(cts, ds->timescale, base_ds->timescale);\n\t\t\t\t\t\t\tdiff -= base_ds->adjusted_next_seg_start;\n\t\t\t\t\t\t\t//this one may be negative, but we always want diff_next positive (next SAP in next segment)\n\t\t\t\t\t\t\tif (diff<0)\n\t\t\t\t\t\t\t\tdiff = -diff;\n\t\t\t\t\t\t\t//old arch was only using closest for tracks with sync points\n\t\t\t\t\t\t\tif (gf_sys_old_arch_compat() && (base_ds->sync_points_type==DASHER_SYNC_NONE) ) {\n\t\t\t\t\t\t\t\tif (diff_next > 0) {\n\t\t\t\t\t\t\t\t\tforce_seg_flush = GF_TRUE;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (diff<diff_next) {\n\t\t\t\t\t\t\t\tforce_seg_flush = GF_TRUE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//bounds always in: if the next SAP is strictly greater than the target next segment start, split at this packet\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (diff_next > 0) {\n\t\t\t\t\t\t\t\tforce_seg_flush = GF_TRUE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (force_seg_flush) {\n\t\t\t\t\t\t\tseg_over = GF_TRUE;\n\t\t\t\t\t\t\tif (ds == base_ds) {\n\t\t\t\t\t\t\t\tbase_ds->adjusted_next_seg_start = cts;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//we exceed segment duration - if segment was started, check if we need to stop segment\n\t\t\t//if segment was not started we insert the packet anyway\n\t\t\telse if (!ds->sbound && ds->segment_started && gf_timestamp_greater_or_equal(cts + check_dur, ds->timescale, base_ds->adjusted_next_seg_start, base_ds->timescale) ) {\n\n\n\t\t\t\t//we have a base (muxed rep) and it is not yet done, and we exceed estimated next seg start on base\n\t\t\t\t//wait for the base to be done as the next seg estimate may change if next segment duration is quite\n\t\t\t\t//different from requested duration - cf #2488\n\t\t\t\tif ((ds != base_ds) && !base_ds->seg_done) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t//no sap, segment is over\n\t\t\t\tif (! ctx->sap) {\n\t\t\t\t\tseg_over = GF_TRUE;\n\t\t\t\t}\n\t\t\t\telse if ((ds->stream_type==GF_STREAM_AUDIO)\n\t\t\t\t\t&& gf_timestamp_equal(cts + check_dur, ds->timescale, base_ds->adjusted_next_seg_start, base_ds->timescale)\n\t\t\t\t) {\n\n\t\t\t\t}\n\t\t\t\t// sap, segment is over\n\t\t\t\telse if (sap_type) {\n\n\t\t\t\t\tif (sap_type==3)\n\t\t\t\t\t\tds->nb_sap_3 ++;\n\t\t\t\t\telse if (sap_type>3)\n\t\t\t\t\t\tds->nb_sap_4 ++;\n\n\t\t\t\t\t/*check requested profiles can be generated, or adjust them*/\n\t\t\t\t\tif ((ctx->profile != GF_DASH_PROFILE_FULL)\n\t\t\t\t\t\t&& (ds->nb_sap_4 || (ds->nb_sap_3 > 1))\n\t\t\t\t\t\t/*TODO: store at DS level whether the usage of sap4 is ok or not (eg roll info for AAC is OK, not for xHEAAC-v2)\n\t\t\t\t\t\tfor now we only complain for video*/\n\t\t\t\t\t\t&& ((ds->stream_type==GF_STREAM_VISUAL) || (ctx->strict_sap==DASHER_SAP_ON) )\n\t\t\t\t\t) {\n\t\t\t\t\t\tif ((sap_type == GF_FILTER_SAP_3)\n\t\t\t\t\t\t\t&& (ds->codec_id==GF_CODECID_VVC)\n\t\t\t\t\t\t\t&& (ds->inband_params==2)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tif (ds->set->starts_with_sap<3) {\n\t\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Using VVC with SAP type 3 and inband PPS, profile not yet defined\\n\", ds->nb_sap_4 ? 4 : 3));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] WARNING! Max SAP type %d detected - switching to FULL profile\\n\", ds->nb_sap_4 ? 4 : 3));\n\t\t\t\t\t\t\tctx->profile = GF_DASH_PROFILE_FULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ctx->sseg)\n\t\t\t\t\t\t\tds->set->subsegment_starts_with_sap = sap_type;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tds->set->starts_with_sap = sap_type;\n\t\t\t\t\t}\n\n\t\t\t\t\t//if sap2, silently move startWithSAP to 2 if previsouly 0,1 or 2\n\t\t\t\t\tif (sap_type == GF_FILTER_SAP_2) {\n\t\t\t\t\t\tif (ctx->sseg)\n\t\t\t\t\t\t\tds->set->subsegment_starts_with_sap = MAX(ds->set->subsegment_starts_with_sap, sap_type);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tds->set->starts_with_sap = MAX(ds->set->starts_with_sap, sap_type);\n\t\t\t\t\t}\n\n\t\t\t\t\tseg_over = GF_TRUE;\n\t\t\t\t\tif (ds == base_ds) {\n\t\t\t\t\t\tbase_ds->adjusted_next_seg_start = cts;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tif (ds->muxed_base && ds->muxed_base->done) {\n\t\t\t\tseg_over = GF_FALSE;\n\t\t\t}\n\t\t\t//if flushing now will result in a one sample fragment afterwards\n\t\t\t//because this is the before-last sample, don't flush unless:\n\t\t\t//- we have an asto set (low latency)\n\t\t\t//- this is not an audio stream or all samples are SAPs\n\t\t\t//- we use cues\n\t\t\t//- we use strict_sap=intra mode\n\t\t\telse if (seg_over && ds->nb_samples_in_source && !ctx->loop\n\t\t\t\t&& (ds->nb_pck+1 == ds->nb_samples_in_source)\n\t\t\t\t&& !ds->inband_cues && !ds->cues\n\t\t\t\t&& !ctx->asto\n\t\t\t\t&& ! ((ds->sync_points_type==DASHER_SYNC_NONE) && (ds->stream_type!=GF_STREAM_AUDIO))\n\t\t\t\t&& (ctx->strict_sap!=DASHER_SAP_INTRA_ONLY)\n\t\t\t) {\n\t\t\t\tseg_over = GF_FALSE;\n\t\t\t}\n\t\t\t//if dur=0 (some text streams), don't flush segment\n\t\t\tif (seg_over && dur) {\n\t\t\t\tassert(!ds->seg_done);\n\n\t\t\t\tif (ds->request_period_switch && !gf_list_count(ds->packet_queue)) {\n\t\t\t\t\te = dasher_stream_period_changed(filter, ctx, ds, (ds->request_period_switch==2) ? GF_TRUE : GF_FALSE);\n\t\t\t\t\tif (e < 0) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Period switch request failed.\\n\"));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tassert(gf_list_find(ctx->current_period->streams, ds)<0);\n\t\t\t\t\tcount = gf_list_count(ctx->current_period->streams);\n\t\t\t\t\ti--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tds->seg_done = GF_TRUE;\n\t\t\t\tif (split_dur_next && ctx->do_index) {\n\t\t\t\t\tGF_MPD_SegmentURL *s = gf_list_last(ds->rep->segment_list->segment_URLs);\n\t\t\t\t\ts->split_last_dur = dur;\n\t\t\t\t\tassert(gf_filter_pck_get_duration(pck) > dur);\n\t\t\t\t\tds->rep->segment_list->use_split_dur = GF_TRUE;\n\t\t\t\t}\n\n\t\t\t\tdasher_inject_eods(ctx, ds, GF_FALSE);\n\n\t\t\t\tds->first_cts_in_next_seg = cts;\n\t\t\t\tassert(base_ds->nb_comp_done < base_ds->nb_comp);\n\t\t\t\tbase_ds->nb_comp_done ++;\n\n\t\t\t\tif (split_dur_next)\n\t\t\t\t\tds->split_dur_next = (u32) split_dur_next;\n\n\t\t\t\tif (base_ds->nb_comp_done == base_ds->nb_comp) {\n\t\t\t\t\tdasher_flush_segment(ctx, base_ds, GF_FALSE);\n\t\t\t\t\tseg_done = GF_TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (cts==GF_FILTER_NO_TS) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] WARNING! Source packet has no timestamp !\\n\"));\n\n\t\t\t\tcts = ds->last_cts;\n\t\t\t\tdts = ds->last_dts;\n\t\t\t} else {\n\t\t\t\tu64 ncts = cts + (split_dur ? split_dur : dur);\n\t\t\t\tif (ncts>ds->est_first_cts_in_next_seg)\n\t\t\t\t\tds->est_first_cts_in_next_seg = ncts;\n\n\t\t\t\tncts = gf_timestamp_rescale(ncts, ds->timescale, 1000);\n\t\t\t\tif (ncts>base_ds->max_period_dur)\n\t\t\t\t\tbase_ds->max_period_dur = ncts;\n\n\t\t\t\tds->last_cts = cts + (split_dur ? split_dur : dur);\n\t\t\t\tds->last_dts = dts;\n\t\t\t\tds->est_next_dts = dts + o_dur;\n\t\t\t}\n\n\t\t\tif (!is_packet_split)\n\t\t\t\tds->nb_pck ++;\n\n\t\t\tif (!ds->min_cts_in_seg_plus_one)\n\t\t\t\tds->min_cts_in_seg_plus_one = cts+1;\n\t\t\telse if (ds->min_cts_in_seg_plus_one - 1 > cts)\n\t\t\t\tds->min_cts_in_seg_plus_one = cts+1;\n\n\n\t\t\tif (ctx->sigfrag) {\n\t\t\t\tif (!ds->segment_started) {\n\t\t\t\t\tds->first_cts_in_seg = cts;\n\t\t\t\t\tdasher_mark_segment_start(ctx, ds, NULL, pck);\n\t\t\t\t\tds->segment_started = GF_TRUE;\n\t\t\t\t}\n\n\t\t\t\tds->cumulated_dur += dur;\n\n\t\t\t\t//drop packet if not splitting\n\t\t\t\tif (!ds->split_dur_next)\n\t\t\t\t\tgf_filter_pid_drop_packet(ds->ipid);\n\n\t\t\t\tif (ctx->in_error) {\n\t\t\t\t\tgf_filter_pid_set_discard(ds->ipid, GF_TRUE);\n\t\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\t\t\treturn GF_BAD_PARAM;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (ctx->do_index) {\n\t\t\t\t//frag range may be set for TS and other sources\n\t\t\t\tconst GF_PropertyValue *p = gf_filter_pck_get_property(pck, GF_PROP_PCK_FRAG_RANGE);\n\t\t\t\tif (p) {\n\t\t\t\t\tds->frag_start_offset = p->value.lfrac.num;\n\t\t\t\t\t//frag start only for fmp4\n\t\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FRAG_START);\n\t\t\t\t\tif (p && p->value.boolean) {\n\t\t\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FRAG_TFDT);\n\t\t\t\t\t\tif (p)\n\t\t\t\t\t\t\tds->frag_first_ftdt = p->value.longuint;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//create new ref to input\n\t\t\tdst = NULL;\n\t\t\tif (!ctx->do_index && !ctx->index_media_duration) {\n\t\t\t\tdst = gf_filter_pck_new_ref(ds->opid, 0, 0, pck);\n\t\t\t\tif (!dst) return GF_OUT_OF_MEM;\n\n\t\t\t\t//merge all props\n\t\t\t\tgf_filter_pck_merge_properties(pck, dst);\n\t\t\t\t//we have ts offset, use computed cts and dts\n\t\t\t\tif (ds->ts_offset) {\n\t\t\t\t\tgf_filter_pck_set_cts(dst, gf_filter_pck_get_cts(pck) + ds->ts_offset);\n\t\t\t\t\tgf_filter_pck_set_dts(dst, gf_filter_pck_get_dts(pck) + ds->ts_offset);\n\t\t\t\t}\n\n\t\t\t\tif (gf_sys_old_arch_compat() && ds->clamped_dur.num && ctx->loop\n\t\t\t\t\t&& (cts + 2*o_dur >= ds->ts_offset + base_ds->clamped_dur.num * ds->timescale / base_ds->clamped_dur.den)\n\t\t\t\t) {\n\t\t\t\t\tu32 _dur = dur;\n\t\t\t\t\t/* simple round with (int)+.5 to avoid trucating .99999 to 0 */\n\t\t\t\t\tdur = (u32) (ds->clamped_dur.num * ds->timescale / ds->clamped_dur.den - (dts - ds->ts_offset) + 0.5);\n\t\t\t\t\t//it may happen that the sample duration is 0 if the clamp duration is right after the sample DTS and timescale is not big enough to express it - force to 1\n\t\t\t\t\tif (dur==0)\n\t\t\t\t\t\tdur=1;\n\n\t\t\t\t\tgf_filter_pck_set_duration(dst, dur);\n\t\t\t\t\tds->est_next_dts += (s32) dur - (s32) _dur;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ds->segment_started) {\n\t\t\t\tds->first_cts_in_seg = cts;\n\t\t\t\tif (split_dur_next && (ctx->from_index==IDXMODE_SEG)) {\n\t\t\t\t\tds->first_cts_in_seg -= split_dur_next;\n\t\t\t\t}\n\t\t\t\tdasher_mark_segment_start(ctx, ds, dst, pck);\n\t\t\t\tds->segment_started = GF_TRUE;\n\t\t\t\tif (split_dur_next && ctx->do_index) {\n\t\t\t\t\tGF_MPD_SegmentURL *s = gf_list_last(ds->rep->segment_list->segment_URLs);\n\t\t\t\t\ts->split_first_dur = (u32) split_dur_next;\n\t\t\t\t\tassert(gf_filter_pck_get_duration(pck) > split_dur_next);\n\t\t\t\t\tds->rep->segment_list->use_split_dur = GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//prev packet was split\n\t\t\tif (is_packet_split) {\n\t\t\t\tu64 diff=0;\n\t\t\t\tu8 dep_flags = gf_filter_pck_get_dependency_flags(pck);\n\t\t\t\tu64 ts = gf_filter_pck_get_cts(pck);\n\t\t\t\tif (ts != GF_FILTER_NO_TS) {\n\t\t\t\t\tcts += ds->first_cts;\n\t\t\t\t\tassert(cts >= ts);\n\t\t\t\t\tdiff = cts - ts;\n\t\t\t\t} else {\n\t\t\t\t\tcts = ds->last_cts;\n\t\t\t\t}\n\t\t\t\tif (dst) {\n\t\t\t\t\tgf_filter_pck_set_cts(dst, cts + ds->ts_offset);\n\n\t\t\t\t\tts = gf_filter_pck_get_dts(pck);\n\t\t\t\t\tif (ts != GF_FILTER_NO_TS)\n\t\t\t\t\t\tgf_filter_pck_set_dts(dst, ts + diff + ds->ts_offset);\n\n\t\t\t\t\t//add sample is redundant flag\n\t\t\t\t\tdep_flags |= 0x1;\n\t\t\t\t\tgf_filter_pck_set_dependency_flags(dst, dep_flags);\n\t\t\t\t\t//this one might be incorrect of this split packet is also split, but we update the duration right below\n\t\t\t\t\tgf_filter_pck_set_duration(dst, dur);\n\t\t\t\t}\n\n\t\t\t\t//undo cts shift, we use it just below to compute cumulated dur using orig_cts (stored before shift)\n\t\t\t\tif (diff)\n\t\t\t\t\tcts -= ds->first_cts;\n\t\t\t}\n\n\t\t\t//if split, adjust duration - this may happen on a split packet, if it covered 3 or more segments\n\t\t\tif (split_dur) {\n\t\t\t\tu32 cumulated_split_dur = split_dur;\n\t\t\t\tif (dst)\n\t\t\t\t\tgf_filter_pck_set_duration(dst, split_dur);\n\t\t\t\t//adjust dur\n\t\t\t\tcumulated_split_dur += (u32) (cts - orig_cts);\n\t\t\t\tassert( dur > split_dur);\n\t\t\t\tassert( cumulated_split_dur <= gf_filter_pck_get_duration(pck) );\n\t\t\t\tds->split_dur_next = cumulated_split_dur;\n\t\t\t\tdur = split_dur;\n\t\t\t}\n\n\t\t\t//remove NTP\n\t\t\tif (dst && (ctx->ntp != DASHER_NTP_KEEP))\n\t\t\t\tgf_filter_pck_set_property(dst, GF_PROP_PCK_SENDER_NTP, NULL);\n\n\t\t\t//change packet times\n\t\t\tif (ds->force_timescale && dst) {\n\t\t\t\tu64 ats;\n\t\t\t\tats = gf_filter_pck_get_dts(dst);\n\t\t\t\tif (ats!=GF_FILTER_NO_TS) {\n\t\t\t\t\tats = gf_timestamp_rescale(ats, ds->timescale, ds->force_timescale);\n\t\t\t\t\tgf_filter_pck_set_dts(dst, ats);\n\t\t\t\t}\n\t\t\t\tats = gf_filter_pck_get_cts(dst);\n\t\t\t\tif (ats!=GF_FILTER_NO_TS) {\n\t\t\t\t\tats = gf_timestamp_rescale(ats, ds->timescale, ds->force_timescale);\n\t\t\t\t\tgf_filter_pck_set_cts(dst, ats);\n\t\t\t\t}\n\t\t\t\tats = (u64) gf_filter_pck_get_duration(dst);\n\t\t\t\tif (ats) {\n\t\t\t\t\tats = gf_timestamp_rescale(ats, ds->timescale, ds->force_timescale);\n\t\t\t\t\tgf_filter_pck_set_duration(dst, (u32) ats);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tds->cumulated_dur += dur;\n\n\t\t\tif (ds->current_seg_state && gf_filter_pck_get_crypt_flags(pck))\n\t\t\t\tds->current_seg_state->encrypted = GF_TRUE;\n\t\t\t//TODO check drift between MPD start time and min CTS in segment (not just first CTS in segment)\n\n\t\t\tif (ctx->gxns && dst && !ds->rep->first_tfdt_plus_one && !ds->muxed_base) {\n\t\t\t\tds->rep->first_tfdt_plus_one = 1 + gf_filter_pck_get_dts(dst);\n\t\t\t\tds->rep->first_tfdt_timescale = ds->timescale;\n\t\t\t}\n\t\t\t//send packet\n\t\t\tif (dst)\n\t\t\t\tgf_filter_pck_send(dst);\n\n\t\t\tif (ctx->update_report>=0)\n\t\t\t\tctx->update_report++;\n\n\t\t\tif (ds->dyn_bitrate) {\n\t\t\t\tu32 dsize;\n\t\t\t\tu64 rdts = gf_filter_pck_get_dts(pck);\n\t\t\t\tgf_filter_pck_get_data(pck, &dsize);\n\t\t\t\tif (!ds->rate_first_dts_plus_one)\n\t\t\t\t\tds->rate_first_dts_plus_one = 1 + rdts;\n\t\t\t\tds->rate_last_dts = rdts;\n\t\t\t\tds->rate_media_size += dsize;\n\t\t\t}\n\n\t\t\t//drop packet if not splitting\n\t\t\tif (!ds->split_dur_next)\n\t\t\t\tdasher_drop_input(ctx, ds, GF_FALSE);\n\n\t\t}\n\t}\n\n\tif (nb_seg_waiting && !nb_seg_active) {\n\t\tctx->last_min_segment_start_time = ctx->min_segment_start_time;\n\t\tctx->min_segment_start_time = 0;\n\t\treturn GF_OK;\n\t}\n\n\tnb_init = 0;\n\tfor (i=0; i<count; i++) {\n\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\t//if (ds->muxed_base) ds = ds->muxed_base;\n\t\tif (ds->done || ds->subdur_done) nb_init++;\n\t\telse if (ds->seg_done && ctx->force_period_switch) nb_init++;\n\t\telse if (ds->seg_done && ds->muxed_base && ds->muxed_base->done) {\n\t\t\tnb_init++;\n\t\t\tif (!ds->done && ds->opid) gf_filter_pid_set_eos(ds->opid);\n\t\t\tds->done = 1;\n\t\t}\n\t}\n\n\tif (nb_reg_done && (nb_reg_done == count)) {\n\t\tctx->mpd->gpac_mpd_time = 0;\n\t}\n\n\tdasher_format_report(filter, ctx);\n\n\tif (seg_done) {\n\t\tBool update_period = GF_FALSE;\n\t\tBool update_manifest = GF_FALSE;\n\t\tif (ctx->purge_segments) update_period = GF_TRUE;\n\t\tif (ctx->mpd) {\n\t\t\t//segment timeline used, always update manifest\n\t\t\tif (ctx->stl)\n\t\t\t\tupdate_manifest = GF_TRUE;\n\t\t\telse if (ctx->dmode==GF_DASH_DYNAMIC) {\n\t\t\t\t//publish time not set, we never send the manifest, do it\n\t\t\t\tif (!ctx->mpd->publishTime) {\n\t\t\t\t\tupdate_manifest = GF_TRUE;\n\t\t\t\t}\n\t\t\t\t//whenever we have a new seg in HLS, push new manifest\n\t\t\t\telse if (ctx->do_m3u8) {\n\t\t\t\t\tupdate_manifest = GF_TRUE;\n\t\t\t\t}\n\t\t\t\t//we have a minimum ipdate period\n\t\t\t\telse if (ctx->mpd->minimum_update_period) {\n\t\t\t\t\tu64 diff = dasher_get_utc(ctx) - ctx->mpd->publishTime;\n\t\t\t\t\tif (diff >= ctx->mpd->minimum_update_period)\n\t\t\t\t\t\tupdate_manifest = GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (update_period)\n\t\t\t\tdasher_update_period_duration(ctx, GF_FALSE);\n\n\t\t\tif (update_manifest)\n\t\t\t\tdasher_send_manifest(filter, ctx, GF_FALSE);\n\t\t}\n\t} else if (ctx->force_hls_ll_manifest) {\n\t\tctx->force_hls_ll_manifest = GF_FALSE;\n\t\tdasher_send_manifest(filter, ctx, GF_FALSE);\n\t}\n\n\t//still some running streams in period - do not ask for reschedule, wait for input packets to be available\n\tif (count && (nb_init<count)) {\n\t\treturn GF_OK;\n\t}\n\n\t//in subdur mode once we are done, flush output pids and discard all input packets\n\t//this is done at the end to be able to resume dashing when loop is requested\n\tif (ctx->subdur) {\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_FilterPacket *eods_pck;\n\t\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\t\tif (ds->done) continue;\n\t\t\teods_pck = gf_filter_pck_new_alloc(ds->opid, 0, NULL);\n\t\t\tif (!eods_pck) return GF_OUT_OF_MEM;\n\t\t\tds->done = 2;\n\t\t\tds->subdur_done = GF_TRUE;\n\t\t\tgf_filter_pck_set_property(eods_pck, GF_PROP_PCK_EODS, &PROP_BOOL(GF_TRUE) );\n\t\t\tgf_filter_pck_send(eods_pck);\n\n\t\t\tdasher_drop_input(ctx, ds, GF_TRUE);\n\t\t}\n\t}\n\n\t//we need to wait for full flush of packets before switching periods in order to get the\n\t//proper segment size for segment_list+byte_range mode\n\tif (ctx->nb_seg_url_pending) {\n\t\tu64 diff;\n\t\tif (!ctx->last_evt_check_time) {\n\t\t\tctx->last_evt_check_time = gf_sys_clock_high_res();\n\t\t\tgf_filter_prevent_blocking(filter, GF_TRUE);\n\t\t}\n\n\t\tdiff = gf_sys_clock_high_res() - ctx->last_evt_check_time;\n\t\tif (diff < 10000000) {\n\t\t\tgf_filter_ask_rt_reschedule(filter, 1000);\n\t\t\treturn GF_OK;\n\t\t}\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] timeout %d segment info still pending but no event from muxer after \"LLU\" us, aborting\\n\", ctx->nb_seg_url_pending, diff));\n\t\tctx->nb_seg_url_pending = 0;\n\t\treturn GF_SERVICE_ERROR;\n\t}\n\tif (ctx->sseg && !ctx->on_demand_done && !ctx->sigfrag && !ctx->do_index && !ctx->index_media_duration) {\n\t\treturn GF_OK;\n\t}\n\tgf_filter_prevent_blocking(filter, GF_FALSE);\n\tctx->force_period_switch = GF_FALSE;\n\t//done with this period, do period switch - this will update the MPD if needed\n\te = dasher_switch_period(filter, ctx);\n\t//no more periods\n\tif (e==GF_EOS) {\n\t\tif (!ctx->is_eos) {\n\t\t\tif (ctx->move_to_static) {\n\t\t\t\tctx->dmode = GF_MPD_TYPE_DYNAMIC_LAST;\n\t\t\t\tif (ctx->mpd) {\n\t\t\t\t\tctx->mpd->type = ctx->dmode;\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_DASH, (\"[Dasher] EOS, flushing manifest as static\\n\"));\n\t\t\t\t\tdasher_send_manifest(filter, ctx, GF_FALSE);\n\t\t\t\t}\n\t\t\t\tctx->move_to_static = GF_FALSE;",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 788,
    "critical_vars": [
      "remain"
    ],
    "function": "mpgviddmx_process",
    "filename": "gpac/CVE-2021-40575/CVE-2021-40575_CWE-476_5f2c2a16d30229b6241f02fa28e3d6b810d64858_reframe_mpgvid.c.diff",
    "function_code": "GF_Err mpgviddmx_process(GF_Filter *filter)\n{\n\tGF_MPGVidDmxCtx *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *pck, *dst_pck;\n\tu64 byte_offset;\n\ts64 vosh_start = -1;\n\ts64 vosh_end = -1;\n\tGF_Err e;\n\tchar *data;\n\tu8 *start;\n\tu32 pck_size;\n\ts32 remain;\n\n\t//always reparse duration\n\tif (!ctx->duration.num)\n\t\tmpgviddmx_check_dur(filter, ctx);\n\n\tpck = gf_filter_pid_get_packet(ctx->ipid);\n\tif (!pck) {\n\t\tif (gf_filter_pid_is_eos(ctx->ipid)) {\n\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE, GF_TRUE);\n\t\t\tif (ctx->opid)\n\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\tctx->src_pck = NULL;\n\t\t\treturn GF_EOS;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\tdata = (char *) gf_filter_pck_get_data(pck, &pck_size);\n\tbyte_offset = gf_filter_pck_get_byte_offset(pck);\n\n\tstart = data;\n\tremain = pck_size;\n\n\t//input pid sets some timescale - we flushed pending data , update cts\n\tif (!ctx->resume_from && ctx->timescale) {\n\t\tu64 ts = gf_filter_pck_get_cts(pck);\n\t\tif (ts != GF_FILTER_NO_TS) {\n\t\t\tif (!ctx->cts || !ctx->recompute_cts)\n\t\t\t\tctx->cts = ts;\n\t\t}\n\t\tts = gf_filter_pck_get_dts(pck);\n\t\tif (ts != GF_FILTER_NO_TS) {\n\t\t\tif (!ctx->dts || !ctx->recompute_cts)\n\t\t\t\tctx->dts = ts;\n\n\t\t\tif (!ctx->prev_dts) ctx->prev_dts = ts;\n\t\t\telse if (ctx->prev_dts != ts) {\n\t\t\t\tu64 diff = ts;\n\t\t\t\tdiff -= ctx->prev_dts;\n\t\t\t\tif (!ctx->cur_fps.den) ctx->cur_fps.den = (u32) diff;\n\t\t\t\telse if (ctx->cur_fps.den > diff)\n\t\t\t\t\tctx->cur_fps.den = (u32) diff;\n\t\t\t}\n\t\t}\n\t\tgf_filter_pck_get_framing(pck, &ctx->input_is_au_start, &ctx->input_is_au_end);\n\t\t//this will force CTS recomput of each frame\n\t\tif (ctx->recompute_cts) ctx->input_is_au_start = GF_FALSE;\n\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\tctx->src_pck = pck;\n\t\tgf_filter_pck_ref_props(&ctx->src_pck);\n\t}\n\n\t//we stored some data to find the complete vosh, aggregate this packet with current one\n\tif (!ctx->resume_from && ctx->hdr_store_size) {\n\t\tif (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size) {\n\t\t\tctx->hdr_store_alloc = ctx->hdr_store_size + pck_size;\n\t\t\tctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);\n\t\t}\n\t\tmemcpy(ctx->hdr_store + ctx->hdr_store_size, data, sizeof(char)*pck_size);\n\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\tif (byte_offset >= ctx->hdr_store_size)\n\t\t\t\tbyte_offset -= ctx->hdr_store_size;\n\t\t\telse\n\t\t\t\tbyte_offset = GF_FILTER_NO_BO;\n\t\t}\n\t\tctx->hdr_store_size += pck_size;\n\t\tstart = data = ctx->hdr_store;\n\t\tremain = pck_size = ctx->hdr_store_size;\n\t}\n\n\tif (ctx->resume_from) {\n\t\tif (gf_filter_pid_would_block(ctx->opid))\n\t\t\treturn GF_OK;\n\n\t\t//resume from data copied internally\n\t\tif (ctx->hdr_store_size) {\n\t\t\tassert(ctx->resume_from <= ctx->hdr_store_size);\n\t\t\tstart = data = ctx->hdr_store + ctx->resume_from;\n\t\t\tremain = pck_size = ctx->hdr_store_size - ctx->resume_from;\n\t\t} else {\n\t\t\tassert(remain >= (s32) ctx->resume_from);\n\t\t\tstart += ctx->resume_from;\n\t\t\tremain -= ctx->resume_from;\n\t\t}\n\t\tctx->resume_from = 0;\n\t}\n\n\tif (!ctx->bs) {\n\t\tctx->bs = gf_bs_new(start, remain, GF_BITSTREAM_READ);\n\t} else {\n\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\t}\n\tif (!ctx->vparser) {\n\t\tctx->vparser = gf_m4v_parser_bs_new(ctx->bs, ctx->is_mpg12);\n\t}\n\n\n\twhile (remain) {\n\t\tBool full_frame;\n\t\tu8 *pck_data;\n\t\ts32 current;\n\t\tu8 sc_type, forced_sc_type=0;\n\t\tBool sc_type_forced = GF_FALSE;\n\t\tBool skip_pck = GF_FALSE;\n\t\tu8 ftype;\n\t\tu32 tinc;\n\t\tu64 size=0;\n\t\tu64 fstart;\n\t\tBool is_coded;\n\t\tu32 bytes_from_store = 0;\n\t\tu32 hdr_offset = 0;\n\t\tBool copy_last_bytes = GF_FALSE;\n\n\t\t//not enough bytes to parse start code\n\t\tif (remain<5) {\n\t\t\tmemcpy(ctx->hdr_store, start, remain);\n\t\t\tctx->bytes_in_header = remain;\n\t\t\tbreak;\n\t\t}\n\t\tcurrent = -1;\n\n\t\t//we have some potential bytes of a start code in the store, copy some more bytes and check if valid start code.\n\t\t//if not, dispatch these bytes as continuation of the data\n\t\tif (ctx->bytes_in_header) {\n\n\t\t\tmemcpy(ctx->hdr_store + ctx->bytes_in_header, start, 8 - ctx->bytes_in_header);\n\t\t\tcurrent = mpgviddmx_next_start_code(ctx->hdr_store, 8);\n\n\t\t\t//no start code in stored buffer\n\t\t\tif ((current<0) || (current >= (s32) ctx->bytes_in_header) )  {\n\t\t\t\tif (ctx->opid) {\n\t\t\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->bytes_in_header, &pck_data);\n\t\t\t\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\t\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\t\t\t\t\tgf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);\n\t\t\t\t\tgf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);\n\t\t\t\t\tmemcpy(pck_data, ctx->hdr_store, ctx->bytes_in_header);\n\t\t\t\t\tgf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);\n\n\t\t\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset - ctx->bytes_in_header);\n\t\t\t\t\t}\n\n\t\t\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n\t\t\t\t}\n\n\t\t\t\tif (current<0) current = -1;\n\t\t\t\telse current -= ctx->bytes_in_header;\n\t\t\t\tctx->bytes_in_header = 0;\n\t\t\t} else {\n\t\t\t\t//we have a valid start code, check which byte in our store or in the packet payload is the start code type\n\t\t\t\t//and remember its location to reinit the parser from there\n\t\t\t\thdr_offset = 4 - ctx->bytes_in_header + current;\n\t\t\t\t//bytes still to dispatch\n\t\t\t\tbytes_from_store = ctx->bytes_in_header;\n\t\t\t\tctx->bytes_in_header = 0;\n\t\t\t\tif (!hdr_offset) {\n\t\t\t\t\tforced_sc_type = ctx->hdr_store[current+3];\n\t\t\t\t} else {\n\t\t\t\t\tforced_sc_type = start[hdr_offset-1];\n\t\t\t\t}\n\t\t\t\tsc_type_forced = GF_TRUE;\n\t\t\t}\n\t\t}\n\t\t//no starcode in store, look for startcode in packet\n\t\tif (current == -1) {\n\t\t\t//locate next start code\n\t\t\tcurrent = mpgviddmx_next_start_code(start, remain);\n\t\t\t//no start code, dispatch the block\n\t\t\tif (current<0) {\n\t\t\t\tu8 b3, b2, b1;\n\t\t\t\tif (! ctx->frame_started) {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[MPGVid] no start code in block and no frame started, discarding data\\n\" ));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsize = remain;\n\t\t\t\tb3 = start[remain-3];\n\t\t\t\tb2 = start[remain-2];\n\t\t\t\tb1 = start[remain-1];\n\t\t\t\t//we may have a startcode at the end of the packet, store it and don't dispatch the last 3 bytes !\n\t\t\t\tif (!b1 || !b2 || !b3) {\n\t\t\t\t\tcopy_last_bytes = GF_TRUE;\n\t\t\t\t\tassert(size >= 3);\n\t\t\t\t\tsize -= 3;\n\t\t\t\t\tctx->bytes_in_header = 3;\n\t\t\t\t}\n\n\t\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &pck_data);\n\t\t\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\t\t\t\tmemcpy(pck_data, start, (size_t) size);\n\t\t\t\tgf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);\n\t\t\t\tgf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);\n\t\t\t\tgf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);\n\n\t\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset);\n\t\t\t\t}\n\n\t\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n\t\t\t\tif (copy_last_bytes) {\n\t\t\t\t\tmemcpy(ctx->hdr_store, start+remain-3, 3);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tassert(current>=0);\n\n\t\t//if we are in the middle of parsing the vosh, skip over bytes remaining from previous obj not parsed\n\t\tif ((vosh_start>=0) && current) {\n\t\t\tassert(remain>=current);\n\t\t\tstart += current;\n\t\t\tremain -= current;\n\t\t\tcurrent = 0;\n\t\t}\n\t\t//also skip if no output pid\n\t\tif (!ctx->opid && current) {\n\t\t\tassert(remain>=current);\n\t\t\tstart += current;\n\t\t\tremain -= current;\n\t\t\tcurrent = 0;\n\t\t}\n\t\t//dispatch remaining bytes\n\t\tif (current>0) {\n\t\t\t//flush remaining\n\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, current, &pck_data);\n\t\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\t\t\tgf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);\n\t\t\tgf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);\n\t\t\tgf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_TRUE);\n\t\t\t//bytes were partly in store, partly in packet\n\t\t\tif (bytes_from_store) {\n\t\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset - bytes_from_store);\n\t\t\t\t}\n\t\t\t\tassert(bytes_from_store>=(u32) current);\n\t\t\t\tbytes_from_store -= current;\n\t\t\t\tmemcpy(pck_data, ctx->hdr_store, current);\n\t\t\t} else {\n\t\t\t\t//bytes were only in packet\n\t\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset);\n\t\t\t\t}\n\t\t\t\tmemcpy(pck_data, start, current);\n\t\t\t\tassert(remain>=current);\n\t\t\t\tstart += current;\n\t\t\t\tremain -= current;\n\t\t\t\tcurrent = 0;\n\t\t\t}\n\t\t\tgf_filter_pck_set_carousel_version(dst_pck, 1);\n\n\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n\t\t}\n\n\t\t//not enough bytes to parse start code\n\t\tif (remain<5) {\n\t\t\tmemcpy(ctx->hdr_store, start, remain);\n\t\t\tctx->bytes_in_header = remain;\n\t\t\tbreak;\n\t\t}\n\n\t\t//parse headers\n\t\t//we have a start code loaded, eg the data packet does not have a full start code at the beginning\n\t\tif (sc_type_forced) {\n\t\t\tgf_bs_reassign_buffer(ctx->bs, start + hdr_offset, remain - hdr_offset);\n\t\t\tsc_type = forced_sc_type;\n\t\t} else {\n\t\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\t\t\tgf_bs_read_int(ctx->bs, 24);\n\t\t\tsc_type = gf_bs_read_int(ctx->bs, 8);\n\t\t}\n\n\t\tif (ctx->is_mpg12) {\n\t\t\tswitch (sc_type) {\n\t\t\tcase M2V_SEQ_START_CODE:\n\t\t\tcase M2V_EXT_START_CODE:\n\t\t\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\t\t\t\te = gf_m4v_parse_config(ctx->vparser, &ctx->dsi);\n\t\t\t\t//not enough data, accumulate until we can parse the full header\n\t\t\t\tif (e==GF_EOS) {\n\t\t\t\t\tif (vosh_start<0) vosh_start = 0;\n\t\t\t\t\tif (data == ctx->hdr_store) {\n\t\t\t\t\t\tmemmove(ctx->hdr_store, start, remain);\n\t\t\t\t\t\tctx->hdr_store_size = remain;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {\n\t\t\t\t\t\t\tctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - vosh_start);\n\t\t\t\t\t\t\tctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmemcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );\n\t\t\t\t\t\tctx->hdr_store_size += pck_size - (u32) vosh_start;\n\t\t\t\t\t}\n\t\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t} else if (e != GF_OK) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MPGVid] Failed to parse VOS header: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\t} else {\n\t\t\t\t\tmpgviddmx_check_pid(filter, ctx, 0, NULL);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase M2V_PIC_START_CODE:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t} else {\n\t\t\tu8 PL;\n\t\t\tswitch (sc_type) {\n\t\t\tcase M4V_VOS_START_CODE:\n\t\t\t\tctx->dsi.VideoPL = (u8) gf_bs_read_u8(ctx->bs);\n\t\t\t\tvosh_start = start - (u8 *)data;\n\t\t\t\tskip_pck = GF_TRUE;\n\t\t\t\tassert(remain>=5);\n\t\t\t\tstart += 5;\n\t\t\t\tremain -= 5;\n\t\t\t\tbreak;\n\t\t\tcase M4V_VOL_START_CODE:\n\t\t\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\t\t\t\tPL = ctx->dsi.VideoPL;\n\t\t\t\te = gf_m4v_parse_config(ctx->vparser, &ctx->dsi);\n\t\t\t\tctx->dsi.VideoPL = PL;\n\t\t\t\t//not enough data, accumulate until we can parse the full header\n\t\t\t\tif (e==GF_EOS) {\n\t\t\t\t\tif (vosh_start<0) vosh_start = 0;\n\t\t\t\t\tif (data == ctx->hdr_store) {\n\t\t\t\t\t\tmemmove(ctx->hdr_store, start, remain);\n\t\t\t\t\t\tctx->hdr_store_size = remain;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {\n\t\t\t\t\t\t\tctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - (u32) vosh_start);\n\t\t\t\t\t\t\tctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmemcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );\n\t\t\t\t\t\tctx->hdr_store_size += pck_size - (u32) vosh_start;\n\t\t\t\t\t}\n\t\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t} else if (e != GF_OK) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MPGVid] Failed to parse VOS header: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\t} else {\n\t\t\t\t\tu32 obj_size = (u32) gf_m4v_get_object_start(ctx->vparser);\n\t\t\t\t\tif (vosh_start<0) vosh_start = 0;\n\t\t\t\t\tvosh_end = start - (u8 *)data + obj_size;\n\t\t\t\t\tvosh_end -= vosh_start;\n\t\t\t\t\tmpgviddmx_check_pid(filter, ctx,(u32)  vosh_end, data+vosh_start);\n\t\t\t\t\tskip_pck = GF_TRUE;\n\t\t\t\t\tassert(remain>=(s32) obj_size);\n\t\t\t\t\tstart += obj_size;\n\t\t\t\t\tremain -= obj_size;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase M4V_VOP_START_CODE:\n\t\t\tcase M4V_GOV_START_CODE:\n\t\t\t\tbreak;\n\n\t\t\tcase M4V_VO_START_CODE:\n\t\t\tcase M4V_VISOBJ_START_CODE:\n\t\t\tdefault:\n\t\t\t\tif (vosh_start>=0) {\n\t\t\t\t\tskip_pck = GF_TRUE;\n\t\t\t\t\tassert(remain>=4);\n\t\t\t\t\tstart += 4;\n\t\t\t\t\tremain -= 4;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (skip_pck) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!ctx->opid) {\n\t\t\tassert(remain>=4);\n\t\t\tstart += 4;\n\t\t\tremain -= 4;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->resume_from = (u32) ((char *)start -  (char *)data);\n\t\t\treturn GF_OK;\n\t\t}\n\t\t//at this point, we no longer reaggregate packets\n\t\tctx->hdr_store_size = 0;\n\n\t\tif (ctx->in_seek) {\n\t\t\tu64 nb_frames_at_seek = (u64) (ctx->start_range * ctx->cur_fps.num);\n\t\t\tif (ctx->cts + ctx->cur_fps.den >= nb_frames_at_seek) {\n\t\t\t\t//u32 samples_to_discard = (ctx->cts + ctx->dts_inc) - nb_samples_at_seek;\n\t\t\t\tctx->in_seek = GF_FALSE;\n\t\t\t}\n\t\t}\n\t\t//may happen that after all our checks, only 4 bytes are left, continue to store these 4 bytes\n\t\tif (remain<5)\n\t\t\tcontinue;\n\n\t\t//good to go\n\t\tgf_m4v_parser_reset(ctx->vparser, sc_type_forced ? forced_sc_type + 1 : 0);\n\t\tsize = 0;\n\t\te = gf_m4v_parse_frame(ctx->vparser, &ctx->dsi, &ftype, &tinc, &size, &fstart, &is_coded);\n\t\t//true if we strip VO and VISOBJ assert(!fstart);\n\n\t\t//we skipped bytes already in store + end of start code present in packet, so the size of the first object\n\t\t//needs adjustement\n\t\tif (bytes_from_store) {\n\t\t\tsize += bytes_from_store + hdr_offset;\n\t\t}\n\n\t\tif ((e == GF_EOS) && !ctx->input_is_au_end) {\n\t\t\tu8 b3 = start[remain-3];\n\t\t\tu8 b2 = start[remain-2];\n\t\t\tu8 b1 = start[remain-1];\n\n\t\t\t//we may have a startcode at the end of the packet, store it and don't dispatch the last 3 bytes !\n\t\t\tif (!b1 || !b2 || !b3) {\n\t\t\t\tcopy_last_bytes = GF_TRUE;\n\t\t\t\tassert(size >= 3);\n\t\t\t\tsize -= 3;\n\t\t\t\tctx->bytes_in_header = 3;\n\t\t\t}\n\t\t\tfull_frame = GF_FALSE;\n\t\t} else {\n\t\t\tfull_frame = GF_TRUE;\n\t\t}\n\n\t\tif (!is_coded) {\n\t\t\t/*if prev is B and we're parsing a packed bitstream discard n-vop*/\n\t\t\tif (ctx->forced_packed && ctx->b_frames) {\n\t\t\t\tctx->is_packed = GF_TRUE;\n\t\t\t\tassert(remain>=size);\n\t\t\t\tstart += size;\n\t\t\t\tremain -= (s32) size;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*policy is to import at variable frame rate, skip*/\n\t\t\tif (ctx->vfr) {\n\t\t\t\tctx->is_vfr = GF_TRUE;\n\t\t\t\tmpgviddmx_update_time(ctx);\n\t\t\t\tassert(remain>=size);\n\t\t\t\tstart += size;\n\t\t\t\tremain -= (s32) size;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*policy is to keep non coded frame (constant frame rate), add*/\n\t\t}\n\n\t\tif (ftype==2) {\n\t\t\t//count number of B-frames since last ref\n\t\t\tctx->b_frames++;\n\t\t\tctx->nb_b++;\n\t\t} else {\n\t\t\t//flush all pending packets\n\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE, GF_FALSE);\n\t\t\t//remeber the CTS of the last ref\n\t\t\tctx->last_ref_cts = ctx->cts;\n\t\t\tif (ctx->max_b < ctx->b_frames) ctx->max_b = ctx->b_frames;\n\t\t\t\n\t\t\tctx->b_frames = 0;\n\t\t\tif (ftype)\n\t\t\t\tctx->nb_p++;\n\t\t\telse\n\t\t\t\tctx->nb_i++;\n\t\t}\n\t\tctx->nb_frames++;\n\n\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &pck_data);\n\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\t\t//bytes come from both our store and the data packet\n\t\tif (bytes_from_store) {\n\t\t\tmemcpy(pck_data, ctx->hdr_store+current, bytes_from_store);\n\t\t\tassert(size >= bytes_from_store);\n\t\t\tsize -= bytes_from_store;\n\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset - bytes_from_store);\n\t\t\t}\n\t\t\tmemcpy(pck_data + bytes_from_store, start, (size_t) size);\n\t\t} else {\n\t\t\t//bytes only come the data packet\n\t\t\tmemcpy(pck_data, start, (size_t) size);\n\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset + start - (u8 *) data);\n\t\t\t}\n\t\t}\n\t\tassert(pck_data[0] == 0);\n\t\tassert(pck_data[1] == 0);\n\t\tassert(pck_data[2] == 0x01);\n\n\t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, (full_frame || ctx->input_is_au_end) ? GF_TRUE : GF_FALSE);\n\t\tgf_filter_pck_set_cts(dst_pck, ctx->cts);\n\t\tgf_filter_pck_set_dts(dst_pck, ctx->dts);\n\t\tif (ctx->input_is_au_start) {\n\t\t\tctx->input_is_au_start = GF_FALSE;\n\t\t} else {\n\t\t\t//we use the carousel flag temporarly to indicate the cts must be recomputed\n\t\t\tgf_filter_pck_set_carousel_version(dst_pck, 1);\n\t\t}\n\t\tgf_filter_pck_set_sap(dst_pck, ftype ? GF_FILTER_SAP_NONE : GF_FILTER_SAP_1);\n\t\tgf_filter_pck_set_duration(dst_pck, ctx->cur_fps.den);\n\t\tif (ctx->in_seek) gf_filter_pck_set_seek_flag(dst_pck, GF_TRUE);\n\t\tctx->frame_started = GF_TRUE;\n\n\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n\n\t\tmpgviddmx_update_time(ctx);\n\n\t\tif (!full_frame) {\n\t\t\tif (copy_last_bytes) {\n\t\t\t\tmemcpy(ctx->hdr_store, start+remain-3, 3);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tassert(remain>=size);\n\t\tstart += size;\n\t\tremain -= (s32) size;\n\t}\n\tgf_filter_pid_drop_packet(ctx->ipid);\n\n\treturn GF_OK;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 2883,
    "critical_vars": [
      "av1c->version",
      "av1c->seq_profile",
      "av1c->seq_level_idx_0",
      "av1c->seq_tier_0",
      "stderr"
    ],
    "function": "DumpTrackInfo",
    "filename": "gpac/CVE-2021-32138/CVE-2021-32138_CWE-476_289ffce3e0d224d314f5f92a744d5fe35999f20b_filedump.c.diff",
    "function_code": "void gf_inspect_format_timecode(const u8 *data, u32 size, u32 tmcd_flags, u32 tc_num, u32 tc_den, u32 tmcd_fpt, char szFmt[100]);\n\nvoid DumpTrackInfo(GF_ISOFile *file, GF_ISOTrackID trackID, Bool full_dump, Bool is_track_num, Bool dump_m4sys)\n{\n\tchar szCodec[RFC6381_CODEC_NAME_SIZE_MAX];\n\tDouble scale, max_rate, rate;\n\tBool is_od_track = 0;\n\tu32 trackNum, i, j, ts, mtype, msub_type, timescale, sr, nb_ch, count, alt_group, nb_groups, nb_edits, cdur, csize, bps, pfmt, codecid;\n\tu64 time_slice, dur, size;\n\ts32 cts_shift;\n\tGF_ESD *esd;\n\tchar szDur[50];\n\tchar *lang;\n\n\tif (!is_track_num) {\n\t\ttrackNum = gf_isom_get_track_by_id(file, trackID);\n\t} else {\n\t\ttrackNum = trackID;\n\t\ttrackID = gf_isom_get_track_id(file, trackNum);\n\t}\n\tif (!trackNum) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"No track with ID %d found\\n\", trackID));\n\t\treturn;\n\t}\n\n\ttimescale = gf_isom_get_media_timescale(file, trackNum);\n\tfprintf(stderr, \"# Track %d Info - ID %d - TimeScale %d\\n\", trackNum, trackID, timescale);\n\n\tdur = gf_isom_get_media_original_duration(file, trackNum);\n\tsize = gf_isom_get_media_duration(file, trackNum);\n\tfprintf(stderr, \"Media Duration %s \", format_duration(dur, timescale, szDur));\n\tif (dur != size)\n\t\tfprintf(stderr, \" (recomputed %s)\", format_duration(size, timescale, szDur));\n\tfprintf(stderr, \"\\n\");\n\n\tif (gf_isom_check_data_reference(file, trackNum, 1) != GF_OK) {\n\t\tM4_LOG(GF_LOG_WARNING, (\"Track uses external data reference not supported by GPAC!\\n\"));\n\t}\n\n\tnb_edits = gf_isom_get_edits_count(file, trackNum);\n\tif (nb_edits)\n\t\tfprintf(stderr, \"Track has %d edits: track duration is %s\\n\", nb_edits, format_duration(gf_isom_get_track_duration(file, trackNum), gf_isom_get_timescale(file), szDur));\n\n\tcts_shift = gf_isom_get_composition_offset_shift(file, trackNum);\n\tif (cts_shift)\n\t\tfprintf(stderr, \"Track composition offset shift (negative CTS offset): %d\\n\", cts_shift);\n\n\tif (gf_isom_is_track_in_root_od(file, trackNum) ) fprintf(stderr, \"Track is present in Root OD\\n\");\n\tif (!gf_isom_is_track_enabled(file, trackNum))  fprintf(stderr, \"Track is disabled\\n\");\n\tgf_isom_get_media_language(file, trackNum, &lang);\n\tfprintf(stderr, \"Media Info: Language \\\"%s (%s)\\\" - \", GetLanguage(lang), lang );\n\tgf_free(lang);\n\tmtype = gf_isom_get_media_type(file, trackNum);\n\tfprintf(stderr, \"Type \\\"%s:\", gf_4cc_to_str(mtype));\n\tmsub_type = gf_isom_get_mpeg4_subtype(file, trackNum, 1);\n\tif (!msub_type) msub_type = gf_isom_get_media_subtype(file, trackNum, 1);\n\tfprintf(stderr, \"%s\\\" - %d samples\\n\", gf_4cc_to_str(msub_type), gf_isom_get_sample_count(file, trackNum));\n\n\tpfmt = gf_pixel_fmt_from_qt_type(msub_type);\n\tcodecid = gf_codec_id_from_isobmf(msub_type);\n\n\tcount = gf_isom_get_track_kind_count(file, trackNum);\n\tfor (i = 0; i < count; i++) {\n\t\tchar *kind_scheme, *kind_value;\n\t\tgf_isom_get_track_kind(file, trackNum, i, &kind_scheme, &kind_value);\n\t\tfprintf(stderr, \"Kind: %s - %s\\n\", kind_scheme ? kind_scheme : \"null\", kind_value ? kind_value : \"null\");\n\t\tif (kind_scheme) gf_free(kind_scheme);\n\t\tif (kind_value) gf_free(kind_value);\n\t}\n\n\tif (gf_isom_is_track_fragmented(file, trackID) ) {\n\t\tu32 defaultDuration, defaultSize, defaultDescriptionIndex, defaultRandomAccess;\n\t\tu8 defaultPadding;\n\t\tu16 defaultDegradationPriority;\n\t\tu32 frag_samples;\n\t\tu64 frag_duration;\n\t\tgf_isom_get_fragmented_samples_info(file, trackID, &frag_samples, &frag_duration);\n\t\tfprintf(stderr, \"Fragmented track: %d samples - Media Duration %s\\n\", frag_samples, format_duration(frag_duration, timescale, szDur));\n\n\t\tgf_isom_get_fragment_defaults(file, trackNum, &defaultDuration, &defaultSize, &defaultDescriptionIndex, &defaultRandomAccess, &defaultPadding, &defaultDegradationPriority);\n\n\t\tfprintf(stderr, \"Fragment sample defaults: duration %d size %d stsd %d sync %d padding %d degradation_priority %d\\n\",\n\t\t\t\tdefaultDuration, defaultSize, defaultDescriptionIndex, defaultRandomAccess,\n\t\t\t\t(u32) defaultPadding, (u32) defaultDegradationPriority\n\t\t);\n\t}\n\n\tif (!gf_isom_is_self_contained(file, trackNum, 1)) {\n\t\tconst char *url, *urn;\n\t\tgf_isom_get_data_reference(file, trackNum, 1, &url, &urn);\n\t\tfprintf(stderr, \"Media Data Location: %s\\n\", url ? url : urn);\n\t}\n\n\tif (full_dump) {\n\t\tconst char *handler_name;\n\t\tgf_isom_get_handler_name(file, trackNum, &handler_name);\n\t\tfprintf(stderr, \"Handler name: %s\\n\", handler_name);\n\t}\n\n\tprint_udta(file, trackNum, GF_FALSE);\n\n\tif (gf_isom_is_video_handler_type(mtype) ) {\n\t\ts32 tx, ty;\n\t\tu32 w, h;\n\t\tu16 bit_depth;\n\n\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\tgf_isom_get_visual_bit_depth(file, trackNum, 1, &bit_depth);\n\t\tfprintf(stderr, \"Visual Sample Entry Info: width=%d height=%d (depth=%d bits)\\n\", w, h, (int)bit_depth);\n\n\t\tgf_isom_get_track_layout_info(file, trackNum, &w, &h, &tx, &ty, NULL);\n\t\tfprintf(stderr, \"Visual Track layout: x=%d y=%d width=%d height=%d\\n\", tx, ty, w, h);\n\t}\n\n\tgf_isom_get_audio_info(file, trackNum, 1, &sr, &nb_ch, &bps);\n\tgf_isom_set_nalu_extract_mode(file, trackNum, GF_ISOM_NALU_EXTRACT_INSPECT);\n\n\tmsub_type = gf_isom_get_media_subtype(file, trackNum, 1);\n\tif (msub_type==GF_ISOM_SUBTYPE_MPEG4_CRYP)\n\t\tgf_isom_get_original_format_type(file, trackNum, 1, &msub_type);\n\n\tif ((msub_type==GF_ISOM_SUBTYPE_MPEG4)\n\t        || (msub_type==GF_ISOM_SUBTYPE_AVC_H264)\n\t        || (msub_type==GF_ISOM_SUBTYPE_AVC2_H264)\n\t        || (msub_type==GF_ISOM_SUBTYPE_AVC3_H264)\n\t        || (msub_type==GF_ISOM_SUBTYPE_AVC4_H264)\n\t        || (msub_type==GF_ISOM_SUBTYPE_SVC_H264)\n\t        || (msub_type==GF_ISOM_SUBTYPE_MVC_H264)\n\t        || (msub_type==GF_ISOM_SUBTYPE_LSR1)\n\t        || (msub_type==GF_ISOM_SUBTYPE_HVC1)\n\t        || (msub_type==GF_ISOM_SUBTYPE_HEV1)\n\t        || (msub_type==GF_ISOM_SUBTYPE_HVC2)\n\t        || (msub_type==GF_ISOM_SUBTYPE_HEV2)\n\t        || (msub_type==GF_ISOM_SUBTYPE_LHV1)\n\t        || (msub_type==GF_ISOM_SUBTYPE_LHE1)\n\t        || (msub_type==GF_ISOM_SUBTYPE_HVT1)\n\t   )  {\n\t\tesd = gf_isom_get_esd(file, trackNum, 1);\n\t\tif (!esd || !esd->decoderConfig) {\n\t\t\tM4_LOG(GF_LOG_WARNING, (\"WARNING: Broken MPEG-4 Track\\n\"));\n\t\t\tif (esd) gf_odf_desc_del((GF_Descriptor *)esd);\n\t\t} else {\n\t\t\tconst char *st = gf_stream_type_name(esd->decoderConfig->streamType);\n\t\t\tif (dump_m4sys) {\n\t\t\t\tif (st) {\n\t\t\t\t\tfprintf(stderr, \"MPEG-4 Config%s%s Stream - ObjectTypeIndication 0x%02x\\n\",\n\t\t\t\t\t\t\tfull_dump ? \"\\n\\t\" : \": \", st, esd->decoderConfig->objectTypeIndication);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"MPEG-4 Config%sStream Type 0x%02x - ObjectTypeIndication 0x%02x\\n\",\n\t\t\t\t\t\t\tfull_dump ? \"\\n\\t\" : \": \", esd->decoderConfig->streamType, esd->decoderConfig->objectTypeIndication);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (esd->decoderConfig->streamType==GF_STREAM_OD)\n\t\t\t\tis_od_track=1;\n\n\t\t\tif (esd->decoderConfig->streamType==GF_STREAM_VISUAL) {\n\t\t\t\tu32 w, h;\n\t\t\t\tu16 rvc_predef;\n\t\t\t\tw = h = 0;\n\t\t\t\tif (esd->decoderConfig->objectTypeIndication==GF_CODECID_MPEG4_PART2) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\tif (!esd->decoderConfig->decoderSpecificInfo) {\n#else\n\t\t\t\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\t\t\t\tfprintf(stderr, \"MPEG-4 Visual Size %d x %d\\n\", w, h);\n#endif\n\t\t\t\t\t\tM4_LOG(GF_LOG_WARNING, (\"Non-compliant MPEG-4 Visual track: video_object_layer infos not found in sample description\\n\"));\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\t} else {\n\t\t\t\t\t\tGF_M4VDecSpecInfo dsi;\n\t\t\t\t\t\tgf_m4v_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &dsi);\n\t\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\t\t\t\t\tw = dsi.width;\n\t\t\t\t\t\th = dsi.height;\n\t\t\t\t\t\tfprintf(stderr, \"MPEG-4 Visual Size %d x %d - %s\\n\", w, h, gf_m4v_get_profile_name(dsi.VideoPL));\n\t\t\t\t\t\tif (dsi.par_den && dsi.par_num) {\n\t\t\t\t\t\t\tu32 tw, th;\n\t\t\t\t\t\t\tgf_isom_get_track_layout_info(file, trackNum, &tw, &th, NULL, NULL, NULL);\n\t\t\t\t\t\t\tfprintf(stderr, \"Pixel Aspect Ratio %d:%d - Indicated track size %d x %d\\n\", dsi.par_num, dsi.par_den, tw, th);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t} else if (gf_isom_get_avc_svc_type(file, trackNum, 1) != GF_ISOM_AVCTYPE_NONE) {\n\t\t\t\t\tGF_AVCConfig *avccfg, *svccfg, *mvccfg;\n\n\t\t\t\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\t\t\t\tfprintf(stderr, \"AVC/H264 Video - Visual Size %d x %d\\n\", w, h);\n\n\t\t\t\t\tavccfg = gf_isom_avc_config_get(file, trackNum, 1);\n\t\t\t\t\tsvccfg = gf_isom_svc_config_get(file, trackNum, 1);\n\t\t\t\t\tmvccfg = gf_isom_mvc_config_get(file, trackNum, 1);\n\t\t\t\t\tif (!avccfg && !svccfg && !mvccfg) {\n\t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"\\tNon-compliant AVC track: SPS/PPS not found in sample description\\n\"));\n\t\t\t\t\t} else if (avccfg) {\n\t\t\t\t\t\tfprintf(stderr, \"\\tAVC Info: %d SPS - %d PPS\", gf_list_count(avccfg->sequenceParameterSets) , gf_list_count(avccfg->pictureParameterSets) );\n\t\t\t\t\t\tfprintf(stderr, \" - Profile %s @ Level %g\\n\", gf_avc_get_profile_name(avccfg->AVCProfileIndication), ((Double)avccfg->AVCLevelIndication)/10.0 );\n\t\t\t\t\t\tfprintf(stderr, \"\\tNAL Unit length bits: %d\\n\", 8*avccfg->nal_unit_size);\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\t\tfor (i=0; i<gf_list_count(avccfg->sequenceParameterSets); i++) {\n\t\t\t\t\t\t\ts32 par_n, par_d;\n\t\t\t\t\t\t\tGF_NALUFFParam *slc = gf_list_get(avccfg->sequenceParameterSets, i);\n\t\t\t\t\t\t\tgf_avc_get_sps_info(slc->data, slc->size, NULL, NULL, NULL, &par_n, &par_d);\n\t\t\t\t\t\t\tif ((par_n>0) && (par_d>0)) {\n\t\t\t\t\t\t\t\tu32 tw, th;\n\t\t\t\t\t\t\t\tgf_isom_get_track_layout_info(file, trackNum, &tw, &th, NULL, NULL, NULL);\n\t\t\t\t\t\t\t\tfprintf(stderr, \"\\tPixel Aspect Ratio %d:%d - Indicated track size %d x %d\\n\", par_n, par_d, tw, th);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!full_dump) break;\n\t\t\t\t\t\t}\n#endif\n\n\t\t\t\t\t\tif (avccfg->chroma_bit_depth) {\n\t\t\t\t\t\t\tfprintf(stderr, \"\\tChroma format %s - Luma bit depth %d - chroma bit depth %d\\n\", gf_avc_hevc_get_chroma_format_name(avccfg->chroma_format), avccfg->luma_bit_depth, avccfg->chroma_bit_depth);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tprint_config_hash(avccfg->sequenceParameterSets, \"SPS\");\n\t\t\t\t\t\tprint_config_hash(avccfg->pictureParameterSets, \"PPS\");\n\n\t\t\t\t\t\tgf_odf_avc_cfg_del(avccfg);\n\t\t\t\t\t}\n\t\t\t\t\tif (svccfg) {\n\t\t\t\t\t\tfprintf(stderr, \"\\n\\tSVC Info: %d SPS - %d PPS - Profile %s @ Level %g\\n\", gf_list_count(svccfg->sequenceParameterSets) , gf_list_count(svccfg->pictureParameterSets), gf_avc_get_profile_name(svccfg->AVCProfileIndication), ((Double)svccfg->AVCLevelIndication)/10.0 );\n\t\t\t\t\t\tfprintf(stderr, \"\\tSVC NAL Unit length bits: %d\\n\", 8*svccfg->nal_unit_size);\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\t\tfor (i=0; i<gf_list_count(svccfg->sequenceParameterSets); i++) {\n\t\t\t\t\t\t\tGF_NALUFFParam *slc = gf_list_get(svccfg->sequenceParameterSets, i);\n\t\t\t\t\t\t\tif (slc) {\n\t\t\t\t\t\t\t\ts32 par_n, par_d;\n\t\t\t\t\t\t\t\tu32 s_w, s_h, sps_id;\n\t\t\t\t\t\t\t\tgf_avc_get_sps_info(slc->data, slc->size, &sps_id, &s_w, &s_h, &par_n, &par_d);\n\t\t\t\t\t\t\t\tfprintf(stderr, \"\\t\\tSPS ID %d - Visual Size %d x %d\\n\", sps_id, s_w, s_h);\n\t\t\t\t\t\t\t\tif ((par_n>0) && (par_d>0)) {\n\t\t\t\t\t\t\t\t\tu32 tw, th;\n\t\t\t\t\t\t\t\t\tgf_isom_get_track_layout_info(file, trackNum, &tw, &th, NULL, NULL, NULL);\n\t\t\t\t\t\t\t\t\tfprintf(stderr, \"\\tPixel Aspect Ratio %d:%d - Indicated track size %d x %d\\n\", par_n, par_d, tw, th);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t\tprint_config_hash(svccfg->sequenceParameterSets, \"SPS\");\n\t\t\t\t\t\tprint_config_hash(svccfg->pictureParameterSets, \"PPS\");\n\t\t\t\t\t\tprint_config_hash(svccfg->sequenceParameterSetExtensions, \"SPSEx\");\n\n\t\t\t\t\t\tgf_odf_avc_cfg_del(svccfg);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (mvccfg) {\n\t\t\t\t\t\tfprintf(stderr, \"\\n\\tMVC Info: %d SPS - %d PPS - Profile %s @ Level %g\\n\", gf_list_count(mvccfg->sequenceParameterSets) , gf_list_count(mvccfg->pictureParameterSets), gf_avc_get_profile_name(mvccfg->AVCProfileIndication), ((Double)mvccfg->AVCLevelIndication)/10.0 );\n\t\t\t\t\t\tfprintf(stderr, \"\\tMVC NAL Unit length bits: %d\\n\", 8*mvccfg->nal_unit_size);\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\t\tfor (i=0; i<gf_list_count(mvccfg->sequenceParameterSets); i++) {\n\t\t\t\t\t\t\tGF_NALUFFParam *slc = gf_list_get(mvccfg->sequenceParameterSets, i);\n\t\t\t\t\t\t\tif (slc) {\n\t\t\t\t\t\t\t\tu32 s_w, s_h, sps_id;\n\t\t\t\t\t\t\t\ts32 par_n, par_d;\n\t\t\t\t\t\t\t\tgf_avc_get_sps_info(slc->data, slc->size, &sps_id, &s_w, &s_h, &par_n, &par_d);\n\t\t\t\t\t\t\t\tfprintf(stderr, \"\\t\\tSPS ID %d - Visual Size %d x %d\\n\", sps_id, s_w, s_h);\n\t\t\t\t\t\t\t\tif ((par_n>0) && (par_d>0)) {\n\t\t\t\t\t\t\t\t\tu32 tw, th;\n\t\t\t\t\t\t\t\t\tgf_isom_get_track_layout_info(file, trackNum, &tw, &th, NULL, NULL, NULL);\n\t\t\t\t\t\t\t\t\tfprintf(stderr, \"\\tPixel Aspect Ratio %d:%d - Indicated track size %d x %d\\n\", par_n, par_d, tw, th);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t\tprint_config_hash(mvccfg->sequenceParameterSets, \"SPS\");\n\t\t\t\t\t\tprint_config_hash(mvccfg->pictureParameterSets, \"PPS\");\n\t\t\t\t\t\tgf_odf_avc_cfg_del(mvccfg);\n\t\t\t\t\t}\n\n\t\t\t\t} else if ((esd->decoderConfig->objectTypeIndication==GF_CODECID_HEVC)\n\t\t\t\t           || (esd->decoderConfig->objectTypeIndication==GF_CODECID_LHVC)\n\t\t\t\t          ) {\n\t\t\t\t\tGF_HEVCConfig *hevccfg, *lhvccfg;\n\t\t\t\t\tGF_OperatingPointsInformation *oinf;\n#if !defined(GPAC_DISABLE_AV_PARSERS) && !defined(GPAC_DISABLE_HEVC)\n\t\t\t\t\tHEVCState hevc_state;\n\t\t\t\t\tmemset(&hevc_state, 0, sizeof(HEVCState));\n\t\t\t\t\thevc_state.sps_active_idx = -1;\n#endif\n\n\t\t\t\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\t\t\t\tfprintf(stderr, \"HEVC Video - Visual Size %d x %d\\n\", w, h);\n\t\t\t\t\thevccfg = gf_isom_hevc_config_get(file, trackNum, 1);\n\t\t\t\t\tlhvccfg = gf_isom_lhvc_config_get(file, trackNum, 1);\n\n\t\t\t\t\tif (msub_type==GF_ISOM_SUBTYPE_HVT1) {\n\t\t\t\t\t\tconst u8 *data;\n\t\t\t\t\t\tu32 tsize;\n\t\t\t\t\t\tu32  is_default, tx,ty,tw,th, id, independent;\n\t\t\t\t\t\tBool full_frame;\n\t\t\t\t\t\tif (gf_isom_get_tile_info(file, trackNum, 1, &is_default, &id, &independent, &full_frame, &tx, &ty, &tw, &th)) {\n\t\t\t\t\t\t\tfprintf(stderr, \"\\tHEVC Tile - ID %d independent %d (x,y,w,h)=%d,%d,%d,%d \\n\", id, independent, tx, ty, tw, th);\n\t\t\t\t\t\t} else if (gf_isom_get_sample_group_info(file, trackNum, 1, GF_ISOM_SAMPLE_GROUP_TRIF, &is_default, &data, &tsize)) {\n\t\t\t\t\t\t\tfprintf(stderr, \"\\tHEVC Tile track containing a tile set\\n\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfprintf(stderr, \"\\tHEVC Tile track without tiling info\\n\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (!hevccfg && !lhvccfg) {\n\t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"\\tNon-compliant HEVC track: No hvcC or shcC found in sample description\\n\"));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (gf_isom_get_reference_count(file, trackNum, GF_ISOM_REF_SABT)) {\n\t\t\t\t\t\tfprintf(stderr, \"\\tHEVC Tile base track\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tif (hevccfg) {\n\t\t\t\t\t\tdump_hevc_track_info(file, trackNum, hevccfg\n#if !defined(GPAC_DISABLE_AV_PARSERS) && !defined(GPAC_DISABLE_HEVC)\n\t\t\t\t\t\t\t, &hevc_state\n#endif\n\t\t\t\t\t\t);\n\t\t\t\t\t\tgf_odf_hevc_cfg_del(hevccfg);\n\t\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tif (lhvccfg) {\n\t\t\t\t\t\tdump_hevc_track_info(file, trackNum, lhvccfg\n#if !defined(GPAC_DISABLE_AV_PARSERS) && !defined(GPAC_DISABLE_HEVC)\n\t\t\t\t\t\t\t, &hevc_state\n#endif\n\t\t\t\t\t\t);\n\t\t\t\t\t\tgf_odf_hevc_cfg_del(lhvccfg);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (gf_isom_get_oinf_info(file, trackNum, &oinf)) {\n\t\t\t\t\t\tfprintf(stderr, \"\\n\\tOperating Points Information -\");\n\t\t\t\t\t\tfprintf(stderr, \" scalability_mask %d (\", oinf->scalability_mask);\n\t\t\t\t\t\tswitch (oinf->scalability_mask) {\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tfprintf(stderr, \"Multiview\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\tfprintf(stderr, \"Spatial scalability\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 8:\n\t\t\t\t\t\t\tfprintf(stderr, \"Auxilary\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tfprintf(stderr, \"unknown\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//TODO: need to dump more info ?\n\t\t\t\t\t\tfprintf(stderr, \") num_profile_tier_level %d \", gf_list_count(oinf->profile_tier_levels) );\n\t\t\t\t\t\tfprintf(stderr, \" num_operating_points %d dependency layers %d \\n\", gf_list_count(oinf->operating_points), gf_list_count(oinf->dependency_layers) );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*OGG media*/\n\t\t\t\telse if (esd->decoderConfig->objectTypeIndication==GF_CODECID_THEORA) {\n\t\t\t\t\tchar *szName;\n\t\t\t\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\t\t\t\tif (!strnicmp((char *) &esd->decoderConfig->decoderSpecificInfo->data[3], \"theora\", 6)) szName = \"Theora\";\n\t\t\t\t\telse szName = \"Unknown\";\n\t\t\t\t\tfprintf(stderr, \"Ogg/%s video / GPAC Mux  - Visual Size %d x %d\\n\", szName, w, h);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t//check if we know this codec from its OTI\n\t\t\t\t\tu32 codec_id = gf_codecid_from_oti(GF_STREAM_VISUAL, esd->decoderConfig->objectTypeIndication);\n\t\t\t\t\tif (codec_id) {\n\t\t\t\t\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\t\t\t\t\tfprintf(stderr, \"%s - Visual Size %d x %d\\n\", gf_codecid_name(codec_id), w, h);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!w || !h) {\n\t\t\t\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\t\t\t\tfprintf(stderr, \"Visual Size %d x %d\\n\", w, h);\n\t\t\t\t}\n\t\t\t\tif (gf_isom_get_rvc_config(file, trackNum, 1, &rvc_predef, NULL, NULL, NULL)==GF_OK) {\n\t\t\t\t\tfprintf(stderr, \"Has RVC signaled - Predefined configuration %d\\n\", rvc_predef);\n\t\t\t\t}\n\n\t\t\t} else if (esd->decoderConfig->streamType==GF_STREAM_AUDIO) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\tGF_M4ADecSpecInfo a_cfg;\n\t\t\t\tGF_Err e;\n\t\t\t\tu32 oti;\n#endif\n\t\t\t\tu32 codec_id;\n\t\t\t\tBool is_mp2 = GF_FALSE;\n\t\t\t\tswitch (esd->decoderConfig->objectTypeIndication) {\n\t\t\t\tcase GF_CODECID_AAC_MPEG2_MP:\n\t\t\t\tcase GF_CODECID_AAC_MPEG2_LCP:\n\t\t\t\tcase GF_CODECID_AAC_MPEG2_SSRP:\n\t\t\t\t\tis_mp2 = GF_TRUE;\n\t\t\t\tcase GF_CODECID_AAC_MPEG4:\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\tif (!esd->decoderConfig->decoderSpecificInfo)\n\t\t\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t\telse\n\t\t\t\t\t\te = gf_m4a_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &a_cfg);\n\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Corrupted AAC Config\\n\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchar *signaling = \"implicit\";\n\t\t\t\t\t\tchar *heaac = \"\";\n\t\t\t\t\t\tif (!is_mp2 && a_cfg.has_sbr) {\n\t\t\t\t\t\t\tif (a_cfg.has_ps) heaac = \"(HE-AAC v2) \";\n\t\t\t\t\t\t\telse heaac = \"(HE-AAC v1) \";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (a_cfg.base_object_type==2) {\n\t\t\t\t\t\t\tif (a_cfg.has_ps || a_cfg.has_sbr)\n\t\t\t\t\t\t\t\tsignaling = \"backward compatible\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsignaling = \"hierarchical\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfprintf(stderr, \"%s (AOT=%d %s) %s- %d Channel(s) - SampleRate %d\", gf_m4a_object_type_name(a_cfg.base_object_type), a_cfg.base_object_type, signaling, heaac, a_cfg.nb_chan, a_cfg.base_sr);\n\t\t\t\t\t\tif (is_mp2) fprintf(stderr, \" (MPEG-2 Signaling)\");\n\t\t\t\t\t\tif (a_cfg.has_sbr) fprintf(stderr, \" - SBR: SampleRate %d Type %s\", a_cfg.sbr_sr, gf_m4a_object_type_name(a_cfg.sbr_object_type));\n\t\t\t\t\t\tif (a_cfg.has_ps) fprintf(stderr, \" - PS\");\n\t\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t\t}\n#else\n\t\t\t\t\tfprintf(stderr, \"MPEG-2/4 Audio - %d Channels - SampleRate %d\\n\", nb_ch, sr);\n#endif\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_CODECID_MPEG2_PART3:\n\t\t\t\tcase GF_CODECID_MPEG_AUDIO:\n\t\t\t\t\tif (msub_type == GF_ISOM_SUBTYPE_MPEG4_CRYP) {\n\t\t\t\t\t\tfprintf(stderr, \"MPEG-1/2 Audio - %d Channels - SampleRate %d\\n\", nb_ch, sr);\n\t\t\t\t\t} else {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\t\tGF_ISOSample *samp = gf_isom_get_sample(file, trackNum, 1, &oti);\n\t\t\t\t\t\tif (samp) {\n\t\t\t\t\t\t\tu32 mhdr = GF_4CC((u8)samp->data[0], (u8)samp->data[1], (u8)samp->data[2], (u8)samp->data[3]);\n\t\t\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\t\t\t\t\t\tfprintf(stderr, \"%s Audio - %d Channel(s) - SampleRate %d - Layer %d\\n\",\n\t\t\t\t\t\t\t        gf_mp3_version_name(mhdr),\n\t\t\t\t\t\t\t        gf_mp3_num_channels(mhdr),\n\t\t\t\t\t\t\t        gf_mp3_sampling_rate(mhdr),\n\t\t\t\t\t\t\t        gf_mp3_layer(mhdr)\n\t\t\t\t\t\t\t       );\n\t\t\t\t\t\t\tgf_isom_sample_del(&samp);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error fetching sample: %s\\n\", gf_error_to_string(gf_isom_last_error(file)) ));\n\t\t\t\t\t\t}\n#else\n\t\t\t\t\t\tfprintf(stderr, \"MPEG-1/2 Audio - %d Channels - SampleRate %d\\n\", nb_ch, sr);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_CODECID_EVRC:\n\t\t\t\t\tfprintf(stderr, \"EVRC Audio - Sample Rate 8000 - 1 channel\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_CODECID_SMV:\n\t\t\t\t\tfprintf(stderr, \"SMV Audio - Sample Rate 8000 - 1 channel\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_CODECID_QCELP:\n\t\t\t\t\tfprintf(stderr, \"QCELP Audio - Sample Rate 8000 - 1 channel\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t/*packetVideo hack for EVRC...*/\n\t\t\t\tcase GF_CODECID_EVRC_PV:\n\t\t\t\t\tif (esd->decoderConfig->decoderSpecificInfo && (esd->decoderConfig->decoderSpecificInfo->dataLength==8)\n\t\t\t\t\t        && !strnicmp((char *)esd->decoderConfig->decoderSpecificInfo->data, \"pvmm\", 4)) {\n\t\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\t\t\t\t\tfprintf(stderr, \"EVRC Audio (PacketVideo Mux) - Sample Rate 8000 - 1 channel\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tcodec_id = gf_codecid_from_oti(GF_STREAM_AUDIO, esd->decoderConfig->objectTypeIndication);\n\t\t\t\t\tif (codec_id) {\n\t\t\t\t\t\tfprintf(stderr, \"%s - Sample Rate %d - %d channel(s)\\n\", gf_codecid_name(codec_id), sr, nb_ch);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (esd->decoderConfig->streamType==GF_STREAM_SCENE) {\n\t\t\t\tif (esd->decoderConfig->objectTypeIndication<=4) {\n\t\t\t\t\tGF_BIFSConfig *b_cfg = gf_odf_get_bifs_config(esd->decoderConfig->decoderSpecificInfo, esd->decoderConfig->objectTypeIndication);\n\t\t\t\t\tfprintf(stderr, \"BIFS Scene description - %s stream\\n\", b_cfg->elementaryMasks ? \"Animation\" : \"Command\");\n\t\t\t\t\tif (full_dump && !b_cfg->elementaryMasks) {\n\t\t\t\t\t\tfprintf(stderr, \"\\tWidth %d Height %d Pixel Metrics %s\\n\", b_cfg->pixelWidth, b_cfg->pixelHeight, b_cfg->pixelMetrics ? \"yes\" : \"no\");\n\t\t\t\t\t}\n\t\t\t\t\tgf_odf_desc_del((GF_Descriptor *)b_cfg);\n\t\t\t\t} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_AFX) {\n\t\t\t\t\tu8 tag = esd->decoderConfig->decoderSpecificInfo ? esd->decoderConfig->decoderSpecificInfo->data[0] : 0xFF;\n\t\t\t\t\tconst char *afxtype = gf_stream_type_afx_name(tag);\n\t\t\t\t\tfprintf(stderr, \"AFX Stream - type %s (%d)\\n\", afxtype, tag);\n\t\t\t\t} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_FONT) {\n\t\t\t\t\tfprintf(stderr, \"Font Data stream\\n\");\n\t\t\t\t} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_LASER) {\n\t\t\t\t\tGF_LASERConfig l_cfg;\n\t\t\t\t\tgf_odf_get_laser_config(esd->decoderConfig->decoderSpecificInfo, &l_cfg);\n\t\t\t\t\tfprintf(stderr, \"LASER Stream - %s\\n\", l_cfg.newSceneIndicator ? \"Full Scene\" : \"Scene Segment\");\n\t\t\t\t} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_TEXT_MPEG4) {\n\t\t\t\t\tfprintf(stderr, \"MPEG-4 Streaming Text stream\\n\");\n\t\t\t\t} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_SYNTHESIZED_TEXTURE) {\n\t\t\t\t\tfprintf(stderr, \"Synthetized Texture stream stream\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tM4_LOG(GF_LOG_WARNING, (\"Unknown Systems stream OTI %d\\n\", esd->decoderConfig->objectTypeIndication));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*sync is only valid if we open all tracks to take care of default MP4 sync..*/\n\t\t\tif (!full_dump) {\n\t\t\t\tif (dump_m4sys) {\n\t\t\t\t\tif (!esd->OCRESID || (esd->OCRESID == esd->ESID))\n\t\t\t\t\t\tfprintf(stderr, \"Self-synchronized\\n\");\n\t\t\t\t\telse\n\t\t\t\t\t\tfprintf(stderr, \"Synchronized on stream %d\\n\", esd->OCRESID);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"\\tDecoding Buffer size %d - Bitrate: avg %d - max %d kbps\\n\", esd->decoderConfig->bufferSizeDB, esd->decoderConfig->avgBitrate/1000, esd->decoderConfig->maxBitrate/1000);\n\t\t\t\tif (esd->dependsOnESID)\n\t\t\t\t\tfprintf(stderr, \"\\tDepends on stream %d for decoding\\n\", esd->dependsOnESID);\n\t\t\t\telse\n\t\t\t\t\tfprintf(stderr, \"\\tNo stream dependencies for decoding\\n\");\n\n\t\t\t\tfprintf(stderr, \"\\tStreamPriority %d\\n\", esd->streamPriority);\n\t\t\t\tif (esd->URLString) fprintf(stderr, \"\\tRemote Data Source %s\\n\", esd->URLString);\n\t\t\t}\n\t\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\t\t}\n\t} else if (msub_type == GF_ISOM_SUBTYPE_AV01) {\n\t\tGF_AV1Config *av1c;\n\t\tu32 w, h;\n\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\tfprintf(stderr, \"\\tAOM AV1 stream - Resolution %d x %d\\n\", w, h);\n\n\t\tav1c = gf_isom_av1_config_get(file, trackNum, 1);\n\t\tfprintf(stderr, \"\\tversion=%u, profile=%u, level_idx0=%u, tier=%u\\n\", (u32)av1c->version, (u32)av1c->seq_profile, (u32)av1c->seq_level_idx_0, (u32)av1c->seq_tier_0);\n\t\tfprintf(stderr, \"\\thigh_bitdepth=%u, twelve_bit=%u, monochrome=%u\\n\", (u32)av1c->high_bitdepth, (u32)av1c->twelve_bit, (u32)av1c->monochrome);\n\t\tfprintf(stderr, \"\\tchroma: subsampling_x=%u, subsampling_y=%u, sample_position=%u\\n\", (u32)av1c->chroma_subsampling_x, (u32)av1c->chroma_subsampling_y, (u32)av1c->chroma_sample_position);\n\n\t\tif (av1c->initial_presentation_delay_present)\n\t\t\tfprintf(stderr, \"\\tInitial presentation delay %u\\n\", (u32) av1c->initial_presentation_delay_minus_one+1);\n\n\t\tcount = gf_list_count(av1c->obu_array);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tu8 hash[20];\n\t\t\tGF_AV1_OBUArrayEntry *obu = gf_list_get(av1c->obu_array, i);\n\t\t\tgf_sha1_csum((u8*)obu->obu, (u32)obu->obu_length, hash);\n\t\t\tfprintf(stderr, \"\\tOBU#%d %s hash: \", i+1, gf_av1_get_obu_name(obu->obu_type) );\n\t\t\tfor (j=0; j<20; j++) fprintf(stderr, \"%02X\", hash[j]);\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t}\n\t\tgf_odf_av1_cfg_del(av1c);\n\t} else if (msub_type == GF_ISOM_SUBTYPE_3GP_H263) {\n\t\tu32 w, h;\n\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\tfprintf(stderr, \"\\t3GPP H263 stream - Resolution %d x %d\\n\", w, h);\n\t} else if (msub_type == GF_ISOM_SUBTYPE_MJP2) {\n\t\tu32 w, h;\n\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\tfprintf(stderr, \"\\tMotionJPEG2000 stream - Resolution %d x %d\\n\", w, h);\n\t} else if ((msub_type == GF_ISOM_SUBTYPE_3GP_AMR) || (msub_type == GF_ISOM_SUBTYPE_3GP_AMR_WB)) {\n\t\tfprintf(stderr, \"\\t3GPP AMR%s stream - Sample Rate %d - %d channel(s) %d bps\\n\", (msub_type == GF_ISOM_SUBTYPE_3GP_AMR_WB) ? \" Wide Band\" : \"\", sr, nb_ch, (u32) bps);\n\t} else if (msub_type == GF_ISOM_SUBTYPE_3GP_EVRC) {\n\t\tfprintf(stderr, \"\\t3GPP EVRC stream - Sample Rate %d - %d channel(s) %d bps\\n\", sr, nb_ch, (u32) bps);\n\t} else if (msub_type == GF_ISOM_SUBTYPE_3GP_QCELP) {\n\t\tfprintf(stderr, \"\\t3GPP QCELP stream - Sample Rate %d - %d channel(s) %d bps\\n\", sr, nb_ch, (u32) bps);\n\t} else if (msub_type == GF_ISOM_SUBTYPE_MP3) {\n\t\tfprintf(stderr, \"\\tMPEG 1/2 Audio stream - Sample Rate %d - %d channel(s) %d bps\\n\", sr, nb_ch, (u32) bps);\n\t} else if ((msub_type == GF_ISOM_SUBTYPE_AC3) || (msub_type == GF_ISOM_SUBTYPE_EC3)) {\n\t\tu32 br = 0;\n\t\tconst char *lfe = \"\";\n\t\tBool is_ec3 = (msub_type == GF_ISOM_SUBTYPE_EC3) ? GF_TRUE : GF_FALSE;\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tGF_AC3Config *ac3 = gf_isom_ac3_config_get(file, trackNum, 1);\n\t\tif (ac3) {\n\t\t\tnb_ch = gf_ac3_get_channels(ac3->streams[0].acmod);\n\t\t\tfor (i=0; i<ac3->streams[0].nb_dep_sub; ++i) {\n\t\t\t\tassert(ac3->streams[0].nb_dep_sub == 1);\n\t\t\t\tnb_ch += gf_ac3_get_channels(ac3->streams[0].chan_loc);\n\t\t\t}\n\t\t\tif (ac3->streams[0].lfon) lfe = \".1\";\n\t\t\tbr = ac3->is_ec3 ? ac3->brcode : gf_ac3_get_bitrate(ac3->brcode);\n\t\t\tis_ec3 = ac3->is_ec3;\n\t\t\tgf_free(ac3);\n\t\t}\n#endif\n\t\tfprintf(stderr, \"\\t%s stream - Sample Rate %d - %d%s channel(s) - bitrate %d\\n\", is_ec3 ? \"EC-3\" : \"AC-3\", sr, nb_ch, lfe, br);\n\t} else if (msub_type == GF_ISOM_SUBTYPE_3GP_SMV) {\n\t\tfprintf(stderr, \"\\t3GPP SMV stream - Sample Rate %d - %d channel(s) %d bits per samples\\n\", sr, nb_ch, (u32) bps);\n\t} else if (msub_type == GF_ISOM_SUBTYPE_3GP_DIMS) {\n\t\tu32 w, h;\n\t\tGF_DIMSDescription dims;\n\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\n\t\tgf_isom_get_dims_description(file, trackNum, 1, &dims);\n\t\tfprintf(stderr, \"\\t3GPP DIMS stream - size %d x %d - Profile %d - Level %d\\n\", w, h, dims.profile, dims.level);\n\t\tfprintf(stderr, \"\\tpathComponents: %d - useFullRequestHost: %s\\n\", dims.pathComponents, dims.fullRequestHost ? \"yes\" : \"no\");\n\t\tfprintf(stderr, \"\\tstream type: %s - redundant: %s\\n\", dims.streamType ? \"primary\" : \"secondary\", (dims.containsRedundant==1) ? \"main\" : ((dims.containsRedundant==2) ? \"redundant\" : \"main+redundant\") );\n\t\tif (dims.textEncoding[0]) fprintf(stderr, \"\\ttext encoding %s\\n\", dims.textEncoding);\n\t\tif (dims.contentEncoding[0]) fprintf(stderr, \"\\tcontent encoding %s\\n\", dims.contentEncoding);\n\t\tif (dims.content_script_types) fprintf(stderr, \"\\tscript languages %s\\n\", dims.content_script_types);\n\t} else if (mtype==GF_ISOM_MEDIA_HINT) {\n\t\tu32 refTrack;\n\t\ts32 refCount = gf_isom_get_reference_count(file, trackNum, GF_ISOM_REF_HINT);\n\t\tif (refCount>0) {\n\t\t\tfprintf(stderr, \"Streaming Hint Track for track%s \", (refCount>1) ? \"s\" :\"\");\n\t\t\tfor (i=0; i<(u32) refCount; i++) {\n\t\t\t\tgf_isom_get_reference(file, trackNum, GF_ISOM_REF_HINT, i+1, &refTrack);\n\t\t\t\tif (i) fprintf(stderr, \" - \");\n\t\t\t\tfprintf(stderr, \"ID %d\", gf_isom_get_track_id(file, refTrack));\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t} else {\n\t\t\tfprintf(stderr, \"Streaming Hint Track (no refs)\\n\");\n\t\t}\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\t\trefCount = gf_isom_get_payt_count(file, trackNum);\n\t\tif (refCount>0) {\n\t\t\tfor (i=0; i<(u32) refCount; i++) {\n\t\t\t\tconst char *name = gf_isom_get_payt_info(file, trackNum, i+1, &refTrack);\n\t\t\t\tfprintf(stderr, \"\\tPayload ID %d: type %s\\n\", refTrack, name);\n\t\t\t}\n\t\t}\n#endif\n\t} else if (mtype==GF_ISOM_MEDIA_FLASH) {\n\t\tfprintf(stderr, \"Macromedia Flash Movie\\n\");\n\t} else if ((mtype==GF_ISOM_MEDIA_TEXT) || (mtype==GF_ISOM_MEDIA_SUBT) || (mtype==GF_ISOM_MEDIA_MPEG_SUBT)) {\n\t\tu32 w, h;\n\t\ts16 l;\n\t\ts32 tx, ty;\n\t\tconst char *content_encoding = NULL;\n\t\tconst char *mime = NULL;\n\t\tconst char *config  = NULL;\n\t\tconst char *_namespace = NULL;\n\t\tconst char *schema_loc = NULL;\n\t\tconst char *auxiliary_mimes = NULL;\n\t\tgf_isom_get_track_layout_info(file, trackNum, &w, &h, &tx, &ty, &l);\n\t\tif (msub_type == GF_ISOM_SUBTYPE_SBTT) {\n\t\t\tgf_isom_stxt_get_description(file, trackNum, 1, &mime, &content_encoding, &config);\n\t\t\tfprintf(stderr, \"Textual Subtitle Stream \");\n\t\t\tfprintf(stderr, \"- mime %s\", mime);\n\t\t\tif (content_encoding != NULL) {\n\t\t\t\tfprintf(stderr, \" - encoding %s\", content_encoding);\n\t\t\t}\n\t\t\tif (config != NULL) {\n\t\t\t\tfprintf(stderr, \" - %d bytes config\", (u32) strlen(config));\n\t\t\t}\n\t\t} else if (msub_type == GF_ISOM_SUBTYPE_STXT) {\n\t\t\tgf_isom_stxt_get_description(file, trackNum, 1, &mime, &content_encoding, &config);\n\t\t\tfprintf(stderr, \"Simple Timed Text Stream \");\n\t\t\tfprintf(stderr, \"- mime %s\", mime);\n\t\t\tif (content_encoding != NULL) {\n\t\t\t\tfprintf(stderr, \" - encoding %s\", content_encoding);\n\t\t\t}\n\t\t\tif (config != NULL) {\n\t\t\t\tfprintf(stderr, \" - %d bytes config\", (u32) strlen(config));\n\t\t\t}\n\t\t} else if (msub_type == GF_ISOM_SUBTYPE_STPP) {\n\t\t\tgf_isom_xml_subtitle_get_description(file, trackNum, 1, &_namespace, &schema_loc, &auxiliary_mimes);\n\t\t\tfprintf(stderr, \"XML Subtitle Stream \");\n\t\t\tfprintf(stderr, \"- namespace %s\", _namespace);\n\t\t\tif (schema_loc != NULL) {\n\t\t\t\tfprintf(stderr, \" - schema-location %s\", schema_loc);\n\t\t\t}\n\t\t\tif (auxiliary_mimes != NULL) {\n\t\t\t\tfprintf(stderr, \" - auxiliary-mime-types %s\", auxiliary_mimes);\n\t\t\t}\n\t\t} else {\n\t\t\tfprintf(stderr, \"Unknown Text Stream\");\n\t\t}\n\t\tfprintf(stderr, \"\\n Size %d x %d - Translation X=%d Y=%d - Layer %d\\n\", w, h, tx, ty, l);\n\t} else if (mtype == GF_ISOM_MEDIA_META) {\n\t\tconst char *content_encoding = NULL;\n\t\tif (msub_type == GF_ISOM_SUBTYPE_METT) {\n\t\t\tconst char *mime = NULL;\n\t\t\tconst char *config  = NULL;\n\t\t\tgf_isom_stxt_get_description(file, trackNum, 1, &mime, &content_encoding, &config);\n\t\t\tfprintf(stderr, \"Textual Metadata Stream - mime %s\", mime);\n\t\t\tif (content_encoding != NULL) {\n\t\t\t\tfprintf(stderr, \" - encoding %s\", content_encoding);\n\t\t\t}\n\t\t\tif (config != NULL) {\n\t\t\t\tfprintf(stderr, \" - %d bytes config\", (u32) strlen(config));\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t} else if (msub_type == GF_ISOM_SUBTYPE_METX) {\n\t\t\tconst char *_namespace = NULL;\n\t\t\tconst char *schema_loc = NULL;\n\t\t\tgf_isom_get_xml_metadata_description(file, trackNum, 1, &_namespace, &schema_loc, &content_encoding);\n\t\t\tfprintf(stderr, \"XML Metadata Stream - namespace %s\", _namespace);\n\t\t\tif (content_encoding != NULL) {\n\t\t\t\tfprintf(stderr, \" - encoding %s\", content_encoding);\n\t\t\t}\n\t\t\tif (schema_loc != NULL) {\n\t\t\t\tfprintf(stderr, \" - schema-location %s\", schema_loc);\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t} else {\n\t\t\tfprintf(stderr, \"Unknown Metadata Stream\\n\");\n\t\t}\n\t} else if ((msub_type==GF_ISOM_SUBTYPE_VVC1) || (msub_type==GF_ISOM_SUBTYPE_VVI1)) {\n\t\tGF_VVCConfig *vvccfg;\n\t\tu32 w, h;\n#if !defined(GPAC_DISABLE_AV_PARSERS)\n\t\tVVCState *vvc_state;\n\t\tGF_SAFEALLOC(vvc_state, VVCState);\n\t\tif (vvc_state) vvc_state->sps_active_idx = -1;\n#endif\n\n\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\tfprintf(stderr, \"VVC Video - Visual Size %d x %d\\n\", w, h);\n\t\tvvccfg = gf_isom_vvc_config_get(file, trackNum, 1);\n\n\t\tif (!vvccfg) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Non-compliant VVC track: No vvcC found in sample description\\n\"));\n\t\t} else {\n\t\t\tdump_vvc_track_info(file, trackNum, vvccfg\n#if !defined(GPAC_DISABLE_AV_PARSERS)\n\t\t\t\t, vvc_state\n#endif\n\t\t\t);\n\t\t\tgf_odf_vvc_cfg_del(vvccfg);\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t}\n#if !defined(GPAC_DISABLE_AV_PARSERS)\n\t\tif (vvc_state) gf_free(vvc_state);\n#endif\n\t} else if ((msub_type == GF_ISOM_SUBTYPE_MH3D_MHA1) || (msub_type == GF_ISOM_SUBTYPE_MH3D_MHA2)\n\t\t\t|| (msub_type == GF_ISOM_SUBTYPE_MH3D_MHM1) || (msub_type == GF_ISOM_SUBTYPE_MH3D_MHM2)\n\t) {\n\t\tconst u8 *compat_profiles;\n\t\tu32 nb_compat_profiles;\n\t\tBool valid = GF_FALSE;\n\t\tBool allow_inband = GF_FALSE;\n\t\tif ( (msub_type == GF_ISOM_SUBTYPE_MH3D_MHM1) || (msub_type == GF_ISOM_SUBTYPE_MH3D_MHM2))\n\t\t\tallow_inband = GF_TRUE;\n\n\t\tfprintf(stderr, \"\\tMPEG-H Audio stream - Sample Rate %d\\n\", sr);\n\n\t\tesd = gf_media_map_esd(file, trackNum, 1);\n\t\tif (!esd || !esd->decoderConfig || !esd->decoderConfig->decoderSpecificInfo\n\t\t\t|| !esd->decoderConfig->decoderSpecificInfo->data\n\t\t) {\n\t\t\tif (allow_inband) {\n\t\t\t\tGF_ISOSample *samp = gf_isom_get_sample(file, trackNum, 1, NULL);\n\t\t\t\tif (samp) {\n\t\t\t\t\tu64 ch_layout=0;\n\t\t\t\t\ts32 PL = gf_mpegh_get_mhas_pl(samp->data, samp->dataLength, &ch_layout);\n\t\t\t\t\tif (PL>=0) {\n\t\t\t\t\t\tfprintf(stderr, \"\\tProfileLevelIndication: 0x%02X\", PL);\n\t\t\t\t\t\tif (ch_layout)\n\t\t\t\t\t\t\tfprintf(stderr, \" - Reference Channel Layout %s\", gf_audio_fmt_get_layout_name(ch_layout) );\n\t\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tgf_isom_sample_del(&samp);\n\t\t\t\t}\n\t\t\t\tvalid = GF_TRUE;\n\t\t\t}\n\t\t} else if (esd->decoderConfig->decoderSpecificInfo->dataLength>=5) {\n\t\t\tfprintf(stderr, \"\\tProfileLevelIndication: 0x%02X - Reference Channel Layout %s\\n\", esd->decoderConfig->decoderSpecificInfo->data[1]\n\t\t\t\t, gf_audio_fmt_get_layout_name_from_cicp(esd->decoderConfig->decoderSpecificInfo->data[2])\n\t\t\t);\n\t\t\tvalid = GF_TRUE;\n\t\t}\n\t\tif (!valid) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Invalid MPEG-H audio config\\n\"));\n\t\t}\n\t\tif (esd) gf_odf_desc_del((GF_Descriptor *)esd);\n\t\tcompat_profiles = gf_isom_get_mpegh_compatible_profiles(file, trackNum, 1, &nb_compat_profiles);\n\t\tfor (i=0; i<nb_compat_profiles; i++) {\n\t\t\tif (!i)\n\t\t\t\tfprintf(stderr, \"\\tCompatible profiles:\");\n\t\t\tfprintf(stderr, \" 0x%02X\", compat_profiles[i]);\n\t\t}\n\t\tif (i) fprintf(stderr, \"\\n\");\n\t} else if (msub_type==GF_ISOM_SUBTYPE_MLPA) {\n\t\tu32 fmt, prate;\n\t\tif (gf_isom_truehd_config_get(file, trackNum, 1, &fmt, &prate) != GF_OK) {\n\t\t\tfprintf(stderr, \"\\tInvalid TrueHD audio config\\n\");\n\t\t}\n\t\tfprintf(stderr, \"TrueHD Audio stream - Sample Rate %u - channels %u - format %u peak rate %u\\n\", sr, nb_ch, fmt, prate);\n\t} else if (codecid) {\n\t\tif (gf_isom_is_video_handler_type(mtype) ) {\n\t\t\tu32 w, h;\n\t\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\t\tfprintf(stderr, \"%s - Resolution %d x %d\\n\", gf_codecid_name(codecid), w, h);\n\t\t} else if (mtype==GF_ISOM_MEDIA_AUDIO) {\n\t\t\tgf_isom_get_audio_info(file, trackNum, 1, &sr, &nb_ch, NULL);\n\t\t\tfprintf(stderr, \"%s - Sample Rate %d - %d channel(s)\\n\", gf_codecid_name(codecid), sr, nb_ch);\n\t\t} else {\n\t\t\tfprintf(stderr, \"%s\\n\", gf_codecid_name(codecid) );\n\t\t}\n\t} else if (pfmt) {\n\t\tu32 w, h;\n\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\tfprintf(stderr, \"Raw video %s - Resolution %d x %d\\n\", gf_pixel_fmt_name(pfmt), w, h);\n\t} else if (msub_type==GF_QT_SUBTYPE_TMCD) {\n\t\tu32 stsd_idx;\n\t\tGF_ISOSample *sample = gf_isom_get_sample(file, trackNum, 1, &stsd_idx);\n\t\tfprintf(stderr, \"Time Code stream\\n\");\n\t\tif (sample) {\n\t\t\tchar szTimecode[100];\n\t\t\tu32 tmcd_flags, tmcd_num, tmcd_den, tmcd_fpt;\n\n\t\t\tgf_isom_get_tmcd_config(file, trackNum, stsd_idx, &tmcd_flags, &tmcd_num, &tmcd_den, &tmcd_fpt);\n\n\t\t\tgf_inspect_format_timecode(sample->data, sample->dataLength, tmcd_flags, tmcd_num, tmcd_den, tmcd_fpt, szTimecode);\n\n\t\t\tgf_isom_sample_del(&sample);\n\t\t\tfprintf(stderr, \"\\tFirst timecode: %s\\n\", szTimecode);\n\t\t}\n\t} else {\n\t\tGF_GenericSampleDescription *udesc;\n\n\t\tudesc = gf_isom_get_generic_sample_description(file, trackNum, 1);\n\t\tif (udesc) {\n\t\t\tif (gf_isom_is_video_handler_type(mtype) ) {\n                fprintf(stderr, \"%s - Compressor \\\"%s\\\" - Resolution %d x %d\\n\",\n\t\t\t\t\t\t( (mtype == GF_ISOM_MEDIA_VISUAL ? \"Visual\" : \"Auxiliary Video\") ),\n                        udesc->compressor_name, udesc->width, udesc->height);\n\t\t\t} else if (mtype==GF_ISOM_MEDIA_AUDIO) {\n\t\t\t\tfprintf(stderr, \"Audio - Sample Rate %d - %d channel(s)\\n\", udesc->samplerate, udesc->nb_channels);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"Unknown media type\\n\");\n\t\t\t}\n\t\t\tif (udesc->vendor_code)\n\t\t\t\tfprintf(stderr, \"\\tVendor code \\\"%s\\\" - Version %d - revision %d\\n\", gf_4cc_to_str(udesc->vendor_code), udesc->version, udesc->revision);\n\n\t\t\tif (udesc->extension_buf) {\n\t\t\t\tfprintf(stderr, \"\\tCodec configuration data size: %d bytes\\n\", udesc->extension_buf_size);\n\t\t\t\tgf_free(udesc->extension_buf);\n\t\t\t}\n\t\t\tgf_free(udesc);\n\t\t} else {\n\t\t\tfprintf(stderr, \"Unknown track type\\n\");\n\t\t}\n\t}\n\n\n\t/*Crypto info*/\n\tif (gf_isom_is_track_encrypted(file, trackNum)) {\n\t\tconst char *scheme_URI, *KMS_URI;\n\t\tu32 scheme_type, version;\n\t\tu32 IV_size;\n\t\tBool use_sel_enc;\n\n\t\tif (gf_isom_is_ismacryp_media(file, trackNum, 1)) {\n\t\t\tgf_isom_get_ismacryp_info(file, trackNum, 1, NULL, &scheme_type, &version, &scheme_URI, &KMS_URI, &use_sel_enc, &IV_size, NULL);\n\t\t\tfprintf(stderr, \"\\n\\tProtected by ISMA E&A scheme %s (version %d)\\n\", gf_4cc_to_str(scheme_type), version);\n\t\t\tif (scheme_URI) fprintf(stderr, \"scheme location: %s\\n\", scheme_URI);\n\t\t\tif (KMS_URI) {\n\t\t\t\tif (!strnicmp(KMS_URI, \"(key)\", 5)) fprintf(stderr, \"\\tKMS location: key in file\\n\");\n\t\t\t\telse fprintf(stderr, \"\\tKMS location: %s\\n\", KMS_URI);\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\tSelective Encryption: %s\\n\", use_sel_enc ? \"Yes\" : \"No\");\n\t\t\tif (IV_size) fprintf(stderr, \"\\tInitialization Vector size: %d bits\\n\", IV_size*8);\n\t\t} else if (gf_isom_is_omadrm_media(file, trackNum, 1)) {\n\t\t\tconst char *textHdrs;\n\t\t\tu32 enc_type, hdr_len;\n\t\t\tu64 orig_len;\n\t\t\tgf_isom_get_omadrm_info(file, trackNum, 1, NULL, &scheme_type, &version, &scheme_URI, &KMS_URI, &textHdrs, &hdr_len, &orig_len, &enc_type, &use_sel_enc, &IV_size, NULL);\n\t\t\tfprintf(stderr, \"\\n\\tProtected by OMA DRM scheme %s (version %d)\\n\", gf_4cc_to_str(scheme_type), version);\n\t\t\tfprintf(stderr, \"\\tRights Issuer: %s\\n\", KMS_URI);\n\t\t\tfprintf(stderr, \"\\tContent ID: %s\\n\", scheme_URI);\n\t\t\tif (textHdrs) {\n\t\t\t\tu32 offset;\n\t\t\t\tconst char *start = textHdrs;\n\t\t\t\tfprintf(stderr, \"\\tOMA Textual Headers:\\n\");\n\t\t\t\ti=0;\n\t\t\t\toffset=0;\n\t\t\t\twhile (i<hdr_len) {\n\t\t\t\t\tif (start[i]==0) {\n\t\t\t\t\t\tfprintf(stderr, \"\\t\\t%s\\n\", start+offset);\n\t\t\t\t\t\toffset=i+1;\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\\\tt%s\\n\", start+offset);\n\t\t\t}\n\t\t\tif (orig_len) fprintf(stderr, \"\\tOriginal media size \"LLD\"\\n\", orig_len);\n\t\t\tfprintf(stderr, \"\\tEncryption algorithm %s\\n\", (enc_type==1) ? \"AEA 128 CBC\" : (enc_type ? \"AEA 128 CTR\" : \"None\"));\n\t\t\tfprintf(stderr, \"\\tSelective Encryption: %s\\n\", use_sel_enc ? \"Yes\" : \"No\");\n\t\t\tif (IV_size) fprintf(stderr, \"\\tInitialization Vector size: %d bits\\n\", IV_size*8);\n\t\t} else if(gf_isom_is_cenc_media(file, trackNum, 1)) {\n\t\t\tconst u8 *def_key;\n\t\t\tu32 def_key_size;\n\t\t\tBool IsEncrypted;\n\t\t\tu8 crypt_byte_block, skip_byte_block;\n\t\t\tIV_size = 0;\n\t\t\tgf_isom_get_cenc_info(file, trackNum, 1, NULL, &scheme_type, &version);\n\n\t\t\tgf_isom_cenc_get_default_info(file, trackNum, 1, NULL, &IsEncrypted, &crypt_byte_block, &skip_byte_block, &def_key, &def_key_size);\n\n\t\t\tfprintf(stderr, \"\\n\\tProtected by CENC scheme %s version 0x%08X\", gf_4cc_to_str(scheme_type), version);\n\n\t\t\tif (crypt_byte_block && skip_byte_block)\n\t\t\t\tfprintf(stderr, \" - Pattern %d:%d\", (u32) skip_byte_block, (u32) crypt_byte_block);\n\t\t\tif (def_key && def_key[0])\n\t\t\t\tfprintf(stderr, \" - MultiKey\");\n\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t\tdump_key_info(def_key, def_key_size, IsEncrypted);\n\n\t\t} else if(gf_isom_is_adobe_protection_media(file, trackNum, 1)) {\n\t\t\tgf_isom_get_adobe_protection_info(file, trackNum, 1, NULL, &scheme_type, &version, NULL);\n\t\t\tfprintf(stderr, \"\\nProtected by Adobe scheme %s (version %d)\\n\", gf_4cc_to_str(scheme_type), version);\n\t\t} else {\n\t\t\tfprintf(stderr, \"\\nProtected by unknown scheme %s\\n\", gf_4cc_to_str(gf_isom_is_media_encrypted(file, trackNum, 0) ));\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t}\n\n\tif ( gf_media_get_rfc_6381_codec_name(file, trackNum, szCodec, GF_FALSE, GF_FALSE) == GF_OK) {\n\t\tfprintf(stderr, \"\\tRFC6381 Codec Parameters: %s\\n\", szCodec);\n\t}\n\n\n\tDumpMetaItem(file, 0, trackNum, \"\\tTrack Meta\");\n\n\tgf_isom_get_track_switch_group_count(file, trackNum, &alt_group, &nb_groups);\n\tif (alt_group) {\n\t\tfprintf(stderr, \"Alternate Group ID %d\\n\", alt_group);\n\t\tfor (i=0; i<nb_groups; i++) {\n\t\t\tu32 nb_crit, switchGroupID;\n\t\t\tconst u32 *criterias = gf_isom_get_track_switch_parameter(file, trackNum, i+1, &switchGroupID, &nb_crit);\n\t\t\tif (!nb_crit) {\n\t\t\t\tfprintf(stderr, \"\\tNo criteria in %s group\\n\", switchGroupID ? \"switch\" : \"alternate\");\n\t\t\t} else {\n\t\t\t\tif (switchGroupID) {\n\t\t\t\t\tfprintf(stderr, \"\\tSwitchGroup ID %d criterias: \", switchGroupID);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"\\tAlternate Group criterias: \");\n\t\t\t\t}\n\t\t\t\tfor (j=0; j<nb_crit; j++) {\n\t\t\t\t\tif (j) fprintf(stderr, \" \");\n\t\t\t\t\tfprintf(stderr, \"%s\", gf_4cc_to_str(criterias[j]) );\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch (gf_isom_has_sync_points(file, trackNum)) {\n\tcase 0:\n\t\tfprintf(stderr, \"\\tAll samples are sync\\n\");\n\t\tbreak;\n\tcase 1:\n\t{\n\t\tu32 nb_sync = gf_isom_get_sync_point_count(file, trackNum) - 1;\n\t\tif (! nb_sync) {\n\t\t\tfprintf(stderr, \"\\tOnly one sync sample\\n\");\n\t\t} else {\n\t\t\tfprintf(stderr, \"\\tAverage GOP length: %d samples\\n\", gf_isom_get_sample_count(file, trackNum) / nb_sync);\n\t\t}\n\t}\n\tbreak;\n\tcase 2:\n\t\tfprintf(stderr, \"\\tNo sync sample found\\n\");\n\t\tbreak;\n\t}\n\tfprintf(stderr, \"\\tMax sample duration: %d / %d\\n\", gf_isom_get_max_sample_delta(file, trackNum), timescale);\n\n\tif (!full_dump) {\n\t\tfprintf(stderr, \"\\n\");\n\t\treturn;\n\t}\n\n\tdur = size = 0;\n\tmax_rate = rate = 0;\n\ttime_slice = 0;\n\tts = gf_isom_get_media_timescale(file, trackNum);\n\tcsize = gf_isom_get_constant_sample_size(file, trackNum);\n\tcdur = gf_isom_get_constant_sample_duration(file, trackNum);\n\tcount = gf_isom_get_sample_count(file, trackNum);\n\tif (csize && cdur) {\n\t\tsize = count * csize;\n\t\tdur = cdur * count;\n\t} else {\n\n\t\tfor (j=0; j<count; j++) {\n\t\t\tGF_ISOSample *samp;\n\t\t\tif (is_od_track) {\n\t\t\t\tsamp = gf_isom_get_sample(file, trackNum, j+1, NULL);\n\t\t\t} else {\n\t\t\t\tsamp = gf_isom_get_sample_info(file, trackNum, j+1, NULL, NULL);\n\t\t\t}\n\t\t\tif (!samp) {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Failed to fetch sample %d\\n\", j+1));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdur = samp->DTS+samp->CTS_Offset;\n\t\t\tsize += samp->dataLength;\n\t\t\trate += samp->dataLength;\n\t\t\tif (samp->DTS - time_slice > ts) {\n\t\t\t\tDouble max_tmp = rate * ts / (samp->DTS - time_slice);\n\t\t\t\tif (max_rate < max_tmp )\n\t\t\t\t\tmax_rate = max_tmp;\n\n\t\t\t\trate = 0;\n\t\t\t\ttime_slice = samp->DTS;\n\t\t\t}\n\t\t\tgf_isom_sample_del(&samp);\n\t\t}\n\t}\n\tfprintf(stderr, \"\\nComputed info from media:\\n\");\n\tif (csize && cdur) {\n\t\tfprintf(stderr, \"\\tConstant sample size %d bytes and dur %d / %d\\n\", csize, cdur, ts);\n\t}\n\tscale = 1000.0 / ts;\n\tdur = (u64) (scale * dur);\n\tfprintf(stderr, \"\\tTotal size \"LLU\" bytes - Total samples duration \"LLU\" ms\\n\", size, dur);\n\tif (!dur) {\n\t\tfprintf(stderr, \"\\n\");\n\t\treturn;\n\t}\n\t/*rate in byte, dur is in ms*/\n\trate = 8000.0 * size / dur;\n\n\tif (!max_rate)\n\t\tmax_rate = rate;\n\telse\n\t\tmax_rate *= 8.0;\n\n\tif (rate >= 1500) {\n\t\tfprintf(stderr, \"\\tAverage rate %.2f kbps - Max Rate %.2f kbps\\n\", rate/1000, max_rate/1000);\n\t} else {\n\t\tfprintf(stderr, \"\\tAverage rate %.2f bps - Max Rate %.2f bps\\n\", rate, max_rate);\n\t}\n\n\t{\n\t\tu32 dmin, dmax, davg, smin, smax, savg;\n\t\tgf_isom_get_chunks_infos(file, trackNum, &dmin, &davg, &dmax, &smin, &savg, &smax);\n\t\tfprintf(stderr, \"\\tChunk durations: min %d ms - max %d ms - average %d ms\\n\", (1000*dmin)/ts, (1000*dmax)/ts, (1000*davg)/ts);\n\t\tfprintf(stderr, \"\\tChunk sizes (bytes): min %d - max %d - average %d\\n\", smin, smax, savg);\n\t}\n\tfprintf(stderr, \"\\n\");\n\n\tcount = gf_isom_get_chapter_count(file, trackNum);\n\tif (count) {\n\t\tconst char *name;\n\t\tu64 time;\n\t\tfprintf(stderr, \"\\nChapters:\\n\");\n\t\tfor (j=0; j<count; j++) {\n\t\t\tgf_isom_get_chapter(file, trackNum, j+1, &time, &name);\n\t\t\tfprintf(stderr, \"\\tChapter #%d - %s - \\\"%s\\\"\\n\", j+1, format_duration(time, 1000, szDur), name);\n\t\t}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 2883,
    "critical_vars": [
      "av1c"
    ],
    "function": "DumpTrackInfo",
    "filename": "gpac/CVE-2021-32138/CVE-2021-32138_CWE-476_289ffce3e0d224d314f5f92a744d5fe35999f20b_filedump.c.diff",
    "function_code": "void gf_inspect_format_timecode(const u8 *data, u32 size, u32 tmcd_flags, u32 tc_num, u32 tc_den, u32 tmcd_fpt, char szFmt[100]);\n\nvoid DumpTrackInfo(GF_ISOFile *file, GF_ISOTrackID trackID, Bool full_dump, Bool is_track_num, Bool dump_m4sys)\n{\n\tchar szCodec[RFC6381_CODEC_NAME_SIZE_MAX];\n\tDouble scale, max_rate, rate;\n\tBool is_od_track = 0;\n\tu32 trackNum, i, j, ts, mtype, msub_type, timescale, sr, nb_ch, count, alt_group, nb_groups, nb_edits, cdur, csize, bps, pfmt, codecid;\n\tu64 time_slice, dur, size;\n\ts32 cts_shift;\n\tGF_ESD *esd;\n\tchar szDur[50];\n\tchar *lang;\n\n\tif (!is_track_num) {\n\t\ttrackNum = gf_isom_get_track_by_id(file, trackID);\n\t} else {\n\t\ttrackNum = trackID;\n\t\ttrackID = gf_isom_get_track_id(file, trackNum);\n\t}\n\tif (!trackNum) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"No track with ID %d found\\n\", trackID));\n\t\treturn;\n\t}\n\n\ttimescale = gf_isom_get_media_timescale(file, trackNum);\n\tfprintf(stderr, \"# Track %d Info - ID %d - TimeScale %d\\n\", trackNum, trackID, timescale);\n\n\tdur = gf_isom_get_media_original_duration(file, trackNum);\n\tsize = gf_isom_get_media_duration(file, trackNum);\n\tfprintf(stderr, \"Media Duration %s \", format_duration(dur, timescale, szDur));\n\tif (dur != size)\n\t\tfprintf(stderr, \" (recomputed %s)\", format_duration(size, timescale, szDur));\n\tfprintf(stderr, \"\\n\");\n\n\tif (gf_isom_check_data_reference(file, trackNum, 1) != GF_OK) {\n\t\tM4_LOG(GF_LOG_WARNING, (\"Track uses external data reference not supported by GPAC!\\n\"));\n\t}\n\n\tnb_edits = gf_isom_get_edits_count(file, trackNum);\n\tif (nb_edits)\n\t\tfprintf(stderr, \"Track has %d edits: track duration is %s\\n\", nb_edits, format_duration(gf_isom_get_track_duration(file, trackNum), gf_isom_get_timescale(file), szDur));\n\n\tcts_shift = gf_isom_get_composition_offset_shift(file, trackNum);\n\tif (cts_shift)\n\t\tfprintf(stderr, \"Track composition offset shift (negative CTS offset): %d\\n\", cts_shift);\n\n\tif (gf_isom_is_track_in_root_od(file, trackNum) ) fprintf(stderr, \"Track is present in Root OD\\n\");\n\tif (!gf_isom_is_track_enabled(file, trackNum))  fprintf(stderr, \"Track is disabled\\n\");\n\tgf_isom_get_media_language(file, trackNum, &lang);\n\tfprintf(stderr, \"Media Info: Language \\\"%s (%s)\\\" - \", GetLanguage(lang), lang );\n\tgf_free(lang);\n\tmtype = gf_isom_get_media_type(file, trackNum);\n\tfprintf(stderr, \"Type \\\"%s:\", gf_4cc_to_str(mtype));\n\tmsub_type = gf_isom_get_mpeg4_subtype(file, trackNum, 1);\n\tif (!msub_type) msub_type = gf_isom_get_media_subtype(file, trackNum, 1);\n\tfprintf(stderr, \"%s\\\" - %d samples\\n\", gf_4cc_to_str(msub_type), gf_isom_get_sample_count(file, trackNum));\n\n\tpfmt = gf_pixel_fmt_from_qt_type(msub_type);\n\tcodecid = gf_codec_id_from_isobmf(msub_type);\n\n\tcount = gf_isom_get_track_kind_count(file, trackNum);\n\tfor (i = 0; i < count; i++) {\n\t\tchar *kind_scheme, *kind_value;\n\t\tgf_isom_get_track_kind(file, trackNum, i, &kind_scheme, &kind_value);\n\t\tfprintf(stderr, \"Kind: %s - %s\\n\", kind_scheme ? kind_scheme : \"null\", kind_value ? kind_value : \"null\");\n\t\tif (kind_scheme) gf_free(kind_scheme);\n\t\tif (kind_value) gf_free(kind_value);\n\t}\n\n\tif (gf_isom_is_track_fragmented(file, trackID) ) {\n\t\tu32 defaultDuration, defaultSize, defaultDescriptionIndex, defaultRandomAccess;\n\t\tu8 defaultPadding;\n\t\tu16 defaultDegradationPriority;\n\t\tu32 frag_samples;\n\t\tu64 frag_duration;\n\t\tgf_isom_get_fragmented_samples_info(file, trackID, &frag_samples, &frag_duration);\n\t\tfprintf(stderr, \"Fragmented track: %d samples - Media Duration %s\\n\", frag_samples, format_duration(frag_duration, timescale, szDur));\n\n\t\tgf_isom_get_fragment_defaults(file, trackNum, &defaultDuration, &defaultSize, &defaultDescriptionIndex, &defaultRandomAccess, &defaultPadding, &defaultDegradationPriority);\n\n\t\tfprintf(stderr, \"Fragment sample defaults: duration %d size %d stsd %d sync %d padding %d degradation_priority %d\\n\",\n\t\t\t\tdefaultDuration, defaultSize, defaultDescriptionIndex, defaultRandomAccess,\n\t\t\t\t(u32) defaultPadding, (u32) defaultDegradationPriority\n\t\t);\n\t}\n\n\tif (!gf_isom_is_self_contained(file, trackNum, 1)) {\n\t\tconst char *url, *urn;\n\t\tgf_isom_get_data_reference(file, trackNum, 1, &url, &urn);\n\t\tfprintf(stderr, \"Media Data Location: %s\\n\", url ? url : urn);\n\t}\n\n\tif (full_dump) {\n\t\tconst char *handler_name;\n\t\tgf_isom_get_handler_name(file, trackNum, &handler_name);\n\t\tfprintf(stderr, \"Handler name: %s\\n\", handler_name);\n\t}\n\n\tprint_udta(file, trackNum, GF_FALSE);\n\n\tif (gf_isom_is_video_handler_type(mtype) ) {\n\t\ts32 tx, ty;\n\t\tu32 w, h;\n\t\tu16 bit_depth;\n\n\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\tgf_isom_get_visual_bit_depth(file, trackNum, 1, &bit_depth);\n\t\tfprintf(stderr, \"Visual Sample Entry Info: width=%d height=%d (depth=%d bits)\\n\", w, h, (int)bit_depth);\n\n\t\tgf_isom_get_track_layout_info(file, trackNum, &w, &h, &tx, &ty, NULL);\n\t\tfprintf(stderr, \"Visual Track layout: x=%d y=%d width=%d height=%d\\n\", tx, ty, w, h);\n\t}\n\n\tgf_isom_get_audio_info(file, trackNum, 1, &sr, &nb_ch, &bps);\n\tgf_isom_set_nalu_extract_mode(file, trackNum, GF_ISOM_NALU_EXTRACT_INSPECT);\n\n\tmsub_type = gf_isom_get_media_subtype(file, trackNum, 1);\n\tif (msub_type==GF_ISOM_SUBTYPE_MPEG4_CRYP)\n\t\tgf_isom_get_original_format_type(file, trackNum, 1, &msub_type);\n\n\tif ((msub_type==GF_ISOM_SUBTYPE_MPEG4)\n\t        || (msub_type==GF_ISOM_SUBTYPE_AVC_H264)\n\t        || (msub_type==GF_ISOM_SUBTYPE_AVC2_H264)\n\t        || (msub_type==GF_ISOM_SUBTYPE_AVC3_H264)\n\t        || (msub_type==GF_ISOM_SUBTYPE_AVC4_H264)\n\t        || (msub_type==GF_ISOM_SUBTYPE_SVC_H264)\n\t        || (msub_type==GF_ISOM_SUBTYPE_MVC_H264)\n\t        || (msub_type==GF_ISOM_SUBTYPE_LSR1)\n\t        || (msub_type==GF_ISOM_SUBTYPE_HVC1)\n\t        || (msub_type==GF_ISOM_SUBTYPE_HEV1)\n\t        || (msub_type==GF_ISOM_SUBTYPE_HVC2)\n\t        || (msub_type==GF_ISOM_SUBTYPE_HEV2)\n\t        || (msub_type==GF_ISOM_SUBTYPE_LHV1)\n\t        || (msub_type==GF_ISOM_SUBTYPE_LHE1)\n\t        || (msub_type==GF_ISOM_SUBTYPE_HVT1)\n\t   )  {\n\t\tesd = gf_isom_get_esd(file, trackNum, 1);\n\t\tif (!esd || !esd->decoderConfig) {\n\t\t\tM4_LOG(GF_LOG_WARNING, (\"WARNING: Broken MPEG-4 Track\\n\"));\n\t\t\tif (esd) gf_odf_desc_del((GF_Descriptor *)esd);\n\t\t} else {\n\t\t\tconst char *st = gf_stream_type_name(esd->decoderConfig->streamType);\n\t\t\tif (dump_m4sys) {\n\t\t\t\tif (st) {\n\t\t\t\t\tfprintf(stderr, \"MPEG-4 Config%s%s Stream - ObjectTypeIndication 0x%02x\\n\",\n\t\t\t\t\t\t\tfull_dump ? \"\\n\\t\" : \": \", st, esd->decoderConfig->objectTypeIndication);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"MPEG-4 Config%sStream Type 0x%02x - ObjectTypeIndication 0x%02x\\n\",\n\t\t\t\t\t\t\tfull_dump ? \"\\n\\t\" : \": \", esd->decoderConfig->streamType, esd->decoderConfig->objectTypeIndication);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (esd->decoderConfig->streamType==GF_STREAM_OD)\n\t\t\t\tis_od_track=1;\n\n\t\t\tif (esd->decoderConfig->streamType==GF_STREAM_VISUAL) {\n\t\t\t\tu32 w, h;\n\t\t\t\tu16 rvc_predef;\n\t\t\t\tw = h = 0;\n\t\t\t\tif (esd->decoderConfig->objectTypeIndication==GF_CODECID_MPEG4_PART2) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\tif (!esd->decoderConfig->decoderSpecificInfo) {\n#else\n\t\t\t\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\t\t\t\tfprintf(stderr, \"MPEG-4 Visual Size %d x %d\\n\", w, h);\n#endif\n\t\t\t\t\t\tM4_LOG(GF_LOG_WARNING, (\"Non-compliant MPEG-4 Visual track: video_object_layer infos not found in sample description\\n\"));\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\t} else {\n\t\t\t\t\t\tGF_M4VDecSpecInfo dsi;\n\t\t\t\t\t\tgf_m4v_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &dsi);\n\t\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\t\t\t\t\tw = dsi.width;\n\t\t\t\t\t\th = dsi.height;\n\t\t\t\t\t\tfprintf(stderr, \"MPEG-4 Visual Size %d x %d - %s\\n\", w, h, gf_m4v_get_profile_name(dsi.VideoPL));\n\t\t\t\t\t\tif (dsi.par_den && dsi.par_num) {\n\t\t\t\t\t\t\tu32 tw, th;\n\t\t\t\t\t\t\tgf_isom_get_track_layout_info(file, trackNum, &tw, &th, NULL, NULL, NULL);\n\t\t\t\t\t\t\tfprintf(stderr, \"Pixel Aspect Ratio %d:%d - Indicated track size %d x %d\\n\", dsi.par_num, dsi.par_den, tw, th);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t} else if (gf_isom_get_avc_svc_type(file, trackNum, 1) != GF_ISOM_AVCTYPE_NONE) {\n\t\t\t\t\tGF_AVCConfig *avccfg, *svccfg, *mvccfg;\n\n\t\t\t\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\t\t\t\tfprintf(stderr, \"AVC/H264 Video - Visual Size %d x %d\\n\", w, h);\n\n\t\t\t\t\tavccfg = gf_isom_avc_config_get(file, trackNum, 1);\n\t\t\t\t\tsvccfg = gf_isom_svc_config_get(file, trackNum, 1);\n\t\t\t\t\tmvccfg = gf_isom_mvc_config_get(file, trackNum, 1);\n\t\t\t\t\tif (!avccfg && !svccfg && !mvccfg) {\n\t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"\\tNon-compliant AVC track: SPS/PPS not found in sample description\\n\"));\n\t\t\t\t\t} else if (avccfg) {\n\t\t\t\t\t\tfprintf(stderr, \"\\tAVC Info: %d SPS - %d PPS\", gf_list_count(avccfg->sequenceParameterSets) , gf_list_count(avccfg->pictureParameterSets) );\n\t\t\t\t\t\tfprintf(stderr, \" - Profile %s @ Level %g\\n\", gf_avc_get_profile_name(avccfg->AVCProfileIndication), ((Double)avccfg->AVCLevelIndication)/10.0 );\n\t\t\t\t\t\tfprintf(stderr, \"\\tNAL Unit length bits: %d\\n\", 8*avccfg->nal_unit_size);\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\t\tfor (i=0; i<gf_list_count(avccfg->sequenceParameterSets); i++) {\n\t\t\t\t\t\t\ts32 par_n, par_d;\n\t\t\t\t\t\t\tGF_NALUFFParam *slc = gf_list_get(avccfg->sequenceParameterSets, i);\n\t\t\t\t\t\t\tgf_avc_get_sps_info(slc->data, slc->size, NULL, NULL, NULL, &par_n, &par_d);\n\t\t\t\t\t\t\tif ((par_n>0) && (par_d>0)) {\n\t\t\t\t\t\t\t\tu32 tw, th;\n\t\t\t\t\t\t\t\tgf_isom_get_track_layout_info(file, trackNum, &tw, &th, NULL, NULL, NULL);\n\t\t\t\t\t\t\t\tfprintf(stderr, \"\\tPixel Aspect Ratio %d:%d - Indicated track size %d x %d\\n\", par_n, par_d, tw, th);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!full_dump) break;\n\t\t\t\t\t\t}\n#endif\n\n\t\t\t\t\t\tif (avccfg->chroma_bit_depth) {\n\t\t\t\t\t\t\tfprintf(stderr, \"\\tChroma format %s - Luma bit depth %d - chroma bit depth %d\\n\", gf_avc_hevc_get_chroma_format_name(avccfg->chroma_format), avccfg->luma_bit_depth, avccfg->chroma_bit_depth);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tprint_config_hash(avccfg->sequenceParameterSets, \"SPS\");\n\t\t\t\t\t\tprint_config_hash(avccfg->pictureParameterSets, \"PPS\");\n\n\t\t\t\t\t\tgf_odf_avc_cfg_del(avccfg);\n\t\t\t\t\t}\n\t\t\t\t\tif (svccfg) {\n\t\t\t\t\t\tfprintf(stderr, \"\\n\\tSVC Info: %d SPS - %d PPS - Profile %s @ Level %g\\n\", gf_list_count(svccfg->sequenceParameterSets) , gf_list_count(svccfg->pictureParameterSets), gf_avc_get_profile_name(svccfg->AVCProfileIndication), ((Double)svccfg->AVCLevelIndication)/10.0 );\n\t\t\t\t\t\tfprintf(stderr, \"\\tSVC NAL Unit length bits: %d\\n\", 8*svccfg->nal_unit_size);\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\t\tfor (i=0; i<gf_list_count(svccfg->sequenceParameterSets); i++) {\n\t\t\t\t\t\t\tGF_NALUFFParam *slc = gf_list_get(svccfg->sequenceParameterSets, i);\n\t\t\t\t\t\t\tif (slc) {\n\t\t\t\t\t\t\t\ts32 par_n, par_d;\n\t\t\t\t\t\t\t\tu32 s_w, s_h, sps_id;\n\t\t\t\t\t\t\t\tgf_avc_get_sps_info(slc->data, slc->size, &sps_id, &s_w, &s_h, &par_n, &par_d);\n\t\t\t\t\t\t\t\tfprintf(stderr, \"\\t\\tSPS ID %d - Visual Size %d x %d\\n\", sps_id, s_w, s_h);\n\t\t\t\t\t\t\t\tif ((par_n>0) && (par_d>0)) {\n\t\t\t\t\t\t\t\t\tu32 tw, th;\n\t\t\t\t\t\t\t\t\tgf_isom_get_track_layout_info(file, trackNum, &tw, &th, NULL, NULL, NULL);\n\t\t\t\t\t\t\t\t\tfprintf(stderr, \"\\tPixel Aspect Ratio %d:%d - Indicated track size %d x %d\\n\", par_n, par_d, tw, th);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t\tprint_config_hash(svccfg->sequenceParameterSets, \"SPS\");\n\t\t\t\t\t\tprint_config_hash(svccfg->pictureParameterSets, \"PPS\");\n\t\t\t\t\t\tprint_config_hash(svccfg->sequenceParameterSetExtensions, \"SPSEx\");\n\n\t\t\t\t\t\tgf_odf_avc_cfg_del(svccfg);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (mvccfg) {\n\t\t\t\t\t\tfprintf(stderr, \"\\n\\tMVC Info: %d SPS - %d PPS - Profile %s @ Level %g\\n\", gf_list_count(mvccfg->sequenceParameterSets) , gf_list_count(mvccfg->pictureParameterSets), gf_avc_get_profile_name(mvccfg->AVCProfileIndication), ((Double)mvccfg->AVCLevelIndication)/10.0 );\n\t\t\t\t\t\tfprintf(stderr, \"\\tMVC NAL Unit length bits: %d\\n\", 8*mvccfg->nal_unit_size);\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\t\tfor (i=0; i<gf_list_count(mvccfg->sequenceParameterSets); i++) {\n\t\t\t\t\t\t\tGF_NALUFFParam *slc = gf_list_get(mvccfg->sequenceParameterSets, i);\n\t\t\t\t\t\t\tif (slc) {\n\t\t\t\t\t\t\t\tu32 s_w, s_h, sps_id;\n\t\t\t\t\t\t\t\ts32 par_n, par_d;\n\t\t\t\t\t\t\t\tgf_avc_get_sps_info(slc->data, slc->size, &sps_id, &s_w, &s_h, &par_n, &par_d);\n\t\t\t\t\t\t\t\tfprintf(stderr, \"\\t\\tSPS ID %d - Visual Size %d x %d\\n\", sps_id, s_w, s_h);\n\t\t\t\t\t\t\t\tif ((par_n>0) && (par_d>0)) {\n\t\t\t\t\t\t\t\t\tu32 tw, th;\n\t\t\t\t\t\t\t\t\tgf_isom_get_track_layout_info(file, trackNum, &tw, &th, NULL, NULL, NULL);\n\t\t\t\t\t\t\t\t\tfprintf(stderr, \"\\tPixel Aspect Ratio %d:%d - Indicated track size %d x %d\\n\", par_n, par_d, tw, th);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t\tprint_config_hash(mvccfg->sequenceParameterSets, \"SPS\");\n\t\t\t\t\t\tprint_config_hash(mvccfg->pictureParameterSets, \"PPS\");\n\t\t\t\t\t\tgf_odf_avc_cfg_del(mvccfg);\n\t\t\t\t\t}\n\n\t\t\t\t} else if ((esd->decoderConfig->objectTypeIndication==GF_CODECID_HEVC)\n\t\t\t\t           || (esd->decoderConfig->objectTypeIndication==GF_CODECID_LHVC)\n\t\t\t\t          ) {\n\t\t\t\t\tGF_HEVCConfig *hevccfg, *lhvccfg;\n\t\t\t\t\tGF_OperatingPointsInformation *oinf;\n#if !defined(GPAC_DISABLE_AV_PARSERS) && !defined(GPAC_DISABLE_HEVC)\n\t\t\t\t\tHEVCState hevc_state;\n\t\t\t\t\tmemset(&hevc_state, 0, sizeof(HEVCState));\n\t\t\t\t\thevc_state.sps_active_idx = -1;\n#endif\n\n\t\t\t\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\t\t\t\tfprintf(stderr, \"HEVC Video - Visual Size %d x %d\\n\", w, h);\n\t\t\t\t\thevccfg = gf_isom_hevc_config_get(file, trackNum, 1);\n\t\t\t\t\tlhvccfg = gf_isom_lhvc_config_get(file, trackNum, 1);\n\n\t\t\t\t\tif (msub_type==GF_ISOM_SUBTYPE_HVT1) {\n\t\t\t\t\t\tconst u8 *data;\n\t\t\t\t\t\tu32 tsize;\n\t\t\t\t\t\tu32  is_default, tx,ty,tw,th, id, independent;\n\t\t\t\t\t\tBool full_frame;\n\t\t\t\t\t\tif (gf_isom_get_tile_info(file, trackNum, 1, &is_default, &id, &independent, &full_frame, &tx, &ty, &tw, &th)) {\n\t\t\t\t\t\t\tfprintf(stderr, \"\\tHEVC Tile - ID %d independent %d (x,y,w,h)=%d,%d,%d,%d \\n\", id, independent, tx, ty, tw, th);\n\t\t\t\t\t\t} else if (gf_isom_get_sample_group_info(file, trackNum, 1, GF_ISOM_SAMPLE_GROUP_TRIF, &is_default, &data, &tsize)) {\n\t\t\t\t\t\t\tfprintf(stderr, \"\\tHEVC Tile track containing a tile set\\n\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfprintf(stderr, \"\\tHEVC Tile track without tiling info\\n\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (!hevccfg && !lhvccfg) {\n\t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"\\tNon-compliant HEVC track: No hvcC or shcC found in sample description\\n\"));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (gf_isom_get_reference_count(file, trackNum, GF_ISOM_REF_SABT)) {\n\t\t\t\t\t\tfprintf(stderr, \"\\tHEVC Tile base track\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tif (hevccfg) {\n\t\t\t\t\t\tdump_hevc_track_info(file, trackNum, hevccfg\n#if !defined(GPAC_DISABLE_AV_PARSERS) && !defined(GPAC_DISABLE_HEVC)\n\t\t\t\t\t\t\t, &hevc_state\n#endif\n\t\t\t\t\t\t);\n\t\t\t\t\t\tgf_odf_hevc_cfg_del(hevccfg);\n\t\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tif (lhvccfg) {\n\t\t\t\t\t\tdump_hevc_track_info(file, trackNum, lhvccfg\n#if !defined(GPAC_DISABLE_AV_PARSERS) && !defined(GPAC_DISABLE_HEVC)\n\t\t\t\t\t\t\t, &hevc_state\n#endif\n\t\t\t\t\t\t);\n\t\t\t\t\t\tgf_odf_hevc_cfg_del(lhvccfg);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (gf_isom_get_oinf_info(file, trackNum, &oinf)) {\n\t\t\t\t\t\tfprintf(stderr, \"\\n\\tOperating Points Information -\");\n\t\t\t\t\t\tfprintf(stderr, \" scalability_mask %d (\", oinf->scalability_mask);\n\t\t\t\t\t\tswitch (oinf->scalability_mask) {\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tfprintf(stderr, \"Multiview\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\tfprintf(stderr, \"Spatial scalability\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 8:\n\t\t\t\t\t\t\tfprintf(stderr, \"Auxilary\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tfprintf(stderr, \"unknown\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//TODO: need to dump more info ?\n\t\t\t\t\t\tfprintf(stderr, \") num_profile_tier_level %d \", gf_list_count(oinf->profile_tier_levels) );\n\t\t\t\t\t\tfprintf(stderr, \" num_operating_points %d dependency layers %d \\n\", gf_list_count(oinf->operating_points), gf_list_count(oinf->dependency_layers) );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*OGG media*/\n\t\t\t\telse if (esd->decoderConfig->objectTypeIndication==GF_CODECID_THEORA) {\n\t\t\t\t\tchar *szName;\n\t\t\t\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\t\t\t\tif (!strnicmp((char *) &esd->decoderConfig->decoderSpecificInfo->data[3], \"theora\", 6)) szName = \"Theora\";\n\t\t\t\t\telse szName = \"Unknown\";\n\t\t\t\t\tfprintf(stderr, \"Ogg/%s video / GPAC Mux  - Visual Size %d x %d\\n\", szName, w, h);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t//check if we know this codec from its OTI\n\t\t\t\t\tu32 codec_id = gf_codecid_from_oti(GF_STREAM_VISUAL, esd->decoderConfig->objectTypeIndication);\n\t\t\t\t\tif (codec_id) {\n\t\t\t\t\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\t\t\t\t\tfprintf(stderr, \"%s - Visual Size %d x %d\\n\", gf_codecid_name(codec_id), w, h);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!w || !h) {\n\t\t\t\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\t\t\t\tfprintf(stderr, \"Visual Size %d x %d\\n\", w, h);\n\t\t\t\t}\n\t\t\t\tif (gf_isom_get_rvc_config(file, trackNum, 1, &rvc_predef, NULL, NULL, NULL)==GF_OK) {\n\t\t\t\t\tfprintf(stderr, \"Has RVC signaled - Predefined configuration %d\\n\", rvc_predef);\n\t\t\t\t}\n\n\t\t\t} else if (esd->decoderConfig->streamType==GF_STREAM_AUDIO) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\tGF_M4ADecSpecInfo a_cfg;\n\t\t\t\tGF_Err e;\n\t\t\t\tu32 oti;\n#endif\n\t\t\t\tu32 codec_id;\n\t\t\t\tBool is_mp2 = GF_FALSE;\n\t\t\t\tswitch (esd->decoderConfig->objectTypeIndication) {\n\t\t\t\tcase GF_CODECID_AAC_MPEG2_MP:\n\t\t\t\tcase GF_CODECID_AAC_MPEG2_LCP:\n\t\t\t\tcase GF_CODECID_AAC_MPEG2_SSRP:\n\t\t\t\t\tis_mp2 = GF_TRUE;\n\t\t\t\tcase GF_CODECID_AAC_MPEG4:\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\tif (!esd->decoderConfig->decoderSpecificInfo)\n\t\t\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t\telse\n\t\t\t\t\t\te = gf_m4a_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &a_cfg);\n\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Corrupted AAC Config\\n\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchar *signaling = \"implicit\";\n\t\t\t\t\t\tchar *heaac = \"\";\n\t\t\t\t\t\tif (!is_mp2 && a_cfg.has_sbr) {\n\t\t\t\t\t\t\tif (a_cfg.has_ps) heaac = \"(HE-AAC v2) \";\n\t\t\t\t\t\t\telse heaac = \"(HE-AAC v1) \";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (a_cfg.base_object_type==2) {\n\t\t\t\t\t\t\tif (a_cfg.has_ps || a_cfg.has_sbr)\n\t\t\t\t\t\t\t\tsignaling = \"backward compatible\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsignaling = \"hierarchical\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfprintf(stderr, \"%s (AOT=%d %s) %s- %d Channel(s) - SampleRate %d\", gf_m4a_object_type_name(a_cfg.base_object_type), a_cfg.base_object_type, signaling, heaac, a_cfg.nb_chan, a_cfg.base_sr);\n\t\t\t\t\t\tif (is_mp2) fprintf(stderr, \" (MPEG-2 Signaling)\");\n\t\t\t\t\t\tif (a_cfg.has_sbr) fprintf(stderr, \" - SBR: SampleRate %d Type %s\", a_cfg.sbr_sr, gf_m4a_object_type_name(a_cfg.sbr_object_type));\n\t\t\t\t\t\tif (a_cfg.has_ps) fprintf(stderr, \" - PS\");\n\t\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t\t}\n#else\n\t\t\t\t\tfprintf(stderr, \"MPEG-2/4 Audio - %d Channels - SampleRate %d\\n\", nb_ch, sr);\n#endif\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_CODECID_MPEG2_PART3:\n\t\t\t\tcase GF_CODECID_MPEG_AUDIO:\n\t\t\t\t\tif (msub_type == GF_ISOM_SUBTYPE_MPEG4_CRYP) {\n\t\t\t\t\t\tfprintf(stderr, \"MPEG-1/2 Audio - %d Channels - SampleRate %d\\n\", nb_ch, sr);\n\t\t\t\t\t} else {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\t\tGF_ISOSample *samp = gf_isom_get_sample(file, trackNum, 1, &oti);\n\t\t\t\t\t\tif (samp) {\n\t\t\t\t\t\t\tu32 mhdr = GF_4CC((u8)samp->data[0], (u8)samp->data[1], (u8)samp->data[2], (u8)samp->data[3]);\n\t\t\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\t\t\t\t\t\tfprintf(stderr, \"%s Audio - %d Channel(s) - SampleRate %d - Layer %d\\n\",\n\t\t\t\t\t\t\t        gf_mp3_version_name(mhdr),\n\t\t\t\t\t\t\t        gf_mp3_num_channels(mhdr),\n\t\t\t\t\t\t\t        gf_mp3_sampling_rate(mhdr),\n\t\t\t\t\t\t\t        gf_mp3_layer(mhdr)\n\t\t\t\t\t\t\t       );\n\t\t\t\t\t\t\tgf_isom_sample_del(&samp);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error fetching sample: %s\\n\", gf_error_to_string(gf_isom_last_error(file)) ));\n\t\t\t\t\t\t}\n#else\n\t\t\t\t\t\tfprintf(stderr, \"MPEG-1/2 Audio - %d Channels - SampleRate %d\\n\", nb_ch, sr);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_CODECID_EVRC:\n\t\t\t\t\tfprintf(stderr, \"EVRC Audio - Sample Rate 8000 - 1 channel\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_CODECID_SMV:\n\t\t\t\t\tfprintf(stderr, \"SMV Audio - Sample Rate 8000 - 1 channel\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_CODECID_QCELP:\n\t\t\t\t\tfprintf(stderr, \"QCELP Audio - Sample Rate 8000 - 1 channel\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t/*packetVideo hack for EVRC...*/\n\t\t\t\tcase GF_CODECID_EVRC_PV:\n\t\t\t\t\tif (esd->decoderConfig->decoderSpecificInfo && (esd->decoderConfig->decoderSpecificInfo->dataLength==8)\n\t\t\t\t\t        && !strnicmp((char *)esd->decoderConfig->decoderSpecificInfo->data, \"pvmm\", 4)) {\n\t\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\t\t\t\t\tfprintf(stderr, \"EVRC Audio (PacketVideo Mux) - Sample Rate 8000 - 1 channel\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tcodec_id = gf_codecid_from_oti(GF_STREAM_AUDIO, esd->decoderConfig->objectTypeIndication);\n\t\t\t\t\tif (codec_id) {\n\t\t\t\t\t\tfprintf(stderr, \"%s - Sample Rate %d - %d channel(s)\\n\", gf_codecid_name(codec_id), sr, nb_ch);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (esd->decoderConfig->streamType==GF_STREAM_SCENE) {\n\t\t\t\tif (esd->decoderConfig->objectTypeIndication<=4) {\n\t\t\t\t\tGF_BIFSConfig *b_cfg = gf_odf_get_bifs_config(esd->decoderConfig->decoderSpecificInfo, esd->decoderConfig->objectTypeIndication);\n\t\t\t\t\tfprintf(stderr, \"BIFS Scene description - %s stream\\n\", b_cfg->elementaryMasks ? \"Animation\" : \"Command\");\n\t\t\t\t\tif (full_dump && !b_cfg->elementaryMasks) {\n\t\t\t\t\t\tfprintf(stderr, \"\\tWidth %d Height %d Pixel Metrics %s\\n\", b_cfg->pixelWidth, b_cfg->pixelHeight, b_cfg->pixelMetrics ? \"yes\" : \"no\");\n\t\t\t\t\t}\n\t\t\t\t\tgf_odf_desc_del((GF_Descriptor *)b_cfg);\n\t\t\t\t} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_AFX) {\n\t\t\t\t\tu8 tag = esd->decoderConfig->decoderSpecificInfo ? esd->decoderConfig->decoderSpecificInfo->data[0] : 0xFF;\n\t\t\t\t\tconst char *afxtype = gf_stream_type_afx_name(tag);\n\t\t\t\t\tfprintf(stderr, \"AFX Stream - type %s (%d)\\n\", afxtype, tag);\n\t\t\t\t} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_FONT) {\n\t\t\t\t\tfprintf(stderr, \"Font Data stream\\n\");\n\t\t\t\t} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_LASER) {\n\t\t\t\t\tGF_LASERConfig l_cfg;\n\t\t\t\t\tgf_odf_get_laser_config(esd->decoderConfig->decoderSpecificInfo, &l_cfg);\n\t\t\t\t\tfprintf(stderr, \"LASER Stream - %s\\n\", l_cfg.newSceneIndicator ? \"Full Scene\" : \"Scene Segment\");\n\t\t\t\t} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_TEXT_MPEG4) {\n\t\t\t\t\tfprintf(stderr, \"MPEG-4 Streaming Text stream\\n\");\n\t\t\t\t} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_SYNTHESIZED_TEXTURE) {\n\t\t\t\t\tfprintf(stderr, \"Synthetized Texture stream stream\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tM4_LOG(GF_LOG_WARNING, (\"Unknown Systems stream OTI %d\\n\", esd->decoderConfig->objectTypeIndication));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*sync is only valid if we open all tracks to take care of default MP4 sync..*/\n\t\t\tif (!full_dump) {\n\t\t\t\tif (dump_m4sys) {\n\t\t\t\t\tif (!esd->OCRESID || (esd->OCRESID == esd->ESID))\n\t\t\t\t\t\tfprintf(stderr, \"Self-synchronized\\n\");\n\t\t\t\t\telse\n\t\t\t\t\t\tfprintf(stderr, \"Synchronized on stream %d\\n\", esd->OCRESID);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"\\tDecoding Buffer size %d - Bitrate: avg %d - max %d kbps\\n\", esd->decoderConfig->bufferSizeDB, esd->decoderConfig->avgBitrate/1000, esd->decoderConfig->maxBitrate/1000);\n\t\t\t\tif (esd->dependsOnESID)\n\t\t\t\t\tfprintf(stderr, \"\\tDepends on stream %d for decoding\\n\", esd->dependsOnESID);\n\t\t\t\telse\n\t\t\t\t\tfprintf(stderr, \"\\tNo stream dependencies for decoding\\n\");\n\n\t\t\t\tfprintf(stderr, \"\\tStreamPriority %d\\n\", esd->streamPriority);\n\t\t\t\tif (esd->URLString) fprintf(stderr, \"\\tRemote Data Source %s\\n\", esd->URLString);\n\t\t\t}\n\t\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\t\t}\n\t} else if (msub_type == GF_ISOM_SUBTYPE_AV01) {\n\t\tGF_AV1Config *av1c;\n\t\tu32 w, h;\n\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\tfprintf(stderr, \"\\tAOM AV1 stream - Resolution %d x %d\\n\", w, h);\n\n\t\tav1c = gf_isom_av1_config_get(file, trackNum, 1);\n\t\tif (!av1c) {\n\t\t\tfprintf(stderr, \"\\tCorrupted av1 config\\n\");\n\t\t} else {\n\t\t\tfprintf(stderr, \"\\tversion=%u, profile=%u, level_idx0=%u, tier=%u\\n\", (u32)av1c->version, (u32)av1c->seq_profile, (u32)av1c->seq_level_idx_0, (u32)av1c->seq_tier_0);\n\t\t\tfprintf(stderr, \"\\thigh_bitdepth=%u, twelve_bit=%u, monochrome=%u\\n\", (u32)av1c->high_bitdepth, (u32)av1c->twelve_bit, (u32)av1c->monochrome);\n\t\t\tfprintf(stderr, \"\\tchroma: subsampling_x=%u, subsampling_y=%u, sample_position=%u\\n\", (u32)av1c->chroma_subsampling_x, (u32)av1c->chroma_subsampling_y, (u32)av1c->chroma_sample_position);\n\n\t\t\tif (av1c->initial_presentation_delay_present)\n\t\t\t\tfprintf(stderr, \"\\tInitial presentation delay %u\\n\", (u32) av1c->initial_presentation_delay_minus_one+1);\n\n\t\t\tcount = gf_list_count(av1c->obu_array);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tu8 hash[20];\n\t\t\t\tGF_AV1_OBUArrayEntry *obu = gf_list_get(av1c->obu_array, i);\n\t\t\t\tgf_sha1_csum((u8*)obu->obu, (u32)obu->obu_length, hash);\n\t\t\t\tfprintf(stderr, \"\\tOBU#%d %s hash: \", i+1, gf_av1_get_obu_name(obu->obu_type) );\n\t\t\t\tfor (j=0; j<20; j++) fprintf(stderr, \"%02X\", hash[j]);\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t\tgf_odf_av1_cfg_del(av1c);\n\t\t}\n\t} else if (msub_type == GF_ISOM_SUBTYPE_3GP_H263) {\n\t\tu32 w, h;\n\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\tfprintf(stderr, \"\\t3GPP H263 stream - Resolution %d x %d\\n\", w, h);\n\t} else if (msub_type == GF_ISOM_SUBTYPE_MJP2) {\n\t\tu32 w, h;\n\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\tfprintf(stderr, \"\\tMotionJPEG2000 stream - Resolution %d x %d\\n\", w, h);\n\t} else if ((msub_type == GF_ISOM_SUBTYPE_3GP_AMR) || (msub_type == GF_ISOM_SUBTYPE_3GP_AMR_WB)) {\n\t\tfprintf(stderr, \"\\t3GPP AMR%s stream - Sample Rate %d - %d channel(s) %d bps\\n\", (msub_type == GF_ISOM_SUBTYPE_3GP_AMR_WB) ? \" Wide Band\" : \"\", sr, nb_ch, (u32) bps);\n\t} else if (msub_type == GF_ISOM_SUBTYPE_3GP_EVRC) {\n\t\tfprintf(stderr, \"\\t3GPP EVRC stream - Sample Rate %d - %d channel(s) %d bps\\n\", sr, nb_ch, (u32) bps);\n\t} else if (msub_type == GF_ISOM_SUBTYPE_3GP_QCELP) {\n\t\tfprintf(stderr, \"\\t3GPP QCELP stream - Sample Rate %d - %d channel(s) %d bps\\n\", sr, nb_ch, (u32) bps);\n\t} else if (msub_type == GF_ISOM_SUBTYPE_MP3) {\n\t\tfprintf(stderr, \"\\tMPEG 1/2 Audio stream - Sample Rate %d - %d channel(s) %d bps\\n\", sr, nb_ch, (u32) bps);\n\t} else if ((msub_type == GF_ISOM_SUBTYPE_AC3) || (msub_type == GF_ISOM_SUBTYPE_EC3)) {\n\t\tu32 br = 0;\n\t\tconst char *lfe = \"\";\n\t\tBool is_ec3 = (msub_type == GF_ISOM_SUBTYPE_EC3) ? GF_TRUE : GF_FALSE;\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tGF_AC3Config *ac3 = gf_isom_ac3_config_get(file, trackNum, 1);\n\t\tif (ac3) {\n\t\t\tnb_ch = gf_ac3_get_channels(ac3->streams[0].acmod);\n\t\t\tfor (i=0; i<ac3->streams[0].nb_dep_sub; ++i) {\n\t\t\t\tassert(ac3->streams[0].nb_dep_sub == 1);\n\t\t\t\tnb_ch += gf_ac3_get_channels(ac3->streams[0].chan_loc);\n\t\t\t}\n\t\t\tif (ac3->streams[0].lfon) lfe = \".1\";\n\t\t\tbr = ac3->is_ec3 ? ac3->brcode : gf_ac3_get_bitrate(ac3->brcode);\n\t\t\tis_ec3 = ac3->is_ec3;\n\t\t\tgf_free(ac3);\n\t\t}\n#endif\n\t\tfprintf(stderr, \"\\t%s stream - Sample Rate %d - %d%s channel(s) - bitrate %d\\n\", is_ec3 ? \"EC-3\" : \"AC-3\", sr, nb_ch, lfe, br);\n\t} else if (msub_type == GF_ISOM_SUBTYPE_3GP_SMV) {\n\t\tfprintf(stderr, \"\\t3GPP SMV stream - Sample Rate %d - %d channel(s) %d bits per samples\\n\", sr, nb_ch, (u32) bps);\n\t} else if (msub_type == GF_ISOM_SUBTYPE_3GP_DIMS) {\n\t\tu32 w, h;\n\t\tGF_DIMSDescription dims;\n\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\n\t\tgf_isom_get_dims_description(file, trackNum, 1, &dims);\n\t\tfprintf(stderr, \"\\t3GPP DIMS stream - size %d x %d - Profile %d - Level %d\\n\", w, h, dims.profile, dims.level);\n\t\tfprintf(stderr, \"\\tpathComponents: %d - useFullRequestHost: %s\\n\", dims.pathComponents, dims.fullRequestHost ? \"yes\" : \"no\");\n\t\tfprintf(stderr, \"\\tstream type: %s - redundant: %s\\n\", dims.streamType ? \"primary\" : \"secondary\", (dims.containsRedundant==1) ? \"main\" : ((dims.containsRedundant==2) ? \"redundant\" : \"main+redundant\") );\n\t\tif (dims.textEncoding[0]) fprintf(stderr, \"\\ttext encoding %s\\n\", dims.textEncoding);\n\t\tif (dims.contentEncoding[0]) fprintf(stderr, \"\\tcontent encoding %s\\n\", dims.contentEncoding);\n\t\tif (dims.content_script_types) fprintf(stderr, \"\\tscript languages %s\\n\", dims.content_script_types);\n\t} else if (mtype==GF_ISOM_MEDIA_HINT) {\n\t\tu32 refTrack;\n\t\ts32 refCount = gf_isom_get_reference_count(file, trackNum, GF_ISOM_REF_HINT);\n\t\tif (refCount>0) {\n\t\t\tfprintf(stderr, \"Streaming Hint Track for track%s \", (refCount>1) ? \"s\" :\"\");\n\t\t\tfor (i=0; i<(u32) refCount; i++) {\n\t\t\t\tgf_isom_get_reference(file, trackNum, GF_ISOM_REF_HINT, i+1, &refTrack);\n\t\t\t\tif (i) fprintf(stderr, \" - \");\n\t\t\t\tfprintf(stderr, \"ID %d\", gf_isom_get_track_id(file, refTrack));\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t} else {\n\t\t\tfprintf(stderr, \"Streaming Hint Track (no refs)\\n\");\n\t\t}\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\t\trefCount = gf_isom_get_payt_count(file, trackNum);\n\t\tif (refCount>0) {\n\t\t\tfor (i=0; i<(u32) refCount; i++) {\n\t\t\t\tconst char *name = gf_isom_get_payt_info(file, trackNum, i+1, &refTrack);\n\t\t\t\tfprintf(stderr, \"\\tPayload ID %d: type %s\\n\", refTrack, name);\n\t\t\t}\n\t\t}\n#endif\n\t} else if (mtype==GF_ISOM_MEDIA_FLASH) {\n\t\tfprintf(stderr, \"Macromedia Flash Movie\\n\");\n\t} else if ((mtype==GF_ISOM_MEDIA_TEXT) || (mtype==GF_ISOM_MEDIA_SUBT) || (mtype==GF_ISOM_MEDIA_MPEG_SUBT)) {\n\t\tu32 w, h;\n\t\ts16 l;\n\t\ts32 tx, ty;\n\t\tconst char *content_encoding = NULL;\n\t\tconst char *mime = NULL;\n\t\tconst char *config  = NULL;\n\t\tconst char *_namespace = NULL;\n\t\tconst char *schema_loc = NULL;\n\t\tconst char *auxiliary_mimes = NULL;\n\t\tgf_isom_get_track_layout_info(file, trackNum, &w, &h, &tx, &ty, &l);\n\t\tif (msub_type == GF_ISOM_SUBTYPE_SBTT) {\n\t\t\tgf_isom_stxt_get_description(file, trackNum, 1, &mime, &content_encoding, &config);\n\t\t\tfprintf(stderr, \"Textual Subtitle Stream \");\n\t\t\tfprintf(stderr, \"- mime %s\", mime);\n\t\t\tif (content_encoding != NULL) {\n\t\t\t\tfprintf(stderr, \" - encoding %s\", content_encoding);\n\t\t\t}\n\t\t\tif (config != NULL) {\n\t\t\t\tfprintf(stderr, \" - %d bytes config\", (u32) strlen(config));\n\t\t\t}\n\t\t} else if (msub_type == GF_ISOM_SUBTYPE_STXT) {\n\t\t\tgf_isom_stxt_get_description(file, trackNum, 1, &mime, &content_encoding, &config);\n\t\t\tfprintf(stderr, \"Simple Timed Text Stream \");\n\t\t\tfprintf(stderr, \"- mime %s\", mime);\n\t\t\tif (content_encoding != NULL) {\n\t\t\t\tfprintf(stderr, \" - encoding %s\", content_encoding);\n\t\t\t}\n\t\t\tif (config != NULL) {\n\t\t\t\tfprintf(stderr, \" - %d bytes config\", (u32) strlen(config));\n\t\t\t}\n\t\t} else if (msub_type == GF_ISOM_SUBTYPE_STPP) {\n\t\t\tgf_isom_xml_subtitle_get_description(file, trackNum, 1, &_namespace, &schema_loc, &auxiliary_mimes);\n\t\t\tfprintf(stderr, \"XML Subtitle Stream \");\n\t\t\tfprintf(stderr, \"- namespace %s\", _namespace);\n\t\t\tif (schema_loc != NULL) {\n\t\t\t\tfprintf(stderr, \" - schema-location %s\", schema_loc);\n\t\t\t}\n\t\t\tif (auxiliary_mimes != NULL) {\n\t\t\t\tfprintf(stderr, \" - auxiliary-mime-types %s\", auxiliary_mimes);\n\t\t\t}\n\t\t} else {\n\t\t\tfprintf(stderr, \"Unknown Text Stream\");\n\t\t}\n\t\tfprintf(stderr, \"\\n Size %d x %d - Translation X=%d Y=%d - Layer %d\\n\", w, h, tx, ty, l);\n\t} else if (mtype == GF_ISOM_MEDIA_META) {\n\t\tconst char *content_encoding = NULL;\n\t\tif (msub_type == GF_ISOM_SUBTYPE_METT) {\n\t\t\tconst char *mime = NULL;\n\t\t\tconst char *config  = NULL;\n\t\t\tgf_isom_stxt_get_description(file, trackNum, 1, &mime, &content_encoding, &config);\n\t\t\tfprintf(stderr, \"Textual Metadata Stream - mime %s\", mime);\n\t\t\tif (content_encoding != NULL) {\n\t\t\t\tfprintf(stderr, \" - encoding %s\", content_encoding);\n\t\t\t}\n\t\t\tif (config != NULL) {\n\t\t\t\tfprintf(stderr, \" - %d bytes config\", (u32) strlen(config));\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t} else if (msub_type == GF_ISOM_SUBTYPE_METX) {\n\t\t\tconst char *_namespace = NULL;\n\t\t\tconst char *schema_loc = NULL;\n\t\t\tgf_isom_get_xml_metadata_description(file, trackNum, 1, &_namespace, &schema_loc, &content_encoding);\n\t\t\tfprintf(stderr, \"XML Metadata Stream - namespace %s\", _namespace);\n\t\t\tif (content_encoding != NULL) {\n\t\t\t\tfprintf(stderr, \" - encoding %s\", content_encoding);\n\t\t\t}\n\t\t\tif (schema_loc != NULL) {\n\t\t\t\tfprintf(stderr, \" - schema-location %s\", schema_loc);\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t} else {\n\t\t\tfprintf(stderr, \"Unknown Metadata Stream\\n\");\n\t\t}\n\t} else if ((msub_type==GF_ISOM_SUBTYPE_VVC1) || (msub_type==GF_ISOM_SUBTYPE_VVI1)) {\n\t\tGF_VVCConfig *vvccfg;\n\t\tu32 w, h;\n#if !defined(GPAC_DISABLE_AV_PARSERS)\n\t\tVVCState *vvc_state;\n\t\tGF_SAFEALLOC(vvc_state, VVCState);\n\t\tif (vvc_state) vvc_state->sps_active_idx = -1;\n#endif\n\n\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\tfprintf(stderr, \"VVC Video - Visual Size %d x %d\\n\", w, h);\n\t\tvvccfg = gf_isom_vvc_config_get(file, trackNum, 1);\n\n\t\tif (!vvccfg) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Non-compliant VVC track: No vvcC found in sample description\\n\"));\n\t\t} else {\n\t\t\tdump_vvc_track_info(file, trackNum, vvccfg\n#if !defined(GPAC_DISABLE_AV_PARSERS)\n\t\t\t\t, vvc_state\n#endif\n\t\t\t);\n\t\t\tgf_odf_vvc_cfg_del(vvccfg);\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t}\n#if !defined(GPAC_DISABLE_AV_PARSERS)\n\t\tif (vvc_state) gf_free(vvc_state);\n#endif\n\t} else if ((msub_type == GF_ISOM_SUBTYPE_MH3D_MHA1) || (msub_type == GF_ISOM_SUBTYPE_MH3D_MHA2)\n\t\t\t|| (msub_type == GF_ISOM_SUBTYPE_MH3D_MHM1) || (msub_type == GF_ISOM_SUBTYPE_MH3D_MHM2)\n\t) {\n\t\tconst u8 *compat_profiles;\n\t\tu32 nb_compat_profiles;\n\t\tBool valid = GF_FALSE;\n\t\tBool allow_inband = GF_FALSE;\n\t\tif ( (msub_type == GF_ISOM_SUBTYPE_MH3D_MHM1) || (msub_type == GF_ISOM_SUBTYPE_MH3D_MHM2))\n\t\t\tallow_inband = GF_TRUE;\n\n\t\tfprintf(stderr, \"\\tMPEG-H Audio stream - Sample Rate %d\\n\", sr);\n\n\t\tesd = gf_media_map_esd(file, trackNum, 1);\n\t\tif (!esd || !esd->decoderConfig || !esd->decoderConfig->decoderSpecificInfo\n\t\t\t|| !esd->decoderConfig->decoderSpecificInfo->data\n\t\t) {\n\t\t\tif (allow_inband) {\n\t\t\t\tGF_ISOSample *samp = gf_isom_get_sample(file, trackNum, 1, NULL);\n\t\t\t\tif (samp) {\n\t\t\t\t\tu64 ch_layout=0;\n\t\t\t\t\ts32 PL = gf_mpegh_get_mhas_pl(samp->data, samp->dataLength, &ch_layout);\n\t\t\t\t\tif (PL>=0) {\n\t\t\t\t\t\tfprintf(stderr, \"\\tProfileLevelIndication: 0x%02X\", PL);\n\t\t\t\t\t\tif (ch_layout)\n\t\t\t\t\t\t\tfprintf(stderr, \" - Reference Channel Layout %s\", gf_audio_fmt_get_layout_name(ch_layout) );\n\t\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tgf_isom_sample_del(&samp);\n\t\t\t\t}\n\t\t\t\tvalid = GF_TRUE;\n\t\t\t}\n\t\t} else if (esd->decoderConfig->decoderSpecificInfo->dataLength>=5) {\n\t\t\tfprintf(stderr, \"\\tProfileLevelIndication: 0x%02X - Reference Channel Layout %s\\n\", esd->decoderConfig->decoderSpecificInfo->data[1]\n\t\t\t\t, gf_audio_fmt_get_layout_name_from_cicp(esd->decoderConfig->decoderSpecificInfo->data[2])\n\t\t\t);\n\t\t\tvalid = GF_TRUE;\n\t\t}\n\t\tif (!valid) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Invalid MPEG-H audio config\\n\"));\n\t\t}\n\t\tif (esd) gf_odf_desc_del((GF_Descriptor *)esd);\n\t\tcompat_profiles = gf_isom_get_mpegh_compatible_profiles(file, trackNum, 1, &nb_compat_profiles);\n\t\tfor (i=0; i<nb_compat_profiles; i++) {\n\t\t\tif (!i)\n\t\t\t\tfprintf(stderr, \"\\tCompatible profiles:\");\n\t\t\tfprintf(stderr, \" 0x%02X\", compat_profiles[i]);\n\t\t}\n\t\tif (i) fprintf(stderr, \"\\n\");\n\t} else if (msub_type==GF_ISOM_SUBTYPE_MLPA) {\n\t\tu32 fmt, prate;\n\t\tif (gf_isom_truehd_config_get(file, trackNum, 1, &fmt, &prate) != GF_OK) {\n\t\t\tfprintf(stderr, \"\\tInvalid TrueHD audio config\\n\");\n\t\t}\n\t\tfprintf(stderr, \"TrueHD Audio stream - Sample Rate %u - channels %u - format %u peak rate %u\\n\", sr, nb_ch, fmt, prate);\n\t} else if (codecid) {\n\t\tif (gf_isom_is_video_handler_type(mtype) ) {\n\t\t\tu32 w, h;\n\t\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\t\tfprintf(stderr, \"%s - Resolution %d x %d\\n\", gf_codecid_name(codecid), w, h);\n\t\t} else if (mtype==GF_ISOM_MEDIA_AUDIO) {\n\t\t\tgf_isom_get_audio_info(file, trackNum, 1, &sr, &nb_ch, NULL);\n\t\t\tfprintf(stderr, \"%s - Sample Rate %d - %d channel(s)\\n\", gf_codecid_name(codecid), sr, nb_ch);\n\t\t} else {\n\t\t\tfprintf(stderr, \"%s\\n\", gf_codecid_name(codecid) );\n\t\t}\n\t} else if (pfmt) {\n\t\tu32 w, h;\n\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\tfprintf(stderr, \"Raw video %s - Resolution %d x %d\\n\", gf_pixel_fmt_name(pfmt), w, h);\n\t} else if (msub_type==GF_QT_SUBTYPE_TMCD) {\n\t\tu32 stsd_idx;\n\t\tGF_ISOSample *sample = gf_isom_get_sample(file, trackNum, 1, &stsd_idx);\n\t\tfprintf(stderr, \"Time Code stream\\n\");\n\t\tif (sample) {\n\t\t\tchar szTimecode[100];\n\t\t\tu32 tmcd_flags, tmcd_num, tmcd_den, tmcd_fpt;\n\n\t\t\tgf_isom_get_tmcd_config(file, trackNum, stsd_idx, &tmcd_flags, &tmcd_num, &tmcd_den, &tmcd_fpt);\n\n\t\t\tgf_inspect_format_timecode(sample->data, sample->dataLength, tmcd_flags, tmcd_num, tmcd_den, tmcd_fpt, szTimecode);\n\n\t\t\tgf_isom_sample_del(&sample);\n\t\t\tfprintf(stderr, \"\\tFirst timecode: %s\\n\", szTimecode);\n\t\t}\n\t} else {\n\t\tGF_GenericSampleDescription *udesc;\n\n\t\tudesc = gf_isom_get_generic_sample_description(file, trackNum, 1);\n\t\tif (udesc) {\n\t\t\tif (gf_isom_is_video_handler_type(mtype) ) {\n                fprintf(stderr, \"%s - Compressor \\\"%s\\\" - Resolution %d x %d\\n\",\n\t\t\t\t\t\t( (mtype == GF_ISOM_MEDIA_VISUAL ? \"Visual\" : \"Auxiliary Video\") ),\n                        udesc->compressor_name, udesc->width, udesc->height);\n\t\t\t} else if (mtype==GF_ISOM_MEDIA_AUDIO) {\n\t\t\t\tfprintf(stderr, \"Audio - Sample Rate %d - %d channel(s)\\n\", udesc->samplerate, udesc->nb_channels);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"Unknown media type\\n\");\n\t\t\t}\n\t\t\tif (udesc->vendor_code)\n\t\t\t\tfprintf(stderr, \"\\tVendor code \\\"%s\\\" - Version %d - revision %d\\n\", gf_4cc_to_str(udesc->vendor_code), udesc->version, udesc->revision);\n\n\t\t\tif (udesc->extension_buf) {\n\t\t\t\tfprintf(stderr, \"\\tCodec configuration data size: %d bytes\\n\", udesc->extension_buf_size);\n\t\t\t\tgf_free(udesc->extension_buf);\n\t\t\t}\n\t\t\tgf_free(udesc);\n\t\t} else {\n\t\t\tfprintf(stderr, \"Unknown track type\\n\");\n\t\t}\n\t}\n\n\n\t/*Crypto info*/\n\tif (gf_isom_is_track_encrypted(file, trackNum)) {\n\t\tconst char *scheme_URI, *KMS_URI;\n\t\tu32 scheme_type, version;\n\t\tu32 IV_size;\n\t\tBool use_sel_enc;\n\n\t\tif (gf_isom_is_ismacryp_media(file, trackNum, 1)) {\n\t\t\tgf_isom_get_ismacryp_info(file, trackNum, 1, NULL, &scheme_type, &version, &scheme_URI, &KMS_URI, &use_sel_enc, &IV_size, NULL);\n\t\t\tfprintf(stderr, \"\\n\\tProtected by ISMA E&A scheme %s (version %d)\\n\", gf_4cc_to_str(scheme_type), version);\n\t\t\tif (scheme_URI) fprintf(stderr, \"scheme location: %s\\n\", scheme_URI);\n\t\t\tif (KMS_URI) {\n\t\t\t\tif (!strnicmp(KMS_URI, \"(key)\", 5)) fprintf(stderr, \"\\tKMS location: key in file\\n\");\n\t\t\t\telse fprintf(stderr, \"\\tKMS location: %s\\n\", KMS_URI);\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\tSelective Encryption: %s\\n\", use_sel_enc ? \"Yes\" : \"No\");\n\t\t\tif (IV_size) fprintf(stderr, \"\\tInitialization Vector size: %d bits\\n\", IV_size*8);\n\t\t} else if (gf_isom_is_omadrm_media(file, trackNum, 1)) {\n\t\t\tconst char *textHdrs;\n\t\t\tu32 enc_type, hdr_len;\n\t\t\tu64 orig_len;\n\t\t\tgf_isom_get_omadrm_info(file, trackNum, 1, NULL, &scheme_type, &version, &scheme_URI, &KMS_URI, &textHdrs, &hdr_len, &orig_len, &enc_type, &use_sel_enc, &IV_size, NULL);\n\t\t\tfprintf(stderr, \"\\n\\tProtected by OMA DRM scheme %s (version %d)\\n\", gf_4cc_to_str(scheme_type), version);\n\t\t\tfprintf(stderr, \"\\tRights Issuer: %s\\n\", KMS_URI);\n\t\t\tfprintf(stderr, \"\\tContent ID: %s\\n\", scheme_URI);\n\t\t\tif (textHdrs) {\n\t\t\t\tu32 offset;\n\t\t\t\tconst char *start = textHdrs;\n\t\t\t\tfprintf(stderr, \"\\tOMA Textual Headers:\\n\");\n\t\t\t\ti=0;\n\t\t\t\toffset=0;\n\t\t\t\twhile (i<hdr_len) {\n\t\t\t\t\tif (start[i]==0) {\n\t\t\t\t\t\tfprintf(stderr, \"\\t\\t%s\\n\", start+offset);\n\t\t\t\t\t\toffset=i+1;\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\\\tt%s\\n\", start+offset);\n\t\t\t}\n\t\t\tif (orig_len) fprintf(stderr, \"\\tOriginal media size \"LLD\"\\n\", orig_len);\n\t\t\tfprintf(stderr, \"\\tEncryption algorithm %s\\n\", (enc_type==1) ? \"AEA 128 CBC\" : (enc_type ? \"AEA 128 CTR\" : \"None\"));\n\t\t\tfprintf(stderr, \"\\tSelective Encryption: %s\\n\", use_sel_enc ? \"Yes\" : \"No\");\n\t\t\tif (IV_size) fprintf(stderr, \"\\tInitialization Vector size: %d bits\\n\", IV_size*8);\n\t\t} else if(gf_isom_is_cenc_media(file, trackNum, 1)) {\n\t\t\tconst u8 *def_key;\n\t\t\tu32 def_key_size;\n\t\t\tBool IsEncrypted;\n\t\t\tu8 crypt_byte_block, skip_byte_block;\n\t\t\tIV_size = 0;\n\t\t\tgf_isom_get_cenc_info(file, trackNum, 1, NULL, &scheme_type, &version);\n\n\t\t\tgf_isom_cenc_get_default_info(file, trackNum, 1, NULL, &IsEncrypted, &crypt_byte_block, &skip_byte_block, &def_key, &def_key_size);\n\n\t\t\tfprintf(stderr, \"\\n\\tProtected by CENC scheme %s version 0x%08X\", gf_4cc_to_str(scheme_type), version);\n\n\t\t\tif (crypt_byte_block && skip_byte_block)\n\t\t\t\tfprintf(stderr, \" - Pattern %d:%d\", (u32) skip_byte_block, (u32) crypt_byte_block);\n\t\t\tif (def_key && def_key[0])\n\t\t\t\tfprintf(stderr, \" - MultiKey\");\n\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t\tdump_key_info(def_key, def_key_size, IsEncrypted);\n\n\t\t} else if(gf_isom_is_adobe_protection_media(file, trackNum, 1)) {\n\t\t\tgf_isom_get_adobe_protection_info(file, trackNum, 1, NULL, &scheme_type, &version, NULL);\n\t\t\tfprintf(stderr, \"\\nProtected by Adobe scheme %s (version %d)\\n\", gf_4cc_to_str(scheme_type), version);\n\t\t} else {\n\t\t\tfprintf(stderr, \"\\nProtected by unknown scheme %s\\n\", gf_4cc_to_str(gf_isom_is_media_encrypted(file, trackNum, 0) ));\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t}\n\n\tif ( gf_media_get_rfc_6381_codec_name(file, trackNum, szCodec, GF_FALSE, GF_FALSE) == GF_OK) {\n\t\tfprintf(stderr, \"\\tRFC6381 Codec Parameters: %s\\n\", szCodec);\n\t}\n\n\n\tDumpMetaItem(file, 0, trackNum, \"\\tTrack Meta\");\n\n\tgf_isom_get_track_switch_group_count(file, trackNum, &alt_group, &nb_groups);\n\tif (alt_group) {\n\t\tfprintf(stderr, \"Alternate Group ID %d\\n\", alt_group);\n\t\tfor (i=0; i<nb_groups; i++) {\n\t\t\tu32 nb_crit, switchGroupID;\n\t\t\tconst u32 *criterias = gf_isom_get_track_switch_parameter(file, trackNum, i+1, &switchGroupID, &nb_crit);\n\t\t\tif (!nb_crit) {\n\t\t\t\tfprintf(stderr, \"\\tNo criteria in %s group\\n\", switchGroupID ? \"switch\" : \"alternate\");\n\t\t\t} else {\n\t\t\t\tif (switchGroupID) {\n\t\t\t\t\tfprintf(stderr, \"\\tSwitchGroup ID %d criterias: \", switchGroupID);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"\\tAlternate Group criterias: \");\n\t\t\t\t}\n\t\t\t\tfor (j=0; j<nb_crit; j++) {\n\t\t\t\t\tif (j) fprintf(stderr, \" \");\n\t\t\t\t\tfprintf(stderr, \"%s\", gf_4cc_to_str(criterias[j]) );\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch (gf_isom_has_sync_points(file, trackNum)) {\n\tcase 0:\n\t\tfprintf(stderr, \"\\tAll samples are sync\\n\");\n\t\tbreak;\n\tcase 1:\n\t{\n\t\tu32 nb_sync = gf_isom_get_sync_point_count(file, trackNum) - 1;\n\t\tif (! nb_sync) {\n\t\t\tfprintf(stderr, \"\\tOnly one sync sample\\n\");\n\t\t} else {\n\t\t\tfprintf(stderr, \"\\tAverage GOP length: %d samples\\n\", gf_isom_get_sample_count(file, trackNum) / nb_sync);\n\t\t}\n\t}\n\tbreak;\n\tcase 2:\n\t\tfprintf(stderr, \"\\tNo sync sample found\\n\");\n\t\tbreak;\n\t}\n\tfprintf(stderr, \"\\tMax sample duration: %d / %d\\n\", gf_isom_get_max_sample_delta(file, trackNum), timescale);\n\n\tif (!full_dump) {\n\t\tfprintf(stderr, \"\\n\");\n\t\treturn;\n\t}\n\n\tdur = size = 0;\n\tmax_rate = rate = 0;\n\ttime_slice = 0;\n\tts = gf_isom_get_media_timescale(file, trackNum);\n\tcsize = gf_isom_get_constant_sample_size(file, trackNum);\n\tcdur = gf_isom_get_constant_sample_duration(file, trackNum);\n\tcount = gf_isom_get_sample_count(file, trackNum);\n\tif (csize && cdur) {\n\t\tsize = count * csize;\n\t\tdur = cdur * count;\n\t} else {\n\n\t\tfor (j=0; j<count; j++) {\n\t\t\tGF_ISOSample *samp;\n\t\t\tif (is_od_track) {\n\t\t\t\tsamp = gf_isom_get_sample(file, trackNum, j+1, NULL);\n\t\t\t} else {\n\t\t\t\tsamp = gf_isom_get_sample_info(file, trackNum, j+1, NULL, NULL);\n\t\t\t}\n\t\t\tif (!samp) {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Failed to fetch sample %d\\n\", j+1));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdur = samp->DTS+samp->CTS_Offset;\n\t\t\tsize += samp->dataLength;\n\t\t\trate += samp->dataLength;\n\t\t\tif (samp->DTS - time_slice > ts) {\n\t\t\t\tDouble max_tmp = rate * ts / (samp->DTS - time_slice);\n\t\t\t\tif (max_rate < max_tmp )\n\t\t\t\t\tmax_rate = max_tmp;\n\n\t\t\t\trate = 0;\n\t\t\t\ttime_slice = samp->DTS;\n\t\t\t}\n\t\t\tgf_isom_sample_del(&samp);\n\t\t}\n\t}\n\tfprintf(stderr, \"\\nComputed info from media:\\n\");\n\tif (csize && cdur) {\n\t\tfprintf(stderr, \"\\tConstant sample size %d bytes and dur %d / %d\\n\", csize, cdur, ts);\n\t}\n\tscale = 1000.0 / ts;\n\tdur = (u64) (scale * dur);\n\tfprintf(stderr, \"\\tTotal size \"LLU\" bytes - Total samples duration \"LLU\" ms\\n\", size, dur);\n\tif (!dur) {\n\t\tfprintf(stderr, \"\\n\");\n\t\treturn;\n\t}\n\t/*rate in byte, dur is in ms*/\n\trate = 8000.0 * size / dur;\n\n\tif (!max_rate)\n\t\tmax_rate = rate;\n\telse\n\t\tmax_rate *= 8.0;\n\n\tif (rate >= 1500) {\n\t\tfprintf(stderr, \"\\tAverage rate %.2f kbps - Max Rate %.2f kbps\\n\", rate/1000, max_rate/1000);\n\t} else {\n\t\tfprintf(stderr, \"\\tAverage rate %.2f bps - Max Rate %.2f bps\\n\", rate, max_rate);\n\t}\n\n\t{\n\t\tu32 dmin, dmax, davg, smin, smax, savg;\n\t\tgf_isom_get_chunks_infos(file, trackNum, &dmin, &davg, &dmax, &smin, &savg, &smax);\n\t\tfprintf(stderr, \"\\tChunk durations: min %d ms - max %d ms - average %d ms\\n\", (1000*dmin)/ts, (1000*dmax)/ts, (1000*davg)/ts);\n\t\tfprintf(stderr, \"\\tChunk sizes (bytes): min %d - max %d - average %d\\n\", smin, smax, savg);\n\t}\n\tfprintf(stderr, \"\\n\");\n\n\tcount = gf_isom_get_chapter_count(file, trackNum);\n\tif (count) {\n\t\tconst char *name;\n\t\tu64 time;\n\t\tfprintf(stderr, \"\\nChapters:\\n\");\n\t\tfor (j=0; j<count; j++) {\n\t\t\tgf_isom_get_chapter(file, trackNum, j+1, &time, &name);\n\t\t\tfprintf(stderr, \"\\tChapter #%d - %s - \\\"%s\\\"\\n\", j+1, format_duration(time, 1000, szDur), name);\n\t\t}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 664,
    "critical_vars": [
      "d->iccprofile_file"
    ],
    "function": "do_iccprofile_item",
    "filename": "deark/CVE-2021-28855/CVE-2021-28855_CWE-476_287f5ac31dfdc074669182f51ece637706070eeb_pict.c.diff",
    "function_code": "static void do_iccprofile_item(deark *c, lctx *d, i64 pos, i64 len)\n{\n\ti64 selector;\n\ti64 data_len;\n\n\tif(len<4) return;\n\tselector = de_getu32be(pos);\n\tdata_len = len-4;\n\tde_dbg(c, \"ICC profile segment, selector=%d, data len=%d\", (int)selector,\n\t\t(int)data_len);\n\n\tif(selector!=1) {\n\t\t// If this is not a Continuation segment, close any current file.\n\t\tdbuf_close(d->iccprofile_file);\n\t\td->iccprofile_file = NULL;\n\t}\n\n\tif(selector==0) { // Beginning segment\n\t\td->iccprofile_file = dbuf_create_output_file(c, \"icc\", NULL, DE_CREATEFLAG_IS_AUX);\n\t}\n\n\tif(selector==0 || selector==1) {\n\t\t// Beginning and Continuation segments normally have profile data.\n\t\t// End segments (selector==2) are not allowed to include data.\n\n\t\tif(!d->iccprofile_file) {\n\t\t\tde_warn(c, \"Bad ICC profile segment\");\n\t\t\treturn;\n\t\t}\n\t\tdbuf_copy(c->infile, pos+4, data_len, d->iccprofile_file);\n\t}\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 2272,
    "critical_vars": [
      "p->question"
    ],
    "function": "dns_packet_is_reply_for",
    "filename": "systemd/CVE-2017-9217/CVE-2017-9217_CWE-476_a924f43f30f9c4acaf70618dd2a055f8b0f166be_resolved-dns-packet.c.diff",
    "function_code": "int dns_packet_is_reply_for(DnsPacket *p, const DnsResourceKey *key) {\n        int r;\n\n        assert(p);\n        assert(key);\n\n        /* Checks if the specified packet is a reply for the specified\n         * key and the specified key is the only one in the question\n         * section. */\n\n        if (DNS_PACKET_QR(p) != 1)\n                return 0;\n\n        /* Let's unpack the packet, if that hasn't happened yet. */\n        r = dns_packet_extract(p);\n        if (r < 0)\n                return r;\n\n        if (!p->question)\n                return 0;\n\n        if (p->question->n_keys != 1)\n                return 0;\n\n        return dns_resource_key_equal(p->question->keys[0], key);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 207,
    "critical_vars": [
      "sprinc"
    ],
    "function": "process_tgs_req",
    "filename": "krb5/CVE-2021-37750/CVE-2021-37750_CWE-476_d775c95af7606a51bf79547a94fa52ddd1cb7f49_do_tgs_req.c.diff",
    "function_code": "process_tgs_req(krb5_kdc_req *request, krb5_data *pkt,\n                const krb5_fulladdr *from, kdc_realm_t *kdc_active_realm,\n                krb5_data **response)\n{\n    krb5_keyblock * subkey = 0;\n    krb5_keyblock *header_key = NULL;\n    krb5_keyblock *stkt_server_key = NULL;\n    krb5_keyblock *subject_key;\n    krb5_db_entry *server = NULL;\n    krb5_db_entry *stkt_server = NULL;\n    krb5_db_entry *subject_server;\n    krb5_kdc_rep reply;\n    krb5_enc_kdc_rep_part reply_encpart;\n    krb5_ticket ticket_reply, *header_ticket = 0;\n    const krb5_ticket *stkt = NULL;\n    krb5_enc_tkt_part enc_tkt_reply;\n    int newtransited = 0;\n    krb5_error_code retval = 0;\n    krb5_keyblock server_keyblock, *encrypting_key;\n    krb5_timestamp kdc_time, authtime = 0;\n    krb5_keyblock session_key, local_tgt_key;\n    krb5_keyblock *reply_key = NULL;\n    krb5_principal cprinc = NULL, sprinc = NULL, altcprinc = NULL;\n    krb5_const_principal authdata_client;\n    krb5_principal stkt_authdata_client = NULL;\n    krb5_last_req_entry *nolrarray[2], nolrentry;\n    int errcode;\n    const char        *status = 0;\n    krb5_enc_tkt_part *header_enc_tkt = NULL; /* TGT */\n    krb5_enc_tkt_part *subject_tkt = NULL; /* TGT or evidence ticket */\n    krb5_db_entry *client = NULL, *header_server = NULL;\n    krb5_db_entry *local_tgt, *local_tgt_storage = NULL;\n    krb5_pa_s4u_x509_user *s4u_x509_user = NULL; /* protocol transition request */\n    krb5_authdata **kdc_issued_auth_data = NULL; /* auth data issued by KDC */\n    unsigned int c_flags = 0, s_flags = 0;       /* client/server KDB flags */\n    krb5_boolean is_referral, is_crossrealm;\n    const char *emsg = NULL;\n    krb5_kvno ticket_kvno = 0;\n    struct kdc_request_state *state = NULL;\n    krb5_pa_data *pa_tgs_req; /*points into request*/\n    krb5_data scratch;\n    krb5_pa_data **e_data = NULL;\n    krb5_audit_state *au_state = NULL;\n    krb5_data **auth_indicators = NULL;\n    void *ad_info = NULL, *stkt_ad_info = NULL;\n\n    memset(&reply, 0, sizeof(reply));\n    memset(&reply_encpart, 0, sizeof(reply_encpart));\n    memset(&ticket_reply, 0, sizeof(ticket_reply));\n    memset(&enc_tkt_reply, 0, sizeof(enc_tkt_reply));\n    memset(&server_keyblock, 0, sizeof(server_keyblock));\n    memset(&local_tgt_key, 0, sizeof(local_tgt_key));\n    session_key.contents = NULL;\n\n    /* Save pointer to client-requested service principal, in case of\n     * errors before a successful call to search_sprinc(). */\n    sprinc = request->server;\n\n    if (request->msg_type != KRB5_TGS_REQ) {\n        krb5_free_kdc_req(kdc_context, request);\n        return KRB5_BADMSGTYPE;\n    }\n\n    errcode = kdc_make_rstate(kdc_active_realm, &state);\n    if (errcode != 0)\n        goto cleanup;\n\n    /* Initialize audit state. */\n    errcode = kau_init_kdc_req(kdc_context, request, from, &au_state);\n    if (errcode)\n        goto cleanup;\n\n    /* Seed the audit trail with the request ID and basic information. */\n    kau_tgs_req(kdc_context, TRUE, au_state);\n\n    errcode = kdc_process_tgs_req(kdc_active_realm,\n                                  request, from, pkt, &header_ticket,\n                                  &header_server, &header_key, &subkey,\n                                  &pa_tgs_req);\n    if (header_ticket && header_ticket->enc_part2)\n        cprinc = header_ticket->enc_part2->client;\n\n    if (errcode) {\n        status = \"PROCESS_TGS\";\n        goto cleanup;\n    }\n\n    if (!header_ticket) {\n        errcode = KRB5_NO_TKT_SUPPLIED;        /* XXX? */\n        goto cleanup;\n    }\n    errcode = kau_make_tkt_id(kdc_context, header_ticket,\n                              &au_state->tkt_in_id);\n    if (errcode)\n        goto cleanup;\n\n    scratch.length = pa_tgs_req->length;\n    scratch.data = (char *) pa_tgs_req->contents;\n    errcode = kdc_find_fast(&request, &scratch, subkey,\n                            header_ticket->enc_part2->session, state, NULL);\n    /* Reset sprinc because kdc_find_fast() can replace request. */\n    sprinc = request->server;\n    if (errcode !=0) {\n        status = \"FIND_FAST\";\n        goto cleanup;\n    }\n    if (sprinc == NULL) {\n        status = \"NULL_SERVER\";\n        errcode = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n        goto cleanup;\n    }\n\n    errcode = get_local_tgt(kdc_context, &sprinc->realm, header_server,\n                            &local_tgt, &local_tgt_storage, &local_tgt_key);\n    if (errcode) {\n        status = \"GET_LOCAL_TGT\";\n        goto cleanup;\n    }\n\n    /* Ignore (for now) the request modification due to FAST processing. */\n    au_state->request = request;\n\n    /*\n     * Pointer to the encrypted part of the header ticket, which may be\n     * replaced to point to the encrypted part of the evidence ticket\n     * if constrained delegation is used. This simplifies the number of\n     * special cases for constrained delegation.\n     */\n    header_enc_tkt = header_ticket->enc_part2;\n\n    /*\n     * We've already dealt with the AP_REQ authentication, so we can\n     * use header_ticket freely.  The encrypted part (if any) has been\n     * decrypted with the session key.\n     */\n\n    au_state->stage = SRVC_PRINC;\n\n    /* XXX make sure server here has the proper realm...taken from AP_REQ\n       header? */\n\n    if (isflagset(request->kdc_options, KDC_OPT_CANONICALIZE)) {\n        setflag(c_flags, KRB5_KDB_FLAG_CANONICALIZE);\n        setflag(s_flags, KRB5_KDB_FLAG_CANONICALIZE);\n    }\n\n    errcode = search_sprinc(kdc_active_realm, request, s_flags, &server,\n                            &status);\n    if (errcode != 0)\n        goto cleanup;\n    sprinc = server->princ;\n\n    /* If we got a cross-realm TGS which is not the requested server, we are\n     * issuing a referral (or alternate TGT, which we treat similarly). */\n    is_referral = is_cross_tgs_principal(server->princ) &&\n        !krb5_principal_compare(kdc_context, request->server, server->princ);\n\n    au_state->stage = VALIDATE_POL;\n\n    if ((errcode = krb5_timeofday(kdc_context, &kdc_time)))\n        goto cleanup;\n\n    is_crossrealm = !data_eq(header_server->princ->realm, sprinc->realm);\n    if (is_crossrealm)\n        setflag(c_flags, KRB5_KDB_FLAG_CROSS_REALM);\n    if (is_referral)\n        setflag(c_flags, KRB5_KDB_FLAG_ISSUING_REFERRAL);\n\n    /* Check for protocol transition */\n    errcode = kdc_process_s4u2self_req(kdc_active_realm, request, server,\n                                       subkey, header_enc_tkt->session,\n                                       &s4u_x509_user, &client, &status);\n    if (s4u_x509_user != NULL || errcode != 0) {\n        if (s4u_x509_user != NULL)\n            au_state->s4u2self_user = s4u_x509_user->user_id.user;\n        au_state->status = status;\n        kau_s4u2self(kdc_context, errcode ? FALSE : TRUE, au_state);\n        au_state->s4u2self_user = NULL;\n    }\n\n    /* For user-to-user and S4U2Proxy requests, decrypt the second ticket. */\n    errcode = decrypt_2ndtkt(kdc_active_realm, request, c_flags,\n                             &stkt, &stkt_server, &stkt_server_key, &status);\n    if (errcode)\n        goto cleanup;\n\n    retval = validate_tgs_request(kdc_active_realm, request, server,\n                                  header_ticket, stkt, stkt_server, kdc_time,\n                                  s4u_x509_user, client, is_crossrealm,\n                                  is_referral, &status, &e_data);\n    if (retval) {\n        if (retval == KDC_ERR_POLICY || retval == KDC_ERR_BADOPTION)\n            au_state->violation = PROT_CONSTRAINT;\n        errcode = retval + ERROR_TABLE_BASE_krb5;\n        goto cleanup;\n    }\n\n    if (errcode)\n        goto cleanup;\n\n    if (s4u_x509_user != NULL && client == NULL) {\n        /*\n         * For an S4U2Self referral request (the requesting service is\n         * following a referral back to its own realm), the authdata in the\n         * header ticket should be for the requested client.\n         */\n        setflag(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION);\n        authdata_client = s4u_x509_user->user_id.user;\n    } else {\n        /* Otherwise (including for initial S4U2Self requests), the authdata\n         * should be for the header ticket client. */\n        authdata_client = header_enc_tkt->client;\n    }\n    errcode = krb5_db_get_authdata_info(kdc_context, c_flags,\n                                        header_enc_tkt->authorization_data,\n                                        authdata_client, request->server,\n                                        header_key, &local_tgt_key, local_tgt,\n                                        header_enc_tkt->times.authtime,\n                                        &ad_info, NULL);\n    if (errcode && errcode != KRB5_PLUGIN_OP_NOTSUPP)\n        goto cleanup;\n\n    /* Flag all S4U2Self requests now that we have checked the authdata. */\n    if (s4u_x509_user != NULL)\n        setflag(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION);\n\n    if (isflagset(request->kdc_options, KDC_OPT_CNAME_IN_ADDL_TKT)) {\n        /* Do constrained delegation protocol and authorization checks. */\n        setflag(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION);\n\n        errcode = kdc_process_s4u2proxy_req(kdc_active_realm, c_flags, request,\n                                            stkt->enc_part2, local_tgt,\n                                            &local_tgt_key, stkt_server,\n                                            stkt_server_key,\n                                            header_ticket->enc_part2->client,\n                                            server, request->server, ad_info,\n                                            &stkt_ad_info,\n                                            &stkt_authdata_client,\n                                            &status);\n        if (errcode == KDC_ERR_POLICY || errcode == KDC_ERR_BADOPTION)\n            au_state->violation = PROT_CONSTRAINT;\n        else if (errcode)\n            au_state->violation = LOCAL_POLICY;\n        au_state->status = status;\n        retval = kau_make_tkt_id(kdc_context, stkt, &au_state->evid_tkt_id);\n        if (retval) {\n            errcode = retval;\n            goto cleanup;\n        }\n        kau_s4u2proxy(kdc_context, errcode ? FALSE : TRUE, au_state);\n        if (errcode)\n            goto cleanup;\n\n        assert(krb5_is_tgs_principal(header_ticket->server));\n\n        /* Use the parsed authdata from the second ticket during authdata\n         * handling. */\n        krb5_db_free_authdata_info(kdc_context, ad_info);\n        ad_info = stkt_ad_info;\n        stkt_ad_info = NULL;\n    }\n\n    au_state->stage = ISSUE_TKT;\n\n    errcode = gen_session_key(kdc_active_realm, request, server, &session_key,\n                              &status);\n    if (errcode)\n        goto cleanup;\n\n    /*\n     * subject_tkt will refer to the evidence ticket (for constrained\n     * delegation) or the TGT. The distinction from header_enc_tkt is\n     * necessary because the TGS signature only protects some fields:\n     * the others could be forged by a malicious server.\n     */\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)) {\n        subject_tkt = stkt->enc_part2;\n        subject_server = stkt_server;\n        subject_key = stkt_server_key;\n    } else {\n        subject_tkt = header_enc_tkt;\n        subject_server = header_server;\n        subject_key = header_key;\n    }\n    authtime = subject_tkt->times.authtime;\n\n    /* Extract and check auth indicators from the subject ticket, except for\n     * S4U2Self requests (where the client didn't authenticate). */\n    if (s4u_x509_user == NULL) {\n        errcode = get_auth_indicators(kdc_context, subject_tkt, local_tgt,\n                                      &local_tgt_key, &auth_indicators);\n        if (errcode) {\n            status = \"GET_AUTH_INDICATORS\";\n            goto cleanup;\n        }\n\n        errcode = check_indicators(kdc_context, server, auth_indicators);\n        if (errcode) {\n            status = \"HIGHER_AUTHENTICATION_REQUIRED\";\n            goto cleanup;\n        }\n    }\n\n    if (is_referral)\n        ticket_reply.server = server->princ;\n    else\n        ticket_reply.server = request->server; /* XXX careful for realm... */\n\n    enc_tkt_reply.flags = get_ticket_flags(request->kdc_options, client,\n                                           server, header_enc_tkt);\n    enc_tkt_reply.times.starttime = 0;\n\n    /* OK_TO_AUTH_AS_DELEGATE must be set on the service requesting S4U2Self\n     * for forwardable tickets to be issued. */\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION) &&\n        !is_referral &&\n        !isflagset(server->attributes, KRB5_KDB_OK_TO_AUTH_AS_DELEGATE))\n        clear(enc_tkt_reply.flags, TKT_FLG_FORWARDABLE);\n\n    /* don't use new addresses unless forwarded, see below */\n\n    enc_tkt_reply.caddrs = header_enc_tkt->caddrs;\n    /* noaddrarray[0] = 0; */\n    reply_encpart.caddrs = 0;/* optional...don't put it in */\n    reply_encpart.enc_padata = NULL;\n\n    /*\n     * It should be noted that local policy may affect the\n     * processing of any of these flags.  For example, some\n     * realms may refuse to issue renewable tickets\n     */\n\n    if (isflagset(request->kdc_options, KDC_OPT_FORWARDED) ||\n        isflagset(request->kdc_options, KDC_OPT_PROXY)) {\n\n        /* include new addresses in ticket & reply */\n\n        enc_tkt_reply.caddrs = request->addresses;\n        reply_encpart.caddrs = request->addresses;\n    }\n\n    if (isflagset(request->kdc_options, KDC_OPT_POSTDATED))\n        enc_tkt_reply.times.starttime = request->from;\n    else\n        enc_tkt_reply.times.starttime = kdc_time;\n\n    if (isflagset(request->kdc_options, KDC_OPT_VALIDATE)) {\n        assert(isflagset(c_flags, KRB5_KDB_FLAGS_S4U) == 0);\n        /* BEWARE of allocation hanging off of ticket & enc_part2, it belongs\n           to the caller */\n        ticket_reply = *(header_ticket);\n        enc_tkt_reply = *(header_ticket->enc_part2);\n        enc_tkt_reply.authorization_data = NULL;\n        clear(enc_tkt_reply.flags, TKT_FLG_INVALID);\n    }\n\n    if (isflagset(request->kdc_options, KDC_OPT_RENEW)) {\n        krb5_timestamp old_starttime;\n        krb5_deltat old_life;\n\n        assert(isflagset(c_flags, KRB5_KDB_FLAGS_S4U) == 0);\n        /* BEWARE of allocation hanging off of ticket & enc_part2, it belongs\n           to the caller */\n        ticket_reply = *(header_ticket);\n        enc_tkt_reply = *(header_ticket->enc_part2);\n        enc_tkt_reply.authorization_data = NULL;\n\n        old_starttime = enc_tkt_reply.times.starttime ?\n            enc_tkt_reply.times.starttime : enc_tkt_reply.times.authtime;\n        old_life = ts_delta(enc_tkt_reply.times.endtime, old_starttime);\n\n        enc_tkt_reply.times.starttime = kdc_time;\n        enc_tkt_reply.times.endtime =\n            ts_min(header_ticket->enc_part2->times.renew_till,\n                   ts_incr(kdc_time, old_life));\n    } else {\n        /* not a renew request */\n        enc_tkt_reply.times.starttime = kdc_time;\n\n        kdc_get_ticket_endtime(kdc_active_realm, enc_tkt_reply.times.starttime,\n                               header_enc_tkt->times.endtime, request->till,\n                               client, server, &enc_tkt_reply.times.endtime);\n    }\n\n    kdc_get_ticket_renewtime(kdc_active_realm, request, header_enc_tkt, client,\n                             server, &enc_tkt_reply);\n\n    errcode = check_kdcpolicy_tgs(kdc_context, request, server, header_ticket,\n                                  auth_indicators, kdc_time,\n                                  &enc_tkt_reply.times, &status);\n    if (errcode)\n        goto cleanup;\n\n    /*\n     * Set authtime to be the same as header or evidence ticket's\n     */\n    enc_tkt_reply.times.authtime = authtime;\n\n    /* starttime is optional, and treated as authtime if not present.\n       so we can nuke it if it matches */\n    if (enc_tkt_reply.times.starttime == enc_tkt_reply.times.authtime)\n        enc_tkt_reply.times.starttime = 0;\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION)) {\n        altcprinc = s4u_x509_user->user_id.user;\n    } else if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)) {\n        /* kdc_process_s4u2proxy_req() only allows cross-realm requests if\n         * stkt_authdata_client is set. */\n        altcprinc = is_crossrealm ? stkt_authdata_client : subject_tkt->client;\n    } else {\n        altcprinc = NULL;\n    }\n    if (isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY)) {\n        encrypting_key = stkt->enc_part2->session;\n    } else {\n        errcode = get_first_current_key(kdc_context, server, &server_keyblock);\n        if (errcode) {\n            status = \"FINDING_SERVER_KEY\";\n            goto cleanup;\n        }\n        encrypting_key = &server_keyblock;\n    }\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)) {\n        /*\n         * Don't allow authorization data to be disabled if constrained\n         * delegation is requested. We don't want to deny the server\n         * the ability to validate that delegation was used.\n         */\n        clear(server->attributes, KRB5_KDB_NO_AUTH_DATA_REQUIRED);\n    }\n    if (isflagset(server->attributes, KRB5_KDB_NO_AUTH_DATA_REQUIRED) == 0) {\n        /* If we are not doing protocol transition, try to look up the subject\n         * principal so that KDB modules can add additional authdata. */\n        if (!isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION)) {\n            /* Generate authorization data so we can include it in ticket */\n            setflag(c_flags, KRB5_KDB_FLAG_INCLUDE_PAC);\n            /* Map principals from foreign (possibly non-AD) realms */\n            setflag(c_flags, KRB5_KDB_FLAG_MAP_PRINCIPALS);\n\n            assert(client == NULL); /* should not have been set already */\n\n            errcode = krb5_db_get_principal(kdc_context, subject_tkt->client,\n                                            c_flags, &client);\n        }\n    }\n\n    if (isflagset(c_flags, KRB5_KDB_FLAGS_S4U) && !is_referral)\n        enc_tkt_reply.client = altcprinc;\n    else\n        enc_tkt_reply.client = header_enc_tkt->client;\n\n    enc_tkt_reply.session = &session_key;\n    enc_tkt_reply.transited.tr_type = KRB5_DOMAIN_X500_COMPRESS;\n    enc_tkt_reply.transited.tr_contents = empty_string; /* equivalent of \"\" */\n\n    /*\n     * Only add the realm of the presented tgt to the transited list if\n     * it is different than the server realm (cross-realm) and it is different\n     * than the realm of the client (since the realm of the client is already\n     * implicitly part of the transited list and should not be explicitly\n     * listed).\n     */\n    if (!is_crossrealm ||\n        krb5_realm_compare(kdc_context, header_ticket->server,\n                           enc_tkt_reply.client)) {\n        /* tgt issued by local realm or issued by realm of client */\n        enc_tkt_reply.transited = header_enc_tkt->transited;\n    } else {\n        /* tgt issued by some other realm and not the realm of the client */\n        /* assemble new transited field into allocated storage */\n        if (header_enc_tkt->transited.tr_type !=\n            KRB5_DOMAIN_X500_COMPRESS) {\n            status = \"VALIDATE_TRANSIT_TYPE\";\n            errcode = KRB5KDC_ERR_TRTYPE_NOSUPP;\n            goto cleanup;\n        }\n        memset(&enc_tkt_reply.transited, 0, sizeof(enc_tkt_reply.transited));\n        enc_tkt_reply.transited.tr_type = KRB5_DOMAIN_X500_COMPRESS;\n        if ((errcode =\n             add_to_transited(&header_enc_tkt->transited.tr_contents,\n                              &enc_tkt_reply.transited.tr_contents,\n                              header_ticket->server,\n                              enc_tkt_reply.client,\n                              request->server))) {\n            status = \"ADD_TO_TRANSITED_LIST\";\n            goto cleanup;\n        }\n        newtransited = 1;\n    }\n    if (!isflagset (request->kdc_options, KDC_OPT_DISABLE_TRANSITED_CHECK)) {\n        errcode = kdc_check_transited_list (kdc_active_realm,\n                                            &enc_tkt_reply.transited.tr_contents,\n                                            krb5_princ_realm (kdc_context, header_enc_tkt->client),\n                                            krb5_princ_realm (kdc_context, request->server));\n        if (errcode == 0) {\n            setflag (enc_tkt_reply.flags, TKT_FLG_TRANSIT_POLICY_CHECKED);\n        } else {\n            log_tgs_badtrans(kdc_context, cprinc, sprinc,\n                             &enc_tkt_reply.transited.tr_contents, errcode);\n        }\n    } else\n        krb5_klog_syslog(LOG_INFO, _(\"not checking transit path\"));\n    if (kdc_active_realm->realm_reject_bad_transit &&\n        !isflagset(enc_tkt_reply.flags, TKT_FLG_TRANSIT_POLICY_CHECKED)) {\n        errcode = KRB5KDC_ERR_POLICY;\n        status = \"BAD_TRANSIT\";\n        au_state->violation = LOCAL_POLICY;\n        goto cleanup;\n    }\n\n    errcode = handle_authdata(kdc_context, c_flags, client, server,\n                              subject_server, local_tgt, &local_tgt_key,\n                              subkey != NULL ? subkey :\n                              header_ticket->enc_part2->session,\n                              encrypting_key, subject_key, pkt, request,\n                              altcprinc, ad_info, subject_tkt,\n                              &auth_indicators, &enc_tkt_reply);\n    if (errcode) {\n        krb5_klog_syslog(LOG_INFO, _(\"TGS_REQ : handle_authdata (%d)\"),\n                         errcode);\n        status = \"HANDLE_AUTHDATA\";\n        goto cleanup;\n    }\n\n    ticket_reply.enc_part2 = &enc_tkt_reply;\n\n    /* If we are doing user-to-user authentication, encrypt the ticket using\n     * the session key of the second ticket. */\n    if (isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY)) {\n        ticket_kvno = 0;\n        ticket_reply.enc_part.enctype = stkt->enc_part2->session->enctype;\n        kau_u2u(kdc_context, TRUE, au_state);\n    } else {\n        ticket_kvno = current_kvno(server);\n    }\n\n    errcode = krb5_encrypt_tkt_part(kdc_context, encrypting_key,\n                                    &ticket_reply);\n    if (errcode)\n        goto cleanup;\n    ticket_reply.enc_part.kvno = ticket_kvno;\n    /* Start assembling the response */\n    au_state->stage = ENCR_REP;\n    reply.msg_type = KRB5_TGS_REP;\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION) &&\n        krb5int_find_pa_data(kdc_context, request->padata,\n                             KRB5_PADATA_S4U_X509_USER) != NULL) {\n        errcode = kdc_make_s4u2self_rep(kdc_context,\n                                        subkey,\n                                        header_ticket->enc_part2->session,\n                                        s4u_x509_user,\n                                        &reply,\n                                        &reply_encpart);\n        if (errcode)\n            au_state->status = status;\n        kau_s4u2self(kdc_context, errcode ? FALSE : TRUE, au_state);\n        if (errcode)\n            goto cleanup;\n    }\n\n    reply.client = enc_tkt_reply.client;\n    reply.enc_part.kvno = 0;/* We are using the session key */\n    reply.ticket = &ticket_reply;\n\n    reply_encpart.session = &session_key;\n    reply_encpart.nonce = request->nonce;\n\n    /* copy the time fields */\n    reply_encpart.times = enc_tkt_reply.times;\n\n    nolrentry.lr_type = KRB5_LRQ_NONE;\n    nolrentry.value = 0;\n    nolrentry.magic = 0;\n    nolrarray[0] = &nolrentry;\n    nolrarray[1] = 0;\n    reply_encpart.last_req = nolrarray;        /* not available for TGS reqs */\n    reply_encpart.key_exp = 0;/* ditto */\n    reply_encpart.flags = enc_tkt_reply.flags;\n    reply_encpart.server = ticket_reply.server;\n\n    /* use the session key in the ticket, unless there's a subsession key\n       in the AP_REQ */\n    reply.enc_part.enctype = subkey ? subkey->enctype :\n        header_ticket->enc_part2->session->enctype;\n    errcode  = kdc_fast_response_handle_padata(state, request, &reply,\n                                               subkey ? subkey->enctype : header_ticket->enc_part2->session->enctype);\n    if (errcode)\n        goto cleanup;\n    errcode =kdc_fast_handle_reply_key(state,\n                                       subkey?subkey:header_ticket->enc_part2->session, &reply_key);\n    if (errcode)\n        goto cleanup;\n    errcode = return_enc_padata(kdc_context, pkt, request,\n                                reply_key, server, &reply_encpart,\n                                is_referral &&\n                                isflagset(s_flags,\n                                          KRB5_KDB_FLAG_CANONICALIZE));\n    if (errcode) {\n        status = \"KDC_RETURN_ENC_PADATA\";\n        goto cleanup;\n    }\n\n    errcode = kau_make_tkt_id(kdc_context, &ticket_reply, &au_state->tkt_out_id);\n    if (errcode)\n        goto cleanup;\n\n    if (kdc_fast_hide_client(state))\n        reply.client = (krb5_principal)krb5_anonymous_principal();\n    errcode = krb5_encode_kdc_rep(kdc_context, KRB5_TGS_REP, &reply_encpart,\n                                  subkey ? 1 : 0,\n                                  reply_key,\n                                  &reply, response);\n    if (!errcode)\n        status = \"ISSUE\";\n\n    memset(ticket_reply.enc_part.ciphertext.data, 0,\n           ticket_reply.enc_part.ciphertext.length);\n    free(ticket_reply.enc_part.ciphertext.data);\n    /* these parts are left on as a courtesy from krb5_encode_kdc_rep so we\n       can use them in raw form if needed.  But, we don't... */\n    memset(reply.enc_part.ciphertext.data, 0,\n           reply.enc_part.ciphertext.length);\n    free(reply.enc_part.ciphertext.data);\n\ncleanup:\n    if (status == NULL)\n        status = \"UNKNOWN_REASON\";\n    krb5_free_keyblock_contents(kdc_context, &server_keyblock);\n    if (reply_key)\n        krb5_free_keyblock(kdc_context, reply_key);\n    if (stkt_server_key)\n        krb5_free_keyblock(kdc_context, stkt_server_key);\n    if (errcode)\n        emsg = krb5_get_error_message (kdc_context, errcode);\n\n    if (au_state != NULL) {\n        au_state->status = status;\n        if (!errcode)\n            au_state->reply = &reply;\n        kau_tgs_req(kdc_context, errcode ? FALSE : TRUE, au_state);\n        kau_free_kdc_req(au_state);\n    }\n\n    log_tgs_req(kdc_context, from, request, &reply, cprinc,\n                sprinc, altcprinc, authtime,\n                c_flags, status, errcode, emsg);\n    if (errcode) {\n        krb5_free_error_message (kdc_context, emsg);\n        emsg = NULL;\n    }\n\n    if (errcode && state != NULL) {\n        int got_err = 0;\n        if (status == 0) {\n            status = krb5_get_error_message (kdc_context, errcode);\n            got_err = 1;\n        }\n        errcode -= ERROR_TABLE_BASE_krb5;\n        if (errcode < 0 || errcode > KRB_ERR_MAX)\n            errcode = KRB_ERR_GENERIC;\n\n        retval = prepare_error_tgs(state, request, header_ticket, errcode,\n                                   (server != NULL) ? server->princ : NULL,\n                                   response, status, e_data);\n        if (got_err) {\n            krb5_free_error_message (kdc_context, status);\n            status = 0;\n        }\n    }\n\n    if (header_ticket != NULL)\n        krb5_free_ticket(kdc_context, header_ticket);\n    if (request != NULL)\n        krb5_free_kdc_req(kdc_context, request);\n    if (state)\n        kdc_free_rstate(state);\n    krb5_db_free_principal(kdc_context, server);\n    krb5_db_free_principal(kdc_context, stkt_server);\n    krb5_db_free_principal(kdc_context, header_server);\n    krb5_db_free_principal(kdc_context, client);\n    krb5_db_free_principal(kdc_context, local_tgt_storage);\n    if (local_tgt_key.contents != NULL)\n        krb5_free_keyblock_contents(kdc_context, &local_tgt_key);\n    if (session_key.contents != NULL)\n        krb5_free_keyblock_contents(kdc_context, &session_key);\n    if (newtransited)\n        free(enc_tkt_reply.transited.tr_contents.data);\n    if (s4u_x509_user != NULL)\n        krb5_free_pa_s4u_x509_user(kdc_context, s4u_x509_user);\n    if (kdc_issued_auth_data != NULL)\n        krb5_free_authdata(kdc_context, kdc_issued_auth_data);\n    if (subkey != NULL)\n        krb5_free_keyblock(kdc_context, subkey);\n    if (header_key != NULL)\n        krb5_free_keyblock(kdc_context, header_key);\n    if (reply.padata)\n        krb5_free_pa_data(kdc_context, reply.padata);\n    if (reply_encpart.enc_padata)\n        krb5_free_pa_data(kdc_context, reply_encpart.enc_padata);\n    if (enc_tkt_reply.authorization_data != NULL)\n        krb5_free_authdata(kdc_context, enc_tkt_reply.authorization_data);\n    krb5_free_pa_data(kdc_context, e_data);\n    k5_free_data_ptr_list(auth_indicators);\n    krb5_db_free_authdata_info(kdc_context, ad_info);\n    krb5_db_free_authdata_info(kdc_context, stkt_ad_info);\n    krb5_free_principal(kdc_context, stkt_authdata_client);\n\n    return retval;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 333,
    "critical_vars": [
      "mask"
    ],
    "function": "kadm5_create_principal_3",
    "filename": "krb5/CVE-2018-5729/CVE-2018-5729_CWE-476_e1caf6fb74981da62039846931ebdffed71309d1_svr_principal.c.diff",
    "function_code": "kadm5_create_principal_3(void *server_handle,\n                         kadm5_principal_ent_t entry, long mask,\n                         int n_ks_tuple, krb5_key_salt_tuple *ks_tuple,\n                         char *password)\n{\n    krb5_db_entry               *kdb;\n    osa_princ_ent_rec           adb;\n    kadm5_policy_ent_rec        polent;\n    krb5_boolean                have_polent = FALSE;\n    krb5_timestamp              now;\n    krb5_tl_data                *tl_data_tail;\n    unsigned int                ret;\n    kadm5_server_handle_t handle = server_handle;\n    krb5_keyblock               *act_mkey;\n    krb5_kvno                   act_kvno;\n    int                         new_n_ks_tuple = 0;\n    krb5_key_salt_tuple         *new_ks_tuple = NULL;\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    check_1_6_dummy(entry, mask, n_ks_tuple, ks_tuple, &password);\n\n    /*\n     * Argument sanity checking, and opening up the DB\n     */\n    if (entry == NULL)\n        return EINVAL;\n    if(!(mask & KADM5_PRINCIPAL) || (mask & KADM5_MOD_NAME) ||\n       (mask & KADM5_MOD_TIME) || (mask & KADM5_LAST_PWD_CHANGE) ||\n       (mask & KADM5_MKVNO) || (mask & KADM5_AUX_ATTRIBUTES) ||\n       (mask & KADM5_LAST_SUCCESS) || (mask & KADM5_LAST_FAILED) ||\n       (mask & KADM5_FAIL_AUTH_COUNT))\n        return KADM5_BAD_MASK;\n    if ((mask & KADM5_KEY_DATA) && entry->n_key_data != 0)\n        return KADM5_BAD_MASK;\n    if((mask & KADM5_POLICY) && entry->policy == NULL)\n        return KADM5_BAD_MASK;\n    if((mask & KADM5_POLICY) && (mask & KADM5_POLICY_CLR))\n        return KADM5_BAD_MASK;\n    if((mask & ~ALL_PRINC_MASK))\n        return KADM5_BAD_MASK;\n    if (mask & KADM5_TL_DATA) {\n        for (tl_data_tail = entry->tl_data; tl_data_tail != NULL;\n             tl_data_tail = tl_data_tail->tl_data_next) {\n            if (tl_data_tail->tl_data_type < 256)\n                return KADM5_BAD_TL_TYPE;\n        }\n    }\n\n    /*\n     * Check to see if the principal exists\n     */\n    ret = kdb_get_entry(handle, entry->principal, &kdb, &adb);\n\n    switch(ret) {\n    case KADM5_UNK_PRINC:\n        break;\n    case 0:\n        kdb_free_entry(handle, kdb, &adb);\n        return KADM5_DUP;\n    default:\n        return ret;\n    }\n\n    kdb = calloc(1, sizeof(*kdb));\n    if (kdb == NULL)\n        return ENOMEM;\n    memset(&adb, 0, sizeof(osa_princ_ent_rec));\n\n    /*\n     * If a policy was specified, load it.\n     * If we can not find the one specified return an error\n     */\n    if ((mask & KADM5_POLICY)) {\n        ret = get_policy(handle, entry->policy, &polent, &have_polent);\n        if (ret)\n            goto cleanup;\n    }\n    if (password) {\n        ret = passwd_check(handle, password, have_polent ? &polent : NULL,\n                           entry->principal);\n        if (ret)\n            goto cleanup;\n    }\n    /*\n     * Start populating the various DB fields, using the\n     * \"defaults\" for fields that were not specified by the\n     * mask.\n     */\n    if ((ret = krb5_timeofday(handle->context, &now)))\n        goto cleanup;\n\n    kdb->magic = KRB5_KDB_MAGIC_NUMBER;\n    kdb->len = KRB5_KDB_V1_BASE_LENGTH; /* gag me with a chainsaw */\n\n    if ((mask & KADM5_ATTRIBUTES))\n        kdb->attributes = entry->attributes;\n    else\n        kdb->attributes = handle->params.flags;\n\n    if ((mask & KADM5_MAX_LIFE))\n        kdb->max_life = entry->max_life;\n    else\n        kdb->max_life = handle->params.max_life;\n\n    if (mask & KADM5_MAX_RLIFE)\n        kdb->max_renewable_life = entry->max_renewable_life;\n    else\n        kdb->max_renewable_life = handle->params.max_rlife;\n\n    if ((mask & KADM5_PRINC_EXPIRE_TIME))\n        kdb->expiration = entry->princ_expire_time;\n    else\n        kdb->expiration = handle->params.expiration;\n\n    kdb->pw_expiration = 0;\n    if (have_polent) {\n        if(polent.pw_max_life)\n            kdb->pw_expiration = ts_incr(now, polent.pw_max_life);\n        else\n            kdb->pw_expiration = 0;\n    }\n    if ((mask & KADM5_PW_EXPIRATION))\n        kdb->pw_expiration = entry->pw_expiration;\n\n    kdb->last_success = 0;\n    kdb->last_failed = 0;\n    kdb->fail_auth_count = 0;\n\n    /* this is kind of gross, but in order to free the tl data, I need\n       to free the entire kdb entry, and that will try to free the\n       principal. */\n\n    ret = krb5_copy_principal(handle->context, entry->principal, &kdb->princ);\n    if (ret)\n        goto cleanup;\n\n    if ((ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now)))\n        goto cleanup;\n\n    if (mask & KADM5_TL_DATA) {\n        /* splice entry->tl_data onto the front of kdb->tl_data */\n        for (tl_data_tail = entry->tl_data; tl_data_tail;\n             tl_data_tail = tl_data_tail->tl_data_next)\n        {\n            ret = krb5_dbe_update_tl_data(handle->context, kdb, tl_data_tail);\n            if( ret )\n                goto cleanup;\n        }\n    }\n\n    /*\n     * We need to have setup the TL data, so we have strings, so we can\n     * check enctype policy, which is why we check/initialize ks_tuple\n     * this late.\n     */\n    ret = apply_keysalt_policy(handle, entry->policy, n_ks_tuple, ks_tuple,\n                               &new_n_ks_tuple, &new_ks_tuple);\n    if (ret)\n        goto cleanup;\n\n    /* initialize the keys */\n\n    ret = kdb_get_active_mkey(handle, &act_kvno, &act_mkey);\n    if (ret)\n        goto cleanup;\n\n    if (mask & KADM5_KEY_DATA) {\n        /* The client requested no keys for this principal. */\n        assert(entry->n_key_data == 0);\n    } else if (password) {\n        ret = krb5_dbe_cpw(handle->context, act_mkey, new_ks_tuple,\n                           new_n_ks_tuple, password,\n                           (mask & KADM5_KVNO)?entry->kvno:1,\n                           FALSE, kdb);\n    } else {\n        /* Null password means create with random key (new in 1.8). */\n        ret = krb5_dbe_crk(handle->context, &master_keyblock,\n                           new_ks_tuple, new_n_ks_tuple, FALSE, kdb);\n    }\n    if (ret)\n        goto cleanup;\n\n    /* Record the master key VNO used to encrypt this entry's keys */\n    ret = krb5_dbe_update_mkvno(handle->context, kdb, act_kvno);\n    if (ret)\n        goto cleanup;\n\n    ret = k5_kadm5_hook_create(handle->context, handle->hook_handles,\n                               KADM5_HOOK_STAGE_PRECOMMIT, entry, mask,\n                               new_n_ks_tuple, new_ks_tuple, password);\n    if (ret)\n        goto cleanup;\n\n    /* populate the admin-server-specific fields.  In the OV server,\n       this used to be in a separate database.  Since there's already\n       marshalling code for the admin fields, to keep things simple,\n       I'm going to keep it, and make all the admin stuff occupy a\n       single tl_data record, */\n\n    adb.admin_history_kvno = INITIAL_HIST_KVNO;\n    if (mask & KADM5_POLICY) {\n        adb.aux_attributes = KADM5_POLICY;\n\n        /* this does *not* need to be strdup'ed, because adb is xdr */\n        /* encoded in osa_adb_create_princ, and not ever freed */\n\n        adb.policy = entry->policy;\n    }\n\n    /* In all cases key and the principal data is set, let the database provider know */\n    kdb->mask = mask | KADM5_KEY_DATA | KADM5_PRINCIPAL ;\n\n    /* store the new db entry */\n    ret = kdb_put_entry(handle, kdb, &adb);\n\n    (void) k5_kadm5_hook_create(handle->context, handle->hook_handles,\n                                KADM5_HOOK_STAGE_POSTCOMMIT, entry, mask,\n                                new_n_ks_tuple, new_ks_tuple, password);\n\ncleanup:\n    free(new_ks_tuple);\n    krb5_db_free_principal(handle->context, kdb);\n    if (have_polent)\n        (void) kadm5_free_policy_ent(handle->lhandle, &polent);\n    return ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 665,
    "critical_vars": [
      "**values"
    ],
    "function": "krb5_ldap_put_principal",
    "filename": "krb5/CVE-2018-5729/CVE-2018-5729_CWE-476_e1caf6fb74981da62039846931ebdffed71309d1_ldap_principal2.c.diff",
    "function_code": "krb5_ldap_put_principal(krb5_context context, krb5_db_entry *entry,\n                        char **db_args)\n{\n    int                         l=0, kerberos_principal_object_type=0;\n    unsigned int                ntrees=0, tre=0;\n    krb5_error_code             st=0, tempst=0;\n    LDAP                        *ld=NULL;\n    LDAPMessage                 *result=NULL, *ent=NULL;\n    char                        **subtreelist = NULL;\n    char                        *user=NULL, *subtree=NULL, *principal_dn=NULL;\n    char                        **values=NULL, *strval[10]={NULL}, errbuf[1024];\n    char                        *filtuser=NULL;\n    struct berval               **bersecretkey=NULL;\n    LDAPMod                     **mods=NULL;\n    krb5_boolean                create_standalone=FALSE;\n    krb5_boolean                krb_identity_exists=FALSE, establish_links=FALSE;\n    char                        *standalone_principal_dn=NULL;\n    krb5_tl_data                *tl_data=NULL;\n    krb5_key_data               **keys=NULL;\n    kdb5_dal_handle             *dal_handle=NULL;\n    krb5_ldap_context           *ldap_context=NULL;\n    krb5_ldap_server_handle     *ldap_server_handle=NULL;\n    osa_princ_ent_rec           princ_ent = {0};\n    xargs_t                     xargs = {0};\n    char                        *polname = NULL;\n    OPERATION optype;\n    krb5_boolean                found_entry = FALSE;\n\n    /* Clear the global error string */\n    krb5_clear_error_message(context);\n\n    SETUP_CONTEXT();\n    if (ldap_context->lrparams == NULL || ldap_context->container_dn == NULL)\n        return EINVAL;\n\n    /* get ldap handle */\n    GET_HANDLE();\n\n    if (!is_principal_in_realm(ldap_context, entry->princ)) {\n        st = EINVAL;\n        k5_setmsg(context, st,\n                  _(\"Principal does not belong to the default realm\"));\n        goto cleanup;\n    }\n\n    /* get the principal information to act on */\n    if (((st=krb5_unparse_name(context, entry->princ, &user)) != 0) ||\n        ((st=krb5_ldap_unparse_principal_name(user)) != 0))\n        goto cleanup;\n    filtuser = ldap_filter_correct(user);\n    if (filtuser == NULL) {\n        st = ENOMEM;\n        goto cleanup;\n    }\n\n    /* Identity the type of operation, it can be\n     * add principal or modify principal.\n     * hack if the entry->mask has KRB_PRINCIPAL flag set\n     * then it is a add operation\n     */\n    if (entry->mask & KADM5_PRINCIPAL)\n        optype = ADD_PRINCIPAL;\n    else\n        optype = MODIFY_PRINCIPAL;\n\n    if (((st=krb5_get_princ_type(context, entry, &kerberos_principal_object_type)) != 0) ||\n        ((st=krb5_get_userdn(context, entry, &principal_dn)) != 0))\n        goto cleanup;\n\n    if ((st=process_db_args(context, db_args, &xargs, optype)) != 0)\n        goto cleanup;\n\n    if (entry->mask & KADM5_LOAD) {\n        unsigned int     tree = 0;\n        int              numlentries = 0;\n        char             *filter = NULL;\n\n        /*  A load operation is special, will do a mix-in (add krbprinc\n         *  attrs to a non-krb object entry) if an object exists with a\n         *  matching krbprincipalname attribute so try to find existing\n         *  object and set principal_dn.  This assumes that the\n         *  krbprincipalname attribute is unique (only one object entry has\n         *  a particular krbprincipalname attribute).\n         */\n        if (asprintf(&filter, FILTER\"%s))\", filtuser) < 0) {\n            filter = NULL;\n            st = ENOMEM;\n            goto cleanup;\n        }\n\n        /* get the current subtree list */\n        if ((st = krb5_get_subtree_info(ldap_context, &subtreelist, &ntrees)) != 0)\n            goto cleanup;\n\n        found_entry = FALSE;\n        /* search for entry with matching krbprincipalname attribute */\n        for (tree = 0; found_entry == FALSE && tree < ntrees; ++tree) {\n            if (principal_dn == NULL) {\n                LDAP_SEARCH_1(subtreelist[tree], ldap_context->lrparams->search_scope, filter, principal_attributes, IGNORE_STATUS);\n            } else {\n                /* just look for entry with principal_dn */\n                LDAP_SEARCH_1(principal_dn, LDAP_SCOPE_BASE, filter, principal_attributes, IGNORE_STATUS);\n            }\n            if (st == LDAP_SUCCESS) {\n                numlentries = ldap_count_entries(ld, result);\n                if (numlentries > 1) {\n                    free(filter);\n                    st = EINVAL;\n                    k5_setmsg(context, st,\n                              _(\"operation can not continue, more than one \"\n                                \"entry with principal name \\\"%s\\\" found\"),\n                              user);\n                    goto cleanup;\n                } else if (numlentries == 1) {\n                    found_entry = TRUE;\n                    if (principal_dn == NULL) {\n                        ent = ldap_first_entry(ld, result);\n                        if (ent != NULL) {\n                            /* setting principal_dn will cause that entry to be modified further down */\n                            if ((principal_dn = ldap_get_dn(ld, ent)) == NULL) {\n                                ldap_get_option (ld, LDAP_OPT_RESULT_CODE, &st);\n                                st = set_ldap_error (context, st, 0);\n                                free(filter);\n                                goto cleanup;\n                            }\n                        }\n                    }\n                }\n            } else if (st != LDAP_NO_SUCH_OBJECT) {\n                /* could not perform search, return with failure */\n                st = set_ldap_error (context, st, 0);\n                free(filter);\n                goto cleanup;\n            }\n            ldap_msgfree(result);\n            result = NULL;\n            /*\n             * If it isn't found then assume a standalone princ entry is to\n             * be created.\n             */\n        } /* end for (tree = 0; principal_dn == ... */\n\n        free(filter);\n\n        if (found_entry == FALSE && principal_dn != NULL) {\n            /*\n             * if principal_dn is null then there is code further down to\n             * deal with setting standalone_principal_dn.  Also note that\n             * this will set create_standalone true for\n             * non-mix-in entries which is okay if loading from a dump.\n             */\n            create_standalone = TRUE;\n            standalone_principal_dn = strdup(principal_dn);\n            CHECK_NULL(standalone_principal_dn);\n        }\n    } /* end if (entry->mask & KADM5_LOAD */\n\n    /* time to generate the DN information with the help of\n     * containerdn, principalcontainerreference or\n     * realmcontainerdn information\n     */\n    if (principal_dn == NULL && xargs.dn == NULL) { /* creation of standalone principal */\n        /* get the subtree information */\n        if (entry->princ->length == 2 && entry->princ->data[0].length == strlen(\"krbtgt\") &&\n            strncmp(entry->princ->data[0].data, \"krbtgt\", entry->princ->data[0].length) == 0) {\n            /* if the principal is a inter-realm principal, always created in the realm container */\n            subtree = strdup(ldap_context->lrparams->realmdn);\n        } else if (xargs.containerdn) {\n            if ((st=checkattributevalue(ld, xargs.containerdn, NULL, NULL, NULL)) != 0) {\n                if (st == KRB5_KDB_NOENTRY || st == KRB5_KDB_CONSTRAINT_VIOLATION) {\n                    int ost = st;\n                    st = EINVAL;\n                    k5_wrapmsg(context, ost, st, _(\"'%s' not found\"),\n                               xargs.containerdn);\n                }\n                goto cleanup;\n            }\n            subtree = strdup(xargs.containerdn);\n        } else if (ldap_context->lrparams->containerref && strlen(ldap_context->lrparams->containerref) != 0) {\n            /*\n             * Here the subtree should be changed with\n             * principalcontainerreference attribute value\n             */\n            subtree = strdup(ldap_context->lrparams->containerref);\n        } else {\n            subtree = strdup(ldap_context->lrparams->realmdn);\n        }\n        CHECK_NULL(subtree);\n\n        if (asprintf(&standalone_principal_dn, \"krbprincipalname=%s,%s\",\n                     filtuser, subtree) < 0)\n            standalone_principal_dn = NULL;\n        CHECK_NULL(standalone_principal_dn);\n        /*\n         * free subtree when you are done using the subtree\n         * set the boolean create_standalone to TRUE\n         */\n        create_standalone = TRUE;\n        free(subtree);\n        subtree = NULL;\n    }\n\n    /*\n     * If the DN information is presented by the user, time to\n     * validate the input to ensure that the DN falls under\n     * any of the subtrees\n     */\n    if (xargs.dn_from_kbd == TRUE) {\n        /* make sure the DN falls in the subtree */\n        int              dnlen=0, subtreelen=0;\n        char             *dn=NULL;\n        krb5_boolean     outofsubtree=TRUE;\n\n        if (xargs.dn != NULL) {\n            dn = xargs.dn;\n        } else if (xargs.linkdn != NULL) {\n            dn = xargs.linkdn;\n        } else if (standalone_principal_dn != NULL) {\n            /*\n             * Even though the standalone_principal_dn is constructed\n             * within this function, there is the containerdn input\n             * from the user that can become part of the it.\n             */\n            dn = standalone_principal_dn;\n        }\n\n        /* Get the current subtree list if we haven't already done so. */\n        if (subtreelist == NULL) {\n            st = krb5_get_subtree_info(ldap_context, &subtreelist, &ntrees);\n            if (st)\n                goto cleanup;\n        }\n\n        for (tre=0; tre<ntrees; ++tre) {\n            if (subtreelist[tre] == NULL || strlen(subtreelist[tre]) == 0) {\n                outofsubtree = FALSE;\n                break;\n            } else {\n                dnlen = strlen (dn);\n                subtreelen = strlen(subtreelist[tre]);\n                if ((dnlen >= subtreelen) && (strcasecmp((dn + dnlen - subtreelen), subtreelist[tre]) == 0)) {\n                    outofsubtree = FALSE;\n                    break;\n                }\n            }\n        }\n\n        if (outofsubtree == TRUE) {\n            st = EINVAL;\n            k5_setmsg(context, st, _(\"DN is out of the realm subtree\"));\n            goto cleanup;\n        }\n\n        /*\n         * dn value will be set either by dn, linkdn or the standalone_principal_dn\n         * In the first 2 cases, the dn should be existing and in the last case we\n         * are supposed to create the ldap object. so the below should not be\n         * executed for the last case.\n         */\n\n        if (standalone_principal_dn == NULL) {\n            /*\n             * If the ldap object is missing, this results in an error.\n             */\n\n            /*\n             * Search for krbprincipalname attribute here.\n             * This is to find if a kerberos identity is already present\n             * on the ldap object, in which case adding a kerberos identity\n             * on the ldap object should result in an error.\n             */\n            char  *attributes[]={\"krbticketpolicyreference\", \"krbprincipalname\", NULL};\n\n            ldap_msgfree(result);\n            result = NULL;\n            LDAP_SEARCH_1(dn, LDAP_SCOPE_BASE, 0, attributes, IGNORE_STATUS);\n            if (st == LDAP_SUCCESS) {\n                ent = ldap_first_entry(ld, result);\n                if (ent != NULL) {\n                    if ((values=ldap_get_values(ld, ent, \"krbticketpolicyreference\")) != NULL) {\n                        ldap_value_free(values);\n                    }\n\n                    if ((values=ldap_get_values(ld, ent, \"krbprincipalname\")) != NULL) {\n                        krb_identity_exists = TRUE;\n                        ldap_value_free(values);\n                    }\n                }\n            } else {\n                st = set_ldap_error(context, st, OP_SEARCH);\n                goto cleanup;\n            }\n        }\n    }\n\n    /*\n     * If xargs.dn is set then the request is to add a\n     * kerberos principal on a ldap object, but if\n     * there is one already on the ldap object this\n     * should result in an error.\n     */\n\n    if (xargs.dn != NULL && krb_identity_exists == TRUE) {\n        st = EINVAL;\n        snprintf(errbuf, sizeof(errbuf),\n                 _(\"ldap object is already kerberized\"));\n        k5_setmsg(context, st, \"%s\", errbuf);\n        goto cleanup;\n    }\n\n    if (xargs.linkdn != NULL) {\n        /*\n         * link information can be changed using modprinc.\n         * However, link information can be changed only on the\n         * standalone kerberos principal objects. A standalone\n         * kerberos principal object is of type krbprincipal\n         * structural objectclass.\n         *\n         * NOTE: kerberos principals on an ldap object can't be\n         * linked to other ldap objects.\n         */\n        if (optype == MODIFY_PRINCIPAL &&\n            kerberos_principal_object_type != KDB_STANDALONE_PRINCIPAL_OBJECT) {\n            st = EINVAL;\n            snprintf(errbuf, sizeof(errbuf),\n                     _(\"link information can not be set/updated as the \"\n                       \"kerberos principal belongs to an ldap object\"));\n            k5_setmsg(context, st, \"%s\", errbuf);\n            goto cleanup;\n        }\n        /*\n         * Check the link information. If there is already a link\n         * existing then this operation is not allowed.\n         */\n        {\n            char **linkdns=NULL;\n            int  j=0;\n\n            if ((st=krb5_get_linkdn(context, entry, &linkdns)) != 0) {\n                snprintf(errbuf, sizeof(errbuf),\n                         _(\"Failed getting object references\"));\n                k5_setmsg(context, st, \"%s\", errbuf);\n                goto cleanup;\n            }\n            if (linkdns != NULL) {\n                st = EINVAL;\n                snprintf(errbuf, sizeof(errbuf),\n                         _(\"kerberos principal is already linked to a ldap \"\n                           \"object\"));\n                k5_setmsg(context, st, \"%s\", errbuf);\n                for (j=0; linkdns[j] != NULL; ++j)\n                    free (linkdns[j]);\n                free (linkdns);\n                goto cleanup;\n            }\n        }\n\n        establish_links = TRUE;\n    }\n\n    if (entry->mask & KADM5_LAST_SUCCESS) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->last_success)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastSuccessfulAuth\", LDAP_MOD_REPLACE, strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free (strval[0]);\n    }\n\n    if (entry->mask & KADM5_LAST_FAILED) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->last_failed)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastFailedAuth\", LDAP_MOD_REPLACE, strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free(strval[0]);\n    }\n\n    if (entry->mask & KADM5_FAIL_AUTH_COUNT) {\n        krb5_kvno fail_auth_count;\n\n        fail_auth_count = entry->fail_auth_count;\n        if (entry->mask & KADM5_FAIL_AUTH_COUNT_INCREMENT)\n            fail_auth_count++;\n\n        st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                       LDAP_MOD_REPLACE,\n                                       fail_auth_count);\n        if (st != 0)\n            goto cleanup;\n    } else if (entry->mask & KADM5_FAIL_AUTH_COUNT_INCREMENT) {\n        int attr_mask = 0;\n        krb5_boolean has_fail_count;\n\n        /* Check if the krbLoginFailedCount attribute exists.  (Through\n         * krb5 1.8.1, it wasn't set in new entries.) */\n        st = krb5_get_attributes_mask(context, entry, &attr_mask);\n        if (st != 0)\n            goto cleanup;\n        has_fail_count = ((attr_mask & KDB_FAIL_AUTH_COUNT_ATTR) != 0);\n\n        /*\n         * If the client library and server supports RFC 4525,\n         * then use it to increment by one the value of the\n         * krbLoginFailedCount attribute. Otherwise, assert the\n         * (provided) old value by deleting it before adding.\n         */\n#ifdef LDAP_MOD_INCREMENT\n        if (ldap_server_handle->server_info->modify_increment &&\n            has_fail_count) {\n            st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                           LDAP_MOD_INCREMENT, 1);\n            if (st != 0)\n                goto cleanup;\n        } else {\n#endif /* LDAP_MOD_INCREMENT */\n            if (has_fail_count) {\n                st = krb5_add_int_mem_ldap_mod(&mods,\n                                               \"krbLoginFailedCount\",\n                                               LDAP_MOD_DELETE,\n                                               entry->fail_auth_count);\n                if (st != 0)\n                    goto cleanup;\n            }\n            st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                           LDAP_MOD_ADD,\n                                           entry->fail_auth_count + 1);\n            if (st != 0)\n                goto cleanup;\n#ifdef LDAP_MOD_INCREMENT\n        }\n#endif\n    } else if (optype == ADD_PRINCIPAL) {\n        /* Initialize krbLoginFailedCount in new entries to help avoid a\n         * race during the first failed login. */\n        st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                       LDAP_MOD_ADD, 0);\n    }\n\n    if (entry->mask & KADM5_MAX_LIFE) {\n        if ((st=krb5_add_int_mem_ldap_mod(&mods, \"krbmaxticketlife\", LDAP_MOD_REPLACE, entry->max_life)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_MAX_RLIFE) {\n        if ((st=krb5_add_int_mem_ldap_mod(&mods, \"krbmaxrenewableage\", LDAP_MOD_REPLACE,\n                                          entry->max_renewable_life)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_ATTRIBUTES) {\n        if ((st=krb5_add_int_mem_ldap_mod(&mods, \"krbticketflags\", LDAP_MOD_REPLACE,\n                                          entry->attributes)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_PRINCIPAL) {\n        memset(strval, 0, sizeof(strval));\n        strval[0] = user;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbprincipalname\", LDAP_MOD_REPLACE, strval)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_PRINC_EXPIRE_TIME) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->expiration)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbprincipalexpiration\", LDAP_MOD_REPLACE, strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free (strval[0]);\n    }\n\n    if (entry->mask & KADM5_PW_EXPIRATION) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->pw_expiration)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpasswordexpiration\",\n                                          LDAP_MOD_REPLACE,\n                                          strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free (strval[0]);\n    }\n\n    if (entry->mask & KADM5_POLICY || entry->mask & KADM5_KEY_HIST) {\n        memset(&princ_ent, 0, sizeof(princ_ent));\n        for (tl_data=entry->tl_data; tl_data; tl_data=tl_data->tl_data_next) {\n            if (tl_data->tl_data_type == KRB5_TL_KADM_DATA) {\n                if ((st = krb5_lookup_tl_kadm_data(tl_data, &princ_ent)) != 0) {\n                    goto cleanup;\n                }\n                break;\n            }\n        }\n    }\n\n    if (entry->mask & KADM5_POLICY) {\n        if (princ_ent.aux_attributes & KADM5_POLICY) {\n            memset(strval, 0, sizeof(strval));\n            if ((st = krb5_ldap_name_to_policydn (context, princ_ent.policy, &polname)) != 0)\n                goto cleanup;\n            strval[0] = polname;\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpwdpolicyreference\", LDAP_MOD_REPLACE, strval)) != 0)\n                goto cleanup;\n        } else {\n            st = EINVAL;\n            k5_setmsg(context, st, \"Password policy value null\");\n            goto cleanup;\n        }\n    } else if (entry->mask & KADM5_LOAD && found_entry == TRUE) {\n        /*\n         * a load is special in that existing entries must have attrs that\n         * removed.\n         */\n\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpwdpolicyreference\", LDAP_MOD_REPLACE, NULL)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_POLICY_CLR) {\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpwdpolicyreference\", LDAP_MOD_DELETE, NULL)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_KEY_HIST) {\n        bersecretkey = krb5_encode_histkey(&princ_ent);\n        if (bersecretkey == NULL) {\n            st = ENOMEM;\n            goto cleanup;\n        }\n\n        st = krb5_add_ber_mem_ldap_mod(&mods, \"krbpwdhistory\",\n                                       LDAP_MOD_REPLACE | LDAP_MOD_BVALUES,\n                                       bersecretkey);\n        if (st != 0)\n            goto cleanup;\n        free_berdata(bersecretkey);\n        bersecretkey = NULL;\n    }\n\n    if (entry->mask & KADM5_KEY_DATA || entry->mask & KADM5_KVNO) {\n        krb5_kvno mkvno;\n\n        if ((st=krb5_dbe_lookup_mkvno(context, entry, &mkvno)) != 0)\n            goto cleanup;\n        bersecretkey = krb5_encode_krbsecretkey (entry->key_data,\n                                                 entry->n_key_data, mkvno);\n\n        if (bersecretkey == NULL) {\n            st = ENOMEM;\n            goto cleanup;\n        }\n        /* An empty list of bervals is only accepted for modify operations,\n         * not add operations. */\n        if (bersecretkey[0] != NULL || !create_standalone) {\n            st = krb5_add_ber_mem_ldap_mod(&mods, \"krbprincipalkey\",\n                                           LDAP_MOD_REPLACE | LDAP_MOD_BVALUES,\n                                           bersecretkey);\n            if (st != 0)\n                goto cleanup;\n        }\n\n        if (!(entry->mask & KADM5_PRINCIPAL)) {\n            memset(strval, 0, sizeof(strval));\n            if ((strval[0]=getstringtime(entry->pw_expiration)) == NULL)\n                goto cleanup;\n            if ((st=krb5_add_str_mem_ldap_mod(&mods,\n                                              \"krbpasswordexpiration\",\n                                              LDAP_MOD_REPLACE, strval)) != 0) {\n                free (strval[0]);\n                goto cleanup;\n            }\n            free (strval[0]);\n        }\n\n        /* Update last password change whenever a new key is set */\n        {\n            krb5_timestamp last_pw_changed;\n            if ((st=krb5_dbe_lookup_last_pwd_change(context, entry,\n                                                    &last_pw_changed)) != 0)\n                goto cleanup;\n\n            memset(strval, 0, sizeof(strval));\n            if ((strval[0] = getstringtime(last_pw_changed)) == NULL)\n                goto cleanup;\n\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastPwdChange\",\n                                              LDAP_MOD_REPLACE, strval)) != 0) {\n                free (strval[0]);\n                goto cleanup;\n            }\n            free (strval[0]);\n        }\n\n    } /* Modify Key data ends here */\n\n    /* Auth indicators will also be stored in krbExtraData when processing\n     * tl_data. */\n    st = update_ldap_mod_auth_ind(context, entry, &mods);\n    if (st != 0)\n        goto cleanup;\n\n    /* Set tl_data */\n    if (entry->tl_data != NULL) {\n        int count = 0;\n        struct berval **ber_tl_data = NULL;\n        krb5_tl_data *ptr;\n        krb5_timestamp unlock_time;\n        for (ptr = entry->tl_data; ptr != NULL; ptr = ptr->tl_data_next) {\n            if (ptr->tl_data_type == KRB5_TL_LAST_PWD_CHANGE\n#ifdef SECURID\n                || ptr->tl_data_type == KRB5_TL_DB_ARGS\n#endif\n                || ptr->tl_data_type == KRB5_TL_KADM_DATA\n                || ptr->tl_data_type == KDB_TL_USER_INFO\n                || ptr->tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL\n                || ptr->tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK)\n                continue;\n            count++;\n        }\n        if (count != 0) {\n            int j;\n            ber_tl_data = (struct berval **) calloc (count + 1,\n                                                     sizeof (struct berval*));\n            if (ber_tl_data == NULL) {\n                st = ENOMEM;\n                goto cleanup;\n            }\n            for (j = 0, ptr = entry->tl_data; ptr != NULL; ptr = ptr->tl_data_next) {\n                /* Ignore tl_data that are stored in separate directory\n                 * attributes */\n                if (ptr->tl_data_type == KRB5_TL_LAST_PWD_CHANGE\n#ifdef SECURID\n                    || ptr->tl_data_type == KRB5_TL_DB_ARGS\n#endif\n                    || ptr->tl_data_type == KRB5_TL_KADM_DATA\n                    || ptr->tl_data_type == KDB_TL_USER_INFO\n                    || ptr->tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL\n                    || ptr->tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK)\n                    continue;\n                if ((st = tl_data2berval (ptr, &ber_tl_data[j])) != 0)\n                    break;\n                j++;\n            }\n            if (st == 0) {\n                ber_tl_data[count] = NULL;\n                st=krb5_add_ber_mem_ldap_mod(&mods, \"krbExtraData\",\n                                             LDAP_MOD_REPLACE |\n                                             LDAP_MOD_BVALUES, ber_tl_data);\n            }\n            free_berdata(ber_tl_data);\n            if (st != 0)\n                goto cleanup;\n        }\n        if ((st=krb5_dbe_lookup_last_admin_unlock(context, entry,\n                                                  &unlock_time)) != 0)\n            goto cleanup;\n        if (unlock_time != 0) {\n            /* Update last admin unlock */\n            memset(strval, 0, sizeof(strval));\n            if ((strval[0] = getstringtime(unlock_time)) == NULL)\n                goto cleanup;\n\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastAdminUnlock\",\n                                              LDAP_MOD_REPLACE, strval)) != 0) {\n                free (strval[0]);\n                goto cleanup;\n            }\n            free (strval[0]);\n        }\n    }\n\n    /* Directory specific attribute */\n    if (xargs.tktpolicydn != NULL) {\n        int tmask=0;\n\n        if (strlen(xargs.tktpolicydn) != 0) {\n            st = checkattributevalue(ld, xargs.tktpolicydn, \"objectclass\", policyclass, &tmask);\n            CHECK_CLASS_VALIDITY(st, tmask, _(\"ticket policy object value: \"));\n\n            strval[0] = xargs.tktpolicydn;\n            strval[1] = NULL;\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbticketpolicyreference\", LDAP_MOD_REPLACE, strval)) != 0)\n                goto cleanup;\n\n        } else {\n            /* if xargs.tktpolicydn is a empty string, then delete\n             * already existing krbticketpolicyreference attr */\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbticketpolicyreference\", LDAP_MOD_DELETE, NULL)) != 0)\n                goto cleanup;\n        }\n\n    }\n\n    if (establish_links == TRUE) {\n        memset(strval, 0, sizeof(strval));\n        strval[0] = xargs.linkdn;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbObjectReferences\", LDAP_MOD_REPLACE, strval)) != 0)\n            goto cleanup;\n    }\n\n    /*\n     * in case mods is NULL then return\n     * not sure but can happen in a modprinc\n     * so no need to return an error\n     * addprinc will at least have the principal name\n     * and the keys passed in\n     */\n    if (mods == NULL)\n        goto cleanup;\n\n    if (create_standalone == TRUE) {\n        memset(strval, 0, sizeof(strval));\n        strval[0] = \"krbprincipal\";\n        strval[1] = \"krbprincipalaux\";\n        strval[2] = \"krbTicketPolicyAux\";\n\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"objectclass\", LDAP_MOD_ADD, strval)) != 0)\n            goto cleanup;\n\n        st = ldap_add_ext_s(ld, standalone_principal_dn, mods, NULL, NULL);\n        if (st == LDAP_ALREADY_EXISTS && entry->mask & KADM5_LOAD) {\n            /* a load operation must replace an existing entry */\n            st = ldap_delete_ext_s(ld, standalone_principal_dn, NULL, NULL);\n            if (st != LDAP_SUCCESS) {\n                snprintf(errbuf, sizeof(errbuf),\n                         _(\"Principal delete failed (trying to replace \"\n                           \"entry): %s\"), ldap_err2string(st));\n                st = translate_ldap_error (st, OP_ADD);\n                k5_setmsg(context, st, \"%s\", errbuf);\n                goto cleanup;\n            } else {\n                st = ldap_add_ext_s(ld, standalone_principal_dn, mods, NULL, NULL);\n            }\n        }\n        if (st != LDAP_SUCCESS) {\n            snprintf(errbuf, sizeof(errbuf), _(\"Principal add failed: %s\"),\n                     ldap_err2string(st));\n            st = translate_ldap_error (st, OP_ADD);\n            k5_setmsg(context, st, \"%s\", errbuf);\n            goto cleanup;\n        }\n    } else {\n        /*\n         * Here existing ldap object is modified and can be related\n         * to any attribute, so always ensure that the ldap\n         * object is extended with all the kerberos related\n         * objectclasses so that there are no constraint\n         * violations.\n         */\n        {\n            char *attrvalues[] = {\"krbprincipalaux\", \"krbTicketPolicyAux\", NULL};\n            int p, q, r=0, amask=0;\n\n            if ((st=checkattributevalue(ld, (xargs.dn) ? xargs.dn : principal_dn,\n                                        \"objectclass\", attrvalues, &amask)) != 0)\n                goto cleanup;\n\n            memset(strval, 0, sizeof(strval));\n            for (p=1, q=0; p<=2; p<<=1, ++q) {\n                if ((p & amask) == 0)\n                    strval[r++] = attrvalues[q];\n            }\n            if (r != 0) {\n                if ((st=krb5_add_str_mem_ldap_mod(&mods, \"objectclass\", LDAP_MOD_ADD, strval)) != 0)\n                    goto cleanup;\n            }\n        }\n        if (xargs.dn != NULL)\n            st=ldap_modify_ext_s(ld, xargs.dn, mods, NULL, NULL);\n        else\n            st = ldap_modify_ext_s(ld, principal_dn, mods, NULL, NULL);\n\n        if (st != LDAP_SUCCESS) {\n            snprintf(errbuf, sizeof(errbuf), _(\"User modification failed: %s\"),\n                     ldap_err2string(st));\n            st = translate_ldap_error (st, OP_MOD);\n            k5_setmsg(context, st, \"%s\", errbuf);\n            goto cleanup;\n        }\n\n        if (entry->mask & KADM5_FAIL_AUTH_COUNT_INCREMENT)\n            entry->fail_auth_count++;\n    }\n\ncleanup:\n    if (user)\n        free(user);\n\n    if (filtuser)\n        free(filtuser);\n\n    free_xargs(xargs);\n\n    if (standalone_principal_dn)\n        free(standalone_principal_dn);\n\n    if (principal_dn)\n        free (principal_dn);\n\n    if (polname != NULL)\n        free(polname);\n\n    for (tre = 0; tre < ntrees; tre++)\n        free(subtreelist[tre]);\n    free(subtreelist);\n\n    if (subtree)\n        free (subtree);\n\n    if (bersecretkey) {\n        for (l=0; bersecretkey[l]; ++l) {\n            if (bersecretkey[l]->bv_val)\n                free (bersecretkey[l]->bv_val);\n            free (bersecretkey[l]);\n        }\n        free (bersecretkey);\n    }\n\n    if (keys)\n        free (keys);\n\n    ldap_mods_free(mods, 1);\n    ldap_osa_free_princ_ent(&princ_ent);\n    ldap_msgfree(result);\n    krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);\n    return(st);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 766,
    "critical_vars": [
      "char*strval[10]"
    ],
    "function": "krb5_ldap_put_principal",
    "filename": "krb5/CVE-2018-5729/CVE-2018-5729_CWE-476_e1caf6fb74981da62039846931ebdffed71309d1_ldap_principal2.c.diff",
    "function_code": "krb5_ldap_put_principal(krb5_context context, krb5_db_entry *entry,\n                        char **db_args)\n{\n    int                         l=0, kerberos_principal_object_type=0;\n    unsigned int                ntrees=0, tre=0;\n    krb5_error_code             st=0, tempst=0;\n    LDAP                        *ld=NULL;\n    LDAPMessage                 *result=NULL, *ent=NULL;\n    char                        **subtreelist = NULL;\n    char                        *user=NULL, *subtree=NULL, *principal_dn=NULL;\n    char                        *strval[10]={NULL}, errbuf[1024];\n    char                        *filtuser=NULL;\n    struct berval               **bersecretkey=NULL;\n    LDAPMod                     **mods=NULL;\n    krb5_boolean                create_standalone=FALSE;\n    krb5_boolean                establish_links=FALSE;\n    char                        *standalone_principal_dn=NULL;\n    krb5_tl_data                *tl_data=NULL;\n    krb5_key_data               **keys=NULL;\n    kdb5_dal_handle             *dal_handle=NULL;\n    krb5_ldap_context           *ldap_context=NULL;\n    krb5_ldap_server_handle     *ldap_server_handle=NULL;\n    osa_princ_ent_rec           princ_ent = {0};\n    xargs_t                     xargs = {0};\n    char                        *polname = NULL;\n    OPERATION optype;\n    krb5_boolean                found_entry = FALSE;\n\n    /* Clear the global error string */\n    krb5_clear_error_message(context);\n\n    SETUP_CONTEXT();\n    if (ldap_context->lrparams == NULL || ldap_context->container_dn == NULL)\n        return EINVAL;\n\n    /* get ldap handle */\n    GET_HANDLE();\n\n    if (!is_principal_in_realm(ldap_context, entry->princ)) {\n        st = EINVAL;\n        k5_setmsg(context, st,\n                  _(\"Principal does not belong to the default realm\"));\n        goto cleanup;\n    }\n\n    /* get the principal information to act on */\n    if (((st=krb5_unparse_name(context, entry->princ, &user)) != 0) ||\n        ((st=krb5_ldap_unparse_principal_name(user)) != 0))\n        goto cleanup;\n    filtuser = ldap_filter_correct(user);\n    if (filtuser == NULL) {\n        st = ENOMEM;\n        goto cleanup;\n    }\n\n    /* Identity the type of operation, it can be\n     * add principal or modify principal.\n     * hack if the entry->mask has KRB_PRINCIPAL flag set\n     * then it is a add operation\n     */\n    if (entry->mask & KADM5_PRINCIPAL)\n        optype = ADD_PRINCIPAL;\n    else\n        optype = MODIFY_PRINCIPAL;\n\n    if (((st=krb5_get_princ_type(context, entry, &kerberos_principal_object_type)) != 0) ||\n        ((st=krb5_get_userdn(context, entry, &principal_dn)) != 0))\n        goto cleanup;\n\n    if ((st=process_db_args(context, db_args, &xargs, optype)) != 0)\n        goto cleanup;\n\n    if (entry->mask & KADM5_LOAD) {\n        unsigned int     tree = 0;\n        int              numlentries = 0;\n        char             *filter = NULL;\n\n        /*  A load operation is special, will do a mix-in (add krbprinc\n         *  attrs to a non-krb object entry) if an object exists with a\n         *  matching krbprincipalname attribute so try to find existing\n         *  object and set principal_dn.  This assumes that the\n         *  krbprincipalname attribute is unique (only one object entry has\n         *  a particular krbprincipalname attribute).\n         */\n        if (asprintf(&filter, FILTER\"%s))\", filtuser) < 0) {\n            filter = NULL;\n            st = ENOMEM;\n            goto cleanup;\n        }\n\n        /* get the current subtree list */\n        if ((st = krb5_get_subtree_info(ldap_context, &subtreelist, &ntrees)) != 0)\n            goto cleanup;\n\n        found_entry = FALSE;\n        /* search for entry with matching krbprincipalname attribute */\n        for (tree = 0; found_entry == FALSE && tree < ntrees; ++tree) {\n            if (principal_dn == NULL) {\n                LDAP_SEARCH_1(subtreelist[tree], ldap_context->lrparams->search_scope, filter, principal_attributes, IGNORE_STATUS);\n            } else {\n                /* just look for entry with principal_dn */\n                LDAP_SEARCH_1(principal_dn, LDAP_SCOPE_BASE, filter, principal_attributes, IGNORE_STATUS);\n            }\n            if (st == LDAP_SUCCESS) {\n                numlentries = ldap_count_entries(ld, result);\n                if (numlentries > 1) {\n                    free(filter);\n                    st = EINVAL;\n                    k5_setmsg(context, st,\n                              _(\"operation can not continue, more than one \"\n                                \"entry with principal name \\\"%s\\\" found\"),\n                              user);\n                    goto cleanup;\n                } else if (numlentries == 1) {\n                    found_entry = TRUE;\n                    if (principal_dn == NULL) {\n                        ent = ldap_first_entry(ld, result);\n                        if (ent != NULL) {\n                            /* setting principal_dn will cause that entry to be modified further down */\n                            if ((principal_dn = ldap_get_dn(ld, ent)) == NULL) {\n                                ldap_get_option (ld, LDAP_OPT_RESULT_CODE, &st);\n                                st = set_ldap_error (context, st, 0);\n                                free(filter);\n                                goto cleanup;\n                            }\n                        }\n                    }\n                }\n            } else if (st != LDAP_NO_SUCH_OBJECT) {\n                /* could not perform search, return with failure */\n                st = set_ldap_error (context, st, 0);\n                free(filter);\n                goto cleanup;\n            }\n            ldap_msgfree(result);\n            result = NULL;\n            /*\n             * If it isn't found then assume a standalone princ entry is to\n             * be created.\n             */\n        } /* end for (tree = 0; principal_dn == ... */\n\n        free(filter);\n\n        if (found_entry == FALSE && principal_dn != NULL) {\n            /*\n             * if principal_dn is null then there is code further down to\n             * deal with setting standalone_principal_dn.  Also note that\n             * this will set create_standalone true for\n             * non-mix-in entries which is okay if loading from a dump.\n             */\n            create_standalone = TRUE;\n            standalone_principal_dn = strdup(principal_dn);\n            CHECK_NULL(standalone_principal_dn);\n        }\n    } /* end if (entry->mask & KADM5_LOAD */\n\n    /* time to generate the DN information with the help of\n     * containerdn, principalcontainerreference or\n     * realmcontainerdn information\n     */\n    if (principal_dn == NULL && xargs.dn == NULL) { /* creation of standalone principal */\n        /* get the subtree information */\n        if (entry->princ->length == 2 && entry->princ->data[0].length == strlen(\"krbtgt\") &&\n            strncmp(entry->princ->data[0].data, \"krbtgt\", entry->princ->data[0].length) == 0) {\n            /* if the principal is a inter-realm principal, always created in the realm container */\n            subtree = strdup(ldap_context->lrparams->realmdn);\n        } else if (xargs.containerdn) {\n            if ((st=checkattributevalue(ld, xargs.containerdn, NULL, NULL, NULL)) != 0) {\n                if (st == KRB5_KDB_NOENTRY || st == KRB5_KDB_CONSTRAINT_VIOLATION) {\n                    int ost = st;\n                    st = EINVAL;\n                    k5_wrapmsg(context, ost, st, _(\"'%s' not found\"),\n                               xargs.containerdn);\n                }\n                goto cleanup;\n            }\n            subtree = strdup(xargs.containerdn);\n        } else if (ldap_context->lrparams->containerref && strlen(ldap_context->lrparams->containerref) != 0) {\n            /*\n             * Here the subtree should be changed with\n             * principalcontainerreference attribute value\n             */\n            subtree = strdup(ldap_context->lrparams->containerref);\n        } else {\n            subtree = strdup(ldap_context->lrparams->realmdn);\n        }\n        CHECK_NULL(subtree);\n\n        if (asprintf(&standalone_principal_dn, \"krbprincipalname=%s,%s\",\n                     filtuser, subtree) < 0)\n            standalone_principal_dn = NULL;\n        CHECK_NULL(standalone_principal_dn);\n        /*\n         * free subtree when you are done using the subtree\n         * set the boolean create_standalone to TRUE\n         */\n        create_standalone = TRUE;\n        free(subtree);\n        subtree = NULL;\n    }\n\n    /*\n     * If the DN information is presented by the user, time to\n     * validate the input to ensure that the DN falls under\n     * any of the subtrees\n     */\n    if (xargs.dn_from_kbd == TRUE) {\n        /* Get the current subtree list if we haven't already done so. */\n        if (subtreelist == NULL) {\n            st = krb5_get_subtree_info(ldap_context, &subtreelist, &ntrees);\n            if (st)\n                goto cleanup;\n        }\n\n        st = validate_xargs(context, ldap_server_handle, &xargs,\n                            standalone_principal_dn, subtreelist, ntrees);\n        if (st)\n            goto cleanup;\n    }\n\n    if (xargs.linkdn != NULL) {\n        /*\n         * link information can be changed using modprinc.\n         * However, link information can be changed only on the\n         * standalone kerberos principal objects. A standalone\n         * kerberos principal object is of type krbprincipal\n         * structural objectclass.\n         *\n         * NOTE: kerberos principals on an ldap object can't be\n         * linked to other ldap objects.\n         */\n        if (optype == MODIFY_PRINCIPAL &&\n            kerberos_principal_object_type != KDB_STANDALONE_PRINCIPAL_OBJECT) {\n            st = EINVAL;\n            snprintf(errbuf, sizeof(errbuf),\n                     _(\"link information can not be set/updated as the \"\n                       \"kerberos principal belongs to an ldap object\"));\n            k5_setmsg(context, st, \"%s\", errbuf);\n            goto cleanup;\n        }\n        /*\n         * Check the link information. If there is already a link\n         * existing then this operation is not allowed.\n         */\n        {\n            char **linkdns=NULL;\n            int  j=0;\n\n            if ((st=krb5_get_linkdn(context, entry, &linkdns)) != 0) {\n                snprintf(errbuf, sizeof(errbuf),\n                         _(\"Failed getting object references\"));\n                k5_setmsg(context, st, \"%s\", errbuf);\n                goto cleanup;\n            }\n            if (linkdns != NULL) {\n                st = EINVAL;\n                snprintf(errbuf, sizeof(errbuf),\n                         _(\"kerberos principal is already linked to a ldap \"\n                           \"object\"));\n                k5_setmsg(context, st, \"%s\", errbuf);\n                for (j=0; linkdns[j] != NULL; ++j)\n                    free (linkdns[j]);\n                free (linkdns);\n                goto cleanup;\n            }\n        }\n\n        establish_links = TRUE;\n    }\n\n    if (entry->mask & KADM5_LAST_SUCCESS) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->last_success)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastSuccessfulAuth\", LDAP_MOD_REPLACE, strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free (strval[0]);\n    }\n\n    if (entry->mask & KADM5_LAST_FAILED) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->last_failed)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastFailedAuth\", LDAP_MOD_REPLACE, strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free(strval[0]);\n    }\n\n    if (entry->mask & KADM5_FAIL_AUTH_COUNT) {\n        krb5_kvno fail_auth_count;\n\n        fail_auth_count = entry->fail_auth_count;\n        if (entry->mask & KADM5_FAIL_AUTH_COUNT_INCREMENT)\n            fail_auth_count++;\n\n        st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                       LDAP_MOD_REPLACE,\n                                       fail_auth_count);\n        if (st != 0)\n            goto cleanup;\n    } else if (entry->mask & KADM5_FAIL_AUTH_COUNT_INCREMENT) {\n        int attr_mask = 0;\n        krb5_boolean has_fail_count;\n\n        /* Check if the krbLoginFailedCount attribute exists.  (Through\n         * krb5 1.8.1, it wasn't set in new entries.) */\n        st = krb5_get_attributes_mask(context, entry, &attr_mask);\n        if (st != 0)\n            goto cleanup;\n        has_fail_count = ((attr_mask & KDB_FAIL_AUTH_COUNT_ATTR) != 0);\n\n        /*\n         * If the client library and server supports RFC 4525,\n         * then use it to increment by one the value of the\n         * krbLoginFailedCount attribute. Otherwise, assert the\n         * (provided) old value by deleting it before adding.\n         */\n#ifdef LDAP_MOD_INCREMENT\n        if (ldap_server_handle->server_info->modify_increment &&\n            has_fail_count) {\n            st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                           LDAP_MOD_INCREMENT, 1);\n            if (st != 0)\n                goto cleanup;\n        } else {\n#endif /* LDAP_MOD_INCREMENT */\n            if (has_fail_count) {\n                st = krb5_add_int_mem_ldap_mod(&mods,\n                                               \"krbLoginFailedCount\",\n                                               LDAP_MOD_DELETE,\n                                               entry->fail_auth_count);\n                if (st != 0)\n                    goto cleanup;\n            }\n            st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                           LDAP_MOD_ADD,\n                                           entry->fail_auth_count + 1);\n            if (st != 0)\n                goto cleanup;\n#ifdef LDAP_MOD_INCREMENT\n        }\n#endif\n    } else if (optype == ADD_PRINCIPAL) {\n        /* Initialize krbLoginFailedCount in new entries to help avoid a\n         * race during the first failed login. */\n        st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                       LDAP_MOD_ADD, 0);\n    }\n\n    if (entry->mask & KADM5_MAX_LIFE) {\n        if ((st=krb5_add_int_mem_ldap_mod(&mods, \"krbmaxticketlife\", LDAP_MOD_REPLACE, entry->max_life)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_MAX_RLIFE) {\n        if ((st=krb5_add_int_mem_ldap_mod(&mods, \"krbmaxrenewableage\", LDAP_MOD_REPLACE,\n                                          entry->max_renewable_life)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_ATTRIBUTES) {\n        if ((st=krb5_add_int_mem_ldap_mod(&mods, \"krbticketflags\", LDAP_MOD_REPLACE,\n                                          entry->attributes)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_PRINCIPAL) {\n        memset(strval, 0, sizeof(strval));\n        strval[0] = user;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbprincipalname\", LDAP_MOD_REPLACE, strval)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_PRINC_EXPIRE_TIME) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->expiration)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbprincipalexpiration\", LDAP_MOD_REPLACE, strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free (strval[0]);\n    }\n\n    if (entry->mask & KADM5_PW_EXPIRATION) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->pw_expiration)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpasswordexpiration\",\n                                          LDAP_MOD_REPLACE,\n                                          strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free (strval[0]);\n    }\n\n    if (entry->mask & KADM5_POLICY || entry->mask & KADM5_KEY_HIST) {\n        memset(&princ_ent, 0, sizeof(princ_ent));\n        for (tl_data=entry->tl_data; tl_data; tl_data=tl_data->tl_data_next) {\n            if (tl_data->tl_data_type == KRB5_TL_KADM_DATA) {\n                if ((st = krb5_lookup_tl_kadm_data(tl_data, &princ_ent)) != 0) {\n                    goto cleanup;\n                }\n                break;\n            }\n        }\n    }\n\n    if (entry->mask & KADM5_POLICY) {\n        if (princ_ent.aux_attributes & KADM5_POLICY) {\n            memset(strval, 0, sizeof(strval));\n            if ((st = krb5_ldap_name_to_policydn (context, princ_ent.policy, &polname)) != 0)\n                goto cleanup;\n            strval[0] = polname;\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpwdpolicyreference\", LDAP_MOD_REPLACE, strval)) != 0)\n                goto cleanup;\n        } else {\n            st = EINVAL;\n            k5_setmsg(context, st, \"Password policy value null\");\n            goto cleanup;\n        }\n    } else if (entry->mask & KADM5_LOAD && found_entry == TRUE) {\n        /*\n         * a load is special in that existing entries must have attrs that\n         * removed.\n         */\n\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpwdpolicyreference\", LDAP_MOD_REPLACE, NULL)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_POLICY_CLR) {\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpwdpolicyreference\", LDAP_MOD_DELETE, NULL)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_KEY_HIST) {\n        bersecretkey = krb5_encode_histkey(&princ_ent);\n        if (bersecretkey == NULL) {\n            st = ENOMEM;\n            goto cleanup;\n        }\n\n        st = krb5_add_ber_mem_ldap_mod(&mods, \"krbpwdhistory\",\n                                       LDAP_MOD_REPLACE | LDAP_MOD_BVALUES,\n                                       bersecretkey);\n        if (st != 0)\n            goto cleanup;\n        free_berdata(bersecretkey);\n        bersecretkey = NULL;\n    }\n\n    if (entry->mask & KADM5_KEY_DATA || entry->mask & KADM5_KVNO) {\n        krb5_kvno mkvno;\n\n        if ((st=krb5_dbe_lookup_mkvno(context, entry, &mkvno)) != 0)\n            goto cleanup;\n        bersecretkey = krb5_encode_krbsecretkey (entry->key_data,\n                                                 entry->n_key_data, mkvno);\n\n        if (bersecretkey == NULL) {\n            st = ENOMEM;\n            goto cleanup;\n        }\n        /* An empty list of bervals is only accepted for modify operations,\n         * not add operations. */\n        if (bersecretkey[0] != NULL || !create_standalone) {\n            st = krb5_add_ber_mem_ldap_mod(&mods, \"krbprincipalkey\",\n                                           LDAP_MOD_REPLACE | LDAP_MOD_BVALUES,\n                                           bersecretkey);\n            if (st != 0)\n                goto cleanup;\n        }\n\n        if (!(entry->mask & KADM5_PRINCIPAL)) {\n            memset(strval, 0, sizeof(strval));\n            if ((strval[0]=getstringtime(entry->pw_expiration)) == NULL)\n                goto cleanup;\n            if ((st=krb5_add_str_mem_ldap_mod(&mods,\n                                              \"krbpasswordexpiration\",\n                                              LDAP_MOD_REPLACE, strval)) != 0) {\n                free (strval[0]);\n                goto cleanup;\n            }\n            free (strval[0]);\n        }\n\n        /* Update last password change whenever a new key is set */\n        {\n            krb5_timestamp last_pw_changed;\n            if ((st=krb5_dbe_lookup_last_pwd_change(context, entry,\n                                                    &last_pw_changed)) != 0)\n                goto cleanup;\n\n            memset(strval, 0, sizeof(strval));\n            if ((strval[0] = getstringtime(last_pw_changed)) == NULL)\n                goto cleanup;\n\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastPwdChange\",\n                                              LDAP_MOD_REPLACE, strval)) != 0) {\n                free (strval[0]);\n                goto cleanup;\n            }\n            free (strval[0]);\n        }\n\n    } /* Modify Key data ends here */\n\n    /* Auth indicators will also be stored in krbExtraData when processing\n     * tl_data. */\n    st = update_ldap_mod_auth_ind(context, entry, &mods);\n    if (st != 0)\n        goto cleanup;\n\n    /* Set tl_data */\n    if (entry->tl_data != NULL) {\n        int count = 0;\n        struct berval **ber_tl_data = NULL;\n        krb5_tl_data *ptr;\n        krb5_timestamp unlock_time;\n        for (ptr = entry->tl_data; ptr != NULL; ptr = ptr->tl_data_next) {\n            if (ptr->tl_data_type == KRB5_TL_LAST_PWD_CHANGE\n#ifdef SECURID\n                || ptr->tl_data_type == KRB5_TL_DB_ARGS\n#endif\n                || ptr->tl_data_type == KRB5_TL_KADM_DATA\n                || ptr->tl_data_type == KDB_TL_USER_INFO\n                || ptr->tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL\n                || ptr->tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK)\n                continue;\n            count++;\n        }\n        if (count != 0) {\n            int j;\n            ber_tl_data = (struct berval **) calloc (count + 1,\n                                                     sizeof (struct berval*));\n            if (ber_tl_data == NULL) {\n                st = ENOMEM;\n                goto cleanup;\n            }\n            for (j = 0, ptr = entry->tl_data; ptr != NULL; ptr = ptr->tl_data_next) {\n                /* Ignore tl_data that are stored in separate directory\n                 * attributes */\n                if (ptr->tl_data_type == KRB5_TL_LAST_PWD_CHANGE\n#ifdef SECURID\n                    || ptr->tl_data_type == KRB5_TL_DB_ARGS\n#endif\n                    || ptr->tl_data_type == KRB5_TL_KADM_DATA\n                    || ptr->tl_data_type == KDB_TL_USER_INFO\n                    || ptr->tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL\n                    || ptr->tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK)\n                    continue;\n                if ((st = tl_data2berval (ptr, &ber_tl_data[j])) != 0)\n                    break;\n                j++;\n            }\n            if (st == 0) {\n                ber_tl_data[count] = NULL;\n                st=krb5_add_ber_mem_ldap_mod(&mods, \"krbExtraData\",\n                                             LDAP_MOD_REPLACE |\n                                             LDAP_MOD_BVALUES, ber_tl_data);\n            }\n            free_berdata(ber_tl_data);\n            if (st != 0)\n                goto cleanup;\n        }\n        if ((st=krb5_dbe_lookup_last_admin_unlock(context, entry,\n                                                  &unlock_time)) != 0)\n            goto cleanup;\n        if (unlock_time != 0) {\n            /* Update last admin unlock */\n            memset(strval, 0, sizeof(strval));\n            if ((strval[0] = getstringtime(unlock_time)) == NULL)\n                goto cleanup;\n\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastAdminUnlock\",\n                                              LDAP_MOD_REPLACE, strval)) != 0) {\n                free (strval[0]);\n                goto cleanup;\n            }\n            free (strval[0]);\n        }\n    }\n\n    /* Directory specific attribute */\n    if (xargs.tktpolicydn != NULL) {\n        int tmask=0;\n\n        if (strlen(xargs.tktpolicydn) != 0) {\n            st = checkattributevalue(ld, xargs.tktpolicydn, \"objectclass\", policyclass, &tmask);\n            CHECK_CLASS_VALIDITY(st, tmask, _(\"ticket policy object value: \"));\n\n            strval[0] = xargs.tktpolicydn;\n            strval[1] = NULL;\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbticketpolicyreference\", LDAP_MOD_REPLACE, strval)) != 0)\n                goto cleanup;\n\n        } else {\n            /* if xargs.tktpolicydn is a empty string, then delete\n             * already existing krbticketpolicyreference attr */\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbticketpolicyreference\", LDAP_MOD_DELETE, NULL)) != 0)\n                goto cleanup;\n        }\n\n    }\n\n    if (establish_links == TRUE) {\n        memset(strval, 0, sizeof(strval));\n        strval[0] = xargs.linkdn;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbObjectReferences\", LDAP_MOD_REPLACE, strval)) != 0)\n            goto cleanup;\n    }\n\n    /*\n     * in case mods is NULL then return\n     * not sure but can happen in a modprinc\n     * so no need to return an error\n     * addprinc will at least have the principal name\n     * and the keys passed in\n     */\n    if (mods == NULL)\n        goto cleanup;\n\n    if (create_standalone == TRUE) {\n        memset(strval, 0, sizeof(strval));\n        strval[0] = \"krbprincipal\";\n        strval[1] = \"krbprincipalaux\";\n        strval[2] = \"krbTicketPolicyAux\";\n\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"objectclass\", LDAP_MOD_ADD, strval)) != 0)\n            goto cleanup;\n\n        st = ldap_add_ext_s(ld, standalone_principal_dn, mods, NULL, NULL);\n        if (st == LDAP_ALREADY_EXISTS && entry->mask & KADM5_LOAD) {\n            /* a load operation must replace an existing entry */\n            st = ldap_delete_ext_s(ld, standalone_principal_dn, NULL, NULL);\n            if (st != LDAP_SUCCESS) {\n                snprintf(errbuf, sizeof(errbuf),\n                         _(\"Principal delete failed (trying to replace \"\n                           \"entry): %s\"), ldap_err2string(st));\n                st = translate_ldap_error (st, OP_ADD);\n                k5_setmsg(context, st, \"%s\", errbuf);\n                goto cleanup;\n            } else {\n                st = ldap_add_ext_s(ld, standalone_principal_dn, mods, NULL, NULL);\n            }\n        }\n        if (st != LDAP_SUCCESS) {\n            snprintf(errbuf, sizeof(errbuf), _(\"Principal add failed: %s\"),\n                     ldap_err2string(st));\n            st = translate_ldap_error (st, OP_ADD);\n            k5_setmsg(context, st, \"%s\", errbuf);\n            goto cleanup;\n        }\n    } else {\n        /*\n         * Here existing ldap object is modified and can be related\n         * to any attribute, so always ensure that the ldap\n         * object is extended with all the kerberos related\n         * objectclasses so that there are no constraint\n         * violations.\n         */\n        {\n            char *attrvalues[] = {\"krbprincipalaux\", \"krbTicketPolicyAux\", NULL};\n            int p, q, r=0, amask=0;\n\n            if ((st=checkattributevalue(ld, (xargs.dn) ? xargs.dn : principal_dn,\n                                        \"objectclass\", attrvalues, &amask)) != 0)\n                goto cleanup;\n\n            memset(strval, 0, sizeof(strval));\n            for (p=1, q=0; p<=2; p<<=1, ++q) {\n                if ((p & amask) == 0)\n                    strval[r++] = attrvalues[q];\n            }\n            if (r != 0) {\n                if ((st=krb5_add_str_mem_ldap_mod(&mods, \"objectclass\", LDAP_MOD_ADD, strval)) != 0)\n                    goto cleanup;\n            }\n        }\n        if (xargs.dn != NULL)\n            st=ldap_modify_ext_s(ld, xargs.dn, mods, NULL, NULL);\n        else\n            st = ldap_modify_ext_s(ld, principal_dn, mods, NULL, NULL);\n\n        if (st != LDAP_SUCCESS) {\n            snprintf(errbuf, sizeof(errbuf), _(\"User modification failed: %s\"),\n                     ldap_err2string(st));\n            st = translate_ldap_error (st, OP_MOD);\n            k5_setmsg(context, st, \"%s\", errbuf);\n            goto cleanup;\n        }\n\n        if (entry->mask & KADM5_FAIL_AUTH_COUNT_INCREMENT)\n            entry->fail_auth_count++;\n    }\n\ncleanup:\n    if (user)\n        free(user);\n\n    if (filtuser)\n        free(filtuser);\n\n    free_xargs(xargs);\n\n    if (standalone_principal_dn)\n        free(standalone_principal_dn);\n\n    if (principal_dn)\n        free (principal_dn);\n\n    if (polname != NULL)\n        free(polname);\n\n    for (tre = 0; tre < ntrees; tre++)\n        free(subtreelist[tre]);\n    free(subtreelist);\n\n    if (subtree)\n        free (subtree);\n\n    if (bersecretkey) {\n        for (l=0; bersecretkey[l]; ++l) {\n            if (bersecretkey[l]->bv_val)\n                free (bersecretkey[l]->bv_val);\n            free (bersecretkey[l]);\n        }\n        free (bersecretkey);\n    }\n\n    if (keys)\n        free (keys);\n\n    ldap_mods_free(mods, 1);\n    ldap_osa_free_princ_ent(&princ_ent);\n    ldap_msgfree(result);\n    krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);\n    return(st);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 90,
    "critical_vars": [
      "realmstr"
    ],
    "function": "ec_verify",
    "filename": "krb5/CVE-2021-36222/CVE-2021-36222_CWE-476_fc98f520caefff2e5ee9a0026fdf5109944b3562_kdc_preauth_ec.c.diff",
    "function_code": "ec_verify(krb5_context context, krb5_data *req_pkt, krb5_kdc_req *request,\n          krb5_enc_tkt_part *enc_tkt_reply, krb5_pa_data *data,\n          krb5_kdcpreauth_callbacks cb, krb5_kdcpreauth_rock rock,\n          krb5_kdcpreauth_moddata moddata,\n          krb5_kdcpreauth_verify_respond_fn respond, void *arg)\n{\n    krb5_error_code retval = 0;\n    krb5_enc_data *enc = NULL;\n    krb5_data scratch, plain;\n    krb5_keyblock *armor_key = cb->fast_armor(context, rock);\n    krb5_pa_enc_ts *ts = NULL;\n    krb5_keyblock *client_keys = NULL;\n    krb5_keyblock *challenge_key = NULL;\n    krb5_keyblock *kdc_challenge_key;\n    krb5_kdcpreauth_modreq modreq = NULL;\n    int i = 0;\n    char *ai = NULL, *realmstr = NULL;\n    krb5_data realm = request->server->realm;\n\n    plain.data = NULL;\n\n    if (armor_key == NULL) {\n        retval = ENOENT;\n        k5_setmsg(context, ENOENT,\n                  _(\"Encrypted Challenge used outside of FAST tunnel\"));\n    }\n    scratch.data = (char *) data->contents;\n    scratch.length = data->length;\n    if (retval == 0)\n        retval = decode_krb5_enc_data(&scratch, &enc);\n    if (retval == 0) {\n        plain.data =  malloc(enc->ciphertext.length);\n        plain.length = enc->ciphertext.length;\n        if (plain.data == NULL)\n            retval = ENOMEM;\n    }\n\n    /* Check for a configured FAST ec auth indicator. */\n    realmstr = k5memdup0(realm.data, realm.length, &retval);\n    if (realmstr != NULL)\n        retval = profile_get_string(context->profile, KRB5_CONF_REALMS,\n                                    realmstr,\n                                    KRB5_CONF_ENCRYPTED_CHALLENGE_INDICATOR,\n                                    NULL, &ai);\n\n    if (retval == 0)\n        retval = cb->client_keys(context, rock, &client_keys);\n    if (retval == 0) {\n        for (i = 0; client_keys[i].enctype&& (retval == 0); i++ ) {\n            retval = krb5_c_fx_cf2_simple(context,\n                                          armor_key, \"clientchallengearmor\",\n                                          &client_keys[i], \"challengelongterm\",\n                                          &challenge_key);\n            if (retval == 0)\n                retval  = krb5_c_decrypt(context, challenge_key,\n                                         KRB5_KEYUSAGE_ENC_CHALLENGE_CLIENT,\n                                         NULL, enc, &plain);\n            if (challenge_key)\n                krb5_free_keyblock(context, challenge_key);\n            challenge_key = NULL;\n            if (retval == 0)\n                break;\n            /*We failed to decrypt. Try next key*/\n            retval = 0;\n        }\n        if (client_keys[i].enctype == 0) {\n            retval = KRB5KDC_ERR_PREAUTH_FAILED;\n            k5_setmsg(context, retval,\n                      _(\"Incorrect password in encrypted challenge\"));\n        }\n    }\n    if (retval == 0)\n        retval = decode_krb5_pa_enc_ts(&plain, &ts);\n    if (retval == 0)\n        retval = krb5_check_clockskew(context, ts->patimestamp);\n    if (retval == 0) {\n        enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;\n        /*\n         * If this fails, we won't generate a reply to the client.  That may\n         * cause the client to fail, but at this point the KDC has considered\n         * this a success, so the return value is ignored.\n         */\n        if (krb5_c_fx_cf2_simple(context, armor_key, \"kdcchallengearmor\",\n                                 &client_keys[i], \"challengelongterm\",\n                                 &kdc_challenge_key) == 0) {\n            modreq = (krb5_kdcpreauth_modreq)kdc_challenge_key;\n            if (ai != NULL)\n                cb->add_auth_indicator(context, rock, ai);\n        }\n    }\n    cb->free_keys(context, rock, client_keys);\n    if (plain.data)\n        free(plain.data);\n    if (enc)\n        krb5_free_enc_data(context, enc);\n    if (ts)\n        krb5_free_pa_enc_ts(context, ts);\n    free(realmstr);\n    free(ai);\n\n    (*respond)(arg, retval, modreq, NULL, NULL);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 90,
    "critical_vars": [
      "retval"
    ],
    "function": "ec_verify",
    "filename": "krb5/CVE-2021-36222/CVE-2021-36222_CWE-476_fc98f520caefff2e5ee9a0026fdf5109944b3562_kdc_preauth_ec.c.diff",
    "function_code": "ec_verify(krb5_context context, krb5_data *req_pkt, krb5_kdc_req *request,\n          krb5_enc_tkt_part *enc_tkt_reply, krb5_pa_data *data,\n          krb5_kdcpreauth_callbacks cb, krb5_kdcpreauth_rock rock,\n          krb5_kdcpreauth_moddata moddata,\n          krb5_kdcpreauth_verify_respond_fn respond, void *arg)\n{\n    krb5_error_code retval = 0;\n    krb5_enc_data *enc = NULL;\n    krb5_data scratch, plain;\n    krb5_keyblock *armor_key = cb->fast_armor(context, rock);\n    krb5_pa_enc_ts *ts = NULL;\n    krb5_keyblock *client_keys = NULL;\n    krb5_keyblock *challenge_key = NULL;\n    krb5_keyblock *kdc_challenge_key;\n    krb5_kdcpreauth_modreq modreq = NULL;\n    int i = 0;\n    char *ai = NULL, *realmstr = NULL;\n    krb5_data realm = request->server->realm;\n\n    plain.data = NULL;\n\n    if (armor_key == NULL) {\n        retval = ENOENT;\n        k5_setmsg(context, ENOENT,\n                  _(\"Encrypted Challenge used outside of FAST tunnel\"));\n    }\n    scratch.data = (char *) data->contents;\n    scratch.length = data->length;\n    if (retval == 0)\n        retval = decode_krb5_enc_data(&scratch, &enc);\n    if (retval == 0) {\n        plain.data =  malloc(enc->ciphertext.length);\n        plain.length = enc->ciphertext.length;\n        if (plain.data == NULL)\n            retval = ENOMEM;\n    }\n\n    /* Check for a configured FAST ec auth indicator. */\n    if (retval == 0)\n        realmstr = k5memdup0(realm.data, realm.length, &retval);\n    if (realmstr != NULL)\n        retval = profile_get_string(context->profile, KRB5_CONF_REALMS,\n                                    realmstr,\n                                    KRB5_CONF_ENCRYPTED_CHALLENGE_INDICATOR,\n                                    NULL, &ai);\n\n    if (retval == 0)\n        retval = cb->client_keys(context, rock, &client_keys);\n    if (retval == 0) {\n        for (i = 0; client_keys[i].enctype&& (retval == 0); i++ ) {\n            retval = krb5_c_fx_cf2_simple(context,\n                                          armor_key, \"clientchallengearmor\",\n                                          &client_keys[i], \"challengelongterm\",\n                                          &challenge_key);\n            if (retval == 0)\n                retval  = krb5_c_decrypt(context, challenge_key,\n                                         KRB5_KEYUSAGE_ENC_CHALLENGE_CLIENT,\n                                         NULL, enc, &plain);\n            if (challenge_key)\n                krb5_free_keyblock(context, challenge_key);\n            challenge_key = NULL;\n            if (retval == 0)\n                break;\n            /*We failed to decrypt. Try next key*/\n            retval = 0;\n        }\n        if (client_keys[i].enctype == 0) {\n            retval = KRB5KDC_ERR_PREAUTH_FAILED;\n            k5_setmsg(context, retval,\n                      _(\"Incorrect password in encrypted challenge\"));\n        }\n    }\n    if (retval == 0)\n        retval = decode_krb5_pa_enc_ts(&plain, &ts);\n    if (retval == 0)\n        retval = krb5_check_clockskew(context, ts->patimestamp);\n    if (retval == 0) {\n        enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;\n        /*\n         * If this fails, we won't generate a reply to the client.  That may\n         * cause the client to fail, but at this point the KDC has considered\n         * this a success, so the return value is ignored.\n         */\n        if (krb5_c_fx_cf2_simple(context, armor_key, \"kdcchallengearmor\",\n                                 &client_keys[i], \"challengelongterm\",\n                                 &kdc_challenge_key) == 0) {\n            modreq = (krb5_kdcpreauth_modreq)kdc_challenge_key;\n            if (ai != NULL)\n                cb->add_auth_indicator(context, rock, ai);\n        }\n    }\n    cb->free_keys(context, rock, client_keys);\n    if (plain.data)\n        free(plain.data);\n    if (enc)\n        krb5_free_enc_data(context, enc);\n    if (ts)\n        krb5_free_pa_enc_ts(context, ts);\n    free(realmstr);\n    free(ai);\n\n    (*respond)(arg, retval, modreq, NULL, NULL);\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 317,
    "line_new": 317,
    "critical_vars": [
      "ent"
    ],
    "function": "krb5_ldap_get_password_policy_from_dn",
    "filename": "krb5/CVE-2014-5353/CVE-2014-5353_CWE-476_d1f707024f1d0af6e54a18885322d70fa15ec4d3_ldap_pwd_policy.c.diff",
    "function_code": "krb5_ldap_get_password_policy_from_dn(krb5_context context, char *pol_name,\n                                      char *pol_dn, osa_policy_ent_t *policy)\n{\n    krb5_error_code             st=0, tempst=0;\n    LDAP                        *ld=NULL;\n    LDAPMessage                 *result=NULL,*ent=NULL;\n    kdb5_dal_handle             *dal_handle=NULL;\n    krb5_ldap_context           *ldap_context=NULL;\n    krb5_ldap_server_handle     *ldap_server_handle=NULL;\n\n    /* Clear the global error string */\n    krb5_clear_error_message(context);\n\n    /* validate the input parameters */\n    if (pol_dn == NULL)\n        return EINVAL;\n\n    *policy = NULL;\n    SETUP_CONTEXT();\n    GET_HANDLE();\n\n    *(policy) = (osa_policy_ent_t) malloc(sizeof(osa_policy_ent_rec));\n    if (*policy == NULL) {\n        st = ENOMEM;\n        goto cleanup;\n    }\n    memset(*policy, 0, sizeof(osa_policy_ent_rec));\n\n    LDAP_SEARCH(pol_dn, LDAP_SCOPE_BASE, \"(objectclass=krbPwdPolicy)\", password_policy_attributes);\n\n    ent=ldap_first_entry(ld, result);\n    if (ent == NULL) {\n        st = KRB5_KDB_NOENTRY;\n        goto cleanup;\n    }\n    st = populate_policy(context, ld, ent, pol_name, *policy);\n\ncleanup:\n    ldap_msgfree(result);\n    if (st != 0) {\n        if (*policy != NULL) {\n            krb5_ldap_free_password_policy(context, *policy);\n            *policy = NULL;\n        }\n    }\n\n    krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);\n    return st;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 318,
    "critical_vars": [
      "pol_name",
      "ld",
      "st",
      "context",
      "ent",
      "policy"
    ],
    "function": "krb5_ldap_get_password_policy_from_dn",
    "filename": "krb5/CVE-2014-5353/CVE-2014-5353_CWE-476_d1f707024f1d0af6e54a18885322d70fa15ec4d3_ldap_pwd_policy.c.diff",
    "function_code": "krb5_ldap_get_password_policy_from_dn(krb5_context context, char *pol_name,\n                                      char *pol_dn, osa_policy_ent_t *policy)\n{\n    krb5_error_code             st=0, tempst=0;\n    LDAP                        *ld=NULL;\n    LDAPMessage                 *result=NULL,*ent=NULL;\n    kdb5_dal_handle             *dal_handle=NULL;\n    krb5_ldap_context           *ldap_context=NULL;\n    krb5_ldap_server_handle     *ldap_server_handle=NULL;\n\n    /* Clear the global error string */\n    krb5_clear_error_message(context);\n\n    /* validate the input parameters */\n    if (pol_dn == NULL)\n        return EINVAL;\n\n    *policy = NULL;\n    SETUP_CONTEXT();\n    GET_HANDLE();\n\n    *(policy) = (osa_policy_ent_t) malloc(sizeof(osa_policy_ent_rec));\n    if (*policy == NULL) {\n        st = ENOMEM;\n        goto cleanup;\n    }\n    memset(*policy, 0, sizeof(osa_policy_ent_rec));\n\n    LDAP_SEARCH(pol_dn, LDAP_SCOPE_BASE, \"(objectclass=krbPwdPolicy)\", password_policy_attributes);\n\n    ent=ldap_first_entry(ld, result);\n    if (ent != NULL) {\n        if ((st = populate_policy(context, ld, ent, pol_name, *policy)) != 0)\n            goto cleanup;\n    }\n\ncleanup:\n    ldap_msgfree(result);\n    if (st != 0) {\n        if (*policy != NULL) {\n            krb5_ldap_free_password_policy(context, *policy);\n            *policy = NULL;\n        }\n    }\n\n    krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);\n    return st;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 742,
    "critical_vars": [
      "request->client",
      "request->server",
      "kdc_active_realm"
    ],
    "function": "validate_as_request",
    "filename": "krb5/CVE-2016-3120/CVE-2016-3120_CWE-476_93b4a6306a0026cf1cc31ac4bd8a49ba5d034ba7_kdc_util.c.diff",
    "function_code": "validate_as_request(kdc_realm_t *kdc_active_realm,\n                    register krb5_kdc_req *request, krb5_db_entry client,\n                    krb5_db_entry server, krb5_timestamp kdc_time,\n                    const char **status, krb5_pa_data ***e_data)\n{\n    int errcode;\n    krb5_error_code ret;\n\n    /*\n     * If an option is set that is only allowed in TGS requests, complain.\n     */\n    if (request->kdc_options & AS_INVALID_OPTIONS) {\n        *status = \"INVALID AS OPTIONS\";\n        return KDC_ERR_BADOPTION;\n    }\n\n    /* The client must not be expired */\n    if (client.expiration && client.expiration < kdc_time) {\n        *status = \"CLIENT EXPIRED\";\n        if (vague_errors)\n            return(KRB_ERR_GENERIC);\n        else\n            return(KDC_ERR_NAME_EXP);\n    }\n\n    /* The client's password must not be expired, unless the server is\n       a KRB5_KDC_PWCHANGE_SERVICE. */\n    if (client.pw_expiration && client.pw_expiration < kdc_time &&\n        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {\n        *status = \"CLIENT KEY EXPIRED\";\n        if (vague_errors)\n            return(KRB_ERR_GENERIC);\n        else\n            return(KDC_ERR_KEY_EXP);\n    }\n\n    /* The server must not be expired */\n    if (server.expiration && server.expiration < kdc_time) {\n        *status = \"SERVICE EXPIRED\";\n        return(KDC_ERR_SERVICE_EXP);\n    }\n\n    /*\n     * If the client requires password changing, then only allow the\n     * pwchange service.\n     */\n    if (isflagset(client.attributes, KRB5_KDB_REQUIRES_PWCHANGE) &&\n        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {\n        *status = \"REQUIRED PWCHANGE\";\n        return(KDC_ERR_KEY_EXP);\n    }\n\n    /* Client and server must allow postdating tickets */\n    if ((isflagset(request->kdc_options, KDC_OPT_ALLOW_POSTDATE) ||\n         isflagset(request->kdc_options, KDC_OPT_POSTDATED)) &&\n        (isflagset(client.attributes, KRB5_KDB_DISALLOW_POSTDATED) ||\n         isflagset(server.attributes, KRB5_KDB_DISALLOW_POSTDATED))) {\n        *status = \"POSTDATE NOT ALLOWED\";\n        return(KDC_ERR_CANNOT_POSTDATE);\n    }\n\n    /*\n     * A Windows KDC will return KDC_ERR_PREAUTH_REQUIRED instead of\n     * KDC_ERR_POLICY in the following case:\n     *\n     *   - KDC_OPT_FORWARDABLE is set in KDCOptions but local\n     *     policy has KRB5_KDB_DISALLOW_FORWARDABLE set for the\n     *     client, and;\n     *   - KRB5_KDB_REQUIRES_PRE_AUTH is set for the client but\n     *     preauthentication data is absent in the request.\n     *\n     * Hence, this check most be done after the check for preauth\n     * data, and is now performed by validate_forwardable() (the\n     * contents of which were previously below).\n     */\n\n    /* Client and server must allow proxiable tickets */\n    if (isflagset(request->kdc_options, KDC_OPT_PROXIABLE) &&\n        (isflagset(client.attributes, KRB5_KDB_DISALLOW_PROXIABLE) ||\n         isflagset(server.attributes, KRB5_KDB_DISALLOW_PROXIABLE))) {\n        *status = \"PROXIABLE NOT ALLOWED\";\n        return(KDC_ERR_POLICY);\n    }\n\n    /* Check to see if client is locked out */\n    if (isflagset(client.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {\n        *status = \"CLIENT LOCKED OUT\";\n        return(KDC_ERR_CLIENT_REVOKED);\n    }\n\n    /* Check to see if server is locked out */\n    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {\n        *status = \"SERVICE LOCKED OUT\";\n        return(KDC_ERR_S_PRINCIPAL_UNKNOWN);\n    }\n\n    /* Check to see if server is allowed to be a service */\n    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_SVR)) {\n        *status = \"SERVICE NOT ALLOWED\";\n        return(KDC_ERR_MUST_USE_USER2USER);\n    }\n\n    if (check_anon(kdc_active_realm, request->client, request->server) != 0) {\n        *status = \"ANONYMOUS NOT ALLOWED\";\n        return(KDC_ERR_POLICY);\n    }\n\n    /* Perform KDB module policy checks. */\n    ret = krb5_db_check_policy_as(kdc_context, request, &client, &server,\n                                  kdc_time, status, e_data);\n    if (ret && ret != KRB5_PLUGIN_OP_NOTSUPP)\n        return errcode_to_protocol(ret);\n\n    /* Check against local policy. */\n    errcode = against_local_policy_as(request, client, server,\n                                      kdc_time, status, e_data);\n    if (errcode)\n        return errcode;\n\n    return 0;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 742,
    "critical_vars": [
      "request->server",
      "client.princ",
      "kdc_active_realm"
    ],
    "function": "validate_as_request",
    "filename": "krb5/CVE-2016-3120/CVE-2016-3120_CWE-476_93b4a6306a0026cf1cc31ac4bd8a49ba5d034ba7_kdc_util.c.diff",
    "function_code": "validate_as_request(kdc_realm_t *kdc_active_realm,\n                    register krb5_kdc_req *request, krb5_db_entry client,\n                    krb5_db_entry server, krb5_timestamp kdc_time,\n                    const char **status, krb5_pa_data ***e_data)\n{\n    int errcode;\n    krb5_error_code ret;\n\n    /*\n     * If an option is set that is only allowed in TGS requests, complain.\n     */\n    if (request->kdc_options & AS_INVALID_OPTIONS) {\n        *status = \"INVALID AS OPTIONS\";\n        return KDC_ERR_BADOPTION;\n    }\n\n    /* The client must not be expired */\n    if (client.expiration && client.expiration < kdc_time) {\n        *status = \"CLIENT EXPIRED\";\n        if (vague_errors)\n            return(KRB_ERR_GENERIC);\n        else\n            return(KDC_ERR_NAME_EXP);\n    }\n\n    /* The client's password must not be expired, unless the server is\n       a KRB5_KDC_PWCHANGE_SERVICE. */\n    if (client.pw_expiration && client.pw_expiration < kdc_time &&\n        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {\n        *status = \"CLIENT KEY EXPIRED\";\n        if (vague_errors)\n            return(KRB_ERR_GENERIC);\n        else\n            return(KDC_ERR_KEY_EXP);\n    }\n\n    /* The server must not be expired */\n    if (server.expiration && server.expiration < kdc_time) {\n        *status = \"SERVICE EXPIRED\";\n        return(KDC_ERR_SERVICE_EXP);\n    }\n\n    /*\n     * If the client requires password changing, then only allow the\n     * pwchange service.\n     */\n    if (isflagset(client.attributes, KRB5_KDB_REQUIRES_PWCHANGE) &&\n        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {\n        *status = \"REQUIRED PWCHANGE\";\n        return(KDC_ERR_KEY_EXP);\n    }\n\n    /* Client and server must allow postdating tickets */\n    if ((isflagset(request->kdc_options, KDC_OPT_ALLOW_POSTDATE) ||\n         isflagset(request->kdc_options, KDC_OPT_POSTDATED)) &&\n        (isflagset(client.attributes, KRB5_KDB_DISALLOW_POSTDATED) ||\n         isflagset(server.attributes, KRB5_KDB_DISALLOW_POSTDATED))) {\n        *status = \"POSTDATE NOT ALLOWED\";\n        return(KDC_ERR_CANNOT_POSTDATE);\n    }\n\n    /*\n     * A Windows KDC will return KDC_ERR_PREAUTH_REQUIRED instead of\n     * KDC_ERR_POLICY in the following case:\n     *\n     *   - KDC_OPT_FORWARDABLE is set in KDCOptions but local\n     *     policy has KRB5_KDB_DISALLOW_FORWARDABLE set for the\n     *     client, and;\n     *   - KRB5_KDB_REQUIRES_PRE_AUTH is set for the client but\n     *     preauthentication data is absent in the request.\n     *\n     * Hence, this check most be done after the check for preauth\n     * data, and is now performed by validate_forwardable() (the\n     * contents of which were previously below).\n     */\n\n    /* Client and server must allow proxiable tickets */\n    if (isflagset(request->kdc_options, KDC_OPT_PROXIABLE) &&\n        (isflagset(client.attributes, KRB5_KDB_DISALLOW_PROXIABLE) ||\n         isflagset(server.attributes, KRB5_KDB_DISALLOW_PROXIABLE))) {\n        *status = \"PROXIABLE NOT ALLOWED\";\n        return(KDC_ERR_POLICY);\n    }\n\n    /* Check to see if client is locked out */\n    if (isflagset(client.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {\n        *status = \"CLIENT LOCKED OUT\";\n        return(KDC_ERR_CLIENT_REVOKED);\n    }\n\n    /* Check to see if server is locked out */\n    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {\n        *status = \"SERVICE LOCKED OUT\";\n        return(KDC_ERR_S_PRINCIPAL_UNKNOWN);\n    }\n\n    /* Check to see if server is allowed to be a service */\n    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_SVR)) {\n        *status = \"SERVICE NOT ALLOWED\";\n        return(KDC_ERR_MUST_USE_USER2USER);\n    }\n\n    if (check_anon(kdc_active_realm, client.princ, request->server) != 0) {\n        *status = \"ANONYMOUS NOT ALLOWED\";\n        return(KDC_ERR_POLICY);\n    }\n\n    /* Perform KDB module policy checks. */\n    ret = krb5_db_check_policy_as(kdc_context, request, &client, &server,\n                                  kdc_time, status, e_data);\n    if (ret && ret != KRB5_PLUGIN_OP_NOTSUPP)\n        return errcode_to_protocol(ret);\n\n    /* Check against local policy. */\n    errcode = against_local_policy_as(request, client, server,\n                                      kdc_time, status, e_data);\n    if (errcode)\n        return errcode;\n\n    return 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1471,
    "critical_vars": [],
    "function": "acc_ctx_cont",
    "filename": "krb5/CVE-2014-4344/CVE-2014-4344_CWE-476_524688ce87a15fc75f87efc8c039ba4c7d5c197b_spnego_mech.c.diff",
    "function_code": "acc_ctx_cont(OM_uint32 *minstat,\n\t     gss_buffer_t buf,\n\t     gss_ctx_id_t *ctx,\n\t     gss_buffer_t *responseToken,\n\t     gss_buffer_t *mechListMIC,\n\t     OM_uint32 *negState,\n\t     send_token_flag *return_token)\n{\n\tOM_uint32 ret, tmpmin;\n\tgss_OID supportedMech;\n\tspnego_gss_ctx_id_t sc;\n\tunsigned int len;\n\tunsigned char *ptr, *bufstart;\n\n\tsc = (spnego_gss_ctx_id_t)*ctx;\n\tret = GSS_S_DEFECTIVE_TOKEN;\n\t*negState = REJECT;\n\t*minstat = 0;\n\tsupportedMech = GSS_C_NO_OID;\n\t*return_token = ERROR_TOKEN_SEND;\n\t*responseToken = *mechListMIC = GSS_C_NO_BUFFER;\n\n\tptr = bufstart = buf->value;\n#define REMAIN (buf->length - (ptr - bufstart))\n\tif (REMAIN == 0 || REMAIN > INT_MAX)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\n\t/*\n\t * Attempt to work with old Sun SPNEGO.\n\t */\n\tif (*ptr == HEADER_ID) {\n\t\tret = g_verify_token_header(gss_mech_spnego,\n\t\t\t\t\t    &len, &ptr, 0, REMAIN);\n\t\tif (ret) {\n\t\t\t*minstat = ret;\n\t\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t\t}\n\t}\n\tif (*ptr != (CONTEXT | 0x01)) {\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t}\n\tret = get_negTokenResp(minstat, ptr, REMAIN,\n\t\t\t       negState, &supportedMech,\n\t\t\t       responseToken, mechListMIC);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\n\tif (*responseToken == GSS_C_NO_BUFFER &&\n\t    *mechListMIC == GSS_C_NO_BUFFER) {\n\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\tgoto cleanup;\n\t}\n\tif (supportedMech != GSS_C_NO_OID) {\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\tgoto cleanup;\n\t}\n\tsc->firstpass = 0;\n\t*negState = ACCEPT_INCOMPLETE;\n\t*return_token = CONT_TOKEN_SEND;\ncleanup:\n\tif (supportedMech != GSS_C_NO_OID) {\n\t\tgeneric_gss_release_oid(&tmpmin, &supportedMech);\n\t}\n\treturn ret;\n#undef REMAIN\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 737,
    "critical_vars": [
      "vstart_off"
    ],
    "function": "*store_versioninfo_gnu_verdef",
    "filename": "radare2/CVE-2017-16359/CVE-2017-16359_CWE-476_fbaf24bce7ea4211e4608b3ab6c1b45702cb243d_elf.c.diff",
    "function_code": "static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) {\n\tconst char *section_name = \"\";\n\tconst char *link_section_name = \"\";\n\tchar *end = NULL;\n\tElf_(Shdr) *link_shdr = NULL;\n\tut8 dfs[sizeof (Elf_(Verdef))] = {0};\n\tSdb *sdb;\n\tint cnt, i;\n\tif (shdr->sh_link > bin->ehdr.e_shnum) {\n\t\treturn false;\n\t}\n\tlink_shdr = &bin->shdr[shdr->sh_link];\n\tif ((int)shdr->sh_size < 1) {\n\t\treturn false;\n\t}\n\tElf_(Verdef) *defs = calloc (shdr->sh_size, sizeof (char));\n\tif (!defs) {\n\t\treturn false;\n\t}\n\tif (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {\n\t\tsection_name = &bin->shstrtab[shdr->sh_name];\n\t}\n\tif (link_shdr && bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) {\n\t\tlink_section_name = &bin->shstrtab[link_shdr->sh_name];\n\t}\n\tif (!defs) {\n\t\tbprintf (\"Warning: Cannot allocate memory (Check Elf_(Verdef))\\n\");\n\t\treturn NULL;\n\t}\n\tsdb = sdb_new0 ();\n\tend = (char *)defs + shdr->sh_size;\n\tsdb_set (sdb, \"section_name\", section_name, 0);\n\tsdb_num_set (sdb, \"entries\", shdr->sh_info, 0);\n\tsdb_num_set (sdb, \"addr\", shdr->sh_addr, 0);\n\tsdb_num_set (sdb, \"offset\", shdr->sh_offset, 0);\n\tsdb_num_set (sdb, \"link\", shdr->sh_link, 0);\n\tsdb_set (sdb, \"link_section_name\", link_section_name, 0);\n\n\tfor (cnt = 0, i = 0; i >= 0 && cnt < shdr->sh_info && ((char *)defs + i < end); ++cnt) {\n\t\tSdb *sdb_verdef = sdb_new0 ();\n\t\tchar *vstart = ((char*)defs) + i;\n\t\tsize_t vstart_off = i;\n\t\tchar key[32] = {0};\n\t\tElf_(Verdef) *verdef = (Elf_(Verdef)*)vstart;\n\t\tElf_(Verdaux) aux = {0};\n\t\tint j = 0;\n\t\tint isum = 0;\n\n\t\tr_buf_read_at (bin->b, shdr->sh_offset + i, dfs, sizeof (Elf_(Verdef)));\n\t\tverdef->vd_version = READ16 (dfs, j)\n\t\tverdef->vd_flags = READ16 (dfs, j)\n\t\tverdef->vd_ndx = READ16 (dfs, j)\n\t\tverdef->vd_cnt = READ16 (dfs, j)\n\t\tverdef->vd_hash = READ32 (dfs, j)\n\t\tverdef->vd_aux = READ32 (dfs, j)\n\t\tverdef->vd_next = READ32 (dfs, j)\n\t\tint vdaux = verdef->vd_aux;\n\t\tif (vdaux < 1 || shdr->sh_size - vstart_off < vdaux) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\t\tvstart += vdaux;\n\t\tvstart_off += vdaux;\n\t\tif (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tj = 0;\n\t\taux.vda_name = READ32 (vstart, j)\n\t\taux.vda_next = READ32 (vstart, j)\n\n\t\tisum = i + verdef->vd_aux;\n\t\tif (aux.vda_name > bin->dynstr_size) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tsdb_num_set (sdb_verdef, \"idx\", i, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_version\", verdef->vd_version, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_ndx\", verdef->vd_ndx, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_cnt\", verdef->vd_cnt, 0);\n\t\tsdb_set (sdb_verdef, \"vda_name\", &bin->dynstr[aux.vda_name], 0);\n\t\tsdb_set (sdb_verdef, \"flags\", get_ver_flags (verdef->vd_flags), 0);\n\n\t\tfor (j = 1; j < verdef->vd_cnt; ++j) {\n\t\t\tint k;\n\t\t\tSdb *sdb_parent = sdb_new0 ();\n\t\t\tisum += aux.vda_next;\n\t\t\tvstart += aux.vda_next;\n\t\t\tvstart_off += aux.vda_next;\n\t\t\tif (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) {\n\t\t\t\tsdb_free (sdb_verdef);\n\t\t\t\tsdb_free (sdb_parent);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tk = 0;\n\t\t\taux.vda_name = READ32 (vstart, k)\n\t\t\taux.vda_next = READ32 (vstart, k)\n\t\t\tif (aux.vda_name > bin->dynstr_size) {\n\t\t\t\tsdb_free (sdb_verdef);\n\t\t\t\tsdb_free (sdb_parent);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tsdb_num_set (sdb_parent, \"idx\", isum, 0);\n\t\t\tsdb_num_set (sdb_parent, \"parent\", j, 0);\n\t\t\tsdb_set (sdb_parent, \"vda_name\", &bin->dynstr[aux.vda_name], 0);\n\t\t\tsnprintf (key, sizeof (key), \"parent%d\", j - 1);\n\t\t\tsdb_ns_set (sdb_verdef, key, sdb_parent);\n\t\t}\n\n\t\tsnprintf (key, sizeof (key), \"verdef%d\", cnt);\n\t\tsdb_ns_set (sdb, key, sdb_verdef);\n\t\tif (!verdef->vd_next) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\t\tif ((st32)verdef->vd_next < 1) {\n\t\t\teprintf (\"Warning: Invalid vd_next in the ELF version\\n\");\n\t\t\tbreak;\n\t\t}\n\t\ti += verdef->vd_next;\n\t}\n\tfree (defs);\n\treturn sdb;\nout_error:\n\tfree (defs);\n\tsdb_free (sdb);\n\treturn NULL;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 752,
    "critical_vars": [
      "vstart",
      "vdaux"
    ],
    "function": "*store_versioninfo_gnu_verdef",
    "filename": "radare2/CVE-2017-16359/CVE-2017-16359_CWE-476_fbaf24bce7ea4211e4608b3ab6c1b45702cb243d_elf.c.diff",
    "function_code": "static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) {\n\tconst char *section_name = \"\";\n\tconst char *link_section_name = \"\";\n\tchar *end = NULL;\n\tElf_(Shdr) *link_shdr = NULL;\n\tut8 dfs[sizeof (Elf_(Verdef))] = {0};\n\tSdb *sdb;\n\tint cnt, i;\n\tif (shdr->sh_link > bin->ehdr.e_shnum) {\n\t\treturn false;\n\t}\n\tlink_shdr = &bin->shdr[shdr->sh_link];\n\tif ((int)shdr->sh_size < 1) {\n\t\treturn false;\n\t}\n\tElf_(Verdef) *defs = calloc (shdr->sh_size, sizeof (char));\n\tif (!defs) {\n\t\treturn false;\n\t}\n\tif (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {\n\t\tsection_name = &bin->shstrtab[shdr->sh_name];\n\t}\n\tif (link_shdr && bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) {\n\t\tlink_section_name = &bin->shstrtab[link_shdr->sh_name];\n\t}\n\tif (!defs) {\n\t\tbprintf (\"Warning: Cannot allocate memory (Check Elf_(Verdef))\\n\");\n\t\treturn NULL;\n\t}\n\tsdb = sdb_new0 ();\n\tend = (char *)defs + shdr->sh_size;\n\tsdb_set (sdb, \"section_name\", section_name, 0);\n\tsdb_num_set (sdb, \"entries\", shdr->sh_info, 0);\n\tsdb_num_set (sdb, \"addr\", shdr->sh_addr, 0);\n\tsdb_num_set (sdb, \"offset\", shdr->sh_offset, 0);\n\tsdb_num_set (sdb, \"link\", shdr->sh_link, 0);\n\tsdb_set (sdb, \"link_section_name\", link_section_name, 0);\n\n\tfor (cnt = 0, i = 0; i >= 0 && cnt < shdr->sh_info && ((char *)defs + i < end); ++cnt) {\n\t\tSdb *sdb_verdef = sdb_new0 ();\n\t\tchar *vstart = ((char*)defs) + i;\n\t\tchar key[32] = {0};\n\t\tElf_(Verdef) *verdef = (Elf_(Verdef)*)vstart;\n\t\tElf_(Verdaux) aux = {0};\n\t\tint j = 0;\n\t\tint isum = 0;\n\n\t\tr_buf_read_at (bin->b, shdr->sh_offset + i, dfs, sizeof (Elf_(Verdef)));\n\t\tverdef->vd_version = READ16 (dfs, j)\n\t\tverdef->vd_flags = READ16 (dfs, j)\n\t\tverdef->vd_ndx = READ16 (dfs, j)\n\t\tverdef->vd_cnt = READ16 (dfs, j)\n\t\tverdef->vd_hash = READ32 (dfs, j)\n\t\tverdef->vd_aux = READ32 (dfs, j)\n\t\tverdef->vd_next = READ32 (dfs, j)\n\t\tint vdaux = verdef->vd_aux;\n\t\tif (vdaux < 1 || vstart + vdaux < vstart) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\t\tvstart += vdaux;\n\t\tif (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tj = 0;\n\t\taux.vda_name = READ32 (vstart, j)\n\t\taux.vda_next = READ32 (vstart, j)\n\n\t\tisum = i + verdef->vd_aux;\n\t\tif (aux.vda_name > bin->dynstr_size) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tsdb_num_set (sdb_verdef, \"idx\", i, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_version\", verdef->vd_version, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_ndx\", verdef->vd_ndx, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_cnt\", verdef->vd_cnt, 0);\n\t\tsdb_set (sdb_verdef, \"vda_name\", &bin->dynstr[aux.vda_name], 0);\n\t\tsdb_set (sdb_verdef, \"flags\", get_ver_flags (verdef->vd_flags), 0);\n\n\t\tfor (j = 1; j < verdef->vd_cnt; ++j) {\n\t\t\tint k;\n\t\t\tSdb *sdb_parent = sdb_new0 ();\n\t\t\tisum += aux.vda_next;\n\t\t\tvstart += aux.vda_next;\n\t\t\tif (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) {\n\t\t\t\tsdb_free (sdb_verdef);\n\t\t\t\tsdb_free (sdb_parent);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tk = 0;\n\t\t\taux.vda_name = READ32 (vstart, k)\n\t\t\taux.vda_next = READ32 (vstart, k)\n\t\t\tif (aux.vda_name > bin->dynstr_size) {\n\t\t\t\tsdb_free (sdb_verdef);\n\t\t\t\tsdb_free (sdb_parent);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tsdb_num_set (sdb_parent, \"idx\", isum, 0);\n\t\t\tsdb_num_set (sdb_parent, \"parent\", j, 0);\n\t\t\tsdb_set (sdb_parent, \"vda_name\", &bin->dynstr[aux.vda_name], 0);\n\t\t\tsnprintf (key, sizeof (key), \"parent%d\", j - 1);\n\t\t\tsdb_ns_set (sdb_verdef, key, sdb_parent);\n\t\t}\n\n\t\tsnprintf (key, sizeof (key), \"verdef%d\", cnt);\n\t\tsdb_ns_set (sdb, key, sdb_verdef);\n\t\tif (!verdef->vd_next) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\t\tif ((st32)verdef->vd_next < 1) {\n\t\t\teprintf (\"Warning: Invalid vd_next in the ELF version\\n\");\n\t\t\tbreak;\n\t\t}\n\t\ti += verdef->vd_next;\n\t}\n\tfree (defs);\n\treturn sdb;\nout_error:\n\tfree (defs);\n\tsdb_free (sdb);\n\treturn NULL;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 834,
    "critical_vars": [
      "sym->type"
    ],
    "function": "__core_anal_fcn",
    "filename": "radare2/CVE-2022-28070/CVE-2022-28070_CWE-476_4aff1bb00224de4f5bc118f987dfd5d2fe3450d0_canal.c.diff",
    "function_code": "static bool __core_anal_fcn(RCore *core, ut64 at, ut64 from, int reftype, int depth) {\n\tif (depth < 0) {\n//\t\tprintf (\"Too deep for 0x%08\"PFMT64x\"\\n\", at);\n//\t\tr_sys_backtrace ();\n\t\treturn false;\n\t}\n\tint has_next = r_config_get_i (core->config, \"anal.hasnext\");\n\tRAnalHint *hint = NULL;\n\tint i, nexti = 0;\n\tut64 *next = NULL;\n\tint fcnlen;\n\tRAnalFunction *fcn = r_anal_function_new (core->anal);\n\tr_warn_if_fail (fcn);\n\tconst char *fcnpfx = r_config_get (core->config, \"anal.fcnprefix\");\n\tif (!fcnpfx) {\n\t\tfcnpfx = \"fcn\";\n\t}\n\tconst char *cc = r_anal_cc_default (core->anal);\n\tif (!cc) {\n\t\tif (r_anal_cc_once (core->anal)) {\n\t\t\teprintf (\"Warning: set your favourite calling convention in `e anal.cc=?`\\n\");\n\t\t}\n\t\tcc = \"reg\";\n\t}\n\tfcn->cc = r_str_constpool_get (&core->anal->constpool, cc);\n\tr_warn_if_fail (fcn->cc);\n\thint = r_anal_hint_get (core->anal, at);\n\tif (hint && hint->bits == 16) {\n\t\t// expand 16bit for function\n\t\tfcn->bits = 16;\n\t} else {\n\t\tfcn->bits = core->anal->bits;\n\t}\n\tfcn->addr = at;\n\tfcn->name = get_function_name (core, at);\n\n\tif (!fcn->name) {\n\t\tfcn->name = r_str_newf (\"%s.%08\"PFMT64x, fcnpfx, at);\n\t}\n\tr_anal_fcn_invalidate_read_ahead_cache ();\n\tdo {\n\t\tRFlagItem *f;\n\t\tut64 delta = r_anal_function_linear_size (fcn);\n\t\tif (!r_io_is_valid_offset (core->io, at + delta, !core->anal->opt.noncode)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\tfcnlen = r_anal_function(core->anal, fcn, at + delta, core->anal->opt.bb_max_size, reftype);\n\t\tif (core->anal->opt.searchstringrefs) {\n\t\t\tr_anal_set_stringrefs (core, fcn);\n\t\t}\n\t\tif (fcnlen == 0) {\n\t\t\tif (core->anal->verbose) {\n\t\t\t\teprintf (\"Analyzed function size is 0 at 0x%08\"PFMT64x\"\\n\", at + delta);\n\t\t\t}\n\t\t\tgoto error;\n\t\t}\n\t\tif (fcnlen < 0) {\n\t\t\tswitch (fcnlen) {\n\t\t\tcase R_ANAL_RET_ERROR:\n\t\t\tcase R_ANAL_RET_NEW:\n\t\t\tcase R_ANAL_RET_DUP:\n\t\t\tcase R_ANAL_RET_END:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\teprintf (\"Oops. Negative fcnsize at 0x%08\"PFMT64x\" (%d)\\n\", at, fcnlen);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tf = r_core_flag_get_by_spaces (core->flags, fcn->addr);\n\t\tset_fcn_name_from_flag (fcn, f, fcnpfx);\n\n\t\tif (fcnlen == R_ANAL_RET_ERROR ||\n\t\t\t(fcnlen == R_ANAL_RET_END && !r_anal_function_realsize (fcn))) { /* Error analyzing function */\n\t\t\tif (core->anal->opt.followbrokenfcnsrefs) {\n\t\t\t\tr_anal_analyze_fcn_refs (core, fcn, depth);\n\t\t\t}\n\t\t\tgoto error;\n\t\t} else if (fcnlen == R_ANAL_RET_END) { /* Function analysis complete */\n\t\t\tf = r_core_flag_get_by_spaces (core->flags, fcn->addr);\n\t\t\tif (f && f->name && strncmp (f->name, \"sect\", 4)) { /* Check if it's already flagged */\n\t\t\t\tchar *new_name = strdup (f->name);\n\t\t\t\tif (is_entry_flag (f)) {\n\t\t\t\t\tRListIter *iter;\n\t\t\t\t\tRBinSymbol *sym;\n\t\t\t\t\tconst RList *syms = r_bin_get_symbols (core->bin);\n\t\t\t\t\tut64 baddr = r_config_get_i (core->config, \"bin.baddr\");\n\t\t\t\t\tr_list_foreach (syms, iter, sym) {\n\t\t\t\t\t\tif (sym->type && (sym->paddr + baddr) == fcn->addr && !strcmp (sym->type, R_BIN_TYPE_FUNC_STR)) {\n\t\t\t\t\t\t\tfree (new_name);\n\t\t\t\t\t\t\tnew_name = r_str_newf (\"sym.%s\", sym->name);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (fcn->name);\n\t\t\t\tfcn->name = new_name;\n\t\t\t} else {\n\t\t\t\tR_FREE (fcn->name);\n\t\t\t\tconst char *fcnpfx = r_anal_fcntype_tostring (fcn->type);\n\t\t\t\tif (!fcnpfx || !*fcnpfx || !strcmp (fcnpfx, \"fcn\")) {\n\t\t\t\t\tfcnpfx = r_config_get (core->config, \"anal.fcnprefix\");\n\t\t\t\t}\n\t\t\t\tfcn->name = r_str_newf (\"%s.%08\"PFMT64x, fcnpfx, fcn->addr);\n\t\t\t\tautoname_imp_trampoline (core, fcn);\n\t\t\t\t/* Add flag */\n\t\t\t\tr_flag_space_push (core->flags, R_FLAGS_FS_FUNCTIONS);\n\t\t\t\tr_flag_set (core->flags, fcn->name, fcn->addr, r_anal_function_linear_size (fcn));\n\t\t\t\tr_flag_space_pop (core->flags);\n\t\t\t}\n\n\t\t\t/* New function: Add initial xref */\n\t\t\tif (from != UT64_MAX) {\n\t\t\t\tr_anal_xrefs_set (core->anal, from, fcn->addr, reftype);\n\t\t\t}\n\t\t\t// XXX: this is wrong. See CID 1134565\n\t\t\tr_anal_add_function (core->anal, fcn);\n\t\t\tif (has_next) {\n\t\t\t\tut64 addr = r_anal_function_max_addr (fcn);\n\t\t\t\tRIOMap *map = r_io_map_get_at (core->io, addr);\n\t\t\t\t// only get next if found on an executable section\n\t\t\t\tif (!map || (map && map->perm & R_PERM_X)) {\n\t\t\t\t\tfor (i = 0; i < nexti; i++) {\n\t\t\t\t\t\tif (next[i] == addr) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (i == nexti) {\n\t\t\t\t\t\tut64 at = r_anal_function_max_addr (fcn);\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tut64 size;\n\t\t\t\t\t\t\tRAnalMetaItem *mi = r_meta_get_at (core->anal, at, R_META_TYPE_ANY, &size);\n\t\t\t\t\t\t\tif (!mi) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tat += size;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// TODO: ensure next address is function after padding (nop or trap or wat)\n\t\t\t\t\t\t// XXX noisy for test cases because we want to clear the stderr\n\t\t\t\t\t\tr_cons_clear_line (1);\n\t\t\t\t\t\tloganal (fcn->addr, at, 10000 - depth);\n\t\t\t\t\t\tnext = next_append (next, &nexti, at);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!r_anal_analyze_fcn_refs (core, fcn, depth)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t} while (fcnlen != R_ANAL_RET_END);\n\tr_list_free (core->anal->leaddrs);\n\tcore->anal->leaddrs = NULL;\n\tif (has_next) {\n\t\tfor (i = 0; i < nexti; i++) {\n\t\t\tif (!next[i] || r_anal_get_fcn_in (core->anal, next[i], 0)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tr_core_anal_fcn (core, next[i], from, 0, depth - 1);\n\t\t}\n\t\tfree (next);\n\t}\n\tif (core->anal->cur && core->anal->cur->arch && !strcmp (core->anal->cur->arch, \"x86\")) {\n\t\tr_anal_function_check_bp_use (fcn);\n\t\tif (fcn && !fcn->bp_frame) {\n\t\t\tr_anal_function_delete_vars_by_kind (fcn, R_ANAL_VAR_KIND_BPV);\n\t\t}\n\t}\n\tr_anal_hint_free (hint);\n\treturn true;\n\nerror:\n\tr_list_free (core->anal->leaddrs);\n\tcore->anal->leaddrs = NULL;\n\t// ugly hack to free fcn\n\tif (fcn) {\n\t\tif (!r_anal_function_realsize (fcn) || fcn->addr == UT64_MAX) {\n\t\t\tr_anal_function_free (fcn);\n\t\t\tfcn = NULL;\n\t\t} else {\n\t\t\t// TODO: mark this function as not properly analyzed\n\t\t\tif (!fcn->name) {\n\t\t\t\t// XXX dupped code.\n\t\t\t\tfcn->name = r_str_newf (\n\t\t\t\t\t\"%s.%08\" PFMT64x,\n\t\t\t\t\tr_anal_fcntype_tostring (fcn->type),\n\t\t\t\t\tat);\n\t\t\t\t/* Add flag */\n\t\t\t\tr_flag_space_push (core->flags, R_FLAGS_FS_FUNCTIONS);\n\t\t\t\tr_flag_set (core->flags, fcn->name, at, r_anal_function_linear_size (fcn));\n\t\t\t\tr_flag_space_pop (core->flags);\n\t\t\t}\n\t\t\tr_anal_add_function (core->anal, fcn);\n\t\t}\n\t\tif (fcn && has_next) {\n\t\t\tut64 newaddr = r_anal_function_max_addr (fcn);\n\t\t\tRIOMap *map = r_io_map_get_at (core->io, newaddr);\n\t\t\tif (!map || (map && (map->perm & R_PERM_X))) {\n\t\t\t\tnext = next_append (next, &nexti, newaddr);\n\t\t\t\tfor (i = 0; i < nexti; i++) {\n\t\t\t\t\tif (!next[i]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tr_core_anal_fcn (core, next[i], next[i], 0, depth - 1);\n\t\t\t\t}\n\t\t\t\tfree (next);\n\t\t\t}\n\t\t}\n\t}\n\tif (fcn && core->anal->cur && core->anal->cur->arch && !strcmp (core->anal->cur->arch, \"x86\")) {\n\t\tr_anal_function_check_bp_use (fcn);\n\t\tif (!fcn->bp_frame) {\n\t\t\tr_anal_function_delete_vars_by_kind (fcn, R_ANAL_VAR_KIND_BPV);\n\t\t}\n\t}\n\tr_anal_hint_free (hint);\n\treturn false;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 364,
    "critical_vars": [
      "sym"
    ],
    "function": "*symbols",
    "filename": "radare2/CVE-2022-0712/CVE-2022-0712_CWE-476_515e592b9bea0612bc63d8e93239ff35bcf645c7_bin_symbols.c.diff",
    "function_code": "static RList *symbols(RBinFile *bf) {\n\tRList *res = r_list_newf ((RListFree)r_bin_symbol_free);\n\tr_return_val_if_fail (res && bf->o && bf->o->bin_obj, res);\n\tRCoreSymCacheElement *element = bf->o->bin_obj;\n\tsize_t i;\n\tHtUU *hash = ht_uu_new0 ();\n\tif (!hash) {\n\t\treturn res;\n\t}\n\tbool found = false;\n\tfor (i = 0; i < element->hdr->n_lined_symbols; i++) {\n\t\tRCoreSymCacheElementSymbol *sym = (RCoreSymCacheElementSymbol *)&element->lined_symbols[i];\n\t\tif (!sym) {\n\t\t\tbreak;\n\t\t}\n\t\tht_uu_find (hash, sym->paddr, &found);\n\t\tif (found) {\n\t\t\tcontinue;\n\t\t}\n\t\tRBinSymbol *s = bin_symbol_from_symbol (element, sym);\n\t\tif (s) {\n\t\t\tr_list_append (res, s);\n\t\t\tht_uu_insert (hash, sym->paddr, 1);\n\t\t}\n\t}\n\tif (element->symbols) {\n\t\tfor (i = 0; i < element->hdr->n_symbols; i++) {\n\t\t\tRCoreSymCacheElementSymbol *sym = &element->symbols[i];\n\t\t\tht_uu_find (hash, sym->paddr, &found);\n\t\t\tif (found) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRBinSymbol *s = bin_symbol_from_symbol (element, sym);\n\t\t\tif (s) {\n\t\t\t\tr_list_append (res, s);\n\t\t\t}\n\t\t}\n\t}\n\tht_uu_free (hash);\n\treturn res;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "while-Condition",
    "line_old": 118,
    "critical_vars": [
      "true"
    ],
    "function": "*r_bin_ne_get_symbols",
    "filename": "radare2/CVE-2022-1283/CVE-2022-1283_CWE-476_18d1d064bf599a255d55f09fca3104776fc34a67_ne.c.diff",
    "function_code": "RList *r_bin_ne_get_symbols(r_bin_ne_obj_t *bin) {\n\tRBinSymbol *sym;\n\tut16 off = bin->ne_header->ResidNamTable + bin->header_offset;\n\tRList *symbols = r_list_newf (free);\n\tif (!symbols) {\n\t\treturn NULL;\n\t}\n\tRList *entries = r_bin_ne_get_entrypoints (bin);\n\tbool resident = true, first = true;\n\twhile (true) {\n\t\tut8 sz = r_buf_read8_at (bin->buf, off);\n\t\tif (!sz) {\n\t\t\tfirst = true;\n\t\t\tif (resident) {\n\t\t\t\tresident = false;\n\t\t\t\toff = bin->ne_header->OffStartNonResTab;\n\t\t\t\tsz = r_buf_read8_at (bin->buf, off);\n\t\t\t\tif (!sz) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tchar *name = malloc ((ut64)sz + 1);\n\t\tif (!name) {\n\t\t\tbreak;\n\t\t}\n\t\toff++;\n\t\tr_buf_read_at (bin->buf, off, (ut8 *)name, sz);\n\t\tname[sz] = '\\0';\n\t\toff += sz;\n\t\tsym = R_NEW0 (RBinSymbol);\n\t\tif (!sym) {\n\t\t\tbreak;\n\t\t}\n\t\tsym->name = name;\n\t\tif (!first) {\n\t\t\tsym->bind = R_BIN_BIND_GLOBAL_STR;\n\t\t}\n\t\tut16 entry_off = r_buf_read_le16_at (bin->buf, off);\n\t\toff += 2;\n\t\tRBinAddr *entry = r_list_get_n (entries, entry_off);\n\t\tif (entry) {\n\t\t\tsym->paddr = entry->paddr;\n\t\t} else {\n\t\t\tsym->paddr = -1;\n\t\t}\n\t\tsym->ordinal = entry_off;\n\t\tr_list_append (symbols, sym);\n\t\tfirst = false;\n\t}\n\tRListIter *it;\n\tRBinAddr *en;\n\tint i = 1;\n\tr_list_foreach (entries, it, en) {\n\t\tif (!r_list_find (symbols, &en->paddr, __find_symbol_by_paddr)) {\n\t\t\tsym = R_NEW0 (RBinSymbol);\n\t\t\tif (!sym) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsym->name = r_str_newf (\"entry%d\", i - 1);\n\t\t\tsym->paddr = en->paddr;\n\t\t\tsym->bind = R_BIN_BIND_GLOBAL_STR;\n\t\t\tsym->ordinal = i;\n\t\t\tr_list_append (symbols, sym);\n\t\t}\n\t\ti++;\n\t}\n\tbin->symbols = symbols;\n\treturn symbols;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "while-Condition",
    "line_new": 118,
    "critical_vars": [
      "entries"
    ],
    "function": "*r_bin_ne_get_symbols",
    "filename": "radare2/CVE-2022-1283/CVE-2022-1283_CWE-476_18d1d064bf599a255d55f09fca3104776fc34a67_ne.c.diff",
    "function_code": "RList *r_bin_ne_get_symbols(r_bin_ne_obj_t *bin) {\n\tRBinSymbol *sym;\n\tut16 off = bin->ne_header->ResidNamTable + bin->header_offset;\n\tRList *symbols = r_list_newf (free);\n\tif (!symbols) {\n\t\treturn NULL;\n\t}\n\tRList *entries = r_bin_ne_get_entrypoints (bin);\n\tbool resident = true, first = true;\n\twhile (entries) {\n\t\tut8 sz = r_buf_read8_at (bin->buf, off);\n\t\tif (!sz) {\n\t\t\tfirst = true;\n\t\t\tif (resident) {\n\t\t\t\tresident = false;\n\t\t\t\toff = bin->ne_header->OffStartNonResTab;\n\t\t\t\tsz = r_buf_read8_at (bin->buf, off);\n\t\t\t\tif (!sz) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tchar *name = malloc ((ut64)sz + 1);\n\t\tif (!name) {\n\t\t\tbreak;\n\t\t}\n\t\toff++;\n\t\tr_buf_read_at (bin->buf, off, (ut8 *)name, sz);\n\t\tname[sz] = '\\0';\n\t\toff += sz;\n\t\tsym = R_NEW0 (RBinSymbol);\n\t\tif (!sym) {\n\t\t\tbreak;\n\t\t}\n\t\tsym->name = name;\n\t\tif (!first) {\n\t\t\tsym->bind = R_BIN_BIND_GLOBAL_STR;\n\t\t}\n\t\tut16 entry_off = r_buf_read_le16_at (bin->buf, off);\n\t\toff += 2;\n\t\tRBinAddr *entry = r_list_get_n (entries, entry_off);\n\t\tif (entry) {\n\t\t\tsym->paddr = entry->paddr;\n\t\t} else {\n\t\t\tsym->paddr = -1;\n\t\t}\n\t\tsym->ordinal = entry_off;\n\t\tr_list_append (symbols, sym);\n\t\tfirst = false;\n\t}\n\tRListIter *it;\n\tRBinAddr *en;\n\tint i = 1;\n\tr_list_foreach (entries, it, en) {\n\t\tif (!r_list_find (symbols, &en->paddr, __find_symbol_by_paddr)) {\n\t\t\tsym = R_NEW0 (RBinSymbol);\n\t\t\tif (!sym) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsym->name = r_str_newf (\"entry%d\", i - 1);\n\t\t\tsym->paddr = en->paddr;\n\t\t\tsym->bind = R_BIN_BIND_GLOBAL_STR;\n\t\t\tsym->ordinal = i;\n\t\t\tr_list_append (symbols, sym);\n\t\t}\n\t\ti++;\n\t}\n\tbin->symbols = symbols;\n\treturn symbols;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 245,
    "critical_vars": [
      "obj->cache_buf"
    ],
    "function": "load_buffer",
    "filename": "radare2/CVE-2022-0419/CVE-2022-0419_CWE-476_feaa4e7f7399c51ee6f52deb84dc3f795b4035d6_bin_xnu_kernelcache.c.diff",
    "function_code": "static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {\n\tRBuffer *fbuf = r_buf_ref (buf);\n\tstruct MACH0_(opts_t) opts;\n\tMACH0_(opts_set_default) (&opts, bf);\n\tstruct MACH0_(obj_t) *main_mach0 = MACH0_(new_buf) (fbuf, &opts);\n\tif (!main_mach0) {\n\t\treturn false;\n\t}\n\n\tRRebaseInfo *rebase_info = r_rebase_info_new_from_mach0 (fbuf, main_mach0);\n\tRKernelCacheObj *obj = NULL;\n\n\tRPrelinkRange *prelink_range = get_prelink_info_range_from_mach0 (main_mach0);\n\tif (!prelink_range) {\n\t\tgoto beach;\n\t}\n\n\tobj = R_NEW0 (RKernelCacheObj);\n\tif (!obj) {\n\t\tR_FREE (prelink_range);\n\t\tgoto beach;\n\t}\n\n\tRCFValueDict *prelink_info = NULL;\n\tif (main_mach0->hdr.filetype != MH_FILESET && prelink_range->range.size) {\n\t\tprelink_info = r_cf_value_dict_parse (fbuf, prelink_range->range.offset,\n\t\t\t\tprelink_range->range.size, R_CF_OPTION_SKIP_NSDATA);\n\t\tif (!prelink_info) {\n\t\t\tR_FREE (prelink_range);\n\t\t\tR_FREE (obj);\n\t\t\tgoto beach;\n\t\t}\n\t}\n\n\tif (!pending_bin_files) {\n\t\tpending_bin_files = r_list_new ();\n\t\tif (!pending_bin_files) {\n\t\t\tR_FREE (prelink_range);\n\t\t\tR_FREE (obj);\n\t\t\tR_FREE (prelink_info);\n\t\t\tgoto beach;\n\t\t}\n\t}\n\n\tobj->mach0 = main_mach0;\n\tobj->rebase_info = rebase_info;\n\tobj->prelink_info = prelink_info;\n\tobj->cache_buf = fbuf;\n\tobj->pa2va_exec = prelink_range->pa2va_exec;\n\tobj->pa2va_data = prelink_range->pa2va_data;\n\n\tR_FREE (prelink_range);\n\n\t*bin_obj = obj;\n\n\tr_list_push (pending_bin_files, bf);\n\n\tif (rebase_info || main_mach0->chained_starts) {\n\t\tRIO *io = bf->rbin->iob.io;\n\t\tswizzle_io_read (obj, io);\n\t}\n\n\treturn true;\n\nbeach:\n\tr_buf_free (fbuf);\n\tobj->cache_buf = NULL;\n\tMACH0_(mach0_free) (main_mach0);\n\treturn false;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 245,
    "critical_vars": [
      "obj"
    ],
    "function": "load_buffer",
    "filename": "radare2/CVE-2022-0419/CVE-2022-0419_CWE-476_feaa4e7f7399c51ee6f52deb84dc3f795b4035d6_bin_xnu_kernelcache.c.diff",
    "function_code": "static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {\n\tRBuffer *fbuf = r_buf_ref (buf);\n\tstruct MACH0_(opts_t) opts;\n\tMACH0_(opts_set_default) (&opts, bf);\n\tstruct MACH0_(obj_t) *main_mach0 = MACH0_(new_buf) (fbuf, &opts);\n\tif (!main_mach0) {\n\t\treturn false;\n\t}\n\n\tRRebaseInfo *rebase_info = r_rebase_info_new_from_mach0 (fbuf, main_mach0);\n\tRKernelCacheObj *obj = NULL;\n\n\tRPrelinkRange *prelink_range = get_prelink_info_range_from_mach0 (main_mach0);\n\tif (!prelink_range) {\n\t\tgoto beach;\n\t}\n\n\tobj = R_NEW0 (RKernelCacheObj);\n\tif (!obj) {\n\t\tR_FREE (prelink_range);\n\t\tgoto beach;\n\t}\n\n\tRCFValueDict *prelink_info = NULL;\n\tif (main_mach0->hdr.filetype != MH_FILESET && prelink_range->range.size) {\n\t\tprelink_info = r_cf_value_dict_parse (fbuf, prelink_range->range.offset,\n\t\t\t\tprelink_range->range.size, R_CF_OPTION_SKIP_NSDATA);\n\t\tif (!prelink_info) {\n\t\t\tR_FREE (prelink_range);\n\t\t\tR_FREE (obj);\n\t\t\tgoto beach;\n\t\t}\n\t}\n\n\tif (!pending_bin_files) {\n\t\tpending_bin_files = r_list_new ();\n\t\tif (!pending_bin_files) {\n\t\t\tR_FREE (prelink_range);\n\t\t\tR_FREE (obj);\n\t\t\tR_FREE (prelink_info);\n\t\t\tgoto beach;\n\t\t}\n\t}\n\n\tobj->mach0 = main_mach0;\n\tobj->rebase_info = rebase_info;\n\tobj->prelink_info = prelink_info;\n\tobj->cache_buf = fbuf;\n\tobj->pa2va_exec = prelink_range->pa2va_exec;\n\tobj->pa2va_data = prelink_range->pa2va_data;\n\n\tR_FREE (prelink_range);\n\n\t*bin_obj = obj;\n\n\tr_list_push (pending_bin_files, bf);\n\n\tif (rebase_info || main_mach0->chained_starts) {\n\t\tRIO *io = bf->rbin->iob.io;\n\t\tswizzle_io_read (obj, io);\n\t}\n\n\treturn true;\n\nbeach:\n\tr_buf_free (fbuf);\n\tif (obj) {\n\t\tobj->cache_buf = NULL;\n\t}\n\tMACH0_(mach0_free) (main_mach0);\n\treturn false;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 789,
    "critical_vars": [
      "map->reloc_map"
    ],
    "function": "r_io_bank_read_at",
    "filename": "radare2/CVE-2022-4843/CVE-2022-4843_CWE-476_842f809d4ec6a12af2906f948657281c9ebc8a24_io_bank.c.diff",
    "function_code": "R_API bool r_io_bank_read_at(RIO *io, const ut32 bankid, ut64 addr, ut8 *buf, int len) {\n\tr_return_val_if_fail (io, false);\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tif (!bank) {\n\t\treturn false;\n\t}\n\tRIOSubMap fake_sm = {{0}};\n\tfake_sm.itv.addr = addr;\n\tfake_sm.itv.size = len;\n\tRRBNode *node;\n\tif (R_LIKELY (bank->last_used && r_io_submap_contain (((RIOSubMap *)bank->last_used->data), addr))) {\n\t\tnode = bank->last_used;\n\t} else {\n\t\tnode = _find_entry_submap_node (bank, &fake_sm);\n\t}\n\tmemset (buf, io->Oxff, len);\n\tRIOSubMap *sm = node ? (RIOSubMap *)node->data : NULL;\n\tbool ret = true;\n\twhile (sm && r_io_submap_overlap ((&fake_sm), sm)) {\n\t\tbank->last_used = node;\n\t\tRIOMap *map = r_io_map_get_by_ref (io, &sm->mapref);\n\t\tif (!map) {\n\t\t\t// mapref doesn't belong to map\n\t\t\treturn false;\n\t\t}\n\t\tif (!(map->perm & R_PERM_R)) {\n\t\t\tnode = r_rbnode_next (node);\n\t\t\tsm = node ? (RIOSubMap *)node->data : NULL;\n\t\t\tcontinue;\n\t\t}\n\t\tconst ut64 buf_off = R_MAX (addr, r_io_submap_from (sm)) - addr;\n\t\tconst int read_len = R_MIN (r_io_submap_to ((&fake_sm)),\n\t\t\t\t\t     r_io_submap_to (sm)) - (addr + buf_off) + 1;\n\t\tif (map->perm & R_PERM_RELOC && map->reloc_map) {\n\t\t\tret &= map->reloc_map->read (io, map, addr + buf_off, &buf[buf_off], read_len);\n\t\t} else {\n\t\t\tconst ut64 paddr = addr + buf_off - r_io_map_from (map) + map->delta;\n\t\t\tret &= (r_io_fd_read_at (io, map->fd, paddr, &buf[buf_off], read_len) == read_len);\n\t\t}\n\t\t// check return value here?\n\t\tnode = r_rbnode_next (node);\n\t\tsm = node ? (RIOSubMap *)node->data : NULL;\n\t}\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 878,
    "critical_vars": [
      "map->reloc_map"
    ],
    "function": "r_io_bank_read_from_submap_at",
    "filename": "radare2/CVE-2022-4843/CVE-2022-4843_CWE-476_842f809d4ec6a12af2906f948657281c9ebc8a24_io_bank.c.diff",
    "function_code": "R_API int r_io_bank_read_from_submap_at(RIO *io, const ut32 bankid, ut64 addr, ut8 *buf, int len) {\n\tr_return_val_if_fail (io, -1);\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tif (!bank) {\n\t\treturn 0;\n\t}\n\tif (!len) {\n\t\treturn 0;\n\t}\n\tRRBNode *node;\n\tif (bank->last_used && r_io_submap_contain (((RIOSubMap *)bank->last_used->data), addr)) {\n\t\tnode = bank->last_used;\n\t} else {\n\t\tnode = r_crbtree_find_node (bank->submaps, &addr, _find_sm_by_vaddr_cb, NULL);\n\t\tif (!node) {\n\t\t\treturn 0;\n\t\t}\n\t\tbank->last_used = node;\n\t}\n\tRIOSubMap *sm = (RIOSubMap *)node->data;\n\tif (!r_io_submap_contain (sm, addr)) {\n\t\treturn 0;\n\t}\n\tRIOMap *map = r_io_map_get_by_ref (io, &sm->mapref);\n\tif (!map || !(map->perm & R_PERM_R)) {\n\t\treturn -1;\n\t}\n\tconst int read_len = R_MIN (len, r_io_submap_to (sm) - addr + 1);\n\tif (map->perm & R_PERM_RELOC && map->reloc_map) {\n\t\treturn map->reloc_map->read (io, map, addr, buf, read_len);\n\t}\n\tconst ut64 paddr = addr - r_io_map_from (map) + map->delta;\n\treturn r_io_fd_read_at (io, map->fd, paddr, buf, read_len);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 380,
    "critical_vars": [
      "p4"
    ],
    "function": "dex_parse_debug_item",
    "filename": "radare2/CVE-2017-6415/CVE-2017-6415_CWE-476_68338b71a563b24e62617bb629059adc0c94b230_bin_dex.c.diff",
    "function_code": "static void dex_parse_debug_item(RBinFile *binfile, RBinDexObj *bin,\n\t\t\t\t  RBinDexClass *c, int MI, int MA, int paddr, int ins_size,\n\t\t\t\t  int insns_size, char *class_name, int regsz,\n\t\t\t\t  int debug_info_off) {\n\tstruct r_bin_t *rbin = binfile->rbin;\n\tconst ut8 *p4 = r_buf_get_at (binfile->buf, debug_info_off, NULL);\n\tconst ut8 *p4_end = p4 + binfile->buf->length - debug_info_off;\n\tut64 line_start;\n\tut64 parameters_size;\n\tut64 param_type_idx;\n\tut16 argReg = regsz - ins_size;\n\tut64 source_file_idx = c->source_file;\n\tRList *params, *debug_positions, *emitted_debug_locals = NULL; \n\tbool keep = true;\n\tif (argReg > regsz) {\n\t\treturn; // this return breaks tests\n\t}\n\tp4 = r_uleb128 (p4, p4_end - p4, &line_start);\n\tp4 = r_uleb128 (p4, p4_end - p4, &parameters_size);\n\t// TODO: check when we should use source_file\n\t// The state machine consists of five registers\n\tut32 address = 0;\n\tut32 line = line_start;\n\tif (!(debug_positions = r_list_newf ((RListFree)free))) {\n\t\treturn;\t\n\t}\n\tif (!(emitted_debug_locals = r_list_newf ((RListFree)free))) {\n\t\tr_list_free (debug_positions);\n\t\treturn;\n\t}\n\n\tstruct dex_debug_local_t debug_locals[regsz];\n\tmemset (debug_locals, 0, sizeof (struct dex_debug_local_t) * regsz);\n\tif (!(MA & 0x0008)) {\n\t\tdebug_locals[argReg].name = \"this\";\n\t\tdebug_locals[argReg].descriptor = r_str_newf(\"%s;\", class_name);\n\t\tdebug_locals[argReg].startAddress = 0;\n\t\tdebug_locals[argReg].signature = NULL;\n\t\tdebug_locals[argReg].live = true;\n\t\targReg++;\n\t}\n\tif (!(params = dex_method_signature2 (bin, MI))) {\n\t\tr_list_free (debug_positions);\n\t\tr_list_free (emitted_debug_locals);\n\t\treturn;\n\t}\n\n\tRListIter *iter = r_list_iterator (params);\n\tchar *name;\n\tchar *type;\n\tint reg;\n\n\tr_list_foreach (params, iter, type) {\n\t\tif ((argReg >= regsz) || !type || parameters_size <= 0) {\n\t\t\tr_list_free (debug_positions);\n\t\t\tr_list_free (params);\n\t\t\tr_list_free (emitted_debug_locals);\n\t\t\treturn;\n\t\t}\n\t\tp4 = r_uleb128 (p4, p4_end - p4, &param_type_idx); // read uleb128p1\n\t\tparam_type_idx -= 1;\n\t\tname = getstr (bin, param_type_idx);\n\t\treg = argReg;\n\t\tswitch (type[0]) {\n\t\tcase 'D':\n\t\tcase 'J':\n\t\t\targReg += 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\targReg += 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (name) {\n\t\t\tdebug_locals[reg].name = name;\n\t\t\tdebug_locals[reg].descriptor = type;\n\t\t\tdebug_locals[reg].signature = NULL;\n\t\t\tdebug_locals[reg].startAddress = address;\n\t\t\tdebug_locals[reg].live = true;\n\t\t}\n\t\t--parameters_size;\n\t}\n\n\tif (p4 <= 0) {\n\t\treturn;\n\t}\n\tut8 opcode = *(p4++) & 0xff;\n\twhile (keep) {\n\t\tswitch (opcode) {\n\t\tcase 0x0: // DBG_END_SEQUENCE\n\t\t\tkeep = false;\n\t\t\tbreak;\n\t\tcase 0x1: // DBG_ADVANCE_PC\n\t\t\t{\n\t\t\tut64 addr_diff;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &addr_diff);\n\t\t\taddress += addr_diff;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x2: // DBG_ADVANCE_LINE\n\t\t\t{\n\t\t\tst64 line_diff = r_sleb128 (&p4, p4_end);\n\t\t\tline += line_diff;\n\t\t\t}\n\t\t\tbreak;\t\n\t\tcase 0x3: // DBG_START_LOCAL\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tut64 name_idx;\n\t\t\tut64 type_idx;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &name_idx); \n\t\t\tname_idx -= 1;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &type_idx); \n\t\t\ttype_idx -= 1;\n\t\t\tif (register_num >= regsz) {\n\t\t\t\tr_list_free (debug_positions);\n\t\t\t\tr_list_free (params);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Emit what was previously there, if anything\n\t\t\t// emitLocalCbIfLive\n\t\t\tif (debug_locals[register_num].live) {\n\t\t\t\tstruct dex_debug_local_t *local = malloc (\n\t\t\t\t\tsizeof (struct dex_debug_local_t));\n\t\t\t\tif (!local) {\n\t\t\t\t\tkeep = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlocal->name = debug_locals[register_num].name;\n\t\t\t\tlocal->descriptor = debug_locals[register_num].descriptor;\n\t\t\t\tlocal->startAddress = debug_locals[register_num].startAddress;\n\t\t\t\tlocal->signature = debug_locals[register_num].signature;\n\t\t\t\tlocal->live = true;\n\t\t\t\tlocal->reg = register_num;\n\t\t\t\tlocal->endAddress = address;\n\t\t\t\tr_list_append (emitted_debug_locals, local);\n\t\t\t}\n\t\t\tdebug_locals[register_num].name = getstr (bin, name_idx);\n\t\t\tdebug_locals[register_num].descriptor = dex_type_descriptor (bin, type_idx);\n\t\t\tdebug_locals[register_num].startAddress = address;\n\t\t\tdebug_locals[register_num].signature = NULL;\n\t\t\tdebug_locals[register_num].live = true;\n\t\t\t//eprintf(\"DBG_START_LOCAL %x %x %x\\n\", register_num, name_idx, type_idx);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x4: //DBG_START_LOCAL_EXTENDED\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tut64 name_idx;\n\t\t\tut64 type_idx;\n\t\t\tut64 sig_idx;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &name_idx);\n\t\t\tname_idx -= 1;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &type_idx);\n\t\t\ttype_idx -= 1;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &sig_idx);\n\t\t\tsig_idx -= 1;\n\t\t\tif (register_num >= regsz) {\n\t\t\t\tr_list_free (debug_positions);\n\t\t\t\tr_list_free (params);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Emit what was previously there, if anything\n\t\t\t// emitLocalCbIfLive\n\t\t\tif (debug_locals[register_num].live) {\n\t\t\t\tstruct dex_debug_local_t *local = malloc (\n\t\t\t\t\tsizeof (struct dex_debug_local_t));\n\t\t\t\tif (!local) {\n\t\t\t\t\tkeep = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlocal->name = debug_locals[register_num].name;\n\t\t\t\tlocal->descriptor = debug_locals[register_num].descriptor;\n\t\t\t\tlocal->startAddress = debug_locals[register_num].startAddress;\n\t\t\t\tlocal->signature = debug_locals[register_num].signature;\n\t\t\t\tlocal->live = true;\n\t\t\t\tlocal->reg = register_num;\n\t\t\t\tlocal->endAddress = address;\n\t\t\t\tr_list_append (emitted_debug_locals, local);\n\t\t\t}\n\n\t\t\tdebug_locals[register_num].name = getstr (bin, name_idx);\n\t\t\tdebug_locals[register_num].descriptor = dex_type_descriptor (bin, type_idx);\n\t\t\tdebug_locals[register_num].startAddress = address;\n\t\t\tdebug_locals[register_num].signature = getstr (bin, sig_idx);\n\t\t\tdebug_locals[register_num].live = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x5: // DBG_END_LOCAL\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\t// emitLocalCbIfLive\n\t\t\tif (debug_locals[register_num].live) {\n\t\t\t\tstruct dex_debug_local_t *local = malloc (\n\t\t\t\t\tsizeof (struct dex_debug_local_t));\n\t\t\t\tif (!local) {\n\t\t\t\t\tkeep = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlocal->name = debug_locals[register_num].name;\n\t\t\t\tlocal->descriptor = debug_locals[register_num].descriptor;\n\t\t\t\tlocal->startAddress = debug_locals[register_num].startAddress;\n\t\t\t\tlocal->signature = debug_locals[register_num].signature;\n\t\t\t\tlocal->live = true;\n\t\t\t\tlocal->reg = register_num;\n\t\t\t\tlocal->endAddress = address;\n\t\t\t\tr_list_append (emitted_debug_locals, local);\n\t\t\t}\n\t\t\tdebug_locals[register_num].live = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x6: // DBG_RESTART_LOCAL\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\tif (!debug_locals[register_num].live) {\n\t\t\t\tdebug_locals[register_num].startAddress = address;\n\t\t\t\tdebug_locals[register_num].live = true;\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x7: //DBG_SET_PROLOGUE_END\n\t\t\tbreak;\n\t\tcase 0x8: //DBG_SET_PROLOGUE_BEGIN\n\t\t\tbreak;\n\t\tcase 0x9:\n\t\t\t{\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &source_file_idx);\n\t\t\tsource_file_idx--;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t{\n\t\t\tint adjusted_opcode = opcode - 0x0a;\n\t\t\taddress += (adjusted_opcode / 15);\n\t\t\tline += -4 + (adjusted_opcode % 15);\n\t\t\tstruct dex_debug_position_t *position =\n\t\t\t\tmalloc (sizeof (struct dex_debug_position_t));\n\t\t\tif (!position) {\n\t\t\t\tkeep = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tposition->source_file_idx = source_file_idx;\n\t\t\tposition->address = address;\n\t\t\tposition->line = line;\n\t\t\tr_list_append (debug_positions, position);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\topcode = *(p4++) & 0xff;\n\t}\n\n\tif (!binfile->sdb_addrinfo) {\n\t\tbinfile->sdb_addrinfo = sdb_new0 ();\n\t}\n\n\tchar *fileline;\n\tchar offset[64];\n\tchar *offset_ptr;\n\n\tRListIter *iter1;\n\tstruct dex_debug_position_t *pos;\n\tr_list_foreach (debug_positions, iter1, pos) {\n\t\tfileline = r_str_newf (\"%s|%\"PFMT64d, getstr (bin, pos->source_file_idx), pos->line);\n\t\toffset_ptr = sdb_itoa (pos->address + paddr, offset, 16);\n\t\tsdb_set (binfile->sdb_addrinfo, offset_ptr, fileline, 0);\n\t\tsdb_set (binfile->sdb_addrinfo, fileline, offset_ptr, 0);\n\t}\n\n\tif (!dexdump) {\n\t\tr_list_free (debug_positions);\n\t\tr_list_free (emitted_debug_locals);\n\t\tr_list_free (params);\n\t\treturn;\n\t}\n\n\tRListIter *iter2;\n\tstruct dex_debug_position_t *position;\n\n\trbin->cb_printf (\"      positions     :\\n\");\n\tr_list_foreach (debug_positions, iter2, position) {\n\t\trbin->cb_printf (\"        0x%04llx line=%llu\\n\",\n\t\t\t\t position->address, position->line);\n\t}\n\n\trbin->cb_printf (\"      locals        :\\n\");\n\n\tRListIter *iter3;\n\tstruct dex_debug_local_t *local;\n\tr_list_foreach (emitted_debug_locals, iter3, local) {\n\t\tif (local->signature) {\n\t\t\trbin->cb_printf (\n\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s %s\\n\",\n\t\t\t\tlocal->startAddress, local->endAddress,\n\t\t\t\tlocal->reg, local->name, local->descriptor,\n\t\t\t\tlocal->signature);\n\t\t} else {\n\t\t\trbin->cb_printf (\n\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s\\n\",\n\t\t\t\tlocal->startAddress, local->endAddress,\n\t\t\t\tlocal->reg, local->name, local->descriptor);\n\t\t}\n\t}\n\n\tfor (reg = 0; reg < regsz; reg++) {\n\t\tif (debug_locals[reg].live) {\n\t\t\tif (debug_locals[reg].signature) {\n\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s \"\n\t\t\t\t\t\"%s\\n\",\n\t\t\t\t\tdebug_locals[reg].startAddress,\n\t\t\t\t\tinsns_size, reg, debug_locals[reg].name,\n\t\t\t\t\tdebug_locals[reg].descriptor,\n\t\t\t\t\tdebug_locals[reg].signature);\n\t\t\t} else {\n\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s\"\n\t\t\t\t\t\"\\n\",\n\t\t\t\t\tdebug_locals[reg].startAddress,\n\t\t\t\t\tinsns_size, reg, debug_locals[reg].name,\n\t\t\t\t\tdebug_locals[reg].descriptor);\n\t\t\t}\n\t\t}\n\t}\n\tr_list_free (debug_positions);\n\tr_list_free (emitted_debug_locals);\n\tr_list_free (params);\n}",
    "label": "False"
  }
]