[
  {
    "patch_model": "Add",
    "change_type": "Fun-Head",
    "line_new": 208,
    "critical_vars": [
      "*sops",
      "*sma",
      "nsops"
    ],
    "function": "",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 211,
    "critical_vars": [
      "locknum"
    ],
    "function": "",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 212,
    "critical_vars": [
      "sma->complex_count",
      "nsops"
    ],
    "function": "",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 214,
    "critical_vars": [
      "*sem"
    ],
    "function": "",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 217,
    "critical_vars": [
      "&sem->lock"
    ],
    "function": "",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 223,
    "critical_vars": [
      "sma->complex_count"
    ],
    "function": "",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 224,
    "critical_vars": [
      "&sem->lock"
    ],
    "function": "",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 233,
    "critical_vars": [
      "&sma->sem_perm.lock"
    ],
    "function": "",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 234,
    "critical_vars": [
      "&sem->lock"
    ],
    "function": "",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 235,
    "critical_vars": [
      "&sma->sem_perm.lock"
    ],
    "function": "",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 239,
    "critical_vars": [
      "locknum"
    ],
    "function": "",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 241,
    "critical_vars": [
      "i"
    ],
    "function": "",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 248,
    "critical_vars": [
      "&sma->sem_perm.lock"
    ],
    "function": "",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "for-Condition",
    "line_new": 250,
    "critical_vars": [
      "i"
    ],
    "function": "",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 251,
    "critical_vars": [
      "*sem"
    ],
    "function": "",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 252,
    "critical_vars": [
      "&sem->lock"
    ],
    "function": "",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 254,
    "critical_vars": [
      "locknum"
    ],
    "function": "",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 259,
    "critical_vars": [
      "sma",
      "sem_array",
      "locknum"
    ],
    "function": "",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 261,
    "critical_vars": [
      "locknum"
    ],
    "function": "",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 262,
    "critical_vars": [
      "&sma->sem_perm.lock"
    ],
    "function": "",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 264,
    "critical_vars": [
      "*sem"
    ],
    "function": "",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 265,
    "critical_vars": [
      "&sem->lock"
    ],
    "function": "",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Head",
    "line_old": 196,
    "critical_vars": [
      "*sops",
      "id",
      "*ns",
      "*locknum",
      "nsops"
    ],
    "function": "",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Head",
    "line_new": 274,
    "critical_vars": [
      "*sops",
      "id",
      "*ns",
      "*locknum",
      "nsops"
    ],
    "function": "",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 208,
    "critical_vars": [
      "&ipcp->lock"
    ],
    "function": "*sem_obtain_lock",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 287,
    "critical_vars": [
      "sma"
    ],
    "function": "*sem_obtain_lock",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 288,
    "critical_vars": [
      "*locknum"
    ],
    "function": "*sem_obtain_lock",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 216,
    "critical_vars": [
      "&ipcp->lock"
    ],
    "function": "*sem_obtain_lock",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 296,
    "critical_vars": [
      "sma",
      "locknum"
    ],
    "function": "*sem_obtain_lock",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Head",
    "line_old": 233,
    "critical_vars": [
      "id",
      "*ns"
    ],
    "function": "*sem_obtain_object",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 236,
    "critical_vars": [
      "*ipcp"
    ],
    "function": "*sem_obtain_object",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 238,
    "critical_vars": [
      "ipcp"
    ],
    "function": "*sem_obtain_object",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 257,
    "critical_vars": [
      "&sma->sem_perm"
    ],
    "function": "*sem_obtain_object_check",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 327,
    "critical_vars": [
      "sma"
    ],
    "function": "*sem_obtain_object_check",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 263,
    "critical_vars": [
      "sma"
    ],
    "function": "*sem_obtain_object_check",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 333,
    "critical_vars": [
      "sma"
    ],
    "function": "*sem_obtain_object_check",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 264,
    "critical_vars": [
      "sem_perm"
    ],
    "function": "*sem_obtain_object_check",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 334,
    "critical_vars": [
      "sma"
    ],
    "function": "*sem_obtain_object_check",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 269,
    "critical_vars": [
      "&sma->sem_perm"
    ],
    "function": "*sem_obtain_object_check",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 339,
    "critical_vars": [
      "sma"
    ],
    "function": "*sem_obtain_object_check",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 270,
    "critical_vars": [
      "sma"
    ],
    "function": "*sem_obtain_object_check",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 340,
    "critical_vars": [
      "sma"
    ],
    "function": "*sem_obtain_object_check",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 271,
    "critical_vars": [
      "sem_perm"
    ],
    "function": "*sem_obtain_object_check",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 279,
    "critical_vars": [
      "sem_perm.lock"
    ],
    "function": "sem_putref",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 348,
    "critical_vars": [
      "sma"
    ],
    "function": "sem_putref",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 280,
    "critical_vars": [
      "sma"
    ],
    "function": "sem_putref",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 349,
    "critical_vars": [
      "sma"
    ],
    "function": "sem_putref",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 281,
    "critical_vars": [
      "sem_perm"
    ],
    "function": "sem_putref",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 350,
    "critical_vars": [
      "sma"
    ],
    "function": "sem_putref",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 445,
    "critical_vars": [
      "&sma->sem_base[i].lock"
    ],
    "function": "newary",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "Fun-Call",
    "line_old": 382,
    "line_new": 453,
    "critical_vars": [
      "sma"
    ],
    "function": "newary",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "Fun-Call",
    "line_old": 821,
    "line_new": 892,
    "critical_vars": [
      "sma"
    ],
    "function": "freeary",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 950,
    "critical_vars": [
      "nsems"
    ],
    "function": "semctl_setval",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 961,
    "critical_vars": [
      "sma"
    ],
    "function": "semctl_setval",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1031,
    "critical_vars": [
      "val"
    ],
    "function": "semctl_setval",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 962,
    "critical_vars": [
      "sma"
    ],
    "function": "semctl_setval",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 966,
    "critical_vars": [
      "nsems"
    ],
    "function": "semctl_setval",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 968,
    "critical_vars": [
      "err"
    ],
    "function": "semctl_setval",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 969,
    "critical_vars": [
      "&sma->sem_perm",
      "ns"
    ],
    "function": "semctl_setval",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 1037,
    "critical_vars": [
      "sma"
    ],
    "function": "semctl_setval",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1038,
    "critical_vars": [
      "sma"
    ],
    "function": "semctl_setval",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1043,
    "critical_vars": [
      "semnum"
    ],
    "function": "semctl_setval",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1049,
    "critical_vars": [
      "&sma->sem_perm",
      "ns"
    ],
    "function": "semctl_setval",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 976,
    "critical_vars": [
      "err"
    ],
    "function": "semctl_setval",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 1060,
    "critical_vars": [
      "sma"
    ],
    "function": "semctl_setval",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 977,
    "critical_vars": [
      "semnum"
    ],
    "function": "semctl_setval",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 982,
    "critical_vars": [
      "err"
    ],
    "function": "semctl_setval",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 983,
    "critical_vars": [
      "val"
    ],
    "function": "semctl_setval",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 995,
    "critical_vars": [
      "err"
    ],
    "function": "semctl_setval",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 1073,
    "critical_vars": [
      "sma"
    ],
    "function": "semctl_setval",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 996,
    "critical_vars": [
      "sma"
    ],
    "function": "semctl_setval",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "Fun-Call",
    "line_old": 1054,
    "line_new": 1130,
    "critical_vars": [
      "sma"
    ],
    "function": "semctl_main",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 1135,
    "critical_vars": [
      "sma"
    ],
    "function": "semctl_main",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 1060,
    "critical_vars": [
      "&sma->sem_perm.lock"
    ],
    "function": "semctl_main",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "Fun-Call",
    "line_old": 1063,
    "line_new": 1139,
    "critical_vars": [
      "sma"
    ],
    "function": "semctl_main",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 1074,
    "critical_vars": [
      "sma"
    ],
    "function": "semctl_main",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1150,
    "critical_vars": [
      "sma"
    ],
    "function": "semctl_main",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "Fun-Call",
    "line_old": 1100,
    "line_new": 1179,
    "critical_vars": [
      "sma"
    ],
    "function": "semctl_main",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 1127,
    "critical_vars": [
      "&sma->sem_perm.lock"
    ],
    "function": "semctl_main",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 1206,
    "critical_vars": [
      "sma"
    ],
    "function": "semctl_main",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "Fun-Call",
    "line_old": 1146,
    "line_new": 1225,
    "critical_vars": [
      "sma"
    ],
    "function": "semctl_main",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 1214,
    "critical_vars": [
      "&sma->sem_perm"
    ],
    "function": "semctl_down",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 1293,
    "critical_vars": [
      "sma"
    ],
    "function": "semctl_down",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 1218,
    "critical_vars": [
      "&sma->sem_perm"
    ],
    "function": "semctl_down",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 1297,
    "critical_vars": [
      "sma"
    ],
    "function": "semctl_down",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "Fun-Call",
    "line_old": 1231,
    "line_new": 1310,
    "critical_vars": [
      "sma"
    ],
    "function": "semctl_down",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 1422,
    "critical_vars": [
      "error"
    ],
    "function": "*find_alloc_undo",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 1344,
    "critical_vars": [
      "error"
    ],
    "function": "*find_alloc_undo",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 1366,
    "critical_vars": [
      "sma"
    ],
    "function": "*find_alloc_undo",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1444,
    "critical_vars": [
      "sma"
    ],
    "function": "*find_alloc_undo",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 1446,
    "critical_vars": [
      "un"
    ],
    "function": "*find_alloc_undo",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "Fun-Call",
    "line_old": 1379,
    "line_new": 1461,
    "critical_vars": [
      "sma"
    ],
    "function": "*find_alloc_undo",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "Fun-Call",
    "line_old": 1407,
    "line_new": 1489,
    "critical_vars": [
      "sma"
    ],
    "function": "*find_alloc_undo",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 1447,
    "line_new": 1529,
    "critical_vars": [
      "undos"
    ],
    "function": "SYSCALL_DEFINE4",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 1573,
    "critical_vars": [
      "&tasks"
    ],
    "function": "SYSCALL_DEFINE4",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 1500,
    "critical_vars": [
      "&tasks"
    ],
    "function": "SYSCALL_DEFINE4",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 1505,
    "critical_vars": [
      "un"
    ],
    "function": "SYSCALL_DEFINE4",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 1537,
    "critical_vars": [
      "&sma->sem_perm"
    ],
    "function": "SYSCALL_DEFINE4",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 1620,
    "critical_vars": [
      "locknum"
    ],
    "function": "SYSCALL_DEFINE4",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1621,
    "critical_vars": [
      "un->semid"
    ],
    "function": "SYSCALL_DEFINE4",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 1539,
    "critical_vars": [
      "un->semid"
    ],
    "function": "SYSCALL_DEFINE4",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 1663,
    "critical_vars": [
      "locknum"
    ],
    "function": "SYSCALL_DEFINE4",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 1616,
    "line_new": 1685,
    "critical_vars": [
      "sma"
    ],
    "function": "SYSCALL_DEFINE4",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 1724,
    "critical_vars": [
      "locknum"
    ],
    "function": "SYSCALL_DEFINE4",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 1788,
    "critical_vars": [
      "i"
    ],
    "function": "exit_sem",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 1720,
    "critical_vars": [
      "i"
    ],
    "function": "exit_sem",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 1734,
    "line_new": 1803,
    "critical_vars": [
      "sma"
    ],
    "function": "exit_sem",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 1810,
    "critical_vars": [
      "sma"
    ],
    "function": "exit_sem",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "Fun-Call",
    "line_old": 1745,
    "line_new": 1816,
    "critical_vars": [
      "sma"
    ],
    "function": "exit_sem",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "Fun-Call",
    "line_old": 1785,
    "line_new": 1856,
    "critical_vars": [
      "sma"
    ],
    "function": "exit_sem",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_sem.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "Var-Declaration",
    "line_old": 481,
    "line_new": 481,
    "critical_vars": [
      "refcount"
    ],
    "function": "ipc_free",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_util.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 525,
    "critical_vars": [
      "out"
    ],
    "function": "rcu_use_vmalloc",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_util.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 532,
    "line_new": 531,
    "critical_vars": [
      "out"
    ],
    "function": "rcu_use_vmalloc",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_util.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 533,
    "critical_vars": [
      "out"
    ],
    "function": "rcu_use_vmalloc",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_util.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 534,
    "critical_vars": [
      "ipc_rcu_hdr",
      "data",
      "out"
    ],
    "function": "rcu_use_vmalloc",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_util.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 534,
    "critical_vars": [
      "out"
    ],
    "function": "rcu_use_vmalloc",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_util.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 535,
    "line_new": 535,
    "critical_vars": [
      "ipc_rcu_hdr",
      "data",
      "out"
    ],
    "function": "rcu_use_vmalloc",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_util.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 539,
    "line_new": 538,
    "critical_vars": [
      "out"
    ],
    "function": "rcu_use_vmalloc",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_util.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 540,
    "critical_vars": [
      "out"
    ],
    "function": "rcu_use_vmalloc",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_util.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 541,
    "critical_vars": [
      "ipc_rcu_hdr",
      "data",
      "out"
    ],
    "function": "rcu_use_vmalloc",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_util.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 541,
    "critical_vars": [
      "out"
    ],
    "function": "rcu_use_vmalloc",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_util.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 542,
    "line_new": 542,
    "critical_vars": [
      "ipc_rcu_hdr",
      "data",
      "out"
    ],
    "function": "rcu_use_vmalloc",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_util.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 546,
    "critical_vars": [
      "ipc_rcu_hdr",
      "out"
    ],
    "function": "rcu_use_vmalloc",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_util.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 549,
    "critical_vars": [
      "ptr"
    ],
    "function": "rcu_use_vmalloc",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_util.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Head",
    "line_new": 551,
    "critical_vars": [
      "*ptr"
    ],
    "function": "rcu_use_vmalloc",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_util.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 551,
    "critical_vars": [
      "container_of(ptr,structipc_rcu_hdr,data)->refcount"
    ],
    "function": "rcu_use_vmalloc",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_util.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 581,
    "line_new": 583,
    "critical_vars": [
      "ipc_rcu_hdr",
      "ptr",
      "data"
    ],
    "function": "ipc_schedule_free",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_util.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 690,
    "critical_vars": [
      "msq"
    ],
    "function": "do_msgsnd",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_msg.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 691,
    "critical_vars": [
      "msq"
    ],
    "function": "do_msgsnd",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_msg.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 692,
    "critical_vars": [
      "err"
    ],
    "function": "do_msgsnd",
    "filename": "linux/CVE-2013-4483/CVE-2013-4483_CWE-189_6062a8dc0517bce23e3c2f7d2fea5e22411269a3_msg.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 1272,
    "critical_vars": [
      "val",
      "long"
    ],
    "function": "perf_instruction_pointer",
    "filename": "linux/CVE-2011-4611/CVE-2011-4611_CWE-189_0837e3242c73566fc1c0196b4ec61779c25ffc93_perf_event.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1341,
    "critical_vars": [
      "val"
    ],
    "function": "perf_event_interrupt",
    "filename": "linux/CVE-2011-4611/CVE-2011-4611_CWE-189_0837e3242c73566fc1c0196b4ec61779c25ffc93_perf_event.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 327,
    "critical_vars": [
      "_copy_from_pages"
    ],
    "function": "_copy_from_pages",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_xdr.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 3429,
    "critical_vars": [
      "buflen",
      "pgbase",
      "buf",
      "page",
      "pages"
    ],
    "function": "nfs4_server_supports_acls",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 3432,
    "critical_vars": [
      "*p"
    ],
    "function": "nfs4_server_supports_acls",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 3434,
    "critical_vars": [
      "*pgbase"
    ],
    "function": "nfs4_server_supports_acls",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 3435,
    "critical_vars": [
      "p"
    ],
    "function": "nfs4_server_supports_acls",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "while-Condition",
    "line_old": 3436,
    "critical_vars": [
      "p"
    ],
    "function": "nfs4_server_supports_acls",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 3438,
    "critical_vars": [
      "p"
    ],
    "function": "nfs4_server_supports_acls",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 3540,
    "critical_vars": [
      "*pages"
    ],
    "function": "nfs4_write_cached_acl",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 3537,
    "critical_vars": [
      "structpage*pages[NFS4ACL_MAXPAGES]"
    ],
    "function": "nfs4_write_cached_acl",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 3555,
    "critical_vars": [
      "*localpage"
    ],
    "function": "__nfs4_get_acl_uncached",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf)\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 3552,
    "critical_vars": [
      "ret"
    ],
    "function": "__nfs4_get_acl_uncached",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf) {\n\t\tif (res.acl_len > buflen) {\n\t\t\tret = -ERANGE;\n\t\t\tgoto out_free;\n\t\t}\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\n\t}\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 3556,
    "critical_vars": [
      "ret"
    ],
    "function": "__nfs4_get_acl_uncached",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf)\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 3558,
    "critical_vars": [
      "buflen"
    ],
    "function": "__nfs4_get_acl_uncached",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf)\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 3554,
    "critical_vars": [
      "npages"
    ],
    "function": "__nfs4_get_acl_uncached",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf) {\n\t\tif (res.acl_len > buflen) {\n\t\t\tret = -ERANGE;\n\t\t\tgoto out_free;\n\t\t}\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\n\t}\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 3561,
    "critical_vars": [
      "localpage"
    ],
    "function": "__nfs4_get_acl_uncached",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf)\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 3557,
    "critical_vars": [
      "npages"
    ],
    "function": "__nfs4_get_acl_uncached",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf) {\n\t\tif (res.acl_len > buflen) {\n\t\t\tret = -ERANGE;\n\t\t\tgoto out_free;\n\t\t}\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\n\t}\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 3562,
    "critical_vars": [
      "resp_buf"
    ],
    "function": "__nfs4_get_acl_uncached",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf)\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 3558,
    "critical_vars": [
      "npages"
    ],
    "function": "__nfs4_get_acl_uncached",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf) {\n\t\tif (res.acl_len > buflen) {\n\t\t\tret = -ERANGE;\n\t\t\tgoto out_free;\n\t\t}\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\n\t}\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 3563,
    "critical_vars": [
      "localpage"
    ],
    "function": "__nfs4_get_acl_uncached",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf)\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "for-Condition",
    "line_new": 3560,
    "critical_vars": [
      "i"
    ],
    "function": "__nfs4_get_acl_uncached",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf) {\n\t\tif (res.acl_len > buflen) {\n\t\t\tret = -ERANGE;\n\t\t\tgoto out_free;\n\t\t}\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\n\t}\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 3561,
    "critical_vars": [
      "pages[i]"
    ],
    "function": "__nfs4_get_acl_uncached",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf) {\n\t\tif (res.acl_len > buflen) {\n\t\t\tret = -ERANGE;\n\t\t\tgoto out_free;\n\t\t}\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\n\t}\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 3565,
    "critical_vars": [
      "args.acl_pages[0]"
    ],
    "function": "__nfs4_get_acl_uncached",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf)\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 3562,
    "critical_vars": [
      "pages[i]"
    ],
    "function": "__nfs4_get_acl_uncached",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf) {\n\t\tif (res.acl_len > buflen) {\n\t\t\tret = -ERANGE;\n\t\t\tgoto out_free;\n\t\t}\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\n\t}\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 3566,
    "critical_vars": [
      "args.acl_pgbase"
    ],
    "function": "__nfs4_get_acl_uncached",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf)\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 3567,
    "critical_vars": [
      "args.acl_len"
    ],
    "function": "__nfs4_get_acl_uncached",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf)\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 3565,
    "critical_vars": [
      "npages"
    ],
    "function": "__nfs4_get_acl_uncached",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf) {\n\t\tif (res.acl_len > buflen) {\n\t\t\tret = -ERANGE;\n\t\t\tgoto out_free;\n\t\t}\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\n\t}\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 3567,
    "critical_vars": [
      "args.acl_scratch"
    ],
    "function": "__nfs4_get_acl_uncached",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf) {\n\t\tif (res.acl_len > buflen) {\n\t\t\tret = -ERANGE;\n\t\t\tgoto out_free;\n\t\t}\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\n\t}\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 3569,
    "critical_vars": [
      "resp_buf"
    ],
    "function": "__nfs4_get_acl_uncached",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf)\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 3568,
    "critical_vars": [
      "args.acl_scratch"
    ],
    "function": "__nfs4_get_acl_uncached",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf) {\n\t\tif (res.acl_len > buflen) {\n\t\t\tret = -ERANGE;\n\t\t\tgoto out_free;\n\t\t}\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\n\t}\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 3570,
    "critical_vars": [
      "buf",
      "&args.acl_pgbase",
      "args.acl_pages",
      "buflen"
    ],
    "function": "__nfs4_get_acl_uncached",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf)\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 3572,
    "critical_vars": [
      "ret"
    ],
    "function": "__nfs4_get_acl_uncached",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf)\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 3571,
    "critical_vars": [
      "args.acl_len"
    ],
    "function": "__nfs4_get_acl_uncached",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf) {\n\t\tif (res.acl_len > buflen) {\n\t\t\tret = -ERANGE;\n\t\t\tgoto out_free;\n\t\t}\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\n\t}\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 3572,
    "critical_vars": [
      "args.acl_pgbase"
    ],
    "function": "__nfs4_get_acl_uncached",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf) {\n\t\tif (res.acl_len > buflen) {\n\t\t\tret = -ERANGE;\n\t\t\tgoto out_free;\n\t\t}\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\n\t}\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 3575,
    "critical_vars": [
      "buf"
    ],
    "function": "__nfs4_get_acl_uncached",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf) {\n\t\tif (res.acl_len > buflen) {\n\t\t\tret = -ERANGE;\n\t\t\tgoto out_free;\n\t\t}\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\n\t}\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 3576,
    "critical_vars": [
      "res.acl_flags"
    ],
    "function": "__nfs4_get_acl_uncached",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf) {\n\t\tif (res.acl_len > buflen) {\n\t\t\tret = -ERANGE;\n\t\t\tgoto out_free;\n\t\t}\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\n\t}\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 3577,
    "critical_vars": [
      "resp_buf"
    ],
    "function": "__nfs4_get_acl_uncached",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf) {\n\t\tif (res.acl_len > buflen) {\n\t\t\tret = -ERANGE;\n\t\t\tgoto out_free;\n\t\t}\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\n\t}\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 3579,
    "critical_vars": [
      "args.acl_len",
      "buflen",
      "npages",
      "buf",
      "__func__"
    ],
    "function": "__nfs4_get_acl_uncached",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf) {\n\t\tif (res.acl_len > buflen) {\n\t\t\tret = -ERANGE;\n\t\t\tgoto out_free;\n\t\t}\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\n\t}\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 3581,
    "critical_vars": [
      "ret"
    ],
    "function": "__nfs4_get_acl_uncached",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf) {\n\t\tif (res.acl_len > buflen) {\n\t\t\tret = -ERANGE;\n\t\t\tgoto out_free;\n\t\t}\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\n\t}\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 3575,
    "critical_vars": [
      "res.acl_len"
    ],
    "function": "__nfs4_get_acl_uncached",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf)\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 3586,
    "critical_vars": [
      "acl_len"
    ],
    "function": "__nfs4_get_acl_uncached",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf) {\n\t\tif (res.acl_len > buflen) {\n\t\t\tret = -ERANGE;\n\t\t\tgoto out_free;\n\t\t}\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\n\t}\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 3576,
    "critical_vars": [
      "inode",
      "res.acl_len"
    ],
    "function": "__nfs4_get_acl_uncached",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf)\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 3587,
    "critical_vars": [
      "acl_len"
    ],
    "function": "__nfs4_get_acl_uncached",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf) {\n\t\tif (res.acl_len > buflen) {\n\t\t\tret = -ERANGE;\n\t\t\tgoto out_free;\n\t\t}\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\n\t}\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 3588,
    "critical_vars": [
      "acl_len",
      "inode"
    ],
    "function": "__nfs4_get_acl_uncached",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf) {\n\t\tif (res.acl_len > buflen) {\n\t\t\tret = -ERANGE;\n\t\t\tgoto out_free;\n\t\t}\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\n\t}\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Fun-Call",
    "line_old": 3578,
    "line_new": 3590,
    "critical_vars": [
      "acl_len",
      "res.acl_data_offset",
      "res.acl_len"
    ],
    "function": "__nfs4_get_acl_uncached",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf) {\n\t\tif (res.acl_len > buflen) {\n\t\t\tret = -ERANGE;\n\t\t\tgoto out_free;\n\t\t}\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\n\t}\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 3581,
    "critical_vars": [
      "res.acl_len"
    ],
    "function": "__nfs4_get_acl_uncached",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf)\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 3594,
    "critical_vars": [
      "acl_len"
    ],
    "function": "__nfs4_get_acl_uncached",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf) {\n\t\tif (res.acl_len > buflen) {\n\t\t\tret = -ERANGE;\n\t\t\tgoto out_free;\n\t\t}\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\n\t}\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 3583,
    "critical_vars": [
      "localpage"
    ],
    "function": "__nfs4_get_acl_uncached",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf)\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 3596,
    "critical_vars": [
      "pages",
      "buf",
      "res.acl_data_offset",
      "res.acl_len"
    ],
    "function": "__nfs4_get_acl_uncached",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf) {\n\t\tif (res.acl_len > buflen) {\n\t\t\tret = -ERANGE;\n\t\t\tgoto out_free;\n\t\t}\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\n\t}\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 3584,
    "critical_vars": [
      "buf",
      "resp_buf",
      "res.acl_len"
    ],
    "function": "__nfs4_get_acl_uncached",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf)\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "label": "True"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 3586,
    "line_new": 3599,
    "critical_vars": [
      "ret"
    ],
    "function": "__nfs4_get_acl_uncached",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf) {\n\t\tif (res.acl_len > buflen) {\n\t\t\tret = -ERANGE;\n\t\t\tgoto out_free;\n\t\t}\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\n\t}\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 3588,
    "critical_vars": [
      "localpage"
    ],
    "function": "__nfs4_get_acl_uncached",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf)\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "for-Condition",
    "line_new": 3601,
    "critical_vars": [
      "i"
    ],
    "function": "__nfs4_get_acl_uncached",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf) {\n\t\tif (res.acl_len > buflen) {\n\t\t\tret = -ERANGE;\n\t\t\tgoto out_free;\n\t\t}\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\n\t}\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 3589,
    "critical_vars": [
      "localpage"
    ],
    "function": "__nfs4_get_acl_uncached",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf)\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 3602,
    "critical_vars": [
      "pages[i]"
    ],
    "function": "__nfs4_get_acl_uncached",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf) {\n\t\tif (res.acl_len > buflen) {\n\t\t\tret = -ERANGE;\n\t\t\tgoto out_free;\n\t\t}\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\n\t}\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 3603,
    "critical_vars": [
      "pages[i]"
    ],
    "function": "__nfs4_get_acl_uncached",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf) {\n\t\tif (res.acl_len > buflen) {\n\t\t\tret = -ERANGE;\n\t\t\tgoto out_free;\n\t\t}\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\n\t}\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 3604,
    "critical_vars": [
      "args.acl_scratch"
    ],
    "function": "__nfs4_get_acl_uncached",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf) {\n\t\tif (res.acl_len > buflen) {\n\t\t\tret = -ERANGE;\n\t\t\tgoto out_free;\n\t\t}\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\n\t}\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 3605,
    "critical_vars": [
      "args.acl_scratch"
    ],
    "function": "__nfs4_get_acl_uncached",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4proc.c.diff",
    "function_code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf) {\n\t\tif (res.acl_len > buflen) {\n\t\t\tret = -ERANGE;\n\t\t\tgoto out_free;\n\t\t}\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\n\t}\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 2520,
    "line_new": 2520,
    "critical_vars": [
      "replen"
    ],
    "function": "nfs4_xdr_enc_getacl",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4xdr.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 2525,
    "critical_vars": [
      "args->acl_scratch",
      "xdr"
    ],
    "function": "nfs4_xdr_enc_getacl",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4xdr.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 4960,
    "critical_vars": [
      "*acl_len"
    ],
    "function": "decode_restorefh",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4xdr.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 4962,
    "critical_vars": [
      "*res"
    ],
    "function": "decode_restorefh",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4xdr.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 4964,
    "critical_vars": [
      "*bm_p"
    ],
    "function": "decode_restorefh",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4xdr.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 4968,
    "critical_vars": [
      "*acl_len"
    ],
    "function": "decode_restorefh",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4xdr.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 4970,
    "critical_vars": [
      "res->acl_len"
    ],
    "function": "decode_restorefh",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4xdr.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 4973,
    "critical_vars": [
      "bm_p"
    ],
    "function": "decode_restorefh",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4xdr.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 4988,
    "critical_vars": [
      "xdr->p"
    ],
    "function": "decode_getacl",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4xdr.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 4989,
    "critical_vars": [
      "res->acl_data_offset"
    ],
    "function": "decode_getacl",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4xdr.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 4990,
    "critical_vars": [
      "acl_data_offset"
    ],
    "function": "decode_getacl",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4xdr.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 4995,
    "critical_vars": [
      "attrlen"
    ],
    "function": "decode_getacl",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4xdr.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 4998,
    "critical_vars": [
      "res->acl_flags"
    ],
    "function": "decode_getacl",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4xdr.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 5000,
    "critical_vars": [
      "res->acl_len"
    ],
    "function": "decode_getacl",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4xdr.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 4993,
    "critical_vars": [
      "*acl_len"
    ],
    "function": "decode_getacl",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4xdr.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 5008,
    "critical_vars": [
      "res->acl_len"
    ],
    "function": "decode_getacl",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4xdr.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 6031,
    "line_new": 6046,
    "critical_vars": [
      "status"
    ],
    "function": "nfs4_xdr_dec_getacl",
    "filename": "linux/CVE-2011-4131/CVE-2011-4131_CWE-189_bf118a342f10dafe44b14451a1392c3254629a1f_nfs4xdr.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 823,
    "critical_vars": [
      "offs"
    ],
    "function": "opl3_hw_control",
    "filename": "linux/CVE-2011-1476/CVE-2011-1476_CWE-189_b769f49463711205d57286e64cf535ed4daf59e9_opl3.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 833,
    "critical_vars": [
      "&ins",
      "ins",
      "addr"
    ],
    "function": "opl3_load_patch",
    "filename": "linux/CVE-2011-1476/CVE-2011-1476_CWE-189_b769f49463711205d57286e64cf535ed4daf59e9_opl3.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 244,
    "line_new": 244,
    "critical_vars": [
      "err"
    ],
    "function": "sequencer_write",
    "filename": "linux/CVE-2011-1476/CVE-2011-1476_CWE-189_b769f49463711205d57286e64cf535ed4daf59e9_sequencer.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 479,
    "critical_vars": [
      "offs"
    ],
    "function": "EXPORT_SYMBOL",
    "filename": "linux/CVE-2011-1476/CVE-2011-1476_CWE-189_b769f49463711205d57286e64cf535ed4daf59e9_midi_synth.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 508,
    "critical_vars": [
      "addr",
      "hdr_size",
      "&sysex"
    ],
    "function": "midi_synth_load_patch",
    "filename": "linux/CVE-2011-1476/CVE-2011-1476_CWE-189_b769f49463711205d57286e64cf535ed4daf59e9_midi_synth.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 514,
    "critical_vars": [
      "count"
    ],
    "function": "midi_synth_load_patch",
    "filename": "linux/CVE-2011-1476/CVE-2011-1476_CWE-189_b769f49463711205d57286e64cf535ed4daf59e9_midi_synth.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 64,
    "critical_vars": [
      "pfn_t",
      "npages",
      "kvm",
      "pfn",
      "long"
    ],
    "function": "kvm_pin_pages",
    "filename": "linux/CVE-2014-3601/CVE-2014-3601_CWE-189_350b8bdd689cd2ab2c67c8a86a0be86cfa0751a7_iommu.c.diff",
    "function_code": "static pfn_t kvm_pin_pages(struct kvm_memory_slot *slot, gfn_t gfn,\n\t\t\t   unsigned long npages)\n{\n\tgfn_t end_gfn;\n\tpfn_t pfn;\n\n\tpfn     = gfn_to_pfn_memslot(slot, gfn);\n\tend_gfn = gfn + npages;\n\tgfn    += 1;\n\n\tif (is_error_noslot_pfn(pfn))\n\t\treturn pfn;\n\n\twhile (gfn < end_gfn)\n\t\tgfn_to_pfn_memslot(slot, gfn++);\n\n\treturn pfn;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 66,
    "critical_vars": [
      "i"
    ],
    "function": "kvm_pin_pages",
    "filename": "linux/CVE-2014-3601/CVE-2014-3601_CWE-189_350b8bdd689cd2ab2c67c8a86a0be86cfa0751a7_iommu.c.diff",
    "function_code": "static pfn_t kvm_pin_pages(struct kvm_memory_slot *slot, gfn_t gfn,\n\t\t\t   unsigned long npages)\n{\n\tgfn_t end_gfn;\n\tpfn_t pfn;\n\n\tpfn     = gfn_to_pfn_memslot(slot, gfn);\n\tend_gfn = gfn + npages;\n\tgfn    += 1;\n\n\tif (is_error_noslot_pfn(pfn))\n\t\treturn pfn;\n\n\twhile (gfn < end_gfn)\n\t\tgfn_to_pfn_memslot(slot, gfn++);\n\n\treturn pfn;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "for-Condition",
    "line_new": 68,
    "critical_vars": [
      "i"
    ],
    "function": "kvm_pin_pages",
    "filename": "linux/CVE-2014-3601/CVE-2014-3601_CWE-189_350b8bdd689cd2ab2c67c8a86a0be86cfa0751a7_iommu.c.diff",
    "function_code": "static pfn_t kvm_pin_pages(struct kvm_memory_slot *slot, gfn_t gfn,\n\t\t\t   unsigned long npages)\n{\n\tgfn_t end_gfn;\n\tpfn_t pfn;\n\n\tpfn     = gfn_to_pfn_memslot(slot, gfn);\n\tend_gfn = gfn + npages;\n\tgfn    += 1;\n\n\tif (is_error_noslot_pfn(pfn))\n\t\treturn pfn;\n\n\twhile (gfn < end_gfn)\n\t\tgfn_to_pfn_memslot(slot, gfn++);\n\n\treturn pfn;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 69,
    "critical_vars": [
      "i",
      "pfn"
    ],
    "function": "kvm_pin_pages",
    "filename": "linux/CVE-2014-3601/CVE-2014-3601_CWE-189_350b8bdd689cd2ab2c67c8a86a0be86cfa0751a7_iommu.c.diff",
    "function_code": "static pfn_t kvm_pin_pages(struct kvm_memory_slot *slot, gfn_t gfn,\n\t\t\t   unsigned long npages)\n{\n\tgfn_t end_gfn;\n\tpfn_t pfn;\n\n\tpfn     = gfn_to_pfn_memslot(slot, gfn);\n\tend_gfn = gfn + npages;\n\tgfn    += 1;\n\n\tif (is_error_noslot_pfn(pfn))\n\t\treturn pfn;\n\n\twhile (gfn < end_gfn)\n\t\tgfn_to_pfn_memslot(slot, gfn++);\n\n\treturn pfn;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 134,
    "critical_vars": [
      "page_size",
      "pfn",
      "kvm"
    ],
    "function": "kvm_iommu_map_pages",
    "filename": "linux/CVE-2014-3601/CVE-2014-3601_CWE-189_350b8bdd689cd2ab2c67c8a86a0be86cfa0751a7_iommu.c.diff",
    "function_code": "int kvm_iommu_map_pages(struct kvm *kvm, struct kvm_memory_slot *slot)\n{\n\tgfn_t gfn, end_gfn;\n\tpfn_t pfn;\n\tint r = 0;\n\tstruct iommu_domain *domain = kvm->arch.iommu_domain;\n\tint flags;\n\n\t/* check if iommu exists and in use */\n\tif (!domain)\n\t\treturn 0;\n\n\tgfn     = slot->base_gfn;\n\tend_gfn = gfn + slot->npages;\n\n\tflags = IOMMU_READ;\n\tif (!(slot->flags & KVM_MEM_READONLY))\n\t\tflags |= IOMMU_WRITE;\n\tif (!kvm->arch.iommu_noncoherent)\n\t\tflags |= IOMMU_CACHE;\n\n\n\twhile (gfn < end_gfn) {\n\t\tunsigned long page_size;\n\n\t\t/* Check if already mapped */\n\t\tif (iommu_iova_to_phys(domain, gfn_to_gpa(gfn))) {\n\t\t\tgfn += 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Get the page size we could use to map */\n\t\tpage_size = kvm_host_page_size(kvm, gfn);\n\n\t\t/* Make sure the page_size does not exceed the memslot */\n\t\twhile ((gfn + (page_size >> PAGE_SHIFT)) > end_gfn)\n\t\t\tpage_size >>= 1;\n\n\t\t/* Make sure gfn is aligned to the page size we want to map */\n\t\twhile ((gfn << PAGE_SHIFT) & (page_size - 1))\n\t\t\tpage_size >>= 1;\n\n\t\t/* Make sure hva is aligned to the page size we want to map */\n\t\twhile (__gfn_to_hva_memslot(slot, gfn) & (page_size - 1))\n\t\t\tpage_size >>= 1;\n\n\t\t/*\n\t\t * Pin all pages we are about to map in memory. This is\n\t\t * important because we unmap and unpin in 4kb steps later.\n\t\t */\n\t\tpfn = kvm_pin_pages(slot, gfn, page_size >> PAGE_SHIFT);\n\t\tif (is_error_noslot_pfn(pfn)) {\n\t\t\tgfn += 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Map into IO address space */\n\t\tr = iommu_map(domain, gfn_to_gpa(gfn), pfn_to_hpa(pfn),\n\t\t\t      page_size, flags);\n\t\tif (r) {\n\t\t\tprintk(KERN_ERR \"kvm_iommu_map_address:\"\n\t\t\t       \"iommu failed to map pfn=%llx\\n\", pfn);\n\t\t\tkvm_unpin_pages(kvm, pfn, page_size >> PAGE_SHIFT);\n\t\t\tgoto unmap_pages;\n\t\t}\n\n\t\tgfn += page_size >> PAGE_SHIFT;\n\n\n\t}\n\n\treturn 0;\n\nunmap_pages:\n\tkvm_iommu_put_pages(kvm, slot->base_gfn, gfn - slot->base_gfn);\n\treturn r;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Fun-Call",
    "line_old": 137,
    "line_new": 146,
    "critical_vars": [
      "gfn",
      "slot->base_gfn",
      "kvm"
    ],
    "function": "kvm_iommu_map_pages",
    "filename": "linux/CVE-2014-3601/CVE-2014-3601_CWE-189_350b8bdd689cd2ab2c67c8a86a0be86cfa0751a7_iommu.c.diff",
    "function_code": "int kvm_iommu_map_pages(struct kvm *kvm, struct kvm_memory_slot *slot)\n{\n\tgfn_t gfn, end_gfn;\n\tpfn_t pfn;\n\tint r = 0;\n\tstruct iommu_domain *domain = kvm->arch.iommu_domain;\n\tint flags;\n\n\t/* check if iommu exists and in use */\n\tif (!domain)\n\t\treturn 0;\n\n\tgfn     = slot->base_gfn;\n\tend_gfn = gfn + slot->npages;\n\n\tflags = IOMMU_READ;\n\tif (!(slot->flags & KVM_MEM_READONLY))\n\t\tflags |= IOMMU_WRITE;\n\tif (!kvm->arch.iommu_noncoherent)\n\t\tflags |= IOMMU_CACHE;\n\n\n\twhile (gfn < end_gfn) {\n\t\tunsigned long page_size;\n\n\t\t/* Check if already mapped */\n\t\tif (iommu_iova_to_phys(domain, gfn_to_gpa(gfn))) {\n\t\t\tgfn += 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Get the page size we could use to map */\n\t\tpage_size = kvm_host_page_size(kvm, gfn);\n\n\t\t/* Make sure the page_size does not exceed the memslot */\n\t\twhile ((gfn + (page_size >> PAGE_SHIFT)) > end_gfn)\n\t\t\tpage_size >>= 1;\n\n\t\t/* Make sure gfn is aligned to the page size we want to map */\n\t\twhile ((gfn << PAGE_SHIFT) & (page_size - 1))\n\t\t\tpage_size >>= 1;\n\n\t\t/* Make sure hva is aligned to the page size we want to map */\n\t\twhile (__gfn_to_hva_memslot(slot, gfn) & (page_size - 1))\n\t\t\tpage_size >>= 1;\n\n\t\t/*\n\t\t * Pin all pages we are about to map in memory. This is\n\t\t * important because we unmap and unpin in 4kb steps later.\n\t\t */\n\t\tpfn = kvm_pin_pages(slot, gfn, page_size >> PAGE_SHIFT);\n\t\tif (is_error_noslot_pfn(pfn)) {\n\t\t\tgfn += 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Map into IO address space */\n\t\tr = iommu_map(domain, gfn_to_gpa(gfn), pfn_to_hpa(pfn),\n\t\t\t      page_size, flags);\n\t\tif (r) {\n\t\t\tprintk(KERN_ERR \"kvm_iommu_map_address:\"\n\t\t\t       \"iommu failed to map pfn=%llx\\n\", pfn);\n\t\t\tkvm_unpin_pages(kvm, pfn, page_size >> PAGE_SHIFT);\n\t\t\tgoto unmap_pages;\n\t\t}\n\n\t\tgfn += page_size >> PAGE_SHIFT;\n\n\n\t}\n\n\treturn 0;\n\nunmap_pages:\n\tkvm_iommu_put_pages(kvm, slot->base_gfn, gfn - slot->base_gfn);\n\treturn r;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 269,
    "critical_vars": [
      "pfn_t",
      "npages",
      "kvm",
      "pfn",
      "long"
    ],
    "function": "kvm_iommu_map_guest",
    "filename": "linux/CVE-2014-3601/CVE-2014-3601_CWE-189_350b8bdd689cd2ab2c67c8a86a0be86cfa0751a7_iommu.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 271,
    "critical_vars": [
      "i"
    ],
    "function": "kvm_iommu_map_guest",
    "filename": "linux/CVE-2014-3601/CVE-2014-3601_CWE-189_350b8bdd689cd2ab2c67c8a86a0be86cfa0751a7_iommu.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "for-Condition",
    "line_old": 273,
    "critical_vars": [
      "i"
    ],
    "function": "kvm_iommu_map_guest",
    "filename": "linux/CVE-2014-3601/CVE-2014-3601_CWE-189_350b8bdd689cd2ab2c67c8a86a0be86cfa0751a7_iommu.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 274,
    "critical_vars": [
      "i",
      "pfn"
    ],
    "function": "kvm_iommu_map_guest",
    "filename": "linux/CVE-2014-3601/CVE-2014-3601_CWE-189_350b8bdd689cd2ab2c67c8a86a0be86cfa0751a7_iommu.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 645,
    "critical_vars": [
      "*mem"
    ],
    "function": "uio_mmap_physical",
    "filename": "linux/CVE-2013-4511/CVE-2013-4511_CWE-189_7314e613d5ff9f0934f7a0f74ed7973b903315d1_uio.c.diff",
    "function_code": "static int uio_mmap_physical(struct vm_area_struct *vma)\n{\n\tstruct uio_device *idev = vma->vm_private_data;\n\tint mi = uio_find_mem_index(vma);\n\tstruct uio_mem *mem;\n\tif (mi < 0)\n\t\treturn -EINVAL;\n\tmem = idev->info->mem + mi;\n\n\tif (vma->vm_end - vma->vm_start > mem->size)\n\t\treturn -EINVAL;\n\n\tvma->vm_ops = &uio_physical_vm_ops;\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\n\t/*\n\t * We cannot use the vm_iomap_memory() helper here,\n\t * because vma->vm_pgoff is the map index we looked\n\t * up above in uio_find_mem_index(), rather than an\n\t * actual page offset into the mmap.\n\t *\n\t * So we just do the physical mmap without a page\n\t * offset.\n\t */\n\treturn remap_pfn_range(vma,\n\t\t\t       vma->vm_start,\n\t\t\t       mem->addr >> PAGE_SHIFT,\n\t\t\t       vma->vm_end - vma->vm_start,\n\t\t\t       vma->vm_page_prot);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 648,
    "critical_vars": [
      "mem"
    ],
    "function": "uio_mmap_physical",
    "filename": "linux/CVE-2013-4511/CVE-2013-4511_CWE-189_7314e613d5ff9f0934f7a0f74ed7973b903315d1_uio.c.diff",
    "function_code": "static int uio_mmap_physical(struct vm_area_struct *vma)\n{\n\tstruct uio_device *idev = vma->vm_private_data;\n\tint mi = uio_find_mem_index(vma);\n\tstruct uio_mem *mem;\n\tif (mi < 0)\n\t\treturn -EINVAL;\n\tmem = idev->info->mem + mi;\n\n\tif (vma->vm_end - vma->vm_start > mem->size)\n\t\treturn -EINVAL;\n\n\tvma->vm_ops = &uio_physical_vm_ops;\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\n\t/*\n\t * We cannot use the vm_iomap_memory() helper here,\n\t * because vma->vm_pgoff is the map index we looked\n\t * up above in uio_find_mem_index(), rather than an\n\t * actual page offset into the mmap.\n\t *\n\t * So we just do the physical mmap without a page\n\t * offset.\n\t */\n\treturn remap_pfn_range(vma,\n\t\t\t       vma->vm_start,\n\t\t\t       mem->addr >> PAGE_SHIFT,\n\t\t\t       vma->vm_end - vma->vm_start,\n\t\t\t       vma->vm_page_prot);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 648,
    "critical_vars": [
      "vma->vm_ops"
    ],
    "function": "uio_mmap_physical",
    "filename": "linux/CVE-2013-4511/CVE-2013-4511_CWE-189_7314e613d5ff9f0934f7a0f74ed7973b903315d1_uio.c.diff",
    "function_code": "static int uio_mmap_physical(struct vm_area_struct *vma)\n{\n\tstruct uio_device *idev = vma->vm_private_data;\n\tint mi = uio_find_mem_index(vma);\n\tif (mi < 0)\n\t\treturn -EINVAL;\n\n\tvma->vm_ops = &uio_physical_vm_ops;\n\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\n\treturn remap_pfn_range(vma,\n\t\t\t       vma->vm_start,\n\t\t\t       idev->info->mem[mi].addr >> PAGE_SHIFT,\n\t\t\t       vma->vm_end - vma->vm_start,\n\t\t\t       vma->vm_page_prot);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 650,
    "critical_vars": [
      "vma->vm_end",
      "vma->vm_start"
    ],
    "function": "uio_mmap_physical",
    "filename": "linux/CVE-2013-4511/CVE-2013-4511_CWE-189_7314e613d5ff9f0934f7a0f74ed7973b903315d1_uio.c.diff",
    "function_code": "static int uio_mmap_physical(struct vm_area_struct *vma)\n{\n\tstruct uio_device *idev = vma->vm_private_data;\n\tint mi = uio_find_mem_index(vma);\n\tstruct uio_mem *mem;\n\tif (mi < 0)\n\t\treturn -EINVAL;\n\tmem = idev->info->mem + mi;\n\n\tif (vma->vm_end - vma->vm_start > mem->size)\n\t\treturn -EINVAL;\n\n\tvma->vm_ops = &uio_physical_vm_ops;\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\n\t/*\n\t * We cannot use the vm_iomap_memory() helper here,\n\t * because vma->vm_pgoff is the map index we looked\n\t * up above in uio_find_mem_index(), rather than an\n\t * actual page offset into the mmap.\n\t *\n\t * So we just do the physical mmap without a page\n\t * offset.\n\t */\n\treturn remap_pfn_range(vma,\n\t\t\t       vma->vm_start,\n\t\t\t       mem->addr >> PAGE_SHIFT,\n\t\t\t       vma->vm_end - vma->vm_start,\n\t\t\t       vma->vm_page_prot);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 653,
    "critical_vars": [
      "vma->vm_ops"
    ],
    "function": "uio_mmap_physical",
    "filename": "linux/CVE-2013-4511/CVE-2013-4511_CWE-189_7314e613d5ff9f0934f7a0f74ed7973b903315d1_uio.c.diff",
    "function_code": "static int uio_mmap_physical(struct vm_area_struct *vma)\n{\n\tstruct uio_device *idev = vma->vm_private_data;\n\tint mi = uio_find_mem_index(vma);\n\tstruct uio_mem *mem;\n\tif (mi < 0)\n\t\treturn -EINVAL;\n\tmem = idev->info->mem + mi;\n\n\tif (vma->vm_end - vma->vm_start > mem->size)\n\t\treturn -EINVAL;\n\n\tvma->vm_ops = &uio_physical_vm_ops;\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\n\t/*\n\t * We cannot use the vm_iomap_memory() helper here,\n\t * because vma->vm_pgoff is the map index we looked\n\t * up above in uio_find_mem_index(), rather than an\n\t * actual page offset into the mmap.\n\t *\n\t * So we just do the physical mmap without a page\n\t * offset.\n\t */\n\treturn remap_pfn_range(vma,\n\t\t\t       vma->vm_start,\n\t\t\t       mem->addr >> PAGE_SHIFT,\n\t\t\t       vma->vm_end - vma->vm_start,\n\t\t\t       vma->vm_page_prot);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 1238,
    "critical_vars": [
      "len"
    ],
    "function": "au1200fb_fb_blank",
    "filename": "linux/CVE-2013-4511/CVE-2013-4511_CWE-189_7314e613d5ff9f0934f7a0f74ed7973b903315d1_au1200fb.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 1239,
    "critical_vars": [
      "start"
    ],
    "function": "au1200fb_fb_blank",
    "filename": "linux/CVE-2013-4511/CVE-2013-4511_CWE-189_7314e613d5ff9f0934f7a0f74ed7973b903315d1_au1200fb.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 1242,
    "critical_vars": [
      "vma->vm_pgoff"
    ],
    "function": "au1200fb_fb_blank",
    "filename": "linux/CVE-2013-4511/CVE-2013-4511_CWE-189_7314e613d5ff9f0934f7a0f74ed7973b903315d1_au1200fb.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 1246,
    "critical_vars": [
      "start"
    ],
    "function": "au1200fb_fb_blank",
    "filename": "linux/CVE-2013-4511/CVE-2013-4511_CWE-189_7314e613d5ff9f0934f7a0f74ed7973b903315d1_au1200fb.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 1247,
    "critical_vars": [
      "len"
    ],
    "function": "au1200fb_fb_blank",
    "filename": "linux/CVE-2013-4511/CVE-2013-4511_CWE-189_7314e613d5ff9f0934f7a0f74ed7973b903315d1_au1200fb.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 1249,
    "critical_vars": [
      "off"
    ],
    "function": "au1200fb_fb_blank",
    "filename": "linux/CVE-2013-4511/CVE-2013-4511_CWE-189_7314e613d5ff9f0934f7a0f74ed7973b903315d1_au1200fb.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 1251,
    "critical_vars": [
      "vma->vm_end",
      "vma->vm_start",
      "off"
    ],
    "function": "au1200fb_fb_blank",
    "filename": "linux/CVE-2013-4511/CVE-2013-4511_CWE-189_7314e613d5ff9f0934f7a0f74ed7973b903315d1_au1200fb.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 1255,
    "critical_vars": [
      "off"
    ],
    "function": "au1200fb_fb_blank",
    "filename": "linux/CVE-2013-4511/CVE-2013-4511_CWE-189_7314e613d5ff9f0934f7a0f74ed7973b903315d1_au1200fb.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 1256,
    "critical_vars": [
      "vma->vm_pgoff"
    ],
    "function": "au1200fb_fb_blank",
    "filename": "linux/CVE-2013-4511/CVE-2013-4511_CWE-189_7314e613d5ff9f0934f7a0f74ed7973b903315d1_au1200fb.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 364,
    "critical_vars": [
      "len"
    ],
    "function": "au1100fb_fb_rotate",
    "filename": "linux/CVE-2013-4511/CVE-2013-4511_CWE-189_7314e613d5ff9f0934f7a0f74ed7973b903315d1_au1100fb.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 365,
    "critical_vars": [
      "start"
    ],
    "function": "au1100fb_fb_rotate",
    "filename": "linux/CVE-2013-4511/CVE-2013-4511_CWE-189_7314e613d5ff9f0934f7a0f74ed7973b903315d1_au1100fb.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 369,
    "critical_vars": [
      "vma->vm_pgoff"
    ],
    "function": "au1100fb_fb_rotate",
    "filename": "linux/CVE-2013-4511/CVE-2013-4511_CWE-189_7314e613d5ff9f0934f7a0f74ed7973b903315d1_au1100fb.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 373,
    "critical_vars": [
      "start"
    ],
    "function": "au1100fb_fb_rotate",
    "filename": "linux/CVE-2013-4511/CVE-2013-4511_CWE-189_7314e613d5ff9f0934f7a0f74ed7973b903315d1_au1100fb.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 374,
    "critical_vars": [
      "len"
    ],
    "function": "au1100fb_fb_rotate",
    "filename": "linux/CVE-2013-4511/CVE-2013-4511_CWE-189_7314e613d5ff9f0934f7a0f74ed7973b903315d1_au1100fb.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 376,
    "critical_vars": [
      "off"
    ],
    "function": "au1100fb_fb_rotate",
    "filename": "linux/CVE-2013-4511/CVE-2013-4511_CWE-189_7314e613d5ff9f0934f7a0f74ed7973b903315d1_au1100fb.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 378,
    "critical_vars": [
      "vma->vm_end",
      "vma->vm_start",
      "off"
    ],
    "function": "au1100fb_fb_rotate",
    "filename": "linux/CVE-2013-4511/CVE-2013-4511_CWE-189_7314e613d5ff9f0934f7a0f74ed7973b903315d1_au1100fb.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 382,
    "critical_vars": [
      "off"
    ],
    "function": "au1100fb_fb_rotate",
    "filename": "linux/CVE-2013-4511/CVE-2013-4511_CWE-189_7314e613d5ff9f0934f7a0f74ed7973b903315d1_au1100fb.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 383,
    "critical_vars": [
      "vma->vm_pgoff"
    ],
    "function": "au1100fb_fb_rotate",
    "filename": "linux/CVE-2013-4511/CVE-2013-4511_CWE-189_7314e613d5ff9f0934f7a0f74ed7973b903315d1_au1100fb.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 388,
    "critical_vars": [
      "vma",
      "vma->vm_start",
      "off"
    ],
    "function": "au1100fb_fb_rotate",
    "filename": "linux/CVE-2013-4511/CVE-2013-4511_CWE-189_7314e613d5ff9f0934f7a0f74ed7973b903315d1_au1100fb.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 316,
    "critical_vars": [
      "t"
    ],
    "function": "tcp_illinois_info",
    "filename": "linux/CVE-2012-4565/CVE-2012-4565_CWE-189_8f363b77ee4fbf7c3bbcf5ec2c5ca482d396d664_tcp_illinois.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 318,
    "critical_vars": [
      "t",
      "ca->cnt_rtt"
    ],
    "function": "tcp_illinois_info",
    "filename": "linux/CVE-2012-4565/CVE-2012-4565_CWE-189_8f363b77ee4fbf7c3bbcf5ec2c5ca482d396d664_tcp_illinois.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 317,
    "critical_vars": [
      "info.tcpv_rttcnt"
    ],
    "function": "tcp_illinois_info",
    "filename": "linux/CVE-2012-4565/CVE-2012-4565_CWE-189_8f363b77ee4fbf7c3bbcf5ec2c5ca482d396d664_tcp_illinois.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 319,
    "critical_vars": [
      "info.tcpv_rtt"
    ],
    "function": "tcp_illinois_info",
    "filename": "linux/CVE-2012-4565/CVE-2012-4565_CWE-189_8f363b77ee4fbf7c3bbcf5ec2c5ca482d396d664_tcp_illinois.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 318,
    "critical_vars": [
      "t"
    ],
    "function": "tcp_illinois_info",
    "filename": "linux/CVE-2012-4565/CVE-2012-4565_CWE-189_8f363b77ee4fbf7c3bbcf5ec2c5ca482d396d664_tcp_illinois.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 320,
    "critical_vars": [
      "info.tcpv_rttcnt",
      "t"
    ],
    "function": "tcp_illinois_info",
    "filename": "linux/CVE-2012-4565/CVE-2012-4565_CWE-189_8f363b77ee4fbf7c3bbcf5ec2c5ca482d396d664_tcp_illinois.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 321,
    "critical_vars": [
      "info.tcpv_rtt"
    ],
    "function": "tcp_illinois_info",
    "filename": "linux/CVE-2012-4565/CVE-2012-4565_CWE-189_8f363b77ee4fbf7c3bbcf5ec2c5ca482d396d664_tcp_illinois.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 571,
    "critical_vars": [
      "f_offset"
    ],
    "function": "None_func",
    "filename": "linux/CVE-2014-2889/CVE-2014-2889_CWE-189_a03ffcf873fe0f2565386ca8ef832144c42e67fa_bpf_jit_comp.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 572,
    "line_new": 572,
    "critical_vars": [
      "t_offset"
    ],
    "function": "None_func",
    "filename": "linux/CVE-2014-2889/CVE-2014-2889_CWE-189_a03ffcf873fe0f2565386ca8ef832144c42e67fa_bpf_jit_comp.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1407,
    "critical_vars": [
      "args->buffer_count"
    ],
    "function": "i915_gem_execbuffer2",
    "filename": "linux/CVE-2012-2383/CVE-2012-2383_CWE-189_ed8cd3b2cd61004cab85380c52b1817aca1ca49b_i915_gem_execbuffer.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 51,
    "critical_vars": [
      "tp->tv_sec"
    ],
    "function": "sample_to_timespec",
    "filename": "linux/CVE-2011-3209/CVE-2011-3209_CWE-189_f8bd2258e2d520dff28c855658bd24bdafb5102d_posix-cpu-timers.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 52,
    "critical_vars": [
      "*tp"
    ],
    "function": "sample_to_timespec",
    "filename": "linux/CVE-2011-3209/CVE-2011-3209_CWE-189_f8bd2258e2d520dff28c855658bd24bdafb5102d_posix-cpu-timers.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "Var-Declaration",
    "line_old": 105,
    "line_new": 106,
    "critical_vars": [
      "rem"
    ],
    "function": "jiffies_to_compat_timeval",
    "filename": "linux/CVE-2011-3209/CVE-2011-3209_CWE-189_f8bd2258e2d520dff28c855658bd24bdafb5102d_binfmt_elfn32.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 106,
    "line_new": 107,
    "critical_vars": [
      "value->tv_sec"
    ],
    "function": "jiffies_to_compat_timeval",
    "filename": "linux/CVE-2011-3209/CVE-2011-3209_CWE-189_f8bd2258e2d520dff28c855658bd24bdafb5102d_binfmt_elfn32.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 395,
    "critical_vars": [
      "rem"
    ],
    "function": "EXPORT_SYMBOL",
    "filename": "linux/CVE-2011-3209/CVE-2011-3209_CWE-189_f8bd2258e2d520dff28c855658bd24bdafb5102d_time.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 399,
    "line_new": 400,
    "critical_vars": [
      "ts.tv_sec"
    ],
    "function": "EXPORT_SYMBOL",
    "filename": "linux/CVE-2011-3209/CVE-2011-3209_CWE-189_f8bd2258e2d520dff28c855658bd24bdafb5102d_time.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 400,
    "critical_vars": [
      "nsec"
    ],
    "function": "EXPORT_SYMBOL",
    "filename": "linux/CVE-2011-3209/CVE-2011-3209_CWE-189_f8bd2258e2d520dff28c855658bd24bdafb5102d_time.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 401,
    "critical_vars": [
      "rem"
    ],
    "function": "EXPORT_SYMBOL",
    "filename": "linux/CVE-2011-3209/CVE-2011-3209_CWE-189_f8bd2258e2d520dff28c855658bd24bdafb5102d_time.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 401,
    "critical_vars": [
      "ts.tv_sec",
      "ts.tv_nsec",
      "&ts"
    ],
    "function": "EXPORT_SYMBOL",
    "filename": "linux/CVE-2011-3209/CVE-2011-3209_CWE-189_f8bd2258e2d520dff28c855658bd24bdafb5102d_time.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 402,
    "critical_vars": [
      "ts.tv_sec"
    ],
    "function": "EXPORT_SYMBOL",
    "filename": "linux/CVE-2011-3209/CVE-2011-3209_CWE-189_f8bd2258e2d520dff28c855658bd24bdafb5102d_time.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 403,
    "critical_vars": [
      "rem"
    ],
    "function": "EXPORT_SYMBOL",
    "filename": "linux/CVE-2011-3209/CVE-2011-3209_CWE-189_f8bd2258e2d520dff28c855658bd24bdafb5102d_time.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 405,
    "critical_vars": [
      "ts.tv_nsec"
    ],
    "function": "EXPORT_SYMBOL",
    "filename": "linux/CVE-2011-3209/CVE-2011-3209_CWE-189_f8bd2258e2d520dff28c855658bd24bdafb5102d_time.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 531,
    "critical_vars": [
      "nsec"
    ],
    "function": "jiffies_to_timespec",
    "filename": "linux/CVE-2011-3209/CVE-2011-3209_CWE-189_f8bd2258e2d520dff28c855658bd24bdafb5102d_time.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 535,
    "critical_vars": [
      "rem"
    ],
    "function": "jiffies_to_timespec",
    "filename": "linux/CVE-2011-3209/CVE-2011-3209_CWE-189_f8bd2258e2d520dff28c855658bd24bdafb5102d_time.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 532,
    "line_new": 536,
    "critical_vars": [
      "value->tv_sec"
    ],
    "function": "jiffies_to_timespec",
    "filename": "linux/CVE-2011-3209/CVE-2011-3209_CWE-189_f8bd2258e2d520dff28c855658bd24bdafb5102d_time.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 538,
    "critical_vars": [
      "value->tv_nsec"
    ],
    "function": "jiffies_to_timespec",
    "filename": "linux/CVE-2011-3209/CVE-2011-3209_CWE-189_f8bd2258e2d520dff28c855658bd24bdafb5102d_time.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 570,
    "critical_vars": [
      "nsec"
    ],
    "function": "jiffies_to_timeval",
    "filename": "linux/CVE-2011-3209/CVE-2011-3209_CWE-189_f8bd2258e2d520dff28c855658bd24bdafb5102d_time.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 576,
    "critical_vars": [
      "rem"
    ],
    "function": "jiffies_to_timeval",
    "filename": "linux/CVE-2011-3209/CVE-2011-3209_CWE-189_f8bd2258e2d520dff28c855658bd24bdafb5102d_time.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 571,
    "critical_vars": [
      "tv_usec"
    ],
    "function": "jiffies_to_timeval",
    "filename": "linux/CVE-2011-3209/CVE-2011-3209_CWE-189_f8bd2258e2d520dff28c855658bd24bdafb5102d_time.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 573,
    "line_new": 578,
    "critical_vars": [
      "value->tv_sec"
    ],
    "function": "jiffies_to_timeval",
    "filename": "linux/CVE-2011-3209/CVE-2011-3209_CWE-189_f8bd2258e2d520dff28c855658bd24bdafb5102d_time.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 574,
    "critical_vars": [
      "tv_usec"
    ],
    "function": "jiffies_to_timeval",
    "filename": "linux/CVE-2011-3209/CVE-2011-3209_CWE-189_f8bd2258e2d520dff28c855658bd24bdafb5102d_time.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 580,
    "critical_vars": [
      "value->tv_usec"
    ],
    "function": "jiffies_to_timeval",
    "filename": "linux/CVE-2011-3209/CVE-2011-3209_CWE-189_f8bd2258e2d520dff28c855658bd24bdafb5102d_time.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 575,
    "critical_vars": [
      "value->tv_usec"
    ],
    "function": "jiffies_to_timeval",
    "filename": "linux/CVE-2011-3209/CVE-2011-3209_CWE-189_f8bd2258e2d520dff28c855658bd24bdafb5102d_time.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 3624,
    "critical_vars": [
      "remainder"
    ],
    "function": "list_locations",
    "filename": "linux/CVE-2011-3209/CVE-2011-3209_CWE-189_f8bd2258e2d520dff28c855658bd24bdafb5102d_slub.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 3627,
    "critical_vars": [
      "l->max_time",
      "l->sum_time",
      "&remainder",
      "l->count"
    ],
    "function": "list_locations",
    "filename": "linux/CVE-2011-3209/CVE-2011-3209_CWE-189_f8bd2258e2d520dff28c855658bd24bdafb5102d_slub.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 237,
    "critical_vars": [
      "rem"
    ],
    "function": "notify_cmos_timer",
    "filename": "linux/CVE-2011-3209/CVE-2011-3209_CWE-189_f8bd2258e2d520dff28c855658bd24bdafb5102d_ntp.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 348,
    "line_new": 348,
    "critical_vars": [
      "time_offset"
    ],
    "function": "do_adjtimex",
    "filename": "linux/CVE-2011-3209/CVE-2011-3209_CWE-189_f8bd2258e2d520dff28c855658bd24bdafb5102d_ntp.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "Var-Declaration",
    "line_old": 107,
    "line_new": 108,
    "critical_vars": [
      "rem"
    ],
    "function": "jiffies_to_compat_timeval",
    "filename": "linux/CVE-2011-3209/CVE-2011-3209_CWE-189_f8bd2258e2d520dff28c855658bd24bdafb5102d_binfmt_elfo32.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 108,
    "line_new": 109,
    "critical_vars": [
      "value->tv_sec"
    ],
    "function": "jiffies_to_compat_timeval",
    "filename": "linux/CVE-2011-3209/CVE-2011-3209_CWE-189_f8bd2258e2d520dff28c855658bd24bdafb5102d_binfmt_elfo32.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 475,
    "critical_vars": [
      "tp->tv_sec"
    ],
    "function": "sgi_clock_get",
    "filename": "linux/CVE-2011-3209/CVE-2011-3209_CWE-189_f8bd2258e2d520dff28c855658bd24bdafb5102d_mmtimer.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 477,
    "critical_vars": [
      "*tp"
    ],
    "function": "sgi_clock_get",
    "filename": "linux/CVE-2011-3209/CVE-2011-3209_CWE-189_f8bd2258e2d520dff28c855658bd24bdafb5102d_mmtimer.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 478,
    "critical_vars": [
      "tp->tv_sec"
    ],
    "function": "sgi_clock_get",
    "filename": "linux/CVE-2011-3209/CVE-2011-3209_CWE-189_f8bd2258e2d520dff28c855658bd24bdafb5102d_mmtimer.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "Var-Declaration",
    "line_old": 484,
    "line_new": 486,
    "critical_vars": [
      "rem"
    ],
    "function": "sgi_clock_set",
    "filename": "linux/CVE-2011-3209/CVE-2011-3209_CWE-189_f8bd2258e2d520dff28c855658bd24bdafb5102d_mmtimer.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 488,
    "line_new": 490,
    "critical_vars": [
      "sgi_clock_offset.tv_sec"
    ],
    "function": "sgi_clock_set",
    "filename": "linux/CVE-2011-3209/CVE-2011-3209_CWE-189_f8bd2258e2d520dff28c855658bd24bdafb5102d_mmtimer.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 662,
    "critical_vars": [
      "cur_setting->it_interval",
      "timr->it.mmtimer.incr",
      "sgi_clock_period"
    ],
    "function": "sgi_timer_get",
    "filename": "linux/CVE-2011-3209/CVE-2011-3209_CWE-189_f8bd2258e2d520dff28c855658bd24bdafb5102d_mmtimer.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 661,
    "critical_vars": [
      "cur_setting->it_interval"
    ],
    "function": "sgi_timer_get",
    "filename": "linux/CVE-2011-3209/CVE-2011-3209_CWE-189_f8bd2258e2d520dff28c855658bd24bdafb5102d_mmtimer.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 663,
    "critical_vars": [
      "sgi_clock_period",
      "cur_setting->it_value"
    ],
    "function": "sgi_timer_get",
    "filename": "linux/CVE-2011-3209/CVE-2011-3209_CWE-189_f8bd2258e2d520dff28c855658bd24bdafb5102d_mmtimer.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 662,
    "critical_vars": [
      "cur_setting->it_value"
    ],
    "function": "sgi_timer_get",
    "filename": "linux/CVE-2011-3209/CVE-2011-3209_CWE-189_f8bd2258e2d520dff28c855658bd24bdafb5102d_mmtimer.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 682,
    "line_new": 680,
    "critical_vars": [
      "when"
    ],
    "function": "sgi_timer_set",
    "filename": "linux/CVE-2011-3209/CVE-2011-3209_CWE-189_f8bd2258e2d520dff28c855658bd24bdafb5102d_mmtimer.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 683,
    "line_new": 681,
    "critical_vars": [
      "period"
    ],
    "function": "sgi_timer_set",
    "filename": "linux/CVE-2011-3209/CVE-2011-3209_CWE-189_f8bd2258e2d520dff28c855658bd24bdafb5102d_mmtimer.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 698,
    "line_new": 696,
    "critical_vars": [
      "now"
    ],
    "function": "sgi_timer_set",
    "filename": "linux/CVE-2011-3209/CVE-2011-3209_CWE-189_f8bd2258e2d520dff28c855658bd24bdafb5102d_mmtimer.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 314,
    "critical_vars": [
      "nsops"
    ],
    "function": "sys_oabi_semtimedop",
    "filename": "linux/CVE-2011-1759/CVE-2011-1759_CWE-189_0f22072ab50cac7983f9660d33974b45184da4f9_sys_oabi-compat.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 916,
    "critical_vars": [
      "pdata"
    ],
    "function": "lbs_debugfs_write",
    "filename": "linux/CVE-2013-6378/CVE-2013-6378_CWE-189_a497e47d4aec37aaf8f13509f3ef3d1f6a717d88_debugfs.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 916,
    "critical_vars": [
      "cnt"
    ],
    "function": "lbs_debugfs_write",
    "filename": "linux/CVE-2013-6378/CVE-2013-6378_CWE-189_a497e47d4aec37aaf8f13509f3ef3d1f6a717d88_debugfs.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 919,
    "critical_vars": [
      "pdata"
    ],
    "function": "lbs_debugfs_write",
    "filename": "linux/CVE-2013-6378/CVE-2013-6378_CWE-189_a497e47d4aec37aaf8f13509f3ef3d1f6a717d88_debugfs.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 928,
    "critical_vars": [
      "pdata[cnt]"
    ],
    "function": "lbs_debugfs_write",
    "filename": "linux/CVE-2013-6378/CVE-2013-6378_CWE-189_a497e47d4aec37aaf8f13509f3ef3d1f6a717d88_debugfs.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 713,
    "critical_vars": [
      "dst_state->speculative"
    ],
    "function": "copy_verifier_state",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 758,
    "critical_vars": [
      "speculative"
    ],
    "function": "pop_stack",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 777,
    "critical_vars": [
      "elem->st.speculative"
    ],
    "function": "*push_stack",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Head",
    "line_new": 3073,
    "critical_vars": [
      "*env"
    ],
    "function": "check_reg_sane_offset",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Head",
    "line_new": 3078,
    "critical_vars": [
      "*ptr_reg",
      "off_is_neg",
      "*ptr_limit",
      "opcode"
    ],
    "function": "check_reg_sane_offset",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 3081,
    "critical_vars": [
      "mask_to_left"
    ],
    "function": "check_reg_sane_offset",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 3083,
    "critical_vars": [
      "off"
    ],
    "function": "check_reg_sane_offset",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 3085,
    "critical_vars": [
      "ptr_reg->type"
    ],
    "function": "check_reg_sane_offset",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 3088,
    "critical_vars": [
      "mask_to_left"
    ],
    "function": "check_reg_sane_offset",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 3089,
    "critical_vars": [
      "*ptr_limit"
    ],
    "function": "check_reg_sane_offset",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 3091,
    "critical_vars": [
      "*ptr_limit"
    ],
    "function": "check_reg_sane_offset",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 3095,
    "critical_vars": [
      "*ptr_limit"
    ],
    "function": "check_reg_sane_offset",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 3097,
    "critical_vars": [
      "off"
    ],
    "function": "check_reg_sane_offset",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 3098,
    "critical_vars": [
      "*ptr_limit"
    ],
    "function": "check_reg_sane_offset",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Head",
    "line_new": 3106,
    "critical_vars": [
      "*ptr_reg",
      "off_is_neg",
      "*env",
      "*insn",
      "*dst_reg"
    ],
    "function": "check_reg_sane_offset",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 3112,
    "critical_vars": [
      "*vstate"
    ],
    "function": "check_reg_sane_offset",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 3113,
    "critical_vars": [
      "*aux"
    ],
    "function": "check_reg_sane_offset",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 3114,
    "critical_vars": [
      "ptr_is_dst_reg"
    ],
    "function": "check_reg_sane_offset",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 3115,
    "critical_vars": [
      "opcode"
    ],
    "function": "check_reg_sane_offset",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 3116,
    "critical_vars": [
      "alu_state",
      "alu_limit"
    ],
    "function": "check_reg_sane_offset",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 3117,
    "critical_vars": [
      "tmp"
    ],
    "function": "check_reg_sane_offset",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 3118,
    "critical_vars": [
      "ret"
    ],
    "function": "check_reg_sane_offset",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 3120,
    "critical_vars": [
      "env->allow_ptr_leaks",
      "insn->code"
    ],
    "function": "check_reg_sane_offset",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 3127,
    "critical_vars": [
      "vstate->speculative"
    ],
    "function": "check_reg_sane_offset",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 3130,
    "critical_vars": [
      "alu_state"
    ],
    "function": "check_reg_sane_offset",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 3131,
    "critical_vars": [
      "alu_state"
    ],
    "function": "check_reg_sane_offset",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 3134,
    "critical_vars": [
      "opcode",
      "ptr_reg",
      "&alu_limit",
      "off_is_neg"
    ],
    "function": "check_reg_sane_offset",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 3140,
    "critical_vars": [
      "aux->alu_state",
      "aux->alu_limit"
    ],
    "function": "check_reg_sane_offset",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 3146,
    "critical_vars": [
      "aux->alu_state"
    ],
    "function": "check_reg_sane_offset",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 3147,
    "critical_vars": [
      "aux->alu_limit"
    ],
    "function": "check_reg_sane_offset",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 3149,
    "critical_vars": [
      "ptr_is_dst_reg"
    ],
    "function": "check_reg_sane_offset",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 3160,
    "critical_vars": [
      "tmp"
    ],
    "function": "check_reg_sane_offset",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 3161,
    "critical_vars": [
      "*dst_reg"
    ],
    "function": "check_reg_sane_offset",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 3163,
    "critical_vars": [
      "ret"
    ],
    "function": "check_reg_sane_offset",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 3164,
    "critical_vars": [
      "ptr_is_dst_reg"
    ],
    "function": "check_reg_sane_offset",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 3165,
    "critical_vars": [
      "*dst_reg"
    ],
    "function": "check_reg_sane_offset",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 3189,
    "critical_vars": [
      "ret"
    ],
    "function": "adjust_ptr_min_max_vals",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 3245,
    "critical_vars": [
      "ret"
    ],
    "function": "adjust_ptr_min_max_vals",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 3246,
    "critical_vars": [
      "ret"
    ],
    "function": "adjust_ptr_min_max_vals",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 3247,
    "critical_vars": [
      "dst",
      "env"
    ],
    "function": "adjust_ptr_min_max_vals",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 3300,
    "critical_vars": [
      "ret"
    ],
    "function": "adjust_ptr_min_max_vals",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 3301,
    "critical_vars": [
      "ret"
    ],
    "function": "adjust_ptr_min_max_vals",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 3302,
    "critical_vars": [
      "dst",
      "env"
    ],
    "function": "adjust_ptr_min_max_vals",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 4392,
    "line_new": 4502,
    "critical_vars": [
      "other_branch"
    ],
    "function": "check_cond_jmp_op",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 5616,
    "critical_vars": [
      "cur->speculative",
      "old->speculative"
    ],
    "function": "states_equal",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 5820,
    "critical_vars": [
      "state->speculative"
    ],
    "function": "do_check",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 5860,
    "critical_vars": [
      "env->cur_state->speculative"
    ],
    "function": "do_check",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 5880,
    "critical_vars": [
      "env->cur_state->speculative"
    ],
    "function": "do_check",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 6875,
    "critical_vars": [
      "insn->code"
    ],
    "function": "fixup_bpf_calls",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 6877,
    "critical_vars": [
      "code_add"
    ],
    "function": "fixup_bpf_calls",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 6878,
    "critical_vars": [
      "code_sub"
    ],
    "function": "fixup_bpf_calls",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 6879,
    "critical_vars": [
      "insn_buf"
    ],
    "function": "fixup_bpf_calls",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 6880,
    "critical_vars": [
      "*patch"
    ],
    "function": "fixup_bpf_calls",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 6881,
    "critical_vars": [
      "issrc",
      "isneg"
    ],
    "function": "fixup_bpf_calls",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 6882,
    "critical_vars": [
      "off_reg"
    ],
    "function": "fixup_bpf_calls",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 6884,
    "critical_vars": [
      "aux"
    ],
    "function": "fixup_bpf_calls",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 6885,
    "critical_vars": [
      "aux->alu_state"
    ],
    "function": "fixup_bpf_calls",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 6888,
    "critical_vars": [
      "isneg"
    ],
    "function": "fixup_bpf_calls",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 6889,
    "critical_vars": [
      "issrc"
    ],
    "function": "fixup_bpf_calls",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 6892,
    "critical_vars": [
      "off_reg"
    ],
    "function": "fixup_bpf_calls",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 6893,
    "critical_vars": [
      "isneg"
    ],
    "function": "fixup_bpf_calls",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 6894,
    "critical_vars": [
      "*patch"
    ],
    "function": "fixup_bpf_calls",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 6895,
    "critical_vars": [
      "*patch"
    ],
    "function": "fixup_bpf_calls",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 6896,
    "critical_vars": [
      "*patch"
    ],
    "function": "fixup_bpf_calls",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 6897,
    "critical_vars": [
      "*patch"
    ],
    "function": "fixup_bpf_calls",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 6898,
    "critical_vars": [
      "*patch"
    ],
    "function": "fixup_bpf_calls",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 6899,
    "critical_vars": [
      "*patch"
    ],
    "function": "fixup_bpf_calls",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 6900,
    "critical_vars": [
      "issrc"
    ],
    "function": "fixup_bpf_calls",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 6901,
    "critical_vars": [
      "*patch"
    ],
    "function": "fixup_bpf_calls",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 6903,
    "critical_vars": [
      "insn->src_reg"
    ],
    "function": "fixup_bpf_calls",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 6905,
    "critical_vars": [
      "*patch"
    ],
    "function": "fixup_bpf_calls",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 6908,
    "critical_vars": [
      "isneg"
    ],
    "function": "fixup_bpf_calls",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 6909,
    "critical_vars": [
      "insn->code"
    ],
    "function": "fixup_bpf_calls",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 6911,
    "critical_vars": [
      "*patch"
    ],
    "function": "fixup_bpf_calls",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 6912,
    "critical_vars": [
      "issrc",
      "isneg"
    ],
    "function": "fixup_bpf_calls",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 6913,
    "critical_vars": [
      "*patch"
    ],
    "function": "fixup_bpf_calls",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 6914,
    "critical_vars": [
      "cnt"
    ],
    "function": "fixup_bpf_calls",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 6916,
    "critical_vars": [
      "new_prog"
    ],
    "function": "fixup_bpf_calls",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 6917,
    "critical_vars": [
      "new_prog"
    ],
    "function": "fixup_bpf_calls",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 6920,
    "critical_vars": [
      "delta"
    ],
    "function": "fixup_bpf_calls",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 6921,
    "critical_vars": [
      "env->prog"
    ],
    "function": "fixup_bpf_calls",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 6922,
    "critical_vars": [
      "insn"
    ],
    "function": "fixup_bpf_calls",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_979d63d50c0c0f7bc537bf821e056cc9fe5abd38_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 3106,
    "critical_vars": [
      "bpf_verifier_env",
      "bpf_insn",
      "env",
      "insn"
    ],
    "function": "retrieve_ptr_limit",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_d3bd7413e0ca40b60cf60d4003246d067cafdeda_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Head",
    "line_new": 3112,
    "critical_vars": [
      "alu_state",
      "*aux",
      "alu_limit"
    ],
    "function": "retrieve_ptr_limit",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_d3bd7413e0ca40b60cf60d4003246d067cafdeda_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 3118,
    "critical_vars": [
      "aux->alu_state",
      "aux->alu_limit"
    ],
    "function": "retrieve_ptr_limit",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_d3bd7413e0ca40b60cf60d4003246d067cafdeda_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 3124,
    "critical_vars": [
      "aux->alu_state"
    ],
    "function": "retrieve_ptr_limit",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_d3bd7413e0ca40b60cf60d4003246d067cafdeda_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 3125,
    "critical_vars": [
      "aux->alu_limit"
    ],
    "function": "retrieve_ptr_limit",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_d3bd7413e0ca40b60cf60d4003246d067cafdeda_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Head",
    "line_new": 3129,
    "critical_vars": [
      "*insn",
      "*env"
    ],
    "function": "retrieve_ptr_limit",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_d3bd7413e0ca40b60cf60d4003246d067cafdeda_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 3132,
    "critical_vars": [
      "*aux"
    ],
    "function": "retrieve_ptr_limit",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_d3bd7413e0ca40b60cf60d4003246d067cafdeda_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 3134,
    "critical_vars": [
      "env",
      "insn"
    ],
    "function": "retrieve_ptr_limit",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_d3bd7413e0ca40b60cf60d4003246d067cafdeda_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 3120,
    "critical_vars": [
      "env->allow_ptr_leaks",
      "insn->code"
    ],
    "function": "sanitize_ptr_alu",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_d3bd7413e0ca40b60cf60d4003246d067cafdeda_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 3154,
    "critical_vars": [
      "env",
      "insn"
    ],
    "function": "sanitize_ptr_alu",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_d3bd7413e0ca40b60cf60d4003246d067cafdeda_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 3140,
    "critical_vars": [
      "aux->alu_state",
      "aux->alu_limit"
    ],
    "function": "sanitize_ptr_alu",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_d3bd7413e0ca40b60cf60d4003246d067cafdeda_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 3170,
    "critical_vars": [
      "alu_state",
      "alu_limit",
      "aux"
    ],
    "function": "sanitize_ptr_alu",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_d3bd7413e0ca40b60cf60d4003246d067cafdeda_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 3146,
    "critical_vars": [
      "aux->alu_state"
    ],
    "function": "sanitize_ptr_alu",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_d3bd7413e0ca40b60cf60d4003246d067cafdeda_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 3147,
    "critical_vars": [
      "aux->alu_limit"
    ],
    "function": "sanitize_ptr_alu",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_d3bd7413e0ca40b60cf60d4003246d067cafdeda_verifier.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 3444,
    "critical_vars": [
      "dst"
    ],
    "function": "adjust_scalar_min_max_vals",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_d3bd7413e0ca40b60cf60d4003246d067cafdeda_verifier.c.diff",
    "function_code": "static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,\n\t\t\t\t      struct bpf_insn *insn,\n\t\t\t\t      struct bpf_reg_state *dst_reg,\n\t\t\t\t      struct bpf_reg_state src_reg)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tu8 opcode = BPF_OP(insn->code);\n\tbool src_known, dst_known;\n\ts64 smin_val, smax_val;\n\tu64 umin_val, umax_val;\n\n\tif (BPF_CLASS(insn->code) != BPF_ALU64) {\n\t\t/* 32-bit ALU ops are (32,32)->64 */\n\t\tcoerce_reg_to_32(dst_reg);\n\t\tcoerce_reg_to_32(&src_reg);\n\t}\n\tsmin_val = src_reg.smin_value;\n\tsmax_val = src_reg.smax_value;\n\tumin_val = src_reg.umin_value;\n\tumax_val = src_reg.umax_value;\n\tsrc_known = tnum_is_const(src_reg.var_off);\n\tdst_known = tnum_is_const(dst_reg->var_off);\n\n\tswitch (opcode) {\n\tcase BPF_ADD:\n\t\tif (signed_add_overflows(dst_reg->smin_value, smin_val) ||\n\t\t    signed_add_overflows(dst_reg->smax_value, smax_val)) {\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value += smin_val;\n\t\t\tdst_reg->smax_value += smax_val;\n\t\t}\n\t\tif (dst_reg->umin_value + umin_val < umin_val ||\n\t\t    dst_reg->umax_value + umax_val < umax_val) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value += umin_val;\n\t\t\tdst_reg->umax_value += umax_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_add(dst_reg->var_off, src_reg.var_off);\n\t\tbreak;\n\tcase BPF_SUB:\n\t\tif (signed_sub_overflows(dst_reg->smin_value, smax_val) ||\n\t\t    signed_sub_overflows(dst_reg->smax_value, smin_val)) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value -= smax_val;\n\t\t\tdst_reg->smax_value -= smin_val;\n\t\t}\n\t\tif (dst_reg->umin_value < umax_val) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\t/* Cannot overflow (as long as bounds are consistent) */\n\t\t\tdst_reg->umin_value -= umax_val;\n\t\t\tdst_reg->umax_value -= umin_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_sub(dst_reg->var_off, src_reg.var_off);\n\t\tbreak;\n\tcase BPF_MUL:\n\t\tdst_reg->var_off = tnum_mul(dst_reg->var_off, src_reg.var_off);\n\t\tif (smin_val < 0 || dst_reg->smin_value < 0) {\n\t\t\t/* Ain't nobody got time to multiply that sign */\n\t\t\t__mark_reg_unbounded(dst_reg);\n\t\t\t__update_reg_bounds(dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* Both values are positive, so we can work with unsigned and\n\t\t * copy the result to signed (unless it exceeds S64_MAX).\n\t\t */\n\t\tif (umax_val > U32_MAX || dst_reg->umax_value > U32_MAX) {\n\t\t\t/* Potential overflow, we know nothing */\n\t\t\t__mark_reg_unbounded(dst_reg);\n\t\t\t/* (except what we can learn from the var_off) */\n\t\t\t__update_reg_bounds(dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\tdst_reg->umin_value *= umin_val;\n\t\tdst_reg->umax_value *= umax_val;\n\t\tif (dst_reg->umax_value > S64_MAX) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\tbreak;\n\tcase BPF_AND:\n\t\tif (src_known && dst_known) {\n\t\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value &\n\t\t\t\t\t\t  src_reg.var_off.value);\n\t\t\tbreak;\n\t\t}\n\t\t/* We get our minimum from the var_off, since that's inherently\n\t\t * bitwise.  Our maximum is the minimum of the operands' maxima.\n\t\t */\n\t\tdst_reg->var_off = tnum_and(dst_reg->var_off, src_reg.var_off);\n\t\tdst_reg->umin_value = dst_reg->var_off.value;\n\t\tdst_reg->umax_value = min(dst_reg->umax_value, umax_val);\n\t\tif (dst_reg->smin_value < 0 || smin_val < 0) {\n\t\t\t/* Lose signed bounds when ANDing negative numbers,\n\t\t\t * ain't nobody got time for that.\n\t\t\t */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\t/* ANDing two positives gives a positive, so safe to\n\t\t\t * cast result into s64.\n\t\t\t */\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_OR:\n\t\tif (src_known && dst_known) {\n\t\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value |\n\t\t\t\t\t\t  src_reg.var_off.value);\n\t\t\tbreak;\n\t\t}\n\t\t/* We get our maximum from the var_off, and our minimum is the\n\t\t * maximum of the operands' minima\n\t\t */\n\t\tdst_reg->var_off = tnum_or(dst_reg->var_off, src_reg.var_off);\n\t\tdst_reg->umin_value = max(dst_reg->umin_value, umin_val);\n\t\tdst_reg->umax_value = dst_reg->var_off.value |\n\t\t\t\t      dst_reg->var_off.mask;\n\t\tif (dst_reg->smin_value < 0 || smin_val < 0) {\n\t\t\t/* Lose signed bounds when ORing negative numbers,\n\t\t\t * ain't nobody got time for that.\n\t\t\t */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\t/* ORing two positives gives a positive, so safe to\n\t\t\t * cast result into s64.\n\t\t\t */\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_LSH:\n\t\tif (umax_val > 63) {\n\t\t\t/* Shifts greater than 63 are undefined.  This includes\n\t\t\t * shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* We lose all sign bit information (except what we can pick\n\t\t * up from var_off)\n\t\t */\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t\t/* If we might shift our top bit out, then we know nothing */\n\t\tif (dst_reg->umax_value > 1ULL << (63 - umax_val)) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value <<= umin_val;\n\t\t\tdst_reg->umax_value <<= umax_val;\n\t\t}\n\t\tif (src_known)\n\t\t\tdst_reg->var_off = tnum_lshift(dst_reg->var_off, umin_val);\n\t\telse\n\t\t\tdst_reg->var_off = tnum_lshift(tnum_unknown, umin_val);\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_RSH:\n\t\tif (umax_val > 63) {\n\t\t\t/* Shifts greater than 63 are undefined.  This includes\n\t\t\t * shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* BPF_RSH is an unsigned shift.  If the value in dst_reg might\n\t\t * be negative, then either:\n\t\t * 1) src_reg might be zero, so the sign bit of the result is\n\t\t *    unknown, so we lose our signed bounds\n\t\t * 2) it's known negative, thus the unsigned bounds capture the\n\t\t *    signed bounds\n\t\t * 3) the signed bounds cross zero, so they tell us nothing\n\t\t *    about the result\n\t\t * If the value in dst_reg is known nonnegative, then again the\n\t\t * unsigned bounts capture the signed bounds.\n\t\t * Thus, in all cases it suffices to blow away our signed bounds\n\t\t * and rely on inferring new ones from the unsigned bounds and\n\t\t * var_off of the result.\n\t\t */\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t\tif (src_known)\n\t\t\tdst_reg->var_off = tnum_rshift(dst_reg->var_off,\n\t\t\t\t\t\t       umin_val);\n\t\telse\n\t\t\tdst_reg->var_off = tnum_rshift(tnum_unknown, umin_val);\n\t\tdst_reg->umin_value >>= umax_val;\n\t\tdst_reg->umax_value >>= umin_val;\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tdefault:\n\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\tbreak;\n\t}\n\n\t__reg_deduce_bounds(dst_reg);\n\t__reg_bound_offset(dst_reg);\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 3445,
    "critical_vars": [
      "ret"
    ],
    "function": "adjust_scalar_min_max_vals",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_d3bd7413e0ca40b60cf60d4003246d067cafdeda_verifier.c.diff",
    "function_code": "static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,\n\t\t\t\t      struct bpf_insn *insn,\n\t\t\t\t      struct bpf_reg_state *dst_reg,\n\t\t\t\t      struct bpf_reg_state src_reg)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tu8 opcode = BPF_OP(insn->code);\n\tbool src_known, dst_known;\n\ts64 smin_val, smax_val;\n\tu64 umin_val, umax_val;\n\n\tif (BPF_CLASS(insn->code) != BPF_ALU64) {\n\t\t/* 32-bit ALU ops are (32,32)->64 */\n\t\tcoerce_reg_to_32(dst_reg);\n\t\tcoerce_reg_to_32(&src_reg);\n\t}\n\tsmin_val = src_reg.smin_value;\n\tsmax_val = src_reg.smax_value;\n\tumin_val = src_reg.umin_value;\n\tumax_val = src_reg.umax_value;\n\tsrc_known = tnum_is_const(src_reg.var_off);\n\tdst_known = tnum_is_const(dst_reg->var_off);\n\n\tswitch (opcode) {\n\tcase BPF_ADD:\n\t\tif (signed_add_overflows(dst_reg->smin_value, smin_val) ||\n\t\t    signed_add_overflows(dst_reg->smax_value, smax_val)) {\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value += smin_val;\n\t\t\tdst_reg->smax_value += smax_val;\n\t\t}\n\t\tif (dst_reg->umin_value + umin_val < umin_val ||\n\t\t    dst_reg->umax_value + umax_val < umax_val) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value += umin_val;\n\t\t\tdst_reg->umax_value += umax_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_add(dst_reg->var_off, src_reg.var_off);\n\t\tbreak;\n\tcase BPF_SUB:\n\t\tif (signed_sub_overflows(dst_reg->smin_value, smax_val) ||\n\t\t    signed_sub_overflows(dst_reg->smax_value, smin_val)) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value -= smax_val;\n\t\t\tdst_reg->smax_value -= smin_val;\n\t\t}\n\t\tif (dst_reg->umin_value < umax_val) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\t/* Cannot overflow (as long as bounds are consistent) */\n\t\t\tdst_reg->umin_value -= umax_val;\n\t\t\tdst_reg->umax_value -= umin_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_sub(dst_reg->var_off, src_reg.var_off);\n\t\tbreak;\n\tcase BPF_MUL:\n\t\tdst_reg->var_off = tnum_mul(dst_reg->var_off, src_reg.var_off);\n\t\tif (smin_val < 0 || dst_reg->smin_value < 0) {\n\t\t\t/* Ain't nobody got time to multiply that sign */\n\t\t\t__mark_reg_unbounded(dst_reg);\n\t\t\t__update_reg_bounds(dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* Both values are positive, so we can work with unsigned and\n\t\t * copy the result to signed (unless it exceeds S64_MAX).\n\t\t */\n\t\tif (umax_val > U32_MAX || dst_reg->umax_value > U32_MAX) {\n\t\t\t/* Potential overflow, we know nothing */\n\t\t\t__mark_reg_unbounded(dst_reg);\n\t\t\t/* (except what we can learn from the var_off) */\n\t\t\t__update_reg_bounds(dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\tdst_reg->umin_value *= umin_val;\n\t\tdst_reg->umax_value *= umax_val;\n\t\tif (dst_reg->umax_value > S64_MAX) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\tbreak;\n\tcase BPF_AND:\n\t\tif (src_known && dst_known) {\n\t\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value &\n\t\t\t\t\t\t  src_reg.var_off.value);\n\t\t\tbreak;\n\t\t}\n\t\t/* We get our minimum from the var_off, since that's inherently\n\t\t * bitwise.  Our maximum is the minimum of the operands' maxima.\n\t\t */\n\t\tdst_reg->var_off = tnum_and(dst_reg->var_off, src_reg.var_off);\n\t\tdst_reg->umin_value = dst_reg->var_off.value;\n\t\tdst_reg->umax_value = min(dst_reg->umax_value, umax_val);\n\t\tif (dst_reg->smin_value < 0 || smin_val < 0) {\n\t\t\t/* Lose signed bounds when ANDing negative numbers,\n\t\t\t * ain't nobody got time for that.\n\t\t\t */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\t/* ANDing two positives gives a positive, so safe to\n\t\t\t * cast result into s64.\n\t\t\t */\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_OR:\n\t\tif (src_known && dst_known) {\n\t\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value |\n\t\t\t\t\t\t  src_reg.var_off.value);\n\t\t\tbreak;\n\t\t}\n\t\t/* We get our maximum from the var_off, and our minimum is the\n\t\t * maximum of the operands' minima\n\t\t */\n\t\tdst_reg->var_off = tnum_or(dst_reg->var_off, src_reg.var_off);\n\t\tdst_reg->umin_value = max(dst_reg->umin_value, umin_val);\n\t\tdst_reg->umax_value = dst_reg->var_off.value |\n\t\t\t\t      dst_reg->var_off.mask;\n\t\tif (dst_reg->smin_value < 0 || smin_val < 0) {\n\t\t\t/* Lose signed bounds when ORing negative numbers,\n\t\t\t * ain't nobody got time for that.\n\t\t\t */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\t/* ORing two positives gives a positive, so safe to\n\t\t\t * cast result into s64.\n\t\t\t */\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_LSH:\n\t\tif (umax_val > 63) {\n\t\t\t/* Shifts greater than 63 are undefined.  This includes\n\t\t\t * shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* We lose all sign bit information (except what we can pick\n\t\t * up from var_off)\n\t\t */\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t\t/* If we might shift our top bit out, then we know nothing */\n\t\tif (dst_reg->umax_value > 1ULL << (63 - umax_val)) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value <<= umin_val;\n\t\t\tdst_reg->umax_value <<= umax_val;\n\t\t}\n\t\tif (src_known)\n\t\t\tdst_reg->var_off = tnum_lshift(dst_reg->var_off, umin_val);\n\t\telse\n\t\t\tdst_reg->var_off = tnum_lshift(tnum_unknown, umin_val);\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_RSH:\n\t\tif (umax_val > 63) {\n\t\t\t/* Shifts greater than 63 are undefined.  This includes\n\t\t\t * shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* BPF_RSH is an unsigned shift.  If the value in dst_reg might\n\t\t * be negative, then either:\n\t\t * 1) src_reg might be zero, so the sign bit of the result is\n\t\t *    unknown, so we lose our signed bounds\n\t\t * 2) it's known negative, thus the unsigned bounds capture the\n\t\t *    signed bounds\n\t\t * 3) the signed bounds cross zero, so they tell us nothing\n\t\t *    about the result\n\t\t * If the value in dst_reg is known nonnegative, then again the\n\t\t * unsigned bounts capture the signed bounds.\n\t\t * Thus, in all cases it suffices to blow away our signed bounds\n\t\t * and rely on inferring new ones from the unsigned bounds and\n\t\t * var_off of the result.\n\t\t */\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t\tif (src_known)\n\t\t\tdst_reg->var_off = tnum_rshift(dst_reg->var_off,\n\t\t\t\t\t\t       umin_val);\n\t\telse\n\t\t\tdst_reg->var_off = tnum_rshift(tnum_unknown, umin_val);\n\t\tdst_reg->umin_value >>= umax_val;\n\t\tdst_reg->umax_value >>= umin_val;\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tdefault:\n\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\tbreak;\n\t}\n\n\t__reg_deduce_bounds(dst_reg);\n\t__reg_bound_offset(dst_reg);\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 3480,
    "critical_vars": [
      "ret"
    ],
    "function": "adjust_scalar_min_max_vals",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_d3bd7413e0ca40b60cf60d4003246d067cafdeda_verifier.c.diff",
    "function_code": "static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,\n\t\t\t\t      struct bpf_insn *insn,\n\t\t\t\t      struct bpf_reg_state *dst_reg,\n\t\t\t\t      struct bpf_reg_state src_reg)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tu8 opcode = BPF_OP(insn->code);\n\tbool src_known, dst_known;\n\ts64 smin_val, smax_val;\n\tu64 umin_val, umax_val;\n\n\tif (BPF_CLASS(insn->code) != BPF_ALU64) {\n\t\t/* 32-bit ALU ops are (32,32)->64 */\n\t\tcoerce_reg_to_32(dst_reg);\n\t\tcoerce_reg_to_32(&src_reg);\n\t}\n\tsmin_val = src_reg.smin_value;\n\tsmax_val = src_reg.smax_value;\n\tumin_val = src_reg.umin_value;\n\tumax_val = src_reg.umax_value;\n\tsrc_known = tnum_is_const(src_reg.var_off);\n\tdst_known = tnum_is_const(dst_reg->var_off);\n\n\tswitch (opcode) {\n\tcase BPF_ADD:\n\t\tif (signed_add_overflows(dst_reg->smin_value, smin_val) ||\n\t\t    signed_add_overflows(dst_reg->smax_value, smax_val)) {\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value += smin_val;\n\t\t\tdst_reg->smax_value += smax_val;\n\t\t}\n\t\tif (dst_reg->umin_value + umin_val < umin_val ||\n\t\t    dst_reg->umax_value + umax_val < umax_val) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value += umin_val;\n\t\t\tdst_reg->umax_value += umax_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_add(dst_reg->var_off, src_reg.var_off);\n\t\tbreak;\n\tcase BPF_SUB:\n\t\tif (signed_sub_overflows(dst_reg->smin_value, smax_val) ||\n\t\t    signed_sub_overflows(dst_reg->smax_value, smin_val)) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value -= smax_val;\n\t\t\tdst_reg->smax_value -= smin_val;\n\t\t}\n\t\tif (dst_reg->umin_value < umax_val) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\t/* Cannot overflow (as long as bounds are consistent) */\n\t\t\tdst_reg->umin_value -= umax_val;\n\t\t\tdst_reg->umax_value -= umin_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_sub(dst_reg->var_off, src_reg.var_off);\n\t\tbreak;\n\tcase BPF_MUL:\n\t\tdst_reg->var_off = tnum_mul(dst_reg->var_off, src_reg.var_off);\n\t\tif (smin_val < 0 || dst_reg->smin_value < 0) {\n\t\t\t/* Ain't nobody got time to multiply that sign */\n\t\t\t__mark_reg_unbounded(dst_reg);\n\t\t\t__update_reg_bounds(dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* Both values are positive, so we can work with unsigned and\n\t\t * copy the result to signed (unless it exceeds S64_MAX).\n\t\t */\n\t\tif (umax_val > U32_MAX || dst_reg->umax_value > U32_MAX) {\n\t\t\t/* Potential overflow, we know nothing */\n\t\t\t__mark_reg_unbounded(dst_reg);\n\t\t\t/* (except what we can learn from the var_off) */\n\t\t\t__update_reg_bounds(dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\tdst_reg->umin_value *= umin_val;\n\t\tdst_reg->umax_value *= umax_val;\n\t\tif (dst_reg->umax_value > S64_MAX) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\tbreak;\n\tcase BPF_AND:\n\t\tif (src_known && dst_known) {\n\t\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value &\n\t\t\t\t\t\t  src_reg.var_off.value);\n\t\t\tbreak;\n\t\t}\n\t\t/* We get our minimum from the var_off, since that's inherently\n\t\t * bitwise.  Our maximum is the minimum of the operands' maxima.\n\t\t */\n\t\tdst_reg->var_off = tnum_and(dst_reg->var_off, src_reg.var_off);\n\t\tdst_reg->umin_value = dst_reg->var_off.value;\n\t\tdst_reg->umax_value = min(dst_reg->umax_value, umax_val);\n\t\tif (dst_reg->smin_value < 0 || smin_val < 0) {\n\t\t\t/* Lose signed bounds when ANDing negative numbers,\n\t\t\t * ain't nobody got time for that.\n\t\t\t */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\t/* ANDing two positives gives a positive, so safe to\n\t\t\t * cast result into s64.\n\t\t\t */\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_OR:\n\t\tif (src_known && dst_known) {\n\t\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value |\n\t\t\t\t\t\t  src_reg.var_off.value);\n\t\t\tbreak;\n\t\t}\n\t\t/* We get our maximum from the var_off, and our minimum is the\n\t\t * maximum of the operands' minima\n\t\t */\n\t\tdst_reg->var_off = tnum_or(dst_reg->var_off, src_reg.var_off);\n\t\tdst_reg->umin_value = max(dst_reg->umin_value, umin_val);\n\t\tdst_reg->umax_value = dst_reg->var_off.value |\n\t\t\t\t      dst_reg->var_off.mask;\n\t\tif (dst_reg->smin_value < 0 || smin_val < 0) {\n\t\t\t/* Lose signed bounds when ORing negative numbers,\n\t\t\t * ain't nobody got time for that.\n\t\t\t */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\t/* ORing two positives gives a positive, so safe to\n\t\t\t * cast result into s64.\n\t\t\t */\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_LSH:\n\t\tif (umax_val > 63) {\n\t\t\t/* Shifts greater than 63 are undefined.  This includes\n\t\t\t * shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* We lose all sign bit information (except what we can pick\n\t\t * up from var_off)\n\t\t */\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t\t/* If we might shift our top bit out, then we know nothing */\n\t\tif (dst_reg->umax_value > 1ULL << (63 - umax_val)) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value <<= umin_val;\n\t\t\tdst_reg->umax_value <<= umax_val;\n\t\t}\n\t\tif (src_known)\n\t\t\tdst_reg->var_off = tnum_lshift(dst_reg->var_off, umin_val);\n\t\telse\n\t\t\tdst_reg->var_off = tnum_lshift(tnum_unknown, umin_val);\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_RSH:\n\t\tif (umax_val > 63) {\n\t\t\t/* Shifts greater than 63 are undefined.  This includes\n\t\t\t * shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* BPF_RSH is an unsigned shift.  If the value in dst_reg might\n\t\t * be negative, then either:\n\t\t * 1) src_reg might be zero, so the sign bit of the result is\n\t\t *    unknown, so we lose our signed bounds\n\t\t * 2) it's known negative, thus the unsigned bounds capture the\n\t\t *    signed bounds\n\t\t * 3) the signed bounds cross zero, so they tell us nothing\n\t\t *    about the result\n\t\t * If the value in dst_reg is known nonnegative, then again the\n\t\t * unsigned bounts capture the signed bounds.\n\t\t * Thus, in all cases it suffices to blow away our signed bounds\n\t\t * and rely on inferring new ones from the unsigned bounds and\n\t\t * var_off of the result.\n\t\t */\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t\tif (src_known)\n\t\t\tdst_reg->var_off = tnum_rshift(dst_reg->var_off,\n\t\t\t\t\t\t       umin_val);\n\t\telse\n\t\t\tdst_reg->var_off = tnum_rshift(tnum_unknown, umin_val);\n\t\tdst_reg->umin_value >>= umax_val;\n\t\tdst_reg->umax_value >>= umin_val;\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tdefault:\n\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\tbreak;\n\t}\n\n\t__reg_deduce_bounds(dst_reg);\n\t__reg_bound_offset(dst_reg);\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 3481,
    "critical_vars": [
      "ret"
    ],
    "function": "adjust_scalar_min_max_vals",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_d3bd7413e0ca40b60cf60d4003246d067cafdeda_verifier.c.diff",
    "function_code": "static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,\n\t\t\t\t      struct bpf_insn *insn,\n\t\t\t\t      struct bpf_reg_state *dst_reg,\n\t\t\t\t      struct bpf_reg_state src_reg)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tu8 opcode = BPF_OP(insn->code);\n\tbool src_known, dst_known;\n\ts64 smin_val, smax_val;\n\tu64 umin_val, umax_val;\n\n\tif (BPF_CLASS(insn->code) != BPF_ALU64) {\n\t\t/* 32-bit ALU ops are (32,32)->64 */\n\t\tcoerce_reg_to_32(dst_reg);\n\t\tcoerce_reg_to_32(&src_reg);\n\t}\n\tsmin_val = src_reg.smin_value;\n\tsmax_val = src_reg.smax_value;\n\tumin_val = src_reg.umin_value;\n\tumax_val = src_reg.umax_value;\n\tsrc_known = tnum_is_const(src_reg.var_off);\n\tdst_known = tnum_is_const(dst_reg->var_off);\n\n\tswitch (opcode) {\n\tcase BPF_ADD:\n\t\tif (signed_add_overflows(dst_reg->smin_value, smin_val) ||\n\t\t    signed_add_overflows(dst_reg->smax_value, smax_val)) {\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value += smin_val;\n\t\t\tdst_reg->smax_value += smax_val;\n\t\t}\n\t\tif (dst_reg->umin_value + umin_val < umin_val ||\n\t\t    dst_reg->umax_value + umax_val < umax_val) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value += umin_val;\n\t\t\tdst_reg->umax_value += umax_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_add(dst_reg->var_off, src_reg.var_off);\n\t\tbreak;\n\tcase BPF_SUB:\n\t\tif (signed_sub_overflows(dst_reg->smin_value, smax_val) ||\n\t\t    signed_sub_overflows(dst_reg->smax_value, smin_val)) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value -= smax_val;\n\t\t\tdst_reg->smax_value -= smin_val;\n\t\t}\n\t\tif (dst_reg->umin_value < umax_val) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\t/* Cannot overflow (as long as bounds are consistent) */\n\t\t\tdst_reg->umin_value -= umax_val;\n\t\t\tdst_reg->umax_value -= umin_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_sub(dst_reg->var_off, src_reg.var_off);\n\t\tbreak;\n\tcase BPF_MUL:\n\t\tdst_reg->var_off = tnum_mul(dst_reg->var_off, src_reg.var_off);\n\t\tif (smin_val < 0 || dst_reg->smin_value < 0) {\n\t\t\t/* Ain't nobody got time to multiply that sign */\n\t\t\t__mark_reg_unbounded(dst_reg);\n\t\t\t__update_reg_bounds(dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* Both values are positive, so we can work with unsigned and\n\t\t * copy the result to signed (unless it exceeds S64_MAX).\n\t\t */\n\t\tif (umax_val > U32_MAX || dst_reg->umax_value > U32_MAX) {\n\t\t\t/* Potential overflow, we know nothing */\n\t\t\t__mark_reg_unbounded(dst_reg);\n\t\t\t/* (except what we can learn from the var_off) */\n\t\t\t__update_reg_bounds(dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\tdst_reg->umin_value *= umin_val;\n\t\tdst_reg->umax_value *= umax_val;\n\t\tif (dst_reg->umax_value > S64_MAX) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\tbreak;\n\tcase BPF_AND:\n\t\tif (src_known && dst_known) {\n\t\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value &\n\t\t\t\t\t\t  src_reg.var_off.value);\n\t\t\tbreak;\n\t\t}\n\t\t/* We get our minimum from the var_off, since that's inherently\n\t\t * bitwise.  Our maximum is the minimum of the operands' maxima.\n\t\t */\n\t\tdst_reg->var_off = tnum_and(dst_reg->var_off, src_reg.var_off);\n\t\tdst_reg->umin_value = dst_reg->var_off.value;\n\t\tdst_reg->umax_value = min(dst_reg->umax_value, umax_val);\n\t\tif (dst_reg->smin_value < 0 || smin_val < 0) {\n\t\t\t/* Lose signed bounds when ANDing negative numbers,\n\t\t\t * ain't nobody got time for that.\n\t\t\t */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\t/* ANDing two positives gives a positive, so safe to\n\t\t\t * cast result into s64.\n\t\t\t */\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_OR:\n\t\tif (src_known && dst_known) {\n\t\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value |\n\t\t\t\t\t\t  src_reg.var_off.value);\n\t\t\tbreak;\n\t\t}\n\t\t/* We get our maximum from the var_off, and our minimum is the\n\t\t * maximum of the operands' minima\n\t\t */\n\t\tdst_reg->var_off = tnum_or(dst_reg->var_off, src_reg.var_off);\n\t\tdst_reg->umin_value = max(dst_reg->umin_value, umin_val);\n\t\tdst_reg->umax_value = dst_reg->var_off.value |\n\t\t\t\t      dst_reg->var_off.mask;\n\t\tif (dst_reg->smin_value < 0 || smin_val < 0) {\n\t\t\t/* Lose signed bounds when ORing negative numbers,\n\t\t\t * ain't nobody got time for that.\n\t\t\t */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\t/* ORing two positives gives a positive, so safe to\n\t\t\t * cast result into s64.\n\t\t\t */\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_LSH:\n\t\tif (umax_val > 63) {\n\t\t\t/* Shifts greater than 63 are undefined.  This includes\n\t\t\t * shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* We lose all sign bit information (except what we can pick\n\t\t * up from var_off)\n\t\t */\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t\t/* If we might shift our top bit out, then we know nothing */\n\t\tif (dst_reg->umax_value > 1ULL << (63 - umax_val)) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value <<= umin_val;\n\t\t\tdst_reg->umax_value <<= umax_val;\n\t\t}\n\t\tif (src_known)\n\t\t\tdst_reg->var_off = tnum_lshift(dst_reg->var_off, umin_val);\n\t\telse\n\t\t\tdst_reg->var_off = tnum_lshift(tnum_unknown, umin_val);\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_RSH:\n\t\tif (umax_val > 63) {\n\t\t\t/* Shifts greater than 63 are undefined.  This includes\n\t\t\t * shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* BPF_RSH is an unsigned shift.  If the value in dst_reg might\n\t\t * be negative, then either:\n\t\t * 1) src_reg might be zero, so the sign bit of the result is\n\t\t *    unknown, so we lose our signed bounds\n\t\t * 2) it's known negative, thus the unsigned bounds capture the\n\t\t *    signed bounds\n\t\t * 3) the signed bounds cross zero, so they tell us nothing\n\t\t *    about the result\n\t\t * If the value in dst_reg is known nonnegative, then again the\n\t\t * unsigned bounts capture the signed bounds.\n\t\t * Thus, in all cases it suffices to blow away our signed bounds\n\t\t * and rely on inferring new ones from the unsigned bounds and\n\t\t * var_off of the result.\n\t\t */\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t\tif (src_known)\n\t\t\tdst_reg->var_off = tnum_rshift(dst_reg->var_off,\n\t\t\t\t\t\t       umin_val);\n\t\telse\n\t\t\tdst_reg->var_off = tnum_rshift(tnum_unknown, umin_val);\n\t\tdst_reg->umin_value >>= umax_val;\n\t\tdst_reg->umax_value >>= umin_val;\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tdefault:\n\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\tbreak;\n\t}\n\n\t__reg_deduce_bounds(dst_reg);\n\t__reg_bound_offset(dst_reg);\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 3482,
    "critical_vars": [
      "dst",
      "env"
    ],
    "function": "adjust_scalar_min_max_vals",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_d3bd7413e0ca40b60cf60d4003246d067cafdeda_verifier.c.diff",
    "function_code": "static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,\n\t\t\t\t      struct bpf_insn *insn,\n\t\t\t\t      struct bpf_reg_state *dst_reg,\n\t\t\t\t      struct bpf_reg_state src_reg)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tu8 opcode = BPF_OP(insn->code);\n\tbool src_known, dst_known;\n\ts64 smin_val, smax_val;\n\tu64 umin_val, umax_val;\n\n\tif (BPF_CLASS(insn->code) != BPF_ALU64) {\n\t\t/* 32-bit ALU ops are (32,32)->64 */\n\t\tcoerce_reg_to_32(dst_reg);\n\t\tcoerce_reg_to_32(&src_reg);\n\t}\n\tsmin_val = src_reg.smin_value;\n\tsmax_val = src_reg.smax_value;\n\tumin_val = src_reg.umin_value;\n\tumax_val = src_reg.umax_value;\n\tsrc_known = tnum_is_const(src_reg.var_off);\n\tdst_known = tnum_is_const(dst_reg->var_off);\n\n\tswitch (opcode) {\n\tcase BPF_ADD:\n\t\tif (signed_add_overflows(dst_reg->smin_value, smin_val) ||\n\t\t    signed_add_overflows(dst_reg->smax_value, smax_val)) {\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value += smin_val;\n\t\t\tdst_reg->smax_value += smax_val;\n\t\t}\n\t\tif (dst_reg->umin_value + umin_val < umin_val ||\n\t\t    dst_reg->umax_value + umax_val < umax_val) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value += umin_val;\n\t\t\tdst_reg->umax_value += umax_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_add(dst_reg->var_off, src_reg.var_off);\n\t\tbreak;\n\tcase BPF_SUB:\n\t\tif (signed_sub_overflows(dst_reg->smin_value, smax_val) ||\n\t\t    signed_sub_overflows(dst_reg->smax_value, smin_val)) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value -= smax_val;\n\t\t\tdst_reg->smax_value -= smin_val;\n\t\t}\n\t\tif (dst_reg->umin_value < umax_val) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\t/* Cannot overflow (as long as bounds are consistent) */\n\t\t\tdst_reg->umin_value -= umax_val;\n\t\t\tdst_reg->umax_value -= umin_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_sub(dst_reg->var_off, src_reg.var_off);\n\t\tbreak;\n\tcase BPF_MUL:\n\t\tdst_reg->var_off = tnum_mul(dst_reg->var_off, src_reg.var_off);\n\t\tif (smin_val < 0 || dst_reg->smin_value < 0) {\n\t\t\t/* Ain't nobody got time to multiply that sign */\n\t\t\t__mark_reg_unbounded(dst_reg);\n\t\t\t__update_reg_bounds(dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* Both values are positive, so we can work with unsigned and\n\t\t * copy the result to signed (unless it exceeds S64_MAX).\n\t\t */\n\t\tif (umax_val > U32_MAX || dst_reg->umax_value > U32_MAX) {\n\t\t\t/* Potential overflow, we know nothing */\n\t\t\t__mark_reg_unbounded(dst_reg);\n\t\t\t/* (except what we can learn from the var_off) */\n\t\t\t__update_reg_bounds(dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\tdst_reg->umin_value *= umin_val;\n\t\tdst_reg->umax_value *= umax_val;\n\t\tif (dst_reg->umax_value > S64_MAX) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\tbreak;\n\tcase BPF_AND:\n\t\tif (src_known && dst_known) {\n\t\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value &\n\t\t\t\t\t\t  src_reg.var_off.value);\n\t\t\tbreak;\n\t\t}\n\t\t/* We get our minimum from the var_off, since that's inherently\n\t\t * bitwise.  Our maximum is the minimum of the operands' maxima.\n\t\t */\n\t\tdst_reg->var_off = tnum_and(dst_reg->var_off, src_reg.var_off);\n\t\tdst_reg->umin_value = dst_reg->var_off.value;\n\t\tdst_reg->umax_value = min(dst_reg->umax_value, umax_val);\n\t\tif (dst_reg->smin_value < 0 || smin_val < 0) {\n\t\t\t/* Lose signed bounds when ANDing negative numbers,\n\t\t\t * ain't nobody got time for that.\n\t\t\t */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\t/* ANDing two positives gives a positive, so safe to\n\t\t\t * cast result into s64.\n\t\t\t */\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_OR:\n\t\tif (src_known && dst_known) {\n\t\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value |\n\t\t\t\t\t\t  src_reg.var_off.value);\n\t\t\tbreak;\n\t\t}\n\t\t/* We get our maximum from the var_off, and our minimum is the\n\t\t * maximum of the operands' minima\n\t\t */\n\t\tdst_reg->var_off = tnum_or(dst_reg->var_off, src_reg.var_off);\n\t\tdst_reg->umin_value = max(dst_reg->umin_value, umin_val);\n\t\tdst_reg->umax_value = dst_reg->var_off.value |\n\t\t\t\t      dst_reg->var_off.mask;\n\t\tif (dst_reg->smin_value < 0 || smin_val < 0) {\n\t\t\t/* Lose signed bounds when ORing negative numbers,\n\t\t\t * ain't nobody got time for that.\n\t\t\t */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\t/* ORing two positives gives a positive, so safe to\n\t\t\t * cast result into s64.\n\t\t\t */\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_LSH:\n\t\tif (umax_val > 63) {\n\t\t\t/* Shifts greater than 63 are undefined.  This includes\n\t\t\t * shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* We lose all sign bit information (except what we can pick\n\t\t * up from var_off)\n\t\t */\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t\t/* If we might shift our top bit out, then we know nothing */\n\t\tif (dst_reg->umax_value > 1ULL << (63 - umax_val)) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value <<= umin_val;\n\t\t\tdst_reg->umax_value <<= umax_val;\n\t\t}\n\t\tif (src_known)\n\t\t\tdst_reg->var_off = tnum_lshift(dst_reg->var_off, umin_val);\n\t\telse\n\t\t\tdst_reg->var_off = tnum_lshift(tnum_unknown, umin_val);\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_RSH:\n\t\tif (umax_val > 63) {\n\t\t\t/* Shifts greater than 63 are undefined.  This includes\n\t\t\t * shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* BPF_RSH is an unsigned shift.  If the value in dst_reg might\n\t\t * be negative, then either:\n\t\t * 1) src_reg might be zero, so the sign bit of the result is\n\t\t *    unknown, so we lose our signed bounds\n\t\t * 2) it's known negative, thus the unsigned bounds capture the\n\t\t *    signed bounds\n\t\t * 3) the signed bounds cross zero, so they tell us nothing\n\t\t *    about the result\n\t\t * If the value in dst_reg is known nonnegative, then again the\n\t\t * unsigned bounts capture the signed bounds.\n\t\t * Thus, in all cases it suffices to blow away our signed bounds\n\t\t * and rely on inferring new ones from the unsigned bounds and\n\t\t * var_off of the result.\n\t\t */\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t\tif (src_known)\n\t\t\tdst_reg->var_off = tnum_rshift(dst_reg->var_off,\n\t\t\t\t\t\t       umin_val);\n\t\telse\n\t\t\tdst_reg->var_off = tnum_rshift(tnum_unknown, umin_val);\n\t\tdst_reg->umin_value >>= umax_val;\n\t\tdst_reg->umax_value >>= umin_val;\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tdefault:\n\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\tbreak;\n\t}\n\n\t__reg_deduce_bounds(dst_reg);\n\t__reg_bound_offset(dst_reg);\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 3504,
    "critical_vars": [
      "ret"
    ],
    "function": "adjust_scalar_min_max_vals",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_d3bd7413e0ca40b60cf60d4003246d067cafdeda_verifier.c.diff",
    "function_code": "static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,\n\t\t\t\t      struct bpf_insn *insn,\n\t\t\t\t      struct bpf_reg_state *dst_reg,\n\t\t\t\t      struct bpf_reg_state src_reg)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tu8 opcode = BPF_OP(insn->code);\n\tbool src_known, dst_known;\n\ts64 smin_val, smax_val;\n\tu64 umin_val, umax_val;\n\n\tif (BPF_CLASS(insn->code) != BPF_ALU64) {\n\t\t/* 32-bit ALU ops are (32,32)->64 */\n\t\tcoerce_reg_to_32(dst_reg);\n\t\tcoerce_reg_to_32(&src_reg);\n\t}\n\tsmin_val = src_reg.smin_value;\n\tsmax_val = src_reg.smax_value;\n\tumin_val = src_reg.umin_value;\n\tumax_val = src_reg.umax_value;\n\tsrc_known = tnum_is_const(src_reg.var_off);\n\tdst_known = tnum_is_const(dst_reg->var_off);\n\n\tswitch (opcode) {\n\tcase BPF_ADD:\n\t\tif (signed_add_overflows(dst_reg->smin_value, smin_val) ||\n\t\t    signed_add_overflows(dst_reg->smax_value, smax_val)) {\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value += smin_val;\n\t\t\tdst_reg->smax_value += smax_val;\n\t\t}\n\t\tif (dst_reg->umin_value + umin_val < umin_val ||\n\t\t    dst_reg->umax_value + umax_val < umax_val) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value += umin_val;\n\t\t\tdst_reg->umax_value += umax_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_add(dst_reg->var_off, src_reg.var_off);\n\t\tbreak;\n\tcase BPF_SUB:\n\t\tif (signed_sub_overflows(dst_reg->smin_value, smax_val) ||\n\t\t    signed_sub_overflows(dst_reg->smax_value, smin_val)) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value -= smax_val;\n\t\t\tdst_reg->smax_value -= smin_val;\n\t\t}\n\t\tif (dst_reg->umin_value < umax_val) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\t/* Cannot overflow (as long as bounds are consistent) */\n\t\t\tdst_reg->umin_value -= umax_val;\n\t\t\tdst_reg->umax_value -= umin_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_sub(dst_reg->var_off, src_reg.var_off);\n\t\tbreak;\n\tcase BPF_MUL:\n\t\tdst_reg->var_off = tnum_mul(dst_reg->var_off, src_reg.var_off);\n\t\tif (smin_val < 0 || dst_reg->smin_value < 0) {\n\t\t\t/* Ain't nobody got time to multiply that sign */\n\t\t\t__mark_reg_unbounded(dst_reg);\n\t\t\t__update_reg_bounds(dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* Both values are positive, so we can work with unsigned and\n\t\t * copy the result to signed (unless it exceeds S64_MAX).\n\t\t */\n\t\tif (umax_val > U32_MAX || dst_reg->umax_value > U32_MAX) {\n\t\t\t/* Potential overflow, we know nothing */\n\t\t\t__mark_reg_unbounded(dst_reg);\n\t\t\t/* (except what we can learn from the var_off) */\n\t\t\t__update_reg_bounds(dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\tdst_reg->umin_value *= umin_val;\n\t\tdst_reg->umax_value *= umax_val;\n\t\tif (dst_reg->umax_value > S64_MAX) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\tbreak;\n\tcase BPF_AND:\n\t\tif (src_known && dst_known) {\n\t\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value &\n\t\t\t\t\t\t  src_reg.var_off.value);\n\t\t\tbreak;\n\t\t}\n\t\t/* We get our minimum from the var_off, since that's inherently\n\t\t * bitwise.  Our maximum is the minimum of the operands' maxima.\n\t\t */\n\t\tdst_reg->var_off = tnum_and(dst_reg->var_off, src_reg.var_off);\n\t\tdst_reg->umin_value = dst_reg->var_off.value;\n\t\tdst_reg->umax_value = min(dst_reg->umax_value, umax_val);\n\t\tif (dst_reg->smin_value < 0 || smin_val < 0) {\n\t\t\t/* Lose signed bounds when ANDing negative numbers,\n\t\t\t * ain't nobody got time for that.\n\t\t\t */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\t/* ANDing two positives gives a positive, so safe to\n\t\t\t * cast result into s64.\n\t\t\t */\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_OR:\n\t\tif (src_known && dst_known) {\n\t\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value |\n\t\t\t\t\t\t  src_reg.var_off.value);\n\t\t\tbreak;\n\t\t}\n\t\t/* We get our maximum from the var_off, and our minimum is the\n\t\t * maximum of the operands' minima\n\t\t */\n\t\tdst_reg->var_off = tnum_or(dst_reg->var_off, src_reg.var_off);\n\t\tdst_reg->umin_value = max(dst_reg->umin_value, umin_val);\n\t\tdst_reg->umax_value = dst_reg->var_off.value |\n\t\t\t\t      dst_reg->var_off.mask;\n\t\tif (dst_reg->smin_value < 0 || smin_val < 0) {\n\t\t\t/* Lose signed bounds when ORing negative numbers,\n\t\t\t * ain't nobody got time for that.\n\t\t\t */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\t/* ORing two positives gives a positive, so safe to\n\t\t\t * cast result into s64.\n\t\t\t */\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_LSH:\n\t\tif (umax_val > 63) {\n\t\t\t/* Shifts greater than 63 are undefined.  This includes\n\t\t\t * shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* We lose all sign bit information (except what we can pick\n\t\t * up from var_off)\n\t\t */\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t\t/* If we might shift our top bit out, then we know nothing */\n\t\tif (dst_reg->umax_value > 1ULL << (63 - umax_val)) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value <<= umin_val;\n\t\t\tdst_reg->umax_value <<= umax_val;\n\t\t}\n\t\tif (src_known)\n\t\t\tdst_reg->var_off = tnum_lshift(dst_reg->var_off, umin_val);\n\t\telse\n\t\t\tdst_reg->var_off = tnum_lshift(tnum_unknown, umin_val);\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_RSH:\n\t\tif (umax_val > 63) {\n\t\t\t/* Shifts greater than 63 are undefined.  This includes\n\t\t\t * shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* BPF_RSH is an unsigned shift.  If the value in dst_reg might\n\t\t * be negative, then either:\n\t\t * 1) src_reg might be zero, so the sign bit of the result is\n\t\t *    unknown, so we lose our signed bounds\n\t\t * 2) it's known negative, thus the unsigned bounds capture the\n\t\t *    signed bounds\n\t\t * 3) the signed bounds cross zero, so they tell us nothing\n\t\t *    about the result\n\t\t * If the value in dst_reg is known nonnegative, then again the\n\t\t * unsigned bounts capture the signed bounds.\n\t\t * Thus, in all cases it suffices to blow away our signed bounds\n\t\t * and rely on inferring new ones from the unsigned bounds and\n\t\t * var_off of the result.\n\t\t */\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t\tif (src_known)\n\t\t\tdst_reg->var_off = tnum_rshift(dst_reg->var_off,\n\t\t\t\t\t\t       umin_val);\n\t\telse\n\t\t\tdst_reg->var_off = tnum_rshift(tnum_unknown, umin_val);\n\t\tdst_reg->umin_value >>= umax_val;\n\t\tdst_reg->umax_value >>= umin_val;\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tdefault:\n\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\tbreak;\n\t}\n\n\t__reg_deduce_bounds(dst_reg);\n\t__reg_bound_offset(dst_reg);\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 3505,
    "critical_vars": [
      "ret"
    ],
    "function": "adjust_scalar_min_max_vals",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_d3bd7413e0ca40b60cf60d4003246d067cafdeda_verifier.c.diff",
    "function_code": "static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,\n\t\t\t\t      struct bpf_insn *insn,\n\t\t\t\t      struct bpf_reg_state *dst_reg,\n\t\t\t\t      struct bpf_reg_state src_reg)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tu8 opcode = BPF_OP(insn->code);\n\tbool src_known, dst_known;\n\ts64 smin_val, smax_val;\n\tu64 umin_val, umax_val;\n\n\tif (BPF_CLASS(insn->code) != BPF_ALU64) {\n\t\t/* 32-bit ALU ops are (32,32)->64 */\n\t\tcoerce_reg_to_32(dst_reg);\n\t\tcoerce_reg_to_32(&src_reg);\n\t}\n\tsmin_val = src_reg.smin_value;\n\tsmax_val = src_reg.smax_value;\n\tumin_val = src_reg.umin_value;\n\tumax_val = src_reg.umax_value;\n\tsrc_known = tnum_is_const(src_reg.var_off);\n\tdst_known = tnum_is_const(dst_reg->var_off);\n\n\tswitch (opcode) {\n\tcase BPF_ADD:\n\t\tif (signed_add_overflows(dst_reg->smin_value, smin_val) ||\n\t\t    signed_add_overflows(dst_reg->smax_value, smax_val)) {\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value += smin_val;\n\t\t\tdst_reg->smax_value += smax_val;\n\t\t}\n\t\tif (dst_reg->umin_value + umin_val < umin_val ||\n\t\t    dst_reg->umax_value + umax_val < umax_val) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value += umin_val;\n\t\t\tdst_reg->umax_value += umax_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_add(dst_reg->var_off, src_reg.var_off);\n\t\tbreak;\n\tcase BPF_SUB:\n\t\tif (signed_sub_overflows(dst_reg->smin_value, smax_val) ||\n\t\t    signed_sub_overflows(dst_reg->smax_value, smin_val)) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value -= smax_val;\n\t\t\tdst_reg->smax_value -= smin_val;\n\t\t}\n\t\tif (dst_reg->umin_value < umax_val) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\t/* Cannot overflow (as long as bounds are consistent) */\n\t\t\tdst_reg->umin_value -= umax_val;\n\t\t\tdst_reg->umax_value -= umin_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_sub(dst_reg->var_off, src_reg.var_off);\n\t\tbreak;\n\tcase BPF_MUL:\n\t\tdst_reg->var_off = tnum_mul(dst_reg->var_off, src_reg.var_off);\n\t\tif (smin_val < 0 || dst_reg->smin_value < 0) {\n\t\t\t/* Ain't nobody got time to multiply that sign */\n\t\t\t__mark_reg_unbounded(dst_reg);\n\t\t\t__update_reg_bounds(dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* Both values are positive, so we can work with unsigned and\n\t\t * copy the result to signed (unless it exceeds S64_MAX).\n\t\t */\n\t\tif (umax_val > U32_MAX || dst_reg->umax_value > U32_MAX) {\n\t\t\t/* Potential overflow, we know nothing */\n\t\t\t__mark_reg_unbounded(dst_reg);\n\t\t\t/* (except what we can learn from the var_off) */\n\t\t\t__update_reg_bounds(dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\tdst_reg->umin_value *= umin_val;\n\t\tdst_reg->umax_value *= umax_val;\n\t\tif (dst_reg->umax_value > S64_MAX) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\tbreak;\n\tcase BPF_AND:\n\t\tif (src_known && dst_known) {\n\t\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value &\n\t\t\t\t\t\t  src_reg.var_off.value);\n\t\t\tbreak;\n\t\t}\n\t\t/* We get our minimum from the var_off, since that's inherently\n\t\t * bitwise.  Our maximum is the minimum of the operands' maxima.\n\t\t */\n\t\tdst_reg->var_off = tnum_and(dst_reg->var_off, src_reg.var_off);\n\t\tdst_reg->umin_value = dst_reg->var_off.value;\n\t\tdst_reg->umax_value = min(dst_reg->umax_value, umax_val);\n\t\tif (dst_reg->smin_value < 0 || smin_val < 0) {\n\t\t\t/* Lose signed bounds when ANDing negative numbers,\n\t\t\t * ain't nobody got time for that.\n\t\t\t */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\t/* ANDing two positives gives a positive, so safe to\n\t\t\t * cast result into s64.\n\t\t\t */\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_OR:\n\t\tif (src_known && dst_known) {\n\t\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value |\n\t\t\t\t\t\t  src_reg.var_off.value);\n\t\t\tbreak;\n\t\t}\n\t\t/* We get our maximum from the var_off, and our minimum is the\n\t\t * maximum of the operands' minima\n\t\t */\n\t\tdst_reg->var_off = tnum_or(dst_reg->var_off, src_reg.var_off);\n\t\tdst_reg->umin_value = max(dst_reg->umin_value, umin_val);\n\t\tdst_reg->umax_value = dst_reg->var_off.value |\n\t\t\t\t      dst_reg->var_off.mask;\n\t\tif (dst_reg->smin_value < 0 || smin_val < 0) {\n\t\t\t/* Lose signed bounds when ORing negative numbers,\n\t\t\t * ain't nobody got time for that.\n\t\t\t */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\t/* ORing two positives gives a positive, so safe to\n\t\t\t * cast result into s64.\n\t\t\t */\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_LSH:\n\t\tif (umax_val > 63) {\n\t\t\t/* Shifts greater than 63 are undefined.  This includes\n\t\t\t * shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* We lose all sign bit information (except what we can pick\n\t\t * up from var_off)\n\t\t */\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t\t/* If we might shift our top bit out, then we know nothing */\n\t\tif (dst_reg->umax_value > 1ULL << (63 - umax_val)) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value <<= umin_val;\n\t\t\tdst_reg->umax_value <<= umax_val;\n\t\t}\n\t\tif (src_known)\n\t\t\tdst_reg->var_off = tnum_lshift(dst_reg->var_off, umin_val);\n\t\telse\n\t\t\tdst_reg->var_off = tnum_lshift(tnum_unknown, umin_val);\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_RSH:\n\t\tif (umax_val > 63) {\n\t\t\t/* Shifts greater than 63 are undefined.  This includes\n\t\t\t * shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* BPF_RSH is an unsigned shift.  If the value in dst_reg might\n\t\t * be negative, then either:\n\t\t * 1) src_reg might be zero, so the sign bit of the result is\n\t\t *    unknown, so we lose our signed bounds\n\t\t * 2) it's known negative, thus the unsigned bounds capture the\n\t\t *    signed bounds\n\t\t * 3) the signed bounds cross zero, so they tell us nothing\n\t\t *    about the result\n\t\t * If the value in dst_reg is known nonnegative, then again the\n\t\t * unsigned bounts capture the signed bounds.\n\t\t * Thus, in all cases it suffices to blow away our signed bounds\n\t\t * and rely on inferring new ones from the unsigned bounds and\n\t\t * var_off of the result.\n\t\t */\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t\tif (src_known)\n\t\t\tdst_reg->var_off = tnum_rshift(dst_reg->var_off,\n\t\t\t\t\t\t       umin_val);\n\t\telse\n\t\t\tdst_reg->var_off = tnum_rshift(tnum_unknown, umin_val);\n\t\tdst_reg->umin_value >>= umax_val;\n\t\tdst_reg->umax_value >>= umin_val;\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tdefault:\n\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\tbreak;\n\t}\n\n\t__reg_deduce_bounds(dst_reg);\n\t__reg_bound_offset(dst_reg);\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 3506,
    "critical_vars": [
      "dst",
      "env"
    ],
    "function": "adjust_scalar_min_max_vals",
    "filename": "linux/CVE-2019-7308/CVE-2019-7308_CWE-189_d3bd7413e0ca40b60cf60d4003246d067cafdeda_verifier.c.diff",
    "function_code": "static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,\n\t\t\t\t      struct bpf_insn *insn,\n\t\t\t\t      struct bpf_reg_state *dst_reg,\n\t\t\t\t      struct bpf_reg_state src_reg)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tu8 opcode = BPF_OP(insn->code);\n\tbool src_known, dst_known;\n\ts64 smin_val, smax_val;\n\tu64 umin_val, umax_val;\n\n\tif (BPF_CLASS(insn->code) != BPF_ALU64) {\n\t\t/* 32-bit ALU ops are (32,32)->64 */\n\t\tcoerce_reg_to_32(dst_reg);\n\t\tcoerce_reg_to_32(&src_reg);\n\t}\n\tsmin_val = src_reg.smin_value;\n\tsmax_val = src_reg.smax_value;\n\tumin_val = src_reg.umin_value;\n\tumax_val = src_reg.umax_value;\n\tsrc_known = tnum_is_const(src_reg.var_off);\n\tdst_known = tnum_is_const(dst_reg->var_off);\n\n\tswitch (opcode) {\n\tcase BPF_ADD:\n\t\tif (signed_add_overflows(dst_reg->smin_value, smin_val) ||\n\t\t    signed_add_overflows(dst_reg->smax_value, smax_val)) {\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value += smin_val;\n\t\t\tdst_reg->smax_value += smax_val;\n\t\t}\n\t\tif (dst_reg->umin_value + umin_val < umin_val ||\n\t\t    dst_reg->umax_value + umax_val < umax_val) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value += umin_val;\n\t\t\tdst_reg->umax_value += umax_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_add(dst_reg->var_off, src_reg.var_off);\n\t\tbreak;\n\tcase BPF_SUB:\n\t\tif (signed_sub_overflows(dst_reg->smin_value, smax_val) ||\n\t\t    signed_sub_overflows(dst_reg->smax_value, smin_val)) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value -= smax_val;\n\t\t\tdst_reg->smax_value -= smin_val;\n\t\t}\n\t\tif (dst_reg->umin_value < umax_val) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\t/* Cannot overflow (as long as bounds are consistent) */\n\t\t\tdst_reg->umin_value -= umax_val;\n\t\t\tdst_reg->umax_value -= umin_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_sub(dst_reg->var_off, src_reg.var_off);\n\t\tbreak;\n\tcase BPF_MUL:\n\t\tdst_reg->var_off = tnum_mul(dst_reg->var_off, src_reg.var_off);\n\t\tif (smin_val < 0 || dst_reg->smin_value < 0) {\n\t\t\t/* Ain't nobody got time to multiply that sign */\n\t\t\t__mark_reg_unbounded(dst_reg);\n\t\t\t__update_reg_bounds(dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* Both values are positive, so we can work with unsigned and\n\t\t * copy the result to signed (unless it exceeds S64_MAX).\n\t\t */\n\t\tif (umax_val > U32_MAX || dst_reg->umax_value > U32_MAX) {\n\t\t\t/* Potential overflow, we know nothing */\n\t\t\t__mark_reg_unbounded(dst_reg);\n\t\t\t/* (except what we can learn from the var_off) */\n\t\t\t__update_reg_bounds(dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\tdst_reg->umin_value *= umin_val;\n\t\tdst_reg->umax_value *= umax_val;\n\t\tif (dst_reg->umax_value > S64_MAX) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\tbreak;\n\tcase BPF_AND:\n\t\tif (src_known && dst_known) {\n\t\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value &\n\t\t\t\t\t\t  src_reg.var_off.value);\n\t\t\tbreak;\n\t\t}\n\t\t/* We get our minimum from the var_off, since that's inherently\n\t\t * bitwise.  Our maximum is the minimum of the operands' maxima.\n\t\t */\n\t\tdst_reg->var_off = tnum_and(dst_reg->var_off, src_reg.var_off);\n\t\tdst_reg->umin_value = dst_reg->var_off.value;\n\t\tdst_reg->umax_value = min(dst_reg->umax_value, umax_val);\n\t\tif (dst_reg->smin_value < 0 || smin_val < 0) {\n\t\t\t/* Lose signed bounds when ANDing negative numbers,\n\t\t\t * ain't nobody got time for that.\n\t\t\t */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\t/* ANDing two positives gives a positive, so safe to\n\t\t\t * cast result into s64.\n\t\t\t */\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_OR:\n\t\tif (src_known && dst_known) {\n\t\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value |\n\t\t\t\t\t\t  src_reg.var_off.value);\n\t\t\tbreak;\n\t\t}\n\t\t/* We get our maximum from the var_off, and our minimum is the\n\t\t * maximum of the operands' minima\n\t\t */\n\t\tdst_reg->var_off = tnum_or(dst_reg->var_off, src_reg.var_off);\n\t\tdst_reg->umin_value = max(dst_reg->umin_value, umin_val);\n\t\tdst_reg->umax_value = dst_reg->var_off.value |\n\t\t\t\t      dst_reg->var_off.mask;\n\t\tif (dst_reg->smin_value < 0 || smin_val < 0) {\n\t\t\t/* Lose signed bounds when ORing negative numbers,\n\t\t\t * ain't nobody got time for that.\n\t\t\t */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\t/* ORing two positives gives a positive, so safe to\n\t\t\t * cast result into s64.\n\t\t\t */\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_LSH:\n\t\tif (umax_val > 63) {\n\t\t\t/* Shifts greater than 63 are undefined.  This includes\n\t\t\t * shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* We lose all sign bit information (except what we can pick\n\t\t * up from var_off)\n\t\t */\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t\t/* If we might shift our top bit out, then we know nothing */\n\t\tif (dst_reg->umax_value > 1ULL << (63 - umax_val)) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value <<= umin_val;\n\t\t\tdst_reg->umax_value <<= umax_val;\n\t\t}\n\t\tif (src_known)\n\t\t\tdst_reg->var_off = tnum_lshift(dst_reg->var_off, umin_val);\n\t\telse\n\t\t\tdst_reg->var_off = tnum_lshift(tnum_unknown, umin_val);\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_RSH:\n\t\tif (umax_val > 63) {\n\t\t\t/* Shifts greater than 63 are undefined.  This includes\n\t\t\t * shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* BPF_RSH is an unsigned shift.  If the value in dst_reg might\n\t\t * be negative, then either:\n\t\t * 1) src_reg might be zero, so the sign bit of the result is\n\t\t *    unknown, so we lose our signed bounds\n\t\t * 2) it's known negative, thus the unsigned bounds capture the\n\t\t *    signed bounds\n\t\t * 3) the signed bounds cross zero, so they tell us nothing\n\t\t *    about the result\n\t\t * If the value in dst_reg is known nonnegative, then again the\n\t\t * unsigned bounts capture the signed bounds.\n\t\t * Thus, in all cases it suffices to blow away our signed bounds\n\t\t * and rely on inferring new ones from the unsigned bounds and\n\t\t * var_off of the result.\n\t\t */\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t\tif (src_known)\n\t\t\tdst_reg->var_off = tnum_rshift(dst_reg->var_off,\n\t\t\t\t\t\t       umin_val);\n\t\telse\n\t\t\tdst_reg->var_off = tnum_rshift(tnum_unknown, umin_val);\n\t\tdst_reg->umin_value >>= umax_val;\n\t\tdst_reg->umax_value >>= umin_val;\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tdefault:\n\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\tbreak;\n\t}\n\n\t__reg_deduce_bounds(dst_reg);\n\t__reg_bound_offset(dst_reg);\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 915,
    "line_new": 915,
    "critical_vars": [
      "hwc->event_base"
    ],
    "function": "x86_assign_hw_event",
    "filename": "linux/CVE-2011-2521/CVE-2011-2521_CWE-189_fc66c5210ec2539e800e87d7b3a985323c7be96e_perf_event.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 93,
    "critical_vars": [
      "skb"
    ],
    "function": "*udp6_ufo_fragment",
    "filename": "linux/CVE-2013-4563/CVE-2013-4563_CWE-189_0e033e04c2678dbbe74a46b23fffb7bb918c288e_udp_offload.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 93,
    "critical_vars": [
      "skb->mac_header"
    ],
    "function": "*udp6_ufo_fragment",
    "filename": "linux/CVE-2013-4563/CVE-2013-4563_CWE-189_0e033e04c2678dbbe74a46b23fffb7bb918c288e_udp_offload.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 2481,
    "critical_vars": [
      "newly_acked_sacked",
      "tp->prior_cwnd"
    ],
    "function": "tcp_cwnd_reduction",
    "filename": "linux/CVE-2016-2070/CVE-2016-2070_CWE-189_8b8a321ff72c785ed5e8b4cf6eda20b35d427390_tcp_input.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 844,
    "critical_vars": [
      "apic"
    ],
    "function": "apic_get_tmcct",
    "filename": "linux/CVE-2013-6367/CVE-2013-6367_CWE-189_b963a22e6d1a266a67e9eecc88134713fd54775c_lapic.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 844,
    "critical_vars": [
      "apic->lapic_timer.period",
      "apic"
    ],
    "function": "apic_get_tmcct",
    "filename": "linux/CVE-2013-6367/CVE-2013-6367_CWE-189_b963a22e6d1a266a67e9eecc88134713fd54775c_lapic.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 749,
    "critical_vars": [
      "u16"
    ],
    "function": "oz_hcd_pd_reset",
    "filename": "linux/CVE-2015-4001/CVE-2015-4001_CWE-189_b1bb5b49373b61bf9d2c73a4d30058ba6f069e4c_ozhcd.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "Var-Declaration",
    "line_old": 762,
    "line_new": 762,
    "critical_vars": [
      "copy_len"
    ],
    "function": "oz_hcd_get_desc_cnf",
    "filename": "linux/CVE-2015-4001/CVE-2015-4001_CWE-189_b1bb5b49373b61bf9d2c73a4d30058ba6f069e4c_ozhcd.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 763,
    "line_new": 763,
    "critical_vars": [
      "required_size"
    ],
    "function": "oz_hcd_get_desc_cnf",
    "filename": "linux/CVE-2015-4001/CVE-2015-4001_CWE-189_b1bb5b49373b61bf9d2c73a4d30058ba6f069e4c_ozhcd.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1136,
    "critical_vars": [
      "args->num_cliprects"
    ],
    "function": "i915_gem_do_execbuffer",
    "filename": "linux/CVE-2012-2384/CVE-2012-2384_CWE-189_44afb3a04391a74309d16180d1e4f8386fdfa745_i915_gem_execbuffer.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 1137,
    "critical_vars": [
      "args->num_cliprects"
    ],
    "function": "i915_gem_do_execbuffer",
    "filename": "linux/CVE-2012-2384/CVE-2012-2384_CWE-189_44afb3a04391a74309d16180d1e4f8386fdfa745_i915_gem_execbuffer.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 5334,
    "line_new": 5334,
    "critical_vars": [
      "event_id"
    ],
    "function": "sw_perf_event_destroy",
    "filename": "linux/CVE-2013-2094/CVE-2013-2094_CWE-189_8176cced706b5e5d15887584150764894e94e02f_core.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 412,
    "critical_vars": [
      "namelen"
    ],
    "function": "SYSCALL_DEFINE2",
    "filename": "linux/CVE-2011-2209/CVE-2011-2209_CWE-189_21c5977a836e399fc710ff2c5367845ed5c2527f_osf_sys.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 412,
    "critical_vars": [
      "len"
    ],
    "function": "SYSCALL_DEFINE2",
    "filename": "linux/CVE-2011-2209/CVE-2011-2209_CWE-189_21c5977a836e399fc710ff2c5367845ed5c2527f_osf_sys.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 597,
    "critical_vars": [
      "len"
    ],
    "function": "SYSCALL_DEFINE3",
    "filename": "linux/CVE-2011-2209/CVE-2011-2209_CWE-189_21c5977a836e399fc710ff2c5367845ed5c2527f_osf_sys.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 597,
    "critical_vars": [
      "long"
    ],
    "function": "SYSCALL_DEFINE3",
    "filename": "linux/CVE-2011-2209/CVE-2011-2209_CWE-189_21c5977a836e399fc710ff2c5367845ed5c2527f_osf_sys.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 652,
    "line_new": 652,
    "critical_vars": [
      "nbytes"
    ],
    "function": "SYSCALL_DEFINE5",
    "filename": "linux/CVE-2011-2209/CVE-2011-2209_CWE-189_21c5977a836e399fc710ff2c5367845ed5c2527f_osf_sys.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 1011,
    "critical_vars": [
      "status"
    ],
    "function": "SYSCALL_DEFINE4",
    "filename": "linux/CVE-2011-2209/CVE-2011-2209_CWE-189_21c5977a836e399fc710ff2c5367845ed5c2527f_osf_sys.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 1019,
    "line_new": 1020,
    "critical_vars": [
      "ret"
    ],
    "function": "SYSCALL_DEFINE4",
    "filename": "linux/CVE-2011-2209/CVE-2011-2209_CWE-189_21c5977a836e399fc710ff2c5367845ed5c2527f_osf_sys.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 1028,
    "critical_vars": [
      "err"
    ],
    "function": "SYSCALL_DEFINE4",
    "filename": "linux/CVE-2011-2209/CVE-2011-2209_CWE-189_21c5977a836e399fc710ff2c5367845ed5c2527f_osf_sys.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1494,
    "critical_vars": [
      "iinfo->i_lenEAttr",
      "iinfo->i_lenAlloc"
    ],
    "function": "udf_read_inode",
    "filename": "linux/CVE-2015-4167/CVE-2015-4167_CWE-189_23b133bdc452aa441fcb9b82cbf6dd05cfd342d0_inode.c.diff",
    "function_code": "static int udf_read_inode(struct inode *inode, bool hidden_inode)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct fileEntry *fe;\n\tstruct extendedFileEntry *efe;\n\tuint16_t ident;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tstruct udf_sb_info *sbi = UDF_SB(inode->i_sb);\n\tstruct kernel_lb_addr *iloc = &iinfo->i_location;\n\tunsigned int link_count;\n\tunsigned int indirections = 0;\n\tint ret = -EIO;\n\nreread:\n\tif (iloc->logicalBlockNum >=\n\t    sbi->s_partmaps[iloc->partitionReferenceNum].s_partition_len) {\n\t\tudf_debug(\"block=%d, partition=%d out of range\\n\",\n\t\t\t  iloc->logicalBlockNum, iloc->partitionReferenceNum);\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * Set defaults, but the inode is still incomplete!\n\t * Note: get_new_inode() sets the following on a new inode:\n\t *      i_sb = sb\n\t *      i_no = ino\n\t *      i_flags = sb->s_flags\n\t *      i_state = 0\n\t * clean_inode(): zero fills and sets\n\t *      i_count = 1\n\t *      i_nlink = 1\n\t *      i_op = NULL;\n\t */\n\tbh = udf_read_ptagged(inode->i_sb, iloc, 0, &ident);\n\tif (!bh) {\n\t\tudf_err(inode->i_sb, \"(ino %ld) failed !bh\\n\", inode->i_ino);\n\t\treturn -EIO;\n\t}\n\n\tif (ident != TAG_IDENT_FE && ident != TAG_IDENT_EFE &&\n\t    ident != TAG_IDENT_USE) {\n\t\tudf_err(inode->i_sb, \"(ino %ld) failed ident=%d\\n\",\n\t\t\tinode->i_ino, ident);\n\t\tgoto out;\n\t}\n\n\tfe = (struct fileEntry *)bh->b_data;\n\tefe = (struct extendedFileEntry *)bh->b_data;\n\n\tif (fe->icbTag.strategyType == cpu_to_le16(4096)) {\n\t\tstruct buffer_head *ibh;\n\n\t\tibh = udf_read_ptagged(inode->i_sb, iloc, 1, &ident);\n\t\tif (ident == TAG_IDENT_IE && ibh) {\n\t\t\tstruct kernel_lb_addr loc;\n\t\t\tstruct indirectEntry *ie;\n\n\t\t\tie = (struct indirectEntry *)ibh->b_data;\n\t\t\tloc = lelb_to_cpu(ie->indirectICB.extLocation);\n\n\t\t\tif (ie->indirectICB.extLength) {\n\t\t\t\tbrelse(ibh);\n\t\t\t\tmemcpy(&iinfo->i_location, &loc,\n\t\t\t\t       sizeof(struct kernel_lb_addr));\n\t\t\t\tif (++indirections > UDF_MAX_ICB_NESTING) {\n\t\t\t\t\tudf_err(inode->i_sb,\n\t\t\t\t\t\t\"too many ICBs in ICB hierarchy\"\n\t\t\t\t\t\t\" (max %d supported)\\n\",\n\t\t\t\t\t\tUDF_MAX_ICB_NESTING);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tbrelse(bh);\n\t\t\t\tgoto reread;\n\t\t\t}\n\t\t}\n\t\tbrelse(ibh);\n\t} else if (fe->icbTag.strategyType != cpu_to_le16(4)) {\n\t\tudf_err(inode->i_sb, \"unsupported strategy type: %d\\n\",\n\t\t\tle16_to_cpu(fe->icbTag.strategyType));\n\t\tgoto out;\n\t}\n\tif (fe->icbTag.strategyType == cpu_to_le16(4))\n\t\tiinfo->i_strat4096 = 0;\n\telse /* if (fe->icbTag.strategyType == cpu_to_le16(4096)) */\n\t\tiinfo->i_strat4096 = 1;\n\n\tiinfo->i_alloc_type = le16_to_cpu(fe->icbTag.flags) &\n\t\t\t\t\t\t\tICBTAG_FLAG_AD_MASK;\n\tiinfo->i_unique = 0;\n\tiinfo->i_lenEAttr = 0;\n\tiinfo->i_lenExtents = 0;\n\tiinfo->i_lenAlloc = 0;\n\tiinfo->i_next_alloc_block = 0;\n\tiinfo->i_next_alloc_goal = 0;\n\tif (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_EFE)) {\n\t\tiinfo->i_efe = 1;\n\t\tiinfo->i_use = 0;\n\t\tret = udf_alloc_i_data(inode, inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct extendedFileEntry));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tmemcpy(iinfo->i_ext.i_data,\n\t\t       bh->b_data + sizeof(struct extendedFileEntry),\n\t\t       inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct extendedFileEntry));\n\t} else if (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_FE)) {\n\t\tiinfo->i_efe = 0;\n\t\tiinfo->i_use = 0;\n\t\tret = udf_alloc_i_data(inode, inode->i_sb->s_blocksize -\n\t\t\t\t\t\tsizeof(struct fileEntry));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tmemcpy(iinfo->i_ext.i_data,\n\t\t       bh->b_data + sizeof(struct fileEntry),\n\t\t       inode->i_sb->s_blocksize - sizeof(struct fileEntry));\n\t} else if (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_USE)) {\n\t\tiinfo->i_efe = 0;\n\t\tiinfo->i_use = 1;\n\t\tiinfo->i_lenAlloc = le32_to_cpu(\n\t\t\t\t((struct unallocSpaceEntry *)bh->b_data)->\n\t\t\t\t lengthAllocDescs);\n\t\tret = udf_alloc_i_data(inode, inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct unallocSpaceEntry));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tmemcpy(iinfo->i_ext.i_data,\n\t\t       bh->b_data + sizeof(struct unallocSpaceEntry),\n\t\t       inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct unallocSpaceEntry));\n\t\treturn 0;\n\t}\n\n\tret = -EIO;\n\tread_lock(&sbi->s_cred_lock);\n\ti_uid_write(inode, le32_to_cpu(fe->uid));\n\tif (!uid_valid(inode->i_uid) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_UID_IGNORE) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_UID_SET))\n\t\tinode->i_uid = UDF_SB(inode->i_sb)->s_uid;\n\n\ti_gid_write(inode, le32_to_cpu(fe->gid));\n\tif (!gid_valid(inode->i_gid) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_GID_IGNORE) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_GID_SET))\n\t\tinode->i_gid = UDF_SB(inode->i_sb)->s_gid;\n\n\tif (fe->icbTag.fileType != ICBTAG_FILE_TYPE_DIRECTORY &&\n\t\t\tsbi->s_fmode != UDF_INVALID_MODE)\n\t\tinode->i_mode = sbi->s_fmode;\n\telse if (fe->icbTag.fileType == ICBTAG_FILE_TYPE_DIRECTORY &&\n\t\t\tsbi->s_dmode != UDF_INVALID_MODE)\n\t\tinode->i_mode = sbi->s_dmode;\n\telse\n\t\tinode->i_mode = udf_convert_permissions(fe);\n\tinode->i_mode &= ~sbi->s_umask;\n\tread_unlock(&sbi->s_cred_lock);\n\n\tlink_count = le16_to_cpu(fe->fileLinkCount);\n\tif (!link_count) {\n\t\tif (!hidden_inode) {\n\t\t\tret = -ESTALE;\n\t\t\tgoto out;\n\t\t}\n\t\tlink_count = 1;\n\t}\n\tset_nlink(inode, link_count);\n\n\tinode->i_size = le64_to_cpu(fe->informationLength);\n\tiinfo->i_lenExtents = inode->i_size;\n\n\tif (iinfo->i_efe == 0) {\n\t\tinode->i_blocks = le64_to_cpu(fe->logicalBlocksRecorded) <<\n\t\t\t(inode->i_sb->s_blocksize_bits - 9);\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_atime, fe->accessTime))\n\t\t\tinode->i_atime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_mtime,\n\t\t\t\t\t    fe->modificationTime))\n\t\t\tinode->i_mtime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_ctime, fe->attrTime))\n\t\t\tinode->i_ctime = sbi->s_record_time;\n\n\t\tiinfo->i_unique = le64_to_cpu(fe->uniqueID);\n\t\tiinfo->i_lenEAttr = le32_to_cpu(fe->lengthExtendedAttr);\n\t\tiinfo->i_lenAlloc = le32_to_cpu(fe->lengthAllocDescs);\n\t\tiinfo->i_checkpoint = le32_to_cpu(fe->checkpoint);\n\t} else {\n\t\tinode->i_blocks = le64_to_cpu(efe->logicalBlocksRecorded) <<\n\t\t    (inode->i_sb->s_blocksize_bits - 9);\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_atime, efe->accessTime))\n\t\t\tinode->i_atime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_mtime,\n\t\t\t\t\t    efe->modificationTime))\n\t\t\tinode->i_mtime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&iinfo->i_crtime, efe->createTime))\n\t\t\tiinfo->i_crtime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_ctime, efe->attrTime))\n\t\t\tinode->i_ctime = sbi->s_record_time;\n\n\t\tiinfo->i_unique = le64_to_cpu(efe->uniqueID);\n\t\tiinfo->i_lenEAttr = le32_to_cpu(efe->lengthExtendedAttr);\n\t\tiinfo->i_lenAlloc = le32_to_cpu(efe->lengthAllocDescs);\n\t\tiinfo->i_checkpoint = le32_to_cpu(efe->checkpoint);\n\t}\n\tinode->i_generation = iinfo->i_unique;\n\n\t/* Sanity checks for files in ICB so that we don't get confused later */\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\t/*\n\t\t * For file in ICB data is stored in allocation descriptor\n\t\t * so sizes should match\n\t\t */\n\t\tif (iinfo->i_lenAlloc != inode->i_size)\n\t\t\tgoto out;\n\t\t/* File in ICB has to fit in there... */\n\t\tif (inode->i_size > inode->i_sb->s_blocksize -\n\t\t\t\t\tudf_file_entry_alloc_offset(inode))\n\t\t\tgoto out;\n\t}\n\n\tswitch (fe->icbTag.fileType) {\n\tcase ICBTAG_FILE_TYPE_DIRECTORY:\n\t\tinode->i_op = &udf_dir_inode_operations;\n\t\tinode->i_fop = &udf_dir_operations;\n\t\tinode->i_mode |= S_IFDIR;\n\t\tinc_nlink(inode);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_REALTIME:\n\tcase ICBTAG_FILE_TYPE_REGULAR:\n\tcase ICBTAG_FILE_TYPE_UNDEF:\n\tcase ICBTAG_FILE_TYPE_VAT20:\n\t\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\t\tinode->i_data.a_ops = &udf_adinicb_aops;\n\t\telse\n\t\t\tinode->i_data.a_ops = &udf_aops;\n\t\tinode->i_op = &udf_file_inode_operations;\n\t\tinode->i_fop = &udf_file_operations;\n\t\tinode->i_mode |= S_IFREG;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_BLOCK:\n\t\tinode->i_mode |= S_IFBLK;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_CHAR:\n\t\tinode->i_mode |= S_IFCHR;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_FIFO:\n\t\tinit_special_inode(inode, inode->i_mode | S_IFIFO, 0);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_SOCKET:\n\t\tinit_special_inode(inode, inode->i_mode | S_IFSOCK, 0);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_SYMLINK:\n\t\tinode->i_data.a_ops = &udf_symlink_aops;\n\t\tinode->i_op = &udf_symlink_inode_operations;\n\t\tinode->i_mode = S_IFLNK | S_IRWXUGO;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_MAIN:\n\t\tudf_debug(\"METADATA FILE-----\\n\");\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_MIRROR:\n\t\tudf_debug(\"METADATA MIRROR FILE-----\\n\");\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_BITMAP:\n\t\tudf_debug(\"METADATA BITMAP FILE-----\\n\");\n\t\tbreak;\n\tdefault:\n\t\tudf_err(inode->i_sb, \"(ino %ld) failed unknown file type=%d\\n\",\n\t\t\tinode->i_ino, fe->icbTag.fileType);\n\t\tgoto out;\n\t}\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tstruct deviceSpec *dsea =\n\t\t\t(struct deviceSpec *)udf_get_extendedattr(inode, 12, 1);\n\t\tif (dsea) {\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\tMKDEV(le32_to_cpu(dsea->majorDeviceIdent),\n\t\t\t\t      le32_to_cpu(dsea->minorDeviceIdent)));\n\t\t\t/* Developer ID ??? */\n\t\t} else\n\t\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tbrelse(bh);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1497,
    "critical_vars": [
      "iinfo->i_lenAlloc",
      "inode"
    ],
    "function": "udf_read_inode",
    "filename": "linux/CVE-2015-4167/CVE-2015-4167_CWE-189_23b133bdc452aa441fcb9b82cbf6dd05cfd342d0_inode.c.diff",
    "function_code": "static int udf_read_inode(struct inode *inode, bool hidden_inode)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct fileEntry *fe;\n\tstruct extendedFileEntry *efe;\n\tuint16_t ident;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tstruct udf_sb_info *sbi = UDF_SB(inode->i_sb);\n\tstruct kernel_lb_addr *iloc = &iinfo->i_location;\n\tunsigned int link_count;\n\tunsigned int indirections = 0;\n\tint ret = -EIO;\n\nreread:\n\tif (iloc->logicalBlockNum >=\n\t    sbi->s_partmaps[iloc->partitionReferenceNum].s_partition_len) {\n\t\tudf_debug(\"block=%d, partition=%d out of range\\n\",\n\t\t\t  iloc->logicalBlockNum, iloc->partitionReferenceNum);\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * Set defaults, but the inode is still incomplete!\n\t * Note: get_new_inode() sets the following on a new inode:\n\t *      i_sb = sb\n\t *      i_no = ino\n\t *      i_flags = sb->s_flags\n\t *      i_state = 0\n\t * clean_inode(): zero fills and sets\n\t *      i_count = 1\n\t *      i_nlink = 1\n\t *      i_op = NULL;\n\t */\n\tbh = udf_read_ptagged(inode->i_sb, iloc, 0, &ident);\n\tif (!bh) {\n\t\tudf_err(inode->i_sb, \"(ino %ld) failed !bh\\n\", inode->i_ino);\n\t\treturn -EIO;\n\t}\n\n\tif (ident != TAG_IDENT_FE && ident != TAG_IDENT_EFE &&\n\t    ident != TAG_IDENT_USE) {\n\t\tudf_err(inode->i_sb, \"(ino %ld) failed ident=%d\\n\",\n\t\t\tinode->i_ino, ident);\n\t\tgoto out;\n\t}\n\n\tfe = (struct fileEntry *)bh->b_data;\n\tefe = (struct extendedFileEntry *)bh->b_data;\n\n\tif (fe->icbTag.strategyType == cpu_to_le16(4096)) {\n\t\tstruct buffer_head *ibh;\n\n\t\tibh = udf_read_ptagged(inode->i_sb, iloc, 1, &ident);\n\t\tif (ident == TAG_IDENT_IE && ibh) {\n\t\t\tstruct kernel_lb_addr loc;\n\t\t\tstruct indirectEntry *ie;\n\n\t\t\tie = (struct indirectEntry *)ibh->b_data;\n\t\t\tloc = lelb_to_cpu(ie->indirectICB.extLocation);\n\n\t\t\tif (ie->indirectICB.extLength) {\n\t\t\t\tbrelse(ibh);\n\t\t\t\tmemcpy(&iinfo->i_location, &loc,\n\t\t\t\t       sizeof(struct kernel_lb_addr));\n\t\t\t\tif (++indirections > UDF_MAX_ICB_NESTING) {\n\t\t\t\t\tudf_err(inode->i_sb,\n\t\t\t\t\t\t\"too many ICBs in ICB hierarchy\"\n\t\t\t\t\t\t\" (max %d supported)\\n\",\n\t\t\t\t\t\tUDF_MAX_ICB_NESTING);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tbrelse(bh);\n\t\t\t\tgoto reread;\n\t\t\t}\n\t\t}\n\t\tbrelse(ibh);\n\t} else if (fe->icbTag.strategyType != cpu_to_le16(4)) {\n\t\tudf_err(inode->i_sb, \"unsupported strategy type: %d\\n\",\n\t\t\tle16_to_cpu(fe->icbTag.strategyType));\n\t\tgoto out;\n\t}\n\tif (fe->icbTag.strategyType == cpu_to_le16(4))\n\t\tiinfo->i_strat4096 = 0;\n\telse /* if (fe->icbTag.strategyType == cpu_to_le16(4096)) */\n\t\tiinfo->i_strat4096 = 1;\n\n\tiinfo->i_alloc_type = le16_to_cpu(fe->icbTag.flags) &\n\t\t\t\t\t\t\tICBTAG_FLAG_AD_MASK;\n\tiinfo->i_unique = 0;\n\tiinfo->i_lenEAttr = 0;\n\tiinfo->i_lenExtents = 0;\n\tiinfo->i_lenAlloc = 0;\n\tiinfo->i_next_alloc_block = 0;\n\tiinfo->i_next_alloc_goal = 0;\n\tif (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_EFE)) {\n\t\tiinfo->i_efe = 1;\n\t\tiinfo->i_use = 0;\n\t\tret = udf_alloc_i_data(inode, inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct extendedFileEntry));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tmemcpy(iinfo->i_ext.i_data,\n\t\t       bh->b_data + sizeof(struct extendedFileEntry),\n\t\t       inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct extendedFileEntry));\n\t} else if (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_FE)) {\n\t\tiinfo->i_efe = 0;\n\t\tiinfo->i_use = 0;\n\t\tret = udf_alloc_i_data(inode, inode->i_sb->s_blocksize -\n\t\t\t\t\t\tsizeof(struct fileEntry));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tmemcpy(iinfo->i_ext.i_data,\n\t\t       bh->b_data + sizeof(struct fileEntry),\n\t\t       inode->i_sb->s_blocksize - sizeof(struct fileEntry));\n\t} else if (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_USE)) {\n\t\tiinfo->i_efe = 0;\n\t\tiinfo->i_use = 1;\n\t\tiinfo->i_lenAlloc = le32_to_cpu(\n\t\t\t\t((struct unallocSpaceEntry *)bh->b_data)->\n\t\t\t\t lengthAllocDescs);\n\t\tret = udf_alloc_i_data(inode, inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct unallocSpaceEntry));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tmemcpy(iinfo->i_ext.i_data,\n\t\t       bh->b_data + sizeof(struct unallocSpaceEntry),\n\t\t       inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct unallocSpaceEntry));\n\t\treturn 0;\n\t}\n\n\tret = -EIO;\n\tread_lock(&sbi->s_cred_lock);\n\ti_uid_write(inode, le32_to_cpu(fe->uid));\n\tif (!uid_valid(inode->i_uid) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_UID_IGNORE) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_UID_SET))\n\t\tinode->i_uid = UDF_SB(inode->i_sb)->s_uid;\n\n\ti_gid_write(inode, le32_to_cpu(fe->gid));\n\tif (!gid_valid(inode->i_gid) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_GID_IGNORE) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_GID_SET))\n\t\tinode->i_gid = UDF_SB(inode->i_sb)->s_gid;\n\n\tif (fe->icbTag.fileType != ICBTAG_FILE_TYPE_DIRECTORY &&\n\t\t\tsbi->s_fmode != UDF_INVALID_MODE)\n\t\tinode->i_mode = sbi->s_fmode;\n\telse if (fe->icbTag.fileType == ICBTAG_FILE_TYPE_DIRECTORY &&\n\t\t\tsbi->s_dmode != UDF_INVALID_MODE)\n\t\tinode->i_mode = sbi->s_dmode;\n\telse\n\t\tinode->i_mode = udf_convert_permissions(fe);\n\tinode->i_mode &= ~sbi->s_umask;\n\tread_unlock(&sbi->s_cred_lock);\n\n\tlink_count = le16_to_cpu(fe->fileLinkCount);\n\tif (!link_count) {\n\t\tif (!hidden_inode) {\n\t\t\tret = -ESTALE;\n\t\t\tgoto out;\n\t\t}\n\t\tlink_count = 1;\n\t}\n\tset_nlink(inode, link_count);\n\n\tinode->i_size = le64_to_cpu(fe->informationLength);\n\tiinfo->i_lenExtents = inode->i_size;\n\n\tif (iinfo->i_efe == 0) {\n\t\tinode->i_blocks = le64_to_cpu(fe->logicalBlocksRecorded) <<\n\t\t\t(inode->i_sb->s_blocksize_bits - 9);\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_atime, fe->accessTime))\n\t\t\tinode->i_atime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_mtime,\n\t\t\t\t\t    fe->modificationTime))\n\t\t\tinode->i_mtime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_ctime, fe->attrTime))\n\t\t\tinode->i_ctime = sbi->s_record_time;\n\n\t\tiinfo->i_unique = le64_to_cpu(fe->uniqueID);\n\t\tiinfo->i_lenEAttr = le32_to_cpu(fe->lengthExtendedAttr);\n\t\tiinfo->i_lenAlloc = le32_to_cpu(fe->lengthAllocDescs);\n\t\tiinfo->i_checkpoint = le32_to_cpu(fe->checkpoint);\n\t} else {\n\t\tinode->i_blocks = le64_to_cpu(efe->logicalBlocksRecorded) <<\n\t\t    (inode->i_sb->s_blocksize_bits - 9);\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_atime, efe->accessTime))\n\t\t\tinode->i_atime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_mtime,\n\t\t\t\t\t    efe->modificationTime))\n\t\t\tinode->i_mtime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&iinfo->i_crtime, efe->createTime))\n\t\t\tiinfo->i_crtime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_ctime, efe->attrTime))\n\t\t\tinode->i_ctime = sbi->s_record_time;\n\n\t\tiinfo->i_unique = le64_to_cpu(efe->uniqueID);\n\t\tiinfo->i_lenEAttr = le32_to_cpu(efe->lengthExtendedAttr);\n\t\tiinfo->i_lenAlloc = le32_to_cpu(efe->lengthAllocDescs);\n\t\tiinfo->i_checkpoint = le32_to_cpu(efe->checkpoint);\n\t}\n\tinode->i_generation = iinfo->i_unique;\n\n\t/* Sanity checks for files in ICB so that we don't get confused later */\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\t/*\n\t\t * For file in ICB data is stored in allocation descriptor\n\t\t * so sizes should match\n\t\t */\n\t\tif (iinfo->i_lenAlloc != inode->i_size)\n\t\t\tgoto out;\n\t\t/* File in ICB has to fit in there... */\n\t\tif (inode->i_size > inode->i_sb->s_blocksize -\n\t\t\t\t\tudf_file_entry_alloc_offset(inode))\n\t\t\tgoto out;\n\t}\n\n\tswitch (fe->icbTag.fileType) {\n\tcase ICBTAG_FILE_TYPE_DIRECTORY:\n\t\tinode->i_op = &udf_dir_inode_operations;\n\t\tinode->i_fop = &udf_dir_operations;\n\t\tinode->i_mode |= S_IFDIR;\n\t\tinc_nlink(inode);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_REALTIME:\n\tcase ICBTAG_FILE_TYPE_REGULAR:\n\tcase ICBTAG_FILE_TYPE_UNDEF:\n\tcase ICBTAG_FILE_TYPE_VAT20:\n\t\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\t\tinode->i_data.a_ops = &udf_adinicb_aops;\n\t\telse\n\t\t\tinode->i_data.a_ops = &udf_aops;\n\t\tinode->i_op = &udf_file_inode_operations;\n\t\tinode->i_fop = &udf_file_operations;\n\t\tinode->i_mode |= S_IFREG;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_BLOCK:\n\t\tinode->i_mode |= S_IFBLK;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_CHAR:\n\t\tinode->i_mode |= S_IFCHR;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_FIFO:\n\t\tinit_special_inode(inode, inode->i_mode | S_IFIFO, 0);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_SOCKET:\n\t\tinit_special_inode(inode, inode->i_mode | S_IFSOCK, 0);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_SYMLINK:\n\t\tinode->i_data.a_ops = &udf_symlink_aops;\n\t\tinode->i_op = &udf_symlink_inode_operations;\n\t\tinode->i_mode = S_IFLNK | S_IRWXUGO;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_MAIN:\n\t\tudf_debug(\"METADATA FILE-----\\n\");\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_MIRROR:\n\t\tudf_debug(\"METADATA MIRROR FILE-----\\n\");\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_BITMAP:\n\t\tudf_debug(\"METADATA BITMAP FILE-----\\n\");\n\t\tbreak;\n\tdefault:\n\t\tudf_err(inode->i_sb, \"(ino %ld) failed unknown file type=%d\\n\",\n\t\t\tinode->i_ino, fe->icbTag.fileType);\n\t\tgoto out;\n\t}\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tstruct deviceSpec *dsea =\n\t\t\t(struct deviceSpec *)udf_get_extendedattr(inode, 12, 1);\n\t\tif (dsea) {\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\tMKDEV(le32_to_cpu(dsea->majorDeviceIdent),\n\t\t\t\t      le32_to_cpu(dsea->minorDeviceIdent)));\n\t\t\t/* Developer ID ??? */\n\t\t} else\n\t\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tbrelse(bh);\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 2009,
    "line_new": 2009,
    "critical_vars": [
      "groups_per_flex"
    ],
    "function": "ext4_fill_flex_info",
    "filename": "linux/CVE-2012-2100/CVE-2012-2100_CWE-189_d50f2ab6f050311dbf7b8f5501b25f0bf64a439b_super.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 2014,
    "critical_vars": [
      "groups_per_flex"
    ],
    "function": "ext4_fill_flex_info",
    "filename": "linux/CVE-2012-2100/CVE-2012-2100_CWE-189_d50f2ab6f050311dbf7b8f5501b25f0bf64a439b_super.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 2014,
    "critical_vars": [
      "sbi->s_log_groups_per_flex"
    ],
    "function": "ext4_fill_flex_info",
    "filename": "linux/CVE-2012-2100/CVE-2012-2100_CWE-189_d50f2ab6f050311dbf7b8f5501b25f0bf64a439b_super.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 2016,
    "critical_vars": [
      "groups_per_flex"
    ],
    "function": "ext4_fill_flex_info",
    "filename": "linux/CVE-2012-2100/CVE-2012-2100_CWE-189_d50f2ab6f050311dbf7b8f5501b25f0bf64a439b_super.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 2018,
    "critical_vars": [
      "groups_per_flex"
    ],
    "function": "ext4_fill_flex_info",
    "filename": "linux/CVE-2012-2100/CVE-2012-2100_CWE-189_d50f2ab6f050311dbf7b8f5501b25f0bf64a439b_super.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 1920,
    "critical_vars": [
      "dst[dst_byte_offset]"
    ],
    "function": "ecryptfs_decode_from_filename",
    "filename": "linux/CVE-2014-9683/CVE-2014-9683_CWE-189_942080643bce061c3dd9d5718d3b745dcb39a8bc_crypto.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 183,
    "line_new": 185,
    "critical_vars": [
      "new->cid_mask"
    ],
    "function": "recalculate_apic_map",
    "filename": "linux/CVE-2013-6376/CVE-2013-6376_CWE-189_17d68b763f09a9ce824ae23eb62c9efc57b69271_lapic.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 186,
    "critical_vars": [
      "new->lid_mask"
    ],
    "function": "recalculate_apic_map",
    "filename": "linux/CVE-2013-6376/CVE-2013-6376_CWE-189_17d68b763f09a9ce824ae23eb62c9efc57b69271_lapic.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 412,
    "critical_vars": [
      "namelen"
    ],
    "function": "SYSCALL_DEFINE2",
    "filename": "linux/CVE-2011-2208/CVE-2011-2208_CWE-189_21c5977a836e399fc710ff2c5367845ed5c2527f_osf_sys.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 412,
    "critical_vars": [
      "len"
    ],
    "function": "SYSCALL_DEFINE2",
    "filename": "linux/CVE-2011-2208/CVE-2011-2208_CWE-189_21c5977a836e399fc710ff2c5367845ed5c2527f_osf_sys.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 597,
    "critical_vars": [
      "len"
    ],
    "function": "SYSCALL_DEFINE3",
    "filename": "linux/CVE-2011-2208/CVE-2011-2208_CWE-189_21c5977a836e399fc710ff2c5367845ed5c2527f_osf_sys.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 597,
    "critical_vars": [
      "long"
    ],
    "function": "SYSCALL_DEFINE3",
    "filename": "linux/CVE-2011-2208/CVE-2011-2208_CWE-189_21c5977a836e399fc710ff2c5367845ed5c2527f_osf_sys.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 652,
    "line_new": 652,
    "critical_vars": [
      "nbytes"
    ],
    "function": "SYSCALL_DEFINE5",
    "filename": "linux/CVE-2011-2208/CVE-2011-2208_CWE-189_21c5977a836e399fc710ff2c5367845ed5c2527f_osf_sys.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 1011,
    "critical_vars": [
      "status"
    ],
    "function": "SYSCALL_DEFINE4",
    "filename": "linux/CVE-2011-2208/CVE-2011-2208_CWE-189_21c5977a836e399fc710ff2c5367845ed5c2527f_osf_sys.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 1019,
    "line_new": 1020,
    "critical_vars": [
      "ret"
    ],
    "function": "SYSCALL_DEFINE4",
    "filename": "linux/CVE-2011-2208/CVE-2011-2208_CWE-189_21c5977a836e399fc710ff2c5367845ed5c2527f_osf_sys.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 1028,
    "critical_vars": [
      "err"
    ],
    "function": "SYSCALL_DEFINE4",
    "filename": "linux/CVE-2011-2208/CVE-2011-2208_CWE-189_21c5977a836e399fc710ff2c5367845ed5c2527f_osf_sys.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 280,
    "critical_vars": [
      "vma->vm_flags"
    ],
    "function": "*vma_to_resize",
    "filename": "linux/CVE-2011-2496/CVE-2011-2496_CWE-189_982134ba62618c2d69fbbbd166d0a11ee3b7e3d8_mremap.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 281,
    "critical_vars": [
      "new_len"
    ],
    "function": "*vma_to_resize",
    "filename": "linux/CVE-2011-2496/CVE-2011-2496_CWE-189_982134ba62618c2d69fbbbd166d0a11ee3b7e3d8_mremap.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 281,
    "critical_vars": [
      "new_len"
    ],
    "function": "*vma_to_resize",
    "filename": "linux/CVE-2011-2496/CVE-2011-2496_CWE-189_982134ba62618c2d69fbbbd166d0a11ee3b7e3d8_mremap.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 282,
    "critical_vars": [
      "pgoff"
    ],
    "function": "*vma_to_resize",
    "filename": "linux/CVE-2011-2496/CVE-2011-2496_CWE-189_982134ba62618c2d69fbbbd166d0a11ee3b7e3d8_mremap.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 284,
    "critical_vars": [
      "vma->vm_flags"
    ],
    "function": "*vma_to_resize",
    "filename": "linux/CVE-2011-2496/CVE-2011-2496_CWE-189_982134ba62618c2d69fbbbd166d0a11ee3b7e3d8_mremap.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 286,
    "critical_vars": [
      "pgoff"
    ],
    "function": "*vma_to_resize",
    "filename": "linux/CVE-2011-2496/CVE-2011-2496_CWE-189_982134ba62618c2d69fbbbd166d0a11ee3b7e3d8_mremap.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 287,
    "critical_vars": [
      "pgoff"
    ],
    "function": "*vma_to_resize",
    "filename": "linux/CVE-2011-2496/CVE-2011-2496_CWE-189_982134ba62618c2d69fbbbd166d0a11ee3b7e3d8_mremap.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 288,
    "critical_vars": [
      "new_len",
      "pgoff"
    ],
    "function": "*vma_to_resize",
    "filename": "linux/CVE-2011-2496/CVE-2011-2496_CWE-189_982134ba62618c2d69fbbbd166d0a11ee3b7e3d8_mremap.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 662,
    "critical_vars": [
      "sz"
    ],
    "function": "*xt_alloc_table_info",
    "filename": "linux/CVE-2016-3135/CVE-2016-3135_CWE-189_d157bd761585605b7882935ffb86286919f62ea1_x_tables.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 3282,
    "line_new": 3282,
    "critical_vars": [
      "*pos"
    ],
    "function": "build_unc_path_to_root",
    "filename": "linux/CVE-2013-4247/CVE-2013-4247_CWE-189_1fc29bacedeabb278080e31bb9c1ecb49f143c3b_connect.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "Fun-Call",
    "line_old": 3283,
    "line_new": 3283,
    "critical_vars": [
      "pplen",
      "vol->prepath",
      "pos"
    ],
    "function": "build_unc_path_to_root",
    "filename": "linux/CVE-2013-4247/CVE-2013-4247_CWE-189_1fc29bacedeabb278080e31bb9c1ecb49f143c3b_connect.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 329,
    "critical_vars": [
      "n"
    ],
    "function": "oz_usb_handle_ep_data",
    "filename": "linux/CVE-2015-4003/CVE-2015-4003_CWE-189_04bf464a5dfd9ade0dda918e44366c2c61fce80b_ozusbsvc1.c.diff",
    "function_code": "static void oz_usb_handle_ep_data(struct oz_usb_ctx *usb_ctx,\n\tstruct oz_usb_hdr *usb_hdr, int len)\n{\n\tstruct oz_data *data_hdr = (struct oz_data *)usb_hdr;\n\n\tswitch (data_hdr->format) {\n\tcase OZ_DATA_F_MULTIPLE_FIXED: {\n\t\t\tstruct oz_multiple_fixed *body =\n\t\t\t\t(struct oz_multiple_fixed *)data_hdr;\n\t\t\tu8 *data = body->data;\n\t\t\tint n;\n\t\t\tif (!body->unit_size)\n\t\t\t\tbreak;\n\t\t\tn = (len - sizeof(struct oz_multiple_fixed)+1)\n\t\t\t\t/ body->unit_size;\n\t\t\twhile (n--) {\n\t\t\t\toz_hcd_data_ind(usb_ctx->hport, body->endpoint,\n\t\t\t\t\tdata, body->unit_size);\n\t\t\t\tdata += body->unit_size;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase OZ_DATA_F_ISOC_FIXED: {\n\t\t\tstruct oz_isoc_fixed *body =\n\t\t\t\t(struct oz_isoc_fixed *)data_hdr;\n\t\t\tint data_len = len-sizeof(struct oz_isoc_fixed)+1;\n\t\t\tint unit_size = body->unit_size;\n\t\t\tu8 *data = body->data;\n\t\t\tint count;\n\t\t\tint i;\n\n\t\t\tif (!unit_size)\n\t\t\t\tbreak;\n\t\t\tcount = data_len/unit_size;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\toz_hcd_data_ind(usb_ctx->hport,\n\t\t\t\t\tbody->endpoint, data, unit_size);\n\t\t\t\tdata += unit_size;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 329,
    "critical_vars": [
      "n"
    ],
    "function": "oz_usb_handle_ep_data",
    "filename": "linux/CVE-2015-4003/CVE-2015-4003_CWE-189_04bf464a5dfd9ade0dda918e44366c2c61fce80b_ozusbsvc1.c.diff",
    "function_code": "static void oz_usb_handle_ep_data(struct oz_usb_ctx *usb_ctx,\n\tstruct oz_usb_hdr *usb_hdr, int len)\n{\n\tstruct oz_data *data_hdr = (struct oz_data *)usb_hdr;\n\n\tswitch (data_hdr->format) {\n\tcase OZ_DATA_F_MULTIPLE_FIXED: {\n\t\t\tstruct oz_multiple_fixed *body =\n\t\t\t\t(struct oz_multiple_fixed *)data_hdr;\n\t\t\tu8 *data = body->data;\n\t\t\tunsigned int n;\n\t\t\tif (!body->unit_size ||\n\t\t\t\tlen < sizeof(struct oz_multiple_fixed) - 1)\n\t\t\t\tbreak;\n\t\t\tn = (len - (sizeof(struct oz_multiple_fixed) - 1))\n\t\t\t\t/ body->unit_size;\n\t\t\twhile (n--) {\n\t\t\t\toz_hcd_data_ind(usb_ctx->hport, body->endpoint,\n\t\t\t\t\tdata, body->unit_size);\n\t\t\t\tdata += body->unit_size;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase OZ_DATA_F_ISOC_FIXED: {\n\t\t\tstruct oz_isoc_fixed *body =\n\t\t\t\t(struct oz_isoc_fixed *)data_hdr;\n\t\t\tint data_len = len-sizeof(struct oz_isoc_fixed)+1;\n\t\t\tint unit_size = body->unit_size;\n\t\t\tu8 *data = body->data;\n\t\t\tint count;\n\t\t\tint i;\n\n\t\t\tif (!unit_size)\n\t\t\t\tbreak;\n\t\t\tcount = data_len/unit_size;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\toz_hcd_data_ind(usb_ctx->hport,\n\t\t\t\t\tbody->endpoint, data, unit_size);\n\t\t\t\tdata += unit_size;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 330,
    "critical_vars": [
      "body->unit_size"
    ],
    "function": "oz_usb_handle_ep_data",
    "filename": "linux/CVE-2015-4003/CVE-2015-4003_CWE-189_04bf464a5dfd9ade0dda918e44366c2c61fce80b_ozusbsvc1.c.diff",
    "function_code": "static void oz_usb_handle_ep_data(struct oz_usb_ctx *usb_ctx,\n\tstruct oz_usb_hdr *usb_hdr, int len)\n{\n\tstruct oz_data *data_hdr = (struct oz_data *)usb_hdr;\n\n\tswitch (data_hdr->format) {\n\tcase OZ_DATA_F_MULTIPLE_FIXED: {\n\t\t\tstruct oz_multiple_fixed *body =\n\t\t\t\t(struct oz_multiple_fixed *)data_hdr;\n\t\t\tu8 *data = body->data;\n\t\t\tunsigned int n;\n\t\t\tif (!body->unit_size ||\n\t\t\t\tlen < sizeof(struct oz_multiple_fixed) - 1)\n\t\t\t\tbreak;\n\t\t\tn = (len - (sizeof(struct oz_multiple_fixed) - 1))\n\t\t\t\t/ body->unit_size;\n\t\t\twhile (n--) {\n\t\t\t\toz_hcd_data_ind(usb_ctx->hport, body->endpoint,\n\t\t\t\t\tdata, body->unit_size);\n\t\t\t\tdata += body->unit_size;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase OZ_DATA_F_ISOC_FIXED: {\n\t\t\tstruct oz_isoc_fixed *body =\n\t\t\t\t(struct oz_isoc_fixed *)data_hdr;\n\t\t\tint data_len = len-sizeof(struct oz_isoc_fixed)+1;\n\t\t\tint unit_size = body->unit_size;\n\t\t\tu8 *data = body->data;\n\t\t\tint count;\n\t\t\tint i;\n\n\t\t\tif (!unit_size)\n\t\t\t\tbreak;\n\t\t\tcount = data_len/unit_size;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\toz_hcd_data_ind(usb_ctx->hport,\n\t\t\t\t\tbody->endpoint, data, unit_size);\n\t\t\t\tdata += unit_size;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 332,
    "critical_vars": [
      "n"
    ],
    "function": "oz_usb_handle_ep_data",
    "filename": "linux/CVE-2015-4003/CVE-2015-4003_CWE-189_04bf464a5dfd9ade0dda918e44366c2c61fce80b_ozusbsvc1.c.diff",
    "function_code": "static void oz_usb_handle_ep_data(struct oz_usb_ctx *usb_ctx,\n\tstruct oz_usb_hdr *usb_hdr, int len)\n{\n\tstruct oz_data *data_hdr = (struct oz_data *)usb_hdr;\n\n\tswitch (data_hdr->format) {\n\tcase OZ_DATA_F_MULTIPLE_FIXED: {\n\t\t\tstruct oz_multiple_fixed *body =\n\t\t\t\t(struct oz_multiple_fixed *)data_hdr;\n\t\t\tu8 *data = body->data;\n\t\t\tunsigned int n;\n\t\t\tif (!body->unit_size ||\n\t\t\t\tlen < sizeof(struct oz_multiple_fixed) - 1)\n\t\t\t\tbreak;\n\t\t\tn = (len - (sizeof(struct oz_multiple_fixed) - 1))\n\t\t\t\t/ body->unit_size;\n\t\t\twhile (n--) {\n\t\t\t\toz_hcd_data_ind(usb_ctx->hport, body->endpoint,\n\t\t\t\t\tdata, body->unit_size);\n\t\t\t\tdata += body->unit_size;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase OZ_DATA_F_ISOC_FIXED: {\n\t\t\tstruct oz_isoc_fixed *body =\n\t\t\t\t(struct oz_isoc_fixed *)data_hdr;\n\t\t\tint data_len = len-sizeof(struct oz_isoc_fixed)+1;\n\t\t\tint unit_size = body->unit_size;\n\t\t\tu8 *data = body->data;\n\t\t\tint count;\n\t\t\tint i;\n\n\t\t\tif (!unit_size)\n\t\t\t\tbreak;\n\t\t\tcount = data_len/unit_size;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\toz_hcd_data_ind(usb_ctx->hport,\n\t\t\t\t\tbody->endpoint, data, unit_size);\n\t\t\t\tdata += unit_size;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 375,
    "critical_vars": [
      "buffer"
    ],
    "function": "chk_mem_check",
    "filename": "platform_bionic/CVE-2012-2674/CVE-2012-2674_CWE-189_7f5aa4f35e23fd37425b3a5041737cdf58f87385_malloc_debug_leak.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 375,
    "critical_vars": [
      "size"
    ],
    "function": "chk_mem_check",
    "filename": "platform_bionic/CVE-2012-2674/CVE-2012-2674_CWE-189_7f5aa4f35e23fd37425b3a5041737cdf58f87385_malloc_debug_leak.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 376,
    "critical_vars": [
      "size"
    ],
    "function": "chk_mem_check",
    "filename": "platform_bionic/CVE-2012-2674/CVE-2012-2674_CWE-189_7f5aa4f35e23fd37425b3a5041737cdf58f87385_malloc_debug_leak.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 379,
    "critical_vars": [
      "buffer"
    ],
    "function": "chk_mem_check",
    "filename": "platform_bionic/CVE-2012-2674/CVE-2012-2674_CWE-189_7f5aa4f35e23fd37425b3a5041737cdf58f87385_malloc_debug_leak.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 508,
    "critical_vars": [
      "base"
    ],
    "function": "leak_malloc",
    "filename": "platform_bionic/CVE-2012-2674/CVE-2012-2674_CWE-189_7f5aa4f35e23fd37425b3a5041737cdf58f87385_malloc_debug_leak.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 512,
    "critical_vars": [
      "size"
    ],
    "function": "leak_malloc",
    "filename": "platform_bionic/CVE-2012-2674/CVE-2012-2674_CWE-189_7f5aa4f35e23fd37425b3a5041737cdf58f87385_malloc_debug_leak.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 513,
    "critical_vars": [
      "size"
    ],
    "function": "leak_malloc",
    "filename": "platform_bionic/CVE-2012-2674/CVE-2012-2674_CWE-189_7f5aa4f35e23fd37425b3a5041737cdf58f87385_malloc_debug_leak.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 517,
    "critical_vars": [
      "base"
    ],
    "function": "leak_malloc",
    "filename": "platform_bionic/CVE-2012-2674/CVE-2012-2674_CWE-189_7f5aa4f35e23fd37425b3a5041737cdf58f87385_malloc_debug_leak.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 627,
    "critical_vars": [
      "size"
    ],
    "function": "leak_memalign",
    "filename": "platform_bionic/CVE-2012-2674/CVE-2012-2674_CWE-189_7f5aa4f35e23fd37425b3a5041737cdf58f87385_malloc_debug_leak.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 256,
    "line_new": 256,
    "critical_vars": [
      "cmd"
    ],
    "function": "*php_escape_shell_cmd",
    "filename": "php-src/CVE-2016-1904/CVE-2016-1904_CWE-189_2871c70efaaaa0f102557a17c727fd4d5204dd4b_exec.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 348,
    "line_new": 348,
    "critical_vars": [
      "cmd"
    ],
    "function": "*php_escape_shell_arg",
    "filename": "php-src/CVE-2016-1904/CVE-2016-1904_CWE-189_2871c70efaaaa0f102557a17c727fd4d5204dd4b_exec.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 823,
    "critical_vars": [
      "q"
    ],
    "function": "cdf_read_property_info",
    "filename": "php-src/CVE-2014-3587/CVE-2014-3587_CWE-189_7ba1409a1aee5925180de546057ddd84ff267947_cdf.c.diff",
    "function_code": "cdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    uint32_t offs, cdf_property_info_t **info, size_t *count, size_t *maxcount)\n{\n\tconst cdf_section_header_t *shp;\n\tcdf_section_header_t sh;\n\tconst uint8_t *p, *q, *e;\n\tint16_t s16;\n\tint32_t s32;\n\tuint32_t u32;\n\tint64_t s64;\n\tuint64_t u64;\n\tcdf_timestamp_t tp;\n\tsize_t i, o, o4, nelements, j;\n\tcdf_property_info_t *inp;\n\n\tif (offs > UINT32_MAX / 4) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tshp = CAST(const cdf_section_header_t *, (const void *)\n\t    ((const char *)sst->sst_tab + offs));\n\tif (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1)\n\t\tgoto out;\n\tsh.sh_len = CDF_TOLE4(shp->sh_len);\n#define CDF_SHLEN_LIMIT (UINT32_MAX / 8)\n\tif (sh.sh_len > CDF_SHLEN_LIMIT) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tsh.sh_properties = CDF_TOLE4(shp->sh_properties);\n#define CDF_PROP_LIMIT (UINT32_MAX / (4 * sizeof(*inp)))\n\tif (sh.sh_properties > CDF_PROP_LIMIT)\n\t\tgoto out;\n\tDPRINTF((\"section len: %u properties %u\\n\", sh.sh_len,\n\t    sh.sh_properties));\n\tif (*maxcount) {\n\t\tif (*maxcount > CDF_PROP_LIMIT)\n\t\t\tgoto out;\n\t\t*maxcount += sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t} else {\n\t\t*maxcount = sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    malloc(*maxcount * sizeof(*inp)));\n\t}\n\tif (inp == NULL)\n\t\tgoto out;\n\t*info = inp;\n\tinp += *count;\n\t*count += sh.sh_properties;\n\tp = CAST(const uint8_t *, (const void *)\n\t    ((const char *)(const void *)sst->sst_tab +\n\t    offs + sizeof(sh)));\n\te = CAST(const uint8_t *, (const void *)\n\t    (((const char *)(const void *)shp) + sh.sh_len));\n\tif (cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)\n\t\tgoto out;\n\tfor (i = 0; i < sh.sh_properties; i++) {\n\t\tq = (const uint8_t *)(const void *)\n\t\t    ((const char *)(const void *)p +\n\t\t    CDF_GETUINT32(p, (i << 1) + 1)) - 2 * sizeof(uint32_t);\n\t\tif (q > e) {\n\t\t\tDPRINTF((\"Ran of the end %p > %p\\n\", q, e));\n\t\t\tgoto out;\n\t\t}\n\t\tinp[i].pi_id = CDF_GETUINT32(p, i << 1);\n\t\tinp[i].pi_type = CDF_GETUINT32(q, 0);\n\t\tDPRINTF((\"%d) id=%x type=%x offs=%x,%d\\n\", i, inp[i].pi_id,\n\t\t    inp[i].pi_type, q - p, CDF_GETUINT32(p, (i << 1) + 1)));\n\t\tif (inp[i].pi_type & CDF_VECTOR) {\n\t\t\tnelements = CDF_GETUINT32(q, 1);\n\t\t\to = 2;\n\t\t} else {\n\t\t\tnelements = 1;\n\t\t\to = 1;\n\t\t}\n\t\to4 = o * sizeof(uint32_t);\n\t\tif (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED))\n\t\t\tgoto unknown;\n\t\tswitch (inp[i].pi_type & CDF_TYPEMASK) {\n\t\tcase CDF_NULL:\n\t\tcase CDF_EMPTY:\n\t\t\tbreak;\n\t\tcase CDF_SIGNED16:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s16, &q[o4], sizeof(s16));\n\t\t\tinp[i].pi_s16 = CDF_TOLE2(s16);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s32, &q[o4], sizeof(s32));\n\t\t\tinp[i].pi_s32 = CDF_TOLE4((uint32_t)s32);\n\t\t\tbreak;\n\t\tcase CDF_BOOL:\n\t\tcase CDF_UNSIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u32, &q[o4], sizeof(u32));\n\t\t\tinp[i].pi_u32 = CDF_TOLE4(u32);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s64, &q[o4], sizeof(s64));\n\t\t\tinp[i].pi_s64 = CDF_TOLE8((uint64_t)s64);\n\t\t\tbreak;\n\t\tcase CDF_UNSIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u64, &q[o4], sizeof(u64));\n\t\t\tinp[i].pi_u64 = CDF_TOLE8((uint64_t)u64);\n\t\t\tbreak;\n\t\tcase CDF_LENGTH32_STRING:\n\t\tcase CDF_LENGTH32_WSTRING:\n\t\t\tif (nelements > 1) {\n\t\t\t\tsize_t nelem = inp - *info;\n\t\t\t\tif (*maxcount > CDF_PROP_LIMIT\n\t\t\t\t    || nelements > CDF_PROP_LIMIT)\n\t\t\t\t\tgoto out;\n\t\t\t\t*maxcount += nelements;\n\t\t\t\tinp = CAST(cdf_property_info_t *,\n\t\t\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t\t\t\tif (inp == NULL)\n\t\t\t\t\tgoto out;\n\t\t\t\t*info = inp;\n\t\t\t\tinp = *info + nelem;\n\t\t\t}\n\t\t\tDPRINTF((\"nelements = %d\\n\", nelements));\n\t\t\tfor (j = 0; j < nelements; j++, i++) {\n\t\t\t\tuint32_t l = CDF_GETUINT32(q, o);\n\t\t\t\tinp[i].pi_str.s_len = l;\n\t\t\t\tinp[i].pi_str.s_buf = (const char *)\n\t\t\t\t    (const void *)(&q[o4 + sizeof(l)]);\n\t\t\t\tDPRINTF((\"l = %d, r = %d, s = %s\\n\", l,\n\t\t\t\t    CDF_ROUND(l, sizeof(l)),\n\t\t\t\t    inp[i].pi_str.s_buf));\n\t\t\t\tl = 4 + (uint32_t)CDF_ROUND(l, sizeof(l));\n\t\t\t\to += l >> 2;\n\t\t\t\tif (q + o >= e)\n\t\t\t\t\tgoto out;\n\t\t\t\to4 = o * sizeof(uint32_t);\n\t\t\t}\n\t\t\ti--;\n\t\t\tbreak;\n\t\tcase CDF_FILETIME:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&tp, &q[o4], sizeof(tp));\n\t\t\tinp[i].pi_tp = CDF_TOLE8((uint64_t)tp);\n\t\t\tbreak;\n\t\tcase CDF_CLIPBOARD:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tdefault:\n\t\tunknown:\n\t\t\tDPRINTF((\"Don't know how to deal with %x\\n\",\n\t\t\t    inp[i].pi_type));\n\t\t\tgoto out;\n\t\t}\n\t}\n\treturn 0;\nout:\n\tfree(*info);\n\treturn -1;\n}",
    "label": "False"
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 382,
    "line_new": 386,
    "critical_vars": [
      "n"
    ],
    "function": "malloc",
    "filename": "bdwgc/CVE-2012-2673/CVE-2012-2673_CWE-189_6a93f8e5bcad22137f41b6c60a1c7384baaec2b3_malloc.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 380,
    "critical_vars": [
      "lb",
      "n"
    ],
    "function": "malloc",
    "filename": "bdwgc/CVE-2012-2673/CVE-2012-2673_CWE-189_e10c1eb9908c2774c16b3148b30d2f3823d66a9a_malloc.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 386,
    "critical_vars": [
      "lb",
      "n"
    ],
    "function": "malloc",
    "filename": "bdwgc/CVE-2012-2673/CVE-2012-2673_CWE-189_83231d0ab5ed60015797c3d1ad9056295ac3b2bb_malloc.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 172,
    "critical_vars": [
      "lb_rounded"
    ],
    "function": "GC_generic_malloc",
    "filename": "bdwgc/CVE-2012-2673/CVE-2012-2673_CWE-189_be9df82919960214ee4b9d3313523bff44fd99e1_malloc.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 185,
    "critical_vars": [
      "lb_rounded"
    ],
    "function": "GC_generic_malloc_ignore_off_page",
    "filename": "bdwgc/CVE-2012-2673/CVE-2012-2673_CWE-189_be9df82919960214ee4b9d3313523bff44fd99e1_mallocx.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 64,
    "critical_vars": [
      "string->space"
    ],
    "function": "",
    "filename": "pango/CVE-2009-1194/CVE-2009-1194_CWE-189_4de30e5500eaeb49f4bf0b7a07f718e149a2ed5e_glyphstring.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 65,
    "critical_vars": [
      "string->space"
    ],
    "function": "",
    "filename": "pango/CVE-2009-1194/CVE-2009-1194_CWE-189_4de30e5500eaeb49f4bf0b7a07f718e149a2ed5e_glyphstring.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 66,
    "critical_vars": [
      "string->space"
    ],
    "function": "",
    "filename": "pango/CVE-2009-1194/CVE-2009-1194_CWE-189_4de30e5500eaeb49f4bf0b7a07f718e149a2ed5e_glyphstring.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 68,
    "critical_vars": [
      "string->space"
    ],
    "function": "",
    "filename": "pango/CVE-2009-1194/CVE-2009-1194_CWE-189_4de30e5500eaeb49f4bf0b7a07f718e149a2ed5e_glyphstring.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 69,
    "critical_vars": [
      "max_space"
    ],
    "function": "",
    "filename": "pango/CVE-2009-1194/CVE-2009-1194_CWE-189_4de30e5500eaeb49f4bf0b7a07f718e149a2ed5e_glyphstring.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 71,
    "critical_vars": [
      "new_len"
    ],
    "function": "",
    "filename": "pango/CVE-2009-1194/CVE-2009-1194_CWE-189_4de30e5500eaeb49f4bf0b7a07f718e149a2ed5e_glyphstring.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 72,
    "critical_vars": [
      "more_space"
    ],
    "function": "",
    "filename": "pango/CVE-2009-1194/CVE-2009-1194_CWE-189_4de30e5500eaeb49f4bf0b7a07f718e149a2ed5e_glyphstring.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 74,
    "critical_vars": [
      "more_space"
    ],
    "function": "",
    "filename": "pango/CVE-2009-1194/CVE-2009-1194_CWE-189_4de30e5500eaeb49f4bf0b7a07f718e149a2ed5e_glyphstring.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 76,
    "critical_vars": [
      "more_space"
    ],
    "function": "",
    "filename": "pango/CVE-2009-1194/CVE-2009-1194_CWE-189_4de30e5500eaeb49f4bf0b7a07f718e149a2ed5e_glyphstring.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 78,
    "critical_vars": [
      "guint"
    ],
    "function": "",
    "filename": "pango/CVE-2009-1194/CVE-2009-1194_CWE-189_4de30e5500eaeb49f4bf0b7a07f718e149a2ed5e_glyphstring.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 80,
    "critical_vars": [
      "new_len"
    ],
    "function": "",
    "filename": "pango/CVE-2009-1194/CVE-2009-1194_CWE-189_4de30e5500eaeb49f4bf0b7a07f718e149a2ed5e_glyphstring.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 85,
    "critical_vars": [
      "string->space"
    ],
    "function": "",
    "filename": "pango/CVE-2009-1194/CVE-2009-1194_CWE-189_4de30e5500eaeb49f4bf0b7a07f718e149a2ed5e_glyphstring.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 509,
    "critical_vars": [
      "bits_left"
    ],
    "function": "lzxd_decompress",
    "filename": "libmspack/CVE-2015-4471/CVE-2015-4471_CWE-189_18b6a2cc0b87536015bedd4f7763e6b02d5aa4f3_lzxd.c.diff",
    "function_code": "int lzxd_decompress(struct lzxd_stream *lzx, off_t out_bytes) {\n  /* bitstream and huffman reading variables */\n  register unsigned int bit_buffer;\n  register int bits_left, i=0;\n  unsigned char *i_ptr, *i_end;\n  register unsigned short sym;\n\n  int match_length, length_footer, extra, verbatim_bits, bytes_todo;\n  int this_run, main_element, aligned_bits, j;\n  unsigned char *window, *runsrc, *rundest, buf[12];\n  unsigned int frame_size=0, end_frame, match_offset, window_posn;\n  unsigned int R0, R1, R2;\n\n  /* easy answers */\n  if (!lzx || (out_bytes < 0)) return MSPACK_ERR_ARGS;\n  if (lzx->error) return lzx->error;\n\n  /* flush out any stored-up bytes before we begin */\n  i = lzx->o_end - lzx->o_ptr;\n  if ((off_t) i > out_bytes) i = (int) out_bytes;\n  if (i) {\n    if (lzx->sys->write(lzx->output, lzx->o_ptr, i) != i) {\n      return lzx->error = MSPACK_ERR_WRITE;\n    }\n    lzx->o_ptr  += i;\n    lzx->offset += i;\n    out_bytes   -= i;\n  }\n  if (out_bytes == 0) return MSPACK_ERR_OK;\n\n  /* restore local state */\n  RESTORE_BITS;\n  window = lzx->window;\n  window_posn = lzx->window_posn;\n  R0 = lzx->R0;\n  R1 = lzx->R1;\n  R2 = lzx->R2;\n\n  end_frame = (unsigned int)((lzx->offset + out_bytes) / LZX_FRAME_SIZE) + 1;\n\n  while (lzx->frame < end_frame) {\n    /* have we reached the reset interval? (if there is one?) */\n    if (lzx->reset_interval && ((lzx->frame % lzx->reset_interval) == 0)) {\n      if (lzx->block_remaining) {\n\tD((\"%d bytes remaining at reset interval\", lzx->block_remaining))\n\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n      }\n\n      /* re-read the intel header and reset the huffman lengths */\n      lzxd_reset_state(lzx);\n      R0 = lzx->R0;\n      R1 = lzx->R1;\n      R2 = lzx->R2;\n    }\n\n    /* LZX DELTA format has chunk_size, not present in LZX format */\n    if (lzx->is_delta) {\n      ENSURE_BITS(16);\n      REMOVE_BITS(16);\n    }\n\n    /* read header if necessary */\n    if (!lzx->header_read) {\n      /* read 1 bit. if bit=0, intel filesize = 0.\n       * if bit=1, read intel filesize (32 bits) */\n      j = 0; READ_BITS(i, 1); if (i) { READ_BITS(i, 16); READ_BITS(j, 16); }\n      lzx->intel_filesize = (i << 16) | j;\n      lzx->header_read = 1;\n    } \n\n    /* calculate size of frame: all frames are 32k except the final frame\n     * which is 32kb or less. this can only be calculated when lzx->length\n     * has been filled in. */\n    frame_size = LZX_FRAME_SIZE;\n    if (lzx->length && (lzx->length - lzx->offset) < (off_t)frame_size) {\n      frame_size = lzx->length - lzx->offset;\n    }\n\n    /* decode until one more frame is available */\n    bytes_todo = lzx->frame_posn + frame_size - window_posn;\n    while (bytes_todo > 0) {\n      /* initialise new block, if one is needed */\n      if (lzx->block_remaining == 0) {\n\t/* realign if previous block was an odd-sized UNCOMPRESSED block */\n\tif ((lzx->block_type == LZX_BLOCKTYPE_UNCOMPRESSED) &&\n\t    (lzx->block_length & 1))\n\t{\n\t  READ_IF_NEEDED;\n\t  i_ptr++;\n\t}\n\n\t/* read block type (3 bits) and block length (24 bits) */\n\tREAD_BITS(lzx->block_type, 3);\n\tREAD_BITS(i, 16); READ_BITS(j, 8);\n\tlzx->block_remaining = lzx->block_length = (i << 8) | j;\n\t/*D((\"new block t%d len %u\", lzx->block_type, lzx->block_length))*/\n\n\t/* read individual block headers */\n\tswitch (lzx->block_type) {\n\tcase LZX_BLOCKTYPE_ALIGNED:\n\t  /* read lengths of and build aligned huffman decoding tree */\n\t  for (i = 0; i < 8; i++) { READ_BITS(j, 3); lzx->ALIGNED_len[i] = j; }\n\t  BUILD_TABLE(ALIGNED);\n\t  /* no break -- rest of aligned header is same as verbatim */\n\tcase LZX_BLOCKTYPE_VERBATIM:\n\t  /* read lengths of and build main huffman decoding tree */\n\t  READ_LENGTHS(MAINTREE, 0, 256);\n\t  READ_LENGTHS(MAINTREE, 256, LZX_NUM_CHARS + lzx->num_offsets);\n\t  BUILD_TABLE(MAINTREE);\n\t  /* if the literal 0xE8 is anywhere in the block... */\n\t  if (lzx->MAINTREE_len[0xE8] != 0) lzx->intel_started = 1;\n\t  /* read lengths of and build lengths huffman decoding tree */\n\t  READ_LENGTHS(LENGTH, 0, LZX_NUM_SECONDARY_LENGTHS);\n\t  BUILD_TABLE_MAYBE_EMPTY(LENGTH);\n\t  break;\n\n\tcase LZX_BLOCKTYPE_UNCOMPRESSED:\n\t  /* because we can't assume otherwise */\n\t  lzx->intel_started = 1;\n\n\t  /* read 1-16 (not 0-15) bits to align to bytes */\n\t  if (bits_left == 0) ENSURE_BITS(16);\n\t  bits_left = 0; bit_buffer = 0;\n\n\t  /* read 12 bytes of stored R0 / R1 / R2 values */\n\t  for (rundest = &buf[0], i = 0; i < 12; i++) {\n\t    READ_IF_NEEDED;\n\t    *rundest++ = *i_ptr++;\n\t  }\n\t  R0 = buf[0] | (buf[1] << 8) | (buf[2]  << 16) | (buf[3]  << 24);\n\t  R1 = buf[4] | (buf[5] << 8) | (buf[6]  << 16) | (buf[7]  << 24);\n\t  R2 = buf[8] | (buf[9] << 8) | (buf[10] << 16) | (buf[11] << 24);\n\t  break;\n\n\tdefault:\n\t  D((\"bad block type\"))\n\t  return lzx->error = MSPACK_ERR_DECRUNCH;\n\t}\n      }\n\n      /* decode more of the block:\n       * run = min(what's available, what's needed) */\n      this_run = lzx->block_remaining;\n      if (this_run > bytes_todo) this_run = bytes_todo;\n\n      /* assume we decode exactly this_run bytes, for now */\n      bytes_todo           -= this_run;\n      lzx->block_remaining -= this_run;\n\n      /* decode at least this_run bytes */\n      switch (lzx->block_type) {\n      case LZX_BLOCKTYPE_VERBATIM:\n\twhile (this_run > 0) {\n\t  READ_HUFFSYM(MAINTREE, main_element);\n\t  if (main_element < LZX_NUM_CHARS) {\n\t    /* literal: 0 to LZX_NUM_CHARS-1 */\n\t    window[window_posn++] = main_element;\n\t    this_run--;\n\t  }\n\t  else {\n\t    /* match: LZX_NUM_CHARS + ((slot<<3) | length_header (3 bits)) */\n\t    main_element -= LZX_NUM_CHARS;\n\n\t    /* get match length */\n\t    match_length = main_element & LZX_NUM_PRIMARY_LENGTHS;\n\t    if (match_length == LZX_NUM_PRIMARY_LENGTHS) {\n\t      if (lzx->LENGTH_empty) {\n                D((\"LENGTH symbol needed but tree is empty\"))\n                return lzx->error = MSPACK_ERR_DECRUNCH;\n              }\n\t      READ_HUFFSYM(LENGTH, length_footer);\n\t      match_length += length_footer;\n\t    }\n\t    match_length += LZX_MIN_MATCH;\n\n\t    /* get match offset */\n\t    switch ((match_offset = (main_element >> 3))) {\n\t    case 0: match_offset = R0;                                  break;\n\t    case 1: match_offset = R1; R1=R0;        R0 = match_offset; break;\n\t    case 2: match_offset = R2; R2=R0;        R0 = match_offset; break;\n\t    case 3: match_offset = 1;  R2=R1; R1=R0; R0 = match_offset; break;\n\t    default:\n\t      extra = (match_offset >= 36) ? 17 : extra_bits[match_offset];\n\t      READ_BITS(verbatim_bits, extra);\n\t      match_offset = position_base[match_offset] - 2 + verbatim_bits;\n\t      R2 = R1; R1 = R0; R0 = match_offset;\n\t    }\n\n\t    /* LZX DELTA uses max match length to signal even longer match */\n\t    if (match_length == LZX_MAX_MATCH && lzx->is_delta) {\n\t\tint extra_len = 0;\n\t\tENSURE_BITS(3); /* 4 entry huffman tree */\n\t\tif (PEEK_BITS(1) == 0) {\n\t\t    REMOVE_BITS(1); /* '0' -> 8 extra length bits */\n\t\t    READ_BITS(extra_len, 8);\n\t\t}\n\t\telse if (PEEK_BITS(2) == 2) {\n\t\t    REMOVE_BITS(2); /* '10' -> 10 extra length bits + 0x100 */\n\t\t    READ_BITS(extra_len, 10);\n\t\t    extra_len += 0x100;\n\t\t}\n\t\telse if (PEEK_BITS(3) == 6) {\n\t\t    REMOVE_BITS(3); /* '110' -> 12 extra length bits + 0x500 */\n\t\t    READ_BITS(extra_len, 12);\n\t\t    extra_len += 0x500;\n\t\t}\n\t\telse {\n\t\t    REMOVE_BITS(3); /* '111' -> 15 extra length bits */\n\t\t    READ_BITS(extra_len, 15);\n\t\t}\n\t\tmatch_length += extra_len;\n\t    }\n\n\t    if ((window_posn + match_length) > lzx->window_size) {\n\t      D((\"match ran over window wrap\"))\n\t      return lzx->error = MSPACK_ERR_DECRUNCH;\n\t    }\n\t    \n\t    /* copy match */\n\t    rundest = &window[window_posn];\n\t    i = match_length;\n\t    /* does match offset wrap the window? */\n\t    if (match_offset > window_posn) {\n\t      if (match_offset > lzx->offset &&\n\t\t  (match_offset - window_posn) > lzx->ref_data_size)\n\t      {\n\t\tD((\"match offset beyond LZX stream\"))\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n\t      }\n\t      /* j = length from match offset to end of window */\n\t      j = match_offset - window_posn;\n\t      if (j > (int) lzx->window_size) {\n\t\tD((\"match offset beyond window boundaries\"))\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n\t      }\n\t      runsrc = &window[lzx->window_size - j];\n\t      if (j < i) {\n\t\t/* if match goes over the window edge, do two copy runs */\n\t\ti -= j; while (j-- > 0) *rundest++ = *runsrc++;\n\t\trunsrc = window;\n\t      }\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\t    else {\n\t      runsrc = rundest - match_offset;\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\n\t    this_run    -= match_length;\n\t    window_posn += match_length;\n\t  }\n\t} /* while (this_run > 0) */\n\tbreak;\n\n      case LZX_BLOCKTYPE_ALIGNED:\n\twhile (this_run > 0) {\n\t  READ_HUFFSYM(MAINTREE, main_element);\n\t  if (main_element < LZX_NUM_CHARS) {\n\t    /* literal: 0 to LZX_NUM_CHARS-1 */\n\t    window[window_posn++] = main_element;\n\t    this_run--;\n\t  }\n\t  else {\n\t    /* match: LZX_NUM_CHARS + ((slot<<3) | length_header (3 bits)) */\n\t    main_element -= LZX_NUM_CHARS;\n\n\t    /* get match length */\n\t    match_length = main_element & LZX_NUM_PRIMARY_LENGTHS;\n\t    if (match_length == LZX_NUM_PRIMARY_LENGTHS) {\n              if (lzx->LENGTH_empty) {\n                D((\"LENGTH symbol needed but tree is empty\"))\n                return lzx->error = MSPACK_ERR_DECRUNCH;\n              } \n\t      READ_HUFFSYM(LENGTH, length_footer);\n\t      match_length += length_footer;\n\t    }\n\t    match_length += LZX_MIN_MATCH;\n\n\t    /* get match offset */\n\t    switch ((match_offset = (main_element >> 3))) {\n\t    case 0: match_offset = R0;                             break;\n\t    case 1: match_offset = R1; R1 = R0; R0 = match_offset; break;\n\t    case 2: match_offset = R2; R2 = R0; R0 = match_offset; break;\n\t    default:\n\t      extra = (match_offset >= 36) ? 17 : extra_bits[match_offset];\n\t      match_offset = position_base[match_offset] - 2;\n\t      if (extra > 3) {\n\t\t/* verbatim and aligned bits */\n\t\textra -= 3;\n\t\tREAD_BITS(verbatim_bits, extra);\n\t\tmatch_offset += (verbatim_bits << 3);\n\t\tREAD_HUFFSYM(ALIGNED, aligned_bits);\n\t\tmatch_offset += aligned_bits;\n\t      }\n\t      else if (extra == 3) {\n\t\t/* aligned bits only */\n\t\tREAD_HUFFSYM(ALIGNED, aligned_bits);\n\t\tmatch_offset += aligned_bits;\n\t      }\n\t      else if (extra > 0) { /* extra==1, extra==2 */\n\t\t/* verbatim bits only */\n\t\tREAD_BITS(verbatim_bits, extra);\n\t\tmatch_offset += verbatim_bits;\n\t      }\n\t      else /* extra == 0 */ {\n\t\t/* ??? not defined in LZX specification! */\n\t\tmatch_offset = 1;\n\t      }\n\t      /* update repeated offset LRU queue */\n\t      R2 = R1; R1 = R0; R0 = match_offset;\n\t    }\n\n\t    /* LZX DELTA uses max match length to signal even longer match */\n\t    if (match_length == LZX_MAX_MATCH && lzx->is_delta) {\n\t\tint extra_len = 0;\n\t\tENSURE_BITS(3); /* 4 entry huffman tree */\n\t\tif (PEEK_BITS(1) == 0) {\n\t\t    REMOVE_BITS(1); /* '0' -> 8 extra length bits */\n\t\t    READ_BITS(extra_len, 8);\n\t\t}\n\t\telse if (PEEK_BITS(2) == 2) {\n\t\t    REMOVE_BITS(2); /* '10' -> 10 extra length bits + 0x100 */\n\t\t    READ_BITS(extra_len, 10);\n\t\t    extra_len += 0x100;\n\t\t}\n\t\telse if (PEEK_BITS(3) == 6) {\n\t\t    REMOVE_BITS(3); /* '110' -> 12 extra length bits + 0x500 */\n\t\t    READ_BITS(extra_len, 12);\n\t\t    extra_len += 0x500;\n\t\t}\n\t\telse {\n\t\t    REMOVE_BITS(3); /* '111' -> 15 extra length bits */\n\t\t    READ_BITS(extra_len, 15);\n\t\t}\n\t\tmatch_length += extra_len;\n\t    }\n\n\t    if ((window_posn + match_length) > lzx->window_size) {\n\t      D((\"match ran over window wrap\"))\n\t      return lzx->error = MSPACK_ERR_DECRUNCH;\n\t    }\n\n\t    /* copy match */\n\t    rundest = &window[window_posn];\n\t    i = match_length;\n\t    /* does match offset wrap the window? */\n\t    if (match_offset > window_posn) {\n\t      if (match_offset > lzx->offset &&\n\t\t  (match_offset - window_posn) > lzx->ref_data_size)\n\t      {\n\t\tD((\"match offset beyond LZX stream\"))\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n\t      }\n\t      /* j = length from match offset to end of window */\n\t      j = match_offset - window_posn;\n\t      if (j > (int) lzx->window_size) {\n\t\tD((\"match offset beyond window boundaries\"))\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n\t      }\n\t      runsrc = &window[lzx->window_size - j];\n\t      if (j < i) {\n\t\t/* if match goes over the window edge, do two copy runs */\n\t\ti -= j; while (j-- > 0) *rundest++ = *runsrc++;\n\t\trunsrc = window;\n\t      }\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\t    else {\n\t      runsrc = rundest - match_offset;\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\n\t    this_run    -= match_length;\n\t    window_posn += match_length;\n\t  }\n\t} /* while (this_run > 0) */\n\tbreak;\n\n      case LZX_BLOCKTYPE_UNCOMPRESSED:\n\t/* as this_run is limited not to wrap a frame, this also means it\n\t * won't wrap the window (as the window is a multiple of 32k) */\n        if (window_posn + this_run > lzx->window_size) {\n                D((\"match ran over window boundary\"))\n                return lzx->error = MSPACK_ERR_DECRUNCH;\n        }\n\trundest = &window[window_posn];\n\twindow_posn += this_run;\n\n\twhile (this_run > 0) {\n\t  if ((i = i_end - i_ptr) == 0) {\n\t    READ_IF_NEEDED;\n\t  }\n\t  else {\n\t    if (i > this_run) i = this_run;\n\t    lzx->sys->copy(i_ptr, rundest, (size_t) i);\n\t    rundest  += i;\n\t    i_ptr    += i;\n\t    this_run -= i;\n\t  }\n\t}\n\tbreak;\n\n      default:\n\treturn lzx->error = MSPACK_ERR_DECRUNCH; /* might as well */\n      }\n\n      /* did the final match overrun our desired this_run length? */\n      if (this_run < 0) {\n\tif ((unsigned int)(-this_run) > lzx->block_remaining) {\n\t  D((\"overrun went past end of block by %d (%d remaining)\",\n\t     -this_run, lzx->block_remaining ))\n\t  return lzx->error = MSPACK_ERR_DECRUNCH;\n\t}\n\tlzx->block_remaining -= -this_run;\n      }\n    } /* while (bytes_todo > 0) */\n\n    /* streams don't extend over frame boundaries */\n    if ((window_posn - lzx->frame_posn) != frame_size) {\n      D((\"decode beyond output frame limits! %d != %d\",\n\t window_posn - lzx->frame_posn, frame_size))\n      return lzx->error = MSPACK_ERR_DECRUNCH;\n    }\n\n    /* re-align input bitstream */\n    if (bits_left > 0) ENSURE_BITS(16);\n    if (bits_left & 15) REMOVE_BITS(bits_left & 15);\n\n    /* check that we've used all of the previous frame first */\n    if (lzx->o_ptr != lzx->o_end) {\n      D((\"%ld avail bytes, new %d frame\",\n          (long)(lzx->o_end - lzx->o_ptr), frame_size))\n      return lzx->error = MSPACK_ERR_DECRUNCH;\n    }\n\n    /* does this intel block _really_ need decoding? */\n    if (lzx->intel_started && lzx->intel_filesize &&\n\t(lzx->frame <= 32768) && (frame_size > 10))\n    {\n      unsigned char *data    = &lzx->e8_buf[0];\n      unsigned char *dataend = &lzx->e8_buf[frame_size - 10];\n      signed int curpos      = lzx->intel_curpos;\n      signed int filesize    = lzx->intel_filesize;\n      signed int abs_off, rel_off;\n\n      /* copy e8 block to the e8 buffer and tweak if needed */\n      lzx->o_ptr = data;\n      lzx->sys->copy(&lzx->window[lzx->frame_posn], data, frame_size);\n\n      while (data < dataend) {\n\tif (*data++ != 0xE8) { curpos++; continue; }\n\tabs_off = data[0] | (data[1]<<8) | (data[2]<<16) | (data[3]<<24);\n\tif ((abs_off >= -curpos) && (abs_off < filesize)) {\n\t  rel_off = (abs_off >= 0) ? abs_off - curpos : abs_off + filesize;\n\t  data[0] = (unsigned char) rel_off;\n\t  data[1] = (unsigned char) (rel_off >> 8);\n\t  data[2] = (unsigned char) (rel_off >> 16);\n\t  data[3] = (unsigned char) (rel_off >> 24);\n\t}\n\tdata += 4;\n\tcurpos += 5;\n      }\n      lzx->intel_curpos += frame_size;\n    }\n    else {\n      lzx->o_ptr = &lzx->window[lzx->frame_posn];\n      if (lzx->intel_filesize) lzx->intel_curpos += frame_size;\n    }\n    lzx->o_end = &lzx->o_ptr[frame_size];\n\n    /* write a frame */\n    i = (out_bytes < (off_t)frame_size) ? (unsigned int)out_bytes : frame_size;\n    if (lzx->sys->write(lzx->output, lzx->o_ptr, i) != i) {\n      return lzx->error = MSPACK_ERR_WRITE;\n    }\n    lzx->o_ptr  += i;\n    lzx->offset += i;\n    out_bytes   -= i;\n\n    /* advance frame start position */\n    lzx->frame_posn += frame_size;\n    lzx->frame++;\n\n    /* wrap window / frame position pointers */\n    if (window_posn == lzx->window_size)     window_posn = 0;\n    if (lzx->frame_posn == lzx->window_size) lzx->frame_posn = 0;\n\n  } /* while (lzx->frame < end_frame) */\n\n  if (out_bytes) {\n    D((\"bytes left to output\"))\n    return lzx->error = MSPACK_ERR_DECRUNCH;\n  }\n\n  /* store local state */\n  STORE_BITS;\n  lzx->window_posn = window_posn;\n  lzx->R0 = R0;\n  lzx->R1 = R1;\n  lzx->R2 = R2;\n\n  return MSPACK_ERR_OK;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 510,
    "critical_vars": [
      "bits_left"
    ],
    "function": "lzxd_decompress",
    "filename": "libmspack/CVE-2015-4471/CVE-2015-4471_CWE-189_18b6a2cc0b87536015bedd4f7763e6b02d5aa4f3_lzxd.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 2021,
    "critical_vars": [
      "flags"
    ],
    "function": "nedpmalloc",
    "filename": "nedmalloc/CVE-2012-2675/CVE-2012-2675_CWE-189_2965eca30c408c13473c4146a9d47d547d288db1_nedmalloc.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 2021,
    "critical_vars": [
      "bytes"
    ],
    "function": "nedpmalloc",
    "filename": "nedmalloc/CVE-2012-2675/CVE-2012-2675_CWE-189_2965eca30c408c13473c4146a9d47d547d288db1_nedmalloc.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 2023,
    "critical_vars": [
      "no",
      "bytes",
      "size"
    ],
    "function": "nedpmalloc",
    "filename": "nedmalloc/CVE-2012-2675/CVE-2012-2675_CWE-189_2965eca30c408c13473c4146a9d47d547d288db1_nedmalloc.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 2025,
    "critical_vars": [
      "flags"
    ],
    "function": "nedpmalloc",
    "filename": "nedmalloc/CVE-2012-2675/CVE-2012-2675_CWE-189_2965eca30c408c13473c4146a9d47d547d288db1_nedmalloc.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 331,
    "critical_vars": [
      "size"
    ],
    "function": "*CallMalloc",
    "filename": "nedmalloc/CVE-2012-2675/CVE-2012-2675_CWE-189_1a759756639ab7543b650a10c2d77a0ffc7a2000_nedmalloc.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 331,
    "critical_vars": [
      "bytes"
    ],
    "function": "*CallMalloc",
    "filename": "nedmalloc/CVE-2012-2675/CVE-2012-2675_CWE-189_1a759756639ab7543b650a10c2d77a0ffc7a2000_nedmalloc.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 333,
    "critical_vars": [
      "bytes"
    ],
    "function": "*CallMalloc",
    "filename": "nedmalloc/CVE-2012-2675/CVE-2012-2675_CWE-189_1a759756639ab7543b650a10c2d77a0ffc7a2000_nedmalloc.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 335,
    "critical_vars": [
      "size"
    ],
    "function": "*CallMalloc",
    "filename": "nedmalloc/CVE-2012-2675/CVE-2012-2675_CWE-189_1a759756639ab7543b650a10c2d77a0ffc7a2000_nedmalloc.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 201,
    "critical_vars": [
      "mobj",
      "size"
    ],
    "function": "*alloc_ta_mem",
    "filename": "optee_os/CVE-2019-1010294/CVE-2019-1010294_CWE-189_7e768f8a473409215fe3fff8f6e31f8a3a0103c6_user_ta.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 201,
    "critical_vars": [
      "granularity"
    ],
    "function": "*alloc_ta_mem",
    "filename": "optee_os/CVE-2019-1010294/CVE-2019-1010294_CWE-189_7e768f8a473409215fe3fff8f6e31f8a3a0103c6_user_ta.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 204,
    "critical_vars": [
      "granularity",
      "mobj",
      "size"
    ],
    "function": "*alloc_ta_mem",
    "filename": "optee_os/CVE-2019-1010294/CVE-2019-1010294_CWE-189_7e768f8a473409215fe3fff8f6e31f8a3a0103c6_user_ta.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 366,
    "critical_vars": [
      "length",
      "index"
    ],
    "function": "ByteVector::mid",
    "filename": "taglib/CVE-2012-1584/CVE-2012-1584_CWE-189_dcdf4fd954e3213c355746fa15b7480461972308_tbytevector.cpp.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 366,
    "critical_vars": [
      "length"
    ],
    "function": "ByteVector::mid",
    "filename": "taglib/CVE-2012-1584/CVE-2012-1584_CWE-189_dcdf4fd954e3213c355746fa15b7480461972308_tbytevector.cpp.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 517,
    "critical_vars": [
      "state.sumlen",
      "state.polstr"
    ],
    "function": "parse_tsquery",
    "filename": "postgres/CVE-2014-0064/CVE-2014-0064_CWE-189_31400a673325147e1205326008e32135a78b4d8a_tsquery.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 337,
    "critical_vars": [
      "nnode",
      "sumlen"
    ],
    "function": "QTN2QT",
    "filename": "postgres/CVE-2014-0064/CVE-2014-0064_CWE-189_31400a673325147e1205326008e32135a78b4d8a_tsquery_util.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 443,
    "critical_vars": [
      "pcount"
    ],
    "function": "hstore_recv",
    "filename": "postgres/CVE-2014-0064/CVE-2014-0064_CWE-189_31400a673325147e1205326008e32135a78b4d8a_hstore_io.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 444,
    "critical_vars": [
      "Pairs",
      "pcount"
    ],
    "function": "hstore_recv",
    "filename": "postgres/CVE-2014-0064/CVE-2014-0064_CWE-189_31400a673325147e1205326008e32135a78b4d8a_hstore_io.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 564,
    "critical_vars": [
      "key_count"
    ],
    "function": "hstore_from_arrays",
    "filename": "postgres/CVE-2014-0064/CVE-2014-0064_CWE-189_31400a673325147e1205326008e32135a78b4d8a_hstore_io.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 565,
    "critical_vars": [
      "Pairs",
      "key_count"
    ],
    "function": "hstore_from_arrays",
    "filename": "postgres/CVE-2014-0064/CVE-2014-0064_CWE-189_31400a673325147e1205326008e32135a78b4d8a_hstore_io.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 693,
    "critical_vars": [
      "count"
    ],
    "function": "hstore_from_array",
    "filename": "postgres/CVE-2014-0064/CVE-2014-0064_CWE-189_31400a673325147e1205326008e32135a78b4d8a_hstore_io.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 694,
    "critical_vars": [
      "Pairs",
      "count"
    ],
    "function": "hstore_from_array",
    "filename": "postgres/CVE-2014-0064/CVE-2014-0064_CWE-189_31400a673325147e1205326008e32135a78b4d8a_hstore_io.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 830,
    "critical_vars": [
      "ncolumns"
    ],
    "function": "hstore_from_record",
    "filename": "postgres/CVE-2014-0064/CVE-2014-0064_CWE-189_31400a673325147e1205326008e32135a78b4d8a_hstore_io.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 72,
    "critical_vars": [
      "TxidSnapshot",
      "MaxAllocSize",
      "txid"
    ],
    "function": "None_func",
    "filename": "postgres/CVE-2014-0064/CVE-2014-0064_CWE-189_31400a673325147e1205326008e32135a78b4d8a_txid.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 459,
    "critical_vars": [
      "avail"
    ],
    "function": "txid_snapshot_recv",
    "filename": "postgres/CVE-2014-0064/CVE-2014-0064_CWE-189_31400a673325147e1205326008e32135a78b4d8a_txid.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 464,
    "critical_vars": [
      "nxip"
    ],
    "function": "txid_snapshot_recv",
    "filename": "postgres/CVE-2014-0064/CVE-2014-0064_CWE-189_31400a673325147e1205326008e32135a78b4d8a_txid.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 460,
    "critical_vars": [
      "expect"
    ],
    "function": "txid_snapshot_recv",
    "filename": "postgres/CVE-2014-0064/CVE-2014-0064_CWE-189_31400a673325147e1205326008e32135a78b4d8a_txid.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 461,
    "critical_vars": [
      "nxip",
      "expect"
    ],
    "function": "txid_snapshot_recv",
    "filename": "postgres/CVE-2014-0064/CVE-2014-0064_CWE-189_31400a673325147e1205326008e32135a78b4d8a_txid.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 101,
    "critical_vars": [
      "key_count"
    ],
    "function": "hstoreArrayToPairs",
    "filename": "postgres/CVE-2014-0064/CVE-2014-0064_CWE-189_31400a673325147e1205326008e32135a78b4d8a_hstore_op.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 102,
    "critical_vars": [
      "Pairs",
      "key_count"
    ],
    "function": "hstoreArrayToPairs",
    "filename": "postgres/CVE-2014-0064/CVE-2014-0064_CWE-189_31400a673325147e1205326008e32135a78b4d8a_hstore_op.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 160,
    "critical_vars": [
      "slen"
    ],
    "function": "bit_in",
    "filename": "postgres/CVE-2014-0064/CVE-2014-0064_CWE-189_31400a673325147e1205326008e32135a78b4d8a_varbit.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 472,
    "critical_vars": [
      "slen"
    ],
    "function": "varbit_in",
    "filename": "postgres/CVE-2014-0064/CVE-2014-0064_CWE-189_31400a673325147e1205326008e32135a78b4d8a_varbit.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 970,
    "critical_vars": [
      "bitlen1"
    ],
    "function": "bit_catenate",
    "filename": "postgres/CVE-2014-0064/CVE-2014-0064_CWE-189_31400a673325147e1205326008e32135a78b4d8a_varbit.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 68,
    "critical_vars": [
      "num"
    ],
    "function": "ltree_in",
    "filename": "postgres/CVE-2014-0064/CVE-2014-0064_CWE-189_31400a673325147e1205326008e32135a78b4d8a_ltree_io.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 69,
    "critical_vars": [
      "num",
      "nodeitem"
    ],
    "function": "ltree_in",
    "filename": "postgres/CVE-2014-0064/CVE-2014-0064_CWE-189_31400a673325147e1205326008e32135a78b4d8a_ltree_io.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 237,
    "critical_vars": [
      "num"
    ],
    "function": "lquery_in",
    "filename": "postgres/CVE-2014-0064/CVE-2014-0064_CWE-189_31400a673325147e1205326008e32135a78b4d8a_ltree_io.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 238,
    "critical_vars": [
      "num",
      "MaxAllocSize"
    ],
    "function": "lquery_in",
    "filename": "postgres/CVE-2014-0064/CVE-2014-0064_CWE-189_31400a673325147e1205326008e32135a78b4d8a_ltree_io.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 514,
    "critical_vars": [
      "state.num"
    ],
    "function": "bqarr_in",
    "filename": "postgres/CVE-2014-0064/CVE-2014-0064_CWE-189_31400a673325147e1205326008e32135a78b4d8a__int_bool.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 515,
    "critical_vars": [
      "state.num"
    ],
    "function": "bqarr_in",
    "filename": "postgres/CVE-2014-0064/CVE-2014-0064_CWE-189_31400a673325147e1205326008e32135a78b4d8a__int_bool.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 1387,
    "critical_vars": [
      "size"
    ],
    "function": "path_in",
    "filename": "postgres/CVE-2014-0064/CVE-2014-0064_CWE-189_31400a673325147e1205326008e32135a78b4d8a_geo_ops.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 1388,
    "critical_vars": [
      "base_size"
    ],
    "function": "path_in",
    "filename": "postgres/CVE-2014-0064/CVE-2014-0064_CWE-189_31400a673325147e1205326008e32135a78b4d8a_geo_ops.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 1389,
    "critical_vars": [
      "size"
    ],
    "function": "path_in",
    "filename": "postgres/CVE-2014-0064/CVE-2014-0064_CWE-189_31400a673325147e1205326008e32135a78b4d8a_geo_ops.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1392,
    "critical_vars": [
      "base_size",
      "npts",
      "size"
    ],
    "function": "path_in",
    "filename": "postgres/CVE-2014-0064/CVE-2014-0064_CWE-189_31400a673325147e1205326008e32135a78b4d8a_geo_ops.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 3440,
    "critical_vars": [
      "size"
    ],
    "function": "poly_in",
    "filename": "postgres/CVE-2014-0064/CVE-2014-0064_CWE-189_31400a673325147e1205326008e32135a78b4d8a_geo_ops.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 3450,
    "critical_vars": [
      "base_size"
    ],
    "function": "poly_in",
    "filename": "postgres/CVE-2014-0064/CVE-2014-0064_CWE-189_31400a673325147e1205326008e32135a78b4d8a_geo_ops.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 3451,
    "critical_vars": [
      "size"
    ],
    "function": "poly_in",
    "filename": "postgres/CVE-2014-0064/CVE-2014-0064_CWE-189_31400a673325147e1205326008e32135a78b4d8a_geo_ops.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 3454,
    "critical_vars": [
      "base_size",
      "npts",
      "size"
    ],
    "function": "poly_in",
    "filename": "postgres/CVE-2014-0064/CVE-2014-0064_CWE-189_31400a673325147e1205326008e32135a78b4d8a_geo_ops.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 350,
    "critical_vars": [
      "state.num",
      "state.sumlen"
    ],
    "function": "queryin",
    "filename": "postgres/CVE-2014-0064/CVE-2014-0064_CWE-189_31400a673325147e1205326008e32135a78b4d8a_ltxtquery_io.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 72,
    "critical_vars": [
      "TxidSnapshot",
      "MaxAllocSize",
      "txid"
    ],
    "function": "None_func",
    "filename": "postgres/CVE-2014-2669/CVE-2014-2669_CWE-189_31400a673325147e1205326008e32135a78b4d8a_txid.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 459,
    "critical_vars": [
      "avail"
    ],
    "function": "txid_snapshot_recv",
    "filename": "postgres/CVE-2014-2669/CVE-2014-2669_CWE-189_31400a673325147e1205326008e32135a78b4d8a_txid.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 464,
    "critical_vars": [
      "nxip"
    ],
    "function": "txid_snapshot_recv",
    "filename": "postgres/CVE-2014-2669/CVE-2014-2669_CWE-189_31400a673325147e1205326008e32135a78b4d8a_txid.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 460,
    "critical_vars": [
      "expect"
    ],
    "function": "txid_snapshot_recv",
    "filename": "postgres/CVE-2014-2669/CVE-2014-2669_CWE-189_31400a673325147e1205326008e32135a78b4d8a_txid.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 461,
    "critical_vars": [
      "nxip",
      "expect"
    ],
    "function": "txid_snapshot_recv",
    "filename": "postgres/CVE-2014-2669/CVE-2014-2669_CWE-189_31400a673325147e1205326008e32135a78b4d8a_txid.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 337,
    "critical_vars": [
      "nnode",
      "sumlen"
    ],
    "function": "QTN2QT",
    "filename": "postgres/CVE-2014-2669/CVE-2014-2669_CWE-189_31400a673325147e1205326008e32135a78b4d8a_tsquery_util.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 514,
    "critical_vars": [
      "state.num"
    ],
    "function": "bqarr_in",
    "filename": "postgres/CVE-2014-2669/CVE-2014-2669_CWE-189_31400a673325147e1205326008e32135a78b4d8a__int_bool.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 515,
    "critical_vars": [
      "state.num"
    ],
    "function": "bqarr_in",
    "filename": "postgres/CVE-2014-2669/CVE-2014-2669_CWE-189_31400a673325147e1205326008e32135a78b4d8a__int_bool.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 517,
    "critical_vars": [
      "state.sumlen",
      "state.polstr"
    ],
    "function": "parse_tsquery",
    "filename": "postgres/CVE-2014-2669/CVE-2014-2669_CWE-189_31400a673325147e1205326008e32135a78b4d8a_tsquery.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 1387,
    "critical_vars": [
      "size"
    ],
    "function": "path_in",
    "filename": "postgres/CVE-2014-2669/CVE-2014-2669_CWE-189_31400a673325147e1205326008e32135a78b4d8a_geo_ops.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 1388,
    "critical_vars": [
      "base_size"
    ],
    "function": "path_in",
    "filename": "postgres/CVE-2014-2669/CVE-2014-2669_CWE-189_31400a673325147e1205326008e32135a78b4d8a_geo_ops.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 1389,
    "critical_vars": [
      "size"
    ],
    "function": "path_in",
    "filename": "postgres/CVE-2014-2669/CVE-2014-2669_CWE-189_31400a673325147e1205326008e32135a78b4d8a_geo_ops.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1392,
    "critical_vars": [
      "base_size",
      "npts",
      "size"
    ],
    "function": "path_in",
    "filename": "postgres/CVE-2014-2669/CVE-2014-2669_CWE-189_31400a673325147e1205326008e32135a78b4d8a_geo_ops.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 3440,
    "critical_vars": [
      "size"
    ],
    "function": "poly_in",
    "filename": "postgres/CVE-2014-2669/CVE-2014-2669_CWE-189_31400a673325147e1205326008e32135a78b4d8a_geo_ops.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 3450,
    "critical_vars": [
      "base_size"
    ],
    "function": "poly_in",
    "filename": "postgres/CVE-2014-2669/CVE-2014-2669_CWE-189_31400a673325147e1205326008e32135a78b4d8a_geo_ops.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 3451,
    "critical_vars": [
      "size"
    ],
    "function": "poly_in",
    "filename": "postgres/CVE-2014-2669/CVE-2014-2669_CWE-189_31400a673325147e1205326008e32135a78b4d8a_geo_ops.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 3454,
    "critical_vars": [
      "base_size",
      "npts",
      "size"
    ],
    "function": "poly_in",
    "filename": "postgres/CVE-2014-2669/CVE-2014-2669_CWE-189_31400a673325147e1205326008e32135a78b4d8a_geo_ops.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 160,
    "critical_vars": [
      "slen"
    ],
    "function": "bit_in",
    "filename": "postgres/CVE-2014-2669/CVE-2014-2669_CWE-189_31400a673325147e1205326008e32135a78b4d8a_varbit.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 472,
    "critical_vars": [
      "slen"
    ],
    "function": "varbit_in",
    "filename": "postgres/CVE-2014-2669/CVE-2014-2669_CWE-189_31400a673325147e1205326008e32135a78b4d8a_varbit.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 970,
    "critical_vars": [
      "bitlen1"
    ],
    "function": "bit_catenate",
    "filename": "postgres/CVE-2014-2669/CVE-2014-2669_CWE-189_31400a673325147e1205326008e32135a78b4d8a_varbit.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 443,
    "critical_vars": [
      "pcount"
    ],
    "function": "hstore_recv",
    "filename": "postgres/CVE-2014-2669/CVE-2014-2669_CWE-189_31400a673325147e1205326008e32135a78b4d8a_hstore_io.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 444,
    "critical_vars": [
      "Pairs",
      "pcount"
    ],
    "function": "hstore_recv",
    "filename": "postgres/CVE-2014-2669/CVE-2014-2669_CWE-189_31400a673325147e1205326008e32135a78b4d8a_hstore_io.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 564,
    "critical_vars": [
      "key_count"
    ],
    "function": "hstore_from_arrays",
    "filename": "postgres/CVE-2014-2669/CVE-2014-2669_CWE-189_31400a673325147e1205326008e32135a78b4d8a_hstore_io.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 565,
    "critical_vars": [
      "Pairs",
      "key_count"
    ],
    "function": "hstore_from_arrays",
    "filename": "postgres/CVE-2014-2669/CVE-2014-2669_CWE-189_31400a673325147e1205326008e32135a78b4d8a_hstore_io.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 693,
    "critical_vars": [
      "count"
    ],
    "function": "hstore_from_array",
    "filename": "postgres/CVE-2014-2669/CVE-2014-2669_CWE-189_31400a673325147e1205326008e32135a78b4d8a_hstore_io.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 694,
    "critical_vars": [
      "Pairs",
      "count"
    ],
    "function": "hstore_from_array",
    "filename": "postgres/CVE-2014-2669/CVE-2014-2669_CWE-189_31400a673325147e1205326008e32135a78b4d8a_hstore_io.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 830,
    "critical_vars": [
      "ncolumns"
    ],
    "function": "hstore_from_record",
    "filename": "postgres/CVE-2014-2669/CVE-2014-2669_CWE-189_31400a673325147e1205326008e32135a78b4d8a_hstore_io.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 350,
    "critical_vars": [
      "state.num",
      "state.sumlen"
    ],
    "function": "queryin",
    "filename": "postgres/CVE-2014-2669/CVE-2014-2669_CWE-189_31400a673325147e1205326008e32135a78b4d8a_ltxtquery_io.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 101,
    "critical_vars": [
      "key_count"
    ],
    "function": "hstoreArrayToPairs",
    "filename": "postgres/CVE-2014-2669/CVE-2014-2669_CWE-189_31400a673325147e1205326008e32135a78b4d8a_hstore_op.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 102,
    "critical_vars": [
      "Pairs",
      "key_count"
    ],
    "function": "hstoreArrayToPairs",
    "filename": "postgres/CVE-2014-2669/CVE-2014-2669_CWE-189_31400a673325147e1205326008e32135a78b4d8a_hstore_op.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 68,
    "critical_vars": [
      "num"
    ],
    "function": "ltree_in",
    "filename": "postgres/CVE-2014-2669/CVE-2014-2669_CWE-189_31400a673325147e1205326008e32135a78b4d8a_ltree_io.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 69,
    "critical_vars": [
      "num",
      "nodeitem"
    ],
    "function": "ltree_in",
    "filename": "postgres/CVE-2014-2669/CVE-2014-2669_CWE-189_31400a673325147e1205326008e32135a78b4d8a_ltree_io.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 237,
    "critical_vars": [
      "num"
    ],
    "function": "lquery_in",
    "filename": "postgres/CVE-2014-2669/CVE-2014-2669_CWE-189_31400a673325147e1205326008e32135a78b4d8a_ltree_io.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 238,
    "critical_vars": [
      "num",
      "MaxAllocSize"
    ],
    "function": "lquery_in",
    "filename": "postgres/CVE-2014-2669/CVE-2014-2669_CWE-189_31400a673325147e1205326008e32135a78b4d8a_ltree_io.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 893,
    "critical_vars": [
      "len"
    ],
    "function": "None_func",
    "filename": "rawstudio/CVE-2015-3885/CVE-2015-3885_CWE-189_983bda1f0fa5fa86884381208274198a620f006e_dcraw.cc.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 894,
    "critical_vars": [
      "len"
    ],
    "function": "None_func",
    "filename": "rawstudio/CVE-2015-3885/CVE-2015-3885_CWE-189_983bda1f0fa5fa86884381208274198a620f006e_dcraw.cc.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "Fun-Call",
    "line_old": 99,
    "line_new": 99,
    "critical_vars": [
      "buffer",
      "hasread",
      "putsize",
      "&header"
    ],
    "function": "fcgid_header_bucket_read",
    "filename": "httpd-mod_fcgid/CVE-2010-3872/CVE-2010-3872_CWE-189_b1afa70840b4ab4e6fbc12ac8798b2f3ccc336b2_fcgid_bucket.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 629,
    "critical_vars": [
      "out_len"
    ],
    "function": "string_chunk_split",
    "filename": "hhvm/CVE-2014-6228/CVE-2014-6228_CWE-189_1f91e076a585118495b976a413c1df40f6fd3d41_zend-string.cpp.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 629,
    "critical_vars": [
      "ReserveString",
      "endlen",
      "chunks",
      "srclen"
    ],
    "function": "string_chunk_split",
    "filename": "hhvm/CVE-2014-6228/CVE-2014-6228_CWE-189_1f91e076a585118495b976a413c1df40f6fd3d41_zend-string.cpp.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 630,
    "critical_vars": [
      "out_len",
      "ReserveString"
    ],
    "function": "string_chunk_split",
    "filename": "hhvm/CVE-2014-6228/CVE-2014-6228_CWE-189_1f91e076a585118495b976a413c1df40f6fd3d41_zend-string.cpp.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 673,
    "critical_vars": [
      "s"
    ],
    "function": "license_read_scope_list",
    "filename": "FreeRDP/CVE-2014-0791/CVE-2014-0791_CWE-189_e2745807c4c3e0a590c0f69a9b655dc74ebaa03e_license.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 208,
    "line_new": 208,
    "critical_vars": [
      "cluster"
    ],
    "function": "set_fat",
    "filename": "dosfstools/CVE-2015-8872/CVE-2015-8872_CWE-189_07908124838afcc99c577d1d3e84cef2dbd39cb7_fat.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 29,
    "critical_vars": [
      "offset",
      "length",
      "int32_t"
    ],
    "function": "FontData::Size",
    "filename": "sfntly/CVE-2015-6781/CVE-2015-6781_CWE-189_de776d4ef06ca29c240de3444348894f032b03ff_font_data.cc.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 31,
    "critical_vars": [
      "offset",
      "length",
      "int32_t"
    ],
    "function": "FontData::Size",
    "filename": "sfntly/CVE-2015-6781/CVE-2015-6781_CWE-189_de776d4ef06ca29c240de3444348894f032b03ff_font_data.cc.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 30,
    "critical_vars": [
      "offset",
      "length"
    ],
    "function": "FontData::Size",
    "filename": "sfntly/CVE-2015-6781/CVE-2015-6781_CWE-189_de776d4ef06ca29c240de3444348894f032b03ff_font_data.cc.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 33,
    "critical_vars": [
      "offset"
    ],
    "function": "FontData::Size",
    "filename": "sfntly/CVE-2015-6781/CVE-2015-6781_CWE-189_de776d4ef06ca29c240de3444348894f032b03ff_font_data.cc.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 34,
    "critical_vars": [
      "length"
    ],
    "function": "FontData::Size",
    "filename": "sfntly/CVE-2015-6781/CVE-2015-6781_CWE-189_de776d4ef06ca29c240de3444348894f032b03ff_font_data.cc.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 33,
    "critical_vars": [
      "bound_offset_"
    ],
    "function": "FontData::Size",
    "filename": "sfntly/CVE-2015-6781/CVE-2015-6781_CWE-189_de776d4ef06ca29c240de3444348894f032b03ff_font_data.cc.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 37,
    "critical_vars": [
      "offset"
    ],
    "function": "FontData::Size",
    "filename": "sfntly/CVE-2015-6781/CVE-2015-6781_CWE-189_de776d4ef06ca29c240de3444348894f032b03ff_font_data.cc.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 38,
    "critical_vars": [
      "new_offset"
    ],
    "function": "FontData::Size",
    "filename": "sfntly/CVE-2015-6781/CVE-2015-6781_CWE-189_de776d4ef06ca29c240de3444348894f032b03ff_font_data.cc.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 40,
    "critical_vars": [
      "length"
    ],
    "function": "FontData::Size",
    "filename": "sfntly/CVE-2015-6781/CVE-2015-6781_CWE-189_de776d4ef06ca29c240de3444348894f032b03ff_font_data.cc.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 44,
    "critical_vars": [
      "new_offset"
    ],
    "function": "FontData::Size",
    "filename": "sfntly/CVE-2015-6781/CVE-2015-6781_CWE-189_de776d4ef06ca29c240de3444348894f032b03ff_font_data.cc.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 49,
    "critical_vars": [
      "length"
    ],
    "function": "FontData::Size",
    "filename": "sfntly/CVE-2015-6781/CVE-2015-6781_CWE-189_de776d4ef06ca29c240de3444348894f032b03ff_font_data.cc.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 52,
    "critical_vars": [
      "bound_offset_"
    ],
    "function": "FontData::Size",
    "filename": "sfntly/CVE-2015-6781/CVE-2015-6781_CWE-189_de776d4ef06ca29c240de3444348894f032b03ff_font_data.cc.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 38,
    "critical_vars": [
      "offset",
      "int32_t"
    ],
    "function": "FontData::Size",
    "filename": "sfntly/CVE-2015-6781/CVE-2015-6781_CWE-189_de776d4ef06ca29c240de3444348894f032b03ff_font_data.cc.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 39,
    "critical_vars": [
      "offset"
    ],
    "function": "FontData::Size",
    "filename": "sfntly/CVE-2015-6781/CVE-2015-6781_CWE-189_de776d4ef06ca29c240de3444348894f032b03ff_font_data.cc.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 42,
    "critical_vars": [
      "bound_offset_"
    ],
    "function": "FontData::Size",
    "filename": "sfntly/CVE-2015-6781/CVE-2015-6781_CWE-189_de776d4ef06ca29c240de3444348894f032b03ff_font_data.cc.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "for-Condition",
    "line_old": 34,
    "line_new": 34,
    "critical_vars": [
      "i"
    ],
    "function": "None_func",
    "filename": "FFmpeg/CVE-2013-7014/CVE-2013-7014_CWE-189_86736f59d6a527d8bc807d09b93f971c0fe0bb07_pngdsp.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "for-Condition",
    "line_old": 1934,
    "line_new": 1934,
    "critical_vars": [
      "i"
    ],
    "function": "ff_set_cmp",
    "filename": "FFmpeg/CVE-2013-7010/CVE-2013-7010_CWE-189_454a11a1c9c686c78aa97954306fb63453299760_dsputil.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "for-Condition",
    "line_old": 1959,
    "line_new": 1959,
    "critical_vars": [
      "i"
    ],
    "function": "diff_bytes_c",
    "filename": "FFmpeg/CVE-2013-7010/CVE-2013-7010_CWE-189_454a11a1c9c686c78aa97954306fb63453299760_dsputil.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 456,
    "line_new": 456,
    "critical_vars": [
      "c->tile_stride"
    ],
    "function": "g2m_init_buffers",
    "filename": "FFmpeg/CVE-2013-7013/CVE-2013-7013_CWE-189_821a5938d100458f4d09d634041b05c860554ce0_g2meet.c.diff",
    "function_code": "static int g2m_init_buffers(G2MContext *c)\n{\n    int aligned_height;\n\n    if (!c->framebuf || c->old_width < c->width || c->old_height < c->height) {\n        c->framebuf_stride = FFALIGN(c->width + 15, 16) * 3;\n        aligned_height     = c->height + 15;\n        av_free(c->framebuf);\n        c->framebuf = av_mallocz(c->framebuf_stride * aligned_height);\n        if (!c->framebuf)\n            return AVERROR(ENOMEM);\n    }\n    if (!c->synth_tile || !c->jpeg_tile ||\n        c->old_tile_w < c->tile_width ||\n        c->old_tile_h < c->tile_height) {\n        c->tile_stride = FFALIGN(c->tile_width, 16) * 3;\n        aligned_height = FFALIGN(c->tile_height,    16);\n        av_free(c->synth_tile);\n        av_free(c->jpeg_tile);\n        av_free(c->kempf_buf);\n        av_free(c->kempf_flags);\n        c->synth_tile  = av_mallocz(c->tile_stride      * aligned_height);\n        c->jpeg_tile   = av_mallocz(c->tile_stride      * aligned_height);\n        c->kempf_buf   = av_mallocz((c->tile_width + 1) * aligned_height\n                                    + FF_INPUT_BUFFER_PADDING_SIZE);\n        c->kempf_flags = av_mallocz( c->tile_width      * aligned_height);\n        if (!c->synth_tile || !c->jpeg_tile ||\n            !c->kempf_buf || !c->kempf_flags)\n            return AVERROR(ENOMEM);\n    }\n\n    return 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 303,
    "critical_vars": [
      "blen"
    ],
    "function": "lsr_read_extension",
    "filename": "gpac/CVE-2022-4202/CVE-2022-4202_CWE-189_b3d821c4ae9ba62b3a194d9dcb5e99f17bd56908_lsr_dec.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 307,
    "critical_vars": [
      "lsr->bs",
      "len"
    ],
    "function": "lsr_read_extension",
    "filename": "gpac/CVE-2022-4202/CVE-2022-4202_CWE-189_b3d821c4ae9ba62b3a194d9dcb5e99f17bd56908_lsr_dec.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "while-Condition",
    "line_new": 306,
    "critical_vars": [
      "lsr->bs",
      "len"
    ],
    "function": "lsr_read_extension",
    "filename": "gpac/CVE-2022-4202/CVE-2022-4202_CWE-189_b3d821c4ae9ba62b3a194d9dcb5e99f17bd56908_lsr_dec.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 307,
    "critical_vars": [
      "lsr->bs",
      "len"
    ],
    "function": "lsr_read_extension",
    "filename": "gpac/CVE-2022-4202/CVE-2022-4202_CWE-189_b3d821c4ae9ba62b3a194d9dcb5e99f17bd56908_lsr_dec.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 308,
    "critical_vars": [
      "len"
    ],
    "function": "lsr_read_extension",
    "filename": "gpac/CVE-2022-4202/CVE-2022-4202_CWE-189_b3d821c4ae9ba62b3a194d9dcb5e99f17bd56908_lsr_dec.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 310,
    "critical_vars": [
      "blen"
    ],
    "function": "lsr_read_extension",
    "filename": "gpac/CVE-2022-4202/CVE-2022-4202_CWE-189_b3d821c4ae9ba62b3a194d9dcb5e99f17bd56908_lsr_dec.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 311,
    "critical_vars": [
      "lsr->bs",
      "blen"
    ],
    "function": "lsr_read_extension",
    "filename": "gpac/CVE-2022-4202/CVE-2022-4202_CWE-189_b3d821c4ae9ba62b3a194d9dcb5e99f17bd56908_lsr_dec.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 312,
    "critical_vars": [
      "len"
    ],
    "function": "lsr_read_extension",
    "filename": "gpac/CVE-2022-4202/CVE-2022-4202_CWE-189_b3d821c4ae9ba62b3a194d9dcb5e99f17bd56908_lsr_dec.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "while-Condition",
    "line_new": 314,
    "critical_vars": [
      "len"
    ],
    "function": "lsr_read_extension",
    "filename": "gpac/CVE-2022-4202/CVE-2022-4202_CWE-189_b3d821c4ae9ba62b3a194d9dcb5e99f17bd56908_lsr_dec.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 315,
    "critical_vars": [
      "lsr->bs"
    ],
    "function": "lsr_read_extension",
    "filename": "gpac/CVE-2022-4202/CVE-2022-4202_CWE-189_b3d821c4ae9ba62b3a194d9dcb5e99f17bd56908_lsr_dec.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 316,
    "critical_vars": [
      "len"
    ],
    "function": "lsr_read_extension",
    "filename": "gpac/CVE-2022-4202/CVE-2022-4202_CWE-189_b3d821c4ae9ba62b3a194d9dcb5e99f17bd56908_lsr_dec.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 852,
    "critical_vars": [
      "nb_bits"
    ],
    "function": "lsr_read_id",
    "filename": "gpac/CVE-2022-4202/CVE-2022-4202_CWE-189_b3d821c4ae9ba62b3a194d9dcb5e99f17bd56908_lsr_dec.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 845,
    "line_new": 856,
    "critical_vars": [
      "neg"
    ],
    "function": "lsr_read_id",
    "filename": "gpac/CVE-2022-4202/CVE-2022-4202_CWE-189_b3d821c4ae9ba62b3a194d9dcb5e99f17bd56908_lsr_dec.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 856,
    "line_new": 867,
    "critical_vars": [
      "neg"
    ],
    "function": "lsr_translate_coords",
    "filename": "gpac/CVE-2022-4202/CVE-2022-4202_CWE-189_b3d821c4ae9ba62b3a194d9dcb5e99f17bd56908_lsr_dec.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Replace",
    "change_type": "Assignment",
    "line_old": 867,
    "line_new": 878,
    "critical_vars": [
      "v"
    ],
    "function": "lsr_translate_coords",
    "filename": "gpac/CVE-2022-4202/CVE-2022-4202_CWE-189_b3d821c4ae9ba62b3a194d9dcb5e99f17bd56908_lsr_dec.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 676,
    "critical_vars": [
      "max_write"
    ],
    "function": "None_func",
    "filename": "libarchive/CVE-2013-0211/CVE-2013-0211_CWE-189_22531545514043e04633e1c015c7540b9de9dbe4_archive_write.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 681,
    "critical_vars": [
      "s"
    ],
    "function": "None_func",
    "filename": "libarchive/CVE-2013-0211/CVE-2013-0211_CWE-189_22531545514043e04633e1c015c7540b9de9dbe4_archive_write.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 682,
    "critical_vars": [
      "s"
    ],
    "function": "None_func",
    "filename": "libarchive/CVE-2013-0211/CVE-2013-0211_CWE-189_22531545514043e04633e1c015c7540b9de9dbe4_archive_write.c.diff",
    "function_code": "",
    "label": "Unknown"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 838,
    "critical_vars": [
      "q"
    ],
    "function": "cdf_read_property_info",
    "filename": "file/CVE-2014-3587/CVE-2014-3587_CWE-189_0641e56be1af003aa02c7c6b0184466540637233_cdf.c.diff",
    "function_code": "cdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    uint32_t offs, cdf_property_info_t **info, size_t *count, size_t *maxcount)\n{\n\tconst cdf_section_header_t *shp;\n\tcdf_section_header_t sh;\n\tconst uint8_t *p, *q, *e;\n\tint16_t s16;\n\tint32_t s32;\n\tuint32_t u32;\n\tint64_t s64;\n\tuint64_t u64;\n\tcdf_timestamp_t tp;\n\tsize_t i, o, o4, nelements, j;\n\tcdf_property_info_t *inp;\n\n\tif (offs > UINT32_MAX / 4) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tshp = CAST(const cdf_section_header_t *, (const void *)\n\t    ((const char *)sst->sst_tab + offs));\n\tif (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1)\n\t\tgoto out;\n\tsh.sh_len = CDF_TOLE4(shp->sh_len);\n#define CDF_SHLEN_LIMIT (UINT32_MAX / 8)\n\tif (sh.sh_len > CDF_SHLEN_LIMIT) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tsh.sh_properties = CDF_TOLE4(shp->sh_properties);\n#define CDF_PROP_LIMIT (UINT32_MAX / (4 * sizeof(*inp)))\n\tif (sh.sh_properties > CDF_PROP_LIMIT)\n\t\tgoto out;\n\tDPRINTF((\"section len: %u properties %u\\n\", sh.sh_len,\n\t    sh.sh_properties));\n\tif (*maxcount) {\n\t\tif (*maxcount > CDF_PROP_LIMIT)\n\t\t\tgoto out;\n\t\t*maxcount += sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t} else {\n\t\t*maxcount = sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    malloc(*maxcount * sizeof(*inp)));\n\t}\n\tif (inp == NULL)\n\t\tgoto out;\n\t*info = inp;\n\tinp += *count;\n\t*count += sh.sh_properties;\n\tp = CAST(const uint8_t *, (const void *)\n\t    ((const char *)(const void *)sst->sst_tab +\n\t    offs + sizeof(sh)));\n\te = CAST(const uint8_t *, (const void *)\n\t    (((const char *)(const void *)shp) + sh.sh_len));\n\tif (cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)\n\t\tgoto out;\n\tfor (i = 0; i < sh.sh_properties; i++) {\n\t\tq = (const uint8_t *)(const void *)\n\t\t    ((const char *)(const void *)p +\n\t\t    CDF_GETUINT32(p, (i << 1) + 1)) - 2 * sizeof(uint32_t);\n\t\tif (q > e) {\n\t\t\tDPRINTF((\"Ran of the end %p > %p\\n\", q, e));\n\t\t\tgoto out;\n\t\t}\n\t\tinp[i].pi_id = CDF_GETUINT32(p, i << 1);\n\t\tinp[i].pi_type = CDF_GETUINT32(q, 0);\n\t\tDPRINTF((\"%d) id=%x type=%x offs=%x,%d\\n\", i, inp[i].pi_id,\n\t\t    inp[i].pi_type, q - p, CDF_GETUINT32(p, (i << 1) + 1)));\n\t\tif (inp[i].pi_type & CDF_VECTOR) {\n\t\t\tnelements = CDF_GETUINT32(q, 1);\n\t\t\to = 2;\n\t\t} else {\n\t\t\tnelements = 1;\n\t\t\to = 1;\n\t\t}\n\t\to4 = o * sizeof(uint32_t);\n\t\tif (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED))\n\t\t\tgoto unknown;\n\t\tswitch (inp[i].pi_type & CDF_TYPEMASK) {\n\t\tcase CDF_NULL:\n\t\tcase CDF_EMPTY:\n\t\t\tbreak;\n\t\tcase CDF_SIGNED16:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s16, &q[o4], sizeof(s16));\n\t\t\tinp[i].pi_s16 = CDF_TOLE2(s16);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s32, &q[o4], sizeof(s32));\n\t\t\tinp[i].pi_s32 = CDF_TOLE4((uint32_t)s32);\n\t\t\tbreak;\n\t\tcase CDF_BOOL:\n\t\tcase CDF_UNSIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u32, &q[o4], sizeof(u32));\n\t\t\tinp[i].pi_u32 = CDF_TOLE4(u32);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s64, &q[o4], sizeof(s64));\n\t\t\tinp[i].pi_s64 = CDF_TOLE8((uint64_t)s64);\n\t\t\tbreak;\n\t\tcase CDF_UNSIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u64, &q[o4], sizeof(u64));\n\t\t\tinp[i].pi_u64 = CDF_TOLE8((uint64_t)u64);\n\t\t\tbreak;\n\t\tcase CDF_LENGTH32_STRING:\n\t\tcase CDF_LENGTH32_WSTRING:\n\t\t\tif (nelements > 1) {\n\t\t\t\tsize_t nelem = inp - *info;\n\t\t\t\tif (*maxcount > CDF_PROP_LIMIT\n\t\t\t\t    || nelements > CDF_PROP_LIMIT)\n\t\t\t\t\tgoto out;\n\t\t\t\t*maxcount += nelements;\n\t\t\t\tinp = CAST(cdf_property_info_t *,\n\t\t\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t\t\t\tif (inp == NULL)\n\t\t\t\t\tgoto out;\n\t\t\t\t*info = inp;\n\t\t\t\tinp = *info + nelem;\n\t\t\t}\n\t\t\tDPRINTF((\"nelements = %d\\n\", nelements));\n\t\t\tfor (j = 0; j < nelements; j++, i++) {\n\t\t\t\tuint32_t l = CDF_GETUINT32(q, o);\n\t\t\t\tinp[i].pi_str.s_len = l;\n\t\t\t\tinp[i].pi_str.s_buf = (const char *)\n\t\t\t\t    (const void *)(&q[o4 + sizeof(l)]);\n\t\t\t\tDPRINTF((\"l = %d, r = %d, s = %s\\n\", l,\n\t\t\t\t    CDF_ROUND(l, sizeof(l)),\n\t\t\t\t    inp[i].pi_str.s_buf));\n\t\t\t\tl = 4 + (uint32_t)CDF_ROUND(l, sizeof(l));\n\t\t\t\to += l >> 2;\n\t\t\t\tif (q + o >= e)\n\t\t\t\t\tgoto out;\n\t\t\t\to4 = o * sizeof(uint32_t);\n\t\t\t}\n\t\t\ti--;\n\t\t\tbreak;\n\t\tcase CDF_FILETIME:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&tp, &q[o4], sizeof(tp));\n\t\t\tinp[i].pi_tp = CDF_TOLE8((uint64_t)tp);\n\t\t\tbreak;\n\t\tcase CDF_CLIPBOARD:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tdefault:\n\t\tunknown:\n\t\t\tDPRINTF((\"Don't know how to deal with %x\\n\",\n\t\t\t    inp[i].pi_type));\n\t\t\tgoto out;\n\t\t}\n\t}\n\treturn 0;\nout:\n\tfree(*info);\n\treturn -1;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 839,
    "critical_vars": [
      "p",
      "q"
    ],
    "function": "cdf_read_property_info",
    "filename": "file/CVE-2014-3587/CVE-2014-3587_CWE-189_0641e56be1af003aa02c7c6b0184466540637233_cdf.c.diff",
    "function_code": "cdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    uint32_t offs, cdf_property_info_t **info, size_t *count, size_t *maxcount)\n{\n\tconst cdf_section_header_t *shp;\n\tcdf_section_header_t sh;\n\tconst uint8_t *p, *q, *e;\n\tint16_t s16;\n\tint32_t s32;\n\tuint32_t u32;\n\tint64_t s64;\n\tuint64_t u64;\n\tcdf_timestamp_t tp;\n\tsize_t i, o, o4, nelements, j;\n\tcdf_property_info_t *inp;\n\n\tif (offs > UINT32_MAX / 4) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tshp = CAST(const cdf_section_header_t *, (const void *)\n\t    ((const char *)sst->sst_tab + offs));\n\tif (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1)\n\t\tgoto out;\n\tsh.sh_len = CDF_TOLE4(shp->sh_len);\n#define CDF_SHLEN_LIMIT (UINT32_MAX / 8)\n\tif (sh.sh_len > CDF_SHLEN_LIMIT) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tsh.sh_properties = CDF_TOLE4(shp->sh_properties);\n#define CDF_PROP_LIMIT (UINT32_MAX / (4 * sizeof(*inp)))\n\tif (sh.sh_properties > CDF_PROP_LIMIT)\n\t\tgoto out;\n\tDPRINTF((\"section len: %u properties %u\\n\", sh.sh_len,\n\t    sh.sh_properties));\n\tif (*maxcount) {\n\t\tif (*maxcount > CDF_PROP_LIMIT)\n\t\t\tgoto out;\n\t\t*maxcount += sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t} else {\n\t\t*maxcount = sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    malloc(*maxcount * sizeof(*inp)));\n\t}\n\tif (inp == NULL)\n\t\tgoto out;\n\t*info = inp;\n\tinp += *count;\n\t*count += sh.sh_properties;\n\tp = CAST(const uint8_t *, (const void *)\n\t    ((const char *)(const void *)sst->sst_tab +\n\t    offs + sizeof(sh)));\n\te = CAST(const uint8_t *, (const void *)\n\t    (((const char *)(const void *)shp) + sh.sh_len));\n\tif (cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)\n\t\tgoto out;\n\tfor (i = 0; i < sh.sh_properties; i++) {\n\t\tq = (const uint8_t *)(const void *)\n\t\t    ((const char *)(const void *)p +\n\t\t    CDF_GETUINT32(p, (i << 1) + 1)) - 2 * sizeof(uint32_t);\n\t\tif (q > e) {\n\t\t\tDPRINTF((\"Ran of the end %p > %p\\n\", q, e));\n\t\t\tgoto out;\n\t\t}\n\t\tinp[i].pi_id = CDF_GETUINT32(p, i << 1);\n\t\tinp[i].pi_type = CDF_GETUINT32(q, 0);\n\t\tDPRINTF((\"%d) id=%x type=%x offs=%x,%d\\n\", i, inp[i].pi_id,\n\t\t    inp[i].pi_type, q - p, CDF_GETUINT32(p, (i << 1) + 1)));\n\t\tif (inp[i].pi_type & CDF_VECTOR) {\n\t\t\tnelements = CDF_GETUINT32(q, 1);\n\t\t\to = 2;\n\t\t} else {\n\t\t\tnelements = 1;\n\t\t\to = 1;\n\t\t}\n\t\to4 = o * sizeof(uint32_t);\n\t\tif (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED))\n\t\t\tgoto unknown;\n\t\tswitch (inp[i].pi_type & CDF_TYPEMASK) {\n\t\tcase CDF_NULL:\n\t\tcase CDF_EMPTY:\n\t\t\tbreak;\n\t\tcase CDF_SIGNED16:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s16, &q[o4], sizeof(s16));\n\t\t\tinp[i].pi_s16 = CDF_TOLE2(s16);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s32, &q[o4], sizeof(s32));\n\t\t\tinp[i].pi_s32 = CDF_TOLE4((uint32_t)s32);\n\t\t\tbreak;\n\t\tcase CDF_BOOL:\n\t\tcase CDF_UNSIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u32, &q[o4], sizeof(u32));\n\t\t\tinp[i].pi_u32 = CDF_TOLE4(u32);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s64, &q[o4], sizeof(s64));\n\t\t\tinp[i].pi_s64 = CDF_TOLE8((uint64_t)s64);\n\t\t\tbreak;\n\t\tcase CDF_UNSIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u64, &q[o4], sizeof(u64));\n\t\t\tinp[i].pi_u64 = CDF_TOLE8((uint64_t)u64);\n\t\t\tbreak;\n\t\tcase CDF_LENGTH32_STRING:\n\t\tcase CDF_LENGTH32_WSTRING:\n\t\t\tif (nelements > 1) {\n\t\t\t\tsize_t nelem = inp - *info;\n\t\t\t\tif (*maxcount > CDF_PROP_LIMIT\n\t\t\t\t    || nelements > CDF_PROP_LIMIT)\n\t\t\t\t\tgoto out;\n\t\t\t\t*maxcount += nelements;\n\t\t\t\tinp = CAST(cdf_property_info_t *,\n\t\t\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t\t\t\tif (inp == NULL)\n\t\t\t\t\tgoto out;\n\t\t\t\t*info = inp;\n\t\t\t\tinp = *info + nelem;\n\t\t\t}\n\t\t\tDPRINTF((\"nelements = %d\\n\", nelements));\n\t\t\tfor (j = 0; j < nelements; j++, i++) {\n\t\t\t\tuint32_t l = CDF_GETUINT32(q, o);\n\t\t\t\tinp[i].pi_str.s_len = l;\n\t\t\t\tinp[i].pi_str.s_buf = (const char *)\n\t\t\t\t    (const void *)(&q[o4 + sizeof(l)]);\n\t\t\t\tDPRINTF((\"l = %d, r = %d, s = %s\\n\", l,\n\t\t\t\t    CDF_ROUND(l, sizeof(l)),\n\t\t\t\t    inp[i].pi_str.s_buf));\n\t\t\t\tl = 4 + (uint32_t)CDF_ROUND(l, sizeof(l));\n\t\t\t\to += l >> 2;\n\t\t\t\tif (q + o >= e)\n\t\t\t\t\tgoto out;\n\t\t\t\to4 = o * sizeof(uint32_t);\n\t\t\t}\n\t\t\ti--;\n\t\t\tbreak;\n\t\tcase CDF_FILETIME:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&tp, &q[o4], sizeof(tp));\n\t\t\tinp[i].pi_tp = CDF_TOLE8((uint64_t)tp);\n\t\t\tbreak;\n\t\tcase CDF_CLIPBOARD:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tdefault:\n\t\tunknown:\n\t\t\tDPRINTF((\"Don't know how to deal with %x\\n\",\n\t\t\t    inp[i].pi_type));\n\t\t\tgoto out;\n\t\t}\n\t}\n\treturn 0;\nout:\n\tfree(*info);\n\treturn -1;\n}",
    "label": "False"
  }
]