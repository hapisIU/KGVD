[
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 94,
    "critical_vars": [
      "sr->fid_ofile",
      "sr"
    ],
    "function": "smb_com_flush",
    "filename": "illumos-gate/CVE-2016-6561/CVE-2016-6561_CWE-476_6d1c73b5858fefc6161c7d686345f0dc887ea799_smb_flush.c.diff",
    "function_code": "smb_com_flush(smb_request_t *sr)\n{\n\tsmb_ofile_t\t*file;\n\tsmb_llist_t\t*flist;\n\tint\t\trc;\n\n\tif (smb_flush_required == 0) {\n\t\trc = smbsr_encode_empty_result(sr);\n\t\treturn ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);\n\t}\n\n\tif (sr->smb_fid != 0xffff) {\n\t\tsmbsr_lookup_file(sr);\n\t\tif (sr->fid_ofile == NULL) {\n\t\t\tsmbsr_error(sr, NT_STATUS_INVALID_HANDLE,\n\t\t\t    ERRDOS, ERRbadfid);\n\t\t\treturn (SDRC_ERROR);\n\t\t}\n\n\t\tsmb_flush_file(sr, sr->fid_ofile);\n\t} else {\n\t\tflist = &sr->tid_tree->t_ofile_list;\n\t\tsmb_llist_enter(flist, RW_READER);\n\t\tfile = smb_llist_head(flist);\n\t\twhile (file) {\n\t\t\tmutex_enter(&file->f_mutex);\n\t\t\tsmb_flush_file(sr, file);\n\t\t\tmutex_exit(&file->f_mutex);\n\t\t\tfile = smb_llist_next(flist, file);\n\t\t}\n\t\tsmb_llist_exit(flist);\n\t}\n\n\trc = smbsr_encode_empty_result(sr);\n\treturn ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 93,
    "critical_vars": [
      "sr->fid_ofile",
      "sr"
    ],
    "function": "smb_com_flush",
    "filename": "illumos-gate/CVE-2016-6561/CVE-2016-6561_CWE-476_6d1c73b5858fefc6161c7d686345f0dc887ea799_smb_flush.c.diff",
    "function_code": "smb_com_flush(smb_request_t *sr)\n{\n\tsmb_ofile_t\t*file;\n\tsmb_llist_t\t*flist;\n\tint\t\trc;\n\n\tif (smb_flush_required == 0) {\n\t\trc = smbsr_encode_empty_result(sr);\n\t\treturn ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);\n\t}\n\n\tif (sr->smb_fid != 0xffff) {\n\t\tsmbsr_lookup_file(sr);\n\t\tif (sr->fid_ofile == NULL) {\n\t\t\tsmbsr_error(sr, NT_STATUS_INVALID_HANDLE,\n\t\t\t    ERRDOS, ERRbadfid);\n\t\t\treturn (SDRC_ERROR);\n\t\t}\n\t\tsmb_ofile_flush(sr, sr->fid_ofile);\n\t} else {\n\t\tflist = &sr->tid_tree->t_ofile_list;\n\t\tsmb_llist_enter(flist, RW_READER);\n\t\tfile = smb_llist_head(flist);\n\t\twhile (file) {\n\t\t\tmutex_enter(&file->f_mutex);\n\t\t\tsmb_ofile_flush(sr, file);\n\t\t\tmutex_exit(&file->f_mutex);\n\t\t\tfile = smb_llist_next(flist, file);\n\t\t}\n\t\tsmb_llist_exit(flist);\n\t}\n\n\trc = smbsr_encode_empty_result(sr);\n\treturn ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 54,
    "critical_vars": [
      "of"
    ],
    "function": "smb2_flush",
    "filename": "illumos-gate/CVE-2016-6561/CVE-2016-6561_CWE-476_6d1c73b5858fefc6161c7d686345f0dc887ea799_smb2_flush.c.diff",
    "function_code": "smb2_flush(smb_request_t *sr)\n{\n\tsmb_ofile_t *of = NULL;\n\tuint16_t StructSize;\n\tuint16_t reserved1;\n\tuint32_t reserved2;\n\tsmb2fid_t smb2fid;\n\tuint32_t status;\n\tint rc = 0;\n\n\t/*\n\t * SMB2 Flush request\n\t */\n\trc = smb_mbc_decodef(\n\t    &sr->smb_data, \"wwlqq\",\n\t    &StructSize,\t\t/* w */\n\t    &reserved1,\t\t\t/* w */\n\t    &reserved2,\t\t\t/* l */\n\t    &smb2fid.persistent,\t/* q */\n\t    &smb2fid.temporal);\t\t/* q */\n\tif (rc)\n\t\treturn (SDRC_ERROR);\n\tif (StructSize != 24)\n\t\treturn (SDRC_ERROR);\n\n\tstatus = smb2sr_lookup_fid(sr, &smb2fid);\n\tif (status) {\n\t\tsmb2sr_put_error(sr, status);\n\t\treturn (SDRC_SUCCESS);\n\t}\n\tof = sr->fid_ofile;\n\n\t/*\n\t * XXX - todo:\n\t * Flush named pipe should drain writes.\n\t */\n\tif ((of->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)\n\t\t(void) smb_fsop_commit(sr, of->f_cr, of->f_node);\n\n\t/*\n\t * SMB2 Flush reply\n\t */\n\t(void) smb_mbc_encodef(\n\t    &sr->reply, \"wwl\",\n\t    4,\t/* StructSize */\t/* w */\n\t    0); /* reserved */\t\t/* w */\n\n\treturn (SDRC_SUCCESS);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 55,
    "critical_vars": [
      "sr->fid_ofile",
      "sr"
    ],
    "function": "smb2_flush",
    "filename": "illumos-gate/CVE-2016-6561/CVE-2016-6561_CWE-476_6d1c73b5858fefc6161c7d686345f0dc887ea799_smb2_flush.c.diff",
    "function_code": "smb2_flush(smb_request_t *sr)\n{\n\tuint16_t StructSize;\n\tuint16_t reserved1;\n\tuint32_t reserved2;\n\tsmb2fid_t smb2fid;\n\tuint32_t status;\n\tint rc = 0;\n\n\t/*\n\t * SMB2 Flush request\n\t */\n\trc = smb_mbc_decodef(\n\t    &sr->smb_data, \"wwlqq\",\n\t    &StructSize,\t\t/* w */\n\t    &reserved1,\t\t\t/* w */\n\t    &reserved2,\t\t\t/* l */\n\t    &smb2fid.persistent,\t/* q */\n\t    &smb2fid.temporal);\t\t/* q */\n\tif (rc)\n\t\treturn (SDRC_ERROR);\n\tif (StructSize != 24)\n\t\treturn (SDRC_ERROR);\n\n\tstatus = smb2sr_lookup_fid(sr, &smb2fid);\n\tif (status) {\n\t\tsmb2sr_put_error(sr, status);\n\t\treturn (SDRC_SUCCESS);\n\t}\n\n\tsmb_ofile_flush(sr, sr->fid_ofile);\n\n\t/*\n\t * SMB2 Flush reply\n\t */\n\t(void) smb_mbc_encodef(\n\t    &sr->reply, \"wwl\",\n\t    4,\t/* StructSize */\t/* w */\n\t    0); /* reserved */\t\t/* w */\n\n\treturn (SDRC_SUCCESS);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 5695,
    "critical_vars": [
      "skb"
    ],
    "function": "sctp_sock_migrate",
    "filename": "linux/CVE-2011-2482/CVE-2011-2482_CWE-476_ea2bc483ff5caada7c4aa0d5fbf87d3a6590273d_socket.c.diff",
    "function_code": "static void sctp_sock_migrate(struct sock *oldsk, struct sock *newsk,\n\t\t\t      struct sctp_association *assoc,\n\t\t\t      sctp_socket_type_t type)\n{\n\tstruct sctp_sock *oldsp = sctp_sk(oldsk);\n\tstruct sctp_sock *newsp = sctp_sk(newsk);\n\tstruct sctp_bind_bucket *pp; /* hash list port iterator */\n\tstruct sctp_endpoint *newep = newsp->ep;\n\tstruct sk_buff *skb, *tmp;\n\tstruct sctp_ulpevent *event;\n\tint flags = 0;\n\n\t/* Migrate socket buffer sizes and all the socket level options to the\n\t * new socket.\n\t */\n\tnewsk->sk_sndbuf = oldsk->sk_sndbuf;\n\tnewsk->sk_rcvbuf = oldsk->sk_rcvbuf;\n\t/* Brute force copy old sctp opt. */\n\tinet_sk_copy_descendant(newsk, oldsk);\n\n\t/* Restore the ep value that was overwritten with the above structure\n\t * copy.\n\t */\n\tnewsp->ep = newep;\n\tnewsp->hmac = NULL;\n\n\t/* Hook this new socket in to the bind_hash list. */\n\tpp = sctp_sk(oldsk)->bind_hash;\n\tsk_add_bind_node(newsk, &pp->owner);\n\tsctp_sk(newsk)->bind_hash = pp;\n\tinet_sk(newsk)->num = inet_sk(oldsk)->num;\n\n\t/* Copy the bind_addr list from the original endpoint to the new\n\t * endpoint so that we can handle restarts properly\n\t */\n\tif (PF_INET6 == assoc->base.sk->sk_family)\n\t\tflags = SCTP_ADDR6_ALLOWED;\n\tif (assoc->peer.ipv4_address)\n\t\tflags |= SCTP_ADDR4_PEERSUPP;\n\tif (assoc->peer.ipv6_address)\n\t\tflags |= SCTP_ADDR6_PEERSUPP;\n\tsctp_bind_addr_copy(&newsp->ep->base.bind_addr,\n\t\t\t     &oldsp->ep->base.bind_addr,\n\t\t\t     SCTP_SCOPE_GLOBAL, GFP_KERNEL, flags);\n\n\t/* Move any messages in the old socket's receive queue that are for the\n\t * peeled off association to the new socket's receive queue.\n\t */\n\tsctp_skb_for_each(skb, &oldsk->sk_receive_queue, tmp) {\n\t\tevent = sctp_skb2event(skb);\n\t\tif (event->asoc == assoc) {\n\t\t\tsctp_sock_rfree(skb);\n\t\t\t__skb_unlink(skb, &oldsk->sk_receive_queue);\n\t\t\t__skb_queue_tail(&newsk->sk_receive_queue, skb);\n\t\t\tsctp_skb_set_owner_r(skb, newsk);\n\t\t}\n\t}\n\n\t/* Clean up any messages pending delivery due to partial\n\t * delivery.   Three cases:\n\t * 1) No partial deliver;  no work.\n\t * 2) Peeling off partial delivery; keep pd_lobby in new pd_lobby.\n\t * 3) Peeling off non-partial delivery; move pd_lobby to receive_queue.\n\t */\n\tskb_queue_head_init(&newsp->pd_lobby);\n\tsctp_sk(newsk)->pd_mode = assoc->ulpq.pd_mode;\n\n\tif (sctp_sk(oldsk)->pd_mode) {\n\t\tstruct sk_buff_head *queue;\n\n\t\t/* Decide which queue to move pd_lobby skbs to. */\n\t\tif (assoc->ulpq.pd_mode) {\n\t\t\tqueue = &newsp->pd_lobby;\n\t\t} else\n\t\t\tqueue = &newsk->sk_receive_queue;\n\n\t\t/* Walk through the pd_lobby, looking for skbs that\n\t\t * need moved to the new socket.\n\t\t */\n\t\tsctp_skb_for_each(skb, &oldsp->pd_lobby, tmp) {\n\t\t\tevent = sctp_skb2event(skb);\n\t\t\tif (event->asoc == assoc) {\n\t\t\t\tsctp_sock_rfree(skb);\n\t\t\t\t__skb_unlink(skb, &oldsp->pd_lobby);\n\t\t\t\t__skb_queue_tail(queue, skb);\n\t\t\t\tsctp_skb_set_owner_r(skb, newsk);\n\t\t\t}\n\t\t}\n\n\t\t/* Clear up any skbs waiting for the partial\n\t\t * delivery to finish.\n\t\t */\n\t\tif (assoc->ulpq.pd_mode)\n\t\t\tsctp_clear_pd(oldsk);\n\n\t}\n\n\t/* Set the type of socket to indicate that it is peeled off from the\n\t * original UDP-style socket or created with the accept() call on a\n\t * TCP-style socket..\n\t */\n\tnewsp->type = type;\n\n\t/* Mark the new socket \"in-use\" by the user so that any packets\n\t * that may arrive on the association after we've moved it are\n\t * queued to the backlog.  This prevents a potential race between\n\t * backlog processing on the old socket and new-packet processing\n\t * on the new socket.\n\t */\n\tsctp_lock_sock(newsk);\n\tsctp_assoc_migrate(assoc, newsk);\n\n\t/* If the association on the newsk is already closed before accept()\n\t * is called, set RCV_SHUTDOWN flag.\n\t */\n\tif (sctp_state(assoc, CLOSED) && sctp_style(newsk, TCP))\n\t\tnewsk->sk_shutdown |= RCV_SHUTDOWN;\n\n\tnewsk->sk_state = SCTP_SS_ESTABLISHED;\n\tsctp_release_sock(newsk);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 5725,
    "critical_vars": [
      "skb"
    ],
    "function": "sctp_sock_migrate",
    "filename": "linux/CVE-2011-2482/CVE-2011-2482_CWE-476_ea2bc483ff5caada7c4aa0d5fbf87d3a6590273d_socket.c.diff",
    "function_code": "static void sctp_sock_migrate(struct sock *oldsk, struct sock *newsk,\n\t\t\t      struct sctp_association *assoc,\n\t\t\t      sctp_socket_type_t type)\n{\n\tstruct sctp_sock *oldsp = sctp_sk(oldsk);\n\tstruct sctp_sock *newsp = sctp_sk(newsk);\n\tstruct sctp_bind_bucket *pp; /* hash list port iterator */\n\tstruct sctp_endpoint *newep = newsp->ep;\n\tstruct sk_buff *skb, *tmp;\n\tstruct sctp_ulpevent *event;\n\tint flags = 0;\n\n\t/* Migrate socket buffer sizes and all the socket level options to the\n\t * new socket.\n\t */\n\tnewsk->sk_sndbuf = oldsk->sk_sndbuf;\n\tnewsk->sk_rcvbuf = oldsk->sk_rcvbuf;\n\t/* Brute force copy old sctp opt. */\n\tinet_sk_copy_descendant(newsk, oldsk);\n\n\t/* Restore the ep value that was overwritten with the above structure\n\t * copy.\n\t */\n\tnewsp->ep = newep;\n\tnewsp->hmac = NULL;\n\n\t/* Hook this new socket in to the bind_hash list. */\n\tpp = sctp_sk(oldsk)->bind_hash;\n\tsk_add_bind_node(newsk, &pp->owner);\n\tsctp_sk(newsk)->bind_hash = pp;\n\tinet_sk(newsk)->num = inet_sk(oldsk)->num;\n\n\t/* Copy the bind_addr list from the original endpoint to the new\n\t * endpoint so that we can handle restarts properly\n\t */\n\tif (PF_INET6 == assoc->base.sk->sk_family)\n\t\tflags = SCTP_ADDR6_ALLOWED;\n\tif (assoc->peer.ipv4_address)\n\t\tflags |= SCTP_ADDR4_PEERSUPP;\n\tif (assoc->peer.ipv6_address)\n\t\tflags |= SCTP_ADDR6_PEERSUPP;\n\tsctp_bind_addr_copy(&newsp->ep->base.bind_addr,\n\t\t\t     &oldsp->ep->base.bind_addr,\n\t\t\t     SCTP_SCOPE_GLOBAL, GFP_KERNEL, flags);\n\n\t/* Move any messages in the old socket's receive queue that are for the\n\t * peeled off association to the new socket's receive queue.\n\t */\n\tsctp_skb_for_each(skb, &oldsk->sk_receive_queue, tmp) {\n\t\tevent = sctp_skb2event(skb);\n\t\tif (event->asoc == assoc) {\n\t\t\tsctp_sock_rfree_frag(skb);\n\t\t\t__skb_unlink(skb, &oldsk->sk_receive_queue);\n\t\t\t__skb_queue_tail(&newsk->sk_receive_queue, skb);\n\t\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\t\t}\n\t}\n\n\t/* Clean up any messages pending delivery due to partial\n\t * delivery.   Three cases:\n\t * 1) No partial deliver;  no work.\n\t * 2) Peeling off partial delivery; keep pd_lobby in new pd_lobby.\n\t * 3) Peeling off non-partial delivery; move pd_lobby to receive_queue.\n\t */\n\tskb_queue_head_init(&newsp->pd_lobby);\n\tsctp_sk(newsk)->pd_mode = assoc->ulpq.pd_mode;\n\n\tif (sctp_sk(oldsk)->pd_mode) {\n\t\tstruct sk_buff_head *queue;\n\n\t\t/* Decide which queue to move pd_lobby skbs to. */\n\t\tif (assoc->ulpq.pd_mode) {\n\t\t\tqueue = &newsp->pd_lobby;\n\t\t} else\n\t\t\tqueue = &newsk->sk_receive_queue;\n\n\t\t/* Walk through the pd_lobby, looking for skbs that\n\t\t * need moved to the new socket.\n\t\t */\n\t\tsctp_skb_for_each(skb, &oldsp->pd_lobby, tmp) {\n\t\t\tevent = sctp_skb2event(skb);\n\t\t\tif (event->asoc == assoc) {\n\t\t\t\tsctp_sock_rfree_frag(skb);\n\t\t\t\t__skb_unlink(skb, &oldsp->pd_lobby);\n\t\t\t\t__skb_queue_tail(queue, skb);\n\t\t\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\t\t\t}\n\t\t}\n\n\t\t/* Clear up any skbs waiting for the partial\n\t\t * delivery to finish.\n\t\t */\n\t\tif (assoc->ulpq.pd_mode)\n\t\t\tsctp_clear_pd(oldsk);\n\n\t}\n\n\tsctp_skb_for_each(skb, &assoc->ulpq.reasm, tmp) {\n\t\tsctp_sock_rfree_frag(skb);\n\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\t}\n\n\tsctp_skb_for_each(skb, &assoc->ulpq.lobby, tmp) {\n\t\tsctp_sock_rfree_frag(skb);\n\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\t}\n\n\t/* Set the type of socket to indicate that it is peeled off from the\n\t * original UDP-style socket or created with the accept() call on a\n\t * TCP-style socket..\n\t */\n\tnewsp->type = type;\n\n\t/* Mark the new socket \"in-use\" by the user so that any packets\n\t * that may arrive on the association after we've moved it are\n\t * queued to the backlog.  This prevents a potential race between\n\t * backlog processing on the old socket and new-packet processing\n\t * on the new socket.\n\t */\n\tsctp_lock_sock(newsk);\n\tsctp_assoc_migrate(assoc, newsk);\n\n\t/* If the association on the newsk is already closed before accept()\n\t * is called, set RCV_SHUTDOWN flag.\n\t */\n\tif (sctp_state(assoc, CLOSED) && sctp_style(newsk, TCP))\n\t\tnewsk->sk_shutdown |= RCV_SHUTDOWN;\n\n\tnewsk->sk_state = SCTP_SS_ESTABLISHED;\n\tsctp_release_sock(newsk);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 727,
    "critical_vars": [
      "new_n0->back_pointer"
    ],
    "function": "assoc_array_insert_into_terminal_node",
    "filename": "linux/CVE-2017-12193/CVE-2017-12193_CWE-476_ea6789980fdaa610d7eb63602c746bf6ec70cd2b_assoc_array.c.diff",
    "function_code": "static bool assoc_array_insert_into_terminal_node(struct assoc_array_edit *edit,\n\t\t\t\t\t\t  const struct assoc_array_ops *ops,\n\t\t\t\t\t\t  const void *index_key,\n\t\t\t\t\t\t  struct assoc_array_walk_result *result)\n{\n\tstruct assoc_array_shortcut *shortcut, *new_s0;\n\tstruct assoc_array_node *node, *new_n0, *new_n1, *side;\n\tstruct assoc_array_ptr *ptr;\n\tunsigned long dissimilarity, base_seg, blank;\n\tsize_t keylen;\n\tbool have_meta;\n\tint level, diff;\n\tint slot, next_slot, free_slot, i, j;\n\n\tnode\t= result->terminal_node.node;\n\tlevel\t= result->terminal_node.level;\n\tedit->segment_cache[ASSOC_ARRAY_FAN_OUT] = result->terminal_node.slot;\n\n\tpr_devel(\"-->%s()\\n\", __func__);\n\n\t/* We arrived at a node which doesn't have an onward node or shortcut\n\t * pointer that we have to follow.  This means that (a) the leaf we\n\t * want must go here (either by insertion or replacement) or (b) we\n\t * need to split this node and insert in one of the fragments.\n\t */\n\tfree_slot = -1;\n\n\t/* Firstly, we have to check the leaves in this node to see if there's\n\t * a matching one we should replace in place.\n\t */\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tptr = node->slots[i];\n\t\tif (!ptr) {\n\t\t\tfree_slot = i;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ops->compare_object(assoc_array_ptr_to_leaf(ptr), index_key)) {\n\t\t\tpr_devel(\"replace in slot %d\\n\", i);\n\t\t\tedit->leaf_p = &node->slots[i];\n\t\t\tedit->dead_leaf = node->slots[i];\n\t\t\tpr_devel(\"<--%s() = ok [replace]\\n\", __func__);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/* If there is a free slot in this node then we can just insert the\n\t * leaf here.\n\t */\n\tif (free_slot >= 0) {\n\t\tpr_devel(\"insert in free slot %d\\n\", free_slot);\n\t\tedit->leaf_p = &node->slots[free_slot];\n\t\tedit->adjust_count_on = node;\n\t\tpr_devel(\"<--%s() = ok [insert]\\n\", __func__);\n\t\treturn true;\n\t}\n\n\t/* The node has no spare slots - so we're either going to have to split\n\t * it or insert another node before it.\n\t *\n\t * Whatever, we're going to need at least two new nodes - so allocate\n\t * those now.  We may also need a new shortcut, but we deal with that\n\t * when we need it.\n\t */\n\tnew_n0 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);\n\tif (!new_n0)\n\t\treturn false;\n\tedit->new_meta[0] = assoc_array_node_to_ptr(new_n0);\n\tnew_n1 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);\n\tif (!new_n1)\n\t\treturn false;\n\tedit->new_meta[1] = assoc_array_node_to_ptr(new_n1);\n\n\t/* We need to find out how similar the leaves are. */\n\tpr_devel(\"no spare slots\\n\");\n\thave_meta = false;\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tptr = node->slots[i];\n\t\tif (assoc_array_ptr_is_meta(ptr)) {\n\t\t\tedit->segment_cache[i] = 0xff;\n\t\t\thave_meta = true;\n\t\t\tcontinue;\n\t\t}\n\t\tbase_seg = ops->get_object_key_chunk(\n\t\t\tassoc_array_ptr_to_leaf(ptr), level);\n\t\tbase_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;\n\t\tedit->segment_cache[i] = base_seg & ASSOC_ARRAY_FAN_MASK;\n\t}\n\n\tif (have_meta) {\n\t\tpr_devel(\"have meta\\n\");\n\t\tgoto split_node;\n\t}\n\n\t/* The node contains only leaves */\n\tdissimilarity = 0;\n\tbase_seg = edit->segment_cache[0];\n\tfor (i = 1; i < ASSOC_ARRAY_FAN_OUT; i++)\n\t\tdissimilarity |= edit->segment_cache[i] ^ base_seg;\n\n\tpr_devel(\"only leaves; dissimilarity=%lx\\n\", dissimilarity);\n\n\tif ((dissimilarity & ASSOC_ARRAY_FAN_MASK) == 0) {\n\t\t/* The old leaves all cluster in the same slot.  We will need\n\t\t * to insert a shortcut if the new node wants to cluster with them.\n\t\t */\n\t\tif ((edit->segment_cache[ASSOC_ARRAY_FAN_OUT] ^ base_seg) == 0)\n\t\t\tgoto all_leaves_cluster_together;\n\n\t\t/* Otherwise we can just insert a new node ahead of the old\n\t\t * one.\n\t\t */\n\t\tgoto present_leaves_cluster_but_not_new_leaf;\n\t}\n\nsplit_node:\n\tpr_devel(\"split node\\n\");\n\n\t/* We need to split the current node; we know that the node doesn't\n\t * simply contain a full set of leaves that cluster together (it\n\t * contains meta pointers and/or non-clustering leaves).\n\t *\n\t * We need to expel at least two leaves out of a set consisting of the\n\t * leaves in the node and the new leaf.\n\t *\n\t * We need a new node (n0) to replace the current one and a new node to\n\t * take the expelled nodes (n1).\n\t */\n\tedit->set[0].to = assoc_array_node_to_ptr(new_n0);\n\tnew_n0->back_pointer = node->back_pointer;\n\tnew_n0->parent_slot = node->parent_slot;\n\tnew_n1->back_pointer = assoc_array_node_to_ptr(new_n0);\n\tnew_n1->parent_slot = -1; /* Need to calculate this */\n\ndo_split_node:\n\tpr_devel(\"do_split_node\\n\");\n\n\tnew_n0->nr_leaves_on_branch = node->nr_leaves_on_branch;\n\tnew_n1->nr_leaves_on_branch = 0;\n\n\t/* Begin by finding two matching leaves.  There have to be at least two\n\t * that match - even if there are meta pointers - because any leaf that\n\t * would match a slot with a meta pointer in it must be somewhere\n\t * behind that meta pointer and cannot be here.  Further, given N\n\t * remaining leaf slots, we now have N+1 leaves to go in them.\n\t */\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tslot = edit->segment_cache[i];\n\t\tif (slot != 0xff)\n\t\t\tfor (j = i + 1; j < ASSOC_ARRAY_FAN_OUT + 1; j++)\n\t\t\t\tif (edit->segment_cache[j] == slot)\n\t\t\t\t\tgoto found_slot_for_multiple_occupancy;\n\t}\nfound_slot_for_multiple_occupancy:\n\tpr_devel(\"same slot: %x %x [%02x]\\n\", i, j, slot);\n\tBUG_ON(i >= ASSOC_ARRAY_FAN_OUT);\n\tBUG_ON(j >= ASSOC_ARRAY_FAN_OUT + 1);\n\tBUG_ON(slot >= ASSOC_ARRAY_FAN_OUT);\n\n\tnew_n1->parent_slot = slot;\n\n\t/* Metadata pointers cannot change slot */\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++)\n\t\tif (assoc_array_ptr_is_meta(node->slots[i]))\n\t\t\tnew_n0->slots[i] = node->slots[i];\n\t\telse\n\t\t\tnew_n0->slots[i] = NULL;\n\tBUG_ON(new_n0->slots[slot] != NULL);\n\tnew_n0->slots[slot] = assoc_array_node_to_ptr(new_n1);\n\n\t/* Filter the leaf pointers between the new nodes */\n\tfree_slot = -1;\n\tnext_slot = 0;\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tif (assoc_array_ptr_is_meta(node->slots[i]))\n\t\t\tcontinue;\n\t\tif (edit->segment_cache[i] == slot) {\n\t\t\tnew_n1->slots[next_slot++] = node->slots[i];\n\t\t\tnew_n1->nr_leaves_on_branch++;\n\t\t} else {\n\t\t\tdo {\n\t\t\t\tfree_slot++;\n\t\t\t} while (new_n0->slots[free_slot] != NULL);\n\t\t\tnew_n0->slots[free_slot] = node->slots[i];\n\t\t}\n\t}\n\n\tpr_devel(\"filtered: f=%x n=%x\\n\", free_slot, next_slot);\n\n\tif (edit->segment_cache[ASSOC_ARRAY_FAN_OUT] != slot) {\n\t\tdo {\n\t\t\tfree_slot++;\n\t\t} while (new_n0->slots[free_slot] != NULL);\n\t\tedit->leaf_p = &new_n0->slots[free_slot];\n\t\tedit->adjust_count_on = new_n0;\n\t} else {\n\t\tedit->leaf_p = &new_n1->slots[next_slot++];\n\t\tedit->adjust_count_on = new_n1;\n\t}\n\n\tBUG_ON(next_slot <= 1);\n\n\tedit->set_backpointers_to = assoc_array_node_to_ptr(new_n0);\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tif (edit->segment_cache[i] == 0xff) {\n\t\t\tptr = node->slots[i];\n\t\t\tBUG_ON(assoc_array_ptr_is_leaf(ptr));\n\t\t\tif (assoc_array_ptr_is_node(ptr)) {\n\t\t\t\tside = assoc_array_ptr_to_node(ptr);\n\t\t\t\tedit->set_backpointers[i] = &side->back_pointer;\n\t\t\t} else {\n\t\t\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\t\t\tedit->set_backpointers[i] = &shortcut->back_pointer;\n\t\t\t}\n\t\t}\n\t}\n\n\tptr = node->back_pointer;\n\tif (!ptr)\n\t\tedit->set[0].ptr = &edit->array->root;\n\telse if (assoc_array_ptr_is_node(ptr))\n\t\tedit->set[0].ptr = &assoc_array_ptr_to_node(ptr)->slots[node->parent_slot];\n\telse\n\t\tedit->set[0].ptr = &assoc_array_ptr_to_shortcut(ptr)->next_node;\n\tedit->excised_meta[0] = assoc_array_node_to_ptr(node);\n\tpr_devel(\"<--%s() = ok [split node]\\n\", __func__);\n\treturn true;\n\npresent_leaves_cluster_but_not_new_leaf:\n\t/* All the old leaves cluster in the same slot, but the new leaf wants\n\t * to go into a different slot, so we create a new node to hold the new\n\t * leaf and a pointer to a new node holding all the old leaves.\n\t */\n\tpr_devel(\"present leaves cluster but not new leaf\\n\");\n\n\tnew_n0->back_pointer = node->back_pointer;\n\tnew_n0->parent_slot = node->parent_slot;\n\tnew_n0->nr_leaves_on_branch = node->nr_leaves_on_branch;\n\tnew_n1->back_pointer = assoc_array_node_to_ptr(new_n0);\n\tnew_n1->parent_slot = edit->segment_cache[0];\n\tnew_n1->nr_leaves_on_branch = node->nr_leaves_on_branch;\n\tedit->adjust_count_on = new_n0;\n\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++)\n\t\tnew_n1->slots[i] = node->slots[i];\n\n\tnew_n0->slots[edit->segment_cache[0]] = assoc_array_node_to_ptr(new_n0);\n\tedit->leaf_p = &new_n0->slots[edit->segment_cache[ASSOC_ARRAY_FAN_OUT]];\n\n\tedit->set[0].ptr = &assoc_array_ptr_to_node(node->back_pointer)->slots[node->parent_slot];\n\tedit->set[0].to = assoc_array_node_to_ptr(new_n0);\n\tedit->excised_meta[0] = assoc_array_node_to_ptr(node);\n\tpr_devel(\"<--%s() = ok [insert node before]\\n\", __func__);\n\treturn true;\n\nall_leaves_cluster_together:\n\t/* All the leaves, new and old, want to cluster together in this node\n\t * in the same slot, so we have to replace this node with a shortcut to\n\t * skip over the identical parts of the key and then place a pair of\n\t * nodes, one inside the other, at the end of the shortcut and\n\t * distribute the keys between them.\n\t *\n\t * Firstly we need to work out where the leaves start diverging as a\n\t * bit position into their keys so that we know how big the shortcut\n\t * needs to be.\n\t *\n\t * We only need to make a single pass of N of the N+1 leaves because if\n\t * any keys differ between themselves at bit X then at least one of\n\t * them must also differ with the base key at bit X or before.\n\t */\n\tpr_devel(\"all leaves cluster together\\n\");\n\tdiff = INT_MAX;\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tint x = ops->diff_objects(assoc_array_ptr_to_leaf(node->slots[i]),\n\t\t\t\t\t  index_key);\n\t\tif (x < diff) {\n\t\t\tBUG_ON(x < 0);\n\t\t\tdiff = x;\n\t\t}\n\t}\n\tBUG_ON(diff == INT_MAX);\n\tBUG_ON(diff < level + ASSOC_ARRAY_LEVEL_STEP);\n\n\tkeylen = round_up(diff, ASSOC_ARRAY_KEY_CHUNK_SIZE);\n\tkeylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT;\n\n\tnew_s0 = kzalloc(sizeof(struct assoc_array_shortcut) +\n\t\t\t keylen * sizeof(unsigned long), GFP_KERNEL);\n\tif (!new_s0)\n\t\treturn false;\n\tedit->new_meta[2] = assoc_array_shortcut_to_ptr(new_s0);\n\n\tedit->set[0].to = assoc_array_shortcut_to_ptr(new_s0);\n\tnew_s0->back_pointer = node->back_pointer;\n\tnew_s0->parent_slot = node->parent_slot;\n\tnew_s0->next_node = assoc_array_node_to_ptr(new_n0);\n\tnew_n0->back_pointer = assoc_array_shortcut_to_ptr(new_s0);\n\tnew_n0->parent_slot = 0;\n\tnew_n1->back_pointer = assoc_array_node_to_ptr(new_n0);\n\tnew_n1->parent_slot = -1; /* Need to calculate this */\n\n\tnew_s0->skip_to_level = level = diff & ~ASSOC_ARRAY_LEVEL_STEP_MASK;\n\tpr_devel(\"skip_to_level = %d [diff %d]\\n\", level, diff);\n\tBUG_ON(level <= 0);\n\n\tfor (i = 0; i < keylen; i++)\n\t\tnew_s0->index_key[i] =\n\t\t\tops->get_key_chunk(index_key, i * ASSOC_ARRAY_KEY_CHUNK_SIZE);\n\n\tblank = ULONG_MAX << (level & ASSOC_ARRAY_KEY_CHUNK_MASK);\n\tpr_devel(\"blank off [%zu] %d: %lx\\n\", keylen - 1, level, blank);\n\tnew_s0->index_key[keylen - 1] &= ~blank;\n\n\t/* This now reduces to a node splitting exercise for which we'll need\n\t * to regenerate the disparity table.\n\t */\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tptr = node->slots[i];\n\t\tbase_seg = ops->get_object_key_chunk(assoc_array_ptr_to_leaf(ptr),\n\t\t\t\t\t\t     level);\n\t\tbase_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;\n\t\tedit->segment_cache[i] = base_seg & ASSOC_ARRAY_FAN_MASK;\n\t}\n\n\tbase_seg = ops->get_key_chunk(index_key, level);\n\tbase_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;\n\tedit->segment_cache[ASSOC_ARRAY_FAN_OUT] = base_seg & ASSOC_ARRAY_FAN_MASK;\n\tgoto do_split_node;\n}",
    "label": "True"
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 527,
    "line_new": 527,
    "critical_vars": [
      "index_key",
      "ptr"
    ],
    "function": "assoc_array_insert_into_terminal_node",
    "filename": "linux/CVE-2016-7914/CVE-2016-7914_CWE-476_8d4a2ec1e0b41b0cf9a0c5cd4511da7f8e4f3de2_assoc_array.c.diff",
    "function_code": "static bool assoc_array_insert_into_terminal_node(struct assoc_array_edit *edit,\n\t\t\t\t\t\t  const struct assoc_array_ops *ops,\n\t\t\t\t\t\t  const void *index_key,\n\t\t\t\t\t\t  struct assoc_array_walk_result *result)\n{\n\tstruct assoc_array_shortcut *shortcut, *new_s0;\n\tstruct assoc_array_node *node, *new_n0, *new_n1, *side;\n\tstruct assoc_array_ptr *ptr;\n\tunsigned long dissimilarity, base_seg, blank;\n\tsize_t keylen;\n\tbool have_meta;\n\tint level, diff;\n\tint slot, next_slot, free_slot, i, j;\n\n\tnode\t= result->terminal_node.node;\n\tlevel\t= result->terminal_node.level;\n\tedit->segment_cache[ASSOC_ARRAY_FAN_OUT] = result->terminal_node.slot;\n\n\tpr_devel(\"-->%s()\\n\", __func__);\n\n\t/* We arrived at a node which doesn't have an onward node or shortcut\n\t * pointer that we have to follow.  This means that (a) the leaf we\n\t * want must go here (either by insertion or replacement) or (b) we\n\t * need to split this node and insert in one of the fragments.\n\t */\n\tfree_slot = -1;\n\n\t/* Firstly, we have to check the leaves in this node to see if there's\n\t * a matching one we should replace in place.\n\t */\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tptr = node->slots[i];\n\t\tif (!ptr) {\n\t\t\tfree_slot = i;\n\t\t\tcontinue;\n\t\t}\n\t\tif (assoc_array_ptr_is_leaf(ptr) &&\n\t\t    ops->compare_object(assoc_array_ptr_to_leaf(ptr),\n\t\t\t\t\tindex_key)) {\n\t\t\tpr_devel(\"replace in slot %d\\n\", i);\n\t\t\tedit->leaf_p = &node->slots[i];\n\t\t\tedit->dead_leaf = node->slots[i];\n\t\t\tpr_devel(\"<--%s() = ok [replace]\\n\", __func__);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/* If there is a free slot in this node then we can just insert the\n\t * leaf here.\n\t */\n\tif (free_slot >= 0) {\n\t\tpr_devel(\"insert in free slot %d\\n\", free_slot);\n\t\tedit->leaf_p = &node->slots[free_slot];\n\t\tedit->adjust_count_on = node;\n\t\tpr_devel(\"<--%s() = ok [insert]\\n\", __func__);\n\t\treturn true;\n\t}\n\n\t/* The node has no spare slots - so we're either going to have to split\n\t * it or insert another node before it.\n\t *\n\t * Whatever, we're going to need at least two new nodes - so allocate\n\t * those now.  We may also need a new shortcut, but we deal with that\n\t * when we need it.\n\t */\n\tnew_n0 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);\n\tif (!new_n0)\n\t\treturn false;\n\tedit->new_meta[0] = assoc_array_node_to_ptr(new_n0);\n\tnew_n1 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);\n\tif (!new_n1)\n\t\treturn false;\n\tedit->new_meta[1] = assoc_array_node_to_ptr(new_n1);\n\n\t/* We need to find out how similar the leaves are. */\n\tpr_devel(\"no spare slots\\n\");\n\thave_meta = false;\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tptr = node->slots[i];\n\t\tif (assoc_array_ptr_is_meta(ptr)) {\n\t\t\tedit->segment_cache[i] = 0xff;\n\t\t\thave_meta = true;\n\t\t\tcontinue;\n\t\t}\n\t\tbase_seg = ops->get_object_key_chunk(\n\t\t\tassoc_array_ptr_to_leaf(ptr), level);\n\t\tbase_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;\n\t\tedit->segment_cache[i] = base_seg & ASSOC_ARRAY_FAN_MASK;\n\t}\n\n\tif (have_meta) {\n\t\tpr_devel(\"have meta\\n\");\n\t\tgoto split_node;\n\t}\n\n\t/* The node contains only leaves */\n\tdissimilarity = 0;\n\tbase_seg = edit->segment_cache[0];\n\tfor (i = 1; i < ASSOC_ARRAY_FAN_OUT; i++)\n\t\tdissimilarity |= edit->segment_cache[i] ^ base_seg;\n\n\tpr_devel(\"only leaves; dissimilarity=%lx\\n\", dissimilarity);\n\n\tif ((dissimilarity & ASSOC_ARRAY_FAN_MASK) == 0) {\n\t\t/* The old leaves all cluster in the same slot.  We will need\n\t\t * to insert a shortcut if the new node wants to cluster with them.\n\t\t */\n\t\tif ((edit->segment_cache[ASSOC_ARRAY_FAN_OUT] ^ base_seg) == 0)\n\t\t\tgoto all_leaves_cluster_together;\n\n\t\t/* Otherwise we can just insert a new node ahead of the old\n\t\t * one.\n\t\t */\n\t\tgoto present_leaves_cluster_but_not_new_leaf;\n\t}\n\nsplit_node:\n\tpr_devel(\"split node\\n\");\n\n\t/* We need to split the current node; we know that the node doesn't\n\t * simply contain a full set of leaves that cluster together (it\n\t * contains meta pointers and/or non-clustering leaves).\n\t *\n\t * We need to expel at least two leaves out of a set consisting of the\n\t * leaves in the node and the new leaf.\n\t *\n\t * We need a new node (n0) to replace the current one and a new node to\n\t * take the expelled nodes (n1).\n\t */\n\tedit->set[0].to = assoc_array_node_to_ptr(new_n0);\n\tnew_n0->back_pointer = node->back_pointer;\n\tnew_n0->parent_slot = node->parent_slot;\n\tnew_n1->back_pointer = assoc_array_node_to_ptr(new_n0);\n\tnew_n1->parent_slot = -1; /* Need to calculate this */\n\ndo_split_node:\n\tpr_devel(\"do_split_node\\n\");\n\n\tnew_n0->nr_leaves_on_branch = node->nr_leaves_on_branch;\n\tnew_n1->nr_leaves_on_branch = 0;\n\n\t/* Begin by finding two matching leaves.  There have to be at least two\n\t * that match - even if there are meta pointers - because any leaf that\n\t * would match a slot with a meta pointer in it must be somewhere\n\t * behind that meta pointer and cannot be here.  Further, given N\n\t * remaining leaf slots, we now have N+1 leaves to go in them.\n\t */\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tslot = edit->segment_cache[i];\n\t\tif (slot != 0xff)\n\t\t\tfor (j = i + 1; j < ASSOC_ARRAY_FAN_OUT + 1; j++)\n\t\t\t\tif (edit->segment_cache[j] == slot)\n\t\t\t\t\tgoto found_slot_for_multiple_occupancy;\n\t}\nfound_slot_for_multiple_occupancy:\n\tpr_devel(\"same slot: %x %x [%02x]\\n\", i, j, slot);\n\tBUG_ON(i >= ASSOC_ARRAY_FAN_OUT);\n\tBUG_ON(j >= ASSOC_ARRAY_FAN_OUT + 1);\n\tBUG_ON(slot >= ASSOC_ARRAY_FAN_OUT);\n\n\tnew_n1->parent_slot = slot;\n\n\t/* Metadata pointers cannot change slot */\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++)\n\t\tif (assoc_array_ptr_is_meta(node->slots[i]))\n\t\t\tnew_n0->slots[i] = node->slots[i];\n\t\telse\n\t\t\tnew_n0->slots[i] = NULL;\n\tBUG_ON(new_n0->slots[slot] != NULL);\n\tnew_n0->slots[slot] = assoc_array_node_to_ptr(new_n1);\n\n\t/* Filter the leaf pointers between the new nodes */\n\tfree_slot = -1;\n\tnext_slot = 0;\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tif (assoc_array_ptr_is_meta(node->slots[i]))\n\t\t\tcontinue;\n\t\tif (edit->segment_cache[i] == slot) {\n\t\t\tnew_n1->slots[next_slot++] = node->slots[i];\n\t\t\tnew_n1->nr_leaves_on_branch++;\n\t\t} else {\n\t\t\tdo {\n\t\t\t\tfree_slot++;\n\t\t\t} while (new_n0->slots[free_slot] != NULL);\n\t\t\tnew_n0->slots[free_slot] = node->slots[i];\n\t\t}\n\t}\n\n\tpr_devel(\"filtered: f=%x n=%x\\n\", free_slot, next_slot);\n\n\tif (edit->segment_cache[ASSOC_ARRAY_FAN_OUT] != slot) {\n\t\tdo {\n\t\t\tfree_slot++;\n\t\t} while (new_n0->slots[free_slot] != NULL);\n\t\tedit->leaf_p = &new_n0->slots[free_slot];\n\t\tedit->adjust_count_on = new_n0;\n\t} else {\n\t\tedit->leaf_p = &new_n1->slots[next_slot++];\n\t\tedit->adjust_count_on = new_n1;\n\t}\n\n\tBUG_ON(next_slot <= 1);\n\n\tedit->set_backpointers_to = assoc_array_node_to_ptr(new_n0);\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tif (edit->segment_cache[i] == 0xff) {\n\t\t\tptr = node->slots[i];\n\t\t\tBUG_ON(assoc_array_ptr_is_leaf(ptr));\n\t\t\tif (assoc_array_ptr_is_node(ptr)) {\n\t\t\t\tside = assoc_array_ptr_to_node(ptr);\n\t\t\t\tedit->set_backpointers[i] = &side->back_pointer;\n\t\t\t} else {\n\t\t\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\t\t\tedit->set_backpointers[i] = &shortcut->back_pointer;\n\t\t\t}\n\t\t}\n\t}\n\n\tptr = node->back_pointer;\n\tif (!ptr)\n\t\tedit->set[0].ptr = &edit->array->root;\n\telse if (assoc_array_ptr_is_node(ptr))\n\t\tedit->set[0].ptr = &assoc_array_ptr_to_node(ptr)->slots[node->parent_slot];\n\telse\n\t\tedit->set[0].ptr = &assoc_array_ptr_to_shortcut(ptr)->next_node;\n\tedit->excised_meta[0] = assoc_array_node_to_ptr(node);\n\tpr_devel(\"<--%s() = ok [split node]\\n\", __func__);\n\treturn true;\n\npresent_leaves_cluster_but_not_new_leaf:\n\t/* All the old leaves cluster in the same slot, but the new leaf wants\n\t * to go into a different slot, so we create a new node to hold the new\n\t * leaf and a pointer to a new node holding all the old leaves.\n\t */\n\tpr_devel(\"present leaves cluster but not new leaf\\n\");\n\n\tnew_n0->back_pointer = node->back_pointer;\n\tnew_n0->parent_slot = node->parent_slot;\n\tnew_n0->nr_leaves_on_branch = node->nr_leaves_on_branch;\n\tnew_n1->back_pointer = assoc_array_node_to_ptr(new_n0);\n\tnew_n1->parent_slot = edit->segment_cache[0];\n\tnew_n1->nr_leaves_on_branch = node->nr_leaves_on_branch;\n\tedit->adjust_count_on = new_n0;\n\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++)\n\t\tnew_n1->slots[i] = node->slots[i];\n\n\tnew_n0->slots[edit->segment_cache[0]] = assoc_array_node_to_ptr(new_n0);\n\tedit->leaf_p = &new_n0->slots[edit->segment_cache[ASSOC_ARRAY_FAN_OUT]];\n\n\tedit->set[0].ptr = &assoc_array_ptr_to_node(node->back_pointer)->slots[node->parent_slot];\n\tedit->set[0].to = assoc_array_node_to_ptr(new_n0);\n\tedit->excised_meta[0] = assoc_array_node_to_ptr(node);\n\tpr_devel(\"<--%s() = ok [insert node before]\\n\", __func__);\n\treturn true;\n\nall_leaves_cluster_together:\n\t/* All the leaves, new and old, want to cluster together in this node\n\t * in the same slot, so we have to replace this node with a shortcut to\n\t * skip over the identical parts of the key and then place a pair of\n\t * nodes, one inside the other, at the end of the shortcut and\n\t * distribute the keys between them.\n\t *\n\t * Firstly we need to work out where the leaves start diverging as a\n\t * bit position into their keys so that we know how big the shortcut\n\t * needs to be.\n\t *\n\t * We only need to make a single pass of N of the N+1 leaves because if\n\t * any keys differ between themselves at bit X then at least one of\n\t * them must also differ with the base key at bit X or before.\n\t */\n\tpr_devel(\"all leaves cluster together\\n\");\n\tdiff = INT_MAX;\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tint x = ops->diff_objects(assoc_array_ptr_to_leaf(node->slots[i]),\n\t\t\t\t\t  index_key);\n\t\tif (x < diff) {\n\t\t\tBUG_ON(x < 0);\n\t\t\tdiff = x;\n\t\t}\n\t}\n\tBUG_ON(diff == INT_MAX);\n\tBUG_ON(diff < level + ASSOC_ARRAY_LEVEL_STEP);\n\n\tkeylen = round_up(diff, ASSOC_ARRAY_KEY_CHUNK_SIZE);\n\tkeylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT;\n\n\tnew_s0 = kzalloc(sizeof(struct assoc_array_shortcut) +\n\t\t\t keylen * sizeof(unsigned long), GFP_KERNEL);\n\tif (!new_s0)\n\t\treturn false;\n\tedit->new_meta[2] = assoc_array_shortcut_to_ptr(new_s0);\n\n\tedit->set[0].to = assoc_array_shortcut_to_ptr(new_s0);\n\tnew_s0->back_pointer = node->back_pointer;\n\tnew_s0->parent_slot = node->parent_slot;\n\tnew_s0->next_node = assoc_array_node_to_ptr(new_n0);\n\tnew_n0->back_pointer = assoc_array_shortcut_to_ptr(new_s0);\n\tnew_n0->parent_slot = 0;\n\tnew_n1->back_pointer = assoc_array_node_to_ptr(new_n0);\n\tnew_n1->parent_slot = -1; /* Need to calculate this */\n\n\tnew_s0->skip_to_level = level = diff & ~ASSOC_ARRAY_LEVEL_STEP_MASK;\n\tpr_devel(\"skip_to_level = %d [diff %d]\\n\", level, diff);\n\tBUG_ON(level <= 0);\n\n\tfor (i = 0; i < keylen; i++)\n\t\tnew_s0->index_key[i] =\n\t\t\tops->get_key_chunk(index_key, i * ASSOC_ARRAY_KEY_CHUNK_SIZE);\n\n\tblank = ULONG_MAX << (level & ASSOC_ARRAY_KEY_CHUNK_MASK);\n\tpr_devel(\"blank off [%zu] %d: %lx\\n\", keylen - 1, level, blank);\n\tnew_s0->index_key[keylen - 1] &= ~blank;\n\n\t/* This now reduces to a node splitting exercise for which we'll need\n\t * to regenerate the disparity table.\n\t */\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tptr = node->slots[i];\n\t\tbase_seg = ops->get_object_key_chunk(assoc_array_ptr_to_leaf(ptr),\n\t\t\t\t\t\t     level);\n\t\tbase_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;\n\t\tedit->segment_cache[i] = base_seg & ASSOC_ARRAY_FAN_MASK;\n\t}\n\n\tbase_seg = ops->get_key_chunk(index_key, level);\n\tbase_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;\n\tedit->segment_cache[ASSOC_ARRAY_FAN_OUT] = base_seg & ASSOC_ARRAY_FAN_MASK;\n\tgoto do_split_node;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 58,
    "critical_vars": [
      "indev"
    ],
    "function": "nf_nat_redirect_ipv4",
    "filename": "linux/CVE-2015-8787/CVE-2015-8787_CWE-476_94f9cd81436c85d8c3a318ba92e236ede73752fc_nf_nat_redirect.c.diff",
    "function_code": "nf_nat_redirect_ipv4(struct sk_buff *skb,\n\t\t     const struct nf_nat_ipv4_multi_range_compat *mr,\n\t\t     unsigned int hooknum)\n{\n\tstruct nf_conn *ct;\n\tenum ip_conntrack_info ctinfo;\n\t__be32 newdst;\n\tstruct nf_nat_range newrange;\n\n\tNF_CT_ASSERT(hooknum == NF_INET_PRE_ROUTING ||\n\t\t     hooknum == NF_INET_LOCAL_OUT);\n\n\tct = nf_ct_get(skb, &ctinfo);\n\tNF_CT_ASSERT(ct && (ctinfo == IP_CT_NEW || ctinfo == IP_CT_RELATED));\n\n\t/* Local packets: make them go to loopback */\n\tif (hooknum == NF_INET_LOCAL_OUT) {\n\t\tnewdst = htonl(0x7F000001);\n\t} else {\n\t\tstruct in_device *indev;\n\t\tstruct in_ifaddr *ifa;\n\n\t\tnewdst = 0;\n\n\t\trcu_read_lock();\n\t\tindev = __in_dev_get_rcu(skb->dev);\n\t\tif (indev != NULL) {\n\t\t\tifa = indev->ifa_list;\n\t\t\tnewdst = ifa->ifa_local;\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tif (!newdst)\n\t\t\treturn NF_DROP;\n\t}\n\n\t/* Transfer from original range. */\n\tmemset(&newrange.min_addr, 0, sizeof(newrange.min_addr));\n\tmemset(&newrange.max_addr, 0, sizeof(newrange.max_addr));\n\tnewrange.flags\t     = mr->range[0].flags | NF_NAT_RANGE_MAP_IPS;\n\tnewrange.min_addr.ip = newdst;\n\tnewrange.max_addr.ip = newdst;\n\tnewrange.min_proto   = mr->range[0].min;\n\tnewrange.max_proto   = mr->range[0].max;\n\n\t/* Hand modified range to generic setup. */\n\treturn nf_nat_setup_info(ct, &newrange, NF_NAT_MANIP_DST);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 58,
    "critical_vars": [
      "indev",
      "indev->ifa_list"
    ],
    "function": "nf_nat_redirect_ipv4",
    "filename": "linux/CVE-2015-8787/CVE-2015-8787_CWE-476_94f9cd81436c85d8c3a318ba92e236ede73752fc_nf_nat_redirect.c.diff",
    "function_code": "nf_nat_redirect_ipv4(struct sk_buff *skb,\n\t\t     const struct nf_nat_ipv4_multi_range_compat *mr,\n\t\t     unsigned int hooknum)\n{\n\tstruct nf_conn *ct;\n\tenum ip_conntrack_info ctinfo;\n\t__be32 newdst;\n\tstruct nf_nat_range newrange;\n\n\tNF_CT_ASSERT(hooknum == NF_INET_PRE_ROUTING ||\n\t\t     hooknum == NF_INET_LOCAL_OUT);\n\n\tct = nf_ct_get(skb, &ctinfo);\n\tNF_CT_ASSERT(ct && (ctinfo == IP_CT_NEW || ctinfo == IP_CT_RELATED));\n\n\t/* Local packets: make them go to loopback */\n\tif (hooknum == NF_INET_LOCAL_OUT) {\n\t\tnewdst = htonl(0x7F000001);\n\t} else {\n\t\tstruct in_device *indev;\n\t\tstruct in_ifaddr *ifa;\n\n\t\tnewdst = 0;\n\n\t\trcu_read_lock();\n\t\tindev = __in_dev_get_rcu(skb->dev);\n\t\tif (indev && indev->ifa_list) {\n\t\t\tifa = indev->ifa_list;\n\t\t\tnewdst = ifa->ifa_local;\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tif (!newdst)\n\t\t\treturn NF_DROP;\n\t}\n\n\t/* Transfer from original range. */\n\tmemset(&newrange.min_addr, 0, sizeof(newrange.min_addr));\n\tmemset(&newrange.max_addr, 0, sizeof(newrange.max_addr));\n\tnewrange.flags\t     = mr->range[0].flags | NF_NAT_RANGE_MAP_IPS;\n\tnewrange.min_addr.ip = newdst;\n\tnewrange.max_addr.ip = newdst;\n\tnewrange.min_proto   = mr->range[0].min;\n\tnewrange.max_proto   = mr->range[0].max;\n\n\t/* Hand modified range to generic setup. */\n\treturn nf_nat_setup_info(ct, &newrange, NF_NAT_MANIP_DST);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 146,
    "critical_vars": [
      "sq"
    ],
    "function": "io_uring_show_fdinfo",
    "filename": "linux/CVE-2023-46862/CVE-2023-46862_CWE-476_7644b1a1c9a7ae8ab99175989bfc8676055edb46_fdinfo.c.diff",
    "function_code": "__cold void io_uring_show_fdinfo(struct seq_file *m, struct file *f)\n{\n\tstruct io_ring_ctx *ctx = f->private_data;\n\tstruct io_sq_data *sq = NULL;\n\tstruct io_overflow_cqe *ocqe;\n\tstruct io_rings *r = ctx->rings;\n\tunsigned int sq_mask = ctx->sq_entries - 1, cq_mask = ctx->cq_entries - 1;\n\tunsigned int sq_head = READ_ONCE(r->sq.head);\n\tunsigned int sq_tail = READ_ONCE(r->sq.tail);\n\tunsigned int cq_head = READ_ONCE(r->cq.head);\n\tunsigned int cq_tail = READ_ONCE(r->cq.tail);\n\tunsigned int cq_shift = 0;\n\tunsigned int sq_shift = 0;\n\tunsigned int sq_entries, cq_entries;\n\tbool has_lock;\n\tunsigned int i;\n\n\tif (ctx->flags & IORING_SETUP_CQE32)\n\t\tcq_shift = 1;\n\tif (ctx->flags & IORING_SETUP_SQE128)\n\t\tsq_shift = 1;\n\n\t/*\n\t * we may get imprecise sqe and cqe info if uring is actively running\n\t * since we get cached_sq_head and cached_cq_tail without uring_lock\n\t * and sq_tail and cq_head are changed by userspace. But it's ok since\n\t * we usually use these info when it is stuck.\n\t */\n\tseq_printf(m, \"SqMask:\\t0x%x\\n\", sq_mask);\n\tseq_printf(m, \"SqHead:\\t%u\\n\", sq_head);\n\tseq_printf(m, \"SqTail:\\t%u\\n\", sq_tail);\n\tseq_printf(m, \"CachedSqHead:\\t%u\\n\", ctx->cached_sq_head);\n\tseq_printf(m, \"CqMask:\\t0x%x\\n\", cq_mask);\n\tseq_printf(m, \"CqHead:\\t%u\\n\", cq_head);\n\tseq_printf(m, \"CqTail:\\t%u\\n\", cq_tail);\n\tseq_printf(m, \"CachedCqTail:\\t%u\\n\", ctx->cached_cq_tail);\n\tseq_printf(m, \"SQEs:\\t%u\\n\", sq_tail - sq_head);\n\tsq_entries = min(sq_tail - sq_head, ctx->sq_entries);\n\tfor (i = 0; i < sq_entries; i++) {\n\t\tunsigned int entry = i + sq_head;\n\t\tstruct io_uring_sqe *sqe;\n\t\tunsigned int sq_idx;\n\n\t\tif (ctx->flags & IORING_SETUP_NO_SQARRAY)\n\t\t\tbreak;\n\t\tsq_idx = READ_ONCE(ctx->sq_array[entry & sq_mask]);\n\t\tif (sq_idx > sq_mask)\n\t\t\tcontinue;\n\t\tsqe = &ctx->sq_sqes[sq_idx << sq_shift];\n\t\tseq_printf(m, \"%5u: opcode:%s, fd:%d, flags:%x, off:%llu, \"\n\t\t\t      \"addr:0x%llx, rw_flags:0x%x, buf_index:%d \"\n\t\t\t      \"user_data:%llu\",\n\t\t\t   sq_idx, io_uring_get_opcode(sqe->opcode), sqe->fd,\n\t\t\t   sqe->flags, (unsigned long long) sqe->off,\n\t\t\t   (unsigned long long) sqe->addr, sqe->rw_flags,\n\t\t\t   sqe->buf_index, sqe->user_data);\n\t\tif (sq_shift) {\n\t\t\tu64 *sqeb = (void *) (sqe + 1);\n\t\t\tint size = sizeof(struct io_uring_sqe) / sizeof(u64);\n\t\t\tint j;\n\n\t\t\tfor (j = 0; j < size; j++) {\n\t\t\t\tseq_printf(m, \", e%d:0x%llx\", j,\n\t\t\t\t\t\t(unsigned long long) *sqeb);\n\t\t\t\tsqeb++;\n\t\t\t}\n\t\t}\n\t\tseq_printf(m, \"\\n\");\n\t}\n\tseq_printf(m, \"CQEs:\\t%u\\n\", cq_tail - cq_head);\n\tcq_entries = min(cq_tail - cq_head, ctx->cq_entries);\n\tfor (i = 0; i < cq_entries; i++) {\n\t\tunsigned int entry = i + cq_head;\n\t\tstruct io_uring_cqe *cqe = &r->cqes[(entry & cq_mask) << cq_shift];\n\n\t\tseq_printf(m, \"%5u: user_data:%llu, res:%d, flag:%x\",\n\t\t\t   entry & cq_mask, cqe->user_data, cqe->res,\n\t\t\t   cqe->flags);\n\t\tif (cq_shift)\n\t\t\tseq_printf(m, \", extra1:%llu, extra2:%llu\\n\",\n\t\t\t\t\tcqe->big_cqe[0], cqe->big_cqe[1]);\n\t\tseq_printf(m, \"\\n\");\n\t}\n\n\t/*\n\t * Avoid ABBA deadlock between the seq lock and the io_uring mutex,\n\t * since fdinfo case grabs it in the opposite direction of normal use\n\t * cases. If we fail to get the lock, we just don't iterate any\n\t * structures that could be going away outside the io_uring mutex.\n\t */\n\thas_lock = mutex_trylock(&ctx->uring_lock);\n\n\tif (has_lock && (ctx->flags & IORING_SETUP_SQPOLL)) {\n\t\tsq = ctx->sq_data;\n\t\tif (!sq->thread)\n\t\t\tsq = NULL;\n\t}\n\n\tseq_printf(m, \"SqThread:\\t%d\\n\", sq ? task_pid_nr(sq->thread) : -1);\n\tseq_printf(m, \"SqThreadCpu:\\t%d\\n\", sq ? task_cpu(sq->thread) : -1);\n\tseq_printf(m, \"UserFiles:\\t%u\\n\", ctx->nr_user_files);\n\tfor (i = 0; has_lock && i < ctx->nr_user_files; i++) {\n\t\tstruct file *f = io_file_from_index(&ctx->file_table, i);\n\n\t\tif (f)\n\t\t\tseq_printf(m, \"%5u: %s\\n\", i, file_dentry(f)->d_iname);\n\t\telse\n\t\t\tseq_printf(m, \"%5u: <none>\\n\", i);\n\t}\n\tseq_printf(m, \"UserBufs:\\t%u\\n\", ctx->nr_user_bufs);\n\tfor (i = 0; has_lock && i < ctx->nr_user_bufs; i++) {\n\t\tstruct io_mapped_ubuf *buf = ctx->user_bufs[i];\n\t\tunsigned int len = buf->ubuf_end - buf->ubuf;\n\n\t\tseq_printf(m, \"%5u: 0x%llx/%u\\n\", i, buf->ubuf, len);\n\t}\n\tif (has_lock && !xa_empty(&ctx->personalities)) {\n\t\tunsigned long index;\n\t\tconst struct cred *cred;\n\n\t\tseq_printf(m, \"Personalities:\\n\");\n\t\txa_for_each(&ctx->personalities, index, cred)\n\t\t\tio_uring_show_cred(m, index, cred);\n\t}\n\n\tseq_puts(m, \"PollList:\\n\");\n\tfor (i = 0; i < (1U << ctx->cancel_table.hash_bits); i++) {\n\t\tstruct io_hash_bucket *hb = &ctx->cancel_table.hbs[i];\n\t\tstruct io_hash_bucket *hbl = &ctx->cancel_table_locked.hbs[i];\n\t\tstruct io_kiocb *req;\n\n\t\tspin_lock(&hb->lock);\n\t\thlist_for_each_entry(req, &hb->list, hash_node)\n\t\t\tseq_printf(m, \"  op=%d, task_works=%d\\n\", req->opcode,\n\t\t\t\t\ttask_work_pending(req->task));\n\t\tspin_unlock(&hb->lock);\n\n\t\tif (!has_lock)\n\t\t\tcontinue;\n\t\thlist_for_each_entry(req, &hbl->list, hash_node)\n\t\t\tseq_printf(m, \"  op=%d, task_works=%d\\n\", req->opcode,\n\t\t\t\t\ttask_work_pending(req->task));\n\t}\n\n\tif (has_lock)\n\t\tmutex_unlock(&ctx->uring_lock);\n\n\tseq_puts(m, \"CqOverflowList:\\n\");\n\tspin_lock(&ctx->completion_lock);\n\tlist_for_each_entry(ocqe, &ctx->cq_overflow_list, list) {\n\t\tstruct io_uring_cqe *cqe = &ocqe->cqe;\n\n\t\tseq_printf(m, \"  user_data=%llu, res=%d, flags=%x\\n\",\n\t\t\t   cqe->user_data, cqe->res, cqe->flags);\n\n\t}\n\n\tspin_unlock(&ctx->completion_lock);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 66,
    "critical_vars": [
      "sq_pid"
    ],
    "function": "io_uring_show_fdinfo",
    "filename": "linux/CVE-2023-46862/CVE-2023-46862_CWE-476_7644b1a1c9a7ae8ab99175989bfc8676055edb46_fdinfo.c.diff",
    "function_code": "__cold void io_uring_show_fdinfo(struct seq_file *m, struct file *f)\n{\n\tstruct io_ring_ctx *ctx = f->private_data;\n\tstruct io_overflow_cqe *ocqe;\n\tstruct io_rings *r = ctx->rings;\n\tunsigned int sq_mask = ctx->sq_entries - 1, cq_mask = ctx->cq_entries - 1;\n\tunsigned int sq_head = READ_ONCE(r->sq.head);\n\tunsigned int sq_tail = READ_ONCE(r->sq.tail);\n\tunsigned int cq_head = READ_ONCE(r->cq.head);\n\tunsigned int cq_tail = READ_ONCE(r->cq.tail);\n\tunsigned int cq_shift = 0;\n\tunsigned int sq_shift = 0;\n\tunsigned int sq_entries, cq_entries;\n\tint sq_pid = -1, sq_cpu = -1;\n\tbool has_lock;\n\tunsigned int i;\n\n\tif (ctx->flags & IORING_SETUP_CQE32)\n\t\tcq_shift = 1;\n\tif (ctx->flags & IORING_SETUP_SQE128)\n\t\tsq_shift = 1;\n\n\t/*\n\t * we may get imprecise sqe and cqe info if uring is actively running\n\t * since we get cached_sq_head and cached_cq_tail without uring_lock\n\t * and sq_tail and cq_head are changed by userspace. But it's ok since\n\t * we usually use these info when it is stuck.\n\t */\n\tseq_printf(m, \"SqMask:\\t0x%x\\n\", sq_mask);\n\tseq_printf(m, \"SqHead:\\t%u\\n\", sq_head);\n\tseq_printf(m, \"SqTail:\\t%u\\n\", sq_tail);\n\tseq_printf(m, \"CachedSqHead:\\t%u\\n\", ctx->cached_sq_head);\n\tseq_printf(m, \"CqMask:\\t0x%x\\n\", cq_mask);\n\tseq_printf(m, \"CqHead:\\t%u\\n\", cq_head);\n\tseq_printf(m, \"CqTail:\\t%u\\n\", cq_tail);\n\tseq_printf(m, \"CachedCqTail:\\t%u\\n\", ctx->cached_cq_tail);\n\tseq_printf(m, \"SQEs:\\t%u\\n\", sq_tail - sq_head);\n\tsq_entries = min(sq_tail - sq_head, ctx->sq_entries);\n\tfor (i = 0; i < sq_entries; i++) {\n\t\tunsigned int entry = i + sq_head;\n\t\tstruct io_uring_sqe *sqe;\n\t\tunsigned int sq_idx;\n\n\t\tif (ctx->flags & IORING_SETUP_NO_SQARRAY)\n\t\t\tbreak;\n\t\tsq_idx = READ_ONCE(ctx->sq_array[entry & sq_mask]);\n\t\tif (sq_idx > sq_mask)\n\t\t\tcontinue;\n\t\tsqe = &ctx->sq_sqes[sq_idx << sq_shift];\n\t\tseq_printf(m, \"%5u: opcode:%s, fd:%d, flags:%x, off:%llu, \"\n\t\t\t      \"addr:0x%llx, rw_flags:0x%x, buf_index:%d \"\n\t\t\t      \"user_data:%llu\",\n\t\t\t   sq_idx, io_uring_get_opcode(sqe->opcode), sqe->fd,\n\t\t\t   sqe->flags, (unsigned long long) sqe->off,\n\t\t\t   (unsigned long long) sqe->addr, sqe->rw_flags,\n\t\t\t   sqe->buf_index, sqe->user_data);\n\t\tif (sq_shift) {\n\t\t\tu64 *sqeb = (void *) (sqe + 1);\n\t\t\tint size = sizeof(struct io_uring_sqe) / sizeof(u64);\n\t\t\tint j;\n\n\t\t\tfor (j = 0; j < size; j++) {\n\t\t\t\tseq_printf(m, \", e%d:0x%llx\", j,\n\t\t\t\t\t\t(unsigned long long) *sqeb);\n\t\t\t\tsqeb++;\n\t\t\t}\n\t\t}\n\t\tseq_printf(m, \"\\n\");\n\t}\n\tseq_printf(m, \"CQEs:\\t%u\\n\", cq_tail - cq_head);\n\tcq_entries = min(cq_tail - cq_head, ctx->cq_entries);\n\tfor (i = 0; i < cq_entries; i++) {\n\t\tunsigned int entry = i + cq_head;\n\t\tstruct io_uring_cqe *cqe = &r->cqes[(entry & cq_mask) << cq_shift];\n\n\t\tseq_printf(m, \"%5u: user_data:%llu, res:%d, flag:%x\",\n\t\t\t   entry & cq_mask, cqe->user_data, cqe->res,\n\t\t\t   cqe->flags);\n\t\tif (cq_shift)\n\t\t\tseq_printf(m, \", extra1:%llu, extra2:%llu\\n\",\n\t\t\t\t\tcqe->big_cqe[0], cqe->big_cqe[1]);\n\t\tseq_printf(m, \"\\n\");\n\t}\n\n\t/*\n\t * Avoid ABBA deadlock between the seq lock and the io_uring mutex,\n\t * since fdinfo case grabs it in the opposite direction of normal use\n\t * cases. If we fail to get the lock, we just don't iterate any\n\t * structures that could be going away outside the io_uring mutex.\n\t */\n\thas_lock = mutex_trylock(&ctx->uring_lock);\n\n\tif (has_lock && (ctx->flags & IORING_SETUP_SQPOLL)) {\n\t\tstruct io_sq_data *sq = ctx->sq_data;\n\n\t\tif (mutex_trylock(&sq->lock)) {\n\t\t\tif (sq->thread) {\n\t\t\t\tsq_pid = task_pid_nr(sq->thread);\n\t\t\t\tsq_cpu = task_cpu(sq->thread);\n\t\t\t}\n\t\t\tmutex_unlock(&sq->lock);\n\t\t}\n\t}\n\n\tseq_printf(m, \"SqThread:\\t%d\\n\", sq_pid);\n\tseq_printf(m, \"SqThreadCpu:\\t%d\\n\", sq_cpu);\n\tseq_printf(m, \"UserFiles:\\t%u\\n\", ctx->nr_user_files);\n\tfor (i = 0; has_lock && i < ctx->nr_user_files; i++) {\n\t\tstruct file *f = io_file_from_index(&ctx->file_table, i);\n\n\t\tif (f)\n\t\t\tseq_printf(m, \"%5u: %s\\n\", i, file_dentry(f)->d_iname);\n\t\telse\n\t\t\tseq_printf(m, \"%5u: <none>\\n\", i);\n\t}\n\tseq_printf(m, \"UserBufs:\\t%u\\n\", ctx->nr_user_bufs);\n\tfor (i = 0; has_lock && i < ctx->nr_user_bufs; i++) {\n\t\tstruct io_mapped_ubuf *buf = ctx->user_bufs[i];\n\t\tunsigned int len = buf->ubuf_end - buf->ubuf;\n\n\t\tseq_printf(m, \"%5u: 0x%llx/%u\\n\", i, buf->ubuf, len);\n\t}\n\tif (has_lock && !xa_empty(&ctx->personalities)) {\n\t\tunsigned long index;\n\t\tconst struct cred *cred;\n\n\t\tseq_printf(m, \"Personalities:\\n\");\n\t\txa_for_each(&ctx->personalities, index, cred)\n\t\t\tio_uring_show_cred(m, index, cred);\n\t}\n\n\tseq_puts(m, \"PollList:\\n\");\n\tfor (i = 0; i < (1U << ctx->cancel_table.hash_bits); i++) {\n\t\tstruct io_hash_bucket *hb = &ctx->cancel_table.hbs[i];\n\t\tstruct io_hash_bucket *hbl = &ctx->cancel_table_locked.hbs[i];\n\t\tstruct io_kiocb *req;\n\n\t\tspin_lock(&hb->lock);\n\t\thlist_for_each_entry(req, &hb->list, hash_node)\n\t\t\tseq_printf(m, \"  op=%d, task_works=%d\\n\", req->opcode,\n\t\t\t\t\ttask_work_pending(req->task));\n\t\tspin_unlock(&hb->lock);\n\n\t\tif (!has_lock)\n\t\t\tcontinue;\n\t\thlist_for_each_entry(req, &hbl->list, hash_node)\n\t\t\tseq_printf(m, \"  op=%d, task_works=%d\\n\", req->opcode,\n\t\t\t\t\ttask_work_pending(req->task));\n\t}\n\n\tif (has_lock)\n\t\tmutex_unlock(&ctx->uring_lock);\n\n\tseq_puts(m, \"CqOverflowList:\\n\");\n\tspin_lock(&ctx->completion_lock);\n\tlist_for_each_entry(ocqe, &ctx->cq_overflow_list, list) {\n\t\tstruct io_uring_cqe *cqe = &ocqe->cqe;\n\n\t\tseq_printf(m, \"  user_data=%llu, res=%d, flags=%x\\n\",\n\t\t\t   cqe->user_data, cqe->res, cqe->flags);\n\n\t}\n\n\tspin_unlock(&ctx->completion_lock);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 388,
    "critical_vars": [
      "mp"
    ],
    "function": "dbFree",
    "filename": "linux/CVE-2023-4385/CVE-2023-4385_CWE-476_0d4837fdb796f99369cf7691d33de1b856bcaf1f_jfs_dmap.c.diff",
    "function_code": "int dbFree(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct super_block *sb = ipbmap->i_sb;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* block to be freed better be within the mapsize. */\n\tif (unlikely((blkno == 0) || (blkno + nblocks > bmp->db_mapsize))) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ip->i_sb, \"block to be freed is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/**\n\t * TRIM the blocks, when mounted with discard option\n\t */\n\tif (JFS_SBI(sb)->flag & JFS_DISCARD)\n\t\tif (JFS_SBI(sb)->minblks_trim <= nblocks)\n\t\t\tjfs_issue_discard(ipbmap, blkno, nblocks);\n\n\t/*\n\t * free the blocks a dmap at a time.\n\t */\n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\t/* release previous dmap if any */\n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the number of blocks to be freed from\n\t\t * this dmap.\n\t\t */\n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\n\t\t/* free the blocks. */\n\t\tif ((rc = dbFreeDmap(bmp, dp, blkno, nb))) {\n\t\t\tjfs_error(ip->i_sb, \"error in block map\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\t/* write the last buffer. */\n\twrite_metapage(mp);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (0);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 388,
    "critical_vars": [
      "mp"
    ],
    "function": "dbFree",
    "filename": "linux/CVE-2023-4385/CVE-2023-4385_CWE-476_0d4837fdb796f99369cf7691d33de1b856bcaf1f_jfs_dmap.c.diff",
    "function_code": "int dbFree(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct super_block *sb = ipbmap->i_sb;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* block to be freed better be within the mapsize. */\n\tif (unlikely((blkno == 0) || (blkno + nblocks > bmp->db_mapsize))) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ip->i_sb, \"block to be freed is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/**\n\t * TRIM the blocks, when mounted with discard option\n\t */\n\tif (JFS_SBI(sb)->flag & JFS_DISCARD)\n\t\tif (JFS_SBI(sb)->minblks_trim <= nblocks)\n\t\t\tjfs_issue_discard(ipbmap, blkno, nblocks);\n\n\t/*\n\t * free the blocks a dmap at a time.\n\t */\n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\t/* release previous dmap if any */\n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the number of blocks to be freed from\n\t\t * this dmap.\n\t\t */\n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\n\t\t/* free the blocks. */\n\t\tif ((rc = dbFreeDmap(bmp, dp, blkno, nb))) {\n\t\t\tjfs_error(ip->i_sb, \"error in block map\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\t/* write the last buffer. */\n\tif (mp)\n\t\twrite_metapage(mp);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (0);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 1398,
    "critical_vars": [
      "v4l2_buf"
    ],
    "function": "tw5864_handle_frame",
    "filename": "linux/CVE-2019-20806/CVE-2019-20806_CWE-476_2e7682ebfc750177a4944eeb56e97a3f05734528_tw5864-video.c.diff",
    "function_code": "static void tw5864_handle_frame(struct tw5864_h264_frame *frame)\n{\n#define SKIP_VLCBUF_BYTES 3\n\tstruct tw5864_input *input = frame->input;\n\tstruct tw5864_dev *dev = input->root;\n\tstruct tw5864_buf *vb;\n\tstruct vb2_v4l2_buffer *v4l2_buf;\n\tint frame_len = frame->vlc_len - SKIP_VLCBUF_BYTES;\n\tu8 *dst = input->buf_cur_ptr;\n\tu8 tail_mask, vlc_mask = 0;\n\tint i;\n\tu8 vlc_first_byte = ((u8 *)(frame->vlc.addr + SKIP_VLCBUF_BYTES))[0];\n\tunsigned long flags;\n\tint zero_run;\n\tu8 *src;\n\tu8 *src_end;\n\n#ifdef DEBUG\n\tif (frame->checksum !=\n\t    tw5864_vlc_checksum((u32 *)frame->vlc.addr, frame_len))\n\t\tdev_err(&dev->pci->dev,\n\t\t\t\"Checksum of encoded frame doesn't match!\\n\");\n#endif\n\n\tspin_lock_irqsave(&input->slock, flags);\n\tvb = input->vb;\n\tinput->vb = NULL;\n\tspin_unlock_irqrestore(&input->slock, flags);\n\n\tv4l2_buf = to_vb2_v4l2_buffer(&vb->vb.vb2_buf);\n\n\tif (!vb) { /* Gone because of disabling */\n\t\tdev_dbg(&dev->pci->dev, \"vb is empty, dropping frame\\n\");\n\t\treturn;\n\t}\n\n\t/*\n\t * Check for space.\n\t * Mind the overhead of startcode emulation prevention.\n\t */\n\tif (input->buf_cur_space_left < frame_len * 5 / 4) {\n\t\tdev_err_once(&dev->pci->dev,\n\t\t\t     \"Left space in vb2 buffer, %d bytes, is less than considered safely enough to put frame of length %d. Dropping this frame.\\n\",\n\t\t\t     input->buf_cur_space_left, frame_len);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 8 - input->tail_nb_bits; i++)\n\t\tvlc_mask |= 1 << i;\n\ttail_mask = (~vlc_mask) & 0xff;\n\n\tdst[0] = (input->tail & tail_mask) | (vlc_first_byte & vlc_mask);\n\tframe_len--;\n\tdst++;\n\n\t/* H.264 startcode emulation prevention */\n\tsrc = frame->vlc.addr + SKIP_VLCBUF_BYTES + 1;\n\tsrc_end = src + frame_len;\n\tzero_run = 0;\n\tfor (; src < src_end; src++) {\n\t\tif (zero_run < 2) {\n\t\t\tif (*src == 0)\n\t\t\t\t++zero_run;\n\t\t\telse\n\t\t\t\tzero_run = 0;\n\t\t} else {\n\t\t\tif ((*src & ~0x03) == 0)\n\t\t\t\t*dst++ = 0x03;\n\t\t\tzero_run = *src == 0;\n\t\t}\n\t\t*dst++ = *src;\n\t}\n\n\tvb2_set_plane_payload(&vb->vb.vb2_buf, 0,\n\t\t\t      dst - (u8 *)vb2_plane_vaddr(&vb->vb.vb2_buf, 0));\n\n\tvb->vb.vb2_buf.timestamp = frame->timestamp;\n\tv4l2_buf->field = V4L2_FIELD_INTERLACED;\n\tv4l2_buf->sequence = frame->seqno;\n\n\t/* Check for motion flags */\n\tif (frame->gop_seqno /* P-frame */ &&\n\t    tw5864_is_motion_triggered(frame)) {\n\t\tstruct v4l2_event ev = {\n\t\t\t.type = V4L2_EVENT_MOTION_DET,\n\t\t\t.u.motion_det = {\n\t\t\t\t.flags = V4L2_EVENT_MD_FL_HAVE_FRAME_SEQ,\n\t\t\t\t.frame_sequence = v4l2_buf->sequence,\n\t\t\t},\n\t\t};\n\n\t\tv4l2_event_queue(&input->vdev, &ev);\n\t}\n\n\tvb2_buffer_done(&vb->vb.vb2_buf, VB2_BUF_STATE_DONE);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 1403,
    "critical_vars": [
      "v4l2_buf"
    ],
    "function": "tw5864_handle_frame",
    "filename": "linux/CVE-2019-20806/CVE-2019-20806_CWE-476_2e7682ebfc750177a4944eeb56e97a3f05734528_tw5864-video.c.diff",
    "function_code": "static void tw5864_handle_frame(struct tw5864_h264_frame *frame)\n{\n#define SKIP_VLCBUF_BYTES 3\n\tstruct tw5864_input *input = frame->input;\n\tstruct tw5864_dev *dev = input->root;\n\tstruct tw5864_buf *vb;\n\tstruct vb2_v4l2_buffer *v4l2_buf;\n\tint frame_len = frame->vlc_len - SKIP_VLCBUF_BYTES;\n\tu8 *dst = input->buf_cur_ptr;\n\tu8 tail_mask, vlc_mask = 0;\n\tint i;\n\tu8 vlc_first_byte = ((u8 *)(frame->vlc.addr + SKIP_VLCBUF_BYTES))[0];\n\tunsigned long flags;\n\tint zero_run;\n\tu8 *src;\n\tu8 *src_end;\n\n#ifdef DEBUG\n\tif (frame->checksum !=\n\t    tw5864_vlc_checksum((u32 *)frame->vlc.addr, frame_len))\n\t\tdev_err(&dev->pci->dev,\n\t\t\t\"Checksum of encoded frame doesn't match!\\n\");\n#endif\n\n\tspin_lock_irqsave(&input->slock, flags);\n\tvb = input->vb;\n\tinput->vb = NULL;\n\tspin_unlock_irqrestore(&input->slock, flags);\n\n\tif (!vb) { /* Gone because of disabling */\n\t\tdev_dbg(&dev->pci->dev, \"vb is empty, dropping frame\\n\");\n\t\treturn;\n\t}\n\n\tv4l2_buf = to_vb2_v4l2_buffer(&vb->vb.vb2_buf);\n\n\t/*\n\t * Check for space.\n\t * Mind the overhead of startcode emulation prevention.\n\t */\n\tif (input->buf_cur_space_left < frame_len * 5 / 4) {\n\t\tdev_err_once(&dev->pci->dev,\n\t\t\t     \"Left space in vb2 buffer, %d bytes, is less than considered safely enough to put frame of length %d. Dropping this frame.\\n\",\n\t\t\t     input->buf_cur_space_left, frame_len);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 8 - input->tail_nb_bits; i++)\n\t\tvlc_mask |= 1 << i;\n\ttail_mask = (~vlc_mask) & 0xff;\n\n\tdst[0] = (input->tail & tail_mask) | (vlc_first_byte & vlc_mask);\n\tframe_len--;\n\tdst++;\n\n\t/* H.264 startcode emulation prevention */\n\tsrc = frame->vlc.addr + SKIP_VLCBUF_BYTES + 1;\n\tsrc_end = src + frame_len;\n\tzero_run = 0;\n\tfor (; src < src_end; src++) {\n\t\tif (zero_run < 2) {\n\t\t\tif (*src == 0)\n\t\t\t\t++zero_run;\n\t\t\telse\n\t\t\t\tzero_run = 0;\n\t\t} else {\n\t\t\tif ((*src & ~0x03) == 0)\n\t\t\t\t*dst++ = 0x03;\n\t\t\tzero_run = *src == 0;\n\t\t}\n\t\t*dst++ = *src;\n\t}\n\n\tvb2_set_plane_payload(&vb->vb.vb2_buf, 0,\n\t\t\t      dst - (u8 *)vb2_plane_vaddr(&vb->vb.vb2_buf, 0));\n\n\tvb->vb.vb2_buf.timestamp = frame->timestamp;\n\tv4l2_buf->field = V4L2_FIELD_INTERLACED;\n\tv4l2_buf->sequence = frame->seqno;\n\n\t/* Check for motion flags */\n\tif (frame->gop_seqno /* P-frame */ &&\n\t    tw5864_is_motion_triggered(frame)) {\n\t\tstruct v4l2_event ev = {\n\t\t\t.type = V4L2_EVENT_MOTION_DET,\n\t\t\t.u.motion_det = {\n\t\t\t\t.flags = V4L2_EVENT_MD_FL_HAVE_FRAME_SEQ,\n\t\t\t\t.frame_sequence = v4l2_buf->sequence,\n\t\t\t},\n\t\t};\n\n\t\tv4l2_event_queue(&input->vdev, &ev);\n\t}\n\n\tvb2_buffer_done(&vb->vb.vb2_buf, VB2_BUF_STATE_DONE);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 154,
    "critical_vars": [
      "inode->i_sb"
    ],
    "function": "jfs_evict_inode",
    "filename": "linux/CVE-2022-3202/CVE-2022-3202_CWE-476_a53046291020ec41e09181396c1e829287b48d47_inode.c.diff",
    "function_code": "void jfs_evict_inode(struct inode *inode)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(inode);\n\n\tjfs_info(\"In jfs_evict_inode, inode = 0x%p\", inode);\n\n\tif (!inode->i_nlink && !is_bad_inode(inode)) {\n\t\tdquot_initialize(inode);\n\n\t\tif (JFS_IP(inode)->fileset == FILESYSTEM_I) {\n\t\t\ttruncate_inode_pages_final(&inode->i_data);\n\n\t\t\tif (test_cflag(COMMIT_Freewmap, inode))\n\t\t\t\tjfs_free_zero_link(inode);\n\n\t\t\tif (JFS_SBI(inode->i_sb)->ipimap)\n\t\t\t\tdiFree(inode);\n\n\t\t\t/*\n\t\t\t * Free the inode from the quota allocation.\n\t\t\t */\n\t\t\tdquot_free_inode(inode);\n\t\t}\n\t} else {\n\t\ttruncate_inode_pages_final(&inode->i_data);\n\t}\n\tclear_inode(inode);\n\tdquot_drop(inode);\n\n\tBUG_ON(!list_empty(&ji->anon_inode_list));\n\n\tspin_lock_irq(&ji->ag_lock);\n\tif (ji->active_ag != -1) {\n\t\tstruct bmap *bmap = JFS_SBI(inode->i_sb)->bmap;\n\t\tatomic_dec(&bmap->db_active[ji->active_ag]);\n\t\tji->active_ag = -1;\n\t}\n\tspin_unlock_irq(&ji->ag_lock);\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 794,
    "critical_vars": [
      "error"
    ],
    "function": "xfs_attr_shortform_to_leaf",
    "filename": "linux/CVE-2018-13094/CVE-2018-13094_CWE-476_bb3d48dcf86a97dc25fe9fc2c11938e19cb4399a_xfs_attr_leaf.c.diff",
    "function_code": "xfs_attr_shortform_to_leaf(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t**leaf_bp)\n{\n\txfs_inode_t *dp;\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\txfs_da_args_t nargs;\n\tchar *tmpbuffer;\n\tint error, i, size;\n\txfs_dablk_t blkno;\n\tstruct xfs_buf *bp;\n\txfs_ifork_t *ifp;\n\n\ttrace_xfs_attr_sf_to_leaf(args);\n\n\tdp = args->dp;\n\tifp = dp->i_afp;\n\tsf = (xfs_attr_shortform_t *)ifp->if_u1.if_data;\n\tsize = be16_to_cpu(sf->hdr.totsize);\n\ttmpbuffer = kmem_alloc(size, KM_SLEEP);\n\tASSERT(tmpbuffer != NULL);\n\tmemcpy(tmpbuffer, ifp->if_u1.if_data, size);\n\tsf = (xfs_attr_shortform_t *)tmpbuffer;\n\n\txfs_idata_realloc(dp, -size, XFS_ATTR_FORK);\n\txfs_bmap_local_to_extents_empty(dp, XFS_ATTR_FORK);\n\n\tbp = NULL;\n\terror = xfs_da_grow_inode(args, &blkno);\n\tif (error) {\n\t\t/*\n\t\t * If we hit an IO error middle of the transaction inside\n\t\t * grow_inode(), we may have inconsistent data. Bail out.\n\t\t */\n\t\tif (error == -EIO)\n\t\t\tgoto out;\n\t\txfs_idata_realloc(dp, size, XFS_ATTR_FORK);\t/* try to put */\n\t\tmemcpy(ifp->if_u1.if_data, tmpbuffer, size);\t/* it back */\n\t\tgoto out;\n\t}\n\n\tASSERT(blkno == 0);\n\terror = xfs_attr3_leaf_create(args, blkno, &bp);\n\tif (error) {\n\t\terror = xfs_da_shrink_inode(args, 0, bp);\n\t\tbp = NULL;\n\t\tif (error)\n\t\t\tgoto out;\n\t\txfs_idata_realloc(dp, size, XFS_ATTR_FORK);\t/* try to put */\n\t\tmemcpy(ifp->if_u1.if_data, tmpbuffer, size);\t/* it back */\n\t\tgoto out;\n\t}\n\n\tmemset((char *)&nargs, 0, sizeof(nargs));\n\tnargs.dp = dp;\n\tnargs.geo = args->geo;\n\tnargs.firstblock = args->firstblock;\n\tnargs.dfops = args->dfops;\n\tnargs.total = args->total;\n\tnargs.whichfork = XFS_ATTR_FORK;\n\tnargs.trans = args->trans;\n\tnargs.op_flags = XFS_DA_OP_OKNOENT;\n\n\tsfe = &sf->list[0];\n\tfor (i = 0; i < sf->hdr.count; i++) {\n\t\tnargs.name = sfe->nameval;\n\t\tnargs.namelen = sfe->namelen;\n\t\tnargs.value = &sfe->nameval[nargs.namelen];\n\t\tnargs.valuelen = sfe->valuelen;\n\t\tnargs.hashval = xfs_da_hashname(sfe->nameval,\n\t\t\t\t\t\tsfe->namelen);\n\t\tnargs.flags = XFS_ATTR_NSP_ONDISK_TO_ARGS(sfe->flags);\n\t\terror = xfs_attr3_leaf_lookup_int(bp, &nargs); /* set a->index */\n\t\tASSERT(error == -ENOATTR);\n\t\terror = xfs_attr3_leaf_add(bp, &nargs);\n\t\tASSERT(error != -ENOSPC);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe);\n\t}\n\terror = 0;\n\t*leaf_bp = bp;\nout:\n\tkmem_free(tmpbuffer);\n\treturn error;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 795,
    "critical_vars": [
      "args",
      "bp"
    ],
    "function": "xfs_attr_shortform_to_leaf",
    "filename": "linux/CVE-2018-13094/CVE-2018-13094_CWE-476_bb3d48dcf86a97dc25fe9fc2c11938e19cb4399a_xfs_attr_leaf.c.diff",
    "function_code": "xfs_attr_shortform_to_leaf(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t**leaf_bp)\n{\n\txfs_inode_t *dp;\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\txfs_da_args_t nargs;\n\tchar *tmpbuffer;\n\tint error, i, size;\n\txfs_dablk_t blkno;\n\tstruct xfs_buf *bp;\n\txfs_ifork_t *ifp;\n\n\ttrace_xfs_attr_sf_to_leaf(args);\n\n\tdp = args->dp;\n\tifp = dp->i_afp;\n\tsf = (xfs_attr_shortform_t *)ifp->if_u1.if_data;\n\tsize = be16_to_cpu(sf->hdr.totsize);\n\ttmpbuffer = kmem_alloc(size, KM_SLEEP);\n\tASSERT(tmpbuffer != NULL);\n\tmemcpy(tmpbuffer, ifp->if_u1.if_data, size);\n\tsf = (xfs_attr_shortform_t *)tmpbuffer;\n\n\txfs_idata_realloc(dp, -size, XFS_ATTR_FORK);\n\txfs_bmap_local_to_extents_empty(dp, XFS_ATTR_FORK);\n\n\tbp = NULL;\n\terror = xfs_da_grow_inode(args, &blkno);\n\tif (error) {\n\t\t/*\n\t\t * If we hit an IO error middle of the transaction inside\n\t\t * grow_inode(), we may have inconsistent data. Bail out.\n\t\t */\n\t\tif (error == -EIO)\n\t\t\tgoto out;\n\t\txfs_idata_realloc(dp, size, XFS_ATTR_FORK);\t/* try to put */\n\t\tmemcpy(ifp->if_u1.if_data, tmpbuffer, size);\t/* it back */\n\t\tgoto out;\n\t}\n\n\tASSERT(blkno == 0);\n\terror = xfs_attr3_leaf_create(args, blkno, &bp);\n\tif (error) {\n\t\t/* xfs_attr3_leaf_create may not have instantiated a block */\n\t\tif (bp && (xfs_da_shrink_inode(args, 0, bp) != 0))\n\t\t\tgoto out;\n\t\txfs_idata_realloc(dp, size, XFS_ATTR_FORK);\t/* try to put */\n\t\tmemcpy(ifp->if_u1.if_data, tmpbuffer, size);\t/* it back */\n\t\tgoto out;\n\t}\n\n\tmemset((char *)&nargs, 0, sizeof(nargs));\n\tnargs.dp = dp;\n\tnargs.geo = args->geo;\n\tnargs.firstblock = args->firstblock;\n\tnargs.dfops = args->dfops;\n\tnargs.total = args->total;\n\tnargs.whichfork = XFS_ATTR_FORK;\n\tnargs.trans = args->trans;\n\tnargs.op_flags = XFS_DA_OP_OKNOENT;\n\n\tsfe = &sf->list[0];\n\tfor (i = 0; i < sf->hdr.count; i++) {\n\t\tnargs.name = sfe->nameval;\n\t\tnargs.namelen = sfe->namelen;\n\t\tnargs.value = &sfe->nameval[nargs.namelen];\n\t\tnargs.valuelen = sfe->valuelen;\n\t\tnargs.hashval = xfs_da_hashname(sfe->nameval,\n\t\t\t\t\t\tsfe->namelen);\n\t\tnargs.flags = XFS_ATTR_NSP_ONDISK_TO_ARGS(sfe->flags);\n\t\terror = xfs_attr3_leaf_lookup_int(bp, &nargs); /* set a->index */\n\t\tASSERT(error == -ENOATTR);\n\t\terror = xfs_attr3_leaf_add(bp, &nargs);\n\t\tASSERT(error != -ENOSPC);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe);\n\t}\n\terror = 0;\n\t*leaf_bp = bp;\nout:\n\tkmem_free(tmpbuffer);\n\treturn error;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 185,
    "critical_vars": [
      "priv",
      "vma"
    ],
    "function": "m_stop",
    "filename": "linux/CVE-2011-3637/CVE-2011-3637_CWE-476_76597cd31470fa130784c78fadb4dab2e624a723_task_mmu.c.diff",
    "function_code": "static void m_stop(struct seq_file *m, void *v)\n{\n\tstruct proc_maps_private *priv = m->private;\n\tstruct vm_area_struct *vma = v;\n\n\tvma_stop(priv, vma);\n\tif (priv->task)\n\t\tput_task_struct(priv->task);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 185,
    "critical_vars": [
      "vma"
    ],
    "function": "m_stop",
    "filename": "linux/CVE-2011-3637/CVE-2011-3637_CWE-476_76597cd31470fa130784c78fadb4dab2e624a723_task_mmu.c.diff",
    "function_code": "static void m_stop(struct seq_file *m, void *v)\n{\n\tstruct proc_maps_private *priv = m->private;\n\tstruct vm_area_struct *vma = v;\n\n\tif (!IS_ERR(vma))\n\t\tvma_stop(priv, vma);\n\tif (priv->task)\n\t\tput_task_struct(priv->task);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 492,
    "critical_vars": [
      "flags"
    ],
    "function": "xfs_iget_cache_miss",
    "filename": "linux/CVE-2018-13093/CVE-2018-13093_CWE-476_afca6c5b2595fc44383919fba740c194b0b76aff_xfs_icache.c.diff",
    "function_code": "xfs_iget_cache_miss(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag,\n\txfs_trans_t\t\t*tp,\n\txfs_ino_t\t\tino,\n\tstruct xfs_inode\t**ipp,\n\tint\t\t\tflags,\n\tint\t\t\tlock_flags)\n{\n\tstruct xfs_inode\t*ip;\n\tint\t\t\terror;\n\txfs_agino_t\t\tagino = XFS_INO_TO_AGINO(mp, ino);\n\tint\t\t\tiflags;\n\n\tip = xfs_inode_alloc(mp, ino);\n\tif (!ip)\n\t\treturn -ENOMEM;\n\n\terror = xfs_iread(mp, tp, ip, flags);\n\tif (error)\n\t\tgoto out_destroy;\n\n\tif (!xfs_inode_verify_forks(ip)) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_destroy;\n\t}\n\n\ttrace_xfs_iget_miss(ip);\n\n\n\t/*\n\t * If we are allocating a new inode, then check what was returned is\n\t * actually a free, empty inode. If we are not allocating an inode,\n\t * the check we didn't find a free inode.\n\t */\n\tif (flags & XFS_IGET_CREATE) {\n\t\tif (VFS_I(ip)->i_mode != 0) {\n\t\t\txfs_warn(mp,\n\"Corruption detected! Free inode 0x%llx not marked free on disk\",\n\t\t\t\tino);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto out_destroy;\n\t\t}\n\t\tif (ip->i_d.di_nblocks != 0) {\n\t\t\txfs_warn(mp,\n\"Corruption detected! Free inode 0x%llx has blocks allocated!\",\n\t\t\t\tino);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto out_destroy;\n\t\t}\n\t} else if (VFS_I(ip)->i_mode == 0) {\n\t\terror = -ENOENT;\n\t\tgoto out_destroy;\n\t}\n\n\t/*\n\t * Preload the radix tree so we can insert safely under the\n\t * write spinlock. Note that we cannot sleep inside the preload\n\t * region. Since we can be called from transaction context, don't\n\t * recurse into the file system.\n\t */\n\tif (radix_tree_preload(GFP_NOFS)) {\n\t\terror = -EAGAIN;\n\t\tgoto out_destroy;\n\t}\n\n\t/*\n\t * Because the inode hasn't been added to the radix-tree yet it can't\n\t * be found by another thread, so we can do the non-sleeping lock here.\n\t */\n\tif (lock_flags) {\n\t\tif (!xfs_ilock_nowait(ip, lock_flags))\n\t\t\tBUG();\n\t}\n\n\t/*\n\t * These values must be set before inserting the inode into the radix\n\t * tree as the moment it is inserted a concurrent lookup (allowed by the\n\t * RCU locking mechanism) can find it and that lookup must see that this\n\t * is an inode currently under construction (i.e. that XFS_INEW is set).\n\t * The ip->i_flags_lock that protects the XFS_INEW flag forms the\n\t * memory barrier that ensures this detection works correctly at lookup\n\t * time.\n\t */\n\tiflags = XFS_INEW;\n\tif (flags & XFS_IGET_DONTCACHE)\n\t\tiflags |= XFS_IDONTCACHE;\n\tip->i_udquot = NULL;\n\tip->i_gdquot = NULL;\n\tip->i_pdquot = NULL;\n\txfs_iflags_set(ip, iflags);\n\n\t/* insert the new inode */\n\tspin_lock(&pag->pag_ici_lock);\n\terror = radix_tree_insert(&pag->pag_ici_root, agino, ip);\n\tif (unlikely(error)) {\n\t\tWARN_ON(error != -EEXIST);\n\t\tXFS_STATS_INC(mp, xs_ig_dup);\n\t\terror = -EAGAIN;\n\t\tgoto out_preload_end;\n\t}\n\tspin_unlock(&pag->pag_ici_lock);\n\tradix_tree_preload_end();\n\n\t*ipp = ip;\n\treturn 0;\n\nout_preload_end:\n\tspin_unlock(&pag->pag_ici_lock);\n\tradix_tree_preload_end();\n\tif (lock_flags)\n\t\txfs_iunlock(ip, lock_flags);\nout_destroy:\n\t__destroy_inode(VFS_I(ip));\n\txfs_inode_free(ip);\n\treturn error;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 531,
    "critical_vars": [
      "error"
    ],
    "function": "xfs_iget_cache_miss",
    "filename": "linux/CVE-2018-13093/CVE-2018-13093_CWE-476_afca6c5b2595fc44383919fba740c194b0b76aff_xfs_icache.c.diff",
    "function_code": "xfs_iget_cache_miss(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag,\n\txfs_trans_t\t\t*tp,\n\txfs_ino_t\t\tino,\n\tstruct xfs_inode\t**ipp,\n\tint\t\t\tflags,\n\tint\t\t\tlock_flags)\n{\n\tstruct xfs_inode\t*ip;\n\tint\t\t\terror;\n\txfs_agino_t\t\tagino = XFS_INO_TO_AGINO(mp, ino);\n\tint\t\t\tiflags;\n\n\tip = xfs_inode_alloc(mp, ino);\n\tif (!ip)\n\t\treturn -ENOMEM;\n\n\terror = xfs_iread(mp, tp, ip, flags);\n\tif (error)\n\t\tgoto out_destroy;\n\n\tif (!xfs_inode_verify_forks(ip)) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_destroy;\n\t}\n\n\ttrace_xfs_iget_miss(ip);\n\n\n\t/*\n\t * Check the inode free state is valid. This also detects lookup\n\t * racing with unlinks.\n\t */\n\terror = xfs_iget_check_free_state(ip, flags);\n\tif (error)\n\t\tgoto out_destroy;\n\n\t/*\n\t * Preload the radix tree so we can insert safely under the\n\t * write spinlock. Note that we cannot sleep inside the preload\n\t * region. Since we can be called from transaction context, don't\n\t * recurse into the file system.\n\t */\n\tif (radix_tree_preload(GFP_NOFS)) {\n\t\terror = -EAGAIN;\n\t\tgoto out_destroy;\n\t}\n\n\t/*\n\t * Because the inode hasn't been added to the radix-tree yet it can't\n\t * be found by another thread, so we can do the non-sleeping lock here.\n\t */\n\tif (lock_flags) {\n\t\tif (!xfs_ilock_nowait(ip, lock_flags))\n\t\t\tBUG();\n\t}\n\n\t/*\n\t * These values must be set before inserting the inode into the radix\n\t * tree as the moment it is inserted a concurrent lookup (allowed by the\n\t * RCU locking mechanism) can find it and that lookup must see that this\n\t * is an inode currently under construction (i.e. that XFS_INEW is set).\n\t * The ip->i_flags_lock that protects the XFS_INEW flag forms the\n\t * memory barrier that ensures this detection works correctly at lookup\n\t * time.\n\t */\n\tiflags = XFS_INEW;\n\tif (flags & XFS_IGET_DONTCACHE)\n\t\tiflags |= XFS_IDONTCACHE;\n\tip->i_udquot = NULL;\n\tip->i_gdquot = NULL;\n\tip->i_pdquot = NULL;\n\txfs_iflags_set(ip, iflags);\n\n\t/* insert the new inode */\n\tspin_lock(&pag->pag_ici_lock);\n\terror = radix_tree_insert(&pag->pag_ici_root, agino, ip);\n\tif (unlikely(error)) {\n\t\tWARN_ON(error != -EEXIST);\n\t\tXFS_STATS_INC(mp, xs_ig_dup);\n\t\terror = -EAGAIN;\n\t\tgoto out_preload_end;\n\t}\n\tspin_unlock(&pag->pag_ici_lock);\n\tradix_tree_preload_end();\n\n\t*ipp = ip;\n\treturn 0;\n\nout_preload_end:\n\tspin_unlock(&pag->pag_ici_lock);\n\tradix_tree_preload_end();\n\tif (lock_flags)\n\t\txfs_iunlock(ip, lock_flags);\nout_destroy:\n\t__destroy_inode(VFS_I(ip));\n\txfs_inode_free(ip);\n\treturn error;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 283,
    "critical_vars": [
      "dynset_expr->ops"
    ],
    "function": "nft_dynset_init",
    "filename": "linux/CVE-2023-6622/CVE-2023-6622_CWE-476_3701cd390fd731ee7ae8b8006246c8db82c72bea_nft_dynset.c.diff",
    "function_code": "static int nft_dynset_init(const struct nft_ctx *ctx,\n\t\t\t   const struct nft_expr *expr,\n\t\t\t   const struct nlattr * const tb[])\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(ctx->net);\n\tstruct nft_dynset *priv = nft_expr_priv(expr);\n\tu8 genmask = nft_genmask_next(ctx->net);\n\tstruct nft_set *set;\n\tu64 timeout;\n\tint err, i;\n\n\tlockdep_assert_held(&nft_net->commit_mutex);\n\n\tif (tb[NFTA_DYNSET_SET_NAME] == NULL ||\n\t    tb[NFTA_DYNSET_OP] == NULL ||\n\t    tb[NFTA_DYNSET_SREG_KEY] == NULL)\n\t\treturn -EINVAL;\n\n\tif (tb[NFTA_DYNSET_FLAGS]) {\n\t\tu32 flags = ntohl(nla_get_be32(tb[NFTA_DYNSET_FLAGS]));\n\t\tif (flags & ~(NFT_DYNSET_F_INV | NFT_DYNSET_F_EXPR))\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (flags & NFT_DYNSET_F_INV)\n\t\t\tpriv->invert = true;\n\t\tif (flags & NFT_DYNSET_F_EXPR)\n\t\t\tpriv->expr = true;\n\t}\n\n\tset = nft_set_lookup_global(ctx->net, ctx->table,\n\t\t\t\t    tb[NFTA_DYNSET_SET_NAME],\n\t\t\t\t    tb[NFTA_DYNSET_SET_ID], genmask);\n\tif (IS_ERR(set))\n\t\treturn PTR_ERR(set);\n\n\tif (set->flags & NFT_SET_OBJECT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (set->ops->update == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\tif (set->flags & NFT_SET_CONSTANT)\n\t\treturn -EBUSY;\n\n\tpriv->op = ntohl(nla_get_be32(tb[NFTA_DYNSET_OP]));\n\tif (priv->op > NFT_DYNSET_OP_DELETE)\n\t\treturn -EOPNOTSUPP;\n\n\ttimeout = 0;\n\tif (tb[NFTA_DYNSET_TIMEOUT] != NULL) {\n\t\tif (!(set->flags & NFT_SET_TIMEOUT))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\terr = nf_msecs_to_jiffies64(tb[NFTA_DYNSET_TIMEOUT], &timeout);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = nft_parse_register_load(tb[NFTA_DYNSET_SREG_KEY], &priv->sreg_key,\n\t\t\t\t      set->klen);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[NFTA_DYNSET_SREG_DATA] != NULL) {\n\t\tif (!(set->flags & NFT_SET_MAP))\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (set->dtype == NFT_DATA_VERDICT)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\terr = nft_parse_register_load(tb[NFTA_DYNSET_SREG_DATA],\n\t\t\t\t\t      &priv->sreg_data, set->dlen);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else if (set->flags & NFT_SET_MAP)\n\t\treturn -EINVAL;\n\n\tif ((tb[NFTA_DYNSET_EXPR] || tb[NFTA_DYNSET_EXPRESSIONS]) &&\n\t    !(set->flags & NFT_SET_EVAL))\n\t\treturn -EINVAL;\n\n\tif (tb[NFTA_DYNSET_EXPR]) {\n\t\tstruct nft_expr *dynset_expr;\n\n\t\tdynset_expr = nft_dynset_expr_alloc(ctx, set,\n\t\t\t\t\t\t    tb[NFTA_DYNSET_EXPR], 0);\n\t\tif (IS_ERR(dynset_expr))\n\t\t\treturn PTR_ERR(dynset_expr);\n\n\t\tpriv->num_exprs++;\n\t\tpriv->expr_array[0] = dynset_expr;\n\n\t\tif (set->num_exprs > 1 ||\n\t\t    (set->num_exprs == 1 &&\n\t\t     dynset_expr->ops != set->exprs[0]->ops)) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err_expr_free;\n\t\t}\n\t} else if (tb[NFTA_DYNSET_EXPRESSIONS]) {\n\t\tstruct nft_expr *dynset_expr;\n\t\tstruct nlattr *tmp;\n\t\tint left;\n\n\t\tif (!priv->expr)\n\t\t\treturn -EINVAL;\n\n\t\ti = 0;\n\t\tnla_for_each_nested(tmp, tb[NFTA_DYNSET_EXPRESSIONS], left) {\n\t\t\tif (i == NFT_SET_EXPR_MAX) {\n\t\t\t\terr = -E2BIG;\n\t\t\t\tgoto err_expr_free;\n\t\t\t}\n\t\t\tif (nla_type(tmp) != NFTA_LIST_ELEM) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto err_expr_free;\n\t\t\t}\n\t\t\tdynset_expr = nft_dynset_expr_alloc(ctx, set, tmp, i);\n\t\t\tif (IS_ERR(dynset_expr)) {\n\t\t\t\terr = PTR_ERR(dynset_expr);\n\t\t\t\tgoto err_expr_free;\n\t\t\t}\n\t\t\tpriv->expr_array[i] = dynset_expr;\n\t\t\tpriv->num_exprs++;\n\n\t\t\tif (set->num_exprs &&\n\t\t\t    dynset_expr->ops != set->exprs[i]->ops) {\n\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\tgoto err_expr_free;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tif (set->num_exprs && set->num_exprs != i) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err_expr_free;\n\t\t}\n\t} else if (set->num_exprs > 0) {\n\t\terr = nft_set_elem_expr_clone(ctx, set, priv->expr_array);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tpriv->num_exprs = set->num_exprs;\n\t}\n\n\tnft_set_ext_prepare(&priv->tmpl);\n\tnft_set_ext_add_length(&priv->tmpl, NFT_SET_EXT_KEY, set->klen);\n\tif (set->flags & NFT_SET_MAP)\n\t\tnft_set_ext_add_length(&priv->tmpl, NFT_SET_EXT_DATA, set->dlen);\n\n\tif (priv->num_exprs)\n\t\tnft_dynset_ext_add_expr(priv);\n\n\tif (set->flags & NFT_SET_TIMEOUT) {\n\t\tif (timeout || set->timeout) {\n\t\t\tnft_set_ext_add(&priv->tmpl, NFT_SET_EXT_TIMEOUT);\n\t\t\tnft_set_ext_add(&priv->tmpl, NFT_SET_EXT_EXPIRATION);\n\t\t}\n\t}\n\n\tpriv->timeout = timeout;\n\n\terr = nf_tables_bind_set(ctx, set, &priv->binding);\n\tif (err < 0)\n\t\tgoto err_expr_free;\n\n\tif (set->size == 0)\n\t\tset->size = 0xffff;\n\n\tpriv->set = set;\n\treturn 0;\n\nerr_expr_free:\n\tfor (i = 0; i < priv->num_exprs; i++)\n\t\tnft_expr_destroy(ctx, priv->expr_array[i]);\n\treturn err;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 284,
    "critical_vars": [
      "i"
    ],
    "function": "nft_dynset_init",
    "filename": "linux/CVE-2023-6622/CVE-2023-6622_CWE-476_3701cd390fd731ee7ae8b8006246c8db82c72bea_nft_dynset.c.diff",
    "function_code": "static int nft_dynset_init(const struct nft_ctx *ctx,\n\t\t\t   const struct nft_expr *expr,\n\t\t\t   const struct nlattr * const tb[])\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(ctx->net);\n\tstruct nft_dynset *priv = nft_expr_priv(expr);\n\tu8 genmask = nft_genmask_next(ctx->net);\n\tstruct nft_set *set;\n\tu64 timeout;\n\tint err, i;\n\n\tlockdep_assert_held(&nft_net->commit_mutex);\n\n\tif (tb[NFTA_DYNSET_SET_NAME] == NULL ||\n\t    tb[NFTA_DYNSET_OP] == NULL ||\n\t    tb[NFTA_DYNSET_SREG_KEY] == NULL)\n\t\treturn -EINVAL;\n\n\tif (tb[NFTA_DYNSET_FLAGS]) {\n\t\tu32 flags = ntohl(nla_get_be32(tb[NFTA_DYNSET_FLAGS]));\n\t\tif (flags & ~(NFT_DYNSET_F_INV | NFT_DYNSET_F_EXPR))\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (flags & NFT_DYNSET_F_INV)\n\t\t\tpriv->invert = true;\n\t\tif (flags & NFT_DYNSET_F_EXPR)\n\t\t\tpriv->expr = true;\n\t}\n\n\tset = nft_set_lookup_global(ctx->net, ctx->table,\n\t\t\t\t    tb[NFTA_DYNSET_SET_NAME],\n\t\t\t\t    tb[NFTA_DYNSET_SET_ID], genmask);\n\tif (IS_ERR(set))\n\t\treturn PTR_ERR(set);\n\n\tif (set->flags & NFT_SET_OBJECT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (set->ops->update == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\tif (set->flags & NFT_SET_CONSTANT)\n\t\treturn -EBUSY;\n\n\tpriv->op = ntohl(nla_get_be32(tb[NFTA_DYNSET_OP]));\n\tif (priv->op > NFT_DYNSET_OP_DELETE)\n\t\treturn -EOPNOTSUPP;\n\n\ttimeout = 0;\n\tif (tb[NFTA_DYNSET_TIMEOUT] != NULL) {\n\t\tif (!(set->flags & NFT_SET_TIMEOUT))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\terr = nf_msecs_to_jiffies64(tb[NFTA_DYNSET_TIMEOUT], &timeout);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = nft_parse_register_load(tb[NFTA_DYNSET_SREG_KEY], &priv->sreg_key,\n\t\t\t\t      set->klen);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[NFTA_DYNSET_SREG_DATA] != NULL) {\n\t\tif (!(set->flags & NFT_SET_MAP))\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (set->dtype == NFT_DATA_VERDICT)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\terr = nft_parse_register_load(tb[NFTA_DYNSET_SREG_DATA],\n\t\t\t\t\t      &priv->sreg_data, set->dlen);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else if (set->flags & NFT_SET_MAP)\n\t\treturn -EINVAL;\n\n\tif ((tb[NFTA_DYNSET_EXPR] || tb[NFTA_DYNSET_EXPRESSIONS]) &&\n\t    !(set->flags & NFT_SET_EVAL))\n\t\treturn -EINVAL;\n\n\tif (tb[NFTA_DYNSET_EXPR]) {\n\t\tstruct nft_expr *dynset_expr;\n\n\t\tdynset_expr = nft_dynset_expr_alloc(ctx, set,\n\t\t\t\t\t\t    tb[NFTA_DYNSET_EXPR], 0);\n\t\tif (IS_ERR(dynset_expr))\n\t\t\treturn PTR_ERR(dynset_expr);\n\n\t\tpriv->num_exprs++;\n\t\tpriv->expr_array[0] = dynset_expr;\n\n\t\tif (set->num_exprs > 1 ||\n\t\t    (set->num_exprs == 1 &&\n\t\t     dynset_expr->ops != set->exprs[0]->ops)) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err_expr_free;\n\t\t}\n\t} else if (tb[NFTA_DYNSET_EXPRESSIONS]) {\n\t\tstruct nft_expr *dynset_expr;\n\t\tstruct nlattr *tmp;\n\t\tint left;\n\n\t\tif (!priv->expr)\n\t\t\treturn -EINVAL;\n\n\t\ti = 0;\n\t\tnla_for_each_nested(tmp, tb[NFTA_DYNSET_EXPRESSIONS], left) {\n\t\t\tif (i == NFT_SET_EXPR_MAX) {\n\t\t\t\terr = -E2BIG;\n\t\t\t\tgoto err_expr_free;\n\t\t\t}\n\t\t\tif (nla_type(tmp) != NFTA_LIST_ELEM) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto err_expr_free;\n\t\t\t}\n\t\t\tdynset_expr = nft_dynset_expr_alloc(ctx, set, tmp, i);\n\t\t\tif (IS_ERR(dynset_expr)) {\n\t\t\t\terr = PTR_ERR(dynset_expr);\n\t\t\t\tgoto err_expr_free;\n\t\t\t}\n\t\t\tpriv->expr_array[i] = dynset_expr;\n\t\t\tpriv->num_exprs++;\n\n\t\t\tif (set->num_exprs) {\n\t\t\t\tif (i >= set->num_exprs) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto err_expr_free;\n\t\t\t\t}\n\t\t\t\tif (dynset_expr->ops != set->exprs[i]->ops) {\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto err_expr_free;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tif (set->num_exprs && set->num_exprs != i) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err_expr_free;\n\t\t}\n\t} else if (set->num_exprs > 0) {\n\t\terr = nft_set_elem_expr_clone(ctx, set, priv->expr_array);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tpriv->num_exprs = set->num_exprs;\n\t}\n\n\tnft_set_ext_prepare(&priv->tmpl);\n\tnft_set_ext_add_length(&priv->tmpl, NFT_SET_EXT_KEY, set->klen);\n\tif (set->flags & NFT_SET_MAP)\n\t\tnft_set_ext_add_length(&priv->tmpl, NFT_SET_EXT_DATA, set->dlen);\n\n\tif (priv->num_exprs)\n\t\tnft_dynset_ext_add_expr(priv);\n\n\tif (set->flags & NFT_SET_TIMEOUT) {\n\t\tif (timeout || set->timeout) {\n\t\t\tnft_set_ext_add(&priv->tmpl, NFT_SET_EXT_TIMEOUT);\n\t\t\tnft_set_ext_add(&priv->tmpl, NFT_SET_EXT_EXPIRATION);\n\t\t}\n\t}\n\n\tpriv->timeout = timeout;\n\n\terr = nf_tables_bind_set(ctx, set, &priv->binding);\n\tif (err < 0)\n\t\tgoto err_expr_free;\n\n\tif (set->size == 0)\n\t\tset->size = 0xffff;\n\n\tpriv->set = set;\n\treturn 0;\n\nerr_expr_free:\n\tfor (i = 0; i < priv->num_exprs; i++)\n\t\tnft_expr_destroy(ctx, priv->expr_array[i]);\n\treturn err;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 400,
    "critical_vars": [
      "page"
    ],
    "function": "migrate_page_move_mapping",
    "filename": "linux/CVE-2016-3070/CVE-2016-3070_CWE-476_42cb14b110a5698ccf26ce59c4441722605a3743_migrate.c.diff",
    "function_code": "int migrate_page_move_mapping(struct address_space *mapping,\n\t\tstruct page *newpage, struct page *page,\n\t\tstruct buffer_head *head, enum migrate_mode mode,\n\t\tint extra_count)\n{\n\tint expected_count = 1 + extra_count;\n\tvoid **pslot;\n\n\tif (!mapping) {\n\t\t/* Anonymous page without mapping */\n\t\tif (page_count(page) != expected_count)\n\t\t\treturn -EAGAIN;\n\n\t\t/* No turning back from here */\n\t\tset_page_memcg(newpage, page_memcg(page));\n\t\tnewpage->index = page->index;\n\t\tnewpage->mapping = page->mapping;\n\t\tif (PageSwapBacked(page))\n\t\t\tSetPageSwapBacked(newpage);\n\n\t\treturn MIGRATEPAGE_SUCCESS;\n\t}\n\n\tspin_lock_irq(&mapping->tree_lock);\n\n\tpslot = radix_tree_lookup_slot(&mapping->page_tree,\n \t\t\t\t\tpage_index(page));\n\n\texpected_count += 1 + page_has_private(page);\n\tif (page_count(page) != expected_count ||\n\t\tradix_tree_deref_slot_protected(pslot, &mapping->tree_lock) != page) {\n\t\tspin_unlock_irq(&mapping->tree_lock);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (!page_freeze_refs(page, expected_count)) {\n\t\tspin_unlock_irq(&mapping->tree_lock);\n\t\treturn -EAGAIN;\n\t}\n\n\t/*\n\t * In the async migration case of moving a page with buffers, lock the\n\t * buffers using trylock before the mapping is moved. If the mapping\n\t * was moved, we later failed to lock the buffers and could not move\n\t * the mapping back due to an elevated page count, we would have to\n\t * block waiting on other references to be dropped.\n\t */\n\tif (mode == MIGRATE_ASYNC && head &&\n\t\t\t!buffer_migrate_lock_buffers(head, mode)) {\n\t\tpage_unfreeze_refs(page, expected_count);\n\t\tspin_unlock_irq(&mapping->tree_lock);\n\t\treturn -EAGAIN;\n\t}\n\n\t/*\n\t * Now we know that no one else is looking at the page:\n\t * no turning back from here.\n\t */\n\tset_page_memcg(newpage, page_memcg(page));\n\tnewpage->index = page->index;\n\tnewpage->mapping = page->mapping;\n\tif (PageSwapBacked(page))\n\t\tSetPageSwapBacked(newpage);\n\n\tget_page(newpage);\t/* add cache reference */\n\tif (PageSwapCache(page)) {\n\t\tSetPageSwapCache(newpage);\n\t\tset_page_private(newpage, page_private(page));\n\t}\n\n\tradix_tree_replace_slot(pslot, newpage);\n\n\t/*\n\t * Drop cache reference from old page by unfreezing\n\t * to one less reference.\n\t * We know this isn't the last reference.\n\t */\n\tpage_unfreeze_refs(page, expected_count - 1);\n\n\t/*\n\t * If moved to a different zone then also account\n\t * the page for that zone. Other VM counters will be\n\t * taken care of when we establish references to the\n\t * new page and drop references to the old page.\n\t *\n\t * Note that anonymous pages are accounted for\n\t * via NR_FILE_PAGES and NR_ANON_PAGES if they\n\t * are mapped to swap space.\n\t */\n\t__dec_zone_page_state(page, NR_FILE_PAGES);\n\t__inc_zone_page_state(newpage, NR_FILE_PAGES);\n\tif (!PageSwapCache(page) && PageSwapBacked(page)) {\n\t\t__dec_zone_page_state(page, NR_SHMEM);\n\t\t__inc_zone_page_state(newpage, NR_SHMEM);\n\t}\n\tspin_unlock_irq(&mapping->tree_lock);\n\n\treturn MIGRATEPAGE_SUCCESS;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 528,
    "critical_vars": [
      "page"
    ],
    "function": "migrate_page_copy",
    "filename": "linux/CVE-2016-3070/CVE-2016-3070_CWE-476_42cb14b110a5698ccf26ce59c4441722605a3743_migrate.c.diff",
    "function_code": "void migrate_page_copy(struct page *newpage, struct page *page)\n{\n\tint cpupid;\n\n\tif (PageHuge(page) || PageTransHuge(page))\n\t\tcopy_huge_page(newpage, page);\n\telse\n\t\tcopy_highpage(newpage, page);\n\n\tif (PageError(page))\n\t\tSetPageError(newpage);\n\tif (PageReferenced(page))\n\t\tSetPageReferenced(newpage);\n\tif (PageUptodate(page))\n\t\tSetPageUptodate(newpage);\n\tif (TestClearPageActive(page)) {\n\t\tVM_BUG_ON_PAGE(PageUnevictable(page), page);\n\t\tSetPageActive(newpage);\n\t} else if (TestClearPageUnevictable(page))\n\t\tSetPageUnevictable(newpage);\n\tif (PageChecked(page))\n\t\tSetPageChecked(newpage);\n\tif (PageMappedToDisk(page))\n\t\tSetPageMappedToDisk(newpage);\n\n\tif (PageDirty(page)) {\n\t\tclear_page_dirty_for_io(page);\n\t\t/*\n\t\t * Want to mark the page and the radix tree as dirty, and\n\t\t * redo the accounting that clear_page_dirty_for_io undid,\n\t\t * but we can't use set_page_dirty because that function\n\t\t * is actually a signal that all of the page has become dirty.\n\t\t * Whereas only part of our page may be dirty.\n\t\t */\n\t\tif (PageSwapBacked(page))\n\t\t\tSetPageDirty(newpage);\n\t\telse\n\t\t\t__set_page_dirty_nobuffers(newpage);\n \t}\n\n\tif (page_is_young(page))\n\t\tset_page_young(newpage);\n\tif (page_is_idle(page))\n\t\tset_page_idle(newpage);\n\n\t/*\n\t * Copy NUMA information to the new page, to prevent over-eager\n\t * future migrations of this same page.\n\t */\n\tcpupid = page_cpupid_xchg_last(page, -1);\n\tpage_cpupid_xchg_last(newpage, cpupid);\n\n\tksm_migrate_page(newpage, page);\n\t/*\n\t * Please do not reorder this without considering how mm/ksm.c's\n\t * get_ksm_page() depends upon ksm_migrate_page() and PageSwapCache().\n\t */\n\tif (PageSwapCache(page))\n\t\tClearPageSwapCache(page);\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\n\t/*\n\t * If any waiters have accumulated on the new page then\n\t * wake them up.\n\t */\n\tif (PageWriteback(newpage))\n\t\tend_page_writeback(newpage);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 551,
    "critical_vars": [
      "newpage"
    ],
    "function": "migrate_page_copy",
    "filename": "linux/CVE-2016-3070/CVE-2016-3070_CWE-476_42cb14b110a5698ccf26ce59c4441722605a3743_migrate.c.diff",
    "function_code": "void migrate_page_copy(struct page *newpage, struct page *page)\n{\n\tint cpupid;\n\n\tif (PageHuge(page) || PageTransHuge(page))\n\t\tcopy_huge_page(newpage, page);\n\telse\n\t\tcopy_highpage(newpage, page);\n\n\tif (PageError(page))\n\t\tSetPageError(newpage);\n\tif (PageReferenced(page))\n\t\tSetPageReferenced(newpage);\n\tif (PageUptodate(page))\n\t\tSetPageUptodate(newpage);\n\tif (TestClearPageActive(page)) {\n\t\tVM_BUG_ON_PAGE(PageUnevictable(page), page);\n\t\tSetPageActive(newpage);\n\t} else if (TestClearPageUnevictable(page))\n\t\tSetPageUnevictable(newpage);\n\tif (PageChecked(page))\n\t\tSetPageChecked(newpage);\n\tif (PageMappedToDisk(page))\n\t\tSetPageMappedToDisk(newpage);\n\n\t/* Move dirty on pages not done by migrate_page_move_mapping() */\n\tif (PageDirty(page))\n\t\tSetPageDirty(newpage);\n\n\tif (page_is_young(page))\n\t\tset_page_young(newpage);\n\tif (page_is_idle(page))\n\t\tset_page_idle(newpage);\n\n\t/*\n\t * Copy NUMA information to the new page, to prevent over-eager\n\t * future migrations of this same page.\n\t */\n\tcpupid = page_cpupid_xchg_last(page, -1);\n\tpage_cpupid_xchg_last(newpage, cpupid);\n\n\tksm_migrate_page(newpage, page);\n\t/*\n\t * Please do not reorder this without considering how mm/ksm.c's\n\t * get_ksm_page() depends upon ksm_migrate_page() and PageSwapCache().\n\t */\n\tif (PageSwapCache(page))\n\t\tClearPageSwapCache(page);\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\n\t/*\n\t * If any waiters have accumulated on the new page then\n\t * wake them up.\n\t */\n\tif (PageWriteback(newpage))\n\t\tend_page_writeback(newpage);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 102,
    "critical_vars": [
      "_payload"
    ],
    "function": "SYSCALL_DEFINE5",
    "filename": "linux/CVE-2017-15274/CVE-2017-15274_CWE-476_5649645d725c73df4302428ee4e02c869248b4c5_keyctl.c.diff",
    "function_code": "SYSCALL_DEFINE5(add_key, const char __user *, _type,\n\t\tconst char __user *, _description,\n\t\tconst void __user *, _payload,\n\t\tsize_t, plen,\n\t\tkey_serial_t, ringid)\n{\n\tkey_ref_t keyring_ref, key_ref;\n\tchar type[32], *description;\n\tvoid *payload;\n\tlong ret;\n\n\tret = -EINVAL;\n\tif (plen > 1024 * 1024 - 1)\n\t\tgoto error;\n\n\t/* draw all the data into kernel space */\n\tret = key_get_type_from_user(type, _type, sizeof(type));\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdescription = NULL;\n\tif (_description) {\n\t\tdescription = strndup_user(_description, KEY_MAX_DESC_SIZE);\n\t\tif (IS_ERR(description)) {\n\t\t\tret = PTR_ERR(description);\n\t\t\tgoto error;\n\t\t}\n\t\tif (!*description) {\n\t\t\tkfree(description);\n\t\t\tdescription = NULL;\n\t\t} else if ((description[0] == '.') &&\n\t\t\t   (strncmp(type, \"keyring\", 7) == 0)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto error2;\n\t\t}\n\t}\n\n\t/* pull the payload in if one was supplied */\n\tpayload = NULL;\n\n\tif (_payload) {\n\t\tret = -ENOMEM;\n\t\tpayload = kvmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error2;\n\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(payload, _payload, plen) != 0)\n\t\t\tgoto error3;\n\t}\n\n\t/* find the target keyring (which must be writable) */\n\tkeyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error3;\n\t}\n\n\t/* create or update the requested key and add it to the target\n\t * keyring */\n\tkey_ref = key_create_or_update(keyring_ref, type, description,\n\t\t\t\t       payload, plen, KEY_PERM_UNDEF,\n\t\t\t\t       KEY_ALLOC_IN_QUOTA);\n\tif (!IS_ERR(key_ref)) {\n\t\tret = key_ref_to_ptr(key_ref)->serial;\n\t\tkey_ref_put(key_ref);\n\t}\n\telse {\n\t\tret = PTR_ERR(key_ref);\n\t}\n\n\tkey_ref_put(keyring_ref);\n error3:\n\tkvfree(payload);\n error2:\n\tkfree(description);\n error:\n\treturn ret;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 102,
    "critical_vars": [
      "plen"
    ],
    "function": "SYSCALL_DEFINE5",
    "filename": "linux/CVE-2017-15274/CVE-2017-15274_CWE-476_5649645d725c73df4302428ee4e02c869248b4c5_keyctl.c.diff",
    "function_code": "SYSCALL_DEFINE5(add_key, const char __user *, _type,\n\t\tconst char __user *, _description,\n\t\tconst void __user *, _payload,\n\t\tsize_t, plen,\n\t\tkey_serial_t, ringid)\n{\n\tkey_ref_t keyring_ref, key_ref;\n\tchar type[32], *description;\n\tvoid *payload;\n\tlong ret;\n\n\tret = -EINVAL;\n\tif (plen > 1024 * 1024 - 1)\n\t\tgoto error;\n\n\t/* draw all the data into kernel space */\n\tret = key_get_type_from_user(type, _type, sizeof(type));\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdescription = NULL;\n\tif (_description) {\n\t\tdescription = strndup_user(_description, KEY_MAX_DESC_SIZE);\n\t\tif (IS_ERR(description)) {\n\t\t\tret = PTR_ERR(description);\n\t\t\tgoto error;\n\t\t}\n\t\tif (!*description) {\n\t\t\tkfree(description);\n\t\t\tdescription = NULL;\n\t\t} else if ((description[0] == '.') &&\n\t\t\t   (strncmp(type, \"keyring\", 7) == 0)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto error2;\n\t\t}\n\t}\n\n\t/* pull the payload in if one was supplied */\n\tpayload = NULL;\n\n\tif (plen) {\n\t\tret = -ENOMEM;\n\t\tpayload = kvmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error2;\n\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(payload, _payload, plen) != 0)\n\t\t\tgoto error3;\n\t}\n\n\t/* find the target keyring (which must be writable) */\n\tkeyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error3;\n\t}\n\n\t/* create or update the requested key and add it to the target\n\t * keyring */\n\tkey_ref = key_create_or_update(keyring_ref, type, description,\n\t\t\t\t       payload, plen, KEY_PERM_UNDEF,\n\t\t\t\t       KEY_ALLOC_IN_QUOTA);\n\tif (!IS_ERR(key_ref)) {\n\t\tret = key_ref_to_ptr(key_ref)->serial;\n\t\tkey_ref_put(key_ref);\n\t}\n\telse {\n\t\tret = PTR_ERR(key_ref);\n\t}\n\n\tkey_ref_put(keyring_ref);\n error3:\n\tkvfree(payload);\n error2:\n\tkfree(description);\n error:\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 327,
    "critical_vars": [
      "_payload"
    ],
    "function": "keyctl_update_key",
    "filename": "linux/CVE-2017-15274/CVE-2017-15274_CWE-476_5649645d725c73df4302428ee4e02c869248b4c5_keyctl.c.diff",
    "function_code": "long keyctl_update_key(key_serial_t id,\n\t\t       const void __user *_payload,\n\t\t       size_t plen)\n{\n\tkey_ref_t key_ref;\n\tvoid *payload;\n\tlong ret;\n\n\tret = -EINVAL;\n\tif (plen > PAGE_SIZE)\n\t\tgoto error;\n\n\t/* pull the payload in if one was supplied */\n\tpayload = NULL;\n\tif (_payload) {\n\t\tret = -ENOMEM;\n\t\tpayload = kmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error;\n\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(payload, _payload, plen) != 0)\n\t\t\tgoto error2;\n\t}\n\n\t/* find the target key (which must be writable) */\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_WRITE);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error2;\n\t}\n\n\t/* update the key */\n\tret = key_update(key_ref, payload, plen);\n\n\tkey_ref_put(key_ref);\nerror2:\n\tkfree(payload);\nerror:\n\treturn ret;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 327,
    "critical_vars": [
      "plen"
    ],
    "function": "keyctl_update_key",
    "filename": "linux/CVE-2017-15274/CVE-2017-15274_CWE-476_5649645d725c73df4302428ee4e02c869248b4c5_keyctl.c.diff",
    "function_code": "long keyctl_update_key(key_serial_t id,\n\t\t       const void __user *_payload,\n\t\t       size_t plen)\n{\n\tkey_ref_t key_ref;\n\tvoid *payload;\n\tlong ret;\n\n\tret = -EINVAL;\n\tif (plen > PAGE_SIZE)\n\t\tgoto error;\n\n\t/* pull the payload in if one was supplied */\n\tpayload = NULL;\n\tif (plen) {\n\t\tret = -ENOMEM;\n\t\tpayload = kmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error;\n\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(payload, _payload, plen) != 0)\n\t\t\tgoto error2;\n\t}\n\n\t/* find the target key (which must be writable) */\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_WRITE);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error2;\n\t}\n\n\t/* update the key */\n\tret = key_update(key_ref, payload, plen);\n\n\tkey_ref_put(key_ref);\nerror2:\n\tkfree(payload);\nerror:\n\treturn ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 2645,
    "critical_vars": [
      "alt"
    ],
    "function": "sd_isoc_init",
    "filename": "linux/CVE-2020-11668/CVE-2020-11668_CWE-476_a246b4d547708f33ff4d4b9a7a5dbac741dc89d8_xirlink_cit.c.diff",
    "function_code": "static int sd_isoc_init(struct gspca_dev *gspca_dev)\n{\n\tstruct usb_host_interface *alt;\n\tint max_packet_size;\n\n\tswitch (gspca_dev->pixfmt.width) {\n\tcase 160:\n\t\tmax_packet_size = 450;\n\t\tbreak;\n\tcase 176:\n\t\tmax_packet_size = 600;\n\t\tbreak;\n\tdefault:\n\t\tmax_packet_size = 1022;\n\t\tbreak;\n\t}\n\n\t/* Start isoc bandwidth \"negotiation\" at max isoc bandwidth */\n\talt = &gspca_dev->dev->actconfig->intf_cache[0]->altsetting[1];\n\talt->endpoint[0].desc.wMaxPacketSize = cpu_to_le16(max_packet_size);\n\n\treturn 0;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 2648,
    "critical_vars": [
      "intfc"
    ],
    "function": "sd_isoc_init",
    "filename": "linux/CVE-2020-11668/CVE-2020-11668_CWE-476_a246b4d547708f33ff4d4b9a7a5dbac741dc89d8_xirlink_cit.c.diff",
    "function_code": "static int sd_isoc_init(struct gspca_dev *gspca_dev)\n{\n\tstruct usb_interface_cache *intfc;\n\tstruct usb_host_interface *alt;\n\tint max_packet_size;\n\n\tswitch (gspca_dev->pixfmt.width) {\n\tcase 160:\n\t\tmax_packet_size = 450;\n\t\tbreak;\n\tcase 176:\n\t\tmax_packet_size = 600;\n\t\tbreak;\n\tdefault:\n\t\tmax_packet_size = 1022;\n\t\tbreak;\n\t}\n\n\tintfc = gspca_dev->dev->actconfig->intf_cache[0];\n\n\tif (intfc->num_altsetting < 2)\n\t\treturn -ENODEV;\n\n\talt = &intfc->altsetting[1];\n\n\tif (alt->desc.bNumEndpoints < 1)\n\t\treturn -ENODEV;\n\n\t/* Start isoc bandwidth \"negotiation\" at max isoc bandwidth */\n\talt->endpoint[0].desc.wMaxPacketSize = cpu_to_le16(max_packet_size);\n\n\treturn 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 264,
    "critical_vars": [
      "ax25->sk"
    ],
    "function": "ax25_disconnect",
    "filename": "linux/CVE-2022-1205/CVE-2022-1205_CWE-476_fc6d01ff9ef03b66d4a3a23b46fc3c3d8cf92009_ax25_subr.c.diff",
    "function_code": "void ax25_disconnect(ax25_cb *ax25, int reason)\n{\n\tax25_clear_queues(ax25);\n\n\tif (!ax25->sk || !sock_flag(ax25->sk, SOCK_DESTROY))\n\t\tax25_stop_heartbeat(ax25);\n\tax25_stop_t1timer(ax25);\n\tax25_stop_t2timer(ax25);\n\tax25_stop_t3timer(ax25);\n\tax25_stop_idletimer(ax25);\n\n\tax25->state = AX25_STATE_0;\n\n\tax25_link_failed(ax25, reason);\n\n\tif (ax25->sk != NULL) {\n\t\tlocal_bh_disable();\n\t\tbh_lock_sock(ax25->sk);\n\t\tax25->sk->sk_state     = TCP_CLOSE;\n\t\tax25->sk->sk_err       = reason;\n\t\tax25->sk->sk_shutdown |= SEND_SHUTDOWN;\n\t\tif (!sock_flag(ax25->sk, SOCK_DEAD)) {\n\t\t\tax25->sk->sk_state_change(ax25->sk);\n\t\t\tsock_set_flag(ax25->sk, SOCK_DEAD);\n\t\t}\n\t\tbh_unlock_sock(ax25->sk);\n\t\tlocal_bh_enable();\n\t}\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 264,
    "critical_vars": [
      "reason"
    ],
    "function": "ax25_disconnect",
    "filename": "linux/CVE-2022-1205/CVE-2022-1205_CWE-476_fc6d01ff9ef03b66d4a3a23b46fc3c3d8cf92009_ax25_subr.c.diff",
    "function_code": "void ax25_disconnect(ax25_cb *ax25, int reason)\n{\n\tax25_clear_queues(ax25);\n\n\tif (reason == ENETUNREACH) {\n\t\tdel_timer_sync(&ax25->timer);\n\t\tdel_timer_sync(&ax25->t1timer);\n\t\tdel_timer_sync(&ax25->t2timer);\n\t\tdel_timer_sync(&ax25->t3timer);\n\t\tdel_timer_sync(&ax25->idletimer);\n\t} else {\n\t\tif (!ax25->sk || !sock_flag(ax25->sk, SOCK_DESTROY))\n\t\t\tax25_stop_heartbeat(ax25);\n\t\tax25_stop_t1timer(ax25);\n\t\tax25_stop_t2timer(ax25);\n\t\tax25_stop_t3timer(ax25);\n\t\tax25_stop_idletimer(ax25);\n\t}\n\n\tax25->state = AX25_STATE_0;\n\n\tax25_link_failed(ax25, reason);\n\n\tif (ax25->sk != NULL) {\n\t\tlocal_bh_disable();\n\t\tbh_lock_sock(ax25->sk);\n\t\tax25->sk->sk_state     = TCP_CLOSE;\n\t\tax25->sk->sk_err       = reason;\n\t\tax25->sk->sk_shutdown |= SEND_SHUTDOWN;\n\t\tif (!sock_flag(ax25->sk, SOCK_DEAD)) {\n\t\t\tax25->sk->sk_state_change(ax25->sk);\n\t\t\tsock_set_flag(ax25->sk, SOCK_DEAD);\n\t\t}\n\t\tbh_unlock_sock(ax25->sk);\n\t\tlocal_bh_enable();\n\t}\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 92,
    "critical_vars": [
      "s->ax25_dev"
    ],
    "function": "ax25_kill_by_device",
    "filename": "linux/CVE-2022-1205/CVE-2022-1205_CWE-476_fc6d01ff9ef03b66d4a3a23b46fc3c3d8cf92009_af_ax25.c.diff",
    "function_code": "static void ax25_kill_by_device(struct net_device *dev)\n{\n\tax25_dev *ax25_dev;\n\tax25_cb *s;\n\tstruct sock *sk;\n\n\tif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\n\t\treturn;\n\n\tspin_lock_bh(&ax25_list_lock);\nagain:\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->ax25_dev == ax25_dev) {\n\t\t\tsk = s->sk;\n\t\t\tif (!sk) {\n\t\t\t\tspin_unlock_bh(&ax25_list_lock);\n\t\t\t\ts->ax25_dev = NULL;\n\t\t\t\tax25_disconnect(s, ENETUNREACH);\n\t\t\t\tspin_lock_bh(&ax25_list_lock);\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tsock_hold(sk);\n\t\t\tspin_unlock_bh(&ax25_list_lock);\n\t\t\tlock_sock(sk);\n\t\t\ts->ax25_dev = NULL;\n\t\t\tif (sk->sk_socket) {\n\t\t\t\tdev_put_track(ax25_dev->dev, &ax25_dev->dev_tracker);\n\t\t\t\tax25_dev_put(ax25_dev);\n\t\t\t}\n\t\t\tax25_disconnect(s, ENETUNREACH);\n\t\t\trelease_sock(sk);\n\t\t\tspin_lock_bh(&ax25_list_lock);\n\t\t\tsock_put(sk);\n\t\t\t/* The entry could have been deleted from the\n\t\t\t * list meanwhile and thus the next pointer is\n\t\t\t * no longer valid.  Play it safe and restart\n\t\t\t * the scan.  Forward progress is ensured\n\t\t\t * because we set s->ax25_dev to NULL and we\n\t\t\t * are never passed a NULL 'dev' argument.\n\t\t\t */\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock_bh(&ax25_list_lock);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 93,
    "critical_vars": [
      "s->ax25_dev"
    ],
    "function": "ax25_kill_by_device",
    "filename": "linux/CVE-2022-1205/CVE-2022-1205_CWE-476_fc6d01ff9ef03b66d4a3a23b46fc3c3d8cf92009_af_ax25.c.diff",
    "function_code": "static void ax25_kill_by_device(struct net_device *dev)\n{\n\tax25_dev *ax25_dev;\n\tax25_cb *s;\n\tstruct sock *sk;\n\n\tif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\n\t\treturn;\n\n\tspin_lock_bh(&ax25_list_lock);\nagain:\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->ax25_dev == ax25_dev) {\n\t\t\tsk = s->sk;\n\t\t\tif (!sk) {\n\t\t\t\tspin_unlock_bh(&ax25_list_lock);\n\t\t\t\tax25_disconnect(s, ENETUNREACH);\n\t\t\t\ts->ax25_dev = NULL;\n\t\t\t\tspin_lock_bh(&ax25_list_lock);\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tsock_hold(sk);\n\t\t\tspin_unlock_bh(&ax25_list_lock);\n\t\t\tlock_sock(sk);\n\t\t\tax25_disconnect(s, ENETUNREACH);\n\t\t\ts->ax25_dev = NULL;\n\t\t\tif (sk->sk_socket) {\n\t\t\t\tdev_put_track(ax25_dev->dev, &ax25_dev->dev_tracker);\n\t\t\t\tax25_dev_put(ax25_dev);\n\t\t\t}\n\t\t\trelease_sock(sk);\n\t\t\tspin_lock_bh(&ax25_list_lock);\n\t\t\tsock_put(sk);\n\t\t\t/* The entry could have been deleted from the\n\t\t\t * list meanwhile and thus the next pointer is\n\t\t\t * no longer valid.  Play it safe and restart\n\t\t\t * the scan.  Forward progress is ensured\n\t\t\t * because we set s->ax25_dev to NULL and we\n\t\t\t * are never passed a NULL 'dev' argument.\n\t\t\t */\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock_bh(&ax25_list_lock);\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 2057,
    "critical_vars": [
      "skb"
    ],
    "function": "ieee80211_parse_tx_radiotap",
    "filename": "linux/CVE-2021-38206/CVE-2021-38206_CWE-476_bddc0c411a45d3718ac535a070f349be8eca8d48_tx.c.diff",
    "function_code": "bool ieee80211_parse_tx_radiotap(struct sk_buff *skb,\n\t\t\t\t struct net_device *dev)\n{\n\tstruct ieee80211_local *local = wdev_priv(dev->ieee80211_ptr);\n\tstruct ieee80211_radiotap_iterator iterator;\n\tstruct ieee80211_radiotap_header *rthdr =\n\t\t(struct ieee80211_radiotap_header *) skb->data;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tint ret = ieee80211_radiotap_iterator_init(&iterator, rthdr, skb->len,\n\t\t\t\t\t\t   NULL);\n\tu16 txflags;\n\tu16 rate = 0;\n\tbool rate_found = false;\n\tu8 rate_retries = 0;\n\tu16 rate_flags = 0;\n\tu8 mcs_known, mcs_flags, mcs_bw;\n\tu16 vht_known;\n\tu8 vht_mcs = 0, vht_nss = 0;\n\tint i;\n\n\tif (!ieee80211_validate_radiotap_len(skb))\n\t\treturn false;\n\n\tinfo->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT |\n\t\t       IEEE80211_TX_CTL_DONTFRAG;\n\n\t/*\n\t * for every radiotap entry that is present\n\t * (ieee80211_radiotap_iterator_next returns -ENOENT when no more\n\t * entries present, or -EINVAL on error)\n\t */\n\n\twhile (!ret) {\n\t\tret = ieee80211_radiotap_iterator_next(&iterator);\n\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\t/* see if this argument is something we can use */\n\t\tswitch (iterator.this_arg_index) {\n\t\t/*\n\t\t * You must take care when dereferencing iterator.this_arg\n\t\t * for multibyte types... the pointer is not aligned.  Use\n\t\t * get_unaligned((type *)iterator.this_arg) to dereference\n\t\t * iterator.this_arg for type \"type\" safely on all arches.\n\t\t*/\n\t\tcase IEEE80211_RADIOTAP_FLAGS:\n\t\t\tif (*iterator.this_arg & IEEE80211_RADIOTAP_F_FCS) {\n\t\t\t\t/*\n\t\t\t\t * this indicates that the skb we have been\n\t\t\t\t * handed has the 32-bit FCS CRC at the end...\n\t\t\t\t * we should react to that by snipping it off\n\t\t\t\t * because it will be recomputed and added\n\t\t\t\t * on transmission\n\t\t\t\t */\n\t\t\t\tif (skb->len < (iterator._max_length + FCS_LEN))\n\t\t\t\t\treturn false;\n\n\t\t\t\tskb_trim(skb, skb->len - FCS_LEN);\n\t\t\t}\n\t\t\tif (*iterator.this_arg & IEEE80211_RADIOTAP_F_WEP)\n\t\t\t\tinfo->flags &= ~IEEE80211_TX_INTFL_DONT_ENCRYPT;\n\t\t\tif (*iterator.this_arg & IEEE80211_RADIOTAP_F_FRAG)\n\t\t\t\tinfo->flags &= ~IEEE80211_TX_CTL_DONTFRAG;\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_TX_FLAGS:\n\t\t\ttxflags = get_unaligned_le16(iterator.this_arg);\n\t\t\tif (txflags & IEEE80211_RADIOTAP_F_TX_NOACK)\n\t\t\t\tinfo->flags |= IEEE80211_TX_CTL_NO_ACK;\n\t\t\tif (txflags & IEEE80211_RADIOTAP_F_TX_NOSEQNO)\n\t\t\t\tinfo->control.flags |= IEEE80211_TX_CTRL_NO_SEQNO;\n\t\t\tif (txflags & IEEE80211_RADIOTAP_F_TX_ORDER)\n\t\t\t\tinfo->control.flags |=\n\t\t\t\t\tIEEE80211_TX_CTRL_DONT_REORDER;\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_RATE:\n\t\t\trate = *iterator.this_arg;\n\t\t\trate_flags = 0;\n\t\t\trate_found = true;\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_DATA_RETRIES:\n\t\t\trate_retries = *iterator.this_arg;\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_MCS:\n\t\t\tmcs_known = iterator.this_arg[0];\n\t\t\tmcs_flags = iterator.this_arg[1];\n\t\t\tif (!(mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_MCS))\n\t\t\t\tbreak;\n\n\t\t\trate_found = true;\n\t\t\trate = iterator.this_arg[2];\n\t\t\trate_flags = IEEE80211_TX_RC_MCS;\n\n\t\t\tif (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_GI &&\n\t\t\t    mcs_flags & IEEE80211_RADIOTAP_MCS_SGI)\n\t\t\t\trate_flags |= IEEE80211_TX_RC_SHORT_GI;\n\n\t\t\tmcs_bw = mcs_flags & IEEE80211_RADIOTAP_MCS_BW_MASK;\n\t\t\tif (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_BW &&\n\t\t\t    mcs_bw == IEEE80211_RADIOTAP_MCS_BW_40)\n\t\t\t\trate_flags |= IEEE80211_TX_RC_40_MHZ_WIDTH;\n\n\t\t\tif (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_FEC &&\n\t\t\t    mcs_flags & IEEE80211_RADIOTAP_MCS_FEC_LDPC)\n\t\t\t\tinfo->flags |= IEEE80211_TX_CTL_LDPC;\n\n\t\t\tif (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_STBC) {\n\t\t\t\tu8 stbc = u8_get_bits(mcs_flags,\n\t\t\t\t\t\t      IEEE80211_RADIOTAP_MCS_STBC_MASK);\n\n\t\t\t\tinfo->flags |=\n\t\t\t\t\tu32_encode_bits(stbc,\n\t\t\t\t\t\t\tIEEE80211_TX_CTL_STBC);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_VHT:\n\t\t\tvht_known = get_unaligned_le16(iterator.this_arg);\n\t\t\trate_found = true;\n\n\t\t\trate_flags = IEEE80211_TX_RC_VHT_MCS;\n\t\t\tif ((vht_known & IEEE80211_RADIOTAP_VHT_KNOWN_GI) &&\n\t\t\t    (iterator.this_arg[2] &\n\t\t\t     IEEE80211_RADIOTAP_VHT_FLAG_SGI))\n\t\t\t\trate_flags |= IEEE80211_TX_RC_SHORT_GI;\n\t\t\tif (vht_known &\n\t\t\t    IEEE80211_RADIOTAP_VHT_KNOWN_BANDWIDTH) {\n\t\t\t\tif (iterator.this_arg[3] == 1)\n\t\t\t\t\trate_flags |=\n\t\t\t\t\t\tIEEE80211_TX_RC_40_MHZ_WIDTH;\n\t\t\t\telse if (iterator.this_arg[3] == 4)\n\t\t\t\t\trate_flags |=\n\t\t\t\t\t\tIEEE80211_TX_RC_80_MHZ_WIDTH;\n\t\t\t\telse if (iterator.this_arg[3] == 11)\n\t\t\t\t\trate_flags |=\n\t\t\t\t\t\tIEEE80211_TX_RC_160_MHZ_WIDTH;\n\t\t\t}\n\n\t\t\tvht_mcs = iterator.this_arg[4] >> 4;\n\t\t\tvht_nss = iterator.this_arg[4] & 0xF;\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Please update the file\n\t\t * Documentation/networking/mac80211-injection.rst\n\t\t * when parsing new fields here.\n\t\t */\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret != -ENOENT) /* ie, if we didn't simply run out of fields */\n\t\treturn false;\n\n\tif (rate_found) {\n\t\tstruct ieee80211_supported_band *sband =\n\t\t\tlocal->hw.wiphy->bands[info->band];\n\n\t\tinfo->control.flags |= IEEE80211_TX_CTRL_RATE_INJECT;\n\n\t\tfor (i = 0; i < IEEE80211_TX_MAX_RATES; i++) {\n\t\t\tinfo->control.rates[i].idx = -1;\n\t\t\tinfo->control.rates[i].flags = 0;\n\t\t\tinfo->control.rates[i].count = 0;\n\t\t}\n\n\t\tif (rate_flags & IEEE80211_TX_RC_MCS) {\n\t\t\tinfo->control.rates[0].idx = rate;\n\t\t} else if (rate_flags & IEEE80211_TX_RC_VHT_MCS) {\n\t\t\tieee80211_rate_set_vht(info->control.rates, vht_mcs,\n\t\t\t\t\t       vht_nss);\n\t\t} else if (sband) {\n\t\t\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\t\t\tif (rate * 5 != sband->bitrates[i].bitrate)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tinfo->control.rates[0].idx = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (info->control.rates[0].idx < 0)\n\t\t\tinfo->control.flags &= ~IEEE80211_TX_CTRL_RATE_INJECT;\n\n\t\tinfo->control.rates[0].flags = rate_flags;\n\t\tinfo->control.rates[0].count = min_t(u8, rate_retries + 1,\n\t\t\t\t\t\t     local->hw.max_rate_tries);\n\t}\n\n\treturn true;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 2240,
    "critical_vars": [
      "skb",
      "dev"
    ],
    "function": "ieee80211_monitor_start_xmit",
    "filename": "linux/CVE-2021-38206/CVE-2021-38206_CWE-476_bddc0c411a45d3718ac535a070f349be8eca8d48_tx.c.diff",
    "function_code": "netdev_tx_t ieee80211_monitor_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t struct net_device *dev)\n{\n\tstruct ieee80211_local *local = wdev_priv(dev->ieee80211_ptr);\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr;\n\tstruct ieee80211_sub_if_data *tmp_sdata, *sdata;\n\tstruct cfg80211_chan_def *chandef;\n\tu16 len_rthdr;\n\tint hdrlen;\n\n\tmemset(info, 0, sizeof(*info));\n\tinfo->flags = IEEE80211_TX_CTL_REQ_TX_STATUS |\n\t\t      IEEE80211_TX_CTL_INJECTED;\n\n\t/* Sanity-check and process the injection radiotap header */\n\tif (!ieee80211_parse_tx_radiotap(skb, dev))\n\t\tgoto fail;\n\n\t/* we now know there is a radiotap header with a length we can use */\n\tlen_rthdr = ieee80211_get_radiotap_len(skb->data);\n\n\t/*\n\t * fix up the pointers accounting for the radiotap\n\t * header still being in there.  We are being given\n\t * a precooked IEEE80211 header so no need for\n\t * normal processing\n\t */\n\tskb_set_mac_header(skb, len_rthdr);\n\t/*\n\t * these are just fixed to the end of the rt area since we\n\t * don't have any better information and at this point, nobody cares\n\t */\n\tskb_set_network_header(skb, len_rthdr);\n\tskb_set_transport_header(skb, len_rthdr);\n\n\tif (skb->len < len_rthdr + 2)\n\t\tgoto fail;\n\n\thdr = (struct ieee80211_hdr *)(skb->data + len_rthdr);\n\thdrlen = ieee80211_hdrlen(hdr->frame_control);\n\n\tif (skb->len < len_rthdr + hdrlen)\n\t\tgoto fail;\n\n\t/*\n\t * Initialize skb->protocol if the injected frame is a data frame\n\t * carrying a rfc1042 header\n\t */\n\tif (ieee80211_is_data(hdr->frame_control) &&\n\t    skb->len >= len_rthdr + hdrlen + sizeof(rfc1042_header) + 2) {\n\t\tu8 *payload = (u8 *)hdr + hdrlen;\n\n\t\tif (ether_addr_equal(payload, rfc1042_header))\n\t\t\tskb->protocol = cpu_to_be16((payload[6] << 8) |\n\t\t\t\t\t\t    payload[7]);\n\t}\n\n\trcu_read_lock();\n\n\t/*\n\t * We process outgoing injected frames that have a local address\n\t * we handle as though they are non-injected frames.\n\t * This code here isn't entirely correct, the local MAC address\n\t * isn't always enough to find the interface to use; for proper\n\t * VLAN support we have an nl80211-based mechanism.\n\t *\n\t * This is necessary, for example, for old hostapd versions that\n\t * don't use nl80211-based management TX/RX.\n\t */\n\tsdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\n\tlist_for_each_entry_rcu(tmp_sdata, &local->interfaces, list) {\n\t\tif (!ieee80211_sdata_running(tmp_sdata))\n\t\t\tcontinue;\n\t\tif (tmp_sdata->vif.type == NL80211_IFTYPE_MONITOR ||\n\t\t    tmp_sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\n\t\t\tcontinue;\n\t\tif (ether_addr_equal(tmp_sdata->vif.addr, hdr->addr2)) {\n\t\t\tsdata = tmp_sdata;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\n\tif (!chanctx_conf) {\n\t\ttmp_sdata = rcu_dereference(local->monitor_sdata);\n\t\tif (tmp_sdata)\n\t\t\tchanctx_conf =\n\t\t\t\trcu_dereference(tmp_sdata->vif.chanctx_conf);\n\t}\n\n\tif (chanctx_conf)\n\t\tchandef = &chanctx_conf->def;\n\telse if (!local->use_chanctx)\n\t\tchandef = &local->_oper_chandef;\n\telse\n\t\tgoto fail_rcu;\n\n\t/*\n\t * Frame injection is not allowed if beaconing is not allowed\n\t * or if we need radar detection. Beaconing is usually not allowed when\n\t * the mode or operation (Adhoc, AP, Mesh) does not support DFS.\n\t * Passive scan is also used in world regulatory domains where\n\t * your country is not known and as such it should be treated as\n\t * NO TX unless the channel is explicitly allowed in which case\n\t * your current regulatory domain would not have the passive scan\n\t * flag.\n\t *\n\t * Since AP mode uses monitor interfaces to inject/TX management\n\t * frames we can make AP mode the exception to this rule once it\n\t * supports radar detection as its implementation can deal with\n\t * radar detection by itself. We can do that later by adding a\n\t * monitor flag interfaces used for AP support.\n\t */\n\tif (!cfg80211_reg_can_beacon(local->hw.wiphy, chandef,\n\t\t\t\t     sdata->vif.type))\n\t\tgoto fail_rcu;\n\n\tinfo->band = chandef->chan->band;\n\n\t/* Initialize skb->priority according to frame type and TID class,\n\t * with respect to the sub interface that the frame will actually\n\t * be transmitted on. If the DONT_REORDER flag is set, the original\n\t * skb-priority is preserved to assure frames injected with this\n\t * flag are not reordered relative to each other.\n\t */\n\tieee80211_select_queue_80211(sdata, skb, hdr);\n\tskb_set_queue_mapping(skb, ieee80211_ac_from_tid(skb->priority));\n\n\t/* remove the injection radiotap header */\n\tskb_pull(skb, len_rthdr);\n\n\tieee80211_xmit(sdata, NULL, skb);\n\trcu_read_unlock();\n\n\treturn NETDEV_TX_OK;\n\nfail_rcu:\n\trcu_read_unlock();\nfail:\n\tdev_kfree_skb(skb);\n\treturn NETDEV_TX_OK; /* meaning, we dealt with the skb */\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 2252,
    "critical_vars": [
      "skb"
    ],
    "function": "ieee80211_monitor_start_xmit",
    "filename": "linux/CVE-2021-38206/CVE-2021-38206_CWE-476_bddc0c411a45d3718ac535a070f349be8eca8d48_tx.c.diff",
    "function_code": "netdev_tx_t ieee80211_monitor_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t struct net_device *dev)\n{\n\tstruct ieee80211_local *local = wdev_priv(dev->ieee80211_ptr);\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr;\n\tstruct ieee80211_sub_if_data *tmp_sdata, *sdata;\n\tstruct cfg80211_chan_def *chandef;\n\tu16 len_rthdr;\n\tint hdrlen;\n\n\tmemset(info, 0, sizeof(*info));\n\tinfo->flags = IEEE80211_TX_CTL_REQ_TX_STATUS |\n\t\t      IEEE80211_TX_CTL_INJECTED;\n\n\t/* Sanity-check the length of the radiotap header */\n\tif (!ieee80211_validate_radiotap_len(skb))\n\t\tgoto fail;\n\n\t/* we now know there is a radiotap header with a length we can use */\n\tlen_rthdr = ieee80211_get_radiotap_len(skb->data);\n\n\t/*\n\t * fix up the pointers accounting for the radiotap\n\t * header still being in there.  We are being given\n\t * a precooked IEEE80211 header so no need for\n\t * normal processing\n\t */\n\tskb_set_mac_header(skb, len_rthdr);\n\t/*\n\t * these are just fixed to the end of the rt area since we\n\t * don't have any better information and at this point, nobody cares\n\t */\n\tskb_set_network_header(skb, len_rthdr);\n\tskb_set_transport_header(skb, len_rthdr);\n\n\tif (skb->len < len_rthdr + 2)\n\t\tgoto fail;\n\n\thdr = (struct ieee80211_hdr *)(skb->data + len_rthdr);\n\thdrlen = ieee80211_hdrlen(hdr->frame_control);\n\n\tif (skb->len < len_rthdr + hdrlen)\n\t\tgoto fail;\n\n\t/*\n\t * Initialize skb->protocol if the injected frame is a data frame\n\t * carrying a rfc1042 header\n\t */\n\tif (ieee80211_is_data(hdr->frame_control) &&\n\t    skb->len >= len_rthdr + hdrlen + sizeof(rfc1042_header) + 2) {\n\t\tu8 *payload = (u8 *)hdr + hdrlen;\n\n\t\tif (ether_addr_equal(payload, rfc1042_header))\n\t\t\tskb->protocol = cpu_to_be16((payload[6] << 8) |\n\t\t\t\t\t\t    payload[7]);\n\t}\n\n\trcu_read_lock();\n\n\t/*\n\t * We process outgoing injected frames that have a local address\n\t * we handle as though they are non-injected frames.\n\t * This code here isn't entirely correct, the local MAC address\n\t * isn't always enough to find the interface to use; for proper\n\t * VLAN support we have an nl80211-based mechanism.\n\t *\n\t * This is necessary, for example, for old hostapd versions that\n\t * don't use nl80211-based management TX/RX.\n\t */\n\tsdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\n\tlist_for_each_entry_rcu(tmp_sdata, &local->interfaces, list) {\n\t\tif (!ieee80211_sdata_running(tmp_sdata))\n\t\t\tcontinue;\n\t\tif (tmp_sdata->vif.type == NL80211_IFTYPE_MONITOR ||\n\t\t    tmp_sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\n\t\t\tcontinue;\n\t\tif (ether_addr_equal(tmp_sdata->vif.addr, hdr->addr2)) {\n\t\t\tsdata = tmp_sdata;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\n\tif (!chanctx_conf) {\n\t\ttmp_sdata = rcu_dereference(local->monitor_sdata);\n\t\tif (tmp_sdata)\n\t\t\tchanctx_conf =\n\t\t\t\trcu_dereference(tmp_sdata->vif.chanctx_conf);\n\t}\n\n\tif (chanctx_conf)\n\t\tchandef = &chanctx_conf->def;\n\telse if (!local->use_chanctx)\n\t\tchandef = &local->_oper_chandef;\n\telse\n\t\tgoto fail_rcu;\n\n\t/*\n\t * Frame injection is not allowed if beaconing is not allowed\n\t * or if we need radar detection. Beaconing is usually not allowed when\n\t * the mode or operation (Adhoc, AP, Mesh) does not support DFS.\n\t * Passive scan is also used in world regulatory domains where\n\t * your country is not known and as such it should be treated as\n\t * NO TX unless the channel is explicitly allowed in which case\n\t * your current regulatory domain would not have the passive scan\n\t * flag.\n\t *\n\t * Since AP mode uses monitor interfaces to inject/TX management\n\t * frames we can make AP mode the exception to this rule once it\n\t * supports radar detection as its implementation can deal with\n\t * radar detection by itself. We can do that later by adding a\n\t * monitor flag interfaces used for AP support.\n\t */\n\tif (!cfg80211_reg_can_beacon(local->hw.wiphy, chandef,\n\t\t\t\t     sdata->vif.type))\n\t\tgoto fail_rcu;\n\n\tinfo->band = chandef->chan->band;\n\n\t/* Initialize skb->priority according to frame type and TID class,\n\t * with respect to the sub interface that the frame will actually\n\t * be transmitted on. If the DONT_REORDER flag is set, the original\n\t * skb-priority is preserved to assure frames injected with this\n\t * flag are not reordered relative to each other.\n\t */\n\tieee80211_select_queue_80211(sdata, skb, hdr);\n\tskb_set_queue_mapping(skb, ieee80211_ac_from_tid(skb->priority));\n\n\t/*\n\t * Process the radiotap header. This will now take into account the\n\t * selected chandef above to accurately set injection rates and\n\t * retransmissions.\n\t */\n\tif (!ieee80211_parse_tx_radiotap(skb, dev))\n\t\tgoto fail_rcu;\n\n\t/* remove the injection radiotap header */\n\tskb_pull(skb, len_rthdr);\n\n\tieee80211_xmit(sdata, NULL, skb);\n\trcu_read_unlock();\n\n\treturn NETDEV_TX_OK;\n\nfail_rcu:\n\trcu_read_unlock();\nfail:\n\tdev_kfree_skb(skb);\n\treturn NETDEV_TX_OK; /* meaning, we dealt with the skb */\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 895,
    "critical_vars": [
      "ctx.match_data.cmp"
    ],
    "function": "keyring_search",
    "filename": "linux/CVE-2017-2647/CVE-2017-2647_CWE-476_c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81_keyring.c.diff",
    "function_code": "key_ref_t keyring_search(key_ref_t keyring,\n\t\t\t struct key_type *type,\n\t\t\t const char *description)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= type,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= type->match,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tkey_ref_t key;\n\tint ret;\n\n\tif (!ctx.match_data.cmp)\n\t\treturn ERR_PTR(-ENOKEY);\n\n\tif (type->match_preparse) {\n\t\tret = type->match_preparse(&ctx.match_data);\n\t\tif (ret < 0)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\n\tkey = keyring_search_aux(keyring, &ctx);\n\n\tif (type->match_free)\n\t\ttype->match_free(&ctx.match_data);\n\treturn key;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 186,
    "critical_vars": [
      "err"
    ],
    "function": "hash_accept",
    "filename": "linux/CVE-2016-8646/CVE-2016-8646_CWE-476_4afa5f9617927453ac04b24b584f6c718dfb4f45_algif_hash.c.diff",
    "function_code": "static int hash_accept(struct socket *sock, struct socket *newsock, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct hash_ctx *ctx = ask->private;\n\tstruct ahash_request *req = &ctx->req;\n\tchar state[crypto_ahash_statesize(crypto_ahash_reqtfm(req))];\n\tstruct sock *sk2;\n\tstruct alg_sock *ask2;\n\tstruct hash_ctx *ctx2;\n\tint err;\n\n\terr = crypto_ahash_export(req, state);\n\tif (err)\n\t\treturn err;\n\n\terr = af_alg_accept(ask->parent, newsock);\n\tif (err)\n\t\treturn err;\n\n\tsk2 = newsock->sk;\n\task2 = alg_sk(sk2);\n\tctx2 = ask2->private;\n\tctx2->more = 1;\n\n\terr = crypto_ahash_import(&ctx2->req, state);\n\tif (err) {\n\t\tsock_orphan(sk2);\n\t\tsock_put(sk2);\n\t}\n\n\treturn err;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 184,
    "critical_vars": [
      "more"
    ],
    "function": "hash_accept",
    "filename": "linux/CVE-2016-8646/CVE-2016-8646_CWE-476_4afa5f9617927453ac04b24b584f6c718dfb4f45_algif_hash.c.diff",
    "function_code": "static int hash_accept(struct socket *sock, struct socket *newsock, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct hash_ctx *ctx = ask->private;\n\tstruct ahash_request *req = &ctx->req;\n\tchar state[crypto_ahash_statesize(crypto_ahash_reqtfm(req))];\n\tstruct sock *sk2;\n\tstruct alg_sock *ask2;\n\tstruct hash_ctx *ctx2;\n\tbool more;\n\tint err;\n\n\tlock_sock(sk);\n\tmore = ctx->more;\n\terr = more ? crypto_ahash_export(req, state) : 0;\n\trelease_sock(sk);\n\n\tif (err)\n\t\treturn err;\n\n\terr = af_alg_accept(ask->parent, newsock);\n\tif (err)\n\t\treturn err;\n\n\tsk2 = newsock->sk;\n\task2 = alg_sk(sk2);\n\tctx2 = ask2->private;\n\tctx2->more = more;\n\n\tif (!more)\n\t\treturn err;\n\n\terr = crypto_ahash_import(&ctx2->req, state);\n\tif (err) {\n\t\tsock_orphan(sk2);\n\t\tsock_put(sk2);\n\t}\n\n\treturn err;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 1241,
    "critical_vars": [
      "skb"
    ],
    "function": "ipv4_pktinfo_prepare",
    "filename": "linux/CVE-2017-5970/CVE-2017-5970_CWE-476_34b2cef20f19c87999fff3da4071e66937db9644_ip_sockglue.c.diff",
    "function_code": "void ipv4_pktinfo_prepare(const struct sock *sk, struct sk_buff *skb)\n{\n\tstruct in_pktinfo *pktinfo = PKTINFO_SKB_CB(skb);\n\tbool prepare = (inet_sk(sk)->cmsg_flags & IP_CMSG_PKTINFO) ||\n\t\t       ipv6_sk_rxinfo(sk);\n\n\tif (prepare && skb_rtable(skb)) {\n\t\t/* skb->cb is overloaded: prior to this point it is IP{6}CB\n\t\t * which has interface index (iif) as the first member of the\n\t\t * underlying inet{6}_skb_parm struct. This code then overlays\n\t\t * PKTINFO_SKB_CB and in_pktinfo also has iif as the first\n\t\t * element so the iif is picked up from the prior IPCB. If iif\n\t\t * is the loopback interface, then return the sending interface\n\t\t * (e.g., process binds socket to eth0 for Tx which is\n\t\t * redirected to loopback in the rtable/dst).\n\t\t */\n\t\tif (pktinfo->ipi_ifindex == LOOPBACK_IFINDEX)\n\t\t\tpktinfo->ipi_ifindex = inet_iif(skb);\n\n\t\tpktinfo->ipi_spec_dst.s_addr = fib_compute_spec_dst(skb);\n\t} else {\n\t\tpktinfo->ipi_ifindex = 0;\n\t\tpktinfo->ipi_spec_dst.s_addr = 0;\n\t}\n\tskb_dst_drop(skb);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1245,
    "critical_vars": [
      "skb"
    ],
    "function": "ipv4_pktinfo_prepare",
    "filename": "linux/CVE-2017-5970/CVE-2017-5970_CWE-476_34b2cef20f19c87999fff3da4071e66937db9644_ip_sockglue.c.diff",
    "function_code": "void ipv4_pktinfo_prepare(const struct sock *sk, struct sk_buff *skb)\n{\n\tstruct in_pktinfo *pktinfo = PKTINFO_SKB_CB(skb);\n\tbool prepare = (inet_sk(sk)->cmsg_flags & IP_CMSG_PKTINFO) ||\n\t\t       ipv6_sk_rxinfo(sk);\n\n\tif (prepare && skb_rtable(skb)) {\n\t\t/* skb->cb is overloaded: prior to this point it is IP{6}CB\n\t\t * which has interface index (iif) as the first member of the\n\t\t * underlying inet{6}_skb_parm struct. This code then overlays\n\t\t * PKTINFO_SKB_CB and in_pktinfo also has iif as the first\n\t\t * element so the iif is picked up from the prior IPCB. If iif\n\t\t * is the loopback interface, then return the sending interface\n\t\t * (e.g., process binds socket to eth0 for Tx which is\n\t\t * redirected to loopback in the rtable/dst).\n\t\t */\n\t\tif (pktinfo->ipi_ifindex == LOOPBACK_IFINDEX)\n\t\t\tpktinfo->ipi_ifindex = inet_iif(skb);\n\n\t\tpktinfo->ipi_spec_dst.s_addr = fib_compute_spec_dst(skb);\n\t} else {\n\t\tpktinfo->ipi_ifindex = 0;\n\t\tpktinfo->ipi_spec_dst.s_addr = 0;\n\t}\n\t/* We need to keep the dst for __ip_options_echo()\n\t * We could restrict the test to opt.ts_needtime || opt.srr,\n\t * but the following is good enough as IP options are not often used.\n\t */\n\tif (unlikely(IPCB(skb)->opt.optlen))\n\t\tskb_dst_force(skb);\n\telse\n\t\tskb_dst_drop(skb);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 511,
    "critical_vars": [
      "bit",
      "bitmap->bitmap"
    ],
    "function": "ida_free",
    "filename": "linux/CVE-2023-6915/CVE-2023-6915_CWE-476_af73483f4e8b6f5c68c9aa63257bdd929a9c194a_idr.c.diff",
    "function_code": "void ida_free(struct ida *ida, unsigned int id)\n{\n\tXA_STATE(xas, &ida->xa, id / IDA_BITMAP_BITS);\n\tunsigned bit = id % IDA_BITMAP_BITS;\n\tstruct ida_bitmap *bitmap;\n\tunsigned long flags;\n\n\tif ((int)id < 0)\n\t\treturn;\n\n\txas_lock_irqsave(&xas, flags);\n\tbitmap = xas_load(&xas);\n\n\tif (xa_is_value(bitmap)) {\n\t\tunsigned long v = xa_to_value(bitmap);\n\t\tif (bit >= BITS_PER_XA_VALUE)\n\t\t\tgoto err;\n\t\tif (!(v & (1UL << bit)))\n\t\t\tgoto err;\n\t\tv &= ~(1UL << bit);\n\t\tif (!v)\n\t\t\tgoto delete;\n\t\txas_store(&xas, xa_mk_value(v));\n\t} else {\n\t\tif (!test_bit(bit, bitmap->bitmap))\n\t\t\tgoto err;\n\t\t__clear_bit(bit, bitmap->bitmap);\n\t\txas_set_mark(&xas, XA_FREE_MARK);\n\t\tif (bitmap_empty(bitmap->bitmap, IDA_BITMAP_BITS)) {\n\t\t\tkfree(bitmap);\ndelete:\n\t\t\txas_store(&xas, NULL);\n\t\t}\n\t}\n\txas_unlock_irqrestore(&xas, flags);\n\treturn;\n err:\n\txas_unlock_irqrestore(&xas, flags);\n\tWARN(1, \"ida_free called for id=%d which is not allocated.\\n\", id);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 511,
    "critical_vars": [
      "bitmap",
      "bitmap->bitmap",
      "bit"
    ],
    "function": "ida_free",
    "filename": "linux/CVE-2023-6915/CVE-2023-6915_CWE-476_af73483f4e8b6f5c68c9aa63257bdd929a9c194a_idr.c.diff",
    "function_code": "void ida_free(struct ida *ida, unsigned int id)\n{\n\tXA_STATE(xas, &ida->xa, id / IDA_BITMAP_BITS);\n\tunsigned bit = id % IDA_BITMAP_BITS;\n\tstruct ida_bitmap *bitmap;\n\tunsigned long flags;\n\n\tif ((int)id < 0)\n\t\treturn;\n\n\txas_lock_irqsave(&xas, flags);\n\tbitmap = xas_load(&xas);\n\n\tif (xa_is_value(bitmap)) {\n\t\tunsigned long v = xa_to_value(bitmap);\n\t\tif (bit >= BITS_PER_XA_VALUE)\n\t\t\tgoto err;\n\t\tif (!(v & (1UL << bit)))\n\t\t\tgoto err;\n\t\tv &= ~(1UL << bit);\n\t\tif (!v)\n\t\t\tgoto delete;\n\t\txas_store(&xas, xa_mk_value(v));\n\t} else {\n\t\tif (!bitmap || !test_bit(bit, bitmap->bitmap))\n\t\t\tgoto err;\n\t\t__clear_bit(bit, bitmap->bitmap);\n\t\txas_set_mark(&xas, XA_FREE_MARK);\n\t\tif (bitmap_empty(bitmap->bitmap, IDA_BITMAP_BITS)) {\n\t\t\tkfree(bitmap);\ndelete:\n\t\t\txas_store(&xas, NULL);\n\t\t}\n\t}\n\txas_unlock_irqrestore(&xas, flags);\n\treturn;\n err:\n\txas_unlock_irqrestore(&xas, flags);\n\tWARN(1, \"ida_free called for id=%d which is not allocated.\\n\", id);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 795,
    "critical_vars": [
      "len"
    ],
    "function": "skcipher_accept_parent",
    "filename": "linux/CVE-2015-8970/CVE-2015-8970_CWE-476_dd504589577d8e8e70f51f997ad487a4cb6c026f_algif_skcipher.c.diff",
    "function_code": "static int skcipher_accept_parent(void *private, struct sock *sk)\n{\n\tstruct skcipher_ctx *ctx;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tunsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(private);\n\n\tctx = sock_kmalloc(sk, len, GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(private),\n\t\t\t       GFP_KERNEL);\n\tif (!ctx->iv) {\n\t\tsock_kfree_s(sk, ctx, len);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(ctx->iv, 0, crypto_skcipher_ivsize(private));\n\n\tINIT_LIST_HEAD(&ctx->tsgl);\n\tctx->len = len;\n\tctx->used = 0;\n\tctx->more = 0;\n\tctx->merge = 0;\n\tctx->enc = 0;\n\tatomic_set(&ctx->inflight, 0);\n\taf_alg_init_completion(&ctx->completion);\n\n\task->private = ctx;\n\n\tskcipher_request_set_tfm(&ctx->req, private);\n\tskcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t      af_alg_complete, &ctx->completion);\n\n\tsk->sk_destruct = skcipher_sock_destruct;\n\n\treturn 0;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 462,
    "critical_vars": [
      "port->serio"
    ],
    "function": "i8042_stop",
    "filename": "linux/CVE-2017-18079/CVE-2017-18079_CWE-476_340d394a789518018f834ff70f7534fc463d3226_i8042.c.diff",
    "function_code": "static void i8042_stop(struct serio *serio)\n{\n\tstruct i8042_port *port = serio->port_data;\n\n\tport->exists = false;\n\n\t/*\n\t * We synchronize with both AUX and KBD IRQs because there is\n\t * a (very unlikely) chance that AUX IRQ is raised for KBD port\n\t * and vice versa.\n\t */\n\tsynchronize_irq(I8042_AUX_IRQ);\n\tsynchronize_irq(I8042_KBD_IRQ);\n\tport->serio = NULL;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 899,
    "critical_vars": [
      "walk",
      "net"
    ],
    "function": "xfrm_dump_sa_done",
    "filename": "linux/CVE-2023-3106/CVE-2023-3106_CWE-476_1ba5bf993c6a3142e18e68ea6452b347f9cb5635_xfrm_user.c.diff",
    "function_code": "static int xfrm_dump_sa_done(struct netlink_callback *cb)\n{\n\tstruct xfrm_state_walk *walk = (struct xfrm_state_walk *) &cb->args[1];\n\tstruct sock *sk = cb->skb->sk;\n\tstruct net *net = sock_net(sk);\n\n\txfrm_state_walk_done(walk, net);\n\treturn 0;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 2429,
    "critical_vars": [
      "error"
    ],
    "function": "expand_downwards",
    "filename": "linux/CVE-2019-9213/CVE-2019-9213_CWE-476_0a1d52994d440e21def1c2174932410b4f2a98a1_mmap.c.diff",
    "function_code": "int expand_downwards(struct vm_area_struct *vma,\n\t\t\t\t   unsigned long address)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct vm_area_struct *prev;\n\tint error;\n\n\taddress &= PAGE_MASK;\n\terror = security_mmap_addr(address);\n\tif (error)\n\t\treturn error;\n\n\t/* Enforce stack_guard_gap */\n\tprev = vma->vm_prev;\n\t/* Check that both stack segments have the same anon_vma? */\n\tif (prev && !(prev->vm_flags & VM_GROWSDOWN) &&\n\t\t\t(prev->vm_flags & (VM_WRITE|VM_READ|VM_EXEC))) {\n\t\tif (address - prev->vm_end < stack_guard_gap)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* We must make sure the anon_vma is allocated. */\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\treturn -ENOMEM;\n\n\t/*\n\t * vma->vm_start/vm_end cannot change under us because the caller\n\t * is required to hold the mmap_sem in read mode.  We need the\n\t * anon_vma lock to serialize against concurrent expand_stacks.\n\t */\n\tanon_vma_lock_write(vma->anon_vma);\n\n\t/* Somebody else might have raced and expanded it already */\n\tif (address < vma->vm_start) {\n\t\tunsigned long size, grow;\n\n\t\tsize = vma->vm_end - address;\n\t\tgrow = (vma->vm_start - address) >> PAGE_SHIFT;\n\n\t\terror = -ENOMEM;\n\t\tif (grow <= vma->vm_pgoff) {\n\t\t\terror = acct_stack_growth(vma, size, grow);\n\t\t\tif (!error) {\n\t\t\t\t/*\n\t\t\t\t * vma_gap_update() doesn't support concurrent\n\t\t\t\t * updates, but we only hold a shared mmap_sem\n\t\t\t\t * lock here, so we need to protect against\n\t\t\t\t * concurrent vma expansions.\n\t\t\t\t * anon_vma_lock_write() doesn't help here, as\n\t\t\t\t * we don't guarantee that all growable vmas\n\t\t\t\t * in a mm share the same root anon vma.\n\t\t\t\t * So, we reuse mm->page_table_lock to guard\n\t\t\t\t * against concurrent vma expansions.\n\t\t\t\t */\n\t\t\t\tspin_lock(&mm->page_table_lock);\n\t\t\t\tif (vma->vm_flags & VM_LOCKED)\n\t\t\t\t\tmm->locked_vm += grow;\n\t\t\t\tvm_stat_account(mm, vma->vm_flags, grow);\n\t\t\t\tanon_vma_interval_tree_pre_update_vma(vma);\n\t\t\t\tvma->vm_start = address;\n\t\t\t\tvma->vm_pgoff -= grow;\n\t\t\t\tanon_vma_interval_tree_post_update_vma(vma);\n\t\t\t\tvma_gap_update(vma);\n\t\t\t\tspin_unlock(&mm->page_table_lock);\n\n\t\t\t\tperf_event_mmap(vma);\n\t\t\t}\n\t\t}\n\t}\n\tanon_vma_unlock_write(vma->anon_vma);\n\tkhugepaged_enter_vma_merge(vma, vma->vm_flags);\n\tvalidate_mm(mm);\n\treturn error;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 2429,
    "critical_vars": [
      "error"
    ],
    "function": "expand_downwards",
    "filename": "linux/CVE-2019-9213/CVE-2019-9213_CWE-476_0a1d52994d440e21def1c2174932410b4f2a98a1_mmap.c.diff",
    "function_code": "int expand_downwards(struct vm_area_struct *vma,\n\t\t\t\t   unsigned long address)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct vm_area_struct *prev;\n\tint error = 0;\n\n\taddress &= PAGE_MASK;\n\tif (address < mmap_min_addr)\n\t\treturn -EPERM;\n\n\t/* Enforce stack_guard_gap */\n\tprev = vma->vm_prev;\n\t/* Check that both stack segments have the same anon_vma? */\n\tif (prev && !(prev->vm_flags & VM_GROWSDOWN) &&\n\t\t\t(prev->vm_flags & (VM_WRITE|VM_READ|VM_EXEC))) {\n\t\tif (address - prev->vm_end < stack_guard_gap)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* We must make sure the anon_vma is allocated. */\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\treturn -ENOMEM;\n\n\t/*\n\t * vma->vm_start/vm_end cannot change under us because the caller\n\t * is required to hold the mmap_sem in read mode.  We need the\n\t * anon_vma lock to serialize against concurrent expand_stacks.\n\t */\n\tanon_vma_lock_write(vma->anon_vma);\n\n\t/* Somebody else might have raced and expanded it already */\n\tif (address < vma->vm_start) {\n\t\tunsigned long size, grow;\n\n\t\tsize = vma->vm_end - address;\n\t\tgrow = (vma->vm_start - address) >> PAGE_SHIFT;\n\n\t\terror = -ENOMEM;\n\t\tif (grow <= vma->vm_pgoff) {\n\t\t\terror = acct_stack_growth(vma, size, grow);\n\t\t\tif (!error) {\n\t\t\t\t/*\n\t\t\t\t * vma_gap_update() doesn't support concurrent\n\t\t\t\t * updates, but we only hold a shared mmap_sem\n\t\t\t\t * lock here, so we need to protect against\n\t\t\t\t * concurrent vma expansions.\n\t\t\t\t * anon_vma_lock_write() doesn't help here, as\n\t\t\t\t * we don't guarantee that all growable vmas\n\t\t\t\t * in a mm share the same root anon vma.\n\t\t\t\t * So, we reuse mm->page_table_lock to guard\n\t\t\t\t * against concurrent vma expansions.\n\t\t\t\t */\n\t\t\t\tspin_lock(&mm->page_table_lock);\n\t\t\t\tif (vma->vm_flags & VM_LOCKED)\n\t\t\t\t\tmm->locked_vm += grow;\n\t\t\t\tvm_stat_account(mm, vma->vm_flags, grow);\n\t\t\t\tanon_vma_interval_tree_pre_update_vma(vma);\n\t\t\t\tvma->vm_start = address;\n\t\t\t\tvma->vm_pgoff -= grow;\n\t\t\t\tanon_vma_interval_tree_post_update_vma(vma);\n\t\t\t\tvma_gap_update(vma);\n\t\t\t\tspin_unlock(&mm->page_table_lock);\n\n\t\t\t\tperf_event_mmap(vma);\n\t\t\t}\n\t\t}\n\t}\n\tanon_vma_unlock_write(vma->anon_vma);\n\tkhugepaged_enter_vma_merge(vma, vma->vm_flags);\n\tvalidate_mm(mm);\n\treturn error;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 1065,
    "critical_vars": [
      "block",
      "new_block",
      "next"
    ],
    "function": "ram_block_add",
    "filename": "unicorn/CVE-2022-29694/CVE-2022-29694_CWE-476_3d3deac5e6d38602b689c4fef5dac004f07a2e63_exec.c.diff",
    "function_code": "static void ram_block_add(struct uc_struct *uc, RAMBlock *new_block)\n{\n    RAMBlock *block;\n    RAMBlock *last_block = NULL;\n\n    new_block->offset = find_ram_offset(uc, new_block->max_length);\n\n    if (!new_block->host) {\n        new_block->host = phys_mem_alloc(uc, new_block->max_length,\n                &new_block->mr->align);\n        if (!new_block->host) {\n            // error_setg_errno(errp, errno,\n            //         \"cannot set up guest memory '%s'\",\n            //         memory_region_name(new_block->mr));\n            return;\n        }\n        // memory_try_enable_merging(new_block->host, new_block->max_length);\n    }\n\n    /* Keep the list sorted from biggest to smallest block.  Unlike QTAILQ,\n     * QLIST (which has an RCU-friendly variant) does not have insertion at\n     * tail, so save the last element in last_block.\n     */\n    RAMBLOCK_FOREACH(block) {\n        last_block = block;\n        if (block->max_length < new_block->max_length) {\n            break;\n        }\n    }\n    if (block) {\n        QLIST_INSERT_BEFORE(block, new_block, next);\n    } else if (last_block) {\n        QLIST_INSERT_AFTER(last_block, new_block, next);\n    } else { /* list is empty */\n        QLIST_INSERT_HEAD(&uc->ram_list.blocks, new_block, next);\n    }\n    uc->ram_list.mru_block = NULL;\n\n    /* Write list before version */\n    //smp_wmb();\n\n    cpu_physical_memory_set_dirty_range(new_block->offset,\n                                        new_block->used_length,\n                                        DIRTY_CLIENTS_ALL);\n\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 1047,
    "critical_vars": [
      "uc->invalid_error"
    ],
    "function": "ram_block_add",
    "filename": "unicorn/CVE-2022-29694/CVE-2022-29694_CWE-476_3d3deac5e6d38602b689c4fef5dac004f07a2e63_exec.c.diff",
    "function_code": "static void ram_block_add(struct uc_struct *uc, RAMBlock *new_block)\n{\n    RAMBlock *block;\n    RAMBlock *last_block = NULL;\n\n    new_block->offset = find_ram_offset(uc, new_block->max_length);\n\n    if (!new_block->host) {\n        new_block->host = phys_mem_alloc(uc, new_block->max_length,\n                &new_block->mr->align);\n        if (!new_block->host) {\n            // mmap fails.\n            uc->invalid_error = UC_ERR_NOMEM;\n            // error_setg_errno(errp, errno,\n            //         \"cannot set up guest memory '%s'\",\n            //         memory_region_name(new_block->mr));\n            return;\n        }\n        // memory_try_enable_merging(new_block->host, new_block->max_length);\n    }\n\n    /* Keep the list sorted from biggest to smallest block.  Unlike QTAILQ,\n     * QLIST (which has an RCU-friendly variant) does not have insertion at\n     * tail, so save the last element in last_block.\n     */\n    RAMBLOCK_FOREACH(block) {\n        last_block = block;\n        if (block->max_length < new_block->max_length) {\n            break;\n        }\n    }\n    if (block) {\n        QLIST_INSERT_BEFORE_RCU(block, new_block, next);\n    } else if (last_block) {\n        QLIST_INSERT_AFTER_RCU(last_block, new_block, next);\n    } else { /* list is empty */\n        QLIST_INSERT_HEAD_RCU(&uc->ram_list.blocks, new_block, next);\n    }\n    uc->ram_list.mru_block = NULL;\n\n    /* Write list before version */\n    //smp_wmb();\n\n    cpu_physical_memory_set_dirty_range(new_block->offset,\n                                        new_block->used_length,\n                                        DIRTY_CLIENTS_ALL);\n\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 1133,
    "critical_vars": [
      "block",
      "next"
    ],
    "function": "qemu_ram_free",
    "filename": "unicorn/CVE-2022-29694/CVE-2022-29694_CWE-476_3d3deac5e6d38602b689c4fef5dac004f07a2e63_exec.c.diff",
    "function_code": "void qemu_ram_free(struct uc_struct *uc, RAMBlock *block)\n{\n    if (!block) {\n        return;\n    }\n\n    //if (block->host) {\n    //    ram_block_notify_remove(block->host, block->max_length);\n    //}\n\n    QLIST_REMOVE(block, next);\n    uc->ram_list.mru_block = NULL;\n    /* Write list before version */\n    //smp_wmb();\n    // call_rcu(block, reclaim_ramblock, rcu);\n    reclaim_ramblock(uc, block);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 1142,
    "critical_vars": [
      "block",
      "next"
    ],
    "function": "qemu_ram_free",
    "filename": "unicorn/CVE-2022-29694/CVE-2022-29694_CWE-476_3d3deac5e6d38602b689c4fef5dac004f07a2e63_exec.c.diff",
    "function_code": "void qemu_ram_free(struct uc_struct *uc, RAMBlock *block)\n{\n    if (!block) {\n        return;\n    }\n\n    //if (block->host) {\n    //    ram_block_notify_remove(block->host, block->max_length);\n    //}\n\n    QLIST_REMOVE_RCU(block, next);\n    uc->ram_list.mru_block = NULL;\n    /* Write list before version */\n    //smp_wmb();\n    // call_rcu(block, reclaim_ramblock, rcu);\n    reclaim_ramblock(uc, block);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 487,
    "critical_vars": [
      "obj"
    ],
    "function": "php_wddx_serialize_object",
    "filename": "php-src/CVE-2016-9934/CVE-2016-9934_CWE-476_6045de69c7dedcba3eadf7c4bba424b19c81d00d_wddx.c.diff",
    "function_code": " */\nstatic void php_wddx_serialize_object(wddx_packet *packet, zval *obj)\n{\n/* OBJECTS_FIXME */\n\tzval **ent, *fname, **varname;\n\tzval *retval = NULL;\n\tconst char *key;\n\tulong idx;\n\tchar tmp_buf[WDDX_BUF_LEN];\n\tHashTable *objhash, *sleephash;\n\tTSRMLS_FETCH();\n\n\tMAKE_STD_ZVAL(fname);\n\tZVAL_STRING(fname, \"__sleep\", 1);\n\n\t/*\n\t * We try to call __sleep() method on object. It's supposed to return an\n\t * array of property names to be serialized.\n\t */\n\tif (call_user_function_ex(CG(function_table), &obj, fname, &retval, 0, 0, 1, NULL TSRMLS_CC) == SUCCESS) {\n\t\tif (retval && (sleephash = HASH_OF(retval))) {\n\t\t\tPHP_CLASS_ATTRIBUTES;\n\n\t\t\tPHP_SET_CLASS_ATTRIBUTES(obj);\n\n\t\t\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_S);\n\t\t\tsnprintf(tmp_buf, WDDX_BUF_LEN, WDDX_VAR_S, PHP_CLASS_NAME_VAR);\n\t\t\tphp_wddx_add_chunk(packet, tmp_buf);\n\t\t\tphp_wddx_add_chunk_static(packet, WDDX_STRING_S);\n\t\t\tphp_wddx_add_chunk_ex(packet, class_name, name_len);\n\t\t\tphp_wddx_add_chunk_static(packet, WDDX_STRING_E);\n\t\t\tphp_wddx_add_chunk_static(packet, WDDX_VAR_E);\n\n\t\t\tPHP_CLEANUP_CLASS_ATTRIBUTES();\n\n\t\t\tobjhash = HASH_OF(obj);\n\n\t\t\tfor (zend_hash_internal_pointer_reset(sleephash);\n\t\t\t\t zend_hash_get_current_data(sleephash, (void **)&varname) == SUCCESS;\n\t\t\t\t zend_hash_move_forward(sleephash)) {\n\t\t\t\tif (Z_TYPE_PP(varname) != IS_STRING) {\n\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"__sleep should return an array only containing the names of instance-variables to serialize.\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (zend_hash_find(objhash, Z_STRVAL_PP(varname), Z_STRLEN_PP(varname)+1, (void **)&ent) == SUCCESS) {\n\t\t\t\t\tphp_wddx_serialize_var(packet, *ent, Z_STRVAL_PP(varname), Z_STRLEN_PP(varname) TSRMLS_CC);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_E);\n\t\t}\n\t} else {\n\t\tuint key_len;\n\n\t\tPHP_CLASS_ATTRIBUTES;\n\n\t\tPHP_SET_CLASS_ATTRIBUTES(obj);\n\n\t\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_S);\n\t\tsnprintf(tmp_buf, WDDX_BUF_LEN, WDDX_VAR_S, PHP_CLASS_NAME_VAR);\n\t\tphp_wddx_add_chunk(packet, tmp_buf);\n\t\tphp_wddx_add_chunk_static(packet, WDDX_STRING_S);\n\t\tphp_wddx_add_chunk_ex(packet, class_name, name_len);\n\t\tphp_wddx_add_chunk_static(packet, WDDX_STRING_E);\n\t\tphp_wddx_add_chunk_static(packet, WDDX_VAR_E);\n\n\t\tPHP_CLEANUP_CLASS_ATTRIBUTES();\n\n\t\tobjhash = HASH_OF(obj);\n\t\tfor (zend_hash_internal_pointer_reset(objhash);\n\t\t\t zend_hash_get_current_data(objhash, (void**)&ent) == SUCCESS;\n\t\t\t zend_hash_move_forward(objhash)) {\n\t\t\tif (*ent == obj) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (zend_hash_get_current_key_ex(objhash, &key, &key_len, &idx, 0, NULL) == HASH_KEY_IS_STRING) {\n\t\t\t\tconst char *class_name, *prop_name;\n\n\t\t\t\tzend_unmangle_property_name(key, key_len-1, &class_name, &prop_name);\n\t\t\t\tphp_wddx_serialize_var(packet, *ent, prop_name, strlen(prop_name)+1 TSRMLS_CC);\n\t\t\t} else {\n\t\t\t\tkey_len = slprintf(tmp_buf, sizeof(tmp_buf), \"%ld\", idx);\n\t\t\t\tphp_wddx_serialize_var(packet, *ent, tmp_buf, key_len TSRMLS_CC);\n\t\t\t}\n\t\t}\n\t\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_E);\n\t}\n\n\tzval_dtor(fname);\n\tFREE_ZVAL(fname);\n\n\tif (retval) {\n\t\tzval_ptr_dtor(&retval);\n\t}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 1155,
    "critical_vars": [
      "opf->metadata->x_meta->dictionary_in_lang"
    ],
    "function": "mobi_build_opf_metadata",
    "filename": "libmobi/CVE-2022-2279/CVE-2022-2279_CWE-476_c0699c8693c47f14a2e57dec7292e862ac7adf9c_opf.c.diff",
    "function_code": "MOBI_RET mobi_build_opf_metadata(OPF *opf,  const MOBIData *m, const MOBIRawml *rawml) {\n    if (m == NULL) {\n        debug_print(\"%s\\n\", \"Initialization failed\");\n        return MOBI_INIT_FAILED;\n    }\n    opf->metadata = calloc(1, sizeof(OPFmetadata));\n    if (opf->metadata == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    /* initialize metadata sub-elements */\n    opf->metadata->meta = calloc(OPF_META_MAX_TAGS, sizeof(OPFmeta*));\n    if (opf->metadata->meta == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    opf->metadata->dc_meta = calloc(1, sizeof(OPFdcmeta));\n    if (opf->metadata->dc_meta == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    opf->metadata->x_meta = calloc(1, sizeof(OPFxmeta));\n    if (opf->metadata->x_meta == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    if (m->eh) {\n        MOBI_RET ret = mobi_get_opf_from_exth(opf->metadata, m);\n        if (ret != MOBI_SUCCESS) {\n            return ret;\n        }\n    }\n    /* check for required elements */\n    if (opf->metadata->dc_meta->identifier == NULL) {\n        /* default id will be \"0\" */\n        char uid_string[11] = \"0\";\n        if (m->mh && m->mh->uid) {\n            snprintf(uid_string, 11, \"%u\", *m->mh->uid);\n        }\n        mobi_opf_set_tagtype(OPFidentifier, opf->metadata->dc_meta->identifier, value, uid_string);\n        mobi_opf_set_tagtype(OPFidentifier, opf->metadata->dc_meta->identifier, id, \"uid\");\n    } else {\n        opf->metadata->dc_meta->identifier[0]->id = strdup(\"uid\");\n    }\n    if (opf->metadata->dc_meta->title == NULL) {\n        opf->metadata->dc_meta->title = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n        if (opf->metadata->dc_meta->title == NULL) {\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        char *title = mobi_meta_get_title(m);\n        if (title == NULL) {\n            title = strdup(\"Unknown\");\n        }\n        opf->metadata->dc_meta->title[0] = title;\n    }\n    if (opf->metadata->dc_meta->language == NULL) {\n        opf->metadata->dc_meta->language = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n        if (opf->metadata->dc_meta->language == NULL) {\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        const char *lang_string = NULL;\n        if (m->mh && m->mh->locale) {\n            uint32_t lang_code = *m->mh->locale;\n            lang_string = mobi_get_locale_string(lang_code);\n        }\n        if (lang_string) {\n            opf->metadata->dc_meta->language[0] = strdup(lang_string);\n        } else {\n            opf->metadata->dc_meta->language[0] = strdup(\"en\");\n        }\n    }\n    /* write optional elements */\n    if (mobi_is_dictionary(m)) {\n        if (opf->metadata->x_meta->dictionary_in_lang == NULL) {\n            if (m->mh && m->mh->dict_input_lang) {\n                opf->metadata->x_meta->dictionary_in_lang = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n                if (opf->metadata->x_meta->dictionary_in_lang == NULL) {\n                    debug_print(\"%s\\n\", \"Memory allocation failed\");\n                    return MOBI_MALLOC_FAILED;\n                }\n                uint32_t dict_lang_in = *m->mh->dict_input_lang;\n                opf->metadata->x_meta->dictionary_in_lang[0] = strdup(mobi_get_locale_string(dict_lang_in));\n            }\n        }\n        if (opf->metadata->x_meta->dictionary_out_lang == NULL) {\n            if (m->mh && m->mh->dict_output_lang) {\n                opf->metadata->x_meta->dictionary_out_lang = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n                if (opf->metadata->x_meta->dictionary_out_lang == NULL) {\n                    debug_print(\"%s\\n\", \"Memory allocation failed\");\n                    return MOBI_MALLOC_FAILED;\n                }\n                uint32_t dict_lang_in = *m->mh->dict_output_lang;\n                opf->metadata->x_meta->dictionary_out_lang[0] = strdup(mobi_get_locale_string(dict_lang_in));\n            }\n        }\n        if (rawml->orth->orth_index_name) {\n            opf->metadata->x_meta->default_lookup_index = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n            if (opf->metadata->x_meta->default_lookup_index == NULL) {\n                debug_print(\"%s\\n\", \"Memory allocation failed\");\n                return MOBI_MALLOC_FAILED;\n            }\n            opf->metadata->x_meta->default_lookup_index[0] = strdup(rawml->orth->orth_index_name);\n        }\n    }\n    return MOBI_SUCCESS;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 693,
    "critical_vars": [
      "key",
      "status"
    ],
    "function": "SetOpAttrScalar",
    "filename": "tensorflow/CVE-2022-29205/CVE-2022-29205_CWE-476_237822b59fc504dda2c564787f5d3ad9c4aa62d9_pywrap_tfe_src.cc.diff",
    "function_code": "bool SetOpAttrScalar(TFE_Context* ctx, TFE_Op* op, const char* key,\n                     PyObject* py_value, TF_AttrType type,\n                     tensorflow::gtl::FlatMap<string, int64_t>* attr_list_sizes,\n                     TF_Status* status) {\n  if (type == TF_ATTR_STRING) {\n    tensorflow::StringPiece value;\n    if (!ParseStringValue(key, py_value, status, &value)) return false;\n    TFE_OpSetAttrString(op, key, value.data(), value.size());\n  } else if (type == TF_ATTR_INT) {\n    int64_t value;\n    if (!ParseInt64Value(key, py_value, status, &value)) return false;\n    TFE_OpSetAttrInt(op, key, value);\n    // attr_list_sizes is set for all int attributes (since at this point we are\n    // not aware if that attribute might be used to calculate the size of an\n    // output list or not).\n    if (attr_list_sizes != nullptr) (*attr_list_sizes)[key] = value;\n  } else if (type == TF_ATTR_FLOAT) {\n    float value;\n    if (!ParseFloatValue(key, py_value, status, &value)) return false;\n    TFE_OpSetAttrFloat(op, key, value);\n  } else if (type == TF_ATTR_BOOL) {\n    unsigned char value;\n    if (!ParseBoolValue(key, py_value, status, &value)) return false;\n    TFE_OpSetAttrBool(op, key, value);\n  } else if (type == TF_ATTR_TYPE) {\n    int value;\n    if (!ParseTypeValue(key, py_value, status, &value)) return false;\n    TFE_OpSetAttrType(op, key, static_cast<TF_DataType>(value));\n  } else if (type == TF_ATTR_SHAPE) {\n    if (py_value == Py_None) {\n      TFE_OpSetAttrShape(op, key, nullptr, -1, status);\n    } else {\n      if (!PySequence_Check(py_value)) {\n        TF_SetStatus(status, TF_INVALID_ARGUMENT,\n                     tensorflow::strings::StrCat(\n                         \"Expecting None or sequence value for attr\", key,\n                         \", got \", py_value->ob_type->tp_name)\n                         .c_str());\n        return false;\n      }\n      const auto num_dims = TensorShapeNumDims(py_value);\n      if (num_dims == -1) {\n        TFE_OpSetAttrShape(op, key, nullptr, -1, status);\n        return true;\n      }\n      std::unique_ptr<int64_t[]> dims(new int64_t[num_dims]);\n      for (int i = 0; i < num_dims; ++i) {\n        tensorflow::Safe_PyObjectPtr inner_py_value(\n            PySequence_ITEM(py_value, i));\n        if (inner_py_value.get() == Py_None) {\n          dims[i] = -1;\n        } else if (!ParseDimensionValue(key, inner_py_value.get(), status,\n                                        &dims[i])) {\n          return false;\n        }\n      }\n      TFE_OpSetAttrShape(op, key, dims.get(), num_dims, status);\n    }\n    if (!status->status.ok()) return false;\n  } else if (type == TF_ATTR_FUNC) {\n    // Allow:\n    // (1) String function name, OR\n    // (2) A Python object with a .name attribute\n    //     (A crude test for being a\n    //     tensorflow.python.framework.function._DefinedFunction)\n    //     (which is what the various \"defun\" or \"Defun\" decorators do).\n    // And in the future also allow an object that can encapsulate\n    // the function name and its attribute values.\n    tensorflow::StringPiece func_name;\n    if (!ParseStringValue(key, py_value, status, &func_name)) {\n      PyObject* name_attr = PyObject_GetAttrString(py_value, \"name\");\n      if (name_attr == nullptr ||\n          !ParseStringValue(key, name_attr, status, &func_name)) {\n        TF_SetStatus(\n            status, TF_INVALID_ARGUMENT,\n            tensorflow::strings::StrCat(\n                \"unable to set function value attribute from a \",\n                py_value->ob_type->tp_name,\n                \" object. If you think this is an error, please file an issue \"\n                \"at https://github.com/tensorflow/tensorflow/issues/new\")\n                .c_str());\n        return false;\n      }\n    }\n    TF_SetStatus(status, TF_OK, \"\");\n    TFE_OpSetAttrFunctionName(op, key, func_name.data(), func_name.size());\n  } else {\n    TF_SetStatus(\n        status, TF_UNIMPLEMENTED,\n        tensorflow::strings::StrCat(\"Attr \", key, \" has unhandled type \", type)\n            .c_str());\n    return false;\n  }\n  return true;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 695,
    "critical_vars": [
      "key",
      "status",
      "nullptr"
    ],
    "function": "SetOpAttrScalar",
    "filename": "tensorflow/CVE-2022-29205/CVE-2022-29205_CWE-476_237822b59fc504dda2c564787f5d3ad9c4aa62d9_pywrap_tfe_src.cc.diff",
    "function_code": "bool SetOpAttrScalar(TFE_Context* ctx, TFE_Op* op, const char* key,\n                     PyObject* py_value, TF_AttrType type,\n                     tensorflow::gtl::FlatMap<string, int64_t>* attr_list_sizes,\n                     TF_Status* status) {\n  if (type == TF_ATTR_STRING) {\n    tensorflow::StringPiece value;\n    if (!ParseStringValue(key, py_value, status, &value)) return false;\n    TFE_OpSetAttrString(op, key, value.data(), value.size());\n  } else if (type == TF_ATTR_INT) {\n    int64_t value;\n    if (!ParseInt64Value(key, py_value, status, &value)) return false;\n    TFE_OpSetAttrInt(op, key, value);\n    // attr_list_sizes is set for all int attributes (since at this point we are\n    // not aware if that attribute might be used to calculate the size of an\n    // output list or not).\n    if (attr_list_sizes != nullptr) (*attr_list_sizes)[key] = value;\n  } else if (type == TF_ATTR_FLOAT) {\n    float value;\n    if (!ParseFloatValue(key, py_value, status, &value)) return false;\n    TFE_OpSetAttrFloat(op, key, value);\n  } else if (type == TF_ATTR_BOOL) {\n    unsigned char value;\n    if (!ParseBoolValue(key, py_value, status, &value)) return false;\n    TFE_OpSetAttrBool(op, key, value);\n  } else if (type == TF_ATTR_TYPE) {\n    int value;\n    if (!ParseTypeValue(key, py_value, status, &value)) return false;\n    TFE_OpSetAttrType(op, key, static_cast<TF_DataType>(value));\n  } else if (type == TF_ATTR_SHAPE) {\n    if (py_value == Py_None) {\n      TFE_OpSetAttrShape(op, key, nullptr, -1, status);\n    } else {\n      if (!PySequence_Check(py_value)) {\n        TF_SetStatus(status, TF_INVALID_ARGUMENT,\n                     tensorflow::strings::StrCat(\n                         \"Expecting None or sequence value for attr\", key,\n                         \", got \", py_value->ob_type->tp_name)\n                         .c_str());\n        return false;\n      }\n      const auto num_dims = TensorShapeNumDims(py_value);\n      if (num_dims == -1) {\n        TFE_OpSetAttrShape(op, key, nullptr, -1, status);\n        return true;\n      }\n      std::unique_ptr<int64_t[]> dims(new int64_t[num_dims]);\n      for (int i = 0; i < num_dims; ++i) {\n        tensorflow::Safe_PyObjectPtr inner_py_value(\n            PySequence_ITEM(py_value, i));\n        // If an error is generated when iterating through object, we can\n        // sometimes get a nullptr.\n        if (inner_py_value.get() == Py_None) {\n          dims[i] = -1;\n        } else if (inner_py_value.get() == nullptr ||\n                   !ParseDimensionValue(key, inner_py_value.get(), status,\n                                        &dims[i])) {\n          return false;\n        }\n      }\n      TFE_OpSetAttrShape(op, key, dims.get(), num_dims, status);\n    }\n    if (!status->status.ok()) return false;\n  } else if (type == TF_ATTR_FUNC) {\n    // Allow:\n    // (1) String function name, OR\n    // (2) A Python object with a .name attribute\n    //     (A crude test for being a\n    //     tensorflow.python.framework.function._DefinedFunction)\n    //     (which is what the various \"defun\" or \"Defun\" decorators do).\n    // And in the future also allow an object that can encapsulate\n    // the function name and its attribute values.\n    tensorflow::StringPiece func_name;\n    if (!ParseStringValue(key, py_value, status, &func_name)) {\n      PyObject* name_attr = PyObject_GetAttrString(py_value, \"name\");\n      if (name_attr == nullptr ||\n          !ParseStringValue(key, name_attr, status, &func_name)) {\n        TF_SetStatus(\n            status, TF_INVALID_ARGUMENT,\n            tensorflow::strings::StrCat(\n                \"unable to set function value attribute from a \",\n                py_value->ob_type->tp_name,\n                \" object. If you think this is an error, please file an issue \"\n                \"at https://github.com/tensorflow/tensorflow/issues/new\")\n                .c_str());\n        return false;\n      }\n    }\n    TF_SetStatus(status, TF_OK, \"\");\n    TFE_OpSetAttrFunctionName(op, key, func_name.data(), func_name.size());\n  } else {\n    TF_SetStatus(\n        status, TF_UNIMPLEMENTED,\n        tensorflow::strings::StrCat(\"Attr \", key, \" has unhandled type \", type)\n            .c_str());\n    return false;\n  }\n  return true;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 544,
    "critical_vars": [
      "output_len"
    ],
    "function": "ndlz4_decompress",
    "filename": "c-blosc2/CVE-2023-37186/CVE-2023-37186_CWE-476_d55bfcd6804699e1435dc3e233fd76c8a5d3f9e3_ndlz4x4.c.diff",
    "function_code": "int ndlz4_decompress(const uint8_t *input, int32_t input_len, uint8_t *output, int32_t output_len,\n                     uint8_t meta, blosc2_dparams *dparams) {\n  BLOSC_UNUSED_PARAM(meta);\n  BLOSC_UNUSED_PARAM(dparams);\n\n  uint8_t *ip = (uint8_t *) input;\n  uint8_t *ip_limit = ip + input_len;\n  uint8_t *op = (uint8_t *) output;\n  uint8_t ndim;\n  uint32_t blockshape[2];\n  uint32_t eshape[2];\n  uint8_t *buffercpy;\n  uint8_t local_buffer[16];\n  uint8_t token;\n  if (NDLZ_UNEXPECT_CONDITIONAL(input_len < 8)) {\n    return 0;\n  }\n\n  /* we start with literal copy */\n  ndim = *ip;\n  ip++;\n  if (ndim != 2) {\n    BLOSC_TRACE_ERROR(\"This codec only works for ndim = 2\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n  memcpy(&blockshape[0], ip, 4);\n  ip += 4;\n  memcpy(&blockshape[1], ip, 4);\n  ip += 4;\n  eshape[0] = ((blockshape[0] + 3) / 4) * 4;\n  eshape[1] = ((blockshape[1] + 3) / 4) * 4;\n\n  if (NDLZ_UNEXPECT_CONDITIONAL(output_len < (int32_t) (blockshape[0] * blockshape[1]))) {\n    return 0;\n  }\n  memset(op, 0, blockshape[0] * blockshape[1]);\n\n  uint32_t i_stop[2];\n  for (int i = 0; i < 2; ++i) {\n    i_stop[i] = eshape[i] / 4;\n  }\n\n  /* main loop */\n  uint32_t ii[2];\n  uint32_t padding[2] = {0};\n  uint32_t ind = 0;\n  uint8_t cell_aux[16];\n  for (ii[0] = 0; ii[0] < i_stop[0]; ++ii[0]) {\n    for (ii[1] = 0; ii[1] < i_stop[1]; ++ii[1]) {      // for each cell\n      if (NDLZ_UNEXPECT_CONDITIONAL(ip > ip_limit)) {\n        BLOSC_TRACE_ERROR(\"Exceeding input length\");\n        return BLOSC2_ERROR_FAILURE;\n      }\n      if (ii[0] == i_stop[0] - 1) {\n        padding[0] = (blockshape[0] % 4 == 0) ? 4 : blockshape[0] % 4;\n      } else {\n        padding[0] = 4;\n      }\n      if (ii[1] == i_stop[1] - 1) {\n        padding[1] = (blockshape[1] % 4 == 0) ? 4 : blockshape[1] % 4;\n      } else {\n        padding[1] = 4;\n      }\n      token = *ip++;\n      if (token == 0) {    // no match\n        buffercpy = ip;\n        ip += padding[0] * padding[1];\n      } else if (token == (uint8_t) ((1U << 7U) | (1U << 6U))) {  // cell match\n        uint16_t offset = *((uint16_t *) ip);\n        buffercpy = ip - offset - 1;\n        ip += 2;\n      } else if (token == (uint8_t) (1U << 6U)) { // whole cell of same element\n        buffercpy = cell_aux;\n        memset(buffercpy, *ip, 16);\n        ip++;\n      } else if (token >= 224) { // three rows match\n        buffercpy = local_buffer;\n        uint16_t offset = *((uint16_t *) ip);\n        offset += 3;\n        ip += 2;\n        int i, j, k;\n        if ((token >> 3U) == 28) {\n          i = 1;\n          j = 2;\n          k = 3;\n        } else {\n          i = 0;\n          if ((token >> 3U) < 30) {\n            j = 1;\n            k = 2;\n          } else {\n            k = 3;\n            if ((token >> 3U) == 30) {\n              j = 1;\n            } else {\n              j = 2;\n            }\n          }\n        }\n        memcpy(&buffercpy[i * 4], ip - offset, 4);\n        memcpy(&buffercpy[j * 4], ip - offset + 4, 4);\n        memcpy(&buffercpy[k * 4], ip - offset + 8, 4);\n        for (int l = 0; l < 4; l++) {\n          if ((l != i) && (l != j) && (l != k)) {\n            memcpy(&buffercpy[l * 4], ip, 4);\n            ip += 4;\n            break;\n          }\n        }\n\n      } else if ((token >= 128) && (token <= 191)) { // rows pair match\n        buffercpy = local_buffer;\n        uint16_t offset = *((uint16_t *) ip);\n        offset += 3;\n        ip += 2;\n        int i, j;\n        if (token == 128) {\n          i = 2;\n          j = 3;\n        } else {\n          i = (token - 128) >> 5U;\n          j = ((token - 128) >> 3U) - (i << 2U);\n        }\n        memcpy(&buffercpy[i * 4], ip - offset, 4);\n        memcpy(&buffercpy[j * 4], ip - offset + 4, 4);\n        for (int k = 0; k < 4; k++) {\n          if ((k != i) && (k != j)) {\n            memcpy(&buffercpy[k * 4], ip, 4);\n            ip += 4;\n          }\n        }\n      } else if ((token >= 40) && (token <= 63)) {  // 2 rows pair matches\n        buffercpy = local_buffer;\n        uint16_t offset_1 = *((uint16_t *) ip);\n        offset_1 += 5;\n        ip += 2;\n        uint16_t offset_2 = *((uint16_t *) ip);\n        offset_2 += 5;\n        ip += 2;\n        int i, j, k, l, m;\n        i = 0;\n        j = ((token - 32) >> 3U);\n        l = -1;\n        for (k = 1; k < 4; k++) {\n          if ((k != i) && (k != j)) {\n            if (l == -1) {\n              l = k;\n            } else {\n              m = k;\n            }\n          }\n        }\n        memcpy(&buffercpy[i * 4], ip - offset_1, 4);\n        memcpy(&buffercpy[j * 4], ip - offset_1 + 4, 4);\n        memcpy(&buffercpy[l * 4], ip - offset_2, 4);\n        memcpy(&buffercpy[m * 4], ip - offset_2 + 4, 4);\n\n      } else {\n        BLOSC_TRACE_ERROR(\"Invalid token: %u at cell [%d, %d]\\n\", token, ii[0], ii[1]);\n        return BLOSC2_ERROR_FAILURE;\n      }\n      // fill op with buffercpy\n      uint32_t orig = ii[0] * 4 * blockshape[1] + ii[1] * 4;\n      for (uint32_t i = 0; i < 4; i++) {\n        if (i < padding[0]) {\n          ind = orig + i * blockshape[1];\n          memcpy(&op[ind], buffercpy, padding[1]);\n        }\n        buffercpy += padding[1];\n      }\n      if (ind > (uint32_t) output_len) {\n        BLOSC_TRACE_ERROR(\"Exceeding output size\");\n        return BLOSC2_ERROR_FAILURE;\n      }\n    }\n  }\n  ind += padding[1];\n\n  if (ind != (blockshape[0] * blockshape[1])) {\n    BLOSC_TRACE_ERROR(\"Output size is not compatible with embedded blockshape\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n  if (ind > (uint32_t) output_len) {\n    BLOSC_TRACE_ERROR(\"Exceeding output size\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n\n  return (int) ind;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 518,
    "critical_vars": [
      "input"
    ],
    "function": "ndlz4_decompress",
    "filename": "c-blosc2/CVE-2023-37186/CVE-2023-37186_CWE-476_d55bfcd6804699e1435dc3e233fd76c8a5d3f9e3_ndlz4x4.c.diff",
    "function_code": "int ndlz4_decompress(const uint8_t *input, int32_t input_len, uint8_t *output, int32_t output_len,\n                     uint8_t meta, blosc2_dparams *dparams) {\n  BLOSC_UNUSED_PARAM(meta);\n  BLOSC_UNUSED_PARAM(dparams);\n  BLOSC_ERROR_NULL(input, BLOSC2_ERROR_NULL_POINTER);\n  BLOSC_ERROR_NULL(output, BLOSC2_ERROR_NULL_POINTER);\n\n  uint8_t *ip = (uint8_t *) input;\n  uint8_t *ip_limit = ip + input_len;\n  uint8_t *op = (uint8_t *) output;\n  uint8_t ndim;\n  uint32_t blockshape[2];\n  uint32_t eshape[2];\n  uint8_t *buffercpy;\n  uint8_t local_buffer[16];\n  uint8_t token;\n  if (NDLZ_UNEXPECT_CONDITIONAL(input_len < 8)) {\n    return 0;\n  }\n\n  /* we start with literal copy */\n  ndim = *ip;\n  ip++;\n  if (ndim != 2) {\n    BLOSC_TRACE_ERROR(\"This codec only works for ndim = 2\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n  memcpy(&blockshape[0], ip, 4);\n  ip += 4;\n  memcpy(&blockshape[1], ip, 4);\n  ip += 4;\n  eshape[0] = ((blockshape[0] + 3) / 4) * 4;\n  eshape[1] = ((blockshape[1] + 3) / 4) * 4;\n\n  if (NDLZ_UNEXPECT_CONDITIONAL((int64_t)output_len < (int64_t)blockshape[0] * (int64_t)blockshape[1])) {\n    return 0;\n  }\n  memset(op, 0, blockshape[0] * blockshape[1]);\n\n  uint32_t i_stop[2];\n  for (int i = 0; i < 2; ++i) {\n    i_stop[i] = eshape[i] / 4;\n  }\n\n  /* main loop */\n  uint32_t ii[2];\n  uint32_t padding[2] = {0};\n  uint32_t ind = 0;\n  uint8_t cell_aux[16];\n  for (ii[0] = 0; ii[0] < i_stop[0]; ++ii[0]) {\n    for (ii[1] = 0; ii[1] < i_stop[1]; ++ii[1]) {      // for each cell\n      if (NDLZ_UNEXPECT_CONDITIONAL(ip > ip_limit)) {\n        BLOSC_TRACE_ERROR(\"Exceeding input length\");\n        return BLOSC2_ERROR_FAILURE;\n      }\n      if (ii[0] == i_stop[0] - 1) {\n        padding[0] = (blockshape[0] % 4 == 0) ? 4 : blockshape[0] % 4;\n      } else {\n        padding[0] = 4;\n      }\n      if (ii[1] == i_stop[1] - 1) {\n        padding[1] = (blockshape[1] % 4 == 0) ? 4 : blockshape[1] % 4;\n      } else {\n        padding[1] = 4;\n      }\n      token = *ip++;\n      if (token == 0) {    // no match\n        buffercpy = ip;\n        ip += padding[0] * padding[1];\n      } else if (token == (uint8_t) ((1U << 7U) | (1U << 6U))) {  // cell match\n        uint16_t offset = *((uint16_t *) ip);\n        buffercpy = ip - offset - 1;\n        ip += 2;\n      } else if (token == (uint8_t) (1U << 6U)) { // whole cell of same element\n        buffercpy = cell_aux;\n        memset(buffercpy, *ip, 16);\n        ip++;\n      } else if (token >= 224) { // three rows match\n        buffercpy = local_buffer;\n        uint16_t offset = *((uint16_t *) ip);\n        offset += 3;\n        ip += 2;\n        int i, j, k;\n        if ((token >> 3U) == 28) {\n          i = 1;\n          j = 2;\n          k = 3;\n        } else {\n          i = 0;\n          if ((token >> 3U) < 30) {\n            j = 1;\n            k = 2;\n          } else {\n            k = 3;\n            if ((token >> 3U) == 30) {\n              j = 1;\n            } else {\n              j = 2;\n            }\n          }\n        }\n        memcpy(&buffercpy[i * 4], ip - offset, 4);\n        memcpy(&buffercpy[j * 4], ip - offset + 4, 4);\n        memcpy(&buffercpy[k * 4], ip - offset + 8, 4);\n        for (int l = 0; l < 4; l++) {\n          if ((l != i) && (l != j) && (l != k)) {\n            memcpy(&buffercpy[l * 4], ip, 4);\n            ip += 4;\n            break;\n          }\n        }\n\n      } else if ((token >= 128) && (token <= 191)) { // rows pair match\n        buffercpy = local_buffer;\n        uint16_t offset = *((uint16_t *) ip);\n        offset += 3;\n        ip += 2;\n        int i, j;\n        if (token == 128) {\n          i = 2;\n          j = 3;\n        } else {\n          i = (token - 128) >> 5U;\n          j = ((token - 128) >> 3U) - (i << 2U);\n        }\n        memcpy(&buffercpy[i * 4], ip - offset, 4);\n        memcpy(&buffercpy[j * 4], ip - offset + 4, 4);\n        for (int k = 0; k < 4; k++) {\n          if ((k != i) && (k != j)) {\n            memcpy(&buffercpy[k * 4], ip, 4);\n            ip += 4;\n          }\n        }\n      } else if ((token >= 40) && (token <= 63)) {  // 2 rows pair matches\n        buffercpy = local_buffer;\n        uint16_t offset_1 = *((uint16_t *) ip);\n        offset_1 += 5;\n        ip += 2;\n        uint16_t offset_2 = *((uint16_t *) ip);\n        offset_2 += 5;\n        ip += 2;\n        int i, j, k, l, m;\n        i = 0;\n        j = ((token - 32) >> 3U);\n        l = -1;\n        for (k = 1; k < 4; k++) {\n          if ((k != i) && (k != j)) {\n            if (l == -1) {\n              l = k;\n            } else {\n              m = k;\n            }\n          }\n        }\n        memcpy(&buffercpy[i * 4], ip - offset_1, 4);\n        memcpy(&buffercpy[j * 4], ip - offset_1 + 4, 4);\n        memcpy(&buffercpy[l * 4], ip - offset_2, 4);\n        memcpy(&buffercpy[m * 4], ip - offset_2 + 4, 4);\n\n      } else {\n        BLOSC_TRACE_ERROR(\"Invalid token: %u at cell [%d, %d]\\n\", token, ii[0], ii[1]);\n        return BLOSC2_ERROR_FAILURE;\n      }\n      // fill op with buffercpy\n      uint32_t orig = ii[0] * 4 * blockshape[1] + ii[1] * 4;\n      for (uint32_t i = 0; i < 4; i++) {\n        if (i < padding[0]) {\n          ind = orig + i * blockshape[1];\n          memcpy(&op[ind], buffercpy, padding[1]);\n        }\n        buffercpy += padding[1];\n      }\n      if (ind > (uint32_t) output_len) {\n        BLOSC_TRACE_ERROR(\"Exceeding output size\");\n        return BLOSC2_ERROR_FAILURE;\n      }\n    }\n  }\n  ind += padding[1];\n\n  if (ind != (blockshape[0] * blockshape[1])) {\n    BLOSC_TRACE_ERROR(\"Output size is not compatible with embedded blockshape\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n  if (ind > (uint32_t) output_len) {\n    BLOSC_TRACE_ERROR(\"Exceeding output size\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n\n  return (int) ind;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 462,
    "critical_vars": [
      "output_len"
    ],
    "function": "ndlz8_decompress",
    "filename": "c-blosc2/CVE-2023-37186/CVE-2023-37186_CWE-476_d55bfcd6804699e1435dc3e233fd76c8a5d3f9e3_ndlz8x8.c.diff",
    "function_code": "int ndlz8_decompress(const uint8_t *input, int32_t input_len, uint8_t *output, int32_t output_len,\n                     uint8_t meta, blosc2_dparams *dparams) {\n  BLOSC_UNUSED_PARAM(meta);\n  BLOSC_UNUSED_PARAM(dparams);\n\n  const int cell_shape = 8;\n  const int cell_size = 64;\n  uint8_t *ip = (uint8_t *) input;\n  uint8_t *ip_limit = ip + input_len;\n  uint8_t *op = (uint8_t *) output;\n  uint8_t ndim;\n  int32_t blockshape[2];\n  int32_t eshape[2];\n  uint8_t *buffercpy;\n  uint8_t token;\n  if (NDLZ_UNEXPECT_CONDITIONAL(input_len < 8)) {\n    return 0;\n  }\n\n  /* we start with literal copy */\n  ndim = *ip;\n  ip++;\n  if (ndim != 2) {\n    BLOSC_TRACE_ERROR(\"This codec only works for ndim = 2\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n  memcpy(&blockshape[0], ip, 4);\n  ip += 4;\n  memcpy(&blockshape[1], ip, 4);\n  ip += 4;\n  eshape[0] = ((blockshape[0] + 7) / cell_shape) * cell_shape;\n  eshape[1] = ((blockshape[1] + 7) / cell_shape) * cell_shape;\n\n  if (NDLZ_UNEXPECT_CONDITIONAL(output_len < blockshape[0] * blockshape[1])) {\n    return 0;\n  }\n  memset(op, 0, blockshape[0] * blockshape[1]);\n\n  int32_t i_stop[2];\n  for (int i = 0; i < 2; ++i) {\n    i_stop[i] = eshape[i] / cell_shape;\n  }\n\n  /* main loop */\n  int32_t ii[2];\n  int32_t padding[2] = {0};\n  int32_t ind = 0;\n  uint8_t *local_buffer = malloc(cell_size);\n  uint8_t *cell_aux = malloc(cell_size);\n  for (ii[0] = 0; ii[0] < i_stop[0]; ++ii[0]) {\n    for (ii[1] = 0; ii[1] < i_stop[1]; ++ii[1]) {      // for each cell\n      if (NDLZ_UNEXPECT_CONDITIONAL(ip > ip_limit)) {\n        free(local_buffer);\n        free(cell_aux);\n        BLOSC_TRACE_ERROR(\"Exceeding input length\");\n        return BLOSC2_ERROR_FAILURE;\n      }\n      if (ii[0] == i_stop[0] - 1) {\n        padding[0] = (blockshape[0] % cell_shape == 0) ? cell_shape : blockshape[0] % cell_shape;\n      } else {\n        padding[0] = cell_shape;\n      }\n      if (ii[1] == i_stop[1] - 1) {\n        padding[1] = (blockshape[1] % cell_shape == 0) ? cell_shape : blockshape[1] % cell_shape;\n      } else {\n        padding[1] = cell_shape;\n      }\n      token = *ip++;\n      uint8_t match_type = (token >> 3U);\n      if (token == 0) {    // no match\n        buffercpy = ip;\n        ip += padding[0] * padding[1];\n      } else if (token == (uint8_t) ((1U << 7U) | (1U << 6U))) {  // cell match\n        uint16_t offset = *((uint16_t *) ip);\n        buffercpy = ip - offset - 1;\n        ip += 2;\n      } else if (token == (uint8_t) (1U << 6U)) { // whole cell of same element\n        buffercpy = cell_aux;\n        memset(buffercpy, *ip, cell_size);\n        ip++;\n      } else if (match_type == 21) {    // triple match\n        buffercpy = local_buffer;\n        int row = (int) (token & 7);\n        uint16_t offset = *((uint16_t *) ip);\n        ip += 2;\n        for (int l = 0; l < 3; l++) {\n          memcpy(&buffercpy[(row + l) * cell_shape],\n                 ip - sizeof(token) - sizeof(offset) - offset + l * cell_shape, cell_shape);\n        }\n        for (int l = 0; l < cell_shape; l++) {\n          if ((l < row) || (l > row + 2)) {\n            memcpy(&buffercpy[l * cell_shape], ip, cell_shape);\n            ip += cell_shape;\n          }\n        }\n      } else if (match_type == 17) {    // pair match\n        buffercpy = local_buffer;\n        int row = (int) (token & 7);\n        uint16_t offset = *((uint16_t *) ip);\n        ip += 2;\n        for (int l = 0; l < 2; l++) {\n          memcpy(&buffercpy[(row + l) * cell_shape],\n                 ip - sizeof(token) - sizeof(offset) - offset + l * cell_shape, cell_shape);\n        }\n        for (int l = 0; l < cell_shape; l++) {\n          if ((l < row) || (l > row + 1)) {\n            memcpy(&buffercpy[l * cell_shape], ip, cell_shape);\n            ip += cell_shape;\n          }\n        }\n      } else {\n        free(local_buffer);\n        free(cell_aux);\n        BLOSC_TRACE_ERROR(\"Invalid token: %u at cell [%d, %d]\\n\", token, ii[0], ii[1]);\n        return BLOSC2_ERROR_FAILURE;\n      }\n\n      int32_t orig = ii[0] * cell_shape * blockshape[1] + ii[1] * cell_shape;\n      for (int32_t i = 0; i < (int32_t) cell_shape; i++) {\n        if (i < padding[0]) {\n          ind = orig + i * blockshape[1];\n          memcpy(&op[ind], buffercpy, padding[1]);\n        }\n        buffercpy += padding[1];\n      }\n      if (ind > output_len) {\n        free(local_buffer);\n        free(cell_aux);\n        BLOSC_TRACE_ERROR(\"Exceeding output size\");\n        return BLOSC2_ERROR_FAILURE;\n      }\n    }\n  }\n  ind += padding[1];\n\n  free(cell_aux);\n  free(local_buffer);\n\n  if (ind != (blockshape[0] * blockshape[1])) {\n    BLOSC_TRACE_ERROR(\"Output size is not compatible with embedded blockshape\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n  if (ind > output_len) {\n    BLOSC_TRACE_ERROR(\"Exceeding output size\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n\n  return (int) ind;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 435,
    "critical_vars": [
      "input"
    ],
    "function": "ndlz8_decompress",
    "filename": "c-blosc2/CVE-2023-37186/CVE-2023-37186_CWE-476_d55bfcd6804699e1435dc3e233fd76c8a5d3f9e3_ndlz8x8.c.diff",
    "function_code": "int ndlz8_decompress(const uint8_t *input, int32_t input_len, uint8_t *output, int32_t output_len,\n                     uint8_t meta, blosc2_dparams *dparams) {\n  BLOSC_UNUSED_PARAM(meta);\n  BLOSC_UNUSED_PARAM(dparams);\n  BLOSC_ERROR_NULL(input, BLOSC2_ERROR_NULL_POINTER);\n  BLOSC_ERROR_NULL(output, BLOSC2_ERROR_NULL_POINTER);\n\n  const int cell_shape = 8;\n  const int cell_size = 64;\n  uint8_t *ip = (uint8_t *) input;\n  uint8_t *ip_limit = ip + input_len;\n  uint8_t *op = (uint8_t *) output;\n  uint8_t ndim;\n  int32_t blockshape[2];\n  int32_t eshape[2];\n  uint8_t *buffercpy;\n  uint8_t token;\n  if (NDLZ_UNEXPECT_CONDITIONAL(input_len < 8)) {\n    return 0;\n  }\n\n  /* we start with literal copy */\n  ndim = *ip;\n  ip++;\n  if (ndim != 2) {\n    BLOSC_TRACE_ERROR(\"This codec only works for ndim = 2\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n  memcpy(&blockshape[0], ip, 4);\n  ip += 4;\n  memcpy(&blockshape[1], ip, 4);\n  ip += 4;\n  eshape[0] = ((blockshape[0] + 7) / cell_shape) * cell_shape;\n  eshape[1] = ((blockshape[1] + 7) / cell_shape) * cell_shape;\n  if (NDLZ_UNEXPECT_CONDITIONAL((int64_t)output_len < (int64_t)blockshape[0] * (int64_t)blockshape[1])) {\n    return 0;\n  }\n  memset(op, 0, blockshape[0] * blockshape[1]);\n\n  int32_t i_stop[2];\n  for (int i = 0; i < 2; ++i) {\n    i_stop[i] = eshape[i] / cell_shape;\n  }\n\n  /* main loop */\n  int32_t ii[2];\n  int32_t padding[2] = {0};\n  int32_t ind = 0;\n  uint8_t *local_buffer = malloc(cell_size);\n  uint8_t *cell_aux = malloc(cell_size);\n  for (ii[0] = 0; ii[0] < i_stop[0]; ++ii[0]) {\n    for (ii[1] = 0; ii[1] < i_stop[1]; ++ii[1]) {      // for each cell\n      if (NDLZ_UNEXPECT_CONDITIONAL(ip > ip_limit)) {\n        free(local_buffer);\n        free(cell_aux);\n        BLOSC_TRACE_ERROR(\"Exceeding input length\");\n        return BLOSC2_ERROR_FAILURE;\n      }\n      if (ii[0] == i_stop[0] - 1) {\n        padding[0] = (blockshape[0] % cell_shape == 0) ? cell_shape : blockshape[0] % cell_shape;\n      } else {\n        padding[0] = cell_shape;\n      }\n      if (ii[1] == i_stop[1] - 1) {\n        padding[1] = (blockshape[1] % cell_shape == 0) ? cell_shape : blockshape[1] % cell_shape;\n      } else {\n        padding[1] = cell_shape;\n      }\n      token = *ip++;\n      uint8_t match_type = (token >> 3U);\n      if (token == 0) {    // no match\n        buffercpy = ip;\n        ip += padding[0] * padding[1];\n      } else if (token == (uint8_t) ((1U << 7U) | (1U << 6U))) {  // cell match\n        uint16_t offset = *((uint16_t *) ip);\n        buffercpy = ip - offset - 1;\n        ip += 2;\n      } else if (token == (uint8_t) (1U << 6U)) { // whole cell of same element\n        buffercpy = cell_aux;\n        memset(buffercpy, *ip, cell_size);\n        ip++;\n      } else if (match_type == 21) {    // triple match\n        buffercpy = local_buffer;\n        int row = (int) (token & 7);\n        uint16_t offset = *((uint16_t *) ip);\n        ip += 2;\n        for (int l = 0; l < 3; l++) {\n          memcpy(&buffercpy[(row + l) * cell_shape],\n                 ip - sizeof(token) - sizeof(offset) - offset + l * cell_shape, cell_shape);\n        }\n        for (int l = 0; l < cell_shape; l++) {\n          if ((l < row) || (l > row + 2)) {\n            memcpy(&buffercpy[l * cell_shape], ip, cell_shape);\n            ip += cell_shape;\n          }\n        }\n      } else if (match_type == 17) {    // pair match\n        buffercpy = local_buffer;\n        int row = (int) (token & 7);\n        uint16_t offset = *((uint16_t *) ip);\n        ip += 2;\n        for (int l = 0; l < 2; l++) {\n          memcpy(&buffercpy[(row + l) * cell_shape],\n                 ip - sizeof(token) - sizeof(offset) - offset + l * cell_shape, cell_shape);\n        }\n        for (int l = 0; l < cell_shape; l++) {\n          if ((l < row) || (l > row + 1)) {\n            memcpy(&buffercpy[l * cell_shape], ip, cell_shape);\n            ip += cell_shape;\n          }\n        }\n      } else {\n        free(local_buffer);\n        free(cell_aux);\n        BLOSC_TRACE_ERROR(\"Invalid token: %u at cell [%d, %d]\\n\", token, ii[0], ii[1]);\n        return BLOSC2_ERROR_FAILURE;\n      }\n\n      int32_t orig = ii[0] * cell_shape * blockshape[1] + ii[1] * cell_shape;\n      for (int32_t i = 0; i < (int32_t) cell_shape; i++) {\n        if (i < padding[0]) {\n          ind = orig + i * blockshape[1];\n          memcpy(&op[ind], buffercpy, padding[1]);\n        }\n        buffercpy += padding[1];\n      }\n      if (ind > output_len) {\n        free(local_buffer);\n        free(cell_aux);\n        BLOSC_TRACE_ERROR(\"Exceeding output size\");\n        return BLOSC2_ERROR_FAILURE;\n      }\n    }\n  }\n  ind += padding[1];\n\n  free(cell_aux);\n  free(local_buffer);\n\n  if (ind != (blockshape[0] * blockshape[1])) {\n    BLOSC_TRACE_ERROR(\"Output size is not compatible with embedded blockshape\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n  if (ind > output_len) {\n    BLOSC_TRACE_ERROR(\"Exceeding output size\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n\n  return (int) ind;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 260,
    "critical_vars": [
      "box->ops"
    ],
    "function": "*jp2_box_get",
    "filename": "jasper/CVE-2016-10250/CVE-2016-10250_CWE-476_bdfe95a6e81ffb4b2fad31a76b57943695beed20_jp2_cod.c.diff",
    "function_code": "jp2_box_t *jp2_box_get(jas_stream_t *in)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\tjas_stream_t *tmpstream;\n\tuint_fast32_t len;\n\tuint_fast64_t extlen;\n\tbool dataflag;\n\n\tbox = 0;\n\ttmpstream = 0;\n\n\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n\t\tgoto error;\n\t}\n\tbox->ops = &jp2_boxinfo_unk.ops;\n\tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n\t\tgoto error;\n\t}\n\tboxinfo = jp2_boxinfolookup(box->type);\n\tbox->info = boxinfo;\n\tbox->ops = &boxinfo->ops;\n\tbox->len = len;\n\tJAS_DBGLOG(10, (\n\t  \"preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\\n\",\n\t  '\"', boxinfo->name, '\"', box->type, box->len\n\t  ));\n\tif (box->len == 1) {\n\t\tif (jp2_getuint64(in, &extlen)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (extlen > 0xffffffffUL) {\n\t\t\tjas_eprintf(\"warning: cannot handle large 64-bit box length\\n\");\n\t\t\textlen = 0xffffffffUL;\n\t\t}\n\t\tbox->len = extlen;\n\t\tbox->datalen = extlen - JP2_BOX_HDRLEN(true);\n\t} else {\n\t\tbox->datalen = box->len - JP2_BOX_HDRLEN(false);\n\t}\n\tif (box->len != 0 && box->len < 8) {\n\t\tgoto error;\n\t}\n\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (jas_stream_copy(tmpstream, in, box->datalen)) {\n\t\t\t// Mark the box data as never having been constructed\n\t\t\t// so that we will not errantly attempt to destroy it later.\n\t\t\tbox->ops = &jp2_boxinfo_unk.ops;\n\t\t\tjas_eprintf(\"cannot copy box data\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_rewind(tmpstream);\n\n\t\tif (box->ops->getdata) {\n\t\t\tif ((*box->ops->getdata)(box, tmpstream)) {\n\t\t\t\tjas_eprintf(\"cannot parse box data\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\tif (jas_getdbglevel() >= 1) {\n\t\tjp2_box_dump(box, stderr);\n\t}\n\n\treturn box;\n\nerror:\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn 0;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 146,
    "critical_vars": [
      "info"
    ],
    "function": "*bmp_decode",
    "filename": "jasper/CVE-2016-8884/CVE-2016-8884_CWE-476_5d66894d2313e3f3469f19066e149e08ff076698_bmp_dec.c.diff",
    "function_code": "jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)\n{\n\tjas_image_t *image;\n\tbmp_hdr_t hdr;\n\tbmp_info_t *info;\n\tuint_fast16_t cmptno;\n\tjas_image_cmptparm_t cmptparms[3];\n\tjas_image_cmptparm_t *cmptparm;\n\tuint_fast16_t numcmpts;\n\tlong n;\n\n\tif (optstr) {\n\t\tjas_eprintf(\"warning: ignoring BMP decoder options\\n\");\n\t}\n\n\tjas_eprintf(\n\t  \"THE BMP FORMAT IS NOT FULLY SUPPORTED!\\n\"\n\t  \"THAT IS, THE JASPER SOFTWARE CANNOT DECODE ALL TYPES OF BMP DATA.\\n\"\n\t  \"IF YOU HAVE ANY PROBLEMS, PLEASE TRY CONVERTING YOUR IMAGE DATA\\n\"\n\t  \"TO THE PNM FORMAT, AND USING THIS FORMAT INSTEAD.\\n\"\n\t  );\n\n\t/* Read the bitmap header. */\n\tif (bmp_gethdr(in, &hdr)) {\n\t\tjas_eprintf(\"cannot get header\\n\");\n\t\treturn 0;\n\t}\n\tJAS_DBGLOG(1, (\n\t  \"BMP header: magic 0x%x; siz %d; res1 %d; res2 %d; off %d\\n\",\n\t  hdr.magic, hdr.siz, hdr.reserved1, hdr.reserved2, hdr.off\n\t  ));\n\n\t/* Read the bitmap information. */\n\tif (!(info = bmp_getinfo(in))) {\n\t\tjas_eprintf(\"cannot get info\\n\");\n\t\treturn 0;\n\t}\n\tJAS_DBGLOG(1,\n\t  (\"BMP information: len %d; width %d; height %d; numplanes %d; \"\n\t  \"depth %d; enctype %d; siz %d; hres %d; vres %d; numcolors %d; \"\n\t  \"mincolors %d\\n\", info->len, info->width, info->height, info->numplanes,\n\t  info->depth, info->enctype, info->siz, info->hres, info->vres,\n\t  info->numcolors, info->mincolors));\n\n\t/* Ensure that we support this type of BMP file. */\n\tif (!bmp_issupported(&hdr, info)) {\n\t\tjas_eprintf(\"error: unsupported BMP encoding\\n\");\n\t\tbmp_info_destroy(info);\n\t\treturn 0;\n\t}\n\n\t/* Skip over any useless data between the end of the palette\n\t  and start of the bitmap data. */\n\tif ((n = hdr.off - (BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN(info))) < 0) {\n\t\tjas_eprintf(\"error: possibly bad bitmap offset?\\n\");\n\t\treturn 0;\n\t}\n\tif (n > 0) {\n\t\tjas_eprintf(\"skipping unknown data in BMP file\\n\");\n\t\tif (bmp_gobble(in, n)) {\n\t\t\tbmp_info_destroy(info);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Get the number of components. */\n\tnumcmpts = bmp_numcmpts(info);\n\n\tfor (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,\n\t  ++cmptparm) {\n\t\tcmptparm->tlx = 0;\n\t\tcmptparm->tly = 0;\n\t\tcmptparm->hstep = 1;\n\t\tcmptparm->vstep = 1;\n\t\tcmptparm->width = info->width;\n\t\tcmptparm->height = info->height;\n\t\tcmptparm->prec = 8;\n\t\tcmptparm->sgnd = false;\n\t}\n\n\t/* Create image object. */\n\tif (!(image = jas_image_create(numcmpts, cmptparms,\n\t  JAS_CLRSPC_UNKNOWN))) {\n\t\tbmp_info_destroy(info);\n\t\treturn 0;\n\t}\n\n\tif (numcmpts == 3) {\n\t\tjas_image_setclrspc(image, JAS_CLRSPC_SRGB);\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));\n\t\tjas_image_setcmpttype(image, 1,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));\n\t\tjas_image_setcmpttype(image, 2,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));\n\t} else {\n\t\tjas_image_setclrspc(image, JAS_CLRSPC_SGRAY);\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));\n\t}\n\n\t/* Read the bitmap data. */\n\tif (bmp_getdata(in, info, image)) {\n\t\tbmp_info_destroy(info);\n\t\tjas_image_destroy(image);\n\t\treturn 0;\n\t}\n\n\tbmp_info_destroy(info);\n\n\treturn image;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 110,
    "critical_vars": [
      "image"
    ],
    "function": "*bmp_decode",
    "filename": "jasper/CVE-2016-8884/CVE-2016-8884_CWE-476_5d66894d2313e3f3469f19066e149e08ff076698_bmp_dec.c.diff",
    "function_code": "jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)\n{\n\tjas_image_t *image;\n\tbmp_hdr_t hdr;\n\tbmp_info_t *info;\n\tuint_fast16_t cmptno;\n\tjas_image_cmptparm_t cmptparms[3];\n\tjas_image_cmptparm_t *cmptparm;\n\tuint_fast16_t numcmpts;\n\tlong n;\n\n\tif (optstr) {\n\t\tjas_eprintf(\"warning: ignoring BMP decoder options\\n\");\n\t}\n\n\tjas_eprintf(\n\t  \"THE BMP FORMAT IS NOT FULLY SUPPORTED!\\n\"\n\t  \"THAT IS, THE JASPER SOFTWARE CANNOT DECODE ALL TYPES OF BMP DATA.\\n\"\n\t  \"IF YOU HAVE ANY PROBLEMS, PLEASE TRY CONVERTING YOUR IMAGE DATA\\n\"\n\t  \"TO THE PNM FORMAT, AND USING THIS FORMAT INSTEAD.\\n\"\n\t  );\n\n\t/* Read the bitmap header. */\n\tif (bmp_gethdr(in, &hdr)) {\n\t\tjas_eprintf(\"cannot get header\\n\");\n\t\treturn 0;\n\t}\n\tJAS_DBGLOG(1, (\n\t  \"BMP header: magic 0x%x; siz %d; res1 %d; res2 %d; off %d\\n\",\n\t  hdr.magic, hdr.siz, hdr.reserved1, hdr.reserved2, hdr.off\n\t  ));\n\n\t/* Read the bitmap information. */\n\tif (!(info = bmp_getinfo(in))) {\n\t\tjas_eprintf(\"cannot get info\\n\");\n\t\treturn 0;\n\t}\n\tJAS_DBGLOG(1,\n\t  (\"BMP information: len %d; width %d; height %d; numplanes %d; \"\n\t  \"depth %d; enctype %d; siz %d; hres %d; vres %d; numcolors %d; \"\n\t  \"mincolors %d\\n\", info->len, info->width, info->height, info->numplanes,\n\t  info->depth, info->enctype, info->siz, info->hres, info->vres,\n\t  info->numcolors, info->mincolors));\n\n\t/* Ensure that we support this type of BMP file. */\n\tif (!bmp_issupported(&hdr, info)) {\n\t\tjas_eprintf(\"error: unsupported BMP encoding\\n\");\n\t\tbmp_info_destroy(info);\n\t\treturn 0;\n\t}\n\n\t/* Skip over any useless data between the end of the palette\n\t  and start of the bitmap data. */\n\tif ((n = hdr.off - (BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN(info))) < 0) {\n\t\tjas_eprintf(\"error: possibly bad bitmap offset?\\n\");\n\t\treturn 0;\n\t}\n\tif (n > 0) {\n\t\tjas_eprintf(\"skipping unknown data in BMP file\\n\");\n\t\tif (bmp_gobble(in, n)) {\n\t\t\tbmp_info_destroy(info);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Get the number of components. */\n\tnumcmpts = bmp_numcmpts(info);\n\n\tfor (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,\n\t  ++cmptparm) {\n\t\tcmptparm->tlx = 0;\n\t\tcmptparm->tly = 0;\n\t\tcmptparm->hstep = 1;\n\t\tcmptparm->vstep = 1;\n\t\tcmptparm->width = info->width;\n\t\tcmptparm->height = info->height;\n\t\tcmptparm->prec = 8;\n\t\tcmptparm->sgnd = false;\n\t}\n\n\t/* Create image object. */\n\tif (!(image = jas_image_create(numcmpts, cmptparms,\n\t  JAS_CLRSPC_UNKNOWN))) {\n\t\tbmp_info_destroy(info);\n\t\treturn 0;\n\t}\n\n\tif (numcmpts == 3) {\n\t\tjas_image_setclrspc(image, JAS_CLRSPC_SRGB);\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));\n\t\tjas_image_setcmpttype(image, 1,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));\n\t\tjas_image_setcmpttype(image, 2,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));\n\t} else {\n\t\tjas_image_setclrspc(image, JAS_CLRSPC_SGRAY);\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));\n\t}\n\n\t/* Read the bitmap data. */\n\tif (bmp_getdata(in, info, image)) {\n\t\tbmp_info_destroy(info);\n\t\tjas_image_destroy(image);\n\t\treturn 0;\n\t}\n\n\tbmp_info_destroy(info);\n\n\treturn image;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 289,
    "critical_vars": [
      "readStatus"
    ],
    "function": "main",
    "filename": "graphite/CVE-2018-7999/CVE-2018-7999_CWE-476_db132b4731a9b4c9534144ba3a18e65b390e9ff6_featuremaptest.cpp.diff",
    "function_code": "int main(int argc, char * argv[])\n{\n    gr_face * face = 0;\n    try\n\t{\n\t\tif (argc != 2)\tthrow std::length_error(\"not enough arguments: need a backing font\");\n\n\t\tdummyFace = face_handle(argv[1]);\n\t\ttestFeatTable<FeatTableTestA>(testDataA, \"A\\n\");\n\t\ttestFeatTable<FeatTableTestB>(testDataB, \"B\\n\");\n\t\ttestFeatTable<FeatTableTestB>(testDataBunsorted, \"Bu\\n\");\n\t\ttestFeatTable<FeatTableTestC>(testDataCunsorted, \"C\\n\");\n\t\ttestFeatTable<FeatTableTestD>(testDataDunsorted, \"D\\n\");\n\t\ttestFeatTable<FeatTableTestE>(testDataE, \"E\\n\");\n\n\t\t// test a bad settings offset stradling the end of the table\n\t\tFeatureMap testFeatureMap;\n\t\tdummyFace.replace_table(TtfUtil::Tag::Feat, &testBadOffset, sizeof testBadOffset);\n\t\tface = gr_make_face_with_ops(&dummyFace, &face_handle::ops, gr_face_dumbRendering);\n\t\tbool readStatus = testFeatureMap.readFeats(*face);\n\t\ttestAssert(\"fail gracefully on bad table\", !readStatus);\n\t}\n\tcatch (std::exception & e)\n\t{\n\t\tfprintf(stderr, \"%s: %s\\n\", argv[0], e.what());\n\t\tgr_face_destroy(face);\n\t\treturn 1;\n\t}\n\n    gr_face_destroy(face);\n    return 0;\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 268,
    "critical_vars": [
      "dumb_font"
    ],
    "function": "GlyphCache::Loader::Loader",
    "filename": "graphite/CVE-2018-7999/CVE-2018-7999_CWE-476_db132b4731a9b4c9534144ba3a18e65b390e9ff6_GlyphCache.cpp.diff",
    "function_code": "GlyphCache::Loader::Loader(const Face & face, const bool dumb_font)\n: _head(face, Tag::head),\n  _hhea(face, Tag::hhea),\n  _hmtx(face, Tag::hmtx),\n  _glyf(face, Tag::glyf),\n  _loca(face, Tag::loca),\n  _long_fmt(false),\n  _has_boxes(false),\n  _num_glyphs_graphics(0),\n  _num_glyphs_attributes(0),\n  _num_attrs(0)\n{\n    if (!operator bool())\n        return;\n\n    const Face::Table maxp = Face::Table(face, Tag::maxp);\n    if (!maxp) { _head = Face::Table(); return; }\n\n    _num_glyphs_graphics = TtfUtil::GlyphCount(maxp);\n    // This will fail if the number of glyphs is wildly out of range.\n    if (_glyf && TtfUtil::LocaLookup(_num_glyphs_graphics-1, _loca, _loca.size(), _head) == size_t(-2))\n    {\n        _head = Face::Table();\n        return;\n    }\n\n    if (!dumb_font)\n    {\n        if ((m_pGlat = Face::Table(face, Tag::Glat, 0x00030000)) == NULL\n            || (m_pGloc = Face::Table(face, Tag::Gloc)) == NULL\n            || m_pGloc.size() < 8)\n        {\n            _head = Face::Table();\n            return;\n        }\n        const byte    * p = m_pGloc;\n        int       version = be::read<uint32>(p);\n        const uint16    flags = be::read<uint16>(p);\n        _num_attrs = be::read<uint16>(p);\n        // We can accurately calculate the number of attributed glyphs by\n        //  subtracting the length of the attribids array (numAttribs long if present)\n        //  and dividing by either 2 or 4 depending on shor or lonf format\n        _long_fmt              = flags & 1;\n        int tmpnumgattrs       = (m_pGloc.size()\n                                   - (p - m_pGloc)\n                                   - sizeof(uint16)*(flags & 0x2 ? _num_attrs : 0))\n                                       / (_long_fmt ? sizeof(uint32) : sizeof(uint16)) - 1;\n\n        if (version >= 0x00020000 || tmpnumgattrs < 0 || tmpnumgattrs > 65535\n            || _num_attrs == 0 || _num_attrs > 0x3000  // is this hard limit appropriate?\n            || _num_glyphs_graphics > tmpnumgattrs\n            || m_pGlat.size() < 4)\n        {\n            _head = Face::Table();\n            return;\n        }\n\n        _num_glyphs_attributes = static_cast<unsigned short>(tmpnumgattrs);\n        p = m_pGlat;\n        version = be::read<uint32>(p);\n        if (version >= 0x00040000 || (version >= 0x00030000 && m_pGlat.size() < 8))       // reject Glat tables that are too new\n        {\n            _head = Face::Table();\n            return;\n        }\n        else if (version >= 0x00030000)\n        {\n            unsigned int glatflags = be::read<uint32>(p);\n            _has_boxes = glatflags & 1;\n            // delete this once the compiler is fixed\n            _has_boxes = true;\n        }\n    }\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 268,
    "critical_vars": [
      "Glat",
      "Gloc",
      "m_pGlat",
      "m_pGloc",
      "face"
    ],
    "function": "GlyphCache::Loader::Loader",
    "filename": "graphite/CVE-2018-7999/CVE-2018-7999_CWE-476_db132b4731a9b4c9534144ba3a18e65b390e9ff6_GlyphCache.cpp.diff",
    "function_code": "GlyphCache::Loader::Loader(const Face & face)\n: _head(face, Tag::head),\n  _hhea(face, Tag::hhea),\n  _hmtx(face, Tag::hmtx),\n  _glyf(face, Tag::glyf),\n  _loca(face, Tag::loca),\n  _long_fmt(false),\n  _has_boxes(false),\n  _num_glyphs_graphics(0),\n  _num_glyphs_attributes(0),\n  _num_attrs(0)\n{\n    if (!operator bool())\n        return;\n\n    const Face::Table maxp = Face::Table(face, Tag::maxp);\n    if (!maxp) { _head = Face::Table(); return; }\n\n    _num_glyphs_graphics = TtfUtil::GlyphCount(maxp);\n    // This will fail if the number of glyphs is wildly out of range.\n    if (_glyf && TtfUtil::LocaLookup(_num_glyphs_graphics-1, _loca, _loca.size(), _head) == size_t(-2))\n    {\n        _head = Face::Table();\n        return;\n    }\n\n    if ((m_pGlat = Face::Table(face, Tag::Glat, 0x00030000)) == NULL\n        || (m_pGloc = Face::Table(face, Tag::Gloc)) == NULL\n        || m_pGloc.size() < 8)\n    {\n        _head = Face::Table();\n        return;\n    }\n    const byte    * p = m_pGloc;\n    int       version = be::read<uint32>(p);\n    const uint16    flags = be::read<uint16>(p);\n    _num_attrs = be::read<uint16>(p);\n    // We can accurately calculate the number of attributed glyphs by\n    //  subtracting the length of the attribids array (numAttribs long if present)\n    //  and dividing by either 2 or 4 depending on shor or lonf format\n    _long_fmt              = flags & 1;\n    int tmpnumgattrs       = (m_pGloc.size()\n                               - (p - m_pGloc)\n                               - sizeof(uint16)*(flags & 0x2 ? _num_attrs : 0))\n                                   / (_long_fmt ? sizeof(uint32) : sizeof(uint16)) - 1;\n\n    if (version >= 0x00020000 || tmpnumgattrs < 0 || tmpnumgattrs > 65535\n        || _num_attrs == 0 || _num_attrs > 0x3000  // is this hard limit appropriate?\n        || _num_glyphs_graphics > tmpnumgattrs\n        || m_pGlat.size() < 4)\n    {\n        _head = Face::Table();\n        return;\n    }\n\n    _num_glyphs_attributes = static_cast<unsigned short>(tmpnumgattrs);\n    p = m_pGlat;\n    version = be::read<uint32>(p);\n    if (version >= 0x00040000 || (version >= 0x00030000 && m_pGlat.size() < 8))       // reject Glat tables that are too new\n    {\n        _head = Face::Table();\n        return;\n    }\n    else if (version >= 0x00030000)\n    {\n        unsigned int glatflags = be::read<uint32>(p);\n        _has_boxes = glatflags & 1;\n        // delete this once the compiler is fixed\n        _has_boxes = true;\n    }\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 684,
    "critical_vars": [
      "error"
    ],
    "function": "vi_pci_write",
    "filename": "hyperkit/CVE-2021-32844/CVE-2021-32844_CWE-476_451558fe8aaa8b24e02e34106e3bb9fe41d7ad13_virtio.c.diff",
    "function_code": "vi_pci_write(UNUSED int vcpu, struct pci_devinst *pi, int baridx,\n\tuint64_t offset, int size, uint64_t value)\n{\n\tstruct virtio_softc *vs = pi->pi_arg;\n\tstruct vqueue_info *vq;\n\tstruct virtio_consts *vc;\n\tstruct config_reg *cr;\n\tuint64_t virtio_config_size, max;\n\tconst char *name;\n\tuint32_t newoff;\n\tint error;\n\n\tif (vs->vs_flags & VIRTIO_USE_MSIX) {\n\t\tif (baridx == pci_msix_table_bar(pi) ||\n\t\t    baridx == pci_msix_pba_bar(pi)) {\n\t\t\tpci_emul_msix_twrite(pi, offset, size, value);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* XXX probably should do something better than just assert() */\n\tassert(baridx == 0);\n\n\tif (vs->vs_mtx)\n\t\tpthread_mutex_lock(vs->vs_mtx);\n\n\tvc = vs->vs_vc;\n\tname = vc->vc_name;\n\n\tif (size != 1 && size != 2 && size != 4)\n\t\tgoto bad;\n\n\tif (pci_msix_enabled(pi))\n\t\tvirtio_config_size = VTCFG_R_CFG1;\n\telse\n\t\tvirtio_config_size = VTCFG_R_CFG0;\n\n\tif (offset >= virtio_config_size) {\n\t\t/*\n\t\t * Subtract off the standard size (including MSI-X\n\t\t * registers if enabled) and dispatch to underlying driver.\n\t\t */\n\t\tnewoff = (uint32_t) (offset - virtio_config_size);\n\t\tmax = vc->vc_cfgsize ? vc->vc_cfgsize : 0x100000000;\n\t\tif ((newoff + ((unsigned) size)) > max)\n\t\t\tgoto bad;\n\t\terror = (*vc->vc_cfgwrite)(DEV_SOFTC(vs), ((int) newoff), size,\n\t\t\t((uint32_t) value));\n\t\tif (!error)\n\t\t\tgoto done;\n\t}\n\nbad:\n\tcr = vi_find_cr((int) offset);\n\tif (cr == NULL || cr->cr_size != size || cr->cr_ro) {\n\t\tif (cr != NULL) {\n\t\t\t/* offset must be OK, wrong size and/or reg is R/O */\n\t\t\tif (cr->cr_size != size)\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"%s: write to %s: bad size %d\\r\\n\",\n\t\t\t\t    name, cr->cr_name, size);\n\t\t\tif (cr->cr_ro)\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"%s: write to read-only reg %s\\r\\n\",\n\t\t\t\t    name, cr->cr_name);\n\t\t} else {\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s: write to bad offset/size %jd/%d\\r\\n\",\n\t\t\t    name, (uintmax_t)offset, size);\n\t\t}\n\t\tgoto done;\n\t}\n\n\tswitch (offset) {\n\tcase VTCFG_R_GUESTCAP:\n\t\tvs->vs_negotiated_caps = (uint32_t) (value & vc->vc_hv_caps);\n\t\tif (vc->vc_apply_features)\n\t\t\t(*vc->vc_apply_features)(DEV_SOFTC(vs),\n\t\t\t    vs->vs_negotiated_caps);\n\t\tbreak;\n\tcase VTCFG_R_PFN:\n\t\tif (vs->vs_curq >= vc->vc_nvq)\n\t\t\tgoto bad_qindex;\n\t\tvi_vq_init(vs, ((uint32_t) value));\n\t\tbreak;\n\tcase VTCFG_R_QSEL:\n\t\t/*\n\t\t * Note that the guest is allowed to select an\n\t\t * invalid queue; we just need to return a QNUM\n\t\t * of 0 while the bad queue is selected.\n\t\t */\n\t\tvs->vs_curq = (int) value;\n\t\tbreak;\n\tcase VTCFG_R_QNOTIFY:\n\t\tif (value >= ((uint64_t) vc->vc_nvq)) {\n\t\t\tfprintf(stderr, \"%s: queue %d notify out of range\\r\\n\",\n\t\t\t\tname, (int)value);\n\t\t\tgoto done;\n\t\t}\n\t\tvq = &vs->vs_queues[value];\n\t\tif (vq->vq_notify)\n\t\t\t(*vq->vq_notify)(DEV_SOFTC(vs), vq);\n\t\telse if (vc->vc_qnotify)\n\t\t\t(*vc->vc_qnotify)(DEV_SOFTC(vs), vq);\n\t\telse\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s: qnotify queue %d: missing vq/vc notify\\r\\n\",\n\t\t\t\tname, (int)value);\n\t\tbreak;\n\tcase VTCFG_R_STATUS:\n\t\tvs->vs_status = (uint8_t) value;\n\t\tif (value == 0)\n\t\t\t(*vc->vc_reset)(DEV_SOFTC(vs));\n\t\tbreak;\n\tcase VTCFG_R_CFGVEC:\n\t\tvs->vs_msix_cfg_idx = (uint16_t) value;\n\t\tbreak;\n\tcase VTCFG_R_QVEC:\n\t\tif (vs->vs_curq >= vc->vc_nvq)\n\t\t\tgoto bad_qindex;\n\t\tvq = &vs->vs_queues[vs->vs_curq];\n\t\tvq->vq_msix_idx = (uint16_t) value;\n\t\tbreak;\n\t}\n\tgoto done;\n\nbad_qindex:\n\tfprintf(stderr,\n\t    \"%s: write config reg %s: curq %d >= max %d\\r\\n\",\n\t    name, cr->cr_name, vs->vs_curq, vc->vc_nvq);\ndone:\n\tif (vs->vs_mtx)\n\t\tpthread_mutex_unlock(vs->vs_mtx);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 684,
    "critical_vars": [
      "vc->vc_cfgwrite"
    ],
    "function": "vi_pci_write",
    "filename": "hyperkit/CVE-2021-32844/CVE-2021-32844_CWE-476_451558fe8aaa8b24e02e34106e3bb9fe41d7ad13_virtio.c.diff",
    "function_code": "vi_pci_write(UNUSED int vcpu, struct pci_devinst *pi, int baridx,\n\tuint64_t offset, int size, uint64_t value)\n{\n\tstruct virtio_softc *vs = pi->pi_arg;\n\tstruct vqueue_info *vq;\n\tstruct virtio_consts *vc;\n\tstruct config_reg *cr;\n\tuint64_t virtio_config_size, max;\n\tconst char *name;\n\tuint32_t newoff;\n\tint error;\n\n\tif (vs->vs_flags & VIRTIO_USE_MSIX) {\n\t\tif (baridx == pci_msix_table_bar(pi) ||\n\t\t    baridx == pci_msix_pba_bar(pi)) {\n\t\t\tpci_emul_msix_twrite(pi, offset, size, value);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* XXX probably should do something better than just assert() */\n\tassert(baridx == 0);\n\n\tif (vs->vs_mtx)\n\t\tpthread_mutex_lock(vs->vs_mtx);\n\n\tvc = vs->vs_vc;\n\tname = vc->vc_name;\n\n\tif (size != 1 && size != 2 && size != 4)\n\t\tgoto bad;\n\n\tif (pci_msix_enabled(pi))\n\t\tvirtio_config_size = VTCFG_R_CFG1;\n\telse\n\t\tvirtio_config_size = VTCFG_R_CFG0;\n\n\tif (offset >= virtio_config_size) {\n\t\t/*\n\t\t * Subtract off the standard size (including MSI-X\n\t\t * registers if enabled) and dispatch to underlying driver.\n\t\t */\n\t\tnewoff = (uint32_t) (offset - virtio_config_size);\n\t\tmax = vc->vc_cfgsize ? vc->vc_cfgsize : 0x100000000;\n\t\tif ((newoff + ((unsigned) size)) > max)\n\t\t\tgoto bad;\n\t\tif (vc->vc_cfgwrite != NULL)\n\t\t\terror = (*vc->vc_cfgwrite)(DEV_SOFTC(vs), ((int) newoff), size,\n\t\t\t\t((uint32_t) value));\n\t\telse\n\t\t\terror = 0;\n\t\tif (!error)\n\t\t\tgoto done;\n\t}\n\nbad:\n\tcr = vi_find_cr((int) offset);\n\tif (cr == NULL || cr->cr_size != size || cr->cr_ro) {\n\t\tif (cr != NULL) {\n\t\t\t/* offset must be OK, wrong size and/or reg is R/O */\n\t\t\tif (cr->cr_size != size)\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"%s: write to %s: bad size %d\\r\\n\",\n\t\t\t\t    name, cr->cr_name, size);\n\t\t\tif (cr->cr_ro)\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"%s: write to read-only reg %s\\r\\n\",\n\t\t\t\t    name, cr->cr_name);\n\t\t} else {\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s: write to bad offset/size %jd/%d\\r\\n\",\n\t\t\t    name, (uintmax_t)offset, size);\n\t\t}\n\t\tgoto done;\n\t}\n\n\tswitch (offset) {\n\tcase VTCFG_R_GUESTCAP:\n\t\tvs->vs_negotiated_caps = (uint32_t) (value & vc->vc_hv_caps);\n\t\tif (vc->vc_apply_features)\n\t\t\t(*vc->vc_apply_features)(DEV_SOFTC(vs),\n\t\t\t    vs->vs_negotiated_caps);\n\t\tbreak;\n\tcase VTCFG_R_PFN:\n\t\tif (vs->vs_curq >= vc->vc_nvq)\n\t\t\tgoto bad_qindex;\n\t\tvi_vq_init(vs, ((uint32_t) value));\n\t\tbreak;\n\tcase VTCFG_R_QSEL:\n\t\t/*\n\t\t * Note that the guest is allowed to select an\n\t\t * invalid queue; we just need to return a QNUM\n\t\t * of 0 while the bad queue is selected.\n\t\t */\n\t\tvs->vs_curq = (int) value;\n\t\tbreak;\n\tcase VTCFG_R_QNOTIFY:\n\t\tif (value >= ((uint64_t) vc->vc_nvq)) {\n\t\t\tfprintf(stderr, \"%s: queue %d notify out of range\\r\\n\",\n\t\t\t\tname, (int)value);\n\t\t\tgoto done;\n\t\t}\n\t\tvq = &vs->vs_queues[value];\n\t\tif (vq->vq_notify)\n\t\t\t(*vq->vq_notify)(DEV_SOFTC(vs), vq);\n\t\telse if (vc->vc_qnotify)\n\t\t\t(*vc->vc_qnotify)(DEV_SOFTC(vs), vq);\n\t\telse\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s: qnotify queue %d: missing vq/vc notify\\r\\n\",\n\t\t\t\tname, (int)value);\n\t\tbreak;\n\tcase VTCFG_R_STATUS:\n\t\tvs->vs_status = (uint8_t) value;\n\t\tif (value == 0)\n\t\t\t(*vc->vc_reset)(DEV_SOFTC(vs));\n\t\tbreak;\n\tcase VTCFG_R_CFGVEC:\n\t\tvs->vs_msix_cfg_idx = (uint16_t) value;\n\t\tbreak;\n\tcase VTCFG_R_QVEC:\n\t\tif (vs->vs_curq >= vc->vc_nvq)\n\t\t\tgoto bad_qindex;\n\t\tvq = &vs->vs_queues[vs->vs_curq];\n\t\tvq->vq_msix_idx = (uint16_t) value;\n\t\tbreak;\n\t}\n\tgoto done;\n\nbad_qindex:\n\tfprintf(stderr,\n\t    \"%s: write config reg %s: curq %d >= max %d\\r\\n\",\n\t    name, cr->cr_name, vs->vs_curq, vc->vc_nvq);\ndone:\n\tif (vs->vs_mtx)\n\t\tpthread_mutex_unlock(vs->vs_mtx);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 562,
    "critical_vars": [
      "error"
    ],
    "function": "vi_pci_read",
    "filename": "hyperkit/CVE-2021-32843/CVE-2021-32843_CWE-476_df0e46c7dbfd81a957d85e449ba41b52f6f7beb4_virtio.c.diff",
    "function_code": "vi_pci_read(UNUSED int vcpu, struct pci_devinst *pi, int baridx,\n\tuint64_t offset, int size)\n{\n\tstruct virtio_softc *vs = pi->pi_arg;\n\tstruct virtio_consts *vc;\n\tstruct config_reg *cr;\n\tuint64_t virtio_config_size, max;\n\tconst char *name;\n\tuint32_t newoff;\n\tuint32_t value;\n\tint error;\n\n\tif (vs->vs_flags & VIRTIO_USE_MSIX) {\n\t\tif (baridx == pci_msix_table_bar(pi) ||\n\t\t    baridx == pci_msix_pba_bar(pi)) {\n\t\t\treturn (pci_emul_msix_tread(pi, offset, size));\n\t\t}\n\t}\n\n\t/* XXX probably should do something better than just assert() */\n\tassert(baridx == 0);\n\n\tif (vs->vs_mtx)\n\t\tpthread_mutex_lock(vs->vs_mtx);\n\n\tvc = vs->vs_vc;\n\tname = vc->vc_name;\n\tvalue = size == 1 ? 0xff : size == 2 ? 0xffff : 0xffffffff;\n\n\tif (size != 1 && size != 2 && size != 4)\n\t\tgoto bad;\n\n\tif (pci_msix_enabled(pi))\n\t\tvirtio_config_size = VTCFG_R_CFG1;\n\telse\n\t\tvirtio_config_size = VTCFG_R_CFG0;\n\n\tif (offset >= virtio_config_size) {\n\t\t/*\n\t\t * Subtract off the standard size (including MSI-X\n\t\t * registers if enabled) and dispatch to underlying driver.\n\t\t * If that fails, fall into general code.\n\t\t */\n\t\tnewoff = (uint32_t) (offset - virtio_config_size);\n\t\tmax = vc->vc_cfgsize ? vc->vc_cfgsize : 0x100000000;\n\t\tif ((newoff + ((unsigned) size)) > max)\n\t\t\tgoto bad;\n\t\terror = (*vc->vc_cfgread)(DEV_SOFTC(vs), ((int) newoff), size, &value);\n\t\tif (!error)\n\t\t\tgoto done;\n\t}\n\nbad:\n\tcr = vi_find_cr((int) offset);\n\tif (cr == NULL || cr->cr_size != size) {\n\t\tif (cr != NULL) {\n\t\t\t/* offset must be OK, so size must be bad */\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s: read from %s: bad size %d\\r\\n\",\n\t\t\t    name, cr->cr_name, size);\n\t\t} else {\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s: read from bad offset/size %jd/%d\\r\\n\",\n\t\t\t    name, (uintmax_t)offset, size);\n\t\t}\n\t\tgoto done;\n\t}\n\n\tswitch (offset) {\n\tcase VTCFG_R_HOSTCAP:\n\t\tvalue = (uint32_t) vc->vc_hv_caps;\n\t\tbreak;\n\tcase VTCFG_R_GUESTCAP:\n\t\tvalue = vs->vs_negotiated_caps;\n\t\tbreak;\n\tcase VTCFG_R_PFN:\n\t\tif (vs->vs_curq < vc->vc_nvq)\n\t\t\tvalue = vs->vs_queues[vs->vs_curq].vq_pfn;\n\t\tbreak;\n\tcase VTCFG_R_QNUM:\n\t\tvalue = vs->vs_curq < vc->vc_nvq ?\n\t\t    vs->vs_queues[vs->vs_curq].vq_qsize : 0;\n\t\tbreak;\n\tcase VTCFG_R_QSEL:\n\t\tvalue = (uint32_t) (vs->vs_curq);\n\t\tbreak;\n\tcase VTCFG_R_QNOTIFY:\n\t\tvalue = 0;\t/* XXX */\n\t\tbreak;\n\tcase VTCFG_R_STATUS:\n\t\tvalue = vs->vs_status;\n\t\tbreak;\n\tcase VTCFG_R_ISR:\n\t\tvalue = vs->vs_isr;\n\t\tvs->vs_isr = 0;\t\t/* a read clears this flag */\n\t\tif (value)\n\t\t\tpci_lintr_deassert(pi);\n\t\tbreak;\n\tcase VTCFG_R_CFGVEC:\n\t\tvalue = vs->vs_msix_cfg_idx;\n\t\tbreak;\n\tcase VTCFG_R_QVEC:\n\t\tvalue = vs->vs_curq < vc->vc_nvq ?\n\t\t    vs->vs_queues[vs->vs_curq].vq_msix_idx :\n\t\t    VIRTIO_MSI_NO_VECTOR;\n\t\tbreak;\n\t}\ndone:\n\tif (vs->vs_mtx)\n\t\tpthread_mutex_unlock(vs->vs_mtx);\n\treturn (value);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 562,
    "critical_vars": [
      "vc->vc_cfgread"
    ],
    "function": "vi_pci_read",
    "filename": "hyperkit/CVE-2021-32843/CVE-2021-32843_CWE-476_df0e46c7dbfd81a957d85e449ba41b52f6f7beb4_virtio.c.diff",
    "function_code": "vi_pci_read(UNUSED int vcpu, struct pci_devinst *pi, int baridx,\n\tuint64_t offset, int size)\n{\n\tstruct virtio_softc *vs = pi->pi_arg;\n\tstruct virtio_consts *vc;\n\tstruct config_reg *cr;\n\tuint64_t virtio_config_size, max;\n\tconst char *name;\n\tuint32_t newoff;\n\tuint32_t value;\n\tint error;\n\n\tif (vs->vs_flags & VIRTIO_USE_MSIX) {\n\t\tif (baridx == pci_msix_table_bar(pi) ||\n\t\t    baridx == pci_msix_pba_bar(pi)) {\n\t\t\treturn (pci_emul_msix_tread(pi, offset, size));\n\t\t}\n\t}\n\n\t/* XXX probably should do something better than just assert() */\n\tassert(baridx == 0);\n\n\tif (vs->vs_mtx)\n\t\tpthread_mutex_lock(vs->vs_mtx);\n\n\tvc = vs->vs_vc;\n\tname = vc->vc_name;\n\tvalue = size == 1 ? 0xff : size == 2 ? 0xffff : 0xffffffff;\n\n\tif (size != 1 && size != 2 && size != 4)\n\t\tgoto bad;\n\n\tif (pci_msix_enabled(pi))\n\t\tvirtio_config_size = VTCFG_R_CFG1;\n\telse\n\t\tvirtio_config_size = VTCFG_R_CFG0;\n\n\tif (offset >= virtio_config_size) {\n\t\t/*\n\t\t * Subtract off the standard size (including MSI-X\n\t\t * registers if enabled) and dispatch to underlying driver.\n\t\t * If that fails, fall into general code.\n\t\t */\n\t\tnewoff = (uint32_t) (offset - virtio_config_size);\n\t\tmax = vc->vc_cfgsize ? vc->vc_cfgsize : 0x100000000;\n\t\tif ((newoff + ((unsigned) size)) > max)\n\t\t\tgoto bad;\n\t\tif (vc->vc_cfgread != NULL)\n\t\t\terror = (*vc->vc_cfgread)(DEV_SOFTC(vs), ((int) newoff), size, &value);\n\t\telse\n\t\t\terror = 0;\n\t\tif (!error)\n\t\t\tgoto done;\n\t}\n\nbad:\n\tcr = vi_find_cr((int) offset);\n\tif (cr == NULL || cr->cr_size != size) {\n\t\tif (cr != NULL) {\n\t\t\t/* offset must be OK, so size must be bad */\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s: read from %s: bad size %d\\r\\n\",\n\t\t\t    name, cr->cr_name, size);\n\t\t} else {\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s: read from bad offset/size %jd/%d\\r\\n\",\n\t\t\t    name, (uintmax_t)offset, size);\n\t\t}\n\t\tgoto done;\n\t}\n\n\tswitch (offset) {\n\tcase VTCFG_R_HOSTCAP:\n\t\tvalue = (uint32_t) vc->vc_hv_caps;\n\t\tbreak;\n\tcase VTCFG_R_GUESTCAP:\n\t\tvalue = vs->vs_negotiated_caps;\n\t\tbreak;\n\tcase VTCFG_R_PFN:\n\t\tif (vs->vs_curq < vc->vc_nvq)\n\t\t\tvalue = vs->vs_queues[vs->vs_curq].vq_pfn;\n\t\tbreak;\n\tcase VTCFG_R_QNUM:\n\t\tvalue = vs->vs_curq < vc->vc_nvq ?\n\t\t    vs->vs_queues[vs->vs_curq].vq_qsize : 0;\n\t\tbreak;\n\tcase VTCFG_R_QSEL:\n\t\tvalue = (uint32_t) (vs->vs_curq);\n\t\tbreak;\n\tcase VTCFG_R_QNOTIFY:\n\t\tvalue = 0;\t/* XXX */\n\t\tbreak;\n\tcase VTCFG_R_STATUS:\n\t\tvalue = vs->vs_status;\n\t\tbreak;\n\tcase VTCFG_R_ISR:\n\t\tvalue = vs->vs_isr;\n\t\tvs->vs_isr = 0;\t\t/* a read clears this flag */\n\t\tif (value)\n\t\t\tpci_lintr_deassert(pi);\n\t\tbreak;\n\tcase VTCFG_R_CFGVEC:\n\t\tvalue = vs->vs_msix_cfg_idx;\n\t\tbreak;\n\tcase VTCFG_R_QVEC:\n\t\tvalue = vs->vs_curq < vc->vc_nvq ?\n\t\t    vs->vs_queues[vs->vs_curq].vq_msix_idx :\n\t\t    VIRTIO_MSI_NO_VECTOR;\n\t\tbreak;\n\t}\ndone:\n\tif (vs->vs_mtx)\n\t\tpthread_mutex_unlock(vs->vs_mtx);\n\treturn (value);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 1853,
    "critical_vars": [
      "ext_port"
    ],
    "function": "GetOutboundPinholeTimeout",
    "filename": "miniupnp/CVE-2019-12108/CVE-2019-12108_CWE-476_86030db849260dd8fb2ed975b9890aef1b62b692_upnpsoap.c.diff",
    "function_code": "GetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<OutboundPinholeTimeout>%d</OutboundPinholeTimeout>\"\n\t\t\"</u:%sResponse>\";\n\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tchar * int_ip, * int_port, * rem_host, * rem_port, * protocol;\n\tint opt=0;\n\t/*int proto=0;*/\n\tunsigned short iport, rport;\n\n\tif (GETFLAG(IPV6FCFWDISABLEDMASK))\n\t{\n\t\tSoapError(h, 702, \"FirewallDisabled\");\n\t\treturn;\n\t}\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tint_ip = GetValueFromNameValueList(&data, \"InternalClient\");\n\tint_port = GetValueFromNameValueList(&data, \"InternalPort\");\n\trem_host = GetValueFromNameValueList(&data, \"RemoteHost\");\n\trem_port = GetValueFromNameValueList(&data, \"RemotePort\");\n\tprotocol = GetValueFromNameValueList(&data, \"Protocol\");\n\n\tif (!int_port || !ext_port || !protocol)\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n\n\trport = (unsigned short)atoi(rem_port);\n\tiport = (unsigned short)atoi(int_port);\n\t/*proto = atoi(protocol);*/\n\n\tsyslog(LOG_INFO, \"%s: retrieving timeout for outbound pinhole from [%s]:%hu to [%s]:%hu protocol %s\", action, int_ip, iport,rem_host, rport, protocol);\n\n\t/* TODO */\n\tr = -1;/*upnp_check_outbound_pinhole(proto, &opt);*/\n\n\tswitch(r)\n\t{\n\t\tcase 1:\t/* success */\n\t\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t\t                   action, ns/*\"urn:schemas-upnp-org:service:WANIPv6FirewallControl:1\"*/,\n\t\t\t                   opt, action);\n\t\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t\t\tbreak;\n\t\tcase -5:\t/* Protocol not supported */\n\t\t\tSoapError(h, 705, \"ProtocolNotSupported\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tSoapError(h, 501, \"ActionFailed\");\n\t}\n\tClearNameValueList(&data);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1853,
    "critical_vars": [
      "protocol",
      "ext_port",
      "int_port"
    ],
    "function": "GetOutboundPinholeTimeout",
    "filename": "miniupnp/CVE-2019-12108/CVE-2019-12108_CWE-476_13585f15c7f7dc28bbbba1661efb280d530d114c_upnpsoap.c.diff",
    "function_code": "GetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<OutboundPinholeTimeout>%d</OutboundPinholeTimeout>\"\n\t\t\"</u:%sResponse>\";\n\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tchar * int_ip, * int_port, * rem_host, * rem_port, * protocol;\n\tint opt=0;\n\t/*int proto=0;*/\n\tunsigned short iport, rport;\n\n\tif (GETFLAG(IPV6FCFWDISABLEDMASK))\n\t{\n\t\tSoapError(h, 702, \"FirewallDisabled\");\n\t\treturn;\n\t}\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tint_ip = GetValueFromNameValueList(&data, \"InternalClient\");\n\tint_port = GetValueFromNameValueList(&data, \"InternalPort\");\n\trem_host = GetValueFromNameValueList(&data, \"RemoteHost\");\n\trem_port = GetValueFromNameValueList(&data, \"RemotePort\");\n\tprotocol = GetValueFromNameValueList(&data, \"Protocol\");\n\n\tif (!int_port || !ext_port || !protocol)\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n\n\trport = (unsigned short)atoi(rem_port);\n\tiport = (unsigned short)atoi(int_port);\n\t/*proto = atoi(protocol);*/\n\n\tsyslog(LOG_INFO, \"%s: retrieving timeout for outbound pinhole from [%s]:%hu to [%s]:%hu protocol %s\", action, int_ip, iport,rem_host, rport, protocol);\n\n\t/* TODO */\n\tr = -1;/*upnp_check_outbound_pinhole(proto, &opt);*/\n\n\tswitch(r)\n\t{\n\t\tcase 1:\t/* success */\n\t\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t\t                   action, ns/*\"urn:schemas-upnp-org:service:WANIPv6FirewallControl:1\"*/,\n\t\t\t                   opt, action);\n\t\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t\t\tbreak;\n\t\tcase -5:\t/* Protocol not supported */\n\t\t\tSoapError(h, 705, \"ProtocolNotSupported\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tSoapError(h, 501, \"ActionFailed\");\n\t}\n\tClearNameValueList(&data);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 244,
    "critical_vars": [
      "file->file_type",
      "ctx"
    ],
    "function": "CompileKeymap",
    "filename": "libxkbcommon/CVE-2018-15855/CVE-2018-15855_CWE-476_917636b1d0d70205a13f89062b95e3a0fc31d4ff_keymap.c.diff",
    "function_code": "CompileKeymap(XkbFile *file, struct xkb_keymap *keymap, enum merge_mode merge)\n{\n    bool ok;\n    XkbFile *files[LAST_KEYMAP_FILE_TYPE + 1] = { NULL };\n    enum xkb_file_type type;\n    struct xkb_context *ctx = keymap->ctx;\n\n    /* Collect section files and check for duplicates. */\n    for (file = (XkbFile *) file->defs; file;\n         file = (XkbFile *) file->common.next) {\n        if (file->file_type < FIRST_KEYMAP_FILE_TYPE ||\n            file->file_type > LAST_KEYMAP_FILE_TYPE) {\n            log_err(ctx, \"Cannot define %s in a keymap file\\n\",\n                    xkb_file_type_to_string(file->file_type));\n            continue;\n        }\n\n        if (files[file->file_type]) {\n            log_err(ctx,\n                    \"More than one %s section in keymap file; \"\n                    \"All sections after the first ignored\\n\",\n                    xkb_file_type_to_string(file->file_type));\n            continue;\n        }\n\n        files[file->file_type] = file;\n    }\n\n    /*\n     * Check that all required section were provided.\n     * Report everything before failing.\n     */\n    ok = true;\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        if (files[type] == NULL) {\n            log_err(ctx, \"Required section %s missing from keymap\\n\",\n                    xkb_file_type_to_string(type));\n            ok = false;\n        }\n    }\n    if (!ok)\n        return false;\n\n    /* Compile sections. */\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        log_dbg(ctx, \"Compiling %s \\\"%s\\\"\\n\",\n                xkb_file_type_to_string(type), files[type]->name);\n\n        ok = compile_file_fns[type](files[type], keymap, merge);\n        if (!ok) {\n            log_err(ctx, \"Failed to compile %s\\n\",\n                    xkb_file_type_to_string(type));\n            return false;\n        }\n    }\n\n    return UpdateDerivedKeymapFields(keymap);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 244,
    "critical_vars": [
      "file->file_type"
    ],
    "function": "CompileKeymap",
    "filename": "libxkbcommon/CVE-2018-15855/CVE-2018-15855_CWE-476_917636b1d0d70205a13f89062b95e3a0fc31d4ff_keymap.c.diff",
    "function_code": "CompileKeymap(XkbFile *file, struct xkb_keymap *keymap, enum merge_mode merge)\n{\n    bool ok;\n    XkbFile *files[LAST_KEYMAP_FILE_TYPE + 1] = { NULL };\n    enum xkb_file_type type;\n    struct xkb_context *ctx = keymap->ctx;\n\n    /* Collect section files and check for duplicates. */\n    for (file = (XkbFile *) file->defs; file;\n         file = (XkbFile *) file->common.next) {\n        if (file->file_type < FIRST_KEYMAP_FILE_TYPE ||\n            file->file_type > LAST_KEYMAP_FILE_TYPE) {\n            if (file->file_type == FILE_TYPE_GEOMETRY) {\n                log_vrb(ctx, 1,\n                        \"Geometry sections are not supported; ignoring\\n\");\n            } else {\n                log_err(ctx, \"Cannot define %s in a keymap file\\n\",\n                        xkb_file_type_to_string(file->file_type));\n            }\n            continue;\n        }\n\n        if (files[file->file_type]) {\n            log_err(ctx,\n                    \"More than one %s section in keymap file; \"\n                    \"All sections after the first ignored\\n\",\n                    xkb_file_type_to_string(file->file_type));\n            continue;\n        }\n\n        files[file->file_type] = file;\n    }\n\n    /*\n     * Check that all required section were provided.\n     * Report everything before failing.\n     */\n    ok = true;\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        if (files[type] == NULL) {\n            log_err(ctx, \"Required section %s missing from keymap\\n\",\n                    xkb_file_type_to_string(type));\n            ok = false;\n        }\n    }\n    if (!ok)\n        return false;\n\n    /* Compile sections. */\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        log_dbg(ctx, \"Compiling %s \\\"%s\\\"\\n\",\n                xkb_file_type_to_string(type), files[type]->name);\n\n        ok = compile_file_fns[type](files[type], keymap, merge);\n        if (!ok) {\n            log_err(ctx, \"Failed to compile %s\\n\",\n                    xkb_file_type_to_string(type));\n            return false;\n        }\n    }\n\n    return UpdateDerivedKeymapFields(keymap);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 267,
    "critical_vars": [
      "pred_txt",
      "symInterpretMatchMaskNames",
      "pred_rtrn"
    ],
    "function": "ResolveStateAndPredicate",
    "filename": "libxkbcommon/CVE-2018-15863/CVE-2018-15863_CWE-476_96df3106d49438e442510c59acad306e94f3db4d_compat.c.diff",
    "function_code": "ResolveStateAndPredicate(ExprDef *expr, enum xkb_match_operation *pred_rtrn,\n                         xkb_mod_mask_t *mods_rtrn, CompatInfo *info)\n{\n    if (expr == NULL) {\n        *pred_rtrn = MATCH_ANY_OR_NONE;\n        *mods_rtrn = MOD_REAL_MASK_ALL;\n        return true;\n    }\n\n    *pred_rtrn = MATCH_EXACTLY;\n    if (expr->expr.op == EXPR_ACTION_DECL) {\n        const char *pred_txt = xkb_atom_text(info->ctx, expr->action.name);\n        if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn)) {\n            log_err(info->ctx,\n                    \"Illegal modifier predicate \\\"%s\\\"; Ignored\\n\", pred_txt);\n            return false;\n        }\n        expr = expr->action.args;\n    }\n    else if (expr->expr.op == EXPR_IDENT) {\n        const char *pred_txt = xkb_atom_text(info->ctx, expr->ident.ident);\n        if (pred_txt && istreq(pred_txt, \"any\")) {\n            *pred_rtrn = MATCH_ANY;\n            *mods_rtrn = MOD_REAL_MASK_ALL;\n            return true;\n        }\n    }\n\n    return ExprResolveModMask(info->ctx, expr, MOD_REAL, &info->mods,\n                              mods_rtrn);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 267,
    "critical_vars": [
      "expr->action.args",
      "pred_txt",
      "symInterpretMatchMaskNames",
      "pred_rtrn"
    ],
    "function": "ResolveStateAndPredicate",
    "filename": "libxkbcommon/CVE-2018-15863/CVE-2018-15863_CWE-476_96df3106d49438e442510c59acad306e94f3db4d_compat.c.diff",
    "function_code": "ResolveStateAndPredicate(ExprDef *expr, enum xkb_match_operation *pred_rtrn,\n                         xkb_mod_mask_t *mods_rtrn, CompatInfo *info)\n{\n    if (expr == NULL) {\n        *pred_rtrn = MATCH_ANY_OR_NONE;\n        *mods_rtrn = MOD_REAL_MASK_ALL;\n        return true;\n    }\n\n    *pred_rtrn = MATCH_EXACTLY;\n    if (expr->expr.op == EXPR_ACTION_DECL) {\n        const char *pred_txt = xkb_atom_text(info->ctx, expr->action.name);\n        if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn) ||\n            !expr->action.args) {\n            log_err(info->ctx,\n                    \"Illegal modifier predicate \\\"%s\\\"; Ignored\\n\", pred_txt);\n            return false;\n        }\n        expr = expr->action.args;\n    }\n    else if (expr->expr.op == EXPR_IDENT) {\n        const char *pred_txt = xkb_atom_text(info->ctx, expr->ident.ident);\n        if (pred_txt && istreq(pred_txt, \"any\")) {\n            *pred_rtrn = MATCH_ANY;\n            *mods_rtrn = MOD_REAL_MASK_ALL;\n            return true;\n        }\n    }\n\n    return ExprResolveModMask(info->ctx, expr, MOD_REAL, &info->mods,\n                              mods_rtrn);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 1168,
    "critical_vars": [
      "lvar->lv_from_outer"
    ],
    "function": "generate_loadvar",
    "filename": "vim/CVE-2022-2874/CVE-2022-2874_CWE-476_4875d6ab068f09df88d24d81de40dcd8d56e243d_vim9compile.c.diff",
    "function_code": "generate_loadvar(\n\tcctx_T\t\t*cctx,\n\tassign_dest_T\tdest,\n\tchar_u\t\t*name,\n\tlvar_T\t\t*lvar,\n\ttype_T\t\t*type)\n{\n    switch (dest)\n    {\n\tcase dest_option:\n\tcase dest_func_option:\n\t    generate_LOAD(cctx, ISN_LOADOPT, 0, name, type);\n\t    break;\n\tcase dest_global:\n\t    if (vim_strchr(name, AUTOLOAD_CHAR) == NULL)\n\t    {\n\t\tif (name[2] == NUL)\n\t\t    generate_instr_type(cctx, ISN_LOADGDICT, &t_dict_any);\n\t\telse\n\t\t    generate_LOAD(cctx, ISN_LOADG, 0, name + 2, type);\n\t    }\n\t    else\n\t\tgenerate_LOAD(cctx, ISN_LOADAUTO, 0, name, type);\n\t    break;\n\tcase dest_buffer:\n\t    generate_LOAD(cctx, ISN_LOADB, 0, name + 2, type);\n\t    break;\n\tcase dest_window:\n\t    generate_LOAD(cctx, ISN_LOADW, 0, name + 2, type);\n\t    break;\n\tcase dest_tab:\n\t    generate_LOAD(cctx, ISN_LOADT, 0, name + 2, type);\n\t    break;\n\tcase dest_script:\n\t    compile_load_scriptvar(cctx,\n\t\t\t\t  name + (name[1] == ':' ? 2 : 0), NULL, NULL);\n\t    break;\n\tcase dest_env:\n\t    // Include $ in the name here\n\t    generate_LOAD(cctx, ISN_LOADENV, 0, name, type);\n\t    break;\n\tcase dest_reg:\n\t    generate_LOAD(cctx, ISN_LOADREG, name[1], NULL, &t_string);\n\t    break;\n\tcase dest_vimvar:\n\t    generate_LOADV(cctx, name + 2);\n\t    break;\n\tcase dest_local:\n\t    if (lvar->lv_from_outer > 0)\n\t\tgenerate_LOADOUTER(cctx, lvar->lv_idx, lvar->lv_from_outer,\n\t\t\t\t\t\t\t\t\t type);\n\t    else\n\t\tgenerate_LOAD(cctx, ISN_LOAD, lvar->lv_idx, NULL, type);\n\t    break;\n\tcase dest_expr:\n\t    // list or dict value should already be on the stack.\n\t    break;\n    }\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1168,
    "critical_vars": [
      "cctx->ctx_skip"
    ],
    "function": "generate_loadvar",
    "filename": "vim/CVE-2022-2874/CVE-2022-2874_CWE-476_4875d6ab068f09df88d24d81de40dcd8d56e243d_vim9compile.c.diff",
    "function_code": "generate_loadvar(\n\tcctx_T\t\t*cctx,\n\tassign_dest_T\tdest,\n\tchar_u\t\t*name,\n\tlvar_T\t\t*lvar,\n\ttype_T\t\t*type)\n{\n    switch (dest)\n    {\n\tcase dest_option:\n\tcase dest_func_option:\n\t    generate_LOAD(cctx, ISN_LOADOPT, 0, name, type);\n\t    break;\n\tcase dest_global:\n\t    if (vim_strchr(name, AUTOLOAD_CHAR) == NULL)\n\t    {\n\t\tif (name[2] == NUL)\n\t\t    generate_instr_type(cctx, ISN_LOADGDICT, &t_dict_any);\n\t\telse\n\t\t    generate_LOAD(cctx, ISN_LOADG, 0, name + 2, type);\n\t    }\n\t    else\n\t\tgenerate_LOAD(cctx, ISN_LOADAUTO, 0, name, type);\n\t    break;\n\tcase dest_buffer:\n\t    generate_LOAD(cctx, ISN_LOADB, 0, name + 2, type);\n\t    break;\n\tcase dest_window:\n\t    generate_LOAD(cctx, ISN_LOADW, 0, name + 2, type);\n\t    break;\n\tcase dest_tab:\n\t    generate_LOAD(cctx, ISN_LOADT, 0, name + 2, type);\n\t    break;\n\tcase dest_script:\n\t    compile_load_scriptvar(cctx,\n\t\t\t\t  name + (name[1] == ':' ? 2 : 0), NULL, NULL);\n\t    break;\n\tcase dest_env:\n\t    // Include $ in the name here\n\t    generate_LOAD(cctx, ISN_LOADENV, 0, name, type);\n\t    break;\n\tcase dest_reg:\n\t    generate_LOAD(cctx, ISN_LOADREG, name[1], NULL, &t_string);\n\t    break;\n\tcase dest_vimvar:\n\t    generate_LOADV(cctx, name + 2);\n\t    break;\n\tcase dest_local:\n\t    if (cctx->ctx_skip != SKIP_YES)\n\t    {\n\t\tif (lvar->lv_from_outer > 0)\n\t\t    generate_LOADOUTER(cctx, lvar->lv_idx, lvar->lv_from_outer,\n\t\t\t\t\t\t\t\t\t type);\n\t\telse\n\t\t    generate_LOAD(cctx, ISN_LOAD, lvar->lv_idx, NULL, type);\n\t    }\n\t    break;\n\tcase dest_expr:\n\t    // list or dict value should already be on the stack.\n\t    break;\n    }\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 2390,
    "critical_vars": [
      "expr_end"
    ],
    "function": "eval0_retarg",
    "filename": "vim/CVE-2022-2231/CVE-2022-2231_CWE-476_79481367a457951aabd9501b510fd7e3eb29c3d8_eval.c.diff",
    "function_code": "eval0_retarg(\n    char_u\t*arg,\n    typval_T\t*rettv,\n    exarg_T\t*eap,\n    evalarg_T\t*evalarg,\n    char_u\t**retarg)\n{\n    int\t\tret;\n    char_u\t*p;\n    char_u\t*expr_end;\n    int\t\tdid_emsg_before = did_emsg;\n    int\t\tcalled_emsg_before = called_emsg;\n    int\t\tflags = evalarg == NULL ? 0 : evalarg->eval_flags;\n    int\t\tcheck_for_end = retarg == NULL;\n    int\t\tend_error = FALSE;\n\n    p = skipwhite(arg);\n    ret = eval1(&p, rettv, evalarg);\n    expr_end = p;\n    p = skipwhite(p);\n\n    // In Vim9 script a command block is not split at NL characters for\n    // commands using an expression argument.  Skip over a '#' comment to check\n    // for a following NL.  Require white space before the '#'.\n    if (in_vim9script() && p > expr_end && retarg == NULL)\n\twhile (*p == '#')\n\t{\n\t    char_u *nl = vim_strchr(p, NL);\n\n\t    if (nl == NULL)\n\t\tbreak;\n\t    p = skipwhite(nl + 1);\n\t    if (eap != NULL && *p != NUL)\n\t\teap->nextcmd = p;\n\t    check_for_end = FALSE;\n\t}\n\n    if (ret != FAIL && check_for_end)\n\tend_error = !ends_excmd2(arg, p);\n    if (ret == FAIL || end_error)\n    {\n\tif (ret != FAIL)\n\t    clear_tv(rettv);\n\t/*\n\t * Report the invalid expression unless the expression evaluation has\n\t * been cancelled due to an aborting error, an interrupt, or an\n\t * exception, or we already gave a more specific error.\n\t * Also check called_emsg for when using assert_fails().\n\t */\n\tif (!aborting()\n\t\t&& did_emsg == did_emsg_before\n\t\t&& called_emsg == called_emsg_before\n\t\t&& (flags & EVAL_CONSTANT) == 0\n\t\t&& (!in_vim9script() || !vim9_bad_comment(p)))\n\t{\n\t    if (end_error)\n\t\tsemsg(_(e_trailing_characters_str), p);\n\t    else\n\t\tsemsg(_(e_invalid_expression_str), arg);\n\t}\n\n\t// Some of the expression may not have been consumed.  Do not check for\n\t// a next command to avoid more errors, unless \"|\" is following, which\n\t// could only be a command separator.\n\tif (eap != NULL && skipwhite(p)[0] == '|' && skipwhite(p)[1] != '|')\n\t    eap->nextcmd = check_nextcmd(p);\n\treturn FAIL;\n    }\n\n    if (retarg != NULL)\n\t*retarg = p;\n    else if (check_for_end && eap != NULL)\n\tset_nextcmd(eap, p);\n\n    return ret;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 2391,
    "critical_vars": [
      "ret"
    ],
    "function": "eval0_retarg",
    "filename": "vim/CVE-2022-2231/CVE-2022-2231_CWE-476_79481367a457951aabd9501b510fd7e3eb29c3d8_eval.c.diff",
    "function_code": "eval0_retarg(\n    char_u\t*arg,\n    typval_T\t*rettv,\n    exarg_T\t*eap,\n    evalarg_T\t*evalarg,\n    char_u\t**retarg)\n{\n    int\t\tret;\n    char_u\t*p;\n    char_u\t*expr_end;\n    int\t\tdid_emsg_before = did_emsg;\n    int\t\tcalled_emsg_before = called_emsg;\n    int\t\tflags = evalarg == NULL ? 0 : evalarg->eval_flags;\n    int\t\tcheck_for_end = retarg == NULL;\n    int\t\tend_error = FALSE;\n\n    p = skipwhite(arg);\n    ret = eval1(&p, rettv, evalarg);\n\n    if (ret != FAIL)\n    {\n\texpr_end = p;\n\tp = skipwhite(p);\n\n\t// In Vim9 script a command block is not split at NL characters for\n\t// commands using an expression argument.  Skip over a '#' comment to\n\t// check for a following NL.  Require white space before the '#'.\n\tif (in_vim9script() && p > expr_end && retarg == NULL)\n\t    while (*p == '#')\n\t    {\n\t\tchar_u *nl = vim_strchr(p, NL);\n\n\t\tif (nl == NULL)\n\t\t    break;\n\t\tp = skipwhite(nl + 1);\n\t\tif (eap != NULL && *p != NUL)\n\t\t    eap->nextcmd = p;\n\t\tcheck_for_end = FALSE;\n\t    }\n\n\tif (check_for_end)\n\t    end_error = !ends_excmd2(arg, p);\n    }\n\n    if (ret == FAIL || end_error)\n    {\n\tif (ret != FAIL)\n\t    clear_tv(rettv);\n\t/*\n\t * Report the invalid expression unless the expression evaluation has\n\t * been cancelled due to an aborting error, an interrupt, or an\n\t * exception, or we already gave a more specific error.\n\t * Also check called_emsg for when using assert_fails().\n\t */\n\tif (!aborting()\n\t\t&& did_emsg == did_emsg_before\n\t\t&& called_emsg == called_emsg_before\n\t\t&& (flags & EVAL_CONSTANT) == 0\n\t\t&& (!in_vim9script() || !vim9_bad_comment(p)))\n\t{\n\t    if (end_error)\n\t\tsemsg(_(e_trailing_characters_str), p);\n\t    else\n\t\tsemsg(_(e_invalid_expression_str), arg);\n\t}\n\n\t// Some of the expression may not have been consumed.  Do not check for\n\t// a next command to avoid more errors, unless \"|\" is following, which\n\t// could only be a command separator.\n\tif (eap != NULL && p != NULL\n\t\t\t  &&  skipwhite(p)[0] == '|' && skipwhite(p)[1] != '|')\n\t    eap->nextcmd = check_nextcmd(p);\n\treturn FAIL;\n    }\n\n    if (retarg != NULL)\n\t*retarg = p;\n    else if (check_for_end && eap != NULL)\n\tset_nextcmd(eap, p);\n\n    return ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 98,
    "critical_vars": [
      "buffer"
    ],
    "function": "*realloc_buffer",
    "filename": "vim/CVE-2018-20786/CVE-2018-20786_CWE-476_cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8_termscreen.c.diff",
    "function_code": "static ScreenCell *realloc_buffer(VTermScreen *screen, ScreenCell *buffer, int new_rows, int new_cols)\n{\n  ScreenCell *new_buffer = vterm_allocator_malloc(screen->vt, sizeof(ScreenCell) * new_rows * new_cols);\n  int row, col;\n\n  for(row = 0; row < new_rows; row++) {\n    for(col = 0; col < new_cols; col++) {\n      ScreenCell *new_cell = new_buffer + row*new_cols + col;\n\n      if(buffer && row < screen->rows && col < screen->cols)\n        *new_cell = buffer[row * screen->cols + col];\n      else {\n        new_cell->chars[0] = 0;\n        new_cell->pen = screen->pen;\n      }\n    }\n  }\n\n  if(buffer)\n    vterm_allocator_free(screen->vt, buffer);\n\n  return new_buffer;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 99,
    "critical_vars": [
      "screen->vt",
      "buffer"
    ],
    "function": "*realloc_buffer",
    "filename": "vim/CVE-2018-20786/CVE-2018-20786_CWE-476_cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8_termscreen.c.diff",
    "function_code": "static ScreenCell *realloc_buffer(VTermScreen *screen, ScreenCell *buffer, int new_rows, int new_cols)\n{\n  ScreenCell *new_buffer = vterm_allocator_malloc(screen->vt, sizeof(ScreenCell) * new_rows * new_cols);\n  int row, col;\n\n  for(row = 0; row < new_rows; row++) {\n    for(col = 0; col < new_cols; col++) {\n      ScreenCell *new_cell = new_buffer + row*new_cols + col;\n\n      if(buffer && row < screen->rows && col < screen->cols)\n        *new_cell = buffer[row * screen->cols + col];\n      else {\n        new_cell->chars[0] = 0;\n        new_cell->pen = screen->pen;\n      }\n    }\n  }\n\n  vterm_allocator_free(screen->vt, buffer);\n\n  return new_buffer;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 521,
    "critical_vars": [
      "screen->sb_buffer"
    ],
    "function": "resize",
    "filename": "vim/CVE-2018-20786/CVE-2018-20786_CWE-476_cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8_termscreen.c.diff",
    "function_code": "static int resize(int new_rows, int new_cols, VTermPos *delta, void *user)\n{\n  VTermScreen *screen = user;\n\n  int is_altscreen = (screen->buffers[1] && screen->buffer == screen->buffers[1]);\n\n  int old_rows = screen->rows;\n  int old_cols = screen->cols;\n  int first_blank_row;\n\n  if(!is_altscreen && new_rows < old_rows) {\n    // Fewer rows - determine if we're going to scroll at all, and if so, push\n    // those lines to scrollback\n    VTermPos pos = { 0, 0 };\n    VTermPos cursor = screen->state->pos;\n    // Find the first blank row after the cursor.\n    for(pos.row = old_rows - 1; pos.row >= new_rows; pos.row--)\n      if(!vterm_screen_is_eol(screen, pos) || cursor.row == pos.row)\n        break;\n\n    first_blank_row = pos.row + 1;\n    if(first_blank_row > new_rows) {\n      VTermRect rect = {0,0,0,0};\n      rect.end_row   = old_rows;\n      rect.end_col   = old_cols;\n      scrollrect(rect, first_blank_row - new_rows, 0, user);\n      vterm_screen_flush_damage(screen);\n\n      delta->row -= first_blank_row - new_rows;\n    }\n  }\n\n  screen->buffers[0] = realloc_buffer(screen, screen->buffers[0], new_rows, new_cols);\n  if(screen->buffers[1])\n    screen->buffers[1] = realloc_buffer(screen, screen->buffers[1], new_rows, new_cols);\n\n  screen->buffer = is_altscreen ? screen->buffers[1] : screen->buffers[0];\n\n  screen->rows = new_rows;\n  screen->cols = new_cols;\n\n  if(screen->sb_buffer)\n    vterm_allocator_free(screen->vt, screen->sb_buffer);\n\n  screen->sb_buffer = vterm_allocator_malloc(screen->vt, sizeof(VTermScreenCell) * new_cols);\n\n  if(new_cols > old_cols) {\n    VTermRect rect;\n    rect.start_row = 0;\n    rect.end_row   = old_rows;\n    rect.start_col = old_cols;\n    rect.end_col   = new_cols;\n    damagerect(screen, rect);\n  }\n\n  if(new_rows > old_rows) {\n    if(!is_altscreen && screen->callbacks && screen->callbacks->sb_popline) {\n      int rows = new_rows - old_rows;\n      while(rows) {\n        VTermRect rect = {0,0,0,0};\n        VTermPos pos = { 0, 0 };\n        if(!(screen->callbacks->sb_popline(screen->cols, screen->sb_buffer, screen->cbdata)))\n          break;\n\n\trect.end_row   = screen->rows;\n\trect.end_col   = screen->cols;\n        scrollrect(rect, -1, 0, user);\n\n        for(pos.col = 0; pos.col < screen->cols; pos.col += screen->sb_buffer[pos.col].width)\n          vterm_screen_set_cell(screen, pos, screen->sb_buffer + pos.col);\n\n        rect.end_row = 1;\n        damagerect(screen, rect);\n\n        vterm_screen_flush_damage(screen);\n\n        rows--;\n        delta->row++;\n      }\n    }\n\n    {\n      VTermRect rect;\n      rect.start_row = old_rows;\n      rect.end_row   = new_rows;\n      rect.start_col = 0;\n      rect.end_col   = new_cols;\n      damagerect(screen, rect);\n    }\n  }\n\n  if(screen->callbacks && screen->callbacks->resize)\n    return (*screen->callbacks->resize)(new_rows, new_cols, screen->cbdata);\n\n  return 1;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 521,
    "critical_vars": [
      "screen->vt",
      "screen->sb_buffer"
    ],
    "function": "resize",
    "filename": "vim/CVE-2018-20786/CVE-2018-20786_CWE-476_cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8_termscreen.c.diff",
    "function_code": "static int resize(int new_rows, int new_cols, VTermPos *delta, void *user)\n{\n  VTermScreen *screen = user;\n\n  int is_altscreen = (screen->buffers[1] && screen->buffer == screen->buffers[1]);\n\n  int old_rows = screen->rows;\n  int old_cols = screen->cols;\n  int first_blank_row;\n\n  if(!is_altscreen && new_rows < old_rows) {\n    // Fewer rows - determine if we're going to scroll at all, and if so, push\n    // those lines to scrollback\n    VTermPos pos = { 0, 0 };\n    VTermPos cursor = screen->state->pos;\n    // Find the first blank row after the cursor.\n    for(pos.row = old_rows - 1; pos.row >= new_rows; pos.row--)\n      if(!vterm_screen_is_eol(screen, pos) || cursor.row == pos.row)\n        break;\n\n    first_blank_row = pos.row + 1;\n    if(first_blank_row > new_rows) {\n      VTermRect rect = {0,0,0,0};\n      rect.end_row   = old_rows;\n      rect.end_col   = old_cols;\n      scrollrect(rect, first_blank_row - new_rows, 0, user);\n      vterm_screen_flush_damage(screen);\n\n      delta->row -= first_blank_row - new_rows;\n    }\n  }\n\n  screen->buffers[0] = realloc_buffer(screen, screen->buffers[0], new_rows, new_cols);\n  if(screen->buffers[1])\n    screen->buffers[1] = realloc_buffer(screen, screen->buffers[1], new_rows, new_cols);\n\n  screen->buffer = is_altscreen ? screen->buffers[1] : screen->buffers[0];\n\n  screen->rows = new_rows;\n  screen->cols = new_cols;\n\n  vterm_allocator_free(screen->vt, screen->sb_buffer);\n\n  screen->sb_buffer = vterm_allocator_malloc(screen->vt, sizeof(VTermScreenCell) * new_cols);\n\n  if(new_cols > old_cols) {\n    VTermRect rect;\n    rect.start_row = 0;\n    rect.end_row   = old_rows;\n    rect.start_col = old_cols;\n    rect.end_col   = new_cols;\n    damagerect(screen, rect);\n  }\n\n  if(new_rows > old_rows) {\n    if(!is_altscreen && screen->callbacks && screen->callbacks->sb_popline) {\n      int rows = new_rows - old_rows;\n      while(rows) {\n        VTermRect rect = {0,0,0,0};\n        VTermPos pos = { 0, 0 };\n        if(!(screen->callbacks->sb_popline(screen->cols, screen->sb_buffer, screen->cbdata)))\n          break;\n\n\trect.end_row   = screen->rows;\n\trect.end_col   = screen->cols;\n        scrollrect(rect, -1, 0, user);\n\n        for(pos.col = 0; pos.col < screen->cols; pos.col += screen->sb_buffer[pos.col].width)\n          vterm_screen_set_cell(screen, pos, screen->sb_buffer + pos.col);\n\n        rect.end_row = 1;\n        damagerect(screen, rect);\n\n        vterm_screen_flush_damage(screen);\n\n        rows--;\n        delta->row++;\n      }\n    }\n\n    {\n      VTermRect rect;\n      rect.start_row = old_rows;\n      rect.end_row   = new_rows;\n      rect.start_col = 0;\n      rect.end_col   = new_cols;\n      damagerect(screen, rect);\n    }\n  }\n\n  if(screen->callbacks && screen->callbacks->resize)\n    return (*screen->callbacks->resize)(new_rows, new_cols, screen->cbdata);\n\n  return 1;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 655,
    "critical_vars": [
      "screen->buffer",
      "screen->sb_buffer"
    ],
    "function": "*screen_new",
    "filename": "vim/CVE-2018-20786/CVE-2018-20786_CWE-476_cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8_termscreen.c.diff",
    "function_code": "static VTermScreen *screen_new(VTerm *vt)\n{\n  VTermState *state = vterm_obtain_state(vt);\n  VTermScreen *screen;\n  int rows, cols;\n\n  if (state == NULL)\n    return NULL;\n  screen = vterm_allocator_malloc(vt, sizeof(VTermScreen));\n  if (screen == NULL)\n    return NULL;\n\n  vterm_get_size(vt, &rows, &cols);\n\n  screen->vt = vt;\n  screen->state = state;\n\n  screen->damage_merge = VTERM_DAMAGE_CELL;\n  screen->damaged.start_row = -1;\n  screen->pending_scrollrect.start_row = -1;\n\n  screen->rows = rows;\n  screen->cols = cols;\n\n  screen->callbacks = NULL;\n  screen->cbdata    = NULL;\n\n  screen->buffers[0] = realloc_buffer(screen, NULL, rows, cols);\n  screen->buffer = screen->buffers[0];\n  screen->sb_buffer = vterm_allocator_malloc(screen->vt, sizeof(VTermScreenCell) * cols);\n  if (screen->buffer == NULL || screen->sb_buffer == NULL)\n  {\n    vterm_screen_free(screen);\n    return NULL;\n  }\n\n  vterm_state_set_callbacks(screen->state, &state_cbs, screen);\n\n  return screen;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 3725,
    "critical_vars": [
      "vterm"
    ],
    "function": "create_vterm",
    "filename": "vim/CVE-2018-20786/CVE-2018-20786_CWE-476_cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8_terminal.c.diff",
    "function_code": "create_vterm(term_T *term, int rows, int cols)\n{\n    VTerm\t    *vterm;\n    VTermScreen\t    *screen;\n    VTermState\t    *state;\n    VTermValue\t    value;\n\n    vterm = vterm_new_with_allocator(rows, cols, &vterm_allocator, NULL);\n    term->tl_vterm = vterm;\n    screen = vterm_obtain_screen(vterm);\n    vterm_screen_set_callbacks(screen, &screen_callbacks, term);\n    /* TODO: depends on 'encoding'. */\n    vterm_set_utf8(vterm, 1);\n\n    init_default_colors(term);\n\n    vterm_state_set_default_colors(\n\t    vterm_obtain_state(vterm),\n\t    &term->tl_default_color.fg,\n\t    &term->tl_default_color.bg);\n\n    if (t_colors >= 16)\n\tvterm_state_set_bold_highbright(vterm_obtain_state(vterm), 1);\n\n    /* Required to initialize most things. */\n    vterm_screen_reset(screen, 1 /* hard */);\n\n    /* Allow using alternate screen. */\n    vterm_screen_enable_altscreen(screen, 1);\n\n    /* For unix do not use a blinking cursor.  In an xterm this causes the\n     * cursor to blink if it's blinking in the xterm.\n     * For Windows we respect the system wide setting. */\n#ifdef WIN3264\n    if (GetCaretBlinkTime() == INFINITE)\n\tvalue.boolean = 0;\n    else\n\tvalue.boolean = 1;\n#else\n    value.boolean = 0;\n#endif\n    state = vterm_obtain_state(vterm);\n    vterm_state_set_termprop(state, VTERM_PROP_CURSORBLINK, &value);\n    vterm_state_set_unrecognised_fallbacks(state, &parser_fallbacks, term);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 3719,
    "critical_vars": [
      "vterm"
    ],
    "function": "create_vterm",
    "filename": "vim/CVE-2018-20786/CVE-2018-20786_CWE-476_cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8_terminal.c.diff",
    "function_code": "create_vterm(term_T *term, int rows, int cols)\n{\n    VTerm\t    *vterm;\n    VTermScreen\t    *screen;\n    VTermState\t    *state;\n    VTermValue\t    value;\n\n    vterm = vterm_new_with_allocator(rows, cols, &vterm_allocator, NULL);\n    term->tl_vterm = vterm;\n    if (vterm == NULL)\n\treturn FAIL;\n\n    // Allocate screen and state here, so we can bail out if that fails.\n    state = vterm_obtain_state(vterm);\n    screen = vterm_obtain_screen(vterm);\n    if (state == NULL || screen == NULL)\n    {\n\tvterm_free(vterm);\n\treturn FAIL;\n    }\n\n    vterm_screen_set_callbacks(screen, &screen_callbacks, term);\n    /* TODO: depends on 'encoding'. */\n    vterm_set_utf8(vterm, 1);\n\n    init_default_colors(term);\n\n    vterm_state_set_default_colors(\n\t    state,\n\t    &term->tl_default_color.fg,\n\t    &term->tl_default_color.bg);\n\n    if (t_colors >= 16)\n\tvterm_state_set_bold_highbright(vterm_obtain_state(vterm), 1);\n\n    /* Required to initialize most things. */\n    vterm_screen_reset(screen, 1 /* hard */);\n\n    /* Allow using alternate screen. */\n    vterm_screen_enable_altscreen(screen, 1);\n\n    /* For unix do not use a blinking cursor.  In an xterm this causes the\n     * cursor to blink if it's blinking in the xterm.\n     * For Windows we respect the system wide setting. */\n#ifdef WIN3264\n    if (GetCaretBlinkTime() == INFINITE)\n\tvalue.boolean = 0;\n    else\n\tvalue.boolean = 1;\n#else\n    value.boolean = 0;\n#endif\n    vterm_state_set_termprop(state, VTERM_PROP_CURSORBLINK, &value);\n    vterm_state_set_unrecognised_fallbacks(state, &parser_fallbacks, term);\n\n    return OK;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 5632,
    "critical_vars": [
      "term->tl_cols",
      "term",
      "term->tl_rows"
    ],
    "function": "term_and_job_init",
    "filename": "vim/CVE-2018-20786/CVE-2018-20786_CWE-476_cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8_terminal.c.diff",
    "function_code": "term_and_job_init(\n\tterm_T\t    *term,\n\ttypval_T    *argvar,\n\tchar\t    **argv UNUSED,\n\tjobopt_T    *opt,\n\tjobopt_T    *orig_opt)\n{\n    WCHAR\t    *cmd_wchar = NULL;\n    WCHAR\t    *cwd_wchar = NULL;\n    WCHAR\t    *env_wchar = NULL;\n    channel_T\t    *channel = NULL;\n    job_T\t    *job = NULL;\n    DWORD\t    error;\n    HANDLE\t    jo = NULL;\n    HANDLE\t    child_process_handle;\n    HANDLE\t    child_thread_handle;\n    void\t    *winpty_err = NULL;\n    void\t    *spawn_config = NULL;\n    garray_T\t    ga_cmd, ga_env;\n    char_u\t    *cmd = NULL;\n\n    if (dyn_winpty_init(TRUE) == FAIL)\n\treturn FAIL;\n    ga_init2(&ga_cmd, (int)sizeof(char*), 20);\n    ga_init2(&ga_env, (int)sizeof(char*), 20);\n\n    if (argvar->v_type == VAR_STRING)\n    {\n\tcmd = argvar->vval.v_string;\n    }\n    else if (argvar->v_type == VAR_LIST)\n    {\n\tif (win32_build_cmd(argvar->vval.v_list, &ga_cmd) == FAIL)\n\t    goto failed;\n\tcmd = ga_cmd.ga_data;\n    }\n    if (cmd == NULL || *cmd == NUL)\n    {\n\tEMSG(_(e_invarg));\n\tgoto failed;\n    }\n\n    cmd_wchar = enc_to_utf16(cmd, NULL);\n    ga_clear(&ga_cmd);\n    if (cmd_wchar == NULL)\n\tgoto failed;\n    if (opt->jo_cwd != NULL)\n\tcwd_wchar = enc_to_utf16(opt->jo_cwd, NULL);\n\n    win32_build_env(opt->jo_env, &ga_env, TRUE);\n    env_wchar = ga_env.ga_data;\n\n    term->tl_winpty_config = winpty_config_new(0, &winpty_err);\n    if (term->tl_winpty_config == NULL)\n\tgoto failed;\n\n    winpty_config_set_mouse_mode(term->tl_winpty_config,\n\t\t\t\t\t\t    WINPTY_MOUSE_MODE_FORCE);\n    winpty_config_set_initial_size(term->tl_winpty_config,\n\t\t\t\t\t\t term->tl_cols, term->tl_rows);\n    term->tl_winpty = winpty_open(term->tl_winpty_config, &winpty_err);\n    if (term->tl_winpty == NULL)\n\tgoto failed;\n\n    spawn_config = winpty_spawn_config_new(\n\t    WINPTY_SPAWN_FLAG_AUTO_SHUTDOWN |\n\t\tWINPTY_SPAWN_FLAG_EXIT_AFTER_SHUTDOWN,\n\t    NULL,\n\t    cmd_wchar,\n\t    cwd_wchar,\n\t    env_wchar,\n\t    &winpty_err);\n    if (spawn_config == NULL)\n\tgoto failed;\n\n    channel = add_channel();\n    if (channel == NULL)\n\tgoto failed;\n\n    job = job_alloc();\n    if (job == NULL)\n\tgoto failed;\n    if (argvar->v_type == VAR_STRING)\n    {\n\tint argc;\n\n\tbuild_argv_from_string(cmd, &job->jv_argv, &argc);\n    }\n    else\n    {\n\tint argc;\n\n\tbuild_argv_from_list(argvar->vval.v_list, &job->jv_argv, &argc);\n    }\n\n    if (opt->jo_set & JO_IN_BUF)\n\tjob->jv_in_buf = buflist_findnr(opt->jo_io_buf[PART_IN]);\n\n    if (!winpty_spawn(term->tl_winpty, spawn_config, &child_process_handle,\n\t    &child_thread_handle, &error, &winpty_err))\n\tgoto failed;\n\n    channel_set_pipes(channel,\n\t(sock_T)CreateFileW(\n\t    winpty_conin_name(term->tl_winpty),\n\t    GENERIC_WRITE, 0, NULL,\n\t    OPEN_EXISTING, 0, NULL),\n\t(sock_T)CreateFileW(\n\t    winpty_conout_name(term->tl_winpty),\n\t    GENERIC_READ, 0, NULL,\n\t    OPEN_EXISTING, 0, NULL),\n\t(sock_T)CreateFileW(\n\t    winpty_conerr_name(term->tl_winpty),\n\t    GENERIC_READ, 0, NULL,\n\t    OPEN_EXISTING, 0, NULL));\n\n    /* Write lines with CR instead of NL. */\n    channel->ch_write_text_mode = TRUE;\n\n    jo = CreateJobObject(NULL, NULL);\n    if (jo == NULL)\n\tgoto failed;\n\n    if (!AssignProcessToJobObject(jo, child_process_handle))\n    {\n\t/* Failed, switch the way to terminate process with TerminateProcess. */\n\tCloseHandle(jo);\n\tjo = NULL;\n    }\n\n    winpty_spawn_config_free(spawn_config);\n    vim_free(cmd_wchar);\n    vim_free(cwd_wchar);\n    vim_free(env_wchar);\n\n    create_vterm(term, term->tl_rows, term->tl_cols);\n\n#if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)\n    if (opt->jo_set2 & JO2_ANSI_COLORS)\n\tset_vterm_palette(term->tl_vterm, opt->jo_ansi_colors);\n    else\n\tinit_vterm_ansi_colors(term->tl_vterm);\n#endif\n\n    channel_set_job(channel, job, opt);\n    job_set_options(job, opt);\n\n    job->jv_channel = channel;\n    job->jv_proc_info.hProcess = child_process_handle;\n    job->jv_proc_info.dwProcessId = GetProcessId(child_process_handle);\n    job->jv_job_object = jo;\n    job->jv_status = JOB_STARTED;\n    job->jv_tty_in = utf16_to_enc(\n\t    (short_u*)winpty_conin_name(term->tl_winpty), NULL);\n    job->jv_tty_out = utf16_to_enc(\n\t    (short_u*)winpty_conout_name(term->tl_winpty), NULL);\n    ++job->jv_refcount;\n    term->tl_job = job;\n\n    /* Redirecting stdout and stderr doesn't work at the job level.  Instead\n     * open the file here and handle it in.  opt->jo_io was changed in\n     * setup_job_options(), use the original flags here. */\n    if (orig_opt->jo_io[PART_OUT] == JIO_FILE)\n    {\n\tchar_u *fname = opt->jo_io_name[PART_OUT];\n\n\tch_log(channel, \"Opening output file %s\", fname);\n\tterm->tl_out_fd = mch_fopen((char *)fname, WRITEBIN);\n\tif (term->tl_out_fd == NULL)\n\t    EMSG2(_(e_notopen), fname);\n    }\n\n    return OK;\n\nfailed:\n    ga_clear(&ga_cmd);\n    ga_clear(&ga_env);\n    vim_free(cmd_wchar);\n    vim_free(cwd_wchar);\n    if (spawn_config != NULL)\n\twinpty_spawn_config_free(spawn_config);\n    if (channel != NULL)\n\tchannel_clear(channel);\n    if (job != NULL)\n    {\n\tjob->jv_channel = NULL;\n\tjob_cleanup(job);\n    }\n    term->tl_job = NULL;\n    if (jo != NULL)\n\tCloseHandle(jo);\n    if (term->tl_winpty != NULL)\n\twinpty_free(term->tl_winpty);\n    term->tl_winpty = NULL;\n    if (term->tl_winpty_config != NULL)\n\twinpty_config_free(term->tl_winpty_config);\n    term->tl_winpty_config = NULL;\n    if (winpty_err != NULL)\n    {\n\tchar_u *msg = utf16_to_enc(\n\t\t\t\t(short_u *)winpty_error_msg(winpty_err), NULL);\n\n\tEMSG(msg);\n\twinpty_error_free(winpty_err);\n    }\n    return FAIL;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 5646,
    "critical_vars": [
      "term->tl_cols",
      "term",
      "term->tl_rows"
    ],
    "function": "term_and_job_init",
    "filename": "vim/CVE-2018-20786/CVE-2018-20786_CWE-476_cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8_terminal.c.diff",
    "function_code": "term_and_job_init(\n\tterm_T\t    *term,\n\ttypval_T    *argvar,\n\tchar\t    **argv UNUSED,\n\tjobopt_T    *opt,\n\tjobopt_T    *orig_opt)\n{\n    WCHAR\t    *cmd_wchar = NULL;\n    WCHAR\t    *cwd_wchar = NULL;\n    WCHAR\t    *env_wchar = NULL;\n    channel_T\t    *channel = NULL;\n    job_T\t    *job = NULL;\n    DWORD\t    error;\n    HANDLE\t    jo = NULL;\n    HANDLE\t    child_process_handle;\n    HANDLE\t    child_thread_handle;\n    void\t    *winpty_err = NULL;\n    void\t    *spawn_config = NULL;\n    garray_T\t    ga_cmd, ga_env;\n    char_u\t    *cmd = NULL;\n\n    if (dyn_winpty_init(TRUE) == FAIL)\n\treturn FAIL;\n    ga_init2(&ga_cmd, (int)sizeof(char*), 20);\n    ga_init2(&ga_env, (int)sizeof(char*), 20);\n\n    if (argvar->v_type == VAR_STRING)\n    {\n\tcmd = argvar->vval.v_string;\n    }\n    else if (argvar->v_type == VAR_LIST)\n    {\n\tif (win32_build_cmd(argvar->vval.v_list, &ga_cmd) == FAIL)\n\t    goto failed;\n\tcmd = ga_cmd.ga_data;\n    }\n    if (cmd == NULL || *cmd == NUL)\n    {\n\tEMSG(_(e_invarg));\n\tgoto failed;\n    }\n\n    cmd_wchar = enc_to_utf16(cmd, NULL);\n    ga_clear(&ga_cmd);\n    if (cmd_wchar == NULL)\n\tgoto failed;\n    if (opt->jo_cwd != NULL)\n\tcwd_wchar = enc_to_utf16(opt->jo_cwd, NULL);\n\n    win32_build_env(opt->jo_env, &ga_env, TRUE);\n    env_wchar = ga_env.ga_data;\n\n    term->tl_winpty_config = winpty_config_new(0, &winpty_err);\n    if (term->tl_winpty_config == NULL)\n\tgoto failed;\n\n    winpty_config_set_mouse_mode(term->tl_winpty_config,\n\t\t\t\t\t\t    WINPTY_MOUSE_MODE_FORCE);\n    winpty_config_set_initial_size(term->tl_winpty_config,\n\t\t\t\t\t\t term->tl_cols, term->tl_rows);\n    term->tl_winpty = winpty_open(term->tl_winpty_config, &winpty_err);\n    if (term->tl_winpty == NULL)\n\tgoto failed;\n\n    spawn_config = winpty_spawn_config_new(\n\t    WINPTY_SPAWN_FLAG_AUTO_SHUTDOWN |\n\t\tWINPTY_SPAWN_FLAG_EXIT_AFTER_SHUTDOWN,\n\t    NULL,\n\t    cmd_wchar,\n\t    cwd_wchar,\n\t    env_wchar,\n\t    &winpty_err);\n    if (spawn_config == NULL)\n\tgoto failed;\n\n    channel = add_channel();\n    if (channel == NULL)\n\tgoto failed;\n\n    job = job_alloc();\n    if (job == NULL)\n\tgoto failed;\n    if (argvar->v_type == VAR_STRING)\n    {\n\tint argc;\n\n\tbuild_argv_from_string(cmd, &job->jv_argv, &argc);\n    }\n    else\n    {\n\tint argc;\n\n\tbuild_argv_from_list(argvar->vval.v_list, &job->jv_argv, &argc);\n    }\n\n    if (opt->jo_set & JO_IN_BUF)\n\tjob->jv_in_buf = buflist_findnr(opt->jo_io_buf[PART_IN]);\n\n    if (!winpty_spawn(term->tl_winpty, spawn_config, &child_process_handle,\n\t    &child_thread_handle, &error, &winpty_err))\n\tgoto failed;\n\n    channel_set_pipes(channel,\n\t(sock_T)CreateFileW(\n\t    winpty_conin_name(term->tl_winpty),\n\t    GENERIC_WRITE, 0, NULL,\n\t    OPEN_EXISTING, 0, NULL),\n\t(sock_T)CreateFileW(\n\t    winpty_conout_name(term->tl_winpty),\n\t    GENERIC_READ, 0, NULL,\n\t    OPEN_EXISTING, 0, NULL),\n\t(sock_T)CreateFileW(\n\t    winpty_conerr_name(term->tl_winpty),\n\t    GENERIC_READ, 0, NULL,\n\t    OPEN_EXISTING, 0, NULL));\n\n    /* Write lines with CR instead of NL. */\n    channel->ch_write_text_mode = TRUE;\n\n    jo = CreateJobObject(NULL, NULL);\n    if (jo == NULL)\n\tgoto failed;\n\n    if (!AssignProcessToJobObject(jo, child_process_handle))\n    {\n\t/* Failed, switch the way to terminate process with TerminateProcess. */\n\tCloseHandle(jo);\n\tjo = NULL;\n    }\n\n    winpty_spawn_config_free(spawn_config);\n    vim_free(cmd_wchar);\n    vim_free(cwd_wchar);\n    vim_free(env_wchar);\n\n    if (create_vterm(term, term->tl_rows, term->tl_cols) == FAIL)\n\tgoto failed;\n\n#if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)\n    if (opt->jo_set2 & JO2_ANSI_COLORS)\n\tset_vterm_palette(term->tl_vterm, opt->jo_ansi_colors);\n    else\n\tinit_vterm_ansi_colors(term->tl_vterm);\n#endif\n\n    channel_set_job(channel, job, opt);\n    job_set_options(job, opt);\n\n    job->jv_channel = channel;\n    job->jv_proc_info.hProcess = child_process_handle;\n    job->jv_proc_info.dwProcessId = GetProcessId(child_process_handle);\n    job->jv_job_object = jo;\n    job->jv_status = JOB_STARTED;\n    job->jv_tty_in = utf16_to_enc(\n\t    (short_u*)winpty_conin_name(term->tl_winpty), NULL);\n    job->jv_tty_out = utf16_to_enc(\n\t    (short_u*)winpty_conout_name(term->tl_winpty), NULL);\n    ++job->jv_refcount;\n    term->tl_job = job;\n\n    /* Redirecting stdout and stderr doesn't work at the job level.  Instead\n     * open the file here and handle it in.  opt->jo_io was changed in\n     * setup_job_options(), use the original flags here. */\n    if (orig_opt->jo_io[PART_OUT] == JIO_FILE)\n    {\n\tchar_u *fname = opt->jo_io_name[PART_OUT];\n\n\tch_log(channel, \"Opening output file %s\", fname);\n\tterm->tl_out_fd = mch_fopen((char *)fname, WRITEBIN);\n\tif (term->tl_out_fd == NULL)\n\t    EMSG2(_(e_notopen), fname);\n    }\n\n    return OK;\n\nfailed:\n    ga_clear(&ga_cmd);\n    ga_clear(&ga_env);\n    vim_free(cmd_wchar);\n    vim_free(cwd_wchar);\n    if (spawn_config != NULL)\n\twinpty_spawn_config_free(spawn_config);\n    if (channel != NULL)\n\tchannel_clear(channel);\n    if (job != NULL)\n    {\n\tjob->jv_channel = NULL;\n\tjob_cleanup(job);\n    }\n    term->tl_job = NULL;\n    if (jo != NULL)\n\tCloseHandle(jo);\n    if (term->tl_winpty != NULL)\n\twinpty_free(term->tl_winpty);\n    term->tl_winpty = NULL;\n    if (term->tl_winpty_config != NULL)\n\twinpty_config_free(term->tl_winpty_config);\n    term->tl_winpty_config = NULL;\n    if (winpty_err != NULL)\n    {\n\tchar_u *msg = utf16_to_enc(\n\t\t\t\t(short_u *)winpty_error_msg(winpty_err), NULL);\n\n\tEMSG(msg);\n\twinpty_error_free(winpty_err);\n    }\n    return FAIL;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 5713,
    "critical_vars": [
      "term->tl_cols",
      "term",
      "term->tl_rows"
    ],
    "function": "create_pty_only",
    "filename": "vim/CVE-2018-20786/CVE-2018-20786_CWE-476_cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8_terminal.c.diff",
    "function_code": "create_pty_only(term_T *term, jobopt_T *options)\n{\n    HANDLE\t    hPipeIn = INVALID_HANDLE_VALUE;\n    HANDLE\t    hPipeOut = INVALID_HANDLE_VALUE;\n    char\t    in_name[80], out_name[80];\n    channel_T\t    *channel = NULL;\n\n    create_vterm(term, term->tl_rows, term->tl_cols);\n\n    vim_snprintf(in_name, sizeof(in_name), \"\\\\\\\\.\\\\pipe\\\\vim-%d-in-%d\",\n\t    GetCurrentProcessId(),\n\t    curbuf->b_fnum);\n    hPipeIn = CreateNamedPipe(in_name, PIPE_ACCESS_OUTBOUND,\n\t    PIPE_TYPE_MESSAGE | PIPE_NOWAIT,\n\t    PIPE_UNLIMITED_INSTANCES,\n\t    0, 0, NMPWAIT_NOWAIT, NULL);\n    if (hPipeIn == INVALID_HANDLE_VALUE)\n\tgoto failed;\n\n    vim_snprintf(out_name, sizeof(out_name), \"\\\\\\\\.\\\\pipe\\\\vim-%d-out-%d\",\n\t    GetCurrentProcessId(),\n\t    curbuf->b_fnum);\n    hPipeOut = CreateNamedPipe(out_name, PIPE_ACCESS_INBOUND,\n\t    PIPE_TYPE_MESSAGE | PIPE_NOWAIT,\n\t    PIPE_UNLIMITED_INSTANCES,\n\t    0, 0, 0, NULL);\n    if (hPipeOut == INVALID_HANDLE_VALUE)\n\tgoto failed;\n\n    ConnectNamedPipe(hPipeIn, NULL);\n    ConnectNamedPipe(hPipeOut, NULL);\n\n    term->tl_job = job_alloc();\n    if (term->tl_job == NULL)\n\tgoto failed;\n    ++term->tl_job->jv_refcount;\n\n    /* behave like the job is already finished */\n    term->tl_job->jv_status = JOB_FINISHED;\n\n    channel = add_channel();\n    if (channel == NULL)\n\tgoto failed;\n    term->tl_job->jv_channel = channel;\n    channel->ch_keep_open = TRUE;\n    channel->ch_named_pipe = TRUE;\n\n    channel_set_pipes(channel,\n\t(sock_T)hPipeIn,\n\t(sock_T)hPipeOut,\n\t(sock_T)hPipeOut);\n    channel_set_job(channel, term->tl_job, options);\n    term->tl_job->jv_tty_in = vim_strsave((char_u*)in_name);\n    term->tl_job->jv_tty_out = vim_strsave((char_u*)out_name);\n\n    return OK;\n\nfailed:\n    if (hPipeIn != NULL)\n\tCloseHandle(hPipeIn);\n    if (hPipeOut != NULL)\n\tCloseHandle(hPipeOut);\n    return FAIL;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 5728,
    "critical_vars": [
      "term->tl_cols",
      "term",
      "term->tl_rows"
    ],
    "function": "create_pty_only",
    "filename": "vim/CVE-2018-20786/CVE-2018-20786_CWE-476_cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8_terminal.c.diff",
    "function_code": "create_pty_only(term_T *term, jobopt_T *options)\n{\n    HANDLE\t    hPipeIn = INVALID_HANDLE_VALUE;\n    HANDLE\t    hPipeOut = INVALID_HANDLE_VALUE;\n    char\t    in_name[80], out_name[80];\n    channel_T\t    *channel = NULL;\n\n    if (create_vterm(term, term->tl_rows, term->tl_cols) == FAIL)\n\treturn FAIL;\n\n    vim_snprintf(in_name, sizeof(in_name), \"\\\\\\\\.\\\\pipe\\\\vim-%d-in-%d\",\n\t    GetCurrentProcessId(),\n\t    curbuf->b_fnum);\n    hPipeIn = CreateNamedPipe(in_name, PIPE_ACCESS_OUTBOUND,\n\t    PIPE_TYPE_MESSAGE | PIPE_NOWAIT,\n\t    PIPE_UNLIMITED_INSTANCES,\n\t    0, 0, NMPWAIT_NOWAIT, NULL);\n    if (hPipeIn == INVALID_HANDLE_VALUE)\n\tgoto failed;\n\n    vim_snprintf(out_name, sizeof(out_name), \"\\\\\\\\.\\\\pipe\\\\vim-%d-out-%d\",\n\t    GetCurrentProcessId(),\n\t    curbuf->b_fnum);\n    hPipeOut = CreateNamedPipe(out_name, PIPE_ACCESS_INBOUND,\n\t    PIPE_TYPE_MESSAGE | PIPE_NOWAIT,\n\t    PIPE_UNLIMITED_INSTANCES,\n\t    0, 0, 0, NULL);\n    if (hPipeOut == INVALID_HANDLE_VALUE)\n\tgoto failed;\n\n    ConnectNamedPipe(hPipeIn, NULL);\n    ConnectNamedPipe(hPipeOut, NULL);\n\n    term->tl_job = job_alloc();\n    if (term->tl_job == NULL)\n\tgoto failed;\n    ++term->tl_job->jv_refcount;\n\n    /* behave like the job is already finished */\n    term->tl_job->jv_status = JOB_FINISHED;\n\n    channel = add_channel();\n    if (channel == NULL)\n\tgoto failed;\n    term->tl_job->jv_channel = channel;\n    channel->ch_keep_open = TRUE;\n    channel->ch_named_pipe = TRUE;\n\n    channel_set_pipes(channel,\n\t(sock_T)hPipeIn,\n\t(sock_T)hPipeOut,\n\t(sock_T)hPipeOut);\n    channel_set_job(channel, term->tl_job, options);\n    term->tl_job->jv_tty_in = vim_strsave((char_u*)in_name);\n    term->tl_job->jv_tty_out = vim_strsave((char_u*)out_name);\n\n    return OK;\n\nfailed:\n    if (hPipeIn != NULL)\n\tCloseHandle(hPipeIn);\n    if (hPipeOut != NULL)\n\tCloseHandle(hPipeOut);\n    return FAIL;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 3477,
    "critical_vars": [
      "c1"
    ],
    "function": "vgetorpeek",
    "filename": "vim/CVE-2023-1264/CVE-2023-1264_CWE-476_7ac5023a5f1a37baafbe1043645f97ba3443d9f6_getchar.c.diff",
    "function_code": "vgetorpeek(int advance)\n{\n    int\t\tc, c1;\n    int\t\ttimedout = FALSE;\t// waited for more than 'timeoutlen'\n\t\t\t\t\t// for mapping to complete or\n\t\t\t\t\t// 'ttimeoutlen' for complete key code\n    int\t\tmapdepth = 0;\t\t// check for recursive mapping\n    int\t\tmode_deleted = FALSE;   // set when mode has been deleted\n    int\t\tnew_wcol, new_wrow;\n#ifdef FEAT_GUI\n    int\t\tshape_changed = FALSE;  // adjusted cursor shape\n#endif\n    int\t\tn;\n    int\t\told_wcol, old_wrow;\n    int\t\twait_tb_len;\n\n    /*\n     * This function doesn't work very well when called recursively.  This may\n     * happen though, because of:\n     * 1. The call to add_to_showcmd().\tchar_avail() is then used to check if\n     * there is a character available, which calls this function.  In that\n     * case we must return NUL, to indicate no character is available.\n     * 2. A GUI callback function writes to the screen, causing a\n     * wait_return().\n     * Using \":normal\" can also do this, but it saves the typeahead buffer,\n     * thus it should be OK.  But don't get a key from the user then.\n     */\n    if (vgetc_busy > 0 && ex_normal_busy == 0)\n\treturn NUL;\n\n    ++vgetc_busy;\n\n    if (advance)\n    {\n\tKeyStuffed = FALSE;\n\ttypebuf_was_empty = FALSE;\n    }\n\n    init_typebuf();\n    start_stuff();\n    check_end_reg_executing(advance);\n    do\n    {\n/*\n * get a character: 1. from the stuffbuffer\n */\n\tif (typeahead_char != 0)\n\t{\n\t    c = typeahead_char;\n\t    if (advance)\n\t\ttypeahead_char = 0;\n\t}\n\telse\n\t    c = read_readbuffers(advance);\n\tif (c != NUL && !got_int)\n\t{\n\t    if (advance)\n\t    {\n\t\t// KeyTyped = FALSE;  When the command that stuffed something\n\t\t// was typed, behave like the stuffed command was typed.\n\t\t// needed for CTRL-W CTRL-] to open a fold, for example.\n\t\tKeyStuffed = TRUE;\n\t    }\n\t    if (typebuf.tb_no_abbr_cnt == 0)\n\t\ttypebuf.tb_no_abbr_cnt = 1;\t// no abbreviations now\n\t}\n\telse\n\t{\n\t    /*\n\t     * Loop until we either find a matching mapped key, or we\n\t     * are sure that it is not a mapped key.\n\t     * If a mapped key sequence is found we go back to the start to\n\t     * try re-mapping.\n\t     */\n\t    for (;;)\n\t    {\n\t\tlong\twait_time;\n\t\tint\tkeylen = 0;\n\t\tint\tshowcmd_idx;\n\t\tcheck_end_reg_executing(advance);\n\t\t/*\n\t\t * ui_breakcheck() is slow, don't use it too often when\n\t\t * inside a mapping.  But call it each time for typed\n\t\t * characters.\n\t\t */\n\t\tif (typebuf.tb_maplen)\n\t\t    line_breakcheck();\n\t\telse\n\t\t    ui_breakcheck();\t\t// check for CTRL-C\n\t\tif (got_int)\n\t\t{\n\t\t    // flush all input\n\t\t    c = inchar(typebuf.tb_buf, typebuf.tb_buflen - 1, 0L);\n\n\t\t    /*\n\t\t     * If inchar() returns TRUE (script file was active) or we\n\t\t     * are inside a mapping, get out of Insert mode.\n\t\t     * Otherwise we behave like having gotten a CTRL-C.\n\t\t     * As a result typing CTRL-C in insert mode will\n\t\t     * really insert a CTRL-C.\n\t\t     */\n\t\t    if ((c || typebuf.tb_maplen)\n\t\t\t\t     && (State & (MODE_INSERT | MODE_CMDLINE)))\n\t\t\tc = ESC;\n\t\t    else\n\t\t\tc = Ctrl_C;\n\t\t    flush_buffers(FLUSH_INPUT);\t// flush all typeahead\n\n\t\t    if (advance)\n\t\t    {\n\t\t\t// Also record this character, it might be needed to\n\t\t\t// get out of Insert mode.\n\t\t\t*typebuf.tb_buf = c;\n\t\t\tgotchars(typebuf.tb_buf, 1);\n\t\t    }\n\t\t    cmd_silent = FALSE;\n\n\t\t    break;\n\t\t}\n\t\telse if (typebuf.tb_len > 0)\n\t\t{\n\t\t    /*\n\t\t     * Check for a mapping in \"typebuf\".\n\t\t     */\n\t\t    map_result_T result = handle_mapping(\n\t\t\t\t\t\t&keylen, &timedout, &mapdepth);\n\n\t\t    if (result == map_result_retry)\n\t\t\t// try mapping again\n\t\t\tcontinue;\n\t\t    if (result == map_result_fail)\n\t\t    {\n\t\t\t// failed, use the outer loop\n\t\t\tc = -1;\n\t\t\tbreak;\n\t\t    }\n\t\t    if (result == map_result_get)\n\t\t    {\n/*\n * get a character: 2. from the typeahead buffer\n */\n\t\t\tc = typebuf.tb_buf[typebuf.tb_off];\n\t\t\tif (advance)\t// remove chars from tb_buf\n\t\t\t{\n\t\t\t    cmd_silent = (typebuf.tb_silent > 0);\n\t\t\t    if (typebuf.tb_maplen > 0)\n\t\t\t\tKeyTyped = FALSE;\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tKeyTyped = TRUE;\n\t\t\t\t// write char to script file(s)\n\t\t\t\tgotchars(typebuf.tb_buf\n\t\t\t\t\t\t + typebuf.tb_off, 1);\n\t\t\t    }\n\t\t\t    KeyNoremap = typebuf.tb_noremap[\n\t\t\t\t\t\t      typebuf.tb_off];\n\t\t\t    del_typebuf(1, 0);\n\t\t\t}\n\t\t\tbreak;  // got character, break the for loop\n\t\t    }\n\n\t\t    // not enough characters, get more\n\t\t}\n\n/*\n * get a character: 3. from the user - handle <Esc> in Insert mode\n */\n\t\t/*\n\t\t * Special case: if we get an <ESC> in Insert mode and there\n\t\t * are no more characters at once, we pretend to go out of\n\t\t * Insert mode.  This prevents the one second delay after\n\t\t * typing an <ESC>.  If we get something after all, we may\n\t\t * have to redisplay the mode. That the cursor is in the wrong\n\t\t * place does not matter.\n\t\t * Do not do this if the kitty keyboard protocol is used, every\n\t\t * <ESC> is the start of an escape sequence then.\n\t\t */\n\t\tc = 0;\n\t\tnew_wcol = curwin->w_wcol;\n\t\tnew_wrow = curwin->w_wrow;\n\t\tif (\t   advance\n\t\t\t&& typebuf.tb_len == 1\n\t\t\t&& typebuf.tb_buf[typebuf.tb_off] == ESC\n\t\t\t&& !no_mapping\n\t\t\t&& kitty_protocol_state != KKPS_ENABLED\n\t\t\t&& ex_normal_busy == 0\n\t\t\t&& typebuf.tb_maplen == 0\n\t\t\t&& (State & MODE_INSERT)\n\t\t\t&& (p_timeout\n\t\t\t    || (keylen == KEYLEN_PART_KEY && p_ttimeout))\n\t\t\t&& (c = inchar(typebuf.tb_buf + typebuf.tb_off\n\t\t\t\t\t       + typebuf.tb_len, 3, 25L)) == 0)\n\t\t{\n\t\t    colnr_T\tcol = 0;\n\t\t    char_u\t*ptr;\n\n\t\t    if (mode_displayed)\n\t\t    {\n\t\t\tunshowmode(TRUE);\n\t\t\tmode_deleted = TRUE;\n\t\t    }\n#ifdef FEAT_GUI\n\t\t    // may show a different cursor shape\n\t\t    if (gui.in_use && State != MODE_NORMAL && !cmd_silent)\n\t\t    {\n\t\t\tint\t    save_State;\n\n\t\t\tsave_State = State;\n\t\t\tState = MODE_NORMAL;\n\t\t\tgui_update_cursor(TRUE, FALSE);\n\t\t\tState = save_State;\n\t\t\tshape_changed = TRUE;\n\t\t    }\n#endif\n\t\t    validate_cursor();\n\t\t    old_wcol = curwin->w_wcol;\n\t\t    old_wrow = curwin->w_wrow;\n\n\t\t    // move cursor left, if possible\n\t\t    if (curwin->w_cursor.col != 0)\n\t\t    {\n\t\t\tif (curwin->w_wcol > 0)\n\t\t\t{\n\t\t\t    // After auto-indenting and no text is following,\n\t\t\t    // we are expecting to truncate the trailing\n\t\t\t    // white-space, so find the last non-white\n\t\t\t    // character -- webb\n\t\t\t    if (did_ai && *skipwhite(ml_get_curline()\n\t\t\t\t\t\t+ curwin->w_cursor.col) == NUL)\n\t\t\t    {\n\t\t\t\tchartabsize_T cts;\n\n\t\t\t\tcurwin->w_wcol = 0;\n\t\t\t\tptr = ml_get_curline();\n\t\t\t\tinit_chartabsize_arg(&cts, curwin,\n\t\t\t\t\t  curwin->w_cursor.lnum, 0, ptr, ptr);\n\t\t\t\twhile (cts.cts_ptr < ptr + curwin->w_cursor.col)\n\t\t\t\t{\n\t\t\t\t    if (!VIM_ISWHITE(*cts.cts_ptr))\n\t\t\t\t\tcurwin->w_wcol = cts.cts_vcol;\n\t\t\t\t    cts.cts_vcol += lbr_chartabsize(&cts);\n\t\t\t\t    if (has_mbyte)\n\t\t\t\t\tcts.cts_ptr +=\n\t\t\t\t\t\t   (*mb_ptr2len)(cts.cts_ptr);\n\t\t\t\t    else\n\t\t\t\t\t++cts.cts_ptr;\n\t\t\t\t}\n\t\t\t\tclear_chartabsize_arg(&cts);\n\n\t\t\t\tcurwin->w_wrow = curwin->w_cline_row\n\t\t\t\t\t   + curwin->w_wcol / curwin->w_width;\n\t\t\t\tcurwin->w_wcol %= curwin->w_width;\n\t\t\t\tcurwin->w_wcol += curwin_col_off();\n\t\t\t\tcol = 0;\t// no correction needed\n\t\t\t    }\n\t\t\t    else\n\t\t\t    {\n\t\t\t\t--curwin->w_wcol;\n\t\t\t\tcol = curwin->w_cursor.col - 1;\n\t\t\t    }\n\t\t\t}\n\t\t\telse if (curwin->w_p_wrap && curwin->w_wrow)\n\t\t\t{\n\t\t\t    --curwin->w_wrow;\n\t\t\t    curwin->w_wcol = curwin->w_width - 1;\n\t\t\t    col = curwin->w_cursor.col - 1;\n\t\t\t}\n\t\t\tif (has_mbyte && col > 0 && curwin->w_wcol > 0)\n\t\t\t{\n\t\t\t    // Correct when the cursor is on the right halve\n\t\t\t    // of a double-wide character.\n\t\t\t    ptr = ml_get_curline();\n\t\t\t    col -= (*mb_head_off)(ptr, ptr + col);\n\t\t\t    if ((*mb_ptr2cells)(ptr + col) > 1)\n\t\t\t\t--curwin->w_wcol;\n\t\t\t}\n\t\t    }\n\t\t    setcursor();\n\t\t    out_flush();\n\t\t    new_wcol = curwin->w_wcol;\n\t\t    new_wrow = curwin->w_wrow;\n\t\t    curwin->w_wcol = old_wcol;\n\t\t    curwin->w_wrow = old_wrow;\n\t\t}\n\t\tif (c < 0)\n\t\t    continue;\t// end of input script reached\n\n\t\t// Allow mapping for just typed characters. When we get here c\n\t\t// is the number of extra bytes and typebuf.tb_len is 1.\n\t\tfor (n = 1; n <= c; ++n)\n\t\t    typebuf.tb_noremap[typebuf.tb_off + n] = RM_YES;\n\t\ttypebuf.tb_len += c;\n\n\t\t// buffer full, don't map\n\t\tif (typebuf.tb_len >= typebuf.tb_maplen + MAXMAPLEN)\n\t\t{\n\t\t    timedout = TRUE;\n\t\t    continue;\n\t\t}\n\n\t\tif (ex_normal_busy > 0)\n\t\t{\n\t\t    static int tc = 0;\n\n\t\t    // No typeahead left and inside \":normal\".  Must return\n\t\t    // something to avoid getting stuck.  When an incomplete\n\t\t    // mapping is present, behave like it timed out.\n\t\t    if (typebuf.tb_len > 0)\n\t\t    {\n\t\t\ttimedout = TRUE;\n\t\t\tcontinue;\n\t\t    }\n\n\t\t    // When 'insertmode' is set, ESC just beeps in Insert\n\t\t    // mode.  Use CTRL-L to make edit() return.\n\t\t    // For the command line only CTRL-C always breaks it.\n\t\t    // For the cmdline window: Alternate between ESC and\n\t\t    // CTRL-C: ESC for most situations and CTRL-C to close the\n\t\t    // cmdline window.\n\t\t    if (p_im && (State & MODE_INSERT))\n\t\t\tc = Ctrl_L;\n#ifdef FEAT_TERMINAL\n\t\t    else if (terminal_is_active())\n\t\t\tc = K_CANCEL;\n#endif\n\t\t    else if ((State & MODE_CMDLINE)\n\t\t\t\t\t     || (cmdwin_type > 0 && tc == ESC))\n\t\t\tc = Ctrl_C;\n\t\t    else\n\t\t\tc = ESC;\n\t\t    tc = c;\n\t\t    // set a flag to indicate this wasn't a normal char\n\t\t    if (advance)\n\t\t\ttypebuf_was_empty = TRUE;\n\n\t\t    // return from main_loop()\n\t\t    if (pending_exmode_active)\n\t\t\texmode_active = EXMODE_NORMAL;\n\n\t\t    // no chars to block abbreviation for\n\t\t    typebuf.tb_no_abbr_cnt = 0;\n\n\t\t    break;\n\t\t}\n\n/*\n * get a character: 3. from the user - update display\n */\n\t\t// In insert mode a screen update is skipped when characters\n\t\t// are still available.  But when those available characters\n\t\t// are part of a mapping, and we are going to do a blocking\n\t\t// wait here.  Need to update the screen to display the\n\t\t// changed text so far. Also for when 'lazyredraw' is set and\n\t\t// redrawing was postponed because there was something in the\n\t\t// input buffer (e.g., termresponse).\n\t\tif (((State & MODE_INSERT) != 0 || p_lz)\n\t\t\t&& (State & MODE_CMDLINE) == 0\n\t\t\t&& advance && must_redraw != 0 && !need_wait_return)\n\t\t{\n\t\t    update_screen(0);\n\t\t    setcursor(); // put cursor back where it belongs\n\t\t}\n\n\t\t/*\n\t\t * If we have a partial match (and are going to wait for more\n\t\t * input from the user), show the partially matched characters\n\t\t * to the user with showcmd.\n\t\t */\n\t\tshowcmd_idx = 0;\n\t\tc1 = 0;\n\t\tif (typebuf.tb_len > 0 && advance && !exmode_active)\n\t\t{\n\t\t    if (((State & (MODE_NORMAL | MODE_INSERT))\n\t\t\t\t\t\t      || State == MODE_LANGMAP)\n\t\t\t    && State != MODE_HITRETURN)\n\t\t    {\n\t\t\t// this looks nice when typing a dead character map\n\t\t\tif (State & MODE_INSERT\n\t\t\t    && ptr2cells(typebuf.tb_buf + typebuf.tb_off\n\t\t\t\t\t\t   + typebuf.tb_len - 1) == 1)\n\t\t\t{\n\t\t\t    edit_putchar(typebuf.tb_buf[typebuf.tb_off\n\t\t\t\t\t\t+ typebuf.tb_len - 1], FALSE);\n\t\t\t    setcursor(); // put cursor back where it belongs\n\t\t\t    c1 = 1;\n\t\t\t}\n\t\t\t// need to use the col and row from above here\n\t\t\told_wcol = curwin->w_wcol;\n\t\t\told_wrow = curwin->w_wrow;\n\t\t\tcurwin->w_wcol = new_wcol;\n\t\t\tcurwin->w_wrow = new_wrow;\n\t\t\tpush_showcmd();\n\t\t\tif (typebuf.tb_len > SHOWCMD_COLS)\n\t\t\t    showcmd_idx = typebuf.tb_len - SHOWCMD_COLS;\n\t\t\twhile (showcmd_idx < typebuf.tb_len)\n\t\t\t    (void)add_to_showcmd(\n\t\t\t       typebuf.tb_buf[typebuf.tb_off + showcmd_idx++]);\n\t\t\tcurwin->w_wcol = old_wcol;\n\t\t\tcurwin->w_wrow = old_wrow;\n\t\t    }\n\n\t\t    // this looks nice when typing a dead character map\n\t\t    if ((State & MODE_CMDLINE)\n#if defined(FEAT_CRYPT) || defined(FEAT_EVAL)\n\t\t\t    && cmdline_star == 0\n#endif\n\t\t\t    && ptr2cells(typebuf.tb_buf + typebuf.tb_off\n\t\t\t\t\t\t   + typebuf.tb_len - 1) == 1)\n\t\t    {\n\t\t\tputcmdline(typebuf.tb_buf[typebuf.tb_off\n\t\t\t\t\t\t+ typebuf.tb_len - 1], FALSE);\n\t\t\tc1 = 1;\n\t\t    }\n\t\t}\n\n/*\n * get a character: 3. from the user - get it\n */\n\t\tif (typebuf.tb_len == 0)\n\t\t    // timedout may have been set if a mapping with empty RHS\n\t\t    // fully matched while longer mappings timed out.\n\t\t    timedout = FALSE;\n\n\t\tif (advance)\n\t\t{\n\t\t    if (typebuf.tb_len == 0\n\t\t\t    || !(p_timeout\n\t\t\t\t || (p_ttimeout && keylen == KEYLEN_PART_KEY)))\n\t\t\t// blocking wait\n\t\t\twait_time = -1L;\n\t\t    else if (keylen == KEYLEN_PART_KEY && p_ttm >= 0)\n\t\t\twait_time = p_ttm;\n\t\t    else\n\t\t\twait_time = p_tm;\n\t\t}\n\t\telse\n\t\t    wait_time = 0;\n\n\t\twait_tb_len = typebuf.tb_len;\n\t\tc = inchar(typebuf.tb_buf + typebuf.tb_off + typebuf.tb_len,\n\t\t\ttypebuf.tb_buflen - typebuf.tb_off - typebuf.tb_len - 1,\n\t\t\twait_time);\n\n\t\tif (showcmd_idx != 0)\n\t\t    pop_showcmd();\n\t\tif (c1 == 1)\n\t\t{\n\t\t    if (State & MODE_INSERT)\n\t\t\tedit_unputchar();\n\t\t    if (State & MODE_CMDLINE)\n\t\t\tunputcmdline();\n\t\t    else\n\t\t\tsetcursor();\t// put cursor back where it belongs\n\t\t}\n\n\t\tif (c < 0)\n\t\t    continue;\t\t// end of input script reached\n\t\tif (c == NUL)\t\t// no character available\n\t\t{\n\t\t    if (!advance)\n\t\t\tbreak;\n\t\t    if (wait_tb_len > 0)\t// timed out\n\t\t    {\n\t\t\ttimedout = TRUE;\n\t\t\tcontinue;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\t    // allow mapping for just typed characters\n\t\t    while (typebuf.tb_buf[typebuf.tb_off\n\t\t\t\t\t\t     + typebuf.tb_len] != NUL)\n\t\t\ttypebuf.tb_noremap[typebuf.tb_off\n\t\t\t\t\t\t + typebuf.tb_len++] = RM_YES;\n#ifdef HAVE_INPUT_METHOD\n\t\t    // Get IM status right after getting keys, not after the\n\t\t    // timeout for a mapping (focus may be lost by then).\n\t\t    vgetc_im_active = im_get_status();\n#endif\n\t\t}\n\t    }\t    // for (;;)\n\t}\t// if (!character from stuffbuf)\n\n\t// if advance is FALSE don't loop on NULs\n    } while ((c < 0 && c != K_CANCEL) || (advance && c == NUL));\n\n    /*\n     * The \"INSERT\" message is taken care of here:\n     *\t if we return an ESC to exit insert mode, the message is deleted\n     *\t if we don't return an ESC but deleted the message before, redisplay it\n     */\n    if (advance && p_smd && msg_silent == 0 && (State & MODE_INSERT))\n    {\n\tif (c == ESC && !mode_deleted && !no_mapping && mode_displayed)\n\t{\n\t    if (typebuf.tb_len && !KeyTyped)\n\t\tredraw_cmdline = TRUE;\t    // delete mode later\n\t    else\n\t\tunshowmode(FALSE);\n\t}\n\telse if (c != ESC && mode_deleted)\n\t{\n\t    if (typebuf.tb_len && !KeyTyped)\n\t\tredraw_cmdline = TRUE;\t    // show mode later\n\t    else\n\t\tshowmode();\n\t}\n    }\n#ifdef FEAT_GUI\n    // may unshow different cursor shape\n    if (gui.in_use && shape_changed)\n\tgui_update_cursor(TRUE, FALSE);\n#endif\n    if (timedout && c == ESC)\n    {\n\tchar_u nop_buf[3];\n\n\t// When recording there will be no timeout.  Add a <Nop> after the ESC\n\t// to avoid that it forms a key code with following characters.\n\tnop_buf[0] = K_SPECIAL;\n\tnop_buf[1] = KS_EXTRA;\n\tnop_buf[2] = KE_NOP;\n\tgotchars(nop_buf, 3);\n    }\n\n    --vgetc_busy;\n\n    return c;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 3477,
    "critical_vars": [
      "showing_partial"
    ],
    "function": "vgetorpeek",
    "filename": "vim/CVE-2023-1264/CVE-2023-1264_CWE-476_7ac5023a5f1a37baafbe1043645f97ba3443d9f6_getchar.c.diff",
    "function_code": "vgetorpeek(int advance)\n{\n    int\t\tc;\n    int\t\ttimedout = FALSE;\t// waited for more than 'timeoutlen'\n\t\t\t\t\t// for mapping to complete or\n\t\t\t\t\t// 'ttimeoutlen' for complete key code\n    int\t\tmapdepth = 0;\t\t// check for recursive mapping\n    int\t\tmode_deleted = FALSE;   // set when mode has been deleted\n    int\t\tnew_wcol, new_wrow;\n#ifdef FEAT_GUI\n    int\t\tshape_changed = FALSE;  // adjusted cursor shape\n#endif\n    int\t\tn;\n    int\t\told_wcol, old_wrow;\n    int\t\twait_tb_len;\n\n    /*\n     * This function doesn't work very well when called recursively.  This may\n     * happen though, because of:\n     * 1. The call to add_to_showcmd().\tchar_avail() is then used to check if\n     * there is a character available, which calls this function.  In that\n     * case we must return NUL, to indicate no character is available.\n     * 2. A GUI callback function writes to the screen, causing a\n     * wait_return().\n     * Using \":normal\" can also do this, but it saves the typeahead buffer,\n     * thus it should be OK.  But don't get a key from the user then.\n     */\n    if (vgetc_busy > 0 && ex_normal_busy == 0)\n\treturn NUL;\n\n    ++vgetc_busy;\n\n    if (advance)\n    {\n\tKeyStuffed = FALSE;\n\ttypebuf_was_empty = FALSE;\n    }\n\n    init_typebuf();\n    start_stuff();\n    check_end_reg_executing(advance);\n    do\n    {\n/*\n * get a character: 1. from the stuffbuffer\n */\n\tif (typeahead_char != 0)\n\t{\n\t    c = typeahead_char;\n\t    if (advance)\n\t\ttypeahead_char = 0;\n\t}\n\telse\n\t    c = read_readbuffers(advance);\n\tif (c != NUL && !got_int)\n\t{\n\t    if (advance)\n\t    {\n\t\t// KeyTyped = FALSE;  When the command that stuffed something\n\t\t// was typed, behave like the stuffed command was typed.\n\t\t// needed for CTRL-W CTRL-] to open a fold, for example.\n\t\tKeyStuffed = TRUE;\n\t    }\n\t    if (typebuf.tb_no_abbr_cnt == 0)\n\t\ttypebuf.tb_no_abbr_cnt = 1;\t// no abbreviations now\n\t}\n\telse\n\t{\n\t    /*\n\t     * Loop until we either find a matching mapped key, or we\n\t     * are sure that it is not a mapped key.\n\t     * If a mapped key sequence is found we go back to the start to\n\t     * try re-mapping.\n\t     */\n\t    for (;;)\n\t    {\n\t\tlong\twait_time;\n\t\tint\tkeylen = 0;\n\t\tint\tshowcmd_idx;\n\t\tcheck_end_reg_executing(advance);\n\t\t/*\n\t\t * ui_breakcheck() is slow, don't use it too often when\n\t\t * inside a mapping.  But call it each time for typed\n\t\t * characters.\n\t\t */\n\t\tif (typebuf.tb_maplen)\n\t\t    line_breakcheck();\n\t\telse\n\t\t    ui_breakcheck();\t\t// check for CTRL-C\n\t\tif (got_int)\n\t\t{\n\t\t    // flush all input\n\t\t    c = inchar(typebuf.tb_buf, typebuf.tb_buflen - 1, 0L);\n\n\t\t    /*\n\t\t     * If inchar() returns TRUE (script file was active) or we\n\t\t     * are inside a mapping, get out of Insert mode.\n\t\t     * Otherwise we behave like having gotten a CTRL-C.\n\t\t     * As a result typing CTRL-C in insert mode will\n\t\t     * really insert a CTRL-C.\n\t\t     */\n\t\t    if ((c || typebuf.tb_maplen)\n\t\t\t\t     && (State & (MODE_INSERT | MODE_CMDLINE)))\n\t\t\tc = ESC;\n\t\t    else\n\t\t\tc = Ctrl_C;\n\t\t    flush_buffers(FLUSH_INPUT);\t// flush all typeahead\n\n\t\t    if (advance)\n\t\t    {\n\t\t\t// Also record this character, it might be needed to\n\t\t\t// get out of Insert mode.\n\t\t\t*typebuf.tb_buf = c;\n\t\t\tgotchars(typebuf.tb_buf, 1);\n\t\t    }\n\t\t    cmd_silent = FALSE;\n\n\t\t    break;\n\t\t}\n\t\telse if (typebuf.tb_len > 0)\n\t\t{\n\t\t    /*\n\t\t     * Check for a mapping in \"typebuf\".\n\t\t     */\n\t\t    map_result_T result = handle_mapping(\n\t\t\t\t\t\t&keylen, &timedout, &mapdepth);\n\n\t\t    if (result == map_result_retry)\n\t\t\t// try mapping again\n\t\t\tcontinue;\n\t\t    if (result == map_result_fail)\n\t\t    {\n\t\t\t// failed, use the outer loop\n\t\t\tc = -1;\n\t\t\tbreak;\n\t\t    }\n\t\t    if (result == map_result_get)\n\t\t    {\n/*\n * get a character: 2. from the typeahead buffer\n */\n\t\t\tc = typebuf.tb_buf[typebuf.tb_off];\n\t\t\tif (advance)\t// remove chars from tb_buf\n\t\t\t{\n\t\t\t    cmd_silent = (typebuf.tb_silent > 0);\n\t\t\t    if (typebuf.tb_maplen > 0)\n\t\t\t\tKeyTyped = FALSE;\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tKeyTyped = TRUE;\n\t\t\t\t// write char to script file(s)\n\t\t\t\tgotchars(typebuf.tb_buf\n\t\t\t\t\t\t + typebuf.tb_off, 1);\n\t\t\t    }\n\t\t\t    KeyNoremap = typebuf.tb_noremap[\n\t\t\t\t\t\t      typebuf.tb_off];\n\t\t\t    del_typebuf(1, 0);\n\t\t\t}\n\t\t\tbreak;  // got character, break the for loop\n\t\t    }\n\n\t\t    // not enough characters, get more\n\t\t}\n\n/*\n * get a character: 3. from the user - handle <Esc> in Insert mode\n */\n\t\t/*\n\t\t * Special case: if we get an <ESC> in Insert mode and there\n\t\t * are no more characters at once, we pretend to go out of\n\t\t * Insert mode.  This prevents the one second delay after\n\t\t * typing an <ESC>.  If we get something after all, we may\n\t\t * have to redisplay the mode. That the cursor is in the wrong\n\t\t * place does not matter.\n\t\t * Do not do this if the kitty keyboard protocol is used, every\n\t\t * <ESC> is the start of an escape sequence then.\n\t\t */\n\t\tc = 0;\n\t\tnew_wcol = curwin->w_wcol;\n\t\tnew_wrow = curwin->w_wrow;\n\t\tif (\t   advance\n\t\t\t&& typebuf.tb_len == 1\n\t\t\t&& typebuf.tb_buf[typebuf.tb_off] == ESC\n\t\t\t&& !no_mapping\n\t\t\t&& kitty_protocol_state != KKPS_ENABLED\n\t\t\t&& ex_normal_busy == 0\n\t\t\t&& typebuf.tb_maplen == 0\n\t\t\t&& (State & MODE_INSERT)\n\t\t\t&& (p_timeout\n\t\t\t    || (keylen == KEYLEN_PART_KEY && p_ttimeout))\n\t\t\t&& (c = inchar(typebuf.tb_buf + typebuf.tb_off\n\t\t\t\t\t       + typebuf.tb_len, 3, 25L)) == 0)\n\t\t{\n\t\t    colnr_T\tcol = 0;\n\t\t    char_u\t*ptr;\n\n\t\t    if (mode_displayed)\n\t\t    {\n\t\t\tunshowmode(TRUE);\n\t\t\tmode_deleted = TRUE;\n\t\t    }\n#ifdef FEAT_GUI\n\t\t    // may show a different cursor shape\n\t\t    if (gui.in_use && State != MODE_NORMAL && !cmd_silent)\n\t\t    {\n\t\t\tint\t    save_State;\n\n\t\t\tsave_State = State;\n\t\t\tState = MODE_NORMAL;\n\t\t\tgui_update_cursor(TRUE, FALSE);\n\t\t\tState = save_State;\n\t\t\tshape_changed = TRUE;\n\t\t    }\n#endif\n\t\t    validate_cursor();\n\t\t    old_wcol = curwin->w_wcol;\n\t\t    old_wrow = curwin->w_wrow;\n\n\t\t    // move cursor left, if possible\n\t\t    if (curwin->w_cursor.col != 0)\n\t\t    {\n\t\t\tif (curwin->w_wcol > 0)\n\t\t\t{\n\t\t\t    // After auto-indenting and no text is following,\n\t\t\t    // we are expecting to truncate the trailing\n\t\t\t    // white-space, so find the last non-white\n\t\t\t    // character -- webb\n\t\t\t    if (did_ai && *skipwhite(ml_get_curline()\n\t\t\t\t\t\t+ curwin->w_cursor.col) == NUL)\n\t\t\t    {\n\t\t\t\tchartabsize_T cts;\n\n\t\t\t\tcurwin->w_wcol = 0;\n\t\t\t\tptr = ml_get_curline();\n\t\t\t\tinit_chartabsize_arg(&cts, curwin,\n\t\t\t\t\t  curwin->w_cursor.lnum, 0, ptr, ptr);\n\t\t\t\twhile (cts.cts_ptr < ptr + curwin->w_cursor.col)\n\t\t\t\t{\n\t\t\t\t    if (!VIM_ISWHITE(*cts.cts_ptr))\n\t\t\t\t\tcurwin->w_wcol = cts.cts_vcol;\n\t\t\t\t    cts.cts_vcol += lbr_chartabsize(&cts);\n\t\t\t\t    if (has_mbyte)\n\t\t\t\t\tcts.cts_ptr +=\n\t\t\t\t\t\t   (*mb_ptr2len)(cts.cts_ptr);\n\t\t\t\t    else\n\t\t\t\t\t++cts.cts_ptr;\n\t\t\t\t}\n\t\t\t\tclear_chartabsize_arg(&cts);\n\n\t\t\t\tcurwin->w_wrow = curwin->w_cline_row\n\t\t\t\t\t   + curwin->w_wcol / curwin->w_width;\n\t\t\t\tcurwin->w_wcol %= curwin->w_width;\n\t\t\t\tcurwin->w_wcol += curwin_col_off();\n\t\t\t\tcol = 0;\t// no correction needed\n\t\t\t    }\n\t\t\t    else\n\t\t\t    {\n\t\t\t\t--curwin->w_wcol;\n\t\t\t\tcol = curwin->w_cursor.col - 1;\n\t\t\t    }\n\t\t\t}\n\t\t\telse if (curwin->w_p_wrap && curwin->w_wrow)\n\t\t\t{\n\t\t\t    --curwin->w_wrow;\n\t\t\t    curwin->w_wcol = curwin->w_width - 1;\n\t\t\t    col = curwin->w_cursor.col - 1;\n\t\t\t}\n\t\t\tif (has_mbyte && col > 0 && curwin->w_wcol > 0)\n\t\t\t{\n\t\t\t    // Correct when the cursor is on the right halve\n\t\t\t    // of a double-wide character.\n\t\t\t    ptr = ml_get_curline();\n\t\t\t    col -= (*mb_head_off)(ptr, ptr + col);\n\t\t\t    if ((*mb_ptr2cells)(ptr + col) > 1)\n\t\t\t\t--curwin->w_wcol;\n\t\t\t}\n\t\t    }\n\t\t    setcursor();\n\t\t    out_flush();\n\t\t    new_wcol = curwin->w_wcol;\n\t\t    new_wrow = curwin->w_wrow;\n\t\t    curwin->w_wcol = old_wcol;\n\t\t    curwin->w_wrow = old_wrow;\n\t\t}\n\t\tif (c < 0)\n\t\t    continue;\t// end of input script reached\n\n\t\t// Allow mapping for just typed characters. When we get here c\n\t\t// is the number of extra bytes and typebuf.tb_len is 1.\n\t\tfor (n = 1; n <= c; ++n)\n\t\t    typebuf.tb_noremap[typebuf.tb_off + n] = RM_YES;\n\t\ttypebuf.tb_len += c;\n\n\t\t// buffer full, don't map\n\t\tif (typebuf.tb_len >= typebuf.tb_maplen + MAXMAPLEN)\n\t\t{\n\t\t    timedout = TRUE;\n\t\t    continue;\n\t\t}\n\n\t\tif (ex_normal_busy > 0)\n\t\t{\n\t\t    static int tc = 0;\n\n\t\t    // No typeahead left and inside \":normal\".  Must return\n\t\t    // something to avoid getting stuck.  When an incomplete\n\t\t    // mapping is present, behave like it timed out.\n\t\t    if (typebuf.tb_len > 0)\n\t\t    {\n\t\t\ttimedout = TRUE;\n\t\t\tcontinue;\n\t\t    }\n\n\t\t    // When 'insertmode' is set, ESC just beeps in Insert\n\t\t    // mode.  Use CTRL-L to make edit() return.\n\t\t    // For the command line only CTRL-C always breaks it.\n\t\t    // For the cmdline window: Alternate between ESC and\n\t\t    // CTRL-C: ESC for most situations and CTRL-C to close the\n\t\t    // cmdline window.\n\t\t    if (p_im && (State & MODE_INSERT))\n\t\t\tc = Ctrl_L;\n#ifdef FEAT_TERMINAL\n\t\t    else if (terminal_is_active())\n\t\t\tc = K_CANCEL;\n#endif\n\t\t    else if ((State & MODE_CMDLINE)\n\t\t\t\t\t     || (cmdwin_type > 0 && tc == ESC))\n\t\t\tc = Ctrl_C;\n\t\t    else\n\t\t\tc = ESC;\n\t\t    tc = c;\n\t\t    // set a flag to indicate this wasn't a normal char\n\t\t    if (advance)\n\t\t\ttypebuf_was_empty = TRUE;\n\n\t\t    // return from main_loop()\n\t\t    if (pending_exmode_active)\n\t\t\texmode_active = EXMODE_NORMAL;\n\n\t\t    // no chars to block abbreviation for\n\t\t    typebuf.tb_no_abbr_cnt = 0;\n\n\t\t    break;\n\t\t}\n\n/*\n * get a character: 3. from the user - update display\n */\n\t\t// In insert mode a screen update is skipped when characters\n\t\t// are still available.  But when those available characters\n\t\t// are part of a mapping, and we are going to do a blocking\n\t\t// wait here.  Need to update the screen to display the\n\t\t// changed text so far. Also for when 'lazyredraw' is set and\n\t\t// redrawing was postponed because there was something in the\n\t\t// input buffer (e.g., termresponse).\n\t\tif (((State & MODE_INSERT) != 0 || p_lz)\n\t\t\t&& (State & MODE_CMDLINE) == 0\n\t\t\t&& advance && must_redraw != 0 && !need_wait_return)\n\t\t{\n\t\t    update_screen(0);\n\t\t    setcursor(); // put cursor back where it belongs\n\t\t}\n\n\t\t/*\n\t\t * If we have a partial match (and are going to wait for more\n\t\t * input from the user), show the partially matched characters\n\t\t * to the user with showcmd.\n\t\t */\n\t\tshowcmd_idx = 0;\n\t\tint showing_partial = FALSE;\n\t\tif (typebuf.tb_len > 0 && advance && !exmode_active)\n\t\t{\n\t\t    if (((State & (MODE_NORMAL | MODE_INSERT))\n\t\t\t\t\t\t      || State == MODE_LANGMAP)\n\t\t\t    && State != MODE_HITRETURN)\n\t\t    {\n\t\t\t// this looks nice when typing a dead character map\n\t\t\tif (State & MODE_INSERT\n\t\t\t    && ptr2cells(typebuf.tb_buf + typebuf.tb_off\n\t\t\t\t\t\t   + typebuf.tb_len - 1) == 1)\n\t\t\t{\n\t\t\t    edit_putchar(typebuf.tb_buf[typebuf.tb_off\n\t\t\t\t\t\t+ typebuf.tb_len - 1], FALSE);\n\t\t\t    setcursor(); // put cursor back where it belongs\n\t\t\t    showing_partial = TRUE;\n\t\t\t}\n\t\t\t// need to use the col and row from above here\n\t\t\told_wcol = curwin->w_wcol;\n\t\t\told_wrow = curwin->w_wrow;\n\t\t\tcurwin->w_wcol = new_wcol;\n\t\t\tcurwin->w_wrow = new_wrow;\n\t\t\tpush_showcmd();\n\t\t\tif (typebuf.tb_len > SHOWCMD_COLS)\n\t\t\t    showcmd_idx = typebuf.tb_len - SHOWCMD_COLS;\n\t\t\twhile (showcmd_idx < typebuf.tb_len)\n\t\t\t    (void)add_to_showcmd(\n\t\t\t       typebuf.tb_buf[typebuf.tb_off + showcmd_idx++]);\n\t\t\tcurwin->w_wcol = old_wcol;\n\t\t\tcurwin->w_wrow = old_wrow;\n\t\t    }\n\n\t\t    // This looks nice when typing a dead character map.\n\t\t    // There is no actual command line for get_number().\n\t\t    if ((State & MODE_CMDLINE)\n\t\t\t    && get_cmdline_info()->cmdbuff != NULL\n#if defined(FEAT_CRYPT) || defined(FEAT_EVAL)\n\t\t\t    && cmdline_star == 0\n#endif\n\t\t\t    && ptr2cells(typebuf.tb_buf + typebuf.tb_off\n\t\t\t\t\t\t   + typebuf.tb_len - 1) == 1)\n\t\t    {\n\t\t\tputcmdline(typebuf.tb_buf[typebuf.tb_off\n\t\t\t\t\t\t+ typebuf.tb_len - 1], FALSE);\n\t\t\tshowing_partial = TRUE;\n\t\t    }\n\t\t}\n\n/*\n * get a character: 3. from the user - get it\n */\n\t\tif (typebuf.tb_len == 0)\n\t\t    // timedout may have been set if a mapping with empty RHS\n\t\t    // fully matched while longer mappings timed out.\n\t\t    timedout = FALSE;\n\n\t\tif (advance)\n\t\t{\n\t\t    if (typebuf.tb_len == 0\n\t\t\t    || !(p_timeout\n\t\t\t\t || (p_ttimeout && keylen == KEYLEN_PART_KEY)))\n\t\t\t// blocking wait\n\t\t\twait_time = -1L;\n\t\t    else if (keylen == KEYLEN_PART_KEY && p_ttm >= 0)\n\t\t\twait_time = p_ttm;\n\t\t    else\n\t\t\twait_time = p_tm;\n\t\t}\n\t\telse\n\t\t    wait_time = 0;\n\n\t\twait_tb_len = typebuf.tb_len;\n\t\tc = inchar(typebuf.tb_buf + typebuf.tb_off + typebuf.tb_len,\n\t\t\ttypebuf.tb_buflen - typebuf.tb_off - typebuf.tb_len - 1,\n\t\t\twait_time);\n\n\t\tif (showcmd_idx != 0)\n\t\t    pop_showcmd();\n\t\tif (showing_partial)\n\t\t{\n\t\t    if (State & MODE_INSERT)\n\t\t\tedit_unputchar();\n\t\t    if ((State & MODE_CMDLINE)\n\t\t\t\t\t&& get_cmdline_info()->cmdbuff != NULL)\n\t\t\tunputcmdline();\n\t\t    else\n\t\t\tsetcursor();\t// put cursor back where it belongs\n\t\t}\n\n\t\tif (c < 0)\n\t\t    continue;\t\t// end of input script reached\n\t\tif (c == NUL)\t\t// no character available\n\t\t{\n\t\t    if (!advance)\n\t\t\tbreak;\n\t\t    if (wait_tb_len > 0)\t// timed out\n\t\t    {\n\t\t\ttimedout = TRUE;\n\t\t\tcontinue;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\t    // allow mapping for just typed characters\n\t\t    while (typebuf.tb_buf[typebuf.tb_off\n\t\t\t\t\t\t     + typebuf.tb_len] != NUL)\n\t\t\ttypebuf.tb_noremap[typebuf.tb_off\n\t\t\t\t\t\t + typebuf.tb_len++] = RM_YES;\n#ifdef HAVE_INPUT_METHOD\n\t\t    // Get IM status right after getting keys, not after the\n\t\t    // timeout for a mapping (focus may be lost by then).\n\t\t    vgetc_im_active = im_get_status();\n#endif\n\t\t}\n\t    }\t    // for (;;)\n\t}\t// if (!character from stuffbuf)\n\n\t// if advance is FALSE don't loop on NULs\n    } while ((c < 0 && c != K_CANCEL) || (advance && c == NUL));\n\n    /*\n     * The \"INSERT\" message is taken care of here:\n     *\t if we return an ESC to exit insert mode, the message is deleted\n     *\t if we don't return an ESC but deleted the message before, redisplay it\n     */\n    if (advance && p_smd && msg_silent == 0 && (State & MODE_INSERT))\n    {\n\tif (c == ESC && !mode_deleted && !no_mapping && mode_displayed)\n\t{\n\t    if (typebuf.tb_len && !KeyTyped)\n\t\tredraw_cmdline = TRUE;\t    // delete mode later\n\t    else\n\t\tunshowmode(FALSE);\n\t}\n\telse if (c != ESC && mode_deleted)\n\t{\n\t    if (typebuf.tb_len && !KeyTyped)\n\t\tredraw_cmdline = TRUE;\t    // show mode later\n\t    else\n\t\tshowmode();\n\t}\n    }\n#ifdef FEAT_GUI\n    // may unshow different cursor shape\n    if (gui.in_use && shape_changed)\n\tgui_update_cursor(TRUE, FALSE);\n#endif\n    if (timedout && c == ESC)\n    {\n\tchar_u nop_buf[3];\n\n\t// When recording there will be no timeout.  Add a <Nop> after the ESC\n\t// to avoid that it forms a key code with following characters.\n\tnop_buf[0] = K_SPECIAL;\n\tnop_buf[1] = KS_EXTRA;\n\tnop_buf[2] = KE_NOP;\n\tgotchars(nop_buf, 3);\n    }\n\n    --vgetc_busy;\n\n    return c;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 2645,
    "critical_vars": [
      "regmatch.regprog"
    ],
    "function": "buflist_findpat",
    "filename": "vim/CVE-2022-1725/CVE-2022-1725_CWE-476_b62dc5e7825bc195efe3041d5b3a9f1528359e1c_buffer.c.diff",
    "function_code": "buflist_findpat(\n    char_u\t*pattern,\n    char_u\t*pattern_end,\t// pointer to first char after pattern\n    int\t\tunlisted,\t// find unlisted buffers\n    int\t\tdiffmode UNUSED, // find diff-mode buffers only\n    int\t\tcurtab_only)\t// find buffers in current tab only\n{\n    buf_T\t*buf;\n    int\t\tmatch = -1;\n    int\t\tfind_listed;\n    char_u\t*pat;\n    char_u\t*patend;\n    int\t\tattempt;\n    char_u\t*p;\n    int\t\ttoggledollar;\n\n    // \"%\" is current file, \"%%\" or \"#\" is alternate file\n    if ((pattern_end == pattern + 1 && (*pattern == '%' || *pattern == '#'))\n\t    || (in_vim9script() && pattern_end == pattern + 2\n\t\t\t\t    && pattern[0] == '%' && pattern[1] == '%'))\n    {\n\tif (*pattern == '#' || pattern_end == pattern + 2)\n\t    match = curwin->w_alt_fnum;\n\telse\n\t    match = curbuf->b_fnum;\n#ifdef FEAT_DIFF\n\tif (diffmode && !diff_mode_buf(buflist_findnr(match)))\n\t    match = -1;\n#endif\n    }\n\n    /*\n     * Try four ways of matching a listed buffer:\n     * attempt == 0: without '^' or '$' (at any position)\n     * attempt == 1: with '^' at start (only at position 0)\n     * attempt == 2: with '$' at end (only match at end)\n     * attempt == 3: with '^' at start and '$' at end (only full match)\n     * Repeat this for finding an unlisted buffer if there was no matching\n     * listed buffer.\n     */\n    else\n    {\n\tpat = file_pat_to_reg_pat(pattern, pattern_end, NULL, FALSE);\n\tif (pat == NULL)\n\t    return -1;\n\tpatend = pat + STRLEN(pat) - 1;\n\ttoggledollar = (patend > pat && *patend == '$');\n\n\t// First try finding a listed buffer.  If not found and \"unlisted\"\n\t// is TRUE, try finding an unlisted buffer.\n\tfind_listed = TRUE;\n\tfor (;;)\n\t{\n\t    for (attempt = 0; attempt <= 3; ++attempt)\n\t    {\n\t\tregmatch_T\tregmatch;\n\n\t\t// may add '^' and '$'\n\t\tif (toggledollar)\n\t\t    *patend = (attempt < 2) ? NUL : '$'; // add/remove '$'\n\t\tp = pat;\n\t\tif (*p == '^' && !(attempt & 1))\t // add/remove '^'\n\t\t    ++p;\n\t\tregmatch.regprog = vim_regcomp(p, magic_isset() ? RE_MAGIC : 0);\n\t\tif (regmatch.regprog == NULL)\n\t\t{\n\t\t    vim_free(pat);\n\t\t    return -1;\n\t\t}\n\n\t\tFOR_ALL_BUFS_FROM_LAST(buf)\n\t\t    if (buf->b_p_bl == find_listed\n#ifdef FEAT_DIFF\n\t\t\t    && (!diffmode || diff_mode_buf(buf))\n#endif\n\t\t\t    && buflist_match(&regmatch, buf, FALSE) != NULL)\n\t\t    {\n\t\t\tif (curtab_only)\n\t\t\t{\n\t\t\t    // Ignore the match if the buffer is not open in\n\t\t\t    // the current tab.\n\t\t\t    win_T\t*wp;\n\n\t\t\t    FOR_ALL_WINDOWS(wp)\n\t\t\t\tif (wp->w_buffer == buf)\n\t\t\t\t    break;\n\t\t\t    if (wp == NULL)\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (match >= 0)\t\t// already found a match\n\t\t\t{\n\t\t\t    match = -2;\n\t\t\t    break;\n\t\t\t}\n\t\t\tmatch = buf->b_fnum;\t// remember first match\n\t\t    }\n\n\t\tvim_regfree(regmatch.regprog);\n\t\tif (match >= 0)\t\t\t// found one match\n\t\t    break;\n\t    }\n\n\t    // Only search for unlisted buffers if there was no match with\n\t    // a listed buffer.\n\t    if (!unlisted || !find_listed || match != -1)\n\t\tbreak;\n\t    find_listed = FALSE;\n\t}\n\n\tvim_free(pat);\n    }\n\n    if (match == -2)\n\tsemsg(_(e_more_than_one_match_for_str), pattern);\n    else if (match < 0)\n\tsemsg(_(e_no_matching_buffer_for_str), pattern);\n    return match;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 2648,
    "critical_vars": [
      "regmatch.regprog"
    ],
    "function": "buflist_findpat",
    "filename": "vim/CVE-2022-1725/CVE-2022-1725_CWE-476_b62dc5e7825bc195efe3041d5b3a9f1528359e1c_buffer.c.diff",
    "function_code": "buflist_findpat(\n    char_u\t*pattern,\n    char_u\t*pattern_end,\t// pointer to first char after pattern\n    int\t\tunlisted,\t// find unlisted buffers\n    int\t\tdiffmode UNUSED, // find diff-mode buffers only\n    int\t\tcurtab_only)\t// find buffers in current tab only\n{\n    buf_T\t*buf;\n    int\t\tmatch = -1;\n    int\t\tfind_listed;\n    char_u\t*pat;\n    char_u\t*patend;\n    int\t\tattempt;\n    char_u\t*p;\n    int\t\ttoggledollar;\n\n    // \"%\" is current file, \"%%\" or \"#\" is alternate file\n    if ((pattern_end == pattern + 1 && (*pattern == '%' || *pattern == '#'))\n\t    || (in_vim9script() && pattern_end == pattern + 2\n\t\t\t\t    && pattern[0] == '%' && pattern[1] == '%'))\n    {\n\tif (*pattern == '#' || pattern_end == pattern + 2)\n\t    match = curwin->w_alt_fnum;\n\telse\n\t    match = curbuf->b_fnum;\n#ifdef FEAT_DIFF\n\tif (diffmode && !diff_mode_buf(buflist_findnr(match)))\n\t    match = -1;\n#endif\n    }\n\n    /*\n     * Try four ways of matching a listed buffer:\n     * attempt == 0: without '^' or '$' (at any position)\n     * attempt == 1: with '^' at start (only at position 0)\n     * attempt == 2: with '$' at end (only match at end)\n     * attempt == 3: with '^' at start and '$' at end (only full match)\n     * Repeat this for finding an unlisted buffer if there was no matching\n     * listed buffer.\n     */\n    else\n    {\n\tpat = file_pat_to_reg_pat(pattern, pattern_end, NULL, FALSE);\n\tif (pat == NULL)\n\t    return -1;\n\tpatend = pat + STRLEN(pat) - 1;\n\ttoggledollar = (patend > pat && *patend == '$');\n\n\t// First try finding a listed buffer.  If not found and \"unlisted\"\n\t// is TRUE, try finding an unlisted buffer.\n\tfind_listed = TRUE;\n\tfor (;;)\n\t{\n\t    for (attempt = 0; attempt <= 3; ++attempt)\n\t    {\n\t\tregmatch_T\tregmatch;\n\n\t\t// may add '^' and '$'\n\t\tif (toggledollar)\n\t\t    *patend = (attempt < 2) ? NUL : '$'; // add/remove '$'\n\t\tp = pat;\n\t\tif (*p == '^' && !(attempt & 1))\t // add/remove '^'\n\t\t    ++p;\n\t\tregmatch.regprog = vim_regcomp(p, magic_isset() ? RE_MAGIC : 0);\n\n\t\tFOR_ALL_BUFS_FROM_LAST(buf)\n\t\t{\n\t\t    if (regmatch.regprog == NULL)\n\t\t    {\n\t\t\t// invalid pattern, possibly after switching engine\n\t\t\tvim_free(pat);\n\t\t\treturn -1;\n\t\t    }\n\t\t    if (buf->b_p_bl == find_listed\n#ifdef FEAT_DIFF\n\t\t\t    && (!diffmode || diff_mode_buf(buf))\n#endif\n\t\t\t    && buflist_match(&regmatch, buf, FALSE) != NULL)\n\t\t    {\n\t\t\tif (curtab_only)\n\t\t\t{\n\t\t\t    // Ignore the match if the buffer is not open in\n\t\t\t    // the current tab.\n\t\t\t    win_T\t*wp;\n\n\t\t\t    FOR_ALL_WINDOWS(wp)\n\t\t\t\tif (wp->w_buffer == buf)\n\t\t\t\t    break;\n\t\t\t    if (wp == NULL)\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (match >= 0)\t\t// already found a match\n\t\t\t{\n\t\t\t    match = -2;\n\t\t\t    break;\n\t\t\t}\n\t\t\tmatch = buf->b_fnum;\t// remember first match\n\t\t    }\n\t\t}\n\n\t\tvim_regfree(regmatch.regprog);\n\t\tif (match >= 0)\t\t\t// found one match\n\t\t    break;\n\t    }\n\n\t    // Only search for unlisted buffers if there was no match with\n\t    // a listed buffer.\n\t    if (!unlisted || !find_listed || match != -1)\n\t\tbreak;\n\t    find_listed = FALSE;\n\t}\n\n\tvim_free(pat);\n    }\n\n    if (match == -2)\n\tsemsg(_(e_more_than_one_match_for_str), pattern);\n    else if (match < 0)\n\tsemsg(_(e_no_matching_buffer_for_str), pattern);\n    return match;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 2769,
    "critical_vars": [
      "regmatch.regprog"
    ],
    "function": "ExpandBufnames",
    "filename": "vim/CVE-2022-1725/CVE-2022-1725_CWE-476_b62dc5e7825bc195efe3041d5b3a9f1528359e1c_buffer.c.diff",
    "function_code": "ExpandBufnames(\n    char_u\t*pat,\n    int\t\t*num_file,\n    char_u\t***file,\n    int\t\toptions)\n{\n    int\t\tcount = 0;\n    buf_T\t*buf;\n    int\t\tround;\n    char_u\t*p;\n    int\t\tattempt;\n    char_u\t*patc = NULL;\n#ifdef FEAT_VIMINFO\n    bufmatch_T\t*matches = NULL;\n#endif\n    int\t\tfuzzy;\n    fuzmatch_str_T  *fuzmatch = NULL;\n\n    *num_file = 0;\t\t    // return values in case of FAIL\n    *file = NULL;\n\n#ifdef FEAT_DIFF\n    if ((options & BUF_DIFF_FILTER) && !curwin->w_p_diff)\n\treturn FAIL;\n#endif\n\n    fuzzy = cmdline_fuzzy_complete(pat);\n\n    // Make a copy of \"pat\" and change \"^\" to \"\\(^\\|[\\/]\\)\" (if doing regular\n    // expression matching)\n    if (!fuzzy)\n    {\n\tif (*pat == '^')\n\t{\n\t    patc = alloc(STRLEN(pat) + 11);\n\t    if (patc == NULL)\n\t\treturn FAIL;\n\t    STRCPY(patc, \"\\\\(^\\\\|[\\\\/]\\\\)\");\n\t    STRCPY(patc + 11, pat + 1);\n\t}\n\telse\n\t    patc = pat;\n    }\n\n    // attempt == 0: try match with    '\\<', match at start of word\n    // attempt == 1: try match without '\\<', match anywhere\n    for (attempt = 0; attempt <= (fuzzy ? 0 : 1); ++attempt)\n    {\n\tregmatch_T\tregmatch;\n\tint\t\tscore = 0;\n\n\tif (!fuzzy)\n\t{\n\t    if (attempt > 0 && patc == pat)\n\t\tbreak;\t// there was no anchor, no need to try again\n\t    regmatch.regprog = vim_regcomp(patc + attempt * 11, RE_MAGIC);\n\t    if (regmatch.regprog == NULL)\n\t    {\n\t\tif (patc != pat)\n\t\t    vim_free(patc);\n\t\treturn FAIL;\n\t    }\n\t}\n\n\t// round == 1: Count the matches.\n\t// round == 2: Build the array to keep the matches.\n\tfor (round = 1; round <= 2; ++round)\n\t{\n\t    count = 0;\n\t    FOR_ALL_BUFFERS(buf)\n\t    {\n\t\tif (!buf->b_p_bl)\t// skip unlisted buffers\n\t\t    continue;\n#ifdef FEAT_DIFF\n\t\tif (options & BUF_DIFF_FILTER)\n\t\t    // Skip buffers not suitable for\n\t\t    // :diffget or :diffput completion.\n\t\t    if (buf == curbuf || !diff_mode_buf(buf))\n\t\t\tcontinue;\n#endif\n\n\t\tif (!fuzzy)\n\t\t    p = buflist_match(&regmatch, buf, p_wic);\n\t\telse\n\t\t{\n\t\t    p = NULL;\n\t\t    // first try matching with the short file name\n\t\t    if ((score = fuzzy_match_str(buf->b_sfname, pat)) != 0)\n\t\t\tp = buf->b_sfname;\n\t\t    if (p == NULL)\n\t\t    {\n\t\t\t// next try matching with the full path file name\n\t\t\tif ((score = fuzzy_match_str(buf->b_ffname, pat)) != 0)\n\t\t\t    p = buf->b_ffname;\n\t\t    }\n\t\t}\n\n\t\tif (p == NULL)\n\t\t    continue;\n\n\t\tif (round == 1)\n\t\t{\n\t\t    ++count;\n\t\t    continue;\n\t\t}\n\n\t\tif (options & WILD_HOME_REPLACE)\n\t\t    p = home_replace_save(buf, p);\n\t\telse\n\t\t    p = vim_strsave(p);\n\n\t\tif (!fuzzy)\n\t\t{\n#ifdef FEAT_VIMINFO\n\t\t    if (matches != NULL)\n\t\t    {\n\t\t\tmatches[count].buf = buf;\n\t\t\tmatches[count].match = p;\n\t\t\tcount++;\n\t\t    }\n\t\t    else\n#endif\n\t\t\t(*file)[count++] = p;\n\t\t}\n\t\telse\n\t\t{\n\t\t    fuzmatch[count].idx = count;\n\t\t    fuzmatch[count].str = p;\n\t\t    fuzmatch[count].score = score;\n\t\t    count++;\n\t\t}\n\t    }\n\t    if (count == 0)\t// no match found, break here\n\t\tbreak;\n\t    if (round == 1)\n\t    {\n\t\tif (!fuzzy)\n\t\t{\n\t\t    *file = ALLOC_MULT(char_u *, count);\n\t\t    if (*file == NULL)\n\t\t    {\n\t\t\tvim_regfree(regmatch.regprog);\n\t\t\tif (patc != pat)\n\t\t\t    vim_free(patc);\n\t\t\treturn FAIL;\n\t\t    }\n#ifdef FEAT_VIMINFO\n\t\t    if (options & WILD_BUFLASTUSED)\n\t\t\tmatches = ALLOC_MULT(bufmatch_T, count);\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t    fuzmatch = ALLOC_MULT(fuzmatch_str_T, count);\n\t\t    if (fuzmatch == NULL)\n\t\t    {\n\t\t\t*num_file = 0;\n\t\t\t*file = NULL;\n\t\t\treturn FAIL;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\tif (!fuzzy)\n\t{\n\t    vim_regfree(regmatch.regprog);\n\t    if (count)\t\t// match(es) found, break here\n\t\tbreak;\n\t}\n    }\n\n    if (!fuzzy && patc != pat)\n\tvim_free(patc);\n\n#ifdef FEAT_VIMINFO\n    if (!fuzzy)\n    {\n\tif (matches != NULL)\n\t{\n\t    int i;\n\t    if (count > 1)\n\t\tqsort(matches, count, sizeof(bufmatch_T), buf_compare);\n\t    // if the current buffer is first in the list, place it at the end\n\t    if (matches[0].buf == curbuf)\n\t    {\n\t\tfor (i = 1; i < count; i++)\n\t\t    (*file)[i-1] = matches[i].match;\n\t\t(*file)[count-1] = matches[0].match;\n\t    }\n\t    else\n\t    {\n\t\tfor (i = 0; i < count; i++)\n\t\t    (*file)[i] = matches[i].match;\n\t    }\n\t    vim_free(matches);\n\t}\n    }\n    else\n    {\n\tif (fuzzymatches_to_strmatches(fuzmatch, file, count, FALSE) == FAIL)\n\t    return FAIL;\n    }\n#endif\n\n    *num_file = count;\n    return (count == 0 ? FAIL : OK);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 2793,
    "critical_vars": [
      "regmatch.regprog"
    ],
    "function": "ExpandBufnames",
    "filename": "vim/CVE-2022-1725/CVE-2022-1725_CWE-476_b62dc5e7825bc195efe3041d5b3a9f1528359e1c_buffer.c.diff",
    "function_code": "ExpandBufnames(\n    char_u\t*pat,\n    int\t\t*num_file,\n    char_u\t***file,\n    int\t\toptions)\n{\n    int\t\tcount = 0;\n    buf_T\t*buf;\n    int\t\tround;\n    char_u\t*p;\n    int\t\tattempt;\n    char_u\t*patc = NULL;\n#ifdef FEAT_VIMINFO\n    bufmatch_T\t*matches = NULL;\n#endif\n    int\t\tfuzzy;\n    fuzmatch_str_T  *fuzmatch = NULL;\n\n    *num_file = 0;\t\t    // return values in case of FAIL\n    *file = NULL;\n\n#ifdef FEAT_DIFF\n    if ((options & BUF_DIFF_FILTER) && !curwin->w_p_diff)\n\treturn FAIL;\n#endif\n\n    fuzzy = cmdline_fuzzy_complete(pat);\n\n    // Make a copy of \"pat\" and change \"^\" to \"\\(^\\|[\\/]\\)\" (if doing regular\n    // expression matching)\n    if (!fuzzy)\n    {\n\tif (*pat == '^')\n\t{\n\t    patc = alloc(STRLEN(pat) + 11);\n\t    if (patc == NULL)\n\t\treturn FAIL;\n\t    STRCPY(patc, \"\\\\(^\\\\|[\\\\/]\\\\)\");\n\t    STRCPY(patc + 11, pat + 1);\n\t}\n\telse\n\t    patc = pat;\n    }\n\n    // attempt == 0: try match with    '\\<', match at start of word\n    // attempt == 1: try match without '\\<', match anywhere\n    for (attempt = 0; attempt <= (fuzzy ? 0 : 1); ++attempt)\n    {\n\tregmatch_T\tregmatch;\n\tint\t\tscore = 0;\n\n\tif (!fuzzy)\n\t{\n\t    if (attempt > 0 && patc == pat)\n\t\tbreak;\t// there was no anchor, no need to try again\n\t    regmatch.regprog = vim_regcomp(patc + attempt * 11, RE_MAGIC);\n\t}\n\n\t// round == 1: Count the matches.\n\t// round == 2: Build the array to keep the matches.\n\tfor (round = 1; round <= 2; ++round)\n\t{\n\t    count = 0;\n\t    FOR_ALL_BUFFERS(buf)\n\t    {\n\t\tif (!buf->b_p_bl)\t// skip unlisted buffers\n\t\t    continue;\n#ifdef FEAT_DIFF\n\t\tif (options & BUF_DIFF_FILTER)\n\t\t    // Skip buffers not suitable for\n\t\t    // :diffget or :diffput completion.\n\t\t    if (buf == curbuf || !diff_mode_buf(buf))\n\t\t\tcontinue;\n#endif\n\n\t\tif (!fuzzy)\n\t\t{\n\t\t    if (regmatch.regprog == NULL)\n\t\t    {\n\t\t\t// invalid pattern, possibly after recompiling\n\t\t\tif (patc != pat)\n\t\t\t    vim_free(patc);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    p = buflist_match(&regmatch, buf, p_wic);\n\t\t}\n\t\telse\n\t\t{\n\t\t    p = NULL;\n\t\t    // first try matching with the short file name\n\t\t    if ((score = fuzzy_match_str(buf->b_sfname, pat)) != 0)\n\t\t\tp = buf->b_sfname;\n\t\t    if (p == NULL)\n\t\t    {\n\t\t\t// next try matching with the full path file name\n\t\t\tif ((score = fuzzy_match_str(buf->b_ffname, pat)) != 0)\n\t\t\t    p = buf->b_ffname;\n\t\t    }\n\t\t}\n\n\t\tif (p == NULL)\n\t\t    continue;\n\n\t\tif (round == 1)\n\t\t{\n\t\t    ++count;\n\t\t    continue;\n\t\t}\n\n\t\tif (options & WILD_HOME_REPLACE)\n\t\t    p = home_replace_save(buf, p);\n\t\telse\n\t\t    p = vim_strsave(p);\n\n\t\tif (!fuzzy)\n\t\t{\n#ifdef FEAT_VIMINFO\n\t\t    if (matches != NULL)\n\t\t    {\n\t\t\tmatches[count].buf = buf;\n\t\t\tmatches[count].match = p;\n\t\t\tcount++;\n\t\t    }\n\t\t    else\n#endif\n\t\t\t(*file)[count++] = p;\n\t\t}\n\t\telse\n\t\t{\n\t\t    fuzmatch[count].idx = count;\n\t\t    fuzmatch[count].str = p;\n\t\t    fuzmatch[count].score = score;\n\t\t    count++;\n\t\t}\n\t    }\n\t    if (count == 0)\t// no match found, break here\n\t\tbreak;\n\t    if (round == 1)\n\t    {\n\t\tif (!fuzzy)\n\t\t{\n\t\t    *file = ALLOC_MULT(char_u *, count);\n\t\t    if (*file == NULL)\n\t\t    {\n\t\t\tvim_regfree(regmatch.regprog);\n\t\t\tif (patc != pat)\n\t\t\t    vim_free(patc);\n\t\t\treturn FAIL;\n\t\t    }\n#ifdef FEAT_VIMINFO\n\t\t    if (options & WILD_BUFLASTUSED)\n\t\t\tmatches = ALLOC_MULT(bufmatch_T, count);\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t    fuzmatch = ALLOC_MULT(fuzmatch_str_T, count);\n\t\t    if (fuzmatch == NULL)\n\t\t    {\n\t\t\t*num_file = 0;\n\t\t\t*file = NULL;\n\t\t\treturn FAIL;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\tif (!fuzzy)\n\t{\n\t    vim_regfree(regmatch.regprog);\n\t    if (count)\t\t// match(es) found, break here\n\t\tbreak;\n\t}\n    }\n\n    if (!fuzzy && patc != pat)\n\tvim_free(patc);\n\n#ifdef FEAT_VIMINFO\n    if (!fuzzy)\n    {\n\tif (matches != NULL)\n\t{\n\t    int i;\n\t    if (count > 1)\n\t\tqsort(matches, count, sizeof(bufmatch_T), buf_compare);\n\t    // if the current buffer is first in the list, place it at the end\n\t    if (matches[0].buf == curbuf)\n\t    {\n\t\tfor (i = 1; i < count; i++)\n\t\t    (*file)[i-1] = matches[i].match;\n\t\t(*file)[count-1] = matches[0].match;\n\t    }\n\t    else\n\t    {\n\t\tfor (i = 0; i < count; i++)\n\t\t    (*file)[i] = matches[i].match;\n\t    }\n\t    vim_free(matches);\n\t}\n    }\n    else\n    {\n\tif (fuzzymatches_to_strmatches(fuzmatch, file, count, FALSE) == FAIL)\n\t    return FAIL;\n    }\n#endif\n\n    *num_file = count;\n    return (count == 0 ? FAIL : OK);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 2234,
    "critical_vars": [
      "gc",
      "gui.dpy",
      "blank_pixmap"
    ],
    "function": "gui_x11_create_blank_mouse",
    "filename": "vim/CVE-2022-47024/CVE-2022-47024_CWE-476_a63ad78ed31e36dbdf3a9cd28071dcdbefce7d19_gui_x11.c.diff",
    "function_code": "gui_x11_create_blank_mouse(void)\n{\n    Pixmap blank_pixmap = XCreatePixmap(gui.dpy, gui.wid, 1, 1, 1);\n    GC gc = XCreateGC(gui.dpy, blank_pixmap, (unsigned long)0, (XGCValues*)0);\n    XDrawPoint(gui.dpy, blank_pixmap, gc, 0, 0);\n    XFreeGC(gui.dpy, gc);\n    return XCreatePixmapCursor(gui.dpy, blank_pixmap, blank_pixmap,\n\t    (XColor*)&gui.norm_pixel, (XColor*)&gui.norm_pixel, 0, 0);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 2235,
    "critical_vars": [
      "gc"
    ],
    "function": "gui_x11_create_blank_mouse",
    "filename": "vim/CVE-2022-47024/CVE-2022-47024_CWE-476_a63ad78ed31e36dbdf3a9cd28071dcdbefce7d19_gui_x11.c.diff",
    "function_code": "gui_x11_create_blank_mouse(void)\n{\n    Pixmap blank_pixmap = XCreatePixmap(gui.dpy, gui.wid, 1, 1, 1);\n    GC gc = XCreateGC(gui.dpy, blank_pixmap, (unsigned long)0, (XGCValues*)0);\n\n    if (gc != NULL)\n    {\n\tXDrawPoint(gui.dpy, blank_pixmap, gc, 0, 0);\n\tXFreeGC(gui.dpy, gc);\n    }\n    return XCreatePixmapCursor(gui.dpy, blank_pixmap, blank_pixmap,\n\t\t     (XColor*)&gui.norm_pixel, (XColor*)&gui.norm_pixel, 0, 0);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 822,
    "critical_vars": [
      "load->real",
      "load"
    ],
    "function": "vips_foreign_load_start",
    "filename": "libvips/CVE-2018-7998/CVE-2018-7998_CWE-476_20d840e6da15c1574b3ed998bc92f91d1e36c2a5_foreign.c.diff",
    "function_code": "vips_foreign_load_start( VipsImage *out, void *a, void *b )\n{\n\tVipsForeignLoad *load = VIPS_FOREIGN_LOAD( b );\n\tVipsForeignLoadClass *class = VIPS_FOREIGN_LOAD_GET_CLASS( load );\n\n\tif( !load->real ) {\n\t\tif( !(load->real = vips_foreign_load_temp( load )) )\n\t\t\treturn( NULL );\n\n#ifdef DEBUG\n\t\tprintf( \"vips_foreign_load_start: triggering ->load()\\n\" );\n#endif /*DEBUG*/\n\n\t\t/* Read the image in. This may involve a long computation and\n\t\t * will finish with load->real holding the decompressed image. \n\t\t *\n\t\t * We want our caller to be able to see this computation on\n\t\t * @out, so eval signals on ->real need to appear on ->out.\n\t\t */\n\t\tload->real->progress_signal = load->out;\n\n\t\t/* Note the load object on the image. Loaders can use \n\t\t * this to signal invalidate if they hit a load error. See\n\t\t * vips_foreign_load_invalidate() below.\n\t\t */\n\t\tg_object_set_qdata( G_OBJECT( load->real ), \n\t\t\tvips__foreign_load_operation, load ); \n\n\t\tif( class->load( load ) ||\n\t\t\tvips_image_pio_input( load->real ) ) \n\t\t\treturn( NULL );\n\n\t\t/* ->header() read the header into @out, load has read the\n\t\t * image into @real. They must match exactly in size, bands,\n\t\t * format and coding for the copy to work.  \n\t\t *\n\t\t * Some versions of ImageMagick give different results between\n\t\t * Ping and Load for some formats, for example.\n\t\t */\n\t\tif( !vips_foreign_load_iscompat( load->real, out ) )\n\t\t\treturn( NULL );\n\n\t\t/* We have to tell vips that out depends on real. We've set\n\t\t * the demand hint below, but not given an input there.\n\t\t */\n\t\tvips_image_pipelinev( load->out, load->out->dhint, \n\t\t\tload->real, NULL );\n\t}\n\n\treturn( vips_region_new( load->real ) );\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 803,
    "critical_vars": [
      "load->error"
    ],
    "function": "vips_foreign_load_start",
    "filename": "libvips/CVE-2018-7998/CVE-2018-7998_CWE-476_20d840e6da15c1574b3ed998bc92f91d1e36c2a5_foreign.c.diff",
    "function_code": "vips_foreign_load_start( VipsImage *out, void *a, void *b )\n{\n\tVipsForeignLoad *load = VIPS_FOREIGN_LOAD( b );\n\tVipsForeignLoadClass *class = VIPS_FOREIGN_LOAD_GET_CLASS( load );\n\n\t/* If this start has failed before in another thread, we can fail now.\n\t */\n\tif( load->error )\n\t\treturn( NULL );\n\n\tif( !load->real ) {\n\t\tif( !(load->real = vips_foreign_load_temp( load )) )\n\t\t\treturn( NULL );\n\n#ifdef DEBUG\n\t\tprintf( \"vips_foreign_load_start: triggering ->load()\\n\" );\n#endif /*DEBUG*/\n\n\t\t/* Read the image in. This may involve a long computation and\n\t\t * will finish with load->real holding the decompressed image. \n\t\t *\n\t\t * We want our caller to be able to see this computation on\n\t\t * @out, so eval signals on ->real need to appear on ->out.\n\t\t */\n\t\tload->real->progress_signal = load->out;\n\n\t\t/* Note the load object on the image. Loaders can use \n\t\t * this to signal invalidate if they hit a load error. See\n\t\t * vips_foreign_load_invalidate() below.\n\t\t */\n\t\tg_object_set_qdata( G_OBJECT( load->real ), \n\t\t\tvips__foreign_load_operation, load ); \n\n\t\t/* Load the image and check the result.\n\t\t *\n\t\t * ->header() read the header into @out, load has read the\n\t\t * image into @real. They must match exactly in size, bands,\n\t\t * format and coding for the copy to work.  \n\t\t *\n\t\t * Some versions of ImageMagick give different results between\n\t\t * Ping and Load for some formats, for example.\n\t\t *\n\t\t * If the load fails, we need to stop\n\t\t */\n\t\tif( class->load( load ) ||\n\t\t\tvips_image_pio_input( load->real ) || \n\t\t\tvips_foreign_load_iscompat( load->real, out ) ) {\n\t\t\tvips_operation_invalidate( VIPS_OPERATION( load ) ); \n\t\t\tload->error = TRUE;\n\n\t\t\treturn( NULL );\n\t\t}\n\n\t\t/* We have to tell vips that out depends on real. We've set\n\t\t * the demand hint below, but not given an input there.\n\t\t */\n\t\tvips_image_pipelinev( load->out, load->out->dhint, \n\t\t\tload->real, NULL );\n\t}\n\n\treturn( vips_region_new( load->real ) );\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 385,
    "critical_vars": [
      "upsample"
    ],
    "function": "jpeg_skip_scanlines",
    "filename": "libjpeg-turbo/CVE-2020-35538/CVE-2020-35538_CWE-476_9120a247436e84c0b4eea828cb11e8f665fcde30_jdapistd.c.diff",
    "function_code": "jpeg_skip_scanlines(j_decompress_ptr cinfo, JDIMENSION num_lines)\n{\n  my_main_ptr main_ptr = (my_main_ptr)cinfo->main;\n  my_coef_ptr coef = (my_coef_ptr)cinfo->coef;\n  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n  JDIMENSION i, x;\n  int y;\n  JDIMENSION lines_per_iMCU_row, lines_left_in_iMCU_row, lines_after_iMCU_row;\n  JDIMENSION lines_to_skip, lines_to_read;\n\n  if (cinfo->global_state != DSTATE_SCANNING)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n\n  /* Do not skip past the bottom of the image. */\n  if (cinfo->output_scanline + num_lines >= cinfo->output_height) {\n    cinfo->output_scanline = cinfo->output_height;\n    (*cinfo->inputctl->finish_input_pass) (cinfo);\n    cinfo->inputctl->eoi_reached = TRUE;\n    return cinfo->output_height - cinfo->output_scanline;\n  }\n\n  if (num_lines == 0)\n    return 0;\n\n  lines_per_iMCU_row = cinfo->_min_DCT_scaled_size * cinfo->max_v_samp_factor;\n  lines_left_in_iMCU_row =\n    (lines_per_iMCU_row - (cinfo->output_scanline % lines_per_iMCU_row)) %\n    lines_per_iMCU_row;\n  lines_after_iMCU_row = num_lines - lines_left_in_iMCU_row;\n\n  /* Skip the lines remaining in the current iMCU row.  When upsampling\n   * requires context rows, we need the previous and next rows in order to read\n   * the current row.  This adds some complexity.\n   */\n  if (cinfo->upsample->need_context_rows) {\n    /* If the skipped lines would not move us past the current iMCU row, we\n     * read the lines and ignore them.  There might be a faster way of doing\n     * this, but we are facing increasing complexity for diminishing returns.\n     * The increasing complexity would be a by-product of meddling with the\n     * state machine used to skip context rows.  Near the end of an iMCU row,\n     * the next iMCU row may have already been entropy-decoded.  In this unique\n     * case, we will read the next iMCU row if we cannot skip past it as well.\n     */\n    if ((num_lines < lines_left_in_iMCU_row + 1) ||\n        (lines_left_in_iMCU_row <= 1 && main_ptr->buffer_full &&\n         lines_after_iMCU_row < lines_per_iMCU_row + 1)) {\n      read_and_discard_scanlines(cinfo, num_lines);\n      return num_lines;\n    }\n\n    /* If the next iMCU row has already been entropy-decoded, make sure that\n     * we do not skip too far.\n     */\n    if (lines_left_in_iMCU_row <= 1 && main_ptr->buffer_full) {\n      cinfo->output_scanline += lines_left_in_iMCU_row + lines_per_iMCU_row;\n      lines_after_iMCU_row -= lines_per_iMCU_row;\n    } else {\n      cinfo->output_scanline += lines_left_in_iMCU_row;\n    }\n\n    /* If we have just completed the first block, adjust the buffer pointers */\n    if (main_ptr->iMCU_row_ctr == 0 ||\n        (main_ptr->iMCU_row_ctr == 1 && lines_left_in_iMCU_row > 2))\n      set_wraparound_pointers(cinfo);\n    main_ptr->buffer_full = FALSE;\n    main_ptr->rowgroup_ctr = 0;\n    main_ptr->context_state = CTX_PREPARE_FOR_IMCU;\n    upsample->next_row_out = cinfo->max_v_samp_factor;\n    upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n  }\n\n  /* Skipping is much simpler when context rows are not required. */\n  else {\n    if (num_lines < lines_left_in_iMCU_row) {\n      increment_simple_rowgroup_ctr(cinfo, num_lines);\n      return num_lines;\n    } else {\n      cinfo->output_scanline += lines_left_in_iMCU_row;\n      main_ptr->buffer_full = FALSE;\n      main_ptr->rowgroup_ctr = 0;\n      upsample->next_row_out = cinfo->max_v_samp_factor;\n      upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n    }\n  }\n\n  /* Calculate how many full iMCU rows we can skip. */\n  if (cinfo->upsample->need_context_rows)\n    lines_to_skip = ((lines_after_iMCU_row - 1) / lines_per_iMCU_row) *\n                    lines_per_iMCU_row;\n  else\n    lines_to_skip = (lines_after_iMCU_row / lines_per_iMCU_row) *\n                    lines_per_iMCU_row;\n  /* Calculate the number of lines that remain to be skipped after skipping all\n   * of the full iMCU rows that we can.  We will not read these lines unless we\n   * have to.\n   */\n  lines_to_read = lines_after_iMCU_row - lines_to_skip;\n\n  /* For images requiring multiple scans (progressive, non-interleaved, etc.),\n   * all of the entropy decoding occurs in jpeg_start_decompress(), assuming\n   * that the input data source is non-suspending.  This makes skipping easy.\n   */\n  if (cinfo->inputctl->has_multiple_scans) {\n    if (cinfo->upsample->need_context_rows) {\n      cinfo->output_scanline += lines_to_skip;\n      cinfo->output_iMCU_row += lines_to_skip / lines_per_iMCU_row;\n      main_ptr->iMCU_row_ctr += lines_to_skip / lines_per_iMCU_row;\n      /* It is complex to properly move to the middle of a context block, so\n       * read the remaining lines instead of skipping them.\n       */\n      read_and_discard_scanlines(cinfo, lines_to_read);\n    } else {\n      cinfo->output_scanline += lines_to_skip;\n      cinfo->output_iMCU_row += lines_to_skip / lines_per_iMCU_row;\n      increment_simple_rowgroup_ctr(cinfo, lines_to_read);\n    }\n    upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n    return num_lines;\n  }\n\n  /* Skip the iMCU rows that we can safely skip. */\n  for (i = 0; i < lines_to_skip; i += lines_per_iMCU_row) {\n    for (y = 0; y < coef->MCU_rows_per_iMCU_row; y++) {\n      for (x = 0; x < cinfo->MCUs_per_row; x++) {\n        /* Calling decode_mcu() with a NULL pointer causes it to discard the\n         * decoded coefficients.  This is ~5% faster for large subsets, but\n         * it's tough to tell a difference for smaller images.\n         */\n        (*cinfo->entropy->decode_mcu) (cinfo, NULL);\n      }\n    }\n    cinfo->input_iMCU_row++;\n    cinfo->output_iMCU_row++;\n    if (cinfo->input_iMCU_row < cinfo->total_iMCU_rows)\n      start_iMCU_row(cinfo);\n    else\n      (*cinfo->inputctl->finish_input_pass) (cinfo);\n  }\n  cinfo->output_scanline += lines_to_skip;\n\n  if (cinfo->upsample->need_context_rows) {\n    /* Context-based upsampling keeps track of iMCU rows. */\n    main_ptr->iMCU_row_ctr += lines_to_skip / lines_per_iMCU_row;\n\n    /* It is complex to properly move to the middle of a context block, so\n     * read the remaining lines instead of skipping them.\n     */\n    read_and_discard_scanlines(cinfo, lines_to_read);\n  } else {\n    increment_simple_rowgroup_ctr(cinfo, lines_to_read);\n  }\n\n  /* Since skipping lines involves skipping the upsampling step, the value of\n   * \"rows_to_go\" will become invalid unless we set it here.  NOTE: This is a\n   * bit odd, since \"rows_to_go\" seems to be redundantly keeping track of\n   * output_scanline.\n   */\n  upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n\n  /* Always skip the requested number of lines. */\n  return num_lines;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 412,
    "critical_vars": [
      "master"
    ],
    "function": "jpeg_skip_scanlines",
    "filename": "libjpeg-turbo/CVE-2020-35538/CVE-2020-35538_CWE-476_9120a247436e84c0b4eea828cb11e8f665fcde30_jdapistd.c.diff",
    "function_code": "jpeg_skip_scanlines(j_decompress_ptr cinfo, JDIMENSION num_lines)\n{\n  my_main_ptr main_ptr = (my_main_ptr)cinfo->main;\n  my_coef_ptr coef = (my_coef_ptr)cinfo->coef;\n  my_master_ptr master = (my_master_ptr)cinfo->master;\n  JDIMENSION i, x;\n  int y;\n  JDIMENSION lines_per_iMCU_row, lines_left_in_iMCU_row, lines_after_iMCU_row;\n  JDIMENSION lines_to_skip, lines_to_read;\n\n  if (cinfo->global_state != DSTATE_SCANNING)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n\n  /* Do not skip past the bottom of the image. */\n  if (cinfo->output_scanline + num_lines >= cinfo->output_height) {\n    cinfo->output_scanline = cinfo->output_height;\n    (*cinfo->inputctl->finish_input_pass) (cinfo);\n    cinfo->inputctl->eoi_reached = TRUE;\n    return cinfo->output_height - cinfo->output_scanline;\n  }\n\n  if (num_lines == 0)\n    return 0;\n\n  lines_per_iMCU_row = cinfo->_min_DCT_scaled_size * cinfo->max_v_samp_factor;\n  lines_left_in_iMCU_row =\n    (lines_per_iMCU_row - (cinfo->output_scanline % lines_per_iMCU_row)) %\n    lines_per_iMCU_row;\n  lines_after_iMCU_row = num_lines - lines_left_in_iMCU_row;\n\n  /* Skip the lines remaining in the current iMCU row.  When upsampling\n   * requires context rows, we need the previous and next rows in order to read\n   * the current row.  This adds some complexity.\n   */\n  if (cinfo->upsample->need_context_rows) {\n    /* If the skipped lines would not move us past the current iMCU row, we\n     * read the lines and ignore them.  There might be a faster way of doing\n     * this, but we are facing increasing complexity for diminishing returns.\n     * The increasing complexity would be a by-product of meddling with the\n     * state machine used to skip context rows.  Near the end of an iMCU row,\n     * the next iMCU row may have already been entropy-decoded.  In this unique\n     * case, we will read the next iMCU row if we cannot skip past it as well.\n     */\n    if ((num_lines < lines_left_in_iMCU_row + 1) ||\n        (lines_left_in_iMCU_row <= 1 && main_ptr->buffer_full &&\n         lines_after_iMCU_row < lines_per_iMCU_row + 1)) {\n      read_and_discard_scanlines(cinfo, num_lines);\n      return num_lines;\n    }\n\n    /* If the next iMCU row has already been entropy-decoded, make sure that\n     * we do not skip too far.\n     */\n    if (lines_left_in_iMCU_row <= 1 && main_ptr->buffer_full) {\n      cinfo->output_scanline += lines_left_in_iMCU_row + lines_per_iMCU_row;\n      lines_after_iMCU_row -= lines_per_iMCU_row;\n    } else {\n      cinfo->output_scanline += lines_left_in_iMCU_row;\n    }\n\n    /* If we have just completed the first block, adjust the buffer pointers */\n    if (main_ptr->iMCU_row_ctr == 0 ||\n        (main_ptr->iMCU_row_ctr == 1 && lines_left_in_iMCU_row > 2))\n      set_wraparound_pointers(cinfo);\n    main_ptr->buffer_full = FALSE;\n    main_ptr->rowgroup_ctr = 0;\n    main_ptr->context_state = CTX_PREPARE_FOR_IMCU;\n    if (master->using_merged_upsample) {\n      my_merged_upsample_ptr upsample =\n        (my_merged_upsample_ptr)cinfo->upsample;\n      upsample->spare_full = FALSE;\n      upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n    } else {\n      my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n      upsample->next_row_out = cinfo->max_v_samp_factor;\n      upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n    }\n  }\n\n  /* Skipping is much simpler when context rows are not required. */\n  else {\n    if (num_lines < lines_left_in_iMCU_row) {\n      increment_simple_rowgroup_ctr(cinfo, num_lines);\n      return num_lines;\n    } else {\n      cinfo->output_scanline += lines_left_in_iMCU_row;\n      main_ptr->buffer_full = FALSE;\n      main_ptr->rowgroup_ctr = 0;\n      if (master->using_merged_upsample) {\n        my_merged_upsample_ptr upsample =\n          (my_merged_upsample_ptr)cinfo->upsample;\n        upsample->spare_full = FALSE;\n        upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n      } else {\n        my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n        upsample->next_row_out = cinfo->max_v_samp_factor;\n        upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n      }\n    }\n  }\n\n  /* Calculate how many full iMCU rows we can skip. */\n  if (cinfo->upsample->need_context_rows)\n    lines_to_skip = ((lines_after_iMCU_row - 1) / lines_per_iMCU_row) *\n                    lines_per_iMCU_row;\n  else\n    lines_to_skip = (lines_after_iMCU_row / lines_per_iMCU_row) *\n                    lines_per_iMCU_row;\n  /* Calculate the number of lines that remain to be skipped after skipping all\n   * of the full iMCU rows that we can.  We will not read these lines unless we\n   * have to.\n   */\n  lines_to_read = lines_after_iMCU_row - lines_to_skip;\n\n  /* For images requiring multiple scans (progressive, non-interleaved, etc.),\n   * all of the entropy decoding occurs in jpeg_start_decompress(), assuming\n   * that the input data source is non-suspending.  This makes skipping easy.\n   */\n  if (cinfo->inputctl->has_multiple_scans) {\n    if (cinfo->upsample->need_context_rows) {\n      cinfo->output_scanline += lines_to_skip;\n      cinfo->output_iMCU_row += lines_to_skip / lines_per_iMCU_row;\n      main_ptr->iMCU_row_ctr += lines_to_skip / lines_per_iMCU_row;\n      /* It is complex to properly move to the middle of a context block, so\n       * read the remaining lines instead of skipping them.\n       */\n      read_and_discard_scanlines(cinfo, lines_to_read);\n    } else {\n      cinfo->output_scanline += lines_to_skip;\n      cinfo->output_iMCU_row += lines_to_skip / lines_per_iMCU_row;\n      increment_simple_rowgroup_ctr(cinfo, lines_to_read);\n    }\n    if (master->using_merged_upsample) {\n      my_merged_upsample_ptr upsample =\n        (my_merged_upsample_ptr)cinfo->upsample;\n      upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n    } else {\n      my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n      upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n    }\n    return num_lines;\n  }\n\n  /* Skip the iMCU rows that we can safely skip. */\n  for (i = 0; i < lines_to_skip; i += lines_per_iMCU_row) {\n    for (y = 0; y < coef->MCU_rows_per_iMCU_row; y++) {\n      for (x = 0; x < cinfo->MCUs_per_row; x++) {\n        /* Calling decode_mcu() with a NULL pointer causes it to discard the\n         * decoded coefficients.  This is ~5% faster for large subsets, but\n         * it's tough to tell a difference for smaller images.\n         */\n        (*cinfo->entropy->decode_mcu) (cinfo, NULL);\n      }\n    }\n    cinfo->input_iMCU_row++;\n    cinfo->output_iMCU_row++;\n    if (cinfo->input_iMCU_row < cinfo->total_iMCU_rows)\n      start_iMCU_row(cinfo);\n    else\n      (*cinfo->inputctl->finish_input_pass) (cinfo);\n  }\n  cinfo->output_scanline += lines_to_skip;\n\n  if (cinfo->upsample->need_context_rows) {\n    /* Context-based upsampling keeps track of iMCU rows. */\n    main_ptr->iMCU_row_ctr += lines_to_skip / lines_per_iMCU_row;\n\n    /* It is complex to properly move to the middle of a context block, so\n     * read the remaining lines instead of skipping them.\n     */\n    read_and_discard_scanlines(cinfo, lines_to_read);\n  } else {\n    increment_simple_rowgroup_ctr(cinfo, lines_to_read);\n  }\n\n  /* Since skipping lines involves skipping the upsampling step, the value of\n   * \"rows_to_go\" will become invalid unless we set it here.  NOTE: This is a\n   * bit odd, since \"rows_to_go\" seems to be redundantly keeping track of\n   * output_scanline.\n   */\n  if (master->using_merged_upsample) {\n    my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;\n    upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n  } else {\n    my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n    upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n  }\n\n  /* Always skip the requested number of lines. */\n  return num_lines;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 174,
    "critical_vars": [
      "s",
      "aString",
      "bufsize"
    ],
    "function": "DU_getStringDOElement",
    "filename": "dcmtk/CVE-2021-41689/CVE-2021-41689_CWE-476_5c14bf53fb42ceca12bbcc0016e8704b1580920d_diutil.cc.diff",
    "function_code": "DU_getStringDOElement(DcmItem *obj, DcmTagKey t, char *s, size_t bufsize)\n{\n    DcmByteString *elem;\n    DcmStack stack;\n    OFCondition ec = EC_Normal;\n    char* aString;\n\n    ec = obj->search(t, stack);\n    elem = (DcmByteString*) stack.top();\n    if (ec == EC_Normal && elem != NULL) {\n        if (elem->getLength() == 0) {\n            s[0] = '\\0';\n        } else {\n            ec =  elem->getString(aString);\n            OFStandard::strlcpy(s, aString, bufsize);\n        }\n    }\n    return (ec == EC_Normal);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 174,
    "critical_vars": [
      "EC_Normal",
      "ec"
    ],
    "function": "DU_getStringDOElement",
    "filename": "dcmtk/CVE-2021-41689/CVE-2021-41689_CWE-476_5c14bf53fb42ceca12bbcc0016e8704b1580920d_diutil.cc.diff",
    "function_code": "DU_getStringDOElement(DcmItem *obj, DcmTagKey t, char *s, size_t bufsize)\n{\n    DcmByteString *elem;\n    DcmStack stack;\n    OFCondition ec = EC_Normal;\n    char* aString;\n\n    ec = obj->search(t, stack);\n    elem = (DcmByteString*) stack.top();\n    if (ec == EC_Normal && elem != NULL) {\n        if (elem->getLength() == 0) {\n            s[0] = '\\0';\n        } else {\n            ec =  elem->getString(aString);\n            if (ec == EC_Normal)\n                OFStandard::strlcpy(s, aString, bufsize);\n        }\n    }\n    return (ec == EC_Normal);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 1839,
    "critical_vars": [
      "data->part[data->num_of_part].content_type"
    ],
    "function": "on_header_value",
    "filename": "open5gs/CVE-2021-44108/CVE-2021-44108_CWE-476_d919b2744cd05abae043490f0a3dd1946c1ccb8c_message.c.diff",
    "function_code": "static int on_header_value(\n        multipart_parser *parser, const char *at, size_t length)\n{\n    multipart_parser_data_t *data = NULL;\n\n    ogs_assert(parser);\n    data = multipart_parser_get_data(parser);\n    ogs_assert(data);\n\n    if (at && length) {\n        SWITCH(data->header_field)\n        CASE(OGS_SBI_CONTENT_TYPE)\n            if (data->part[data->num_of_part].content_type)\n                ogs_free(data->part[data->num_of_part].content_type);\n            data->part[data->num_of_part].content_type =\n                ogs_strndup(at, length);\n            ogs_assert(data->part[data->num_of_part].content_type);\n            break;\n        CASE(OGS_SBI_CONTENT_ID)\n            if (data->part[data->num_of_part].content_id)\n                ogs_free(data->part[data->num_of_part].content_id);\n            data->part[data->num_of_part].content_id =\n                ogs_strndup(at, length);\n            ogs_assert(data->part[data->num_of_part].content_id);\n            break;\n\n        DEFAULT\n            ogs_error(\"Unknown header field [%s]\", data->header_field);\n        END\n    }\n\n    return 0;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1836,
    "critical_vars": [
      "data->num_of_part"
    ],
    "function": "on_header_value",
    "filename": "open5gs/CVE-2021-44108/CVE-2021-44108_CWE-476_d919b2744cd05abae043490f0a3dd1946c1ccb8c_message.c.diff",
    "function_code": "static int on_header_value(\n        multipart_parser *parser, const char *at, size_t length)\n{\n    multipart_parser_data_t *data = NULL;\n\n    ogs_assert(parser);\n    data = multipart_parser_get_data(parser);\n    ogs_assert(data);\n\n    if (data->num_of_part < OGS_SBI_MAX_NUM_OF_PART && at && length) {\n        SWITCH(data->header_field)\n        CASE(OGS_SBI_CONTENT_TYPE)\n            ogs_assert(data->part[data->num_of_part].content_type == NULL);\n            data->part[data->num_of_part].content_type =\n                ogs_strndup(at, length);\n            ogs_assert(data->part[data->num_of_part].content_type);\n            break;\n        CASE(OGS_SBI_CONTENT_ID)\n            ogs_assert(data->part[data->num_of_part].content_id == NULL);\n            data->part[data->num_of_part].content_id =\n                ogs_strndup(at, length);\n            ogs_assert(data->part[data->num_of_part].content_id);\n            break;\n\n        DEFAULT\n            ogs_error(\"Unknown header field [%s]\", data->header_field);\n        END\n    }\n\n    return 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 1904,
    "critical_vars": [
      "length",
      "at"
    ],
    "function": "on_part_data",
    "filename": "open5gs/CVE-2021-44108/CVE-2021-44108_CWE-476_d919b2744cd05abae043490f0a3dd1946c1ccb8c_message.c.diff",
    "function_code": "static int on_part_data(\n        multipart_parser *parser, const char *at, size_t length)\n{\n    multipart_parser_data_t *data = NULL;\n\n    ogs_assert(parser);\n    data = multipart_parser_get_data(parser);\n    ogs_assert(data);\n\n    if (at && length) {\n        SWITCH(data->part[data->num_of_part].content_type)\n        CASE(OGS_SBI_CONTENT_JSON_TYPE)\n        CASE(OGS_SBI_CONTENT_5GNAS_TYPE)\n        CASE(OGS_SBI_CONTENT_NGAP_TYPE)\n            size_t offset = 0;\n\n            if (data->part[data->num_of_part].content == NULL) {\n                data->part[data->num_of_part].content_length = length;\n                data->part[data->num_of_part].content =\n                    (char *)ogs_malloc(length + 1);\n                ogs_assert(data->part[data->num_of_part].content);\n            } else {\n                offset = data->part[data->num_of_part].content_length;\n                if ((data->part[data->num_of_part].content_length + length) >\n                        OGS_HUGE_LEN) {\n                    ogs_error(\"Overflow length [%d:%d]\",\n                        (int)data->part[data->num_of_part].content_length,\n                        (int)length);\n                    ogs_assert_if_reached();\n                    return 0;\n                }\n                data->part[data->num_of_part].content_length += length;\n                data->part[data->num_of_part].content = (char *)ogs_realloc(\n                    data->part[data->num_of_part].content,\n                    data->part[data->num_of_part].content_length + 1);\n                ogs_assert(data->part[data->num_of_part].content);\n            }\n            memcpy(data->part[data->num_of_part].content + offset, at, length);\n            data->part[data->num_of_part].content[\n                data->part[data->num_of_part].content_length] = 0;\n            break;\n\n        DEFAULT\n            ogs_log_hexdump(OGS_LOG_FATAL, (unsigned char *)at, length);\n            ogs_error(\"Unknown content_type [%s]\",\n                    data->part[data->num_of_part].content_type);\n        END\n    }\n    return 0;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1868,
    "critical_vars": [
      "data->num_of_part"
    ],
    "function": "on_part_data",
    "filename": "open5gs/CVE-2021-44108/CVE-2021-44108_CWE-476_d919b2744cd05abae043490f0a3dd1946c1ccb8c_message.c.diff",
    "function_code": "static int on_part_data(\n        multipart_parser *parser, const char *at, size_t length)\n{\n    multipart_parser_data_t *data = NULL;\n\n    ogs_assert(parser);\n    data = multipart_parser_get_data(parser);\n    ogs_assert(data);\n\n    if (data->num_of_part < OGS_SBI_MAX_NUM_OF_PART && at && length) {\n        SWITCH(data->part[data->num_of_part].content_type)\n        CASE(OGS_SBI_CONTENT_JSON_TYPE)\n        CASE(OGS_SBI_CONTENT_5GNAS_TYPE)\n        CASE(OGS_SBI_CONTENT_NGAP_TYPE)\n            size_t offset = 0;\n\n            if (data->part[data->num_of_part].content == NULL) {\n                data->part[data->num_of_part].content_length = length;\n                data->part[data->num_of_part].content =\n                    (char *)ogs_malloc(length + 1);\n                ogs_assert(data->part[data->num_of_part].content);\n            } else {\n                offset = data->part[data->num_of_part].content_length;\n                if ((data->part[data->num_of_part].content_length + length) >\n                        OGS_HUGE_LEN) {\n                    ogs_error(\"Overflow length [%d:%d]\",\n                        (int)data->part[data->num_of_part].content_length,\n                        (int)length);\n                    ogs_assert_if_reached();\n                    return 0;\n                }\n                data->part[data->num_of_part].content_length += length;\n                data->part[data->num_of_part].content = (char *)ogs_realloc(\n                    data->part[data->num_of_part].content,\n                    data->part[data->num_of_part].content_length + 1);\n                ogs_assert(data->part[data->num_of_part].content);\n            }\n            memcpy(data->part[data->num_of_part].content + offset, at, length);\n            data->part[data->num_of_part].content[\n                data->part[data->num_of_part].content_length] = 0;\n            break;\n\n        DEFAULT\n            ogs_error(\"Unknown content_type [%s]\",\n                    data->part[data->num_of_part].content_type);\n            ogs_log_hexdump(OGS_LOG_ERROR, (unsigned char *)at, length);\n        END\n    }\n    return 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 1920,
    "critical_vars": [
      "data->num_of_part"
    ],
    "function": "on_part_data_end",
    "filename": "open5gs/CVE-2021-44108/CVE-2021-44108_CWE-476_d919b2744cd05abae043490f0a3dd1946c1ccb8c_message.c.diff",
    "function_code": "static int on_part_data_end(multipart_parser *parser)\n{\n    multipart_parser_data_t *data = NULL;\n\n    ogs_assert(parser);\n    data = multipart_parser_get_data(parser);\n    ogs_assert(data);\n\n    data->num_of_part++;\n\n    return 0;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1918,
    "critical_vars": [
      "data->num_of_part"
    ],
    "function": "on_part_data_end",
    "filename": "open5gs/CVE-2021-44108/CVE-2021-44108_CWE-476_d919b2744cd05abae043490f0a3dd1946c1ccb8c_message.c.diff",
    "function_code": "static int on_part_data_end(multipart_parser *parser)\n{\n    multipart_parser_data_t *data = NULL;\n\n    ogs_assert(parser);\n    data = multipart_parser_get_data(parser);\n    ogs_assert(data);\n\n    if (data->num_of_part < OGS_SBI_MAX_NUM_OF_PART) {\n        data->num_of_part++;\n    }\n\n    return 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 2019,
    "critical_vars": [
      "data.part[i].content_id"
    ],
    "function": "parse_multipart",
    "filename": "open5gs/CVE-2021-44108/CVE-2021-44108_CWE-476_d919b2744cd05abae043490f0a3dd1946c1ccb8c_message.c.diff",
    "function_code": "static int parse_multipart(\n        ogs_sbi_message_t *message, ogs_sbi_http_message_t *http)\n{\n    char *boundary = NULL;\n    int i;\n\n    multipart_parser_settings settings;\n    multipart_parser_data_t data;\n\n    multipart_parser *parser = NULL;\n\n    ogs_assert(message);\n    ogs_assert(http);\n\n    memset(&settings, 0, sizeof(settings));\n    settings.on_header_field = &on_header_field;\n    settings.on_header_value = &on_header_value;\n    settings.on_part_data = &on_part_data;\n    settings.on_part_data_end = &on_part_data_end;\n\n    for (i = 0; i < http->content_length; i++) {\n        if (http->content[i] == '\\r' && http->content[i+1] == '\\n')\n            break;\n    }\n\n    if (i >= http->content_length) {\n        ogs_error(\"Invalid HTTP content [%d]\", i);\n        ogs_log_hexdump(OGS_LOG_ERROR,\n                (unsigned char *)http->content, http->content_length);\n        return OGS_ERROR;\n    }\n\n    boundary = ogs_strndup(http->content, i);\n    ogs_assert(boundary);\n\n    parser = multipart_parser_init(boundary, &settings);\n    ogs_assert(parser);\n\n    memset(&data, 0, sizeof(data));\n    multipart_parser_set_data(parser, &data);\n    multipart_parser_execute(parser, http->content, http->content_length);\n\n    multipart_parser_free(parser);\n    ogs_free(boundary);\n\n    for (i = 0; i < data.num_of_part; i++) {\n        SWITCH(data.part[i].content_type)\n        CASE(OGS_SBI_CONTENT_JSON_TYPE)\n            parse_json(message,\n                    data.part[i].content_type, data.part[i].content);\n\n            if (data.part[i].content_id)\n                ogs_free(data.part[i].content_id);\n            if (data.part[i].content_type)\n                ogs_free(data.part[i].content_type);\n            if (data.part[i].content)\n                ogs_free(data.part[i].content);\n\n            break;\n\n        CASE(OGS_SBI_CONTENT_5GNAS_TYPE)\n        CASE(OGS_SBI_CONTENT_NGAP_TYPE)\n            http->part[http->num_of_part].content_id =\n                data.part[i].content_id;\n            http->part[http->num_of_part].content_type =\n                data.part[i].content_type;\n            http->part[http->num_of_part].pkbuf =\n                ogs_pkbuf_alloc(NULL, data.part[i].content_length);\n            ogs_expect_or_return_val(\n                http->part[http->num_of_part].pkbuf, OGS_ERROR);\n            ogs_pkbuf_put_data(http->part[http->num_of_part].pkbuf,\n                data.part[i].content, data.part[i].content_length);\n\n            message->part[message->num_of_part].content_id =\n                http->part[http->num_of_part].content_id;\n            message->part[message->num_of_part].content_type =\n                http->part[http->num_of_part].content_type;\n            message->part[message->num_of_part].pkbuf =\n                ogs_pkbuf_copy(http->part[http->num_of_part].pkbuf);\n            ogs_expect_or_return_val(\n                message->part[message->num_of_part].pkbuf, OGS_ERROR);\n\n            http->num_of_part++;\n            message->num_of_part++;\n\n            if (data.part[i].content)\n                ogs_free(data.part[i].content);\n            break;\n\n        DEFAULT\n            ogs_error(\"Unknown content-type[%s]\", data.part[i].content_type);\n        END\n    }\n\n    if (data.part[i].content_id)\n        ogs_free(data.part[i].content_id);\n    if (data.part[i].content_type)\n        ogs_free(data.part[i].content_type);\n\n    if (data.header_field)\n        ogs_free(data.header_field);\n\n    return OGS_OK;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1970,
    "critical_vars": [
      "data.num_of_part"
    ],
    "function": "parse_multipart",
    "filename": "open5gs/CVE-2021-44108/CVE-2021-44108_CWE-476_d919b2744cd05abae043490f0a3dd1946c1ccb8c_message.c.diff",
    "function_code": "static int parse_multipart(\n        ogs_sbi_message_t *message, ogs_sbi_http_message_t *http)\n{\n    char *boundary = NULL;\n    int i;\n\n    multipart_parser_settings settings;\n    multipart_parser_data_t data;\n\n    multipart_parser *parser = NULL;\n\n    ogs_assert(message);\n    ogs_assert(http);\n\n    memset(&settings, 0, sizeof(settings));\n    settings.on_header_field = &on_header_field;\n    settings.on_header_value = &on_header_value;\n    settings.on_part_data = &on_part_data;\n    settings.on_part_data_end = &on_part_data_end;\n\n    for (i = 0; i < http->content_length; i++) {\n        if (http->content[i] == '\\r' && http->content[i+1] == '\\n')\n            break;\n    }\n\n    if (i >= http->content_length) {\n        ogs_error(\"Invalid HTTP content [%d]\", i);\n        ogs_log_hexdump(OGS_LOG_ERROR,\n                (unsigned char *)http->content, http->content_length);\n        return OGS_ERROR;\n    }\n\n    boundary = ogs_strndup(http->content, i);\n    ogs_assert(boundary);\n\n    parser = multipart_parser_init(boundary, &settings);\n    ogs_assert(parser);\n\n    memset(&data, 0, sizeof(data));\n    multipart_parser_set_data(parser, &data);\n    multipart_parser_execute(parser, http->content, http->content_length);\n\n    multipart_parser_free(parser);\n    ogs_free(boundary);\n\n    if (data.num_of_part > OGS_SBI_MAX_NUM_OF_PART) {\n        /* Overflow Issues #1247 */\n        ogs_fatal(\"Overflow num_of_part[%d]\", data.num_of_part);\n        ogs_assert_if_reached();\n    }\n    for (i = 0; i < data.num_of_part; i++) {\n        SWITCH(data.part[i].content_type)\n        CASE(OGS_SBI_CONTENT_JSON_TYPE)\n            parse_json(message,\n                    data.part[i].content_type, data.part[i].content);\n\n            if (data.part[i].content_id)\n                ogs_free(data.part[i].content_id);\n            if (data.part[i].content_type)\n                ogs_free(data.part[i].content_type);\n            if (data.part[i].content)\n                ogs_free(data.part[i].content);\n\n            break;\n\n        CASE(OGS_SBI_CONTENT_5GNAS_TYPE)\n        CASE(OGS_SBI_CONTENT_NGAP_TYPE)\n            http->part[http->num_of_part].content_id =\n                data.part[i].content_id;\n            http->part[http->num_of_part].content_type =\n                data.part[i].content_type;\n            http->part[http->num_of_part].pkbuf =\n                ogs_pkbuf_alloc(NULL, data.part[i].content_length);\n            ogs_expect_or_return_val(\n                http->part[http->num_of_part].pkbuf, OGS_ERROR);\n            ogs_pkbuf_put_data(http->part[http->num_of_part].pkbuf,\n                data.part[i].content, data.part[i].content_length);\n\n            message->part[message->num_of_part].content_id =\n                http->part[http->num_of_part].content_id;\n            message->part[message->num_of_part].content_type =\n                http->part[http->num_of_part].content_type;\n            message->part[message->num_of_part].pkbuf =\n                ogs_pkbuf_copy(http->part[http->num_of_part].pkbuf);\n            ogs_expect_or_return_val(\n                message->part[message->num_of_part].pkbuf, OGS_ERROR);\n\n            http->num_of_part++;\n            message->num_of_part++;\n\n            if (data.part[i].content)\n                ogs_free(data.part[i].content);\n            break;\n\n        DEFAULT\n            ogs_error(\"Unknown content-type[%s]\", data.part[i].content_type);\n\n            if (data.part[i].content_id)\n                ogs_free(data.part[i].content_id);\n            if (data.part[i].content_type)\n                ogs_free(data.part[i].content_type);\n        END\n    }\n\n    if (data.header_field)\n        ogs_free(data.header_field);\n\n    return OGS_OK;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 156,
    "critical_vars": [
      "n2InfoContent->ngap_ie_type"
    ],
    "function": "amf_namf_comm_handle_n1_n2_message_transfer",
    "filename": "open5gs/CVE-2021-44108/CVE-2021-44108_CWE-476_d919b2744cd05abae043490f0a3dd1946c1ccb8c_namf-handler.c.diff",
    "function_code": "int amf_namf_comm_handle_n1_n2_message_transfer(\n        ogs_sbi_stream_t *stream, ogs_sbi_message_t *recvmsg)\n{\n    int status;\n\n    amf_ue_t *amf_ue = NULL;\n    amf_sess_t *sess = NULL;\n\n    ogs_pkbuf_t *n1buf = NULL;\n    ogs_pkbuf_t *n2buf = NULL;\n\n    ogs_pkbuf_t *gmmbuf = NULL;\n    ogs_pkbuf_t *ngapbuf = NULL;\n\n    char *supi = NULL;\n    uint8_t pdu_session_id = OGS_NAS_PDU_SESSION_IDENTITY_UNASSIGNED;\n\n    ogs_sbi_message_t sendmsg;\n    ogs_sbi_response_t *response = NULL;\n\n    OpenAPI_n1_n2_message_transfer_req_data_t *N1N2MessageTransferReqData;\n    OpenAPI_n1_n2_message_transfer_rsp_data_t N1N2MessageTransferRspData;\n    OpenAPI_n1_message_container_t *n1MessageContainer = NULL;\n    OpenAPI_ref_to_binary_data_t *n1MessageContent = NULL;\n    OpenAPI_n2_info_container_t *n2InfoContainer = NULL;\n    OpenAPI_n2_sm_information_t *smInfo = NULL;\n    OpenAPI_n2_info_content_t *n2InfoContent = NULL;\n    OpenAPI_ref_to_binary_data_t *ngapData = NULL;\n\n    ogs_assert(stream);\n    ogs_assert(recvmsg);\n\n    N1N2MessageTransferReqData = recvmsg->N1N2MessageTransferReqData;\n    if (!N1N2MessageTransferReqData) {\n        ogs_error(\"No N1N2MessageTransferReqData\");\n        return OGS_ERROR;\n    }\n\n    if (N1N2MessageTransferReqData->is_pdu_session_id == false) {\n        ogs_error(\"No PDU Session Identity\");\n        return OGS_ERROR;\n    }\n    pdu_session_id = N1N2MessageTransferReqData->pdu_session_id;\n\n    supi = recvmsg->h.resource.component[1];\n    if (!supi) {\n        ogs_error(\"No SUPI\");\n        return OGS_ERROR;\n    }\n\n    amf_ue = amf_ue_find_by_supi(supi);\n    if (!amf_ue) {\n        ogs_error(\"No UE context [%s]\", supi);\n        return OGS_ERROR;\n    }\n\n    sess = amf_sess_find_by_psi(amf_ue, pdu_session_id);\n    if (!sess) {\n        ogs_error(\"[%s] No PDU Session Context [%d]\",\n                amf_ue->supi, pdu_session_id);\n        return OGS_ERROR;\n    }\n\n    n1MessageContainer = N1N2MessageTransferReqData->n1_message_container;\n    if (n1MessageContainer) {\n        n1MessageContent = n1MessageContainer->n1_message_content;\n        if (!n1MessageContent || !n1MessageContent->content_id) {\n            ogs_error(\"No n1MessageContent\");\n            return OGS_ERROR;\n        }\n\n        n1buf = ogs_sbi_find_part_by_content_id(\n                recvmsg, n1MessageContent->content_id);\n        if (!n1buf) {\n            ogs_error(\"[%s] No N1 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        /*\n         * NOTE : The pkbuf created in the SBI message will be removed\n         *        from ogs_sbi_message_free(), so it must be copied.\n         */\n        n1buf = ogs_pkbuf_copy(n1buf);\n        ogs_assert(n1buf);\n    }\n\n    n2InfoContainer = N1N2MessageTransferReqData->n2_info_container;\n    if (n2InfoContainer) {\n        smInfo = n2InfoContainer->sm_info;\n        if (!smInfo) {\n            ogs_error(\"No smInfo\");\n            return OGS_ERROR;\n        }\n        n2InfoContent = smInfo->n2_info_content;\n        if (!n2InfoContent) {\n            ogs_error(\"No n2InfoContent\");\n            return OGS_ERROR;\n        }\n\n        ngapData = n2InfoContent->ngap_data;\n        if (!ngapData || !ngapData->content_id) {\n            ogs_error(\"No ngapData\");\n            return OGS_ERROR;\n        }\n        n2buf = ogs_sbi_find_part_by_content_id(\n                recvmsg, ngapData->content_id);\n        if (!n2buf) {\n            ogs_error(\"[%s] No N2 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        /*\n         * NOTE : The pkbuf created in the SBI message will be removed\n         *        from ogs_sbi_message_free(), so it must be copied.\n         */\n        n2buf = ogs_pkbuf_copy(n2buf);\n        ogs_assert(n2buf);\n    }\n\n    memset(&sendmsg, 0, sizeof(sendmsg));\n\n    status = OGS_SBI_HTTP_STATUS_OK;\n\n    memset(&N1N2MessageTransferRspData, 0, sizeof(N1N2MessageTransferRspData));\n    N1N2MessageTransferRspData.cause =\n        OpenAPI_n1_n2_message_transfer_cause_N1_N2_TRANSFER_INITIATED;\n\n    sendmsg.N1N2MessageTransferRspData = &N1N2MessageTransferRspData;\n\n    switch (n2InfoContent->ngap_ie_type) {\n    case OpenAPI_ngap_ie_type_PDU_RES_SETUP_REQ:\n        if (!n2buf) {\n            ogs_error(\"[%s] No N2 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        if (n1buf) {\n            gmmbuf = gmm_build_dl_nas_transport(sess,\n                    OGS_NAS_PAYLOAD_CONTAINER_N1_SM_INFORMATION, n1buf, 0, 0);\n            ogs_assert(gmmbuf);\n        }\n\n        if (gmmbuf) {\n            ran_ue_t *ran_ue = NULL;\n\n            /***********************************\n             * 4.3.2 PDU Session Establishment *\n             ***********************************/\n\n            ran_ue = ran_ue_cycle(amf_ue->ran_ue);\n            ogs_assert(ran_ue);\n\n            if (sess->pdu_session_establishment_accept) {\n                ogs_pkbuf_free(sess->pdu_session_establishment_accept);\n                sess->pdu_session_establishment_accept = NULL;\n            }\n\n            if (ran_ue->initial_context_setup_request_sent == true) {\n                ngapbuf = ngap_sess_build_pdu_session_resource_setup_request(\n                        sess, gmmbuf, n2buf);\n                ogs_assert(ngapbuf);\n            } else {\n                ngapbuf = ngap_sess_build_initial_context_setup_request(\n                        sess, gmmbuf, n2buf);\n                ogs_assert(ngapbuf);\n\n                ran_ue->initial_context_setup_request_sent = true;\n            }\n\n            if (SESSION_CONTEXT_IN_SMF(sess)) {\n                /*\n                 * [1-CLIENT] /nsmf-pdusession/v1/sm-contexts\n                 * [2-SERVER] /namf-comm/v1/ue-contexts/{supi}/n1-n2-messages\n                 *\n                 * If [2-SERVER] arrives after [1-CLIENT],\n                 * sm-context-ref is created in [1-CLIENT].\n                 * So, the PDU session establishment accpet can be transmitted.\n                 */\n                if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK)\n                    ogs_error(\"nas_5gs_send_to_gnb() failed\");\n            } else {\n                sess->pdu_session_establishment_accept = ngapbuf;\n            }\n\n        } else {\n            /*********************************************\n             * 4.2.3.3 Network Triggered Service Request *\n             *********************************************/\n\n            if (CM_IDLE(amf_ue)) {\n                ogs_sbi_server_t *server = NULL;\n                ogs_sbi_header_t header;\n                ogs_sbi_client_t *client = NULL;\n                ogs_sockaddr_t *addr = NULL;\n\n                if (!N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri) {\n                    ogs_error(\"[%s:%d] No n1-n2-failure-notification-uri\",\n                            amf_ue->supi, sess->psi);\n                    return OGS_ERROR;\n                }\n\n                addr = ogs_sbi_getaddr_from_uri(\n                        N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri);\n                if (!addr) {\n                    ogs_error(\"[%s:%d] Invalid URI [%s]\",\n                            amf_ue->supi, sess->psi,\n                            N1N2MessageTransferReqData->\n                                n1n2_failure_txf_notif_uri);\n                    return OGS_ERROR;;\n                }\n\n                client = ogs_sbi_client_find(addr);\n                if (!client) {\n                    client = ogs_sbi_client_add(addr);\n                    ogs_assert(client);\n                }\n                OGS_SETUP_SBI_CLIENT(&sess->paging, client);\n\n                ogs_freeaddrinfo(addr);\n\n                status = OGS_SBI_HTTP_STATUS_ACCEPTED;\n                N1N2MessageTransferRspData.cause =\n                    OpenAPI_n1_n2_message_transfer_cause_ATTEMPTING_TO_REACH_UE;\n\n                /* Location */\n                server = ogs_sbi_server_from_stream(stream);\n                ogs_assert(server);\n\n                memset(&header, 0, sizeof(header));\n                header.service.name = (char *)OGS_SBI_SERVICE_NAME_NAMF_COMM;\n                header.api.version = (char *)OGS_SBI_API_V1;\n                header.resource.component[0] =\n                    (char *)OGS_SBI_RESOURCE_NAME_UE_CONTEXTS;\n                header.resource.component[1] = amf_ue->supi;\n                header.resource.component[2] =\n                    (char *)OGS_SBI_RESOURCE_NAME_N1_N2_MESSAGES;\n                header.resource.component[3] = sess->sm_context_ref;\n\n                sendmsg.http.location = ogs_sbi_server_uri(server, &header);\n\n                /* Store Paging Info */\n                AMF_SESS_STORE_PAGING_INFO(\n                        sess, sendmsg.http.location,\n                        N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri);\n\n                /* Store N2 Transfer message */\n                AMF_SESS_STORE_N2_TRANSFER(\n                        sess, pdu_session_resource_setup_request, n2buf);\n\n                ogs_assert(OGS_OK == ngap_send_paging(amf_ue));\n\n            } else if (CM_CONNECTED(amf_ue)) {\n                ogs_assert(OGS_OK ==\n                    ngap_send_pdu_resource_setup_request(sess, n2buf));\n\n            } else {\n\n                ogs_fatal(\"[%s] Invalid AMF-UE state\", amf_ue->supi);\n                ogs_assert_if_reached();\n\n            }\n\n        }\n        break;\n\n    case OpenAPI_ngap_ie_type_PDU_RES_MOD_REQ:\n        if (!n1buf) {\n            ogs_error(\"[%s] No N1 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n        if (!n2buf) {\n            ogs_error(\"[%s] No N2 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        if (CM_IDLE(amf_ue)) {\n            ogs_sbi_server_t *server = NULL;\n            ogs_sbi_header_t header;\n\n            status = OGS_SBI_HTTP_STATUS_ACCEPTED;\n            N1N2MessageTransferRspData.cause =\n                OpenAPI_n1_n2_message_transfer_cause_ATTEMPTING_TO_REACH_UE;\n\n            /* Location */\n            server = ogs_sbi_server_from_stream(stream);\n            ogs_assert(server);\n\n            memset(&header, 0, sizeof(header));\n            header.service.name = (char *)OGS_SBI_SERVICE_NAME_NAMF_COMM;\n            header.api.version = (char *)OGS_SBI_API_V1;\n            header.resource.component[0] =\n                (char *)OGS_SBI_RESOURCE_NAME_UE_CONTEXTS;\n            header.resource.component[1] = amf_ue->supi;\n            header.resource.component[2] =\n                (char *)OGS_SBI_RESOURCE_NAME_N1_N2_MESSAGES;\n            header.resource.component[3] = sess->sm_context_ref;\n\n            sendmsg.http.location = ogs_sbi_server_uri(server, &header);\n\n            /* Store Paging Info */\n            AMF_SESS_STORE_PAGING_INFO(\n                    sess, sendmsg.http.location, NULL);\n\n            /* Store 5GSM Message */\n            AMF_SESS_STORE_5GSM_MESSAGE(sess,\n                    OGS_NAS_5GS_PDU_SESSION_MODIFICATION_COMMAND,\n                    n1buf, n2buf);\n\n            ogs_assert(OGS_OK == ngap_send_paging(amf_ue));\n\n        } else if (CM_CONNECTED(amf_ue)) {\n            gmmbuf = gmm_build_dl_nas_transport(sess,\n                    OGS_NAS_PAYLOAD_CONTAINER_N1_SM_INFORMATION, n1buf, 0, 0);\n            ogs_assert(gmmbuf);\n\n            ngapbuf = ngap_build_pdu_session_resource_modify_request(\n                    sess, gmmbuf, n2buf);\n            ogs_assert(ngapbuf);\n\n            if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK)\n                ogs_error(\"nas_5gs_send_to_gnb() failed\");\n\n        } else {\n            ogs_fatal(\"[%s] Invalid AMF-UE state\", amf_ue->supi);\n            ogs_assert_if_reached();\n        }\n\n        break;\n\n    case OpenAPI_ngap_ie_type_PDU_RES_REL_CMD:\n        if (!n2buf) {\n            ogs_error(\"[%s] No N2 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        if (n1buf)\n            ogs_pkbuf_free(n1buf);\n\n        if (CM_IDLE(amf_ue)) {\n            if (n2buf)\n                ogs_pkbuf_free(n2buf);\n\n            if (N1N2MessageTransferReqData->is_skip_ind == true &&\n                N1N2MessageTransferReqData->skip_ind == true) {\n                N1N2MessageTransferRspData.cause =\n                    OpenAPI_n1_n2_message_transfer_cause_N1_MSG_NOT_TRANSFERRED;\n            } else {\n                ogs_fatal(\"[%s] No skipInd\", amf_ue->supi);\n                ogs_assert_if_reached();\n            }\n\n        } else if (CM_CONNECTED(amf_ue)) {\n            ngapbuf = ngap_build_pdu_session_resource_release_command(\n                    sess, NULL, n2buf);\n            ogs_assert(ngapbuf);\n\n            if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK)\n                ogs_error(\"nas_5gs_send_to_gnb() failed\");\n\n        } else {\n            ogs_fatal(\"[%s] Invalid AMF-UE state\", amf_ue->supi);\n            ogs_assert_if_reached();\n        }\n        break;\n\n    default:\n        ogs_error(\"Not implemented ngap_ie_type[%d]\",\n                n2InfoContent->ngap_ie_type);\n        ogs_assert_if_reached();\n    }\n\n    response = ogs_sbi_build_response(&sendmsg, status);\n    ogs_assert(response);\n    ogs_assert(true == ogs_sbi_server_send_response(stream, response));\n\n    if (sendmsg.http.location)\n        ogs_free(sendmsg.http.location);\n\n    return OGS_OK;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 56,
    "critical_vars": [
      "ngapIeType"
    ],
    "function": "amf_namf_comm_handle_n1_n2_message_transfer",
    "filename": "open5gs/CVE-2021-44108/CVE-2021-44108_CWE-476_d919b2744cd05abae043490f0a3dd1946c1ccb8c_namf-handler.c.diff",
    "function_code": "int amf_namf_comm_handle_n1_n2_message_transfer(\n        ogs_sbi_stream_t *stream, ogs_sbi_message_t *recvmsg)\n{\n    int status;\n\n    amf_ue_t *amf_ue = NULL;\n    amf_sess_t *sess = NULL;\n\n    ogs_pkbuf_t *n1buf = NULL;\n    ogs_pkbuf_t *n2buf = NULL;\n\n    ogs_pkbuf_t *gmmbuf = NULL;\n    ogs_pkbuf_t *ngapbuf = NULL;\n\n    char *supi = NULL;\n    uint8_t pdu_session_id = OGS_NAS_PDU_SESSION_IDENTITY_UNASSIGNED;\n\n    ogs_sbi_message_t sendmsg;\n    ogs_sbi_response_t *response = NULL;\n\n    OpenAPI_n1_n2_message_transfer_req_data_t *N1N2MessageTransferReqData;\n    OpenAPI_n1_n2_message_transfer_rsp_data_t N1N2MessageTransferRspData;\n    OpenAPI_n1_message_container_t *n1MessageContainer = NULL;\n    OpenAPI_ref_to_binary_data_t *n1MessageContent = NULL;\n    OpenAPI_n2_info_container_t *n2InfoContainer = NULL;\n    OpenAPI_n2_sm_information_t *smInfo = NULL;\n    OpenAPI_n2_info_content_t *n2InfoContent = NULL;\n    OpenAPI_ref_to_binary_data_t *ngapData = NULL;\n\n    OpenAPI_ngap_ie_type_e ngapIeType = OpenAPI_ngap_ie_type_NULL;\n\n    ogs_assert(stream);\n    ogs_assert(recvmsg);\n\n    N1N2MessageTransferReqData = recvmsg->N1N2MessageTransferReqData;\n    if (!N1N2MessageTransferReqData) {\n        ogs_error(\"No N1N2MessageTransferReqData\");\n        return OGS_ERROR;\n    }\n\n    if (N1N2MessageTransferReqData->is_pdu_session_id == false) {\n        ogs_error(\"No PDU Session Identity\");\n        return OGS_ERROR;\n    }\n    pdu_session_id = N1N2MessageTransferReqData->pdu_session_id;\n\n    supi = recvmsg->h.resource.component[1];\n    if (!supi) {\n        ogs_error(\"No SUPI\");\n        return OGS_ERROR;\n    }\n\n    amf_ue = amf_ue_find_by_supi(supi);\n    if (!amf_ue) {\n        ogs_error(\"No UE context [%s]\", supi);\n        return OGS_ERROR;\n    }\n\n    sess = amf_sess_find_by_psi(amf_ue, pdu_session_id);\n    if (!sess) {\n        ogs_error(\"[%s] No PDU Session Context [%d]\",\n                amf_ue->supi, pdu_session_id);\n        return OGS_ERROR;\n    }\n\n    n1MessageContainer = N1N2MessageTransferReqData->n1_message_container;\n    if (n1MessageContainer) {\n        n1MessageContent = n1MessageContainer->n1_message_content;\n        if (!n1MessageContent || !n1MessageContent->content_id) {\n            ogs_error(\"No n1MessageContent\");\n            return OGS_ERROR;\n        }\n\n        n1buf = ogs_sbi_find_part_by_content_id(\n                recvmsg, n1MessageContent->content_id);\n        if (!n1buf) {\n            ogs_error(\"[%s] No N1 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        /*\n         * NOTE : The pkbuf created in the SBI message will be removed\n         *        from ogs_sbi_message_free(), so it must be copied.\n         */\n        n1buf = ogs_pkbuf_copy(n1buf);\n        ogs_assert(n1buf);\n    }\n\n    n2InfoContainer = N1N2MessageTransferReqData->n2_info_container;\n    if (n2InfoContainer) {\n        smInfo = n2InfoContainer->sm_info;\n        if (!smInfo) {\n            ogs_error(\"No smInfo\");\n            return OGS_ERROR;\n        }\n\n        n2InfoContent = smInfo->n2_info_content;\n        if (!n2InfoContent) {\n            ogs_error(\"No n2InfoContent\");\n            return OGS_ERROR;\n        }\n\n        ngapIeType = n2InfoContent->ngap_ie_type;\n\n        ngapData = n2InfoContent->ngap_data;\n        if (!ngapData || !ngapData->content_id) {\n            ogs_error(\"No ngapData\");\n            return OGS_ERROR;\n        }\n        n2buf = ogs_sbi_find_part_by_content_id(\n                recvmsg, ngapData->content_id);\n        if (!n2buf) {\n            ogs_error(\"[%s] No N2 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        /*\n         * NOTE : The pkbuf created in the SBI message will be removed\n         *        from ogs_sbi_message_free(), so it must be copied.\n         */\n        n2buf = ogs_pkbuf_copy(n2buf);\n        ogs_assert(n2buf);\n    }\n\n    memset(&sendmsg, 0, sizeof(sendmsg));\n\n    status = OGS_SBI_HTTP_STATUS_OK;\n\n    memset(&N1N2MessageTransferRspData, 0, sizeof(N1N2MessageTransferRspData));\n    N1N2MessageTransferRspData.cause =\n        OpenAPI_n1_n2_message_transfer_cause_N1_N2_TRANSFER_INITIATED;\n\n    sendmsg.N1N2MessageTransferRspData = &N1N2MessageTransferRspData;\n\n    switch (ngapIeType) {\n    case OpenAPI_ngap_ie_type_PDU_RES_SETUP_REQ:\n        if (!n2buf) {\n            ogs_error(\"[%s] No N2 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        if (n1buf) {\n            gmmbuf = gmm_build_dl_nas_transport(sess,\n                    OGS_NAS_PAYLOAD_CONTAINER_N1_SM_INFORMATION, n1buf, 0, 0);\n            ogs_assert(gmmbuf);\n        }\n\n        if (gmmbuf) {\n            ran_ue_t *ran_ue = NULL;\n\n            /***********************************\n             * 4.3.2 PDU Session Establishment *\n             ***********************************/\n\n            ran_ue = ran_ue_cycle(amf_ue->ran_ue);\n            ogs_assert(ran_ue);\n\n            if (sess->pdu_session_establishment_accept) {\n                ogs_pkbuf_free(sess->pdu_session_establishment_accept);\n                sess->pdu_session_establishment_accept = NULL;\n            }\n\n            if (ran_ue->initial_context_setup_request_sent == true) {\n                ngapbuf = ngap_sess_build_pdu_session_resource_setup_request(\n                        sess, gmmbuf, n2buf);\n                ogs_assert(ngapbuf);\n            } else {\n                ngapbuf = ngap_sess_build_initial_context_setup_request(\n                        sess, gmmbuf, n2buf);\n                ogs_assert(ngapbuf);\n\n                ran_ue->initial_context_setup_request_sent = true;\n            }\n\n            if (SESSION_CONTEXT_IN_SMF(sess)) {\n                /*\n                 * [1-CLIENT] /nsmf-pdusession/v1/sm-contexts\n                 * [2-SERVER] /namf-comm/v1/ue-contexts/{supi}/n1-n2-messages\n                 *\n                 * If [2-SERVER] arrives after [1-CLIENT],\n                 * sm-context-ref is created in [1-CLIENT].\n                 * So, the PDU session establishment accpet can be transmitted.\n                 */\n                if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK)\n                    ogs_error(\"nas_5gs_send_to_gnb() failed\");\n            } else {\n                sess->pdu_session_establishment_accept = ngapbuf;\n            }\n\n        } else {\n            /*********************************************\n             * 4.2.3.3 Network Triggered Service Request *\n             *********************************************/\n\n            if (CM_IDLE(amf_ue)) {\n                ogs_sbi_server_t *server = NULL;\n                ogs_sbi_header_t header;\n                ogs_sbi_client_t *client = NULL;\n                ogs_sockaddr_t *addr = NULL;\n\n                if (!N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri) {\n                    ogs_error(\"[%s:%d] No n1-n2-failure-notification-uri\",\n                            amf_ue->supi, sess->psi);\n                    return OGS_ERROR;\n                }\n\n                addr = ogs_sbi_getaddr_from_uri(\n                        N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri);\n                if (!addr) {\n                    ogs_error(\"[%s:%d] Invalid URI [%s]\",\n                            amf_ue->supi, sess->psi,\n                            N1N2MessageTransferReqData->\n                                n1n2_failure_txf_notif_uri);\n                    return OGS_ERROR;;\n                }\n\n                client = ogs_sbi_client_find(addr);\n                if (!client) {\n                    client = ogs_sbi_client_add(addr);\n                    ogs_assert(client);\n                }\n                OGS_SETUP_SBI_CLIENT(&sess->paging, client);\n\n                ogs_freeaddrinfo(addr);\n\n                status = OGS_SBI_HTTP_STATUS_ACCEPTED;\n                N1N2MessageTransferRspData.cause =\n                    OpenAPI_n1_n2_message_transfer_cause_ATTEMPTING_TO_REACH_UE;\n\n                /* Location */\n                server = ogs_sbi_server_from_stream(stream);\n                ogs_assert(server);\n\n                memset(&header, 0, sizeof(header));\n                header.service.name = (char *)OGS_SBI_SERVICE_NAME_NAMF_COMM;\n                header.api.version = (char *)OGS_SBI_API_V1;\n                header.resource.component[0] =\n                    (char *)OGS_SBI_RESOURCE_NAME_UE_CONTEXTS;\n                header.resource.component[1] = amf_ue->supi;\n                header.resource.component[2] =\n                    (char *)OGS_SBI_RESOURCE_NAME_N1_N2_MESSAGES;\n                header.resource.component[3] = sess->sm_context_ref;\n\n                sendmsg.http.location = ogs_sbi_server_uri(server, &header);\n\n                /* Store Paging Info */\n                AMF_SESS_STORE_PAGING_INFO(\n                        sess, sendmsg.http.location,\n                        N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri);\n\n                /* Store N2 Transfer message */\n                AMF_SESS_STORE_N2_TRANSFER(\n                        sess, pdu_session_resource_setup_request, n2buf);\n\n                ogs_assert(OGS_OK == ngap_send_paging(amf_ue));\n\n            } else if (CM_CONNECTED(amf_ue)) {\n                ogs_assert(OGS_OK ==\n                    ngap_send_pdu_resource_setup_request(sess, n2buf));\n\n            } else {\n\n                ogs_fatal(\"[%s] Invalid AMF-UE state\", amf_ue->supi);\n                ogs_assert_if_reached();\n\n            }\n\n        }\n        break;\n\n    case OpenAPI_ngap_ie_type_PDU_RES_MOD_REQ:\n        if (!n1buf) {\n            ogs_error(\"[%s] No N1 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n        if (!n2buf) {\n            ogs_error(\"[%s] No N2 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        if (CM_IDLE(amf_ue)) {\n            ogs_sbi_server_t *server = NULL;\n            ogs_sbi_header_t header;\n\n            status = OGS_SBI_HTTP_STATUS_ACCEPTED;\n            N1N2MessageTransferRspData.cause =\n                OpenAPI_n1_n2_message_transfer_cause_ATTEMPTING_TO_REACH_UE;\n\n            /* Location */\n            server = ogs_sbi_server_from_stream(stream);\n            ogs_assert(server);\n\n            memset(&header, 0, sizeof(header));\n            header.service.name = (char *)OGS_SBI_SERVICE_NAME_NAMF_COMM;\n            header.api.version = (char *)OGS_SBI_API_V1;\n            header.resource.component[0] =\n                (char *)OGS_SBI_RESOURCE_NAME_UE_CONTEXTS;\n            header.resource.component[1] = amf_ue->supi;\n            header.resource.component[2] =\n                (char *)OGS_SBI_RESOURCE_NAME_N1_N2_MESSAGES;\n            header.resource.component[3] = sess->sm_context_ref;\n\n            sendmsg.http.location = ogs_sbi_server_uri(server, &header);\n\n            /* Store Paging Info */\n            AMF_SESS_STORE_PAGING_INFO(\n                    sess, sendmsg.http.location, NULL);\n\n            /* Store 5GSM Message */\n            AMF_SESS_STORE_5GSM_MESSAGE(sess,\n                    OGS_NAS_5GS_PDU_SESSION_MODIFICATION_COMMAND,\n                    n1buf, n2buf);\n\n            ogs_assert(OGS_OK == ngap_send_paging(amf_ue));\n\n        } else if (CM_CONNECTED(amf_ue)) {\n            gmmbuf = gmm_build_dl_nas_transport(sess,\n                    OGS_NAS_PAYLOAD_CONTAINER_N1_SM_INFORMATION, n1buf, 0, 0);\n            ogs_assert(gmmbuf);\n\n            ngapbuf = ngap_build_pdu_session_resource_modify_request(\n                    sess, gmmbuf, n2buf);\n            ogs_assert(ngapbuf);\n\n            if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK)\n                ogs_error(\"nas_5gs_send_to_gnb() failed\");\n\n        } else {\n            ogs_fatal(\"[%s] Invalid AMF-UE state\", amf_ue->supi);\n            ogs_assert_if_reached();\n        }\n\n        break;\n\n    case OpenAPI_ngap_ie_type_PDU_RES_REL_CMD:\n        if (!n2buf) {\n            ogs_error(\"[%s] No N2 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        if (n1buf)\n            ogs_pkbuf_free(n1buf);\n\n        if (CM_IDLE(amf_ue)) {\n            if (n2buf)\n                ogs_pkbuf_free(n2buf);\n\n            if (N1N2MessageTransferReqData->is_skip_ind == true &&\n                N1N2MessageTransferReqData->skip_ind == true) {\n                N1N2MessageTransferRspData.cause =\n                    OpenAPI_n1_n2_message_transfer_cause_N1_MSG_NOT_TRANSFERRED;\n            } else {\n                ogs_fatal(\"[%s] No skipInd\", amf_ue->supi);\n                ogs_assert_if_reached();\n            }\n\n        } else if (CM_CONNECTED(amf_ue)) {\n            ngapbuf = ngap_build_pdu_session_resource_release_command(\n                    sess, NULL, n2buf);\n            ogs_assert(ngapbuf);\n\n            if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK)\n                ogs_error(\"nas_5gs_send_to_gnb() failed\");\n\n        } else {\n            ogs_fatal(\"[%s] Invalid AMF-UE state\", amf_ue->supi);\n            ogs_assert_if_reached();\n        }\n        break;\n\n    default:\n        ogs_error(\"Not implemented ngapIeType[%d]\", ngapIeType);\n        ogs_assert_if_reached();\n    }\n\n    response = ogs_sbi_build_response(&sendmsg, status);\n    ogs_assert(response);\n    ogs_assert(true == ogs_sbi_server_send_response(stream, response));\n\n    if (sendmsg.http.location)\n        ogs_free(sendmsg.http.location);\n\n    return OGS_OK;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 253,
    "critical_vars": [
      "defaultMemory"
    ],
    "function": "run",
    "filename": "WAVM/CVE-2018-17293/CVE-2018-17293_CWE-476_31d670b6489e6d708c3b04b911cdf14ac43d846d_wavm.cpp.diff",
    "function_code": "static int run(const CommandLineOptions& options)\n{\n\tIR::Module irModule;\n\n\t// Load the module.\n\tif(!loadModule(options.filename, irModule)) { return EXIT_FAILURE; }\n\tif(options.onlyCheck) { return EXIT_SUCCESS; }\n\n\t// Compile the module.\n\tRuntime::Module* module = nullptr;\n\tif(!options.precompiled) { module = Runtime::compileModule(irModule); }\n\telse\n\t{\n\t\tconst UserSection* precompiledObjectSection = nullptr;\n\t\tfor(const UserSection& userSection : irModule.userSections)\n\t\t{\n\t\t\tif(userSection.name == \"wavm.precompiled_object\")\n\t\t\t{\n\t\t\t\tprecompiledObjectSection = &userSection;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(!precompiledObjectSection)\n\t\t{\n\t\t\tLog::printf(Log::error, \"Input file did not contain 'wavm.precompiled_object' section\");\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmodule = Runtime::loadPrecompiledModule(irModule, precompiledObjectSection->data);\n\t\t}\n\t}\n\n\t// Link the module with the intrinsic modules.\n\tCompartment* compartment = Runtime::createCompartment();\n\tContext* context = Runtime::createContext(compartment);\n\tRootResolver rootResolver(compartment);\n\n\tEmscripten::Instance* emscriptenInstance = nullptr;\n\tif(options.enableEmscripten)\n\t{\n\t\temscriptenInstance = Emscripten::instantiate(compartment, irModule);\n\t\tif(emscriptenInstance)\n\t\t{\n\t\t\trootResolver.moduleNameToInstanceMap.set(\"env\", emscriptenInstance->env);\n\t\t\trootResolver.moduleNameToInstanceMap.set(\"asm2wasm\", emscriptenInstance->asm2wasm);\n\t\t\trootResolver.moduleNameToInstanceMap.set(\"global\", emscriptenInstance->global);\n\t\t}\n\t}\n\n\tif(options.enableThreadTest)\n\t{\n\t\tModuleInstance* threadTestInstance = ThreadTest::instantiate(compartment);\n\t\trootResolver.moduleNameToInstanceMap.set(\"threadTest\", threadTestInstance);\n\t}\n\n\tLinkResult linkResult = linkModule(irModule, rootResolver);\n\tif(!linkResult.success)\n\t{\n\t\tLog::printf(Log::error, \"Failed to link module:\\n\");\n\t\tfor(auto& missingImport : linkResult.missingImports)\n\t\t{\n\t\t\tLog::printf(Log::error,\n\t\t\t\t\t\t\"Missing import: module=\\\"%s\\\" export=\\\"%s\\\" type=\\\"%s\\\"\\n\",\n\t\t\t\t\t\tmissingImport.moduleName.c_str(),\n\t\t\t\t\t\tmissingImport.exportName.c_str(),\n\t\t\t\t\t\tasString(missingImport.type).c_str());\n\t\t}\n\t\treturn EXIT_FAILURE;\n\t}\n\n\t// Instantiate the module.\n\tModuleInstance* moduleInstance = instantiateModule(\n\t\tcompartment, module, std::move(linkResult.resolvedImports), options.filename);\n\tif(!moduleInstance) { return EXIT_FAILURE; }\n\n\t// Call the module start function, if it has one.\n\tFunctionInstance* startFunction = getStartFunction(moduleInstance);\n\tif(startFunction) { invokeFunctionChecked(context, startFunction, {}); }\n\n\tif(options.enableEmscripten)\n\t{\n\t\t// Call the Emscripten global initalizers.\n\t\tEmscripten::initializeGlobals(context, irModule, moduleInstance);\n\t}\n\n\t// Look up the function export to call.\n\tFunctionInstance* functionInstance;\n\tif(!options.functionName)\n\t{\n\t\tfunctionInstance = asFunctionNullable(getInstanceExport(moduleInstance, \"main\"));\n\t\tif(!functionInstance)\n\t\t{ functionInstance = asFunctionNullable(getInstanceExport(moduleInstance, \"_main\")); }\n\t\tif(!functionInstance)\n\t\t{\n\t\t\tLog::printf(Log::error, \"Module does not export main function\\n\");\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tfunctionInstance\n\t\t\t= asFunctionNullable(getInstanceExport(moduleInstance, options.functionName));\n\t\tif(!functionInstance)\n\t\t{\n\t\t\tLog::printf(Log::error, \"Module does not export '%s'\\n\", options.functionName);\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n\tFunctionType functionType = getFunctionType(functionInstance);\n\n\t// Set up the arguments for the invoke.\n\tstd::vector<Value> invokeArgs;\n\tif(!options.functionName)\n\t{\n\t\tif(functionType.params().size() == 2)\n\t\t{\n\t\t\tMemoryInstance* defaultMemory = Runtime::getDefaultMemory(moduleInstance);\n\t\t\tif(!defaultMemory)\n\t\t\t{\n\t\t\t\tLog::printf(\n\t\t\t\t\tLog::error,\n\t\t\t\t\t\"Module does not declare a default memory object to put arguments in.\\n\");\n\t\t\t\treturn EXIT_FAILURE;\n\t\t\t}\n\n\t\t\tstd::vector<const char*> argStrings;\n\t\t\targStrings.push_back(options.filename);\n\t\t\tchar** args = options.args;\n\t\t\twhile(*args) { argStrings.push_back(*args++); };\n\n\t\t\tEmscripten::injectCommandArgs(emscriptenInstance, argStrings, invokeArgs);\n\t\t}\n\t\telse if(functionType.params().size() > 0)\n\t\t{\n\t\t\tLog::printf(Log::error,\n\t\t\t\t\t\t\"WebAssembly function requires %\" PRIu64\n\t\t\t\t\t\t\" argument(s), but only 0 or 2 can be passed!\",\n\t\t\t\t\t\tfunctionType.params().size());\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor(U32 i = 0; options.args[i]; ++i)\n\t\t{\n\t\t\tValue value;\n\t\t\tswitch(functionType.params()[i])\n\t\t\t{\n\t\t\tcase ValueType::i32: value = (U32)atoi(options.args[i]); break;\n\t\t\tcase ValueType::i64: value = (U64)atol(options.args[i]); break;\n\t\t\tcase ValueType::f32: value = (F32)atof(options.args[i]); break;\n\t\t\tcase ValueType::f64: value = atof(options.args[i]); break;\n\t\t\tcase ValueType::v128:\n\t\t\tcase ValueType::anyref:\n\t\t\tcase ValueType::anyfunc:\n\t\t\t\tErrors::fatalf(\"Cannot parse command-line argument for %s function parameter\",\n\t\t\t\t\t\t\t   asString(functionType.params()[i]));\n\t\t\tdefault: Errors::unreachable();\n\t\t\t}\n\t\t\tinvokeArgs.push_back(value);\n\t\t}\n\t}\n\n\t// Invoke the function.\n\tTiming::Timer executionTimer;\n\tIR::ValueTuple functionResults = invokeFunctionChecked(context, functionInstance, invokeArgs);\n\tTiming::logTimer(\"Invoked function\", executionTimer);\n\n\tif(options.functionName)\n\t{\n\t\tLog::printf(Log::debug,\n\t\t\t\t\t\"%s returned: %s\\n\",\n\t\t\t\t\toptions.functionName,\n\t\t\t\t\tasString(functionResults).c_str());\n\t\treturn EXIT_SUCCESS;\n\t}\n\telse if(functionResults.size() == 1 && functionResults[0].type == ValueType::i32)\n\t{\n\t\treturn functionResults[0].i32;\n\t}\n\telse\n\t{\n\t\treturn EXIT_SUCCESS;\n\t}\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 253,
    "critical_vars": [
      "emscriptenInstance"
    ],
    "function": "run",
    "filename": "WAVM/CVE-2018-17293/CVE-2018-17293_CWE-476_31d670b6489e6d708c3b04b911cdf14ac43d846d_wavm.cpp.diff",
    "function_code": "static int run(const CommandLineOptions& options)\n{\n\tIR::Module irModule;\n\n\t// Load the module.\n\tif(!loadModule(options.filename, irModule)) { return EXIT_FAILURE; }\n\tif(options.onlyCheck) { return EXIT_SUCCESS; }\n\n\t// Compile the module.\n\tRuntime::Module* module = nullptr;\n\tif(!options.precompiled) { module = Runtime::compileModule(irModule); }\n\telse\n\t{\n\t\tconst UserSection* precompiledObjectSection = nullptr;\n\t\tfor(const UserSection& userSection : irModule.userSections)\n\t\t{\n\t\t\tif(userSection.name == \"wavm.precompiled_object\")\n\t\t\t{\n\t\t\t\tprecompiledObjectSection = &userSection;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(!precompiledObjectSection)\n\t\t{\n\t\t\tLog::printf(Log::error, \"Input file did not contain 'wavm.precompiled_object' section\");\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmodule = Runtime::loadPrecompiledModule(irModule, precompiledObjectSection->data);\n\t\t}\n\t}\n\n\t// Link the module with the intrinsic modules.\n\tCompartment* compartment = Runtime::createCompartment();\n\tContext* context = Runtime::createContext(compartment);\n\tRootResolver rootResolver(compartment);\n\n\tEmscripten::Instance* emscriptenInstance = nullptr;\n\tif(options.enableEmscripten)\n\t{\n\t\temscriptenInstance = Emscripten::instantiate(compartment, irModule);\n\t\tif(emscriptenInstance)\n\t\t{\n\t\t\trootResolver.moduleNameToInstanceMap.set(\"env\", emscriptenInstance->env);\n\t\t\trootResolver.moduleNameToInstanceMap.set(\"asm2wasm\", emscriptenInstance->asm2wasm);\n\t\t\trootResolver.moduleNameToInstanceMap.set(\"global\", emscriptenInstance->global);\n\t\t}\n\t}\n\n\tif(options.enableThreadTest)\n\t{\n\t\tModuleInstance* threadTestInstance = ThreadTest::instantiate(compartment);\n\t\trootResolver.moduleNameToInstanceMap.set(\"threadTest\", threadTestInstance);\n\t}\n\n\tLinkResult linkResult = linkModule(irModule, rootResolver);\n\tif(!linkResult.success)\n\t{\n\t\tLog::printf(Log::error, \"Failed to link module:\\n\");\n\t\tfor(auto& missingImport : linkResult.missingImports)\n\t\t{\n\t\t\tLog::printf(Log::error,\n\t\t\t\t\t\t\"Missing import: module=\\\"%s\\\" export=\\\"%s\\\" type=\\\"%s\\\"\\n\",\n\t\t\t\t\t\tmissingImport.moduleName.c_str(),\n\t\t\t\t\t\tmissingImport.exportName.c_str(),\n\t\t\t\t\t\tasString(missingImport.type).c_str());\n\t\t}\n\t\treturn EXIT_FAILURE;\n\t}\n\n\t// Instantiate the module.\n\tModuleInstance* moduleInstance = instantiateModule(\n\t\tcompartment, module, std::move(linkResult.resolvedImports), options.filename);\n\tif(!moduleInstance) { return EXIT_FAILURE; }\n\n\t// Call the module start function, if it has one.\n\tFunctionInstance* startFunction = getStartFunction(moduleInstance);\n\tif(startFunction) { invokeFunctionChecked(context, startFunction, {}); }\n\n\tif(options.enableEmscripten)\n\t{\n\t\t// Call the Emscripten global initalizers.\n\t\tEmscripten::initializeGlobals(context, irModule, moduleInstance);\n\t}\n\n\t// Look up the function export to call.\n\tFunctionInstance* functionInstance;\n\tif(!options.functionName)\n\t{\n\t\tfunctionInstance = asFunctionNullable(getInstanceExport(moduleInstance, \"main\"));\n\t\tif(!functionInstance)\n\t\t{ functionInstance = asFunctionNullable(getInstanceExport(moduleInstance, \"_main\")); }\n\t\tif(!functionInstance)\n\t\t{\n\t\t\tLog::printf(Log::error, \"Module does not export main function\\n\");\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tfunctionInstance\n\t\t\t= asFunctionNullable(getInstanceExport(moduleInstance, options.functionName));\n\t\tif(!functionInstance)\n\t\t{\n\t\t\tLog::printf(Log::error, \"Module does not export '%s'\\n\", options.functionName);\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n\tFunctionType functionType = getFunctionType(functionInstance);\n\n\t// Set up the arguments for the invoke.\n\tstd::vector<Value> invokeArgs;\n\tif(!options.functionName)\n\t{\n\t\tif(functionType.params().size() == 2)\n\t\t{\n\t\t\tif(!emscriptenInstance)\n\t\t\t{\n\t\t\t\tLog::printf(\n\t\t\t\t\tLog::error,\n\t\t\t\t\t\"Module does not declare a default memory object to put arguments in.\\n\");\n\t\t\t\treturn EXIT_FAILURE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstd::vector<const char*> argStrings;\n\t\t\t\targStrings.push_back(options.filename);\n\t\t\t\tchar** args = options.args;\n\t\t\t\twhile(*args) { argStrings.push_back(*args++); };\n\n\t\t\t\twavmAssert(emscriptenInstance);\n\t\t\t\tEmscripten::injectCommandArgs(emscriptenInstance, argStrings, invokeArgs);\n\t\t\t}\n\t\t}\n\t\telse if(functionType.params().size() > 0)\n\t\t{\n\t\t\tLog::printf(Log::error,\n\t\t\t\t\t\t\"WebAssembly function requires %\" PRIu64\n\t\t\t\t\t\t\" argument(s), but only 0 or 2 can be passed!\",\n\t\t\t\t\t\tfunctionType.params().size());\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor(U32 i = 0; options.args[i]; ++i)\n\t\t{\n\t\t\tValue value;\n\t\t\tswitch(functionType.params()[i])\n\t\t\t{\n\t\t\tcase ValueType::i32: value = (U32)atoi(options.args[i]); break;\n\t\t\tcase ValueType::i64: value = (U64)atol(options.args[i]); break;\n\t\t\tcase ValueType::f32: value = (F32)atof(options.args[i]); break;\n\t\t\tcase ValueType::f64: value = atof(options.args[i]); break;\n\t\t\tcase ValueType::v128:\n\t\t\tcase ValueType::anyref:\n\t\t\tcase ValueType::anyfunc:\n\t\t\t\tErrors::fatalf(\"Cannot parse command-line argument for %s function parameter\",\n\t\t\t\t\t\t\t   asString(functionType.params()[i]));\n\t\t\tdefault: Errors::unreachable();\n\t\t\t}\n\t\t\tinvokeArgs.push_back(value);\n\t\t}\n\t}\n\n\t// Invoke the function.\n\tTiming::Timer executionTimer;\n\tIR::ValueTuple functionResults = invokeFunctionChecked(context, functionInstance, invokeArgs);\n\tTiming::logTimer(\"Invoked function\", executionTimer);\n\n\tif(options.functionName)\n\t{\n\t\tLog::printf(Log::debug,\n\t\t\t\t\t\"%s returned: %s\\n\",\n\t\t\t\t\toptions.functionName,\n\t\t\t\t\tasString(functionResults).c_str());\n\t\treturn EXIT_SUCCESS;\n\t}\n\telse if(functionResults.size() == 1 && functionResults[0].type == ValueType::i32)\n\t{\n\t\treturn functionResults[0].i32;\n\t}\n\telse\n\t{\n\t\treturn EXIT_SUCCESS;\n\t}\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 3238,
    "critical_vars": [
      "p",
      "str"
    ],
    "function": "forward_search_range",
    "filename": "oniguruma/CVE-2017-9229/CVE-2017-9229_CWE-476_b690371bbf97794b4a1d3f295d4fb9a8b05d402d_regexec.c.diff",
    "function_code": "forward_search_range(regex_t* reg, const UChar* str, const UChar* end, UChar* s,\n\t\t     UChar* range, UChar** low, UChar** high, UChar** low_prev)\n{\n  UChar *p, *pprev = (UChar* )NULL;\n\n#ifdef ONIG_DEBUG_SEARCH\n  fprintf(stderr, \"forward_search_range: str: %d, end: %d, s: %d, range: %d\\n\",\n\t  (int )str, (int )end, (int )s, (int )range);\n#endif\n\n  p = s;\n  if (reg->dmin > 0) {\n    if (ONIGENC_IS_SINGLEBYTE(reg->enc)) {\n      p += reg->dmin;\n    }\n    else {\n      UChar *q = p + reg->dmin;\n\n      if (q >= end) return 0; /* fail */\n      while (p < q) p += enclen(reg->enc, p);\n    }\n  }\n\n retry:\n  switch (reg->optimize) {\n  case ONIG_OPTIMIZE_EXACT:\n    p = slow_search(reg->enc, reg->exact, reg->exact_end, p, end, range);\n    break;\n  case ONIG_OPTIMIZE_EXACT_IC:\n    p = slow_search_ic(reg->enc, reg->case_fold_flag,\n                       reg->exact, reg->exact_end, p, end, range);\n    break;\n\n  case ONIG_OPTIMIZE_EXACT_BM:\n    p = bm_search(reg, reg->exact, reg->exact_end, p, end, range);\n    break;\n\n  case ONIG_OPTIMIZE_EXACT_BM_NOT_REV:\n    p = bm_search_notrev(reg, reg->exact, reg->exact_end, p, end, range);\n    break;\n\n  case ONIG_OPTIMIZE_MAP:\n    p = map_search(reg->enc, reg->map, p, range);\n    break;\n  }\n\n  if (p && p < range) {\n    if (p - reg->dmin < s) {\n    retry_gate:\n      pprev = p;\n      p += enclen(reg->enc, p);\n      goto retry;\n    }\n\n    if (reg->sub_anchor) {\n      UChar* prev;\n\n      switch (reg->sub_anchor) {\n      case ANCHOR_BEGIN_LINE:\n        if (!ON_STR_BEGIN(p)) {\n          prev = onigenc_get_prev_char_head(reg->enc,\n                                            (pprev ? pprev : str), p);\n          if (!ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end))\n            goto retry_gate;\n        }\n        break;\n\n      case ANCHOR_END_LINE:\n        if (ON_STR_END(p)) {\n#ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE\n          prev = (UChar* )onigenc_get_prev_char_head(reg->enc,\n                                                     (pprev ? pprev : str), p);\n          if (prev && ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end))\n            goto retry_gate;\n#endif\n        }\n        else if (! ONIGENC_IS_MBC_NEWLINE(reg->enc, p, end)\n#ifdef USE_CRNL_AS_LINE_TERMINATOR\n                 && ! ONIGENC_IS_MBC_CRNL(reg->enc, p, end)\n#endif\n                 )\n          goto retry_gate;\n        break;\n      }\n    }\n\n    if (reg->dmax == 0) {\n      *low = p;\n      if (low_prev) {\n        if (*low > s)\n          *low_prev = onigenc_get_prev_char_head(reg->enc, s, p);\n        else\n          *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                 (pprev ? pprev : str), p);\n      }\n    }\n    else {\n      if (reg->dmax != ONIG_INFINITE_DISTANCE) {\n        if (p - str < reg->dmax) {\n          *low = (UChar* )str;\n          if (low_prev)\n            *low_prev = onigenc_get_prev_char_head(reg->enc, str, *low);\n        }\n        else {\n          *low = p - reg->dmax;\n          if (*low > s) {\n            *low = onigenc_get_right_adjust_char_head_with_prev(reg->enc, s,\n                                                 *low, (const UChar** )low_prev);\n            if (low_prev && IS_NULL(*low_prev))\n              *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                     (pprev ? pprev : s), *low);\n          }\n          else {\n            if (low_prev)\n              *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                     (pprev ? pprev : str), *low);\n          }\n        }\n      }\n    }\n    /* no needs to adjust *high, *high is used as range check only */\n    *high = p - reg->dmin;\n\n#ifdef ONIG_DEBUG_SEARCH\n    fprintf(stderr,\n    \"forward_search_range success: low: %d, high: %d, dmin: %d, dmax: %d\\n\",\n\t    (int )(*low - str), (int )(*high - str), reg->dmin, reg->dmax);\n#endif\n    return 1; /* success */\n  }\n\n  return 0; /* fail */\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 1311,
    "critical_vars": [
      "len"
    ],
    "function": "compile_length_bag_node",
    "filename": "oniguruma/CVE-2019-13225/CVE-2019-13225_CWE-476_c509265c5f6ae7264f7b8a8aae1cfa5fc59d108c_regcomp.c.diff",
    "function_code": "compile_length_bag_node(BagNode* node, regex_t* reg)\n{\n  int len;\n  int tlen;\n\n  if (node->type == BAG_OPTION)\n    return compile_length_option_node(node, reg);\n\n  if (NODE_BAG_BODY(node)) {\n    tlen = compile_length_tree(NODE_BAG_BODY(node), reg);\n    if (tlen < 0) return tlen;\n  }\n  else\n    tlen = 0;\n\n  switch (node->type) {\n  case BAG_MEMORY:\n#ifdef USE_CALL\n\n    if (node->m.regnum == 0 && NODE_IS_CALLED(node)) {\n      len = tlen + SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN;\n      return len;\n    }\n\n    if (NODE_IS_CALLED(node)) {\n      len = SIZE_OP_MEMORY_START_PUSH + tlen\n        + SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN;\n      if (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum))\n        len += (NODE_IS_RECURSION(node)\n                ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_PUSH);\n      else\n        len += (NODE_IS_RECURSION(node)\n                ? SIZE_OP_MEMORY_END_REC : SIZE_OP_MEMORY_END);\n    }\n    else if (NODE_IS_RECURSION(node)) {\n      len = SIZE_OP_MEMORY_START_PUSH;\n      len += tlen + (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum)\n                     ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_REC);\n    }\n    else\n#endif\n    {\n      if (MEM_STATUS_AT0(reg->bt_mem_start, node->m.regnum))\n        len = SIZE_OP_MEMORY_START_PUSH;\n      else\n        len = SIZE_OP_MEMORY_START;\n\n      len += tlen + (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum)\n                     ? SIZE_OP_MEMORY_END_PUSH : SIZE_OP_MEMORY_END);\n    }\n    break;\n\n  case BAG_STOP_BACKTRACK:\n    if (NODE_IS_STOP_BT_SIMPLE_REPEAT(node)) {\n      int v;\n      QuantNode* qn;\n\n      qn = QUANT_(NODE_BAG_BODY(node));\n      tlen = compile_length_tree(NODE_QUANT_BODY(qn), reg);\n      if (tlen < 0) return tlen;\n\n      v = onig_positive_int_multiply(qn->lower, tlen);\n      if (v < 0) return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;\n      len = v + SIZE_OP_PUSH + tlen + SIZE_OP_POP_OUT + SIZE_OP_JUMP;\n    }\n    else {\n      len = SIZE_OP_ATOMIC_START + tlen + SIZE_OP_ATOMIC_END;\n    }\n    break;\n\n  case BAG_IF_ELSE:\n    {\n      Node* cond = NODE_BAG_BODY(node);\n      Node* Then = node->te.Then;\n      Node* Else = node->te.Else;\n\n      len = compile_length_tree(cond, reg);\n      if (len < 0) return len;\n      len += SIZE_OP_PUSH;\n      len += SIZE_OP_ATOMIC_START + SIZE_OP_ATOMIC_END;\n\n      if (IS_NOT_NULL(Then)) {\n        tlen = compile_length_tree(Then, reg);\n        if (tlen < 0) return tlen;\n        len += tlen;\n      }\n\n      if (IS_NOT_NULL(Else)) {\n        len += SIZE_OP_JUMP;\n        tlen = compile_length_tree(Else, reg);\n        if (tlen < 0) return tlen;\n        len += tlen;\n      }\n    }\n    break;\n\n  case BAG_OPTION:\n    /* never come here, but set for escape warning */\n    len = 0;\n    break;\n  }\n\n  return len;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 1310,
    "critical_vars": [
      "len"
    ],
    "function": "compile_length_bag_node",
    "filename": "oniguruma/CVE-2019-13225/CVE-2019-13225_CWE-476_c509265c5f6ae7264f7b8a8aae1cfa5fc59d108c_regcomp.c.diff",
    "function_code": "compile_length_bag_node(BagNode* node, regex_t* reg)\n{\n  int len;\n  int tlen;\n\n  if (node->type == BAG_OPTION)\n    return compile_length_option_node(node, reg);\n\n  if (NODE_BAG_BODY(node)) {\n    tlen = compile_length_tree(NODE_BAG_BODY(node), reg);\n    if (tlen < 0) return tlen;\n  }\n  else\n    tlen = 0;\n\n  switch (node->type) {\n  case BAG_MEMORY:\n#ifdef USE_CALL\n\n    if (node->m.regnum == 0 && NODE_IS_CALLED(node)) {\n      len = tlen + SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN;\n      return len;\n    }\n\n    if (NODE_IS_CALLED(node)) {\n      len = SIZE_OP_MEMORY_START_PUSH + tlen\n        + SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN;\n      if (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum))\n        len += (NODE_IS_RECURSION(node)\n                ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_PUSH);\n      else\n        len += (NODE_IS_RECURSION(node)\n                ? SIZE_OP_MEMORY_END_REC : SIZE_OP_MEMORY_END);\n    }\n    else if (NODE_IS_RECURSION(node)) {\n      len = SIZE_OP_MEMORY_START_PUSH;\n      len += tlen + (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum)\n                     ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_REC);\n    }\n    else\n#endif\n    {\n      if (MEM_STATUS_AT0(reg->bt_mem_start, node->m.regnum))\n        len = SIZE_OP_MEMORY_START_PUSH;\n      else\n        len = SIZE_OP_MEMORY_START;\n\n      len += tlen + (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum)\n                     ? SIZE_OP_MEMORY_END_PUSH : SIZE_OP_MEMORY_END);\n    }\n    break;\n\n  case BAG_STOP_BACKTRACK:\n    if (NODE_IS_STOP_BT_SIMPLE_REPEAT(node)) {\n      int v;\n      QuantNode* qn;\n\n      qn = QUANT_(NODE_BAG_BODY(node));\n      tlen = compile_length_tree(NODE_QUANT_BODY(qn), reg);\n      if (tlen < 0) return tlen;\n\n      v = onig_positive_int_multiply(qn->lower, tlen);\n      if (v < 0) return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;\n      len = v + SIZE_OP_PUSH + tlen + SIZE_OP_POP_OUT + SIZE_OP_JUMP;\n    }\n    else {\n      len = SIZE_OP_ATOMIC_START + tlen + SIZE_OP_ATOMIC_END;\n    }\n    break;\n\n  case BAG_IF_ELSE:\n    {\n      Node* cond = NODE_BAG_BODY(node);\n      Node* Then = node->te.Then;\n      Node* Else = node->te.Else;\n\n      len = compile_length_tree(cond, reg);\n      if (len < 0) return len;\n      len += SIZE_OP_PUSH;\n      len += SIZE_OP_ATOMIC_START + SIZE_OP_ATOMIC_END;\n\n      if (IS_NOT_NULL(Then)) {\n        tlen = compile_length_tree(Then, reg);\n        if (tlen < 0) return tlen;\n        len += tlen;\n      }\n\n      len += SIZE_OP_JUMP + SIZE_OP_ATOMIC_END;\n\n      if (IS_NOT_NULL(Else)) {\n        tlen = compile_length_tree(Else, reg);\n        if (tlen < 0) return tlen;\n        len += tlen;\n      }\n    }\n    break;\n\n  case BAG_OPTION:\n    /* never come here, but set for escape warning */\n    len = 0;\n    break;\n  }\n\n  return len;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 1476,
    "critical_vars": [
      "Else"
    ],
    "function": "compile_bag_node",
    "filename": "oniguruma/CVE-2019-13225/CVE-2019-13225_CWE-476_c509265c5f6ae7264f7b8a8aae1cfa5fc59d108c_regcomp.c.diff",
    "function_code": "compile_bag_node(BagNode* node, regex_t* reg, ScanEnv* env)\n{\n  int r, len;\n\n  switch (node->type) {\n  case BAG_MEMORY:\n    r = compile_bag_memory_node(node, reg, env);\n    break;\n\n  case BAG_OPTION:\n    r = compile_option_node(node, reg, env);\n    break;\n\n  case BAG_STOP_BACKTRACK:\n    if (NODE_IS_STOP_BT_SIMPLE_REPEAT(node)) {\n      QuantNode* qn = QUANT_(NODE_BAG_BODY(node));\n      r = compile_tree_n_times(NODE_QUANT_BODY(qn), qn->lower, reg, env);\n      if (r != 0) return r;\n\n      len = compile_length_tree(NODE_QUANT_BODY(qn), reg);\n      if (len < 0) return len;\n\n      r = add_op(reg, OP_PUSH);\n      if (r != 0) return r;\n      COP(reg)->push.addr = SIZE_INC_OP + len + SIZE_OP_POP_OUT + SIZE_OP_JUMP;\n\n      r = compile_tree(NODE_QUANT_BODY(qn), reg, env);\n      if (r != 0) return r;\n      r = add_op(reg, OP_POP_OUT);\n      if (r != 0) return r;\n\n      r = add_op(reg, OP_JUMP);\n      if (r != 0) return r;\n      COP(reg)->jump.addr = -((int )SIZE_OP_PUSH + len + (int )SIZE_OP_POP_OUT);\n    }\n    else {\n      r = add_op(reg, OP_ATOMIC_START);\n      if (r != 0) return r;\n      r = compile_tree(NODE_BAG_BODY(node), reg, env);\n      if (r != 0) return r;\n      r = add_op(reg, OP_ATOMIC_END);\n    }\n    break;\n\n  case BAG_IF_ELSE:\n    {\n      int cond_len, then_len, jump_len;\n      Node* cond = NODE_BAG_BODY(node);\n      Node* Then = node->te.Then;\n      Node* Else = node->te.Else;\n\n      r = add_op(reg, OP_ATOMIC_START);\n      if (r != 0) return r;\n\n      cond_len = compile_length_tree(cond, reg);\n      if (cond_len < 0) return cond_len;\n      if (IS_NOT_NULL(Then)) {\n        then_len = compile_length_tree(Then, reg);\n        if (then_len < 0) return then_len;\n      }\n      else\n        then_len = 0;\n\n      jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END;\n      if (IS_NOT_NULL(Else)) jump_len += SIZE_OP_JUMP;\n\n      r = add_op(reg, OP_PUSH);\n      if (r != 0) return r;\n      COP(reg)->push.addr = SIZE_INC_OP + jump_len;\n\n      r = compile_tree(cond, reg, env);\n      if (r != 0) return r;\n      r = add_op(reg, OP_ATOMIC_END);\n      if (r != 0) return r;\n\n      if (IS_NOT_NULL(Then)) {\n        r = compile_tree(Then, reg, env);\n        if (r != 0) return r;\n      }\n\n      if (IS_NOT_NULL(Else)) {\n        int else_len = compile_length_tree(Else, reg);\n        r = add_op(reg, OP_JUMP);\n        if (r != 0) return r;\n        COP(reg)->jump.addr = else_len + SIZE_INC_OP;\n\n        r = compile_tree(Else, reg, env);\n      }\n    }\n    break;\n  }\n\n  return r;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 1459,
    "critical_vars": [
      "else_len"
    ],
    "function": "compile_bag_node",
    "filename": "oniguruma/CVE-2019-13225/CVE-2019-13225_CWE-476_c509265c5f6ae7264f7b8a8aae1cfa5fc59d108c_regcomp.c.diff",
    "function_code": "compile_bag_node(BagNode* node, regex_t* reg, ScanEnv* env)\n{\n  int r, len;\n\n  switch (node->type) {\n  case BAG_MEMORY:\n    r = compile_bag_memory_node(node, reg, env);\n    break;\n\n  case BAG_OPTION:\n    r = compile_option_node(node, reg, env);\n    break;\n\n  case BAG_STOP_BACKTRACK:\n    if (NODE_IS_STOP_BT_SIMPLE_REPEAT(node)) {\n      QuantNode* qn = QUANT_(NODE_BAG_BODY(node));\n      r = compile_tree_n_times(NODE_QUANT_BODY(qn), qn->lower, reg, env);\n      if (r != 0) return r;\n\n      len = compile_length_tree(NODE_QUANT_BODY(qn), reg);\n      if (len < 0) return len;\n\n      r = add_op(reg, OP_PUSH);\n      if (r != 0) return r;\n      COP(reg)->push.addr = SIZE_INC_OP + len + SIZE_OP_POP_OUT + SIZE_OP_JUMP;\n\n      r = compile_tree(NODE_QUANT_BODY(qn), reg, env);\n      if (r != 0) return r;\n      r = add_op(reg, OP_POP_OUT);\n      if (r != 0) return r;\n\n      r = add_op(reg, OP_JUMP);\n      if (r != 0) return r;\n      COP(reg)->jump.addr = -((int )SIZE_OP_PUSH + len + (int )SIZE_OP_POP_OUT);\n    }\n    else {\n      r = add_op(reg, OP_ATOMIC_START);\n      if (r != 0) return r;\n      r = compile_tree(NODE_BAG_BODY(node), reg, env);\n      if (r != 0) return r;\n      r = add_op(reg, OP_ATOMIC_END);\n    }\n    break;\n\n  case BAG_IF_ELSE:\n    {\n      int cond_len, then_len, else_len, jump_len;\n      Node* cond = NODE_BAG_BODY(node);\n      Node* Then = node->te.Then;\n      Node* Else = node->te.Else;\n\n      r = add_op(reg, OP_ATOMIC_START);\n      if (r != 0) return r;\n\n      cond_len = compile_length_tree(cond, reg);\n      if (cond_len < 0) return cond_len;\n      if (IS_NOT_NULL(Then)) {\n        then_len = compile_length_tree(Then, reg);\n        if (then_len < 0) return then_len;\n      }\n      else\n        then_len = 0;\n\n      jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END + SIZE_OP_JUMP;\n\n      r = add_op(reg, OP_PUSH);\n      if (r != 0) return r;\n      COP(reg)->push.addr = SIZE_INC_OP + jump_len;\n\n      r = compile_tree(cond, reg, env);\n      if (r != 0) return r;\n      r = add_op(reg, OP_ATOMIC_END);\n      if (r != 0) return r;\n\n      if (IS_NOT_NULL(Then)) {\n        r = compile_tree(Then, reg, env);\n        if (r != 0) return r;\n      }\n\n      if (IS_NOT_NULL(Else)) {\n        else_len = compile_length_tree(Else, reg);\n        if (else_len < 0) return else_len;\n      }\n      else\n        else_len = 0;\n\n      r = add_op(reg, OP_JUMP);\n      if (r != 0) return r;\n      COP(reg)->jump.addr = SIZE_OP_ATOMIC_END + else_len + SIZE_INC_OP;\n\n      r = add_op(reg, OP_ATOMIC_END);\n      if (r != 0) return r;\n\n      if (IS_NOT_NULL(Else)) {\n        r = compile_tree(Else, reg, env);\n      }\n    }\n    break;\n  }\n\n  return r;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 3801,
    "critical_vars": [
      "c->lookup_values"
    ],
    "function": "start_decoder",
    "filename": "stb/CVE-2019-13219/CVE-2019-13219_CWE-476_98fdfc6df88b1e34a736d5e126e6c8139c8de1a6_stb_vorbis.c.diff",
    "function_code": "static int start_decoder(vorb *f)\n{\n   uint8 header[6], x,y;\n   int len,i,j,k, max_submaps = 0;\n   int longest_floorlist=0;\n\n   // first page, first packet\n\n   if (!start_page(f))                              return FALSE;\n   // validate page flag\n   if (!(f->page_flag & PAGEFLAG_first_page))       return error(f, VORBIS_invalid_first_page);\n   if (f->page_flag & PAGEFLAG_last_page)           return error(f, VORBIS_invalid_first_page);\n   if (f->page_flag & PAGEFLAG_continued_packet)    return error(f, VORBIS_invalid_first_page);\n   // check for expected packet length\n   if (f->segment_count != 1)                       return error(f, VORBIS_invalid_first_page);\n   if (f->segments[0] != 30) {\n      // check for the Ogg skeleton fishead identifying header to refine our error\n      if (f->segments[0] == 64 &&\n          getn(f, header, 6) &&\n          header[0] == 'f' &&\n          header[1] == 'i' &&\n          header[2] == 's' &&\n          header[3] == 'h' &&\n          header[4] == 'e' &&\n          header[5] == 'a' &&\n          get8(f)   == 'd' &&\n          get8(f)   == '\\0')                        return error(f, VORBIS_ogg_skeleton_not_supported);\n      else\n                                                    return error(f, VORBIS_invalid_first_page);\n   }\n\n   // read packet\n   // check packet header\n   if (get8(f) != VORBIS_packet_id)                 return error(f, VORBIS_invalid_first_page);\n   if (!getn(f, header, 6))                         return error(f, VORBIS_unexpected_eof);\n   if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_first_page);\n   // vorbis_version\n   if (get32(f) != 0)                               return error(f, VORBIS_invalid_first_page);\n   f->channels = get8(f); if (!f->channels)         return error(f, VORBIS_invalid_first_page);\n   if (f->channels > STB_VORBIS_MAX_CHANNELS)       return error(f, VORBIS_too_many_channels);\n   f->sample_rate = get32(f); if (!f->sample_rate)  return error(f, VORBIS_invalid_first_page);\n   get32(f); // bitrate_maximum\n   get32(f); // bitrate_nominal\n   get32(f); // bitrate_minimum\n   x = get8(f);\n   {\n      int log0,log1;\n      log0 = x & 15;\n      log1 = x >> 4;\n      f->blocksize_0 = 1 << log0;\n      f->blocksize_1 = 1 << log1;\n      if (log0 < 6 || log0 > 13)                       return error(f, VORBIS_invalid_setup);\n      if (log1 < 6 || log1 > 13)                       return error(f, VORBIS_invalid_setup);\n      if (log0 > log1)                                 return error(f, VORBIS_invalid_setup);\n   }\n\n   // framing_flag\n   x = get8(f);\n   if (!(x & 1))                                    return error(f, VORBIS_invalid_first_page);\n\n   // second packet!\n   if (!start_page(f))                              return FALSE;\n\n   if (!start_packet(f))                            return FALSE;\n   do {\n      len = next_segment(f);\n      skip(f, len);\n      f->bytes_in_seg = 0;\n   } while (len);\n\n   // third packet!\n   if (!start_packet(f))                            return FALSE;\n\n   #ifndef STB_VORBIS_NO_PUSHDATA_API\n   if (IS_PUSH_MODE(f)) {\n      if (!is_whole_packet_present(f, TRUE)) {\n         // convert error in ogg header to write type\n         if (f->error == VORBIS_invalid_stream)\n            f->error = VORBIS_invalid_setup;\n         return FALSE;\n      }\n   }\n   #endif\n\n   crc32_init(); // always init it, to avoid multithread race conditions\n\n   if (get8_packet(f) != VORBIS_packet_setup)       return error(f, VORBIS_invalid_setup);\n   for (i=0; i < 6; ++i) header[i] = get8_packet(f);\n   if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_setup);\n\n   // codebooks\n\n   f->codebook_count = get_bits(f,8) + 1;\n   f->codebooks = (Codebook *) setup_malloc(f, sizeof(*f->codebooks) * f->codebook_count);\n   if (f->codebooks == NULL)                        return error(f, VORBIS_outofmem);\n   memset(f->codebooks, 0, sizeof(*f->codebooks) * f->codebook_count);\n   for (i=0; i < f->codebook_count; ++i) {\n      uint32 *values;\n      int ordered, sorted_count;\n      int total=0;\n      uint8 *lengths;\n      Codebook *c = f->codebooks+i;\n      CHECK(f);\n      x = get_bits(f, 8); if (x != 0x42)            return error(f, VORBIS_invalid_setup);\n      x = get_bits(f, 8); if (x != 0x43)            return error(f, VORBIS_invalid_setup);\n      x = get_bits(f, 8); if (x != 0x56)            return error(f, VORBIS_invalid_setup);\n      x = get_bits(f, 8);\n      c->dimensions = (get_bits(f, 8)<<8) + x;\n      x = get_bits(f, 8);\n      y = get_bits(f, 8);\n      c->entries = (get_bits(f, 8)<<16) + (y<<8) + x;\n      ordered = get_bits(f,1);\n      c->sparse = ordered ? 0 : get_bits(f,1);\n\n      if (c->dimensions == 0 && c->entries != 0)    return error(f, VORBIS_invalid_setup);\n\n      if (c->sparse)\n         lengths = (uint8 *) setup_temp_malloc(f, c->entries);\n      else\n         lengths = c->codeword_lengths = (uint8 *) setup_malloc(f, c->entries);\n\n      if (!lengths) return error(f, VORBIS_outofmem);\n\n      if (ordered) {\n         int current_entry = 0;\n         int current_length = get_bits(f,5) + 1;\n         while (current_entry < c->entries) {\n            int limit = c->entries - current_entry;\n            int n = get_bits(f, ilog(limit));\n            if (current_entry + n > (int) c->entries) { return error(f, VORBIS_invalid_setup); }\n            memset(lengths + current_entry, current_length, n);\n            current_entry += n;\n            ++current_length;\n         }\n      } else {\n         for (j=0; j < c->entries; ++j) {\n            int present = c->sparse ? get_bits(f,1) : 1;\n            if (present) {\n               lengths[j] = get_bits(f, 5) + 1;\n               ++total;\n               if (lengths[j] == 32)\n                  return error(f, VORBIS_invalid_setup);\n            } else {\n               lengths[j] = NO_CODE;\n            }\n         }\n      }\n\n      if (c->sparse && total >= c->entries >> 2) {\n         // convert sparse items to non-sparse!\n         if (c->entries > (int) f->setup_temp_memory_required)\n            f->setup_temp_memory_required = c->entries;\n\n         c->codeword_lengths = (uint8 *) setup_malloc(f, c->entries);\n         if (c->codeword_lengths == NULL) return error(f, VORBIS_outofmem);\n         memcpy(c->codeword_lengths, lengths, c->entries);\n         setup_temp_free(f, lengths, c->entries); // note this is only safe if there have been no intervening temp mallocs!\n         lengths = c->codeword_lengths;\n         c->sparse = 0;\n      }\n\n      // compute the size of the sorted tables\n      if (c->sparse) {\n         sorted_count = total;\n      } else {\n         sorted_count = 0;\n         #ifndef STB_VORBIS_NO_HUFFMAN_BINARY_SEARCH\n         for (j=0; j < c->entries; ++j)\n            if (lengths[j] > STB_VORBIS_FAST_HUFFMAN_LENGTH && lengths[j] != NO_CODE)\n               ++sorted_count;\n         #endif\n      }\n\n      c->sorted_entries = sorted_count;\n      values = NULL;\n\n      CHECK(f);\n      if (!c->sparse) {\n         c->codewords = (uint32 *) setup_malloc(f, sizeof(c->codewords[0]) * c->entries);\n         if (!c->codewords)                  return error(f, VORBIS_outofmem);\n      } else {\n         unsigned int size;\n         if (c->sorted_entries) {\n            c->codeword_lengths = (uint8 *) setup_malloc(f, c->sorted_entries);\n            if (!c->codeword_lengths)           return error(f, VORBIS_outofmem);\n            c->codewords = (uint32 *) setup_temp_malloc(f, sizeof(*c->codewords) * c->sorted_entries);\n            if (!c->codewords)                  return error(f, VORBIS_outofmem);\n            values = (uint32 *) setup_temp_malloc(f, sizeof(*values) * c->sorted_entries);\n            if (!values)                        return error(f, VORBIS_outofmem);\n         }\n         size = c->entries + (sizeof(*c->codewords) + sizeof(*values)) * c->sorted_entries;\n         if (size > f->setup_temp_memory_required)\n            f->setup_temp_memory_required = size;\n      }\n\n      if (!compute_codewords(c, lengths, c->entries, values)) {\n         if (c->sparse) setup_temp_free(f, values, 0);\n         return error(f, VORBIS_invalid_setup);\n      }\n\n      if (c->sorted_entries) {\n         // allocate an extra slot for sentinels\n         c->sorted_codewords = (uint32 *) setup_malloc(f, sizeof(*c->sorted_codewords) * (c->sorted_entries+1));\n         if (c->sorted_codewords == NULL) return error(f, VORBIS_outofmem);\n         // allocate an extra slot at the front so that c->sorted_values[-1] is defined\n         // so that we can catch that case without an extra if\n         c->sorted_values    = ( int   *) setup_malloc(f, sizeof(*c->sorted_values   ) * (c->sorted_entries+1));\n         if (c->sorted_values == NULL) return error(f, VORBIS_outofmem);\n         ++c->sorted_values;\n         c->sorted_values[-1] = -1;\n         compute_sorted_huffman(c, lengths, values);\n      }\n\n      if (c->sparse) {\n         setup_temp_free(f, values, sizeof(*values)*c->sorted_entries);\n         setup_temp_free(f, c->codewords, sizeof(*c->codewords)*c->sorted_entries);\n         setup_temp_free(f, lengths, c->entries);\n         c->codewords = NULL;\n      }\n\n      compute_accelerated_huffman(c);\n\n      CHECK(f);\n      c->lookup_type = get_bits(f, 4);\n      if (c->lookup_type > 2) return error(f, VORBIS_invalid_setup);\n      if (c->lookup_type > 0) {\n         uint16 *mults;\n         c->minimum_value = float32_unpack(get_bits(f, 32));\n         c->delta_value = float32_unpack(get_bits(f, 32));\n         c->value_bits = get_bits(f, 4)+1;\n         c->sequence_p = get_bits(f,1);\n         if (c->lookup_type == 1) {\n            c->lookup_values = lookup1_values(c->entries, c->dimensions);\n         } else {\n            c->lookup_values = c->entries * c->dimensions;\n         }\n         if (c->lookup_values == 0) return error(f, VORBIS_invalid_setup);\n         mults = (uint16 *) setup_temp_malloc(f, sizeof(mults[0]) * c->lookup_values);\n         if (mults == NULL) return error(f, VORBIS_outofmem);\n         for (j=0; j < (int) c->lookup_values; ++j) {\n            int q = get_bits(f, c->value_bits);\n            if (q == EOP) { setup_temp_free(f,mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_invalid_setup); }\n            mults[j] = q;\n         }\n\n#ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK\n         if (c->lookup_type == 1) {\n            int len, sparse = c->sparse;\n            float last=0;\n            // pre-expand the lookup1-style multiplicands, to avoid a divide in the inner loop\n            if (sparse) {\n               if (c->sorted_entries == 0) goto skip;\n               c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->sorted_entries * c->dimensions);\n            } else\n               c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->entries        * c->dimensions);\n            if (c->multiplicands == NULL) { setup_temp_free(f,mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_outofmem); }\n            len = sparse ? c->sorted_entries : c->entries;\n            for (j=0; j < len; ++j) {\n               unsigned int z = sparse ? c->sorted_values[j] : j;\n               unsigned int div=1;\n               for (k=0; k < c->dimensions; ++k) {\n                  int off = (z / div) % c->lookup_values;\n                  float val = mults[off];\n                  val = mults[off]*c->delta_value + c->minimum_value + last;\n                  c->multiplicands[j*c->dimensions + k] = val;\n                  if (c->sequence_p)\n                     last = val;\n                  if (k+1 < c->dimensions) {\n                     if (div > UINT_MAX / (unsigned int) c->lookup_values) {\n                        setup_temp_free(f, mults,sizeof(mults[0])*c->lookup_values);\n                        return error(f, VORBIS_invalid_setup);\n                     }\n                     div *= c->lookup_values;\n                  }\n               }\n            }\n            c->lookup_type = 2;\n         }\n         else\n#endif\n         {\n            float last=0;\n            CHECK(f);\n            c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->lookup_values);\n            if (c->multiplicands == NULL) { setup_temp_free(f, mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_outofmem); }\n            for (j=0; j < (int) c->lookup_values; ++j) {\n               float val = mults[j] * c->delta_value + c->minimum_value + last;\n               c->multiplicands[j] = val;\n               if (c->sequence_p)\n                  last = val;\n            }\n         }\n#ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK\n        skip:;\n#endif\n         setup_temp_free(f, mults, sizeof(mults[0])*c->lookup_values);\n\n         CHECK(f);\n      }\n      CHECK(f);\n   }\n\n   // time domain transfers (notused)\n\n   x = get_bits(f, 6) + 1;\n   for (i=0; i < x; ++i) {\n      uint32 z = get_bits(f, 16);\n      if (z != 0) return error(f, VORBIS_invalid_setup);\n   }\n\n   // Floors\n   f->floor_count = get_bits(f, 6)+1;\n   f->floor_config = (Floor *)  setup_malloc(f, f->floor_count * sizeof(*f->floor_config));\n   if (f->floor_config == NULL) return error(f, VORBIS_outofmem);\n   for (i=0; i < f->floor_count; ++i) {\n      f->floor_types[i] = get_bits(f, 16);\n      if (f->floor_types[i] > 1) return error(f, VORBIS_invalid_setup);\n      if (f->floor_types[i] == 0) {\n         Floor0 *g = &f->floor_config[i].floor0;\n         g->order = get_bits(f,8);\n         g->rate = get_bits(f,16);\n         g->bark_map_size = get_bits(f,16);\n         g->amplitude_bits = get_bits(f,6);\n         g->amplitude_offset = get_bits(f,8);\n         g->number_of_books = get_bits(f,4) + 1;\n         for (j=0; j < g->number_of_books; ++j)\n            g->book_list[j] = get_bits(f,8);\n         return error(f, VORBIS_feature_not_supported);\n      } else {\n         stbv__floor_ordering p[31*8+2];\n         Floor1 *g = &f->floor_config[i].floor1;\n         int max_class = -1; \n         g->partitions = get_bits(f, 5);\n         for (j=0; j < g->partitions; ++j) {\n            g->partition_class_list[j] = get_bits(f, 4);\n            if (g->partition_class_list[j] > max_class)\n               max_class = g->partition_class_list[j];\n         }\n         for (j=0; j <= max_class; ++j) {\n            g->class_dimensions[j] = get_bits(f, 3)+1;\n            g->class_subclasses[j] = get_bits(f, 2);\n            if (g->class_subclasses[j]) {\n               g->class_masterbooks[j] = get_bits(f, 8);\n               if (g->class_masterbooks[j] >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n            }\n            for (k=0; k < 1 << g->class_subclasses[j]; ++k) {\n               g->subclass_books[j][k] = get_bits(f,8)-1;\n               if (g->subclass_books[j][k] >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n            }\n         }\n         g->floor1_multiplier = get_bits(f,2)+1;\n         g->rangebits = get_bits(f,4);\n         g->Xlist[0] = 0;\n         g->Xlist[1] = 1 << g->rangebits;\n         g->values = 2;\n         for (j=0; j < g->partitions; ++j) {\n            int c = g->partition_class_list[j];\n            for (k=0; k < g->class_dimensions[c]; ++k) {\n               g->Xlist[g->values] = get_bits(f, g->rangebits);\n               ++g->values;\n            }\n         }\n         // precompute the sorting\n         for (j=0; j < g->values; ++j) {\n            p[j].x = g->Xlist[j];\n            p[j].id = j;\n         }\n         qsort(p, g->values, sizeof(p[0]), point_compare);\n         for (j=0; j < g->values; ++j)\n            g->sorted_order[j] = (uint8) p[j].id;\n         // precompute the neighbors\n         for (j=2; j < g->values; ++j) {\n            int low,hi;\n            neighbors(g->Xlist, j, &low,&hi);\n            g->neighbors[j][0] = low;\n            g->neighbors[j][1] = hi;\n         }\n\n         if (g->values > longest_floorlist)\n            longest_floorlist = g->values;\n      }\n   }\n\n   // Residue\n   f->residue_count = get_bits(f, 6)+1;\n   f->residue_config = (Residue *) setup_malloc(f, f->residue_count * sizeof(f->residue_config[0]));\n   if (f->residue_config == NULL) return error(f, VORBIS_outofmem);\n   memset(f->residue_config, 0, f->residue_count * sizeof(f->residue_config[0]));\n   for (i=0; i < f->residue_count; ++i) {\n      uint8 residue_cascade[64];\n      Residue *r = f->residue_config+i;\n      f->residue_types[i] = get_bits(f, 16);\n      if (f->residue_types[i] > 2) return error(f, VORBIS_invalid_setup);\n      r->begin = get_bits(f, 24);\n      r->end = get_bits(f, 24);\n      if (r->end < r->begin) return error(f, VORBIS_invalid_setup);\n      r->part_size = get_bits(f,24)+1;\n      r->classifications = get_bits(f,6)+1;\n      r->classbook = get_bits(f,8);\n      if (r->classbook >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n      for (j=0; j < r->classifications; ++j) {\n         uint8 high_bits=0;\n         uint8 low_bits=get_bits(f,3);\n         if (get_bits(f,1))\n            high_bits = get_bits(f,5);\n         residue_cascade[j] = high_bits*8 + low_bits;\n      }\n      r->residue_books = (short (*)[8]) setup_malloc(f, sizeof(r->residue_books[0]) * r->classifications);\n      if (r->residue_books == NULL) return error(f, VORBIS_outofmem);\n      for (j=0; j < r->classifications; ++j) {\n         for (k=0; k < 8; ++k) {\n            if (residue_cascade[j] & (1 << k)) {\n               r->residue_books[j][k] = get_bits(f, 8);\n               if (r->residue_books[j][k] >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n            } else {\n               r->residue_books[j][k] = -1;\n            }\n         }\n      }\n      // precompute the classifications[] array to avoid inner-loop mod/divide\n      // call it 'classdata' since we already have r->classifications\n      r->classdata = (uint8 **) setup_malloc(f, sizeof(*r->classdata) * f->codebooks[r->classbook].entries);\n      if (!r->classdata) return error(f, VORBIS_outofmem);\n      memset(r->classdata, 0, sizeof(*r->classdata) * f->codebooks[r->classbook].entries);\n      for (j=0; j < f->codebooks[r->classbook].entries; ++j) {\n         int classwords = f->codebooks[r->classbook].dimensions;\n         int temp = j;\n         r->classdata[j] = (uint8 *) setup_malloc(f, sizeof(r->classdata[j][0]) * classwords);\n         if (r->classdata[j] == NULL) return error(f, VORBIS_outofmem);\n         for (k=classwords-1; k >= 0; --k) {\n            r->classdata[j][k] = temp % r->classifications;\n            temp /= r->classifications;\n         }\n      }\n   }\n\n   f->mapping_count = get_bits(f,6)+1;\n   f->mapping = (Mapping *) setup_malloc(f, f->mapping_count * sizeof(*f->mapping));\n   if (f->mapping == NULL) return error(f, VORBIS_outofmem);\n   memset(f->mapping, 0, f->mapping_count * sizeof(*f->mapping));\n   for (i=0; i < f->mapping_count; ++i) {\n      Mapping *m = f->mapping + i;      \n      int mapping_type = get_bits(f,16);\n      if (mapping_type != 0) return error(f, VORBIS_invalid_setup);\n      m->chan = (MappingChannel *) setup_malloc(f, f->channels * sizeof(*m->chan));\n      if (m->chan == NULL) return error(f, VORBIS_outofmem);\n      if (get_bits(f,1))\n         m->submaps = get_bits(f,4)+1;\n      else\n         m->submaps = 1;\n      if (m->submaps > max_submaps)\n         max_submaps = m->submaps;\n      if (get_bits(f,1)) {\n         m->coupling_steps = get_bits(f,8)+1;\n         for (k=0; k < m->coupling_steps; ++k) {\n            m->chan[k].magnitude = get_bits(f, ilog(f->channels-1));\n            m->chan[k].angle = get_bits(f, ilog(f->channels-1));\n            if (m->chan[k].magnitude >= f->channels)        return error(f, VORBIS_invalid_setup);\n            if (m->chan[k].angle     >= f->channels)        return error(f, VORBIS_invalid_setup);\n            if (m->chan[k].magnitude == m->chan[k].angle)   return error(f, VORBIS_invalid_setup);\n         }\n      } else\n         m->coupling_steps = 0;\n\n      // reserved field\n      if (get_bits(f,2)) return error(f, VORBIS_invalid_setup);\n      if (m->submaps > 1) {\n         for (j=0; j < f->channels; ++j) {\n            m->chan[j].mux = get_bits(f, 4);\n            if (m->chan[j].mux >= m->submaps)                return error(f, VORBIS_invalid_setup);\n         }\n      } else\n         // @SPECIFICATION: this case is missing from the spec\n         for (j=0; j < f->channels; ++j)\n            m->chan[j].mux = 0;\n\n      for (j=0; j < m->submaps; ++j) {\n         get_bits(f,8); // discard\n         m->submap_floor[j] = get_bits(f,8);\n         m->submap_residue[j] = get_bits(f,8);\n         if (m->submap_floor[j] >= f->floor_count)      return error(f, VORBIS_invalid_setup);\n         if (m->submap_residue[j] >= f->residue_count)  return error(f, VORBIS_invalid_setup);\n      }\n   }\n\n   // Modes\n   f->mode_count = get_bits(f, 6)+1;\n   for (i=0; i < f->mode_count; ++i) {\n      Mode *m = f->mode_config+i;\n      m->blockflag = get_bits(f,1);\n      m->windowtype = get_bits(f,16);\n      m->transformtype = get_bits(f,16);\n      m->mapping = get_bits(f,8);\n      if (m->windowtype != 0)                 return error(f, VORBIS_invalid_setup);\n      if (m->transformtype != 0)              return error(f, VORBIS_invalid_setup);\n      if (m->mapping >= f->mapping_count)     return error(f, VORBIS_invalid_setup);\n   }\n\n   flush_packet(f);\n\n   f->previous_length = 0;\n\n   for (i=0; i < f->channels; ++i) {\n      f->channel_buffers[i] = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1);\n      f->previous_window[i] = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1/2);\n      f->finalY[i]          = (int16 *) setup_malloc(f, sizeof(int16) * longest_floorlist);\n      if (f->channel_buffers[i] == NULL || f->previous_window[i] == NULL || f->finalY[i] == NULL) return error(f, VORBIS_outofmem);\n      memset(f->channel_buffers[i], 0, sizeof(float) * f->blocksize_1);\n      #ifdef STB_VORBIS_NO_DEFER_FLOOR\n      f->floor_buffers[i]   = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1/2);\n      if (f->floor_buffers[i] == NULL) return error(f, VORBIS_outofmem);\n      #endif\n   }\n\n   if (!init_blocksize(f, 0, f->blocksize_0)) return FALSE;\n   if (!init_blocksize(f, 1, f->blocksize_1)) return FALSE;\n   f->blocksize[0] = f->blocksize_0;\n   f->blocksize[1] = f->blocksize_1;\n\n#ifdef STB_VORBIS_DIVIDE_TABLE\n   if (integer_divide_table[1][1]==0)\n      for (i=0; i < DIVTAB_NUMER; ++i)\n         for (j=1; j < DIVTAB_DENOM; ++j)\n            integer_divide_table[i][j] = i / j;\n#endif\n\n   // compute how much temporary memory is needed\n\n   // 1.\n   {\n      uint32 imdct_mem = (f->blocksize_1 * sizeof(float) >> 1);\n      uint32 classify_mem;\n      int i,max_part_read=0;\n      for (i=0; i < f->residue_count; ++i) {\n         Residue *r = f->residue_config + i;\n         unsigned int actual_size = f->blocksize_1 / 2;\n         unsigned int limit_r_begin = r->begin < actual_size ? r->begin : actual_size;\n         unsigned int limit_r_end   = r->end   < actual_size ? r->end   : actual_size;\n         int n_read = limit_r_end - limit_r_begin;\n         int part_read = n_read / r->part_size;\n         if (part_read > max_part_read)\n            max_part_read = part_read;\n      }\n      #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n      classify_mem = f->channels * (sizeof(void*) + max_part_read * sizeof(uint8 *));\n      #else\n      classify_mem = f->channels * (sizeof(void*) + max_part_read * sizeof(int *));\n      #endif\n\n      // maximum reasonable partition size is f->blocksize_1\n\n      f->temp_memory_required = classify_mem;\n      if (imdct_mem > f->temp_memory_required)\n         f->temp_memory_required = imdct_mem;\n   }\n\n   f->first_decode = TRUE;\n\n   if (f->alloc.alloc_buffer) {\n      assert(f->temp_offset == f->alloc.alloc_buffer_length_in_bytes);\n      // check if there's enough temp memory so we don't error later\n      if (f->setup_offset + sizeof(*f) + f->temp_memory_required > (unsigned) f->temp_offset)\n         return error(f, VORBIS_outofmem);\n   }\n\n   f->first_audio_page_offset = stb_vorbis_get_file_offset(f);\n\n   return TRUE;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 3701,
    "critical_vars": [
      "current_length"
    ],
    "function": "start_decoder",
    "filename": "stb/CVE-2019-13219/CVE-2019-13219_CWE-476_98fdfc6df88b1e34a736d5e126e6c8139c8de1a6_stb_vorbis.c.diff",
    "function_code": "static int start_decoder(vorb *f)\n{\n   uint8 header[6], x,y;\n   int len,i,j,k, max_submaps = 0;\n   int longest_floorlist=0;\n\n   // first page, first packet\n\n   if (!start_page(f))                              return FALSE;\n   // validate page flag\n   if (!(f->page_flag & PAGEFLAG_first_page))       return error(f, VORBIS_invalid_first_page);\n   if (f->page_flag & PAGEFLAG_last_page)           return error(f, VORBIS_invalid_first_page);\n   if (f->page_flag & PAGEFLAG_continued_packet)    return error(f, VORBIS_invalid_first_page);\n   // check for expected packet length\n   if (f->segment_count != 1)                       return error(f, VORBIS_invalid_first_page);\n   if (f->segments[0] != 30) {\n      // check for the Ogg skeleton fishead identifying header to refine our error\n      if (f->segments[0] == 64 &&\n          getn(f, header, 6) &&\n          header[0] == 'f' &&\n          header[1] == 'i' &&\n          header[2] == 's' &&\n          header[3] == 'h' &&\n          header[4] == 'e' &&\n          header[5] == 'a' &&\n          get8(f)   == 'd' &&\n          get8(f)   == '\\0')                        return error(f, VORBIS_ogg_skeleton_not_supported);\n      else\n                                                    return error(f, VORBIS_invalid_first_page);\n   }\n\n   // read packet\n   // check packet header\n   if (get8(f) != VORBIS_packet_id)                 return error(f, VORBIS_invalid_first_page);\n   if (!getn(f, header, 6))                         return error(f, VORBIS_unexpected_eof);\n   if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_first_page);\n   // vorbis_version\n   if (get32(f) != 0)                               return error(f, VORBIS_invalid_first_page);\n   f->channels = get8(f); if (!f->channels)         return error(f, VORBIS_invalid_first_page);\n   if (f->channels > STB_VORBIS_MAX_CHANNELS)       return error(f, VORBIS_too_many_channels);\n   f->sample_rate = get32(f); if (!f->sample_rate)  return error(f, VORBIS_invalid_first_page);\n   get32(f); // bitrate_maximum\n   get32(f); // bitrate_nominal\n   get32(f); // bitrate_minimum\n   x = get8(f);\n   {\n      int log0,log1;\n      log0 = x & 15;\n      log1 = x >> 4;\n      f->blocksize_0 = 1 << log0;\n      f->blocksize_1 = 1 << log1;\n      if (log0 < 6 || log0 > 13)                       return error(f, VORBIS_invalid_setup);\n      if (log1 < 6 || log1 > 13)                       return error(f, VORBIS_invalid_setup);\n      if (log0 > log1)                                 return error(f, VORBIS_invalid_setup);\n   }\n\n   // framing_flag\n   x = get8(f);\n   if (!(x & 1))                                    return error(f, VORBIS_invalid_first_page);\n\n   // second packet!\n   if (!start_page(f))                              return FALSE;\n\n   if (!start_packet(f))                            return FALSE;\n   do {\n      len = next_segment(f);\n      skip(f, len);\n      f->bytes_in_seg = 0;\n   } while (len);\n\n   // third packet!\n   if (!start_packet(f))                            return FALSE;\n\n   #ifndef STB_VORBIS_NO_PUSHDATA_API\n   if (IS_PUSH_MODE(f)) {\n      if (!is_whole_packet_present(f, TRUE)) {\n         // convert error in ogg header to write type\n         if (f->error == VORBIS_invalid_stream)\n            f->error = VORBIS_invalid_setup;\n         return FALSE;\n      }\n   }\n   #endif\n\n   crc32_init(); // always init it, to avoid multithread race conditions\n\n   if (get8_packet(f) != VORBIS_packet_setup)       return error(f, VORBIS_invalid_setup);\n   for (i=0; i < 6; ++i) header[i] = get8_packet(f);\n   if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_setup);\n\n   // codebooks\n\n   f->codebook_count = get_bits(f,8) + 1;\n   f->codebooks = (Codebook *) setup_malloc(f, sizeof(*f->codebooks) * f->codebook_count);\n   if (f->codebooks == NULL)                        return error(f, VORBIS_outofmem);\n   memset(f->codebooks, 0, sizeof(*f->codebooks) * f->codebook_count);\n   for (i=0; i < f->codebook_count; ++i) {\n      uint32 *values;\n      int ordered, sorted_count;\n      int total=0;\n      uint8 *lengths;\n      Codebook *c = f->codebooks+i;\n      CHECK(f);\n      x = get_bits(f, 8); if (x != 0x42)            return error(f, VORBIS_invalid_setup);\n      x = get_bits(f, 8); if (x != 0x43)            return error(f, VORBIS_invalid_setup);\n      x = get_bits(f, 8); if (x != 0x56)            return error(f, VORBIS_invalid_setup);\n      x = get_bits(f, 8);\n      c->dimensions = (get_bits(f, 8)<<8) + x;\n      x = get_bits(f, 8);\n      y = get_bits(f, 8);\n      c->entries = (get_bits(f, 8)<<16) + (y<<8) + x;\n      ordered = get_bits(f,1);\n      c->sparse = ordered ? 0 : get_bits(f,1);\n\n      if (c->dimensions == 0 && c->entries != 0)    return error(f, VORBIS_invalid_setup);\n\n      if (c->sparse)\n         lengths = (uint8 *) setup_temp_malloc(f, c->entries);\n      else\n         lengths = c->codeword_lengths = (uint8 *) setup_malloc(f, c->entries);\n\n      if (!lengths) return error(f, VORBIS_outofmem);\n\n      if (ordered) {\n         int current_entry = 0;\n         int current_length = get_bits(f,5) + 1;\n         while (current_entry < c->entries) {\n            int limit = c->entries - current_entry;\n            int n = get_bits(f, ilog(limit));\n            if (current_length >= 32) return error(f, VORBIS_invalid_setup);\n            if (current_entry + n > (int) c->entries) { return error(f, VORBIS_invalid_setup); }\n            memset(lengths + current_entry, current_length, n);\n            current_entry += n;\n            ++current_length;\n         }\n      } else {\n         for (j=0; j < c->entries; ++j) {\n            int present = c->sparse ? get_bits(f,1) : 1;\n            if (present) {\n               lengths[j] = get_bits(f, 5) + 1;\n               ++total;\n               if (lengths[j] == 32)\n                  return error(f, VORBIS_invalid_setup);\n            } else {\n               lengths[j] = NO_CODE;\n            }\n         }\n      }\n\n      if (c->sparse && total >= c->entries >> 2) {\n         // convert sparse items to non-sparse!\n         if (c->entries > (int) f->setup_temp_memory_required)\n            f->setup_temp_memory_required = c->entries;\n\n         c->codeword_lengths = (uint8 *) setup_malloc(f, c->entries);\n         if (c->codeword_lengths == NULL) return error(f, VORBIS_outofmem);\n         memcpy(c->codeword_lengths, lengths, c->entries);\n         setup_temp_free(f, lengths, c->entries); // note this is only safe if there have been no intervening temp mallocs!\n         lengths = c->codeword_lengths;\n         c->sparse = 0;\n      }\n\n      // compute the size of the sorted tables\n      if (c->sparse) {\n         sorted_count = total;\n      } else {\n         sorted_count = 0;\n         #ifndef STB_VORBIS_NO_HUFFMAN_BINARY_SEARCH\n         for (j=0; j < c->entries; ++j)\n            if (lengths[j] > STB_VORBIS_FAST_HUFFMAN_LENGTH && lengths[j] != NO_CODE)\n               ++sorted_count;\n         #endif\n      }\n\n      c->sorted_entries = sorted_count;\n      values = NULL;\n\n      CHECK(f);\n      if (!c->sparse) {\n         c->codewords = (uint32 *) setup_malloc(f, sizeof(c->codewords[0]) * c->entries);\n         if (!c->codewords)                  return error(f, VORBIS_outofmem);\n      } else {\n         unsigned int size;\n         if (c->sorted_entries) {\n            c->codeword_lengths = (uint8 *) setup_malloc(f, c->sorted_entries);\n            if (!c->codeword_lengths)           return error(f, VORBIS_outofmem);\n            c->codewords = (uint32 *) setup_temp_malloc(f, sizeof(*c->codewords) * c->sorted_entries);\n            if (!c->codewords)                  return error(f, VORBIS_outofmem);\n            values = (uint32 *) setup_temp_malloc(f, sizeof(*values) * c->sorted_entries);\n            if (!values)                        return error(f, VORBIS_outofmem);\n         }\n         size = c->entries + (sizeof(*c->codewords) + sizeof(*values)) * c->sorted_entries;\n         if (size > f->setup_temp_memory_required)\n            f->setup_temp_memory_required = size;\n      }\n\n      if (!compute_codewords(c, lengths, c->entries, values)) {\n         if (c->sparse) setup_temp_free(f, values, 0);\n         return error(f, VORBIS_invalid_setup);\n      }\n\n      if (c->sorted_entries) {\n         // allocate an extra slot for sentinels\n         c->sorted_codewords = (uint32 *) setup_malloc(f, sizeof(*c->sorted_codewords) * (c->sorted_entries+1));\n         if (c->sorted_codewords == NULL) return error(f, VORBIS_outofmem);\n         // allocate an extra slot at the front so that c->sorted_values[-1] is defined\n         // so that we can catch that case without an extra if\n         c->sorted_values    = ( int   *) setup_malloc(f, sizeof(*c->sorted_values   ) * (c->sorted_entries+1));\n         if (c->sorted_values == NULL) return error(f, VORBIS_outofmem);\n         ++c->sorted_values;\n         c->sorted_values[-1] = -1;\n         compute_sorted_huffman(c, lengths, values);\n      }\n\n      if (c->sparse) {\n         setup_temp_free(f, values, sizeof(*values)*c->sorted_entries);\n         setup_temp_free(f, c->codewords, sizeof(*c->codewords)*c->sorted_entries);\n         setup_temp_free(f, lengths, c->entries);\n         c->codewords = NULL;\n      }\n\n      compute_accelerated_huffman(c);\n\n      CHECK(f);\n      c->lookup_type = get_bits(f, 4);\n      if (c->lookup_type > 2) return error(f, VORBIS_invalid_setup);\n      if (c->lookup_type > 0) {\n         uint16 *mults;\n         c->minimum_value = float32_unpack(get_bits(f, 32));\n         c->delta_value = float32_unpack(get_bits(f, 32));\n         c->value_bits = get_bits(f, 4)+1;\n         c->sequence_p = get_bits(f,1);\n         if (c->lookup_type == 1) {\n            int values = lookup1_values(c->entries, c->dimensions);\n            if (values < 0) return error(f, VORBIS_invalid_setup);\n            c->lookup_values = (uint32) values;\n         } else {\n            c->lookup_values = c->entries * c->dimensions;\n         }\n         if (c->lookup_values == 0) return error(f, VORBIS_invalid_setup);\n         mults = (uint16 *) setup_temp_malloc(f, sizeof(mults[0]) * c->lookup_values);\n         if (mults == NULL) return error(f, VORBIS_outofmem);\n         for (j=0; j < (int) c->lookup_values; ++j) {\n            int q = get_bits(f, c->value_bits);\n            if (q == EOP) { setup_temp_free(f,mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_invalid_setup); }\n            mults[j] = q;\n         }\n\n#ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK\n         if (c->lookup_type == 1) {\n            int len, sparse = c->sparse;\n            float last=0;\n            // pre-expand the lookup1-style multiplicands, to avoid a divide in the inner loop\n            if (sparse) {\n               if (c->sorted_entries == 0) goto skip;\n               c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->sorted_entries * c->dimensions);\n            } else\n               c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->entries        * c->dimensions);\n            if (c->multiplicands == NULL) { setup_temp_free(f,mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_outofmem); }\n            len = sparse ? c->sorted_entries : c->entries;\n            for (j=0; j < len; ++j) {\n               unsigned int z = sparse ? c->sorted_values[j] : j;\n               unsigned int div=1;\n               for (k=0; k < c->dimensions; ++k) {\n                  int off = (z / div) % c->lookup_values;\n                  float val = mults[off];\n                  val = mults[off]*c->delta_value + c->minimum_value + last;\n                  c->multiplicands[j*c->dimensions + k] = val;\n                  if (c->sequence_p)\n                     last = val;\n                  if (k+1 < c->dimensions) {\n                     if (div > UINT_MAX / (unsigned int) c->lookup_values) {\n                        setup_temp_free(f, mults,sizeof(mults[0])*c->lookup_values);\n                        return error(f, VORBIS_invalid_setup);\n                     }\n                     div *= c->lookup_values;\n                  }\n               }\n            }\n            c->lookup_type = 2;\n         }\n         else\n#endif\n         {\n            float last=0;\n            CHECK(f);\n            c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->lookup_values);\n            if (c->multiplicands == NULL) { setup_temp_free(f, mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_outofmem); }\n            for (j=0; j < (int) c->lookup_values; ++j) {\n               float val = mults[j] * c->delta_value + c->minimum_value + last;\n               c->multiplicands[j] = val;\n               if (c->sequence_p)\n                  last = val;\n            }\n         }\n#ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK\n        skip:;\n#endif\n         setup_temp_free(f, mults, sizeof(mults[0])*c->lookup_values);\n\n         CHECK(f);\n      }\n      CHECK(f);\n   }\n\n   // time domain transfers (notused)\n\n   x = get_bits(f, 6) + 1;\n   for (i=0; i < x; ++i) {\n      uint32 z = get_bits(f, 16);\n      if (z != 0) return error(f, VORBIS_invalid_setup);\n   }\n\n   // Floors\n   f->floor_count = get_bits(f, 6)+1;\n   f->floor_config = (Floor *)  setup_malloc(f, f->floor_count * sizeof(*f->floor_config));\n   if (f->floor_config == NULL) return error(f, VORBIS_outofmem);\n   for (i=0; i < f->floor_count; ++i) {\n      f->floor_types[i] = get_bits(f, 16);\n      if (f->floor_types[i] > 1) return error(f, VORBIS_invalid_setup);\n      if (f->floor_types[i] == 0) {\n         Floor0 *g = &f->floor_config[i].floor0;\n         g->order = get_bits(f,8);\n         g->rate = get_bits(f,16);\n         g->bark_map_size = get_bits(f,16);\n         g->amplitude_bits = get_bits(f,6);\n         g->amplitude_offset = get_bits(f,8);\n         g->number_of_books = get_bits(f,4) + 1;\n         for (j=0; j < g->number_of_books; ++j)\n            g->book_list[j] = get_bits(f,8);\n         return error(f, VORBIS_feature_not_supported);\n      } else {\n         stbv__floor_ordering p[31*8+2];\n         Floor1 *g = &f->floor_config[i].floor1;\n         int max_class = -1; \n         g->partitions = get_bits(f, 5);\n         for (j=0; j < g->partitions; ++j) {\n            g->partition_class_list[j] = get_bits(f, 4);\n            if (g->partition_class_list[j] > max_class)\n               max_class = g->partition_class_list[j];\n         }\n         for (j=0; j <= max_class; ++j) {\n            g->class_dimensions[j] = get_bits(f, 3)+1;\n            g->class_subclasses[j] = get_bits(f, 2);\n            if (g->class_subclasses[j]) {\n               g->class_masterbooks[j] = get_bits(f, 8);\n               if (g->class_masterbooks[j] >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n            }\n            for (k=0; k < 1 << g->class_subclasses[j]; ++k) {\n               g->subclass_books[j][k] = get_bits(f,8)-1;\n               if (g->subclass_books[j][k] >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n            }\n         }\n         g->floor1_multiplier = get_bits(f,2)+1;\n         g->rangebits = get_bits(f,4);\n         g->Xlist[0] = 0;\n         g->Xlist[1] = 1 << g->rangebits;\n         g->values = 2;\n         for (j=0; j < g->partitions; ++j) {\n            int c = g->partition_class_list[j];\n            for (k=0; k < g->class_dimensions[c]; ++k) {\n               g->Xlist[g->values] = get_bits(f, g->rangebits);\n               ++g->values;\n            }\n         }\n         // precompute the sorting\n         for (j=0; j < g->values; ++j) {\n            p[j].x = g->Xlist[j];\n            p[j].id = j;\n         }\n         qsort(p, g->values, sizeof(p[0]), point_compare);\n         for (j=0; j < g->values-1; ++j)\n            if (p[j].x == p[j+1].x)\n               return error(f, VORBIS_invalid_setup);\n         for (j=0; j < g->values; ++j)\n            g->sorted_order[j] = (uint8) p[j].id;\n         // precompute the neighbors\n         for (j=2; j < g->values; ++j) {\n            int low,hi;\n            neighbors(g->Xlist, j, &low,&hi);\n            g->neighbors[j][0] = low;\n            g->neighbors[j][1] = hi;\n         }\n\n         if (g->values > longest_floorlist)\n            longest_floorlist = g->values;\n      }\n   }\n\n   // Residue\n   f->residue_count = get_bits(f, 6)+1;\n   f->residue_config = (Residue *) setup_malloc(f, f->residue_count * sizeof(f->residue_config[0]));\n   if (f->residue_config == NULL) return error(f, VORBIS_outofmem);\n   memset(f->residue_config, 0, f->residue_count * sizeof(f->residue_config[0]));\n   for (i=0; i < f->residue_count; ++i) {\n      uint8 residue_cascade[64];\n      Residue *r = f->residue_config+i;\n      f->residue_types[i] = get_bits(f, 16);\n      if (f->residue_types[i] > 2) return error(f, VORBIS_invalid_setup);\n      r->begin = get_bits(f, 24);\n      r->end = get_bits(f, 24);\n      if (r->end < r->begin) return error(f, VORBIS_invalid_setup);\n      r->part_size = get_bits(f,24)+1;\n      r->classifications = get_bits(f,6)+1;\n      r->classbook = get_bits(f,8);\n      if (r->classbook >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n      for (j=0; j < r->classifications; ++j) {\n         uint8 high_bits=0;\n         uint8 low_bits=get_bits(f,3);\n         if (get_bits(f,1))\n            high_bits = get_bits(f,5);\n         residue_cascade[j] = high_bits*8 + low_bits;\n      }\n      r->residue_books = (short (*)[8]) setup_malloc(f, sizeof(r->residue_books[0]) * r->classifications);\n      if (r->residue_books == NULL) return error(f, VORBIS_outofmem);\n      for (j=0; j < r->classifications; ++j) {\n         for (k=0; k < 8; ++k) {\n            if (residue_cascade[j] & (1 << k)) {\n               r->residue_books[j][k] = get_bits(f, 8);\n               if (r->residue_books[j][k] >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n            } else {\n               r->residue_books[j][k] = -1;\n            }\n         }\n      }\n      // precompute the classifications[] array to avoid inner-loop mod/divide\n      // call it 'classdata' since we already have r->classifications\n      r->classdata = (uint8 **) setup_malloc(f, sizeof(*r->classdata) * f->codebooks[r->classbook].entries);\n      if (!r->classdata) return error(f, VORBIS_outofmem);\n      memset(r->classdata, 0, sizeof(*r->classdata) * f->codebooks[r->classbook].entries);\n      for (j=0; j < f->codebooks[r->classbook].entries; ++j) {\n         int classwords = f->codebooks[r->classbook].dimensions;\n         int temp = j;\n         r->classdata[j] = (uint8 *) setup_malloc(f, sizeof(r->classdata[j][0]) * classwords);\n         if (r->classdata[j] == NULL) return error(f, VORBIS_outofmem);\n         for (k=classwords-1; k >= 0; --k) {\n            r->classdata[j][k] = temp % r->classifications;\n            temp /= r->classifications;\n         }\n      }\n   }\n\n   f->mapping_count = get_bits(f,6)+1;\n   f->mapping = (Mapping *) setup_malloc(f, f->mapping_count * sizeof(*f->mapping));\n   if (f->mapping == NULL) return error(f, VORBIS_outofmem);\n   memset(f->mapping, 0, f->mapping_count * sizeof(*f->mapping));\n   for (i=0; i < f->mapping_count; ++i) {\n      Mapping *m = f->mapping + i;      \n      int mapping_type = get_bits(f,16);\n      if (mapping_type != 0) return error(f, VORBIS_invalid_setup);\n      m->chan = (MappingChannel *) setup_malloc(f, f->channels * sizeof(*m->chan));\n      if (m->chan == NULL) return error(f, VORBIS_outofmem);\n      if (get_bits(f,1))\n         m->submaps = get_bits(f,4)+1;\n      else\n         m->submaps = 1;\n      if (m->submaps > max_submaps)\n         max_submaps = m->submaps;\n      if (get_bits(f,1)) {\n         m->coupling_steps = get_bits(f,8)+1;\n         if (m->coupling_steps > f->channels) return error(f, VORBIS_invalid_setup);\n         for (k=0; k < m->coupling_steps; ++k) {\n            m->chan[k].magnitude = get_bits(f, ilog(f->channels-1));\n            m->chan[k].angle = get_bits(f, ilog(f->channels-1));\n            if (m->chan[k].magnitude >= f->channels)        return error(f, VORBIS_invalid_setup);\n            if (m->chan[k].angle     >= f->channels)        return error(f, VORBIS_invalid_setup);\n            if (m->chan[k].magnitude == m->chan[k].angle)   return error(f, VORBIS_invalid_setup);\n         }\n      } else\n         m->coupling_steps = 0;\n\n      // reserved field\n      if (get_bits(f,2)) return error(f, VORBIS_invalid_setup);\n      if (m->submaps > 1) {\n         for (j=0; j < f->channels; ++j) {\n            m->chan[j].mux = get_bits(f, 4);\n            if (m->chan[j].mux >= m->submaps)                return error(f, VORBIS_invalid_setup);\n         }\n      } else\n         // @SPECIFICATION: this case is missing from the spec\n         for (j=0; j < f->channels; ++j)\n            m->chan[j].mux = 0;\n\n      for (j=0; j < m->submaps; ++j) {\n         get_bits(f,8); // discard\n         m->submap_floor[j] = get_bits(f,8);\n         m->submap_residue[j] = get_bits(f,8);\n         if (m->submap_floor[j] >= f->floor_count)      return error(f, VORBIS_invalid_setup);\n         if (m->submap_residue[j] >= f->residue_count)  return error(f, VORBIS_invalid_setup);\n      }\n   }\n\n   // Modes\n   f->mode_count = get_bits(f, 6)+1;\n   for (i=0; i < f->mode_count; ++i) {\n      Mode *m = f->mode_config+i;\n      m->blockflag = get_bits(f,1);\n      m->windowtype = get_bits(f,16);\n      m->transformtype = get_bits(f,16);\n      m->mapping = get_bits(f,8);\n      if (m->windowtype != 0)                 return error(f, VORBIS_invalid_setup);\n      if (m->transformtype != 0)              return error(f, VORBIS_invalid_setup);\n      if (m->mapping >= f->mapping_count)     return error(f, VORBIS_invalid_setup);\n   }\n\n   flush_packet(f);\n\n   f->previous_length = 0;\n\n   for (i=0; i < f->channels; ++i) {\n      f->channel_buffers[i] = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1);\n      f->previous_window[i] = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1/2);\n      f->finalY[i]          = (int16 *) setup_malloc(f, sizeof(int16) * longest_floorlist);\n      if (f->channel_buffers[i] == NULL || f->previous_window[i] == NULL || f->finalY[i] == NULL) return error(f, VORBIS_outofmem);\n      memset(f->channel_buffers[i], 0, sizeof(float) * f->blocksize_1);\n      #ifdef STB_VORBIS_NO_DEFER_FLOOR\n      f->floor_buffers[i]   = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1/2);\n      if (f->floor_buffers[i] == NULL) return error(f, VORBIS_outofmem);\n      #endif\n   }\n\n   if (!init_blocksize(f, 0, f->blocksize_0)) return FALSE;\n   if (!init_blocksize(f, 1, f->blocksize_1)) return FALSE;\n   f->blocksize[0] = f->blocksize_0;\n   f->blocksize[1] = f->blocksize_1;\n\n#ifdef STB_VORBIS_DIVIDE_TABLE\n   if (integer_divide_table[1][1]==0)\n      for (i=0; i < DIVTAB_NUMER; ++i)\n         for (j=1; j < DIVTAB_DENOM; ++j)\n            integer_divide_table[i][j] = i / j;\n#endif\n\n   // compute how much temporary memory is needed\n\n   // 1.\n   {\n      uint32 imdct_mem = (f->blocksize_1 * sizeof(float) >> 1);\n      uint32 classify_mem;\n      int i,max_part_read=0;\n      for (i=0; i < f->residue_count; ++i) {\n         Residue *r = f->residue_config + i;\n         unsigned int actual_size = f->blocksize_1 / 2;\n         unsigned int limit_r_begin = r->begin < actual_size ? r->begin : actual_size;\n         unsigned int limit_r_end   = r->end   < actual_size ? r->end   : actual_size;\n         int n_read = limit_r_end - limit_r_begin;\n         int part_read = n_read / r->part_size;\n         if (part_read > max_part_read)\n            max_part_read = part_read;\n      }\n      #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n      classify_mem = f->channels * (sizeof(void*) + max_part_read * sizeof(uint8 *));\n      #else\n      classify_mem = f->channels * (sizeof(void*) + max_part_read * sizeof(int *));\n      #endif\n\n      // maximum reasonable partition size is f->blocksize_1\n\n      f->temp_memory_required = classify_mem;\n      if (imdct_mem > f->temp_memory_required)\n         f->temp_memory_required = imdct_mem;\n   }\n\n   f->first_decode = TRUE;\n\n   if (f->alloc.alloc_buffer) {\n      assert(f->temp_offset == f->alloc.alloc_buffer_length_in_bytes);\n      // check if there's enough temp memory so we don't error later\n      if (f->setup_offset + sizeof(*f) + f->temp_memory_required > (unsigned) f->temp_offset)\n         return error(f, VORBIS_outofmem);\n   }\n\n   f->first_audio_page_offset = stb_vorbis_get_file_offset(f);\n\n   return TRUE;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 720,
    "critical_vars": [
      "rdp",
      "length",
      "s->p"
    ],
    "function": "rdp_decrypt",
    "filename": "FreeRDP/CVE-2013-4118/CVE-2013-4118_CWE-476_7d58aac24fe20ffaad7bd9b40c9ddf457c1b06e7_rdp.c.diff",
    "function_code": "BOOL rdp_decrypt(rdpRdp* rdp, STREAM* s, int length, UINT16 securityFlags)\n{\n\tBYTE cmac[8];\n\tBYTE wmac[8];\n\n\tif (rdp->settings->EncryptionMethods == ENCRYPTION_METHOD_FIPS)\n\t{\n\t\tUINT16 len;\n\t\tBYTE version, pad;\n\t\tBYTE* sig;\n\n\t\tif (stream_get_left(s) < 12)\n\t\t\treturn FALSE;\n\n\t\tstream_read_UINT16(s, len); /* 0x10 */\n\t\tstream_read_BYTE(s, version); /* 0x1 */\n\t\tstream_read_BYTE(s, pad);\n\n\t\tsig = s->p;\n\t\tstream_seek(s, 8);\t/* signature */\n\n\t\tlength -= 12;\n\n\t\tif (!security_fips_decrypt(s->p, length, rdp))\n\t\t{\n\t\t\tprintf(\"FATAL: cannot decrypt\\n\");\n\t\t\treturn FALSE; /* TODO */\n\t\t}\n\n\t\tif (!security_fips_check_signature(s->p, length - pad, sig, rdp))\n\t\t{\n\t\t\tprintf(\"FATAL: invalid packet signature\\n\");\n\t\t\treturn FALSE; /* TODO */\n\t\t}\n\n\t\t/* is this what needs adjusting? */\n\t\ts->size -= pad;\n\t\treturn TRUE;\n\t}\n\n\tif (stream_get_left(s) < 8)\n\t\treturn FALSE;\n\n\tstream_read(s, wmac, sizeof(wmac));\n\tlength -= sizeof(wmac);\n\tsecurity_decrypt(s->p, length, rdp);\n\n\tif (securityFlags & SEC_SECURE_CHECKSUM)\n\t\tsecurity_salted_mac_signature(rdp, s->p, length, FALSE, cmac);\n\telse\n\t\tsecurity_mac_signature(rdp, s->p, length, cmac);\n\n\tif (memcmp(wmac, cmac, sizeof(wmac)) != 0)\n\t{\n\t\tprintf(\"WARNING: invalid packet signature\\n\");\n\t\t/*\n\t\t * Because Standard RDP Security is totally broken,\n\t\t * and cannot protect against MITM, don't treat signature\n\t\t * verification failure as critical. This at least enables\n\t\t * us to work with broken RDP clients and servers that\n\t\t * generate invalid signatures.\n\t\t */\n\t\t//return FALSE;\n\t}\n\n\treturn TRUE;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 720,
    "critical_vars": [
      "rdp",
      "length",
      "s->p"
    ],
    "function": "rdp_decrypt",
    "filename": "FreeRDP/CVE-2013-4118/CVE-2013-4118_CWE-476_7d58aac24fe20ffaad7bd9b40c9ddf457c1b06e7_rdp.c.diff",
    "function_code": "BOOL rdp_decrypt(rdpRdp* rdp, STREAM* s, int length, UINT16 securityFlags)\n{\n\tBYTE cmac[8];\n\tBYTE wmac[8];\n\n\tif (rdp->settings->EncryptionMethods == ENCRYPTION_METHOD_FIPS)\n\t{\n\t\tUINT16 len;\n\t\tBYTE version, pad;\n\t\tBYTE* sig;\n\n\t\tif (stream_get_left(s) < 12)\n\t\t\treturn FALSE;\n\n\t\tstream_read_UINT16(s, len); /* 0x10 */\n\t\tstream_read_BYTE(s, version); /* 0x1 */\n\t\tstream_read_BYTE(s, pad);\n\n\t\tsig = s->p;\n\t\tstream_seek(s, 8);\t/* signature */\n\n\t\tlength -= 12;\n\n\t\tif (!security_fips_decrypt(s->p, length, rdp))\n\t\t{\n\t\t\tprintf(\"FATAL: cannot decrypt\\n\");\n\t\t\treturn FALSE; /* TODO */\n\t\t}\n\n\t\tif (!security_fips_check_signature(s->p, length - pad, sig, rdp))\n\t\t{\n\t\t\tprintf(\"FATAL: invalid packet signature\\n\");\n\t\t\treturn FALSE; /* TODO */\n\t\t}\n\n\t\t/* is this what needs adjusting? */\n\t\ts->size -= pad;\n\t\treturn TRUE;\n\t}\n\n\tif (stream_get_left(s) < 8)\n\t\treturn FALSE;\n\n\tstream_read(s, wmac, sizeof(wmac));\n\tlength -= sizeof(wmac);\n\tif (!security_decrypt(s->p, length, rdp))\n\t\treturn FALSE;\n\n\tif (securityFlags & SEC_SECURE_CHECKSUM)\n\t\tsecurity_salted_mac_signature(rdp, s->p, length, FALSE, cmac);\n\telse\n\t\tsecurity_mac_signature(rdp, s->p, length, cmac);\n\n\tif (memcmp(wmac, cmac, sizeof(wmac)) != 0)\n\t{\n\t\tprintf(\"WARNING: invalid packet signature\\n\");\n\t\t/*\n\t\t * Because Standard RDP Security is totally broken,\n\t\t * and cannot protect against MITM, don't treat signature\n\t\t * verification failure as critical. This at least enables\n\t\t * us to work with broken RDP clients and servers that\n\t\t * generate invalid signatures.\n\t\t */\n\t\t//return FALSE;\n\t}\n\n\treturn TRUE;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 285,
    "critical_vars": [
      "eventURLPath",
      "table"
    ],
    "function": "*FindServiceEventURLPath",
    "filename": "pupnp/CVE-2020-13848/CVE-2020-13848_CWE-476_c805c1de1141cb22f74c0d94dd5664bda37398e0_service_table.c.diff",
    "function_code": "service_info *FindServiceEventURLPath(\n\tservice_table *table, const char *eventURLPath)\n{\n\tservice_info *finger = NULL;\n\turi_type parsed_url;\n\turi_type parsed_url_in;\n\n\tif (!table || !eventURLPath) {\n\t\treturn NULL;\n\t}\n\tif (parse_uri(eventURLPath, strlen(eventURLPath), &parsed_url_in) ==\n\t\tHTTP_SUCCESS) {\n\t\tfinger = table->serviceList;\n\t\twhile (finger) {\n\t\t\tif (finger->eventURL) {\n\t\t\t\tif (parse_uri(finger->eventURL,\n\t\t\t\t\t    strlen(finger->eventURL),\n\t\t\t\t\t    &parsed_url) == HTTP_SUCCESS) {\n\t\t\t\t\tif (!token_cmp(&parsed_url.pathquery,\n\t\t\t\t\t\t    &parsed_url_in.pathquery)) {\n\t\t\t\t\t\treturn finger;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinger = finger->next;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 332,
    "critical_vars": [
      "table",
      "controlURLPath"
    ],
    "function": "*FindServiceControlURLPath",
    "filename": "pupnp/CVE-2020-13848/CVE-2020-13848_CWE-476_c805c1de1141cb22f74c0d94dd5664bda37398e0_service_table.c.diff",
    "function_code": "service_info *FindServiceControlURLPath(\n\tservice_table *table, const char *controlURLPath)\n{\n\tservice_info *finger = NULL;\n\turi_type parsed_url;\n\turi_type parsed_url_in;\n\n\tif (!table || !controlURLPath) {\n\t\treturn NULL;\n\t}\n\tif (parse_uri(controlURLPath, strlen(controlURLPath), &parsed_url_in) ==\n\t\tHTTP_SUCCESS) {\n\t\tfinger = table->serviceList;\n\t\twhile (finger) {\n\t\t\tif (finger->controlURL) {\n\t\t\t\tif (parse_uri(finger->controlURL,\n\t\t\t\t\t    strlen(finger->controlURL),\n\t\t\t\t\t    &parsed_url) == HTTP_SUCCESS) {\n\t\t\t\t\tif (!token_cmp(&parsed_url.pathquery,\n\t\t\t\t\t\t    &parsed_url_in.pathquery)) {\n\t\t\t\t\t\treturn finger;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinger = finger->next;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 1654,
    "critical_vars": [
      "update"
    ],
    "function": "gen_hash",
    "filename": "mruby/CVE-2022-0326/CVE-2022-0326_CWE-476_b611c43a5de061ec21b343967e1b64c45c373d7e_codegen.c.diff",
    "function_code": "gen_hash(codegen_scope *s, node *tree, int val, int limit)\n{\n  int slimit = GEN_VAL_STACK_MAX;\n  if (cursp() >= GEN_LIT_ARY_MAX) slimit = INT16_MAX;\n  int len = 0;\n  mrb_bool update = FALSE;\n\n  while (tree) {\n    if (nint(tree->car->car->car) == NODE_KW_REST_ARGS) {\n      if (len > 0) {\n        pop_n(len*2);\n        if (!update) {\n          genop_2(s, OP_HASH, cursp(), len);\n        }\n        else {\n          pop();\n          genop_2(s, OP_HASHADD, cursp(), len);\n        }\n        push();\n      }\n      codegen(s, tree->car->cdr, val);\n      if (len > 0 || update) {\n        pop(); pop();\n        genop_1(s, OP_HASHCAT, cursp());\n        push();\n      }\n      update = TRUE;\n      len = 0;\n    }\n    else {\n      codegen(s, tree->car->car, val);\n      codegen(s, tree->car->cdr, val);\n      len++;\n    }\n    tree = tree->cdr;\n    if (val && cursp() >= slimit) {\n      pop_n(len*2);\n      if (!update) {\n        genop_2(s, OP_HASH, cursp(), len);\n      }\n      else {\n        pop();\n        genop_2(s, OP_HASHADD, cursp(), len);\n      }\n      push();\n      update = TRUE;\n      len = 0;\n    }\n  }\n  if (update) {\n    if (len > 0) {\n      pop_n(len*2+1);\n      genop_2(s, OP_HASHADD, cursp(), len);\n      push();\n    }\n    return -1;                  /* variable length */\n  }\n  if (update) return -1;\n  return len;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1606,
    "critical_vars": [
      "val"
    ],
    "function": "gen_hash",
    "filename": "mruby/CVE-2022-0481/CVE-2022-0481_CWE-476_ae3c99767a27f5c6c584162e2adc6a5d0eb2c54e_codegen.c.diff",
    "function_code": "gen_hash(codegen_scope *s, node *tree, int val, int limit)\n{\n  int slimit = GEN_VAL_STACK_MAX;\n  if (cursp() >= GEN_LIT_ARY_MAX) slimit = INT16_MAX;\n  int len = 0;\n  mrb_bool update = FALSE;\n\n  while (tree) {\n    if (nint(tree->car->car->car) == NODE_KW_REST_ARGS) {\n      if (len > 0) {\n        pop_n(len*2);\n        if (!update) {\n          genop_2(s, OP_HASH, cursp(), len);\n        }\n        else {\n          pop();\n          genop_2(s, OP_HASHADD, cursp(), len);\n        }\n        push();\n      }\n      codegen(s, tree->car->cdr, val);\n      if (len > 0 || update) {\n        pop(); pop();\n        genop_1(s, OP_HASHCAT, cursp());\n        push();\n      }\n      update = TRUE;\n      len = 0;\n    }\n    else {\n      codegen(s, tree->car->car, val);\n      codegen(s, tree->car->cdr, val);\n      len++;\n    }\n    tree = tree->cdr;\n    if (val && cursp() >= slimit) {\n      pop_n(len*2);\n      if (!update) {\n        genop_2(s, OP_HASH, cursp(), len);\n      }\n      else {\n        pop();\n        genop_2(s, OP_HASHADD, cursp(), len);\n      }\n      push();\n      update = TRUE;\n      len = 0;\n    }\n  }\n  if (update) {\n    if (val && len > 0) {\n      pop_n(len*2+1);\n      genop_2(s, OP_HASHADD, cursp(), len);\n      push();\n    }\n    return -1;                  /* variable length */\n  }\n  return len;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 215,
    "critical_vars": [
      "a->upper"
    ],
    "function": "mrb_proc_copy",
    "filename": "mruby/CVE-2021-4110/CVE-2021-4110_CWE-476_f5e10c5a79a17939af763b1dcf5232ce47e24a34_proc.c.diff",
    "function_code": "mrb_proc_copy(struct RProc *a, struct RProc *b)\n{\n  if (a->body.irep) {\n    /* already initialized proc */\n    return;\n  }\n  a->flags = b->flags;\n  a->body = b->body;\n  if (!MRB_PROC_CFUNC_P(a) && a->body.irep) {\n    mrb_irep_incref(NULL, (mrb_irep*)a->body.irep);\n  }\n  a->upper = b->upper;\n  a->e.env = b->e.env;\n  /* a->e.target_class = a->e.target_class; */\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 212,
    "critical_vars": [
      "a->upper"
    ],
    "function": "mrb_proc_copy",
    "filename": "mruby/CVE-2021-4110/CVE-2021-4110_CWE-476_f5e10c5a79a17939af763b1dcf5232ce47e24a34_proc.c.diff",
    "function_code": "mrb_proc_copy(mrb_state *mrb, struct RProc *a, struct RProc *b)\n{\n  if (a->body.irep) {\n    /* already initialized proc */\n    return;\n  }\n  a->flags = b->flags;\n  a->body = b->body;\n  a->upper = b->upper;\n  if (!MRB_PROC_CFUNC_P(a) && a->body.irep) {\n    mrb_irep_incref(mrb, (mrb_irep*)a->body.irep);\n  }\n  a->e.env = b->e.env;\n  /* a->e.target_class = a->e.target_class; */\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 211,
    "critical_vars": [
      "mrb",
      "len"
    ],
    "function": "fiber_switch",
    "filename": "mruby/CVE-2022-0890/CVE-2022-0890_CWE-476_da48e7dbb20024c198493b8724adae1b842083aa_fiber.c.diff",
    "function_code": "fiber_switch(mrb_state *mrb, mrb_value self, mrb_int len, const mrb_value *a, mrb_bool resume, mrb_bool vmexec)\n{\n  struct mrb_context *c = fiber_check(mrb, self);\n  struct mrb_context *old_c = mrb->c;\n  enum mrb_fiber_state status;\n  mrb_value value;\n\n  fiber_check_cfunc(mrb, c);\n  status = c->status;\n  switch (status) {\n  case MRB_FIBER_TRANSFERRED:\n    if (resume) {\n      mrb_raise(mrb, E_FIBER_ERROR, \"resuming transferred fiber\");\n    }\n    break;\n  case MRB_FIBER_RUNNING:\n  case MRB_FIBER_RESUMED:\n    mrb_raise(mrb, E_FIBER_ERROR, \"double resume\");\n    break;\n  case MRB_FIBER_TERMINATED:\n    mrb_raise(mrb, E_FIBER_ERROR, \"resuming dead fiber\");\n    break;\n  default:\n    break;\n  }\n  old_c->status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED;\n  c->prev = resume ? mrb->c : (c->prev ? c->prev : mrb->root_c);\n  fiber_switch_context(mrb, c);\n  if (status == MRB_FIBER_CREATED) {\n    mrb_value *b, *e;\n\n    if (!c->ci->proc) {\n      mrb_raise(mrb, E_FIBER_ERROR, \"double resume (current)\");\n    }\n    mrb_stack_extend(mrb, len+2); /* for receiver and (optional) block */\n    b = c->stbase+1;\n    e = b + len;\n    while (b<e) {\n      *b++ = *a++;\n    }\n    if (vmexec) {\n      c->ci--;                    /* pop dummy callinfo */\n    }\n    c->cibase->n = len;\n    value = c->stbase[0] = MRB_PROC_ENV(c->cibase->proc)->stack[0];\n  }\n  else {\n    value = fiber_result(mrb, a, len);\n    if (vmexec) {\n      c->ci[1].stack[0] = value;\n    }\n  }\n\n  if (vmexec) {\n    c->vmexec = TRUE;\n    value = mrb_vm_exec(mrb, c->ci->proc, c->ci->pc);\n    mrb->c = old_c;\n  }\n  else {\n    MARK_CONTEXT_MODIFY(c);\n  }\n  return value;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 214,
    "critical_vars": [
      "len"
    ],
    "function": "fiber_switch",
    "filename": "mruby/CVE-2022-0890/CVE-2022-0890_CWE-476_da48e7dbb20024c198493b8724adae1b842083aa_fiber.c.diff",
    "function_code": "fiber_switch(mrb_state *mrb, mrb_value self, mrb_int len, const mrb_value *a, mrb_bool resume, mrb_bool vmexec)\n{\n  struct mrb_context *c = fiber_check(mrb, self);\n  struct mrb_context *old_c = mrb->c;\n  enum mrb_fiber_state status;\n  mrb_value value;\n\n  fiber_check_cfunc(mrb, c);\n  status = c->status;\n  switch (status) {\n  case MRB_FIBER_TRANSFERRED:\n    if (resume) {\n      mrb_raise(mrb, E_FIBER_ERROR, \"resuming transferred fiber\");\n    }\n    break;\n  case MRB_FIBER_RUNNING:\n  case MRB_FIBER_RESUMED:\n    mrb_raise(mrb, E_FIBER_ERROR, \"double resume\");\n    break;\n  case MRB_FIBER_TERMINATED:\n    mrb_raise(mrb, E_FIBER_ERROR, \"resuming dead fiber\");\n    break;\n  default:\n    break;\n  }\n  old_c->status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED;\n  c->prev = resume ? mrb->c : (c->prev ? c->prev : mrb->root_c);\n  fiber_switch_context(mrb, c);\n  if (status == MRB_FIBER_CREATED) {\n    mrb_value *b, *e;\n\n    if (!c->ci->proc) {\n      mrb_raise(mrb, E_FIBER_ERROR, \"double resume (current)\");\n    }\n    if (vmexec) {\n      c->ci--;                    /* pop dummy callinfo */\n    }\n    if (len >= 15) {\n      mrb_stack_extend(mrb, 3);   /* for receiver, args and (optional) block */\n      c->stbase[1] = mrb_ary_new_from_values(mrb, len, a);\n      len = 15;\n    }\n    else {\n      mrb_stack_extend(mrb, len+2); /* for receiver and (optional) block */\n      b = c->stbase+1;\n      e = b + len;\n      while (b<e) {\n        *b++ = *a++;\n      }\n    }\n    c->cibase->n = len;\n    value = c->stbase[0] = MRB_PROC_ENV(c->cibase->proc)->stack[0];\n  }\n  else {\n    value = fiber_result(mrb, a, len);\n    if (vmexec) {\n      c->ci[1].stack[0] = value;\n    }\n  }\n\n  if (vmexec) {\n    c->vmexec = TRUE;\n    value = mrb_vm_exec(mrb, c->ci->proc, c->ci->pc);\n    mrb->c = old_c;\n  }\n  else {\n    MARK_CONTEXT_MODIFY(c);\n  }\n  return value;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 2961,
    "critical_vars": [
      "s",
      "lv",
      "s2->ainfo"
    ],
    "function": "codegen",
    "filename": "mruby/CVE-2022-0632/CVE-2022-0632_CWE-476_44f591aa8f7091e6ca6cb418e428ae6d4ceaf77d_codegen.c.diff",
    "function_code": "codegen(codegen_scope *s, node *tree, int val)\n{\n  int nt;\n  int rlev = s->rlev;\n\n  if (!tree) {\n    if (val) {\n      genop_1(s, OP_LOADNIL, cursp());\n      push();\n    }\n    return;\n  }\n\n  s->rlev++;\n  if (s->rlev > MRB_CODEGEN_LEVEL_MAX) {\n    codegen_error(s, \"too complex expression\");\n  }\n  if (s->irep && s->filename_index != tree->filename_index) {\n    mrb_sym fname = mrb_parser_get_filename(s->parser, s->filename_index);\n    const char *filename = mrb_sym_name_len(s->mrb, fname, NULL);\n\n    mrb_debug_info_append_file(s->mrb, s->irep->debug_info,\n                               filename, s->lines, s->debug_start_pos, s->pc);\n    s->debug_start_pos = s->pc;\n    s->filename_index = tree->filename_index;\n    s->filename_sym = mrb_parser_get_filename(s->parser, tree->filename_index);\n  }\n\n  nt = nint(tree->car);\n  s->lineno = tree->lineno;\n  tree = tree->cdr;\n  switch (nt) {\n  case NODE_BEGIN:\n    if (val && !tree) {\n      genop_1(s, OP_LOADNIL, cursp());\n      push();\n    }\n    while (tree) {\n      codegen(s, tree->car, tree->cdr ? NOVAL : val);\n      tree = tree->cdr;\n    }\n    break;\n\n  case NODE_RESCUE:\n    {\n      int noexc;\n      uint32_t exend, pos1, pos2, tmp;\n      struct loopinfo *lp;\n      int catch_entry, begin, end;\n\n      if (tree->car == NULL) goto exit;\n      lp = loop_push(s, LOOP_BEGIN);\n      lp->pc0 = new_label(s);\n      catch_entry = catch_handler_new(s);\n      begin = s->pc;\n      codegen(s, tree->car, VAL);\n      pop();\n      lp->type = LOOP_RESCUE;\n      end = s->pc;\n      noexc = genjmp_0(s, OP_JMP);\n      catch_handler_set(s, catch_entry, MRB_CATCH_RESCUE, begin, end, s->pc);\n      tree = tree->cdr;\n      exend = JMPLINK_START;\n      pos1 = JMPLINK_START;\n      if (tree->car) {\n        node *n2 = tree->car;\n        int exc = cursp();\n\n        genop_1(s, OP_EXCEPT, exc);\n        push();\n        while (n2) {\n          node *n3 = n2->car;\n          node *n4 = n3->car;\n\n          dispatch(s, pos1);\n          pos2 = JMPLINK_START;\n          do {\n            if (n4 && n4->car && nint(n4->car->car) == NODE_SPLAT) {\n              codegen(s, n4->car, VAL);\n              gen_move(s, cursp(), exc, 0);\n              push_n(2); pop_n(2); /* space for one arg and a block */\n              pop();\n              genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_SYM_2(s->mrb, __case_eqq)), 1);\n            }\n            else {\n              if (n4) {\n                codegen(s, n4->car, VAL);\n              }\n              else {\n                genop_2(s, OP_GETCONST, cursp(), new_sym(s, MRB_SYM_2(s->mrb, StandardError)));\n                push();\n              }\n              pop();\n              genop_2(s, OP_RESCUE, exc, cursp());\n            }\n            tmp = genjmp2(s, OP_JMPIF, cursp(), pos2, val);\n            pos2 = tmp;\n            if (n4) {\n              n4 = n4->cdr;\n            }\n          } while (n4);\n          pos1 = genjmp_0(s, OP_JMP);\n          dispatch_linked(s, pos2);\n\n          pop();\n          if (n3->cdr->car) {\n            gen_assignment(s, n3->cdr->car, NULL, exc, NOVAL);\n          }\n          if (n3->cdr->cdr->car) {\n            codegen(s, n3->cdr->cdr->car, val);\n            if (val) pop();\n          }\n          tmp = genjmp(s, OP_JMP, exend);\n          exend = tmp;\n          n2 = n2->cdr;\n          push();\n        }\n        if (pos1 != JMPLINK_START) {\n          dispatch(s, pos1);\n          genop_1(s, OP_RAISEIF, exc);\n        }\n      }\n      pop();\n      tree = tree->cdr;\n      dispatch(s, noexc);\n      if (tree->car) {\n        codegen(s, tree->car, val);\n      }\n      else if (val) {\n        push();\n      }\n      dispatch_linked(s, exend);\n      loop_pop(s, NOVAL);\n    }\n    break;\n\n  case NODE_ENSURE:\n    if (!tree->cdr || !tree->cdr->cdr ||\n        (nint(tree->cdr->cdr->car) == NODE_BEGIN &&\n         tree->cdr->cdr->cdr)) {\n      int catch_entry, begin, end, target;\n      int idx;\n\n      catch_entry = catch_handler_new(s);\n      begin = s->pc;\n      codegen(s, tree->car, val);\n      end = target = s->pc;\n      push();\n      idx = cursp();\n      genop_1(s, OP_EXCEPT, idx);\n      push();\n      codegen(s, tree->cdr->cdr, NOVAL);\n      pop();\n      genop_1(s, OP_RAISEIF, idx);\n      pop();\n      catch_handler_set(s, catch_entry, MRB_CATCH_ENSURE, begin, end, target);\n    }\n    else {                      /* empty ensure ignored */\n      codegen(s, tree->car, val);\n    }\n    break;\n\n  case NODE_LAMBDA:\n    if (val) {\n      int idx = lambda_body(s, tree, 1);\n\n      genop_2(s, OP_LAMBDA, cursp(), idx);\n      push();\n    }\n    break;\n\n  case NODE_BLOCK:\n    if (val) {\n      int idx = lambda_body(s, tree, 1);\n\n      genop_2(s, OP_BLOCK, cursp(), idx);\n      push();\n    }\n    break;\n\n  case NODE_IF:\n    {\n      uint32_t pos1, pos2;\n      mrb_bool nil_p = FALSE;\n      node *elsepart = tree->cdr->cdr->car;\n\n      if (!tree->car) {\n        codegen(s, elsepart, val);\n        goto exit;\n      }\n      if (true_always(tree->car)) {\n        codegen(s, tree->cdr->car, val);\n        goto exit;\n      }\n      if (false_always(tree->car)) {\n        codegen(s, elsepart, val);\n        goto exit;\n      }\n      if (nint(tree->car->car) == NODE_CALL) {\n        node *n = tree->car->cdr;\n        mrb_sym mid = nsym(n->cdr->car);\n        mrb_sym sym_nil_p = MRB_SYM_Q_2(s->mrb, nil);\n        if (mid == sym_nil_p && n->cdr->cdr->car == NULL) {\n          nil_p = TRUE;\n          codegen(s, n->car, VAL);\n        }\n      }\n      if (!nil_p) {\n        codegen(s, tree->car, VAL);\n      }\n      pop();\n      if (val || tree->cdr->car) {\n        if (nil_p) {\n          pos2 = genjmp2_0(s, OP_JMPNIL, cursp(), val);\n          pos1 = genjmp_0(s, OP_JMP);\n          dispatch(s, pos2);\n        }\n        else {\n          pos1 = genjmp2_0(s, OP_JMPNOT, cursp(), val);\n        }\n        codegen(s, tree->cdr->car, val);\n        if (val) pop();\n        if (elsepart || val) {\n          pos2 = genjmp_0(s, OP_JMP);\n          dispatch(s, pos1);\n          codegen(s, elsepart, val);\n          dispatch(s, pos2);\n        }\n        else {\n          dispatch(s, pos1);\n        }\n      }\n      else {                    /* empty then-part */\n        if (elsepart) {\n          if (nil_p) {\n            pos1 = genjmp2_0(s, OP_JMPNIL, cursp(), val);\n          }\n          else {\n            pos1 = genjmp2_0(s, OP_JMPIF, cursp(), val);\n          }\n          codegen(s, elsepart, val);\n          dispatch(s, pos1);\n        }\n        else if (val && !nil_p) {\n          genop_1(s, OP_LOADNIL, cursp());\n          push();\n        }\n      }\n    }\n    break;\n\n  case NODE_AND:\n    {\n      uint32_t pos;\n\n      if (true_always(tree->car)) {\n        codegen(s, tree->cdr, val);\n        goto exit;\n      }\n      if (false_always(tree->car)) {\n        codegen(s, tree->car, val);\n        goto exit;\n      }\n      codegen(s, tree->car, VAL);\n      pop();\n      pos = genjmp2_0(s, OP_JMPNOT, cursp(), val);\n      codegen(s, tree->cdr, val);\n      dispatch(s, pos);\n    }\n    break;\n\n  case NODE_OR:\n    {\n      uint32_t pos;\n\n      if (true_always(tree->car)) {\n        codegen(s, tree->car, val);\n        goto exit;\n      }\n      if (false_always(tree->car)) {\n        codegen(s, tree->cdr, val);\n        goto exit;\n      }\n      codegen(s, tree->car, VAL);\n      pop();\n      pos = genjmp2_0(s, OP_JMPIF, cursp(), val);\n      codegen(s, tree->cdr, val);\n      dispatch(s, pos);\n    }\n    break;\n\n  case NODE_WHILE:\n  case NODE_UNTIL:\n    {\n      if (true_always(tree->car)) {\n        if (nt == NODE_UNTIL) {\n          if (val) {\n            genop_1(s, OP_LOADNIL, cursp());\n            push();\n          }\n          goto exit;\n        }\n      }\n      else if (false_always(tree->car)) {\n        if (nt == NODE_WHILE) {\n          if (val) {\n            genop_1(s, OP_LOADNIL, cursp());\n            push();\n          }\n          goto exit;\n        }\n      }\n\n      uint32_t pos = JMPLINK_START;\n      struct loopinfo *lp = loop_push(s, LOOP_NORMAL);\n\n      if (!val) lp->reg = -1;\n      lp->pc0 = new_label(s);\n      codegen(s, tree->car, VAL);\n      pop();\n      if (nt == NODE_WHILE) {\n        pos = genjmp2_0(s, OP_JMPNOT, cursp(), NOVAL);\n      }\n      else {\n        pos = genjmp2_0(s, OP_JMPIF, cursp(), NOVAL);\n      }\n      lp->pc1 = new_label(s);\n      codegen(s, tree->cdr, NOVAL);\n      genjmp(s, OP_JMP, lp->pc0);\n      dispatch(s, pos);\n      loop_pop(s, val);\n    }\n    break;\n\n  case NODE_FOR:\n    for_body(s, tree);\n    if (val) push();\n    break;\n\n  case NODE_CASE:\n    {\n      int head = 0;\n      uint32_t pos1, pos2, pos3, tmp;\n      node *n;\n\n      pos3 = JMPLINK_START;\n      if (tree->car) {\n        head = cursp();\n        codegen(s, tree->car, VAL);\n      }\n      tree = tree->cdr;\n      while (tree) {\n        n = tree->car->car;\n        pos1 = pos2 = JMPLINK_START;\n        while (n) {\n          codegen(s, n->car, VAL);\n          if (head) {\n            gen_move(s, cursp(), head, 0);\n            push(); push(); pop(); pop(); pop();\n            if (nint(n->car->car) == NODE_SPLAT) {\n              genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_SYM_2(s->mrb, __case_eqq)), 1);\n            }\n            else {\n              genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_OPSYM_2(s->mrb, eqq)), 1);\n            }\n          }\n          else {\n            pop();\n          }\n          tmp = genjmp2(s, OP_JMPIF, cursp(), pos2, NOVAL);\n          pos2 = tmp;\n          n = n->cdr;\n        }\n        if (tree->car->car) {\n          pos1 = genjmp_0(s, OP_JMP);\n          dispatch_linked(s, pos2);\n        }\n        codegen(s, tree->car->cdr, val);\n        if (val) pop();\n        tmp = genjmp(s, OP_JMP, pos3);\n        pos3 = tmp;\n        dispatch(s, pos1);\n        tree = tree->cdr;\n      }\n      if (val) {\n        uint32_t pos = cursp();\n        genop_1(s, OP_LOADNIL, cursp());\n        if (pos3 != JMPLINK_START) dispatch_linked(s, pos3);\n        if (head) pop();\n        if (cursp() != pos) {\n          gen_move(s, cursp(), pos, 0);\n        }\n        push();\n      }\n      else {\n        if (pos3 != JMPLINK_START) {\n          dispatch_linked(s, pos3);\n        }\n        if (head) {\n          pop();\n        }\n      }\n    }\n    break;\n\n  case NODE_SCOPE:\n    scope_body(s, tree, NOVAL);\n    break;\n\n  case NODE_FCALL:\n  case NODE_CALL:\n    gen_call(s, tree, val, 0);\n    break;\n  case NODE_SCALL:\n    gen_call(s, tree, val, 1);\n    break;\n\n  case NODE_DOT2:\n    codegen(s, tree->car, val);\n    codegen(s, tree->cdr, val);\n    if (val) {\n      pop(); pop();\n      genop_1(s, OP_RANGE_INC, cursp());\n      push();\n    }\n    break;\n\n  case NODE_DOT3:\n    codegen(s, tree->car, val);\n    codegen(s, tree->cdr, val);\n    if (val) {\n      pop(); pop();\n      genop_1(s, OP_RANGE_EXC, cursp());\n      push();\n    }\n    break;\n\n  case NODE_COLON2:\n    {\n      int sym = new_sym(s, nsym(tree->cdr));\n\n      codegen(s, tree->car, VAL);\n      pop();\n      genop_2(s, OP_GETMCNST, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_COLON3:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_1(s, OP_OCLASS, cursp());\n      genop_2(s, OP_GETMCNST, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_ARRAY:\n    {\n      int n;\n\n      n = gen_values(s, tree, val, 0);\n      if (val) {\n        if (n >= 0) {\n          pop_n(n);\n          genop_2(s, OP_ARRAY, cursp(), n);\n        }\n        push();\n      }\n    }\n    break;\n\n  case NODE_HASH:\n  case NODE_KW_HASH:\n    {\n      int nk = gen_hash(s, tree, val, GEN_LIT_ARY_MAX);\n      if (val && nk >= 0) {\n        pop_n(nk*2);\n        genop_2(s, OP_HASH, cursp(), nk);\n        push();\n      }\n    }\n    break;\n\n  case NODE_SPLAT:\n    codegen(s, tree, val);\n    break;\n\n  case NODE_ASGN:\n    gen_assignment(s, tree->car, tree->cdr, 0, val);\n    break;\n\n  case NODE_MASGN:\n    {\n      int len = 0, n = 0, post = 0;\n      node *t = tree->cdr, *p;\n      int rhs = cursp();\n\n      if (nint(t->car) == NODE_ARRAY && t->cdr && nosplat(t->cdr)) {\n        /* fixed rhs */\n        t = t->cdr;\n        while (t) {\n          codegen(s, t->car, VAL);\n          len++;\n          t = t->cdr;\n        }\n        tree = tree->car;\n        if (tree->car) {                /* pre */\n          t = tree->car;\n          n = 0;\n          while (t) {\n            if (n < len) {\n              gen_assignment(s, t->car, NULL, rhs+n, NOVAL);\n              n++;\n            }\n            else {\n              genop_1(s, OP_LOADNIL, rhs+n);\n              gen_assignment(s, t->car, NULL, rhs+n, NOVAL);\n            }\n            t = t->cdr;\n          }\n        }\n        t = tree->cdr;\n        if (t) {\n          if (t->cdr) {         /* post count */\n            p = t->cdr->car;\n            while (p) {\n              post++;\n              p = p->cdr;\n            }\n          }\n          if (t->car) {         /* rest (len - pre - post) */\n            int rn;\n\n            if (len < post + n) {\n              rn = 0;\n            }\n            else {\n              rn = len - post - n;\n            }\n            genop_3(s, OP_ARRAY2, cursp(), rhs+n, rn);\n            gen_assignment(s, t->car, NULL, cursp(), NOVAL);\n            n += rn;\n          }\n          if (t->cdr && t->cdr->car) {\n            t = t->cdr->car;\n            while (n<len) {\n              gen_assignment(s, t->car, NULL, rhs+n, NOVAL);\n              t = t->cdr;\n              n++;\n            }\n          }\n        }\n        pop_n(len);\n        if (val) {\n          genop_2(s, OP_ARRAY, rhs, len);\n          push();\n        }\n      }\n      else {\n        /* variable rhs */\n        codegen(s, t, VAL);\n        gen_vmassignment(s, tree->car, rhs, val);\n        if (!val) {\n          pop();\n        }\n      }\n    }\n    break;\n\n  case NODE_OP_ASGN:\n    {\n      mrb_sym sym = nsym(tree->cdr->car);\n      mrb_int len;\n      const char *name = mrb_sym_name_len(s->mrb, sym, &len);\n      int idx, callargs = -1, vsp = -1;\n\n      if ((len == 2 && name[0] == '|' && name[1] == '|') &&\n          (nint(tree->car->car) == NODE_CONST ||\n           nint(tree->car->car) == NODE_CVAR)) {\n        int catch_entry, begin, end;\n        int noexc, exc;\n        struct loopinfo *lp;\n\n        lp = loop_push(s, LOOP_BEGIN);\n        lp->pc0 = new_label(s);\n        catch_entry = catch_handler_new(s);\n        begin = s->pc;\n        exc = cursp();\n        codegen(s, tree->car, VAL);\n        end = s->pc;\n        noexc = genjmp_0(s, OP_JMP);\n        lp->type = LOOP_RESCUE;\n        catch_handler_set(s, catch_entry, MRB_CATCH_RESCUE, begin, end, s->pc);\n        genop_1(s, OP_EXCEPT, exc);\n        genop_1(s, OP_LOADF, exc);\n        dispatch(s, noexc);\n        loop_pop(s, NOVAL);\n      }\n      else if (nint(tree->car->car) == NODE_CALL) {\n        node *n = tree->car->cdr;\n        int base, i, nargs = 0;\n        callargs = 0;\n\n        if (val) {\n          vsp = cursp();\n          push();\n        }\n        codegen(s, n->car, VAL);   /* receiver */\n        idx = new_sym(s, nsym(n->cdr->car));\n        base = cursp()-1;\n        if (n->cdr->cdr->car) {\n          nargs = gen_values(s, n->cdr->cdr->car->car, VAL, 13);\n          if (nargs >= 0) {\n            callargs = nargs;\n          }\n          else { /* varargs */\n            push();\n            nargs = 1;\n            callargs = CALL_MAXARGS;\n          }\n        }\n        /* copy receiver and arguments */\n        gen_move(s, cursp(), base, 1);\n        for (i=0; i<nargs; i++) {\n          gen_move(s, cursp()+i+1, base+i+1, 1);\n        }\n        push_n(nargs+2);pop_n(nargs+2); /* space for receiver, arguments and a block */\n        genop_3(s, OP_SEND, cursp(), idx, callargs);\n        push();\n      }\n      else {\n        codegen(s, tree->car, VAL);\n      }\n      if (len == 2 &&\n          ((name[0] == '|' && name[1] == '|') ||\n           (name[0] == '&' && name[1] == '&'))) {\n        uint32_t pos;\n\n        pop();\n        if (val) {\n          if (vsp >= 0) {\n            gen_move(s, vsp, cursp(), 1);\n          }\n          pos = genjmp2_0(s, name[0]=='|'?OP_JMPIF:OP_JMPNOT, cursp(), val);\n        }\n        else {\n          pos = genjmp2_0(s, name[0]=='|'?OP_JMPIF:OP_JMPNOT, cursp(), val);\n        }\n        codegen(s, tree->cdr->cdr->car, VAL);\n        pop();\n        if (val && vsp >= 0) {\n          gen_move(s, vsp, cursp(), 1);\n        }\n        if (nint(tree->car->car) == NODE_CALL) {\n          if (callargs == CALL_MAXARGS) {\n            pop();\n            genop_2(s, OP_ARYPUSH, cursp(), 1);\n          }\n          else {\n            pop_n(callargs);\n            callargs++;\n          }\n          pop();\n          idx = new_sym(s, attrsym(s, nsym(tree->car->cdr->cdr->car)));\n          genop_3(s, OP_SEND, cursp(), idx, callargs);\n        }\n        else {\n          gen_assignment(s, tree->car, NULL, cursp(), val);\n        }\n        dispatch(s, pos);\n        goto exit;\n      }\n      codegen(s, tree->cdr->cdr->car, VAL);\n      push(); pop();\n      pop(); pop();\n\n      if (len == 1 && name[0] == '+')  {\n        gen_addsub(s, OP_ADD, cursp());\n      }\n      else if (len == 1 && name[0] == '-')  {\n        gen_addsub(s, OP_SUB, cursp());\n      }\n      else if (len == 1 && name[0] == '*')  {\n        genop_1(s, OP_MUL, cursp());\n      }\n      else if (len == 1 && name[0] == '/')  {\n        genop_1(s, OP_DIV, cursp());\n      }\n      else if (len == 1 && name[0] == '<')  {\n        genop_1(s, OP_LT, cursp());\n      }\n      else if (len == 2 && name[0] == '<' && name[1] == '=')  {\n        genop_1(s, OP_LE, cursp());\n      }\n      else if (len == 1 && name[0] == '>')  {\n        genop_1(s, OP_GT, cursp());\n      }\n      else if (len == 2 && name[0] == '>' && name[1] == '=')  {\n        genop_1(s, OP_GE, cursp());\n      }\n      else {\n        idx = new_sym(s, sym);\n        genop_3(s, OP_SEND, cursp(), idx, 1);\n      }\n      if (callargs < 0) {\n        gen_assignment(s, tree->car, NULL, cursp(), val);\n      }\n      else {\n        if (val && vsp >= 0) {\n          gen_move(s, vsp, cursp(), 0);\n        }\n        if (callargs == CALL_MAXARGS) {\n          pop();\n          genop_2(s, OP_ARYPUSH, cursp(), 1);\n        }\n        else {\n          pop_n(callargs);\n          callargs++;\n        }\n        pop();\n        idx = new_sym(s, attrsym(s,nsym(tree->car->cdr->cdr->car)));\n        genop_3(s, OP_SEND, cursp(), idx, callargs);\n      }\n    }\n    break;\n\n  case NODE_SUPER:\n    {\n      codegen_scope *s2 = s;\n      int lv = 0;\n      int n = 0, nk = 0, st = 0;\n\n      push();\n      while (!s2->mscope) {\n        lv++;\n        s2 = s2->prev;\n        if (!s2) break;\n      }\n      if (tree) {\n        node *args = tree->car;\n        if (args) {\n          st = n = gen_values(s, args, VAL, 14);\n          if (n < 0) {\n            st = 1; n = 15;\n            push();\n          }\n        }\n        /* keyword arguments */\n        if (s2 && (s2->ainfo & 0x1) && tree->cdr->car) {\n          nk = gen_hash(s, tree->cdr->car->cdr, VAL, 14);\n          if (nk < 0) {st++; nk = 15;}\n          else st += nk*2;\n          n |= nk<<4;\n        }\n        /* block arguments */\n        if (tree->cdr->cdr) {\n          codegen(s, tree->cdr->cdr, VAL);\n        }\n        else if (!s2) {/* super at top-level */\n          push();      /* no need to push block */\n        }\n        else {\n          gen_blkmove(s, s2->ainfo, lv);\n        }\n        st++;\n      }\n      else {\n        if (!s2) push();\n        else gen_blkmove(s, s2->ainfo, lv);\n        st++;\n      }\n      pop_n(st+1);\n      genop_2(s, OP_SUPER, cursp(), n);\n      if (val) push();\n    }\n    break;\n\n  case NODE_ZSUPER:\n    {\n      codegen_scope *s2 = s;\n      int lv = 0;\n      uint16_t ainfo = 0;\n      int n = CALL_MAXARGS;\n      int sp = cursp();\n\n      push();        /* room for receiver */\n      while (!s2->mscope) {\n        lv++;\n        s2 = s2->prev;\n        if (!s2) break;\n      }\n      if (s2 && s2->ainfo > 0) {\n        ainfo = s2->ainfo;\n      }\n      if (ainfo > 0) {\n        genop_2S(s, OP_ARGARY, cursp(), (ainfo<<4)|(lv & 0xf));\n        push(); push(); push();   /* ARGARY pushes 3 values at most */\n        pop(); pop(); pop();\n        /* keyword arguments */\n        if (ainfo & 0x1) {\n          n |= CALL_MAXARGS<<4;\n          push();\n        }\n        /* block argument */\n        if (tree && tree->cdr && tree->cdr->cdr) {\n          push();\n          codegen(s, tree->cdr->cdr, VAL);\n        }\n      }\n      else {\n        /* block argument */\n        if (tree && tree->cdr && tree->cdr->cdr) {\n          codegen(s, tree->cdr->cdr, VAL);\n        }\n        else {\n          gen_blkmove(s, 0, lv);\n        }\n        n = 0;\n      }\n      s->sp = sp;\n      genop_2(s, OP_SUPER, cursp(), n);\n      if (val) push();\n    }\n    break;\n\n  case NODE_RETURN:\n    if (tree) {\n      gen_retval(s, tree);\n    }\n    else {\n      genop_1(s, OP_LOADNIL, cursp());\n    }\n    if (s->loop) {\n      gen_return(s, OP_RETURN_BLK, cursp());\n    }\n    else {\n      gen_return(s, OP_RETURN, cursp());\n    }\n    if (val) push();\n    break;\n\n  case NODE_YIELD:\n    {\n      codegen_scope *s2 = s;\n      int lv = 0, ainfo = -1;\n      int n = 0, sendv = 0;\n\n      while (!s2->mscope) {\n        lv++;\n        s2 = s2->prev;\n        if (!s2) break;\n      }\n      if (s2) {\n        ainfo = (int)s2->ainfo;\n      }\n      if (ainfo < 0) codegen_error(s, \"invalid yield (SyntaxError)\");\n      push();\n      if (tree) {\n        n = gen_values(s, tree, VAL, 14);\n        if (n < 0) {\n          n = sendv = 1;\n          push();\n        }\n      }\n      push();pop(); /* space for a block */\n      pop_n(n+1);\n      genop_2S(s, OP_BLKPUSH, cursp(), (ainfo<<4)|(lv & 0xf));\n      if (sendv) n = CALL_MAXARGS;\n      genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_SYM_2(s->mrb, call)), n);\n      if (val) push();\n    }\n    break;\n\n  case NODE_BREAK:\n    loop_break(s, tree);\n    if (val) push();\n    break;\n\n  case NODE_NEXT:\n    if (!s->loop) {\n      raise_error(s, \"unexpected next\");\n    }\n    else if (s->loop->type == LOOP_NORMAL) {\n      codegen(s, tree, NOVAL);\n      genjmp(s, OP_JMPUW, s->loop->pc0);\n    }\n    else {\n      if (tree) {\n        codegen(s, tree, VAL);\n        pop();\n      }\n      else {\n        genop_1(s, OP_LOADNIL, cursp());\n      }\n      gen_return(s, OP_RETURN, cursp());\n    }\n    if (val) push();\n    break;\n\n  case NODE_REDO:\n    if (!s->loop || s->loop->type == LOOP_BEGIN || s->loop->type == LOOP_RESCUE) {\n      raise_error(s, \"unexpected redo\");\n    }\n    else {\n      genjmp(s, OP_JMPUW, s->loop->pc1);\n    }\n    if (val) push();\n    break;\n\n  case NODE_RETRY:\n    {\n      const char *msg = \"unexpected retry\";\n      const struct loopinfo *lp = s->loop;\n\n      while (lp && lp->type != LOOP_RESCUE) {\n        lp = lp->prev;\n      }\n      if (!lp) {\n        raise_error(s, msg);\n      }\n      else {\n        genjmp(s, OP_JMPUW, lp->pc0);\n      }\n      if (val) push();\n    }\n    break;\n\n  case NODE_LVAR:\n    if (val) {\n      int idx = lv_idx(s, nsym(tree));\n\n      if (idx > 0) {\n        gen_move(s, cursp(), idx, val);\n      }\n      else {\n        gen_getupvar(s, cursp(), nsym(tree));\n      }\n      push();\n    }\n    break;\n\n  case NODE_NVAR:\n    if (val) {\n      int idx = nint(tree);\n\n      gen_move(s, cursp(), idx, val);\n\n      push();\n    }\n    break;\n\n  case NODE_GVAR:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_GETGV, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_IVAR:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_GETIV, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_CVAR:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_GETCV, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_CONST:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_GETCONST, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_BACK_REF:\n    if (val) {\n      char buf[] = {'$', nchar(tree)};\n      int sym = new_sym(s, mrb_intern(s->mrb, buf, sizeof(buf)));\n\n      genop_2(s, OP_GETGV, cursp(), sym);\n      push();\n    }\n    break;\n\n  case NODE_NTH_REF:\n    if (val) {\n      mrb_state *mrb = s->mrb;\n      mrb_value str;\n      int sym;\n\n      str = mrb_format(mrb, \"$%d\", nint(tree));\n      sym = new_sym(s, mrb_intern_str(mrb, str));\n      genop_2(s, OP_GETGV, cursp(), sym);\n      push();\n    }\n    break;\n\n  case NODE_ARG:\n    /* should not happen */\n    break;\n\n  case NODE_BLOCK_ARG:\n    if (!tree) {\n      int idx = lv_idx(s, MRB_OPSYM_2(s->mrb, and));\n\n      if (idx == 0) {\n        codegen_error(s, \"no anonymous block argument\");\n      }\n      gen_move(s, cursp(), idx, val);\n    }\n    else {\n      codegen(s, tree, val);\n    }\n    break;\n\n  case NODE_INT:\n    if (val) {\n      char *p = (char*)tree->car;\n      int base = nint(tree->cdr->car);\n      mrb_int i;\n      mrb_bool overflow;\n\n      i = readint(s, p, base, FALSE, &overflow);\n      if (overflow) {\n        int off = new_litbn(s, p, base, FALSE);\n        genop_2(s, OP_LOADL, cursp(), off);\n      }\n      else {\n        gen_int(s, cursp(), i);\n      }\n      push();\n    }\n    break;\n\n#ifndef MRB_NO_FLOAT\n  case NODE_FLOAT:\n    if (val) {\n      char *p = (char*)tree;\n      mrb_float f = mrb_float_read(p, NULL);\n      int off = new_lit(s, mrb_float_value(s->mrb, f));\n\n      genop_2(s, OP_LOADL, cursp(), off);\n      push();\n    }\n    break;\n#endif\n\n  case NODE_NEGATE:\n    {\n      nt = nint(tree->car);\n      switch (nt) {\n#ifndef MRB_NO_FLOAT\n      case NODE_FLOAT:\n        if (val) {\n          char *p = (char*)tree->cdr;\n          mrb_float f = mrb_float_read(p, NULL);\n          int off = new_lit(s, mrb_float_value(s->mrb, -f));\n\n          genop_2(s, OP_LOADL, cursp(), off);\n          push();\n        }\n        break;\n#endif\n\n      case NODE_INT:\n        if (val) {\n          char *p = (char*)tree->cdr->car;\n          int base = nint(tree->cdr->cdr->car);\n          mrb_int i;\n          mrb_bool overflow;\n\n          i = readint(s, p, base, TRUE, &overflow);\n          if (overflow) {\n            int off = new_litbn(s, p, base, TRUE);\n            genop_2(s, OP_LOADL, cursp(), off);\n          }\n          else {\n            gen_int(s, cursp(), i);\n          }\n          push();\n        }\n        break;\n\n      default:\n        if (val) {\n          codegen(s, tree, VAL);\n          pop();\n          push_n(2);pop_n(2); /* space for receiver&block */\n          mrb_sym minus = MRB_OPSYM_2(s->mrb, minus);\n          if (!gen_uniop(s, minus, cursp())) {\n            genop_3(s, OP_SEND, cursp(), new_sym(s, minus), 0);\n          }\n          push();\n        }\n        else {\n          codegen(s, tree, NOVAL);\n        }\n        break;\n      }\n    }\n    break;\n\n  case NODE_STR:\n    if (val) {\n      char *p = (char*)tree->car;\n      size_t len = (intptr_t)tree->cdr;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int off = new_lit(s, mrb_str_new(s->mrb, p, len));\n\n      mrb_gc_arena_restore(s->mrb, ai);\n      genop_2(s, OP_STRING, cursp(), off);\n      push();\n    }\n    break;\n\n  case NODE_HEREDOC:\n    tree = ((struct mrb_parser_heredoc_info *)tree)->doc;\n    /* fall through */\n  case NODE_DSTR:\n    if (val) {\n      node *n = tree;\n\n      if (!n) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n        break;\n      }\n      codegen(s, n->car, VAL);\n      n = n->cdr;\n      while (n) {\n        codegen(s, n->car, VAL);\n        pop(); pop();\n        genop_1(s, OP_STRCAT, cursp());\n        push();\n        n = n->cdr;\n      }\n    }\n    else {\n      node *n = tree;\n\n      while (n) {\n        if (nint(n->car->car) != NODE_STR) {\n          codegen(s, n->car, NOVAL);\n        }\n        n = n->cdr;\n      }\n    }\n    break;\n\n  case NODE_WORDS:\n    gen_literal_array(s, tree, FALSE, val);\n    break;\n\n  case NODE_SYMBOLS:\n    gen_literal_array(s, tree, TRUE, val);\n    break;\n\n  case NODE_DXSTR:\n    {\n      node *n;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int sym = new_sym(s, MRB_SYM_2(s->mrb, Kernel));\n\n      genop_1(s, OP_LOADSELF, cursp());\n      push();\n      codegen(s, tree->car, VAL);\n      n = tree->cdr;\n      while (n) {\n        if (nint(n->car->car) == NODE_XSTR) {\n          n->car->car = (struct mrb_ast_node*)(intptr_t)NODE_STR;\n          mrb_assert(!n->cdr); /* must be the end */\n        }\n        codegen(s, n->car, VAL);\n        pop(); pop();\n        genop_1(s, OP_STRCAT, cursp());\n        push();\n        n = n->cdr;\n      }\n      push();                   /* for block */\n      pop_n(3);\n      sym = new_sym(s, MRB_OPSYM_2(s->mrb, tick)); /* ` */\n      genop_3(s, OP_SEND, cursp(), sym, 1);\n      if (val) push();\n      mrb_gc_arena_restore(s->mrb, ai);\n    }\n    break;\n\n  case NODE_XSTR:\n    {\n      char *p = (char*)tree->car;\n      size_t len = (intptr_t)tree->cdr;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int off = new_lit(s, mrb_str_new(s->mrb, p, len));\n      int sym;\n\n      genop_1(s, OP_LOADSELF, cursp());\n      push();\n      genop_2(s, OP_STRING, cursp(), off);\n      push(); push();\n      pop_n(3);\n      sym = new_sym(s, MRB_OPSYM_2(s->mrb, tick)); /* ` */\n      genop_3(s, OP_SEND, cursp(), sym, 1);\n      if (val) push();\n      mrb_gc_arena_restore(s->mrb, ai);\n    }\n    break;\n\n  case NODE_REGX:\n    if (val) {\n      char *p1 = (char*)tree->car;\n      char *p2 = (char*)tree->cdr->car;\n      char *p3 = (char*)tree->cdr->cdr;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int sym = new_sym(s, mrb_intern_lit(s->mrb, REGEXP_CLASS));\n      int off = new_lit(s, mrb_str_new_cstr(s->mrb, p1));\n      int argc = 1;\n\n      genop_1(s, OP_OCLASS, cursp());\n      genop_2(s, OP_GETMCNST, cursp(), sym);\n      push();\n      genop_2(s, OP_STRING, cursp(), off);\n      push();\n      if (p2 || p3) {\n        if (p2) { /* opt */\n          off = new_lit(s, mrb_str_new_cstr(s->mrb, p2));\n          genop_2(s, OP_STRING, cursp(), off);\n        }\n        else {\n          genop_1(s, OP_LOADNIL, cursp());\n        }\n        push();\n        argc++;\n        if (p3) { /* enc */\n          off = new_lit(s, mrb_str_new(s->mrb, p3, 1));\n          genop_2(s, OP_STRING, cursp(), off);\n          push();\n          argc++;\n        }\n      }\n      push(); /* space for a block */\n      pop_n(argc+2);\n      sym = new_sym(s, MRB_SYM_2(s->mrb, compile));\n      genop_3(s, OP_SEND, cursp(), sym, argc);\n      mrb_gc_arena_restore(s->mrb, ai);\n      push();\n    }\n    break;\n\n  case NODE_DREGX:\n    if (val) {\n      node *n = tree->car;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int sym = new_sym(s, mrb_intern_lit(s->mrb, REGEXP_CLASS));\n      int argc = 1;\n      int off;\n      char *p;\n\n      genop_1(s, OP_OCLASS, cursp());\n      genop_2(s, OP_GETMCNST, cursp(), sym);\n      push();\n      codegen(s, n->car, VAL);\n      n = n->cdr;\n      while (n) {\n        codegen(s, n->car, VAL);\n        pop(); pop();\n        genop_1(s, OP_STRCAT, cursp());\n        push();\n        n = n->cdr;\n      }\n      n = tree->cdr->cdr;\n      if (n->car) { /* tail */\n        p = (char*)n->car;\n        off = new_lit(s, mrb_str_new_cstr(s->mrb, p));\n        codegen(s, tree->car, VAL);\n        genop_2(s, OP_STRING, cursp(), off);\n        pop();\n        genop_1(s, OP_STRCAT, cursp());\n        push();\n      }\n      if (n->cdr->car) { /* opt */\n        char *p2 = (char*)n->cdr->car;\n        off = new_lit(s, mrb_str_new_cstr(s->mrb, p2));\n        genop_2(s, OP_STRING, cursp(), off);\n        push();\n        argc++;\n      }\n      if (n->cdr->cdr) { /* enc */\n        char *p2 = (char*)n->cdr->cdr;\n        off = new_lit(s, mrb_str_new_cstr(s->mrb, p2));\n        genop_2(s, OP_STRING, cursp(), off);\n        push();\n        argc++;\n      }\n      push(); /* space for a block */\n      pop_n(argc+2);\n      sym = new_sym(s, MRB_SYM_2(s->mrb, compile));\n      genop_3(s, OP_SEND, cursp(), sym, argc);\n      mrb_gc_arena_restore(s->mrb, ai);\n      push();\n    }\n    else {\n      node *n = tree->car;\n\n      while (n) {\n        if (nint(n->car->car) != NODE_STR) {\n          codegen(s, n->car, NOVAL);\n        }\n        n = n->cdr;\n      }\n    }\n    break;\n\n  case NODE_SYM:\n    if (val) {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_LOADSYM, cursp(), sym);\n      push();\n    }\n    break;\n\n  case NODE_DSYM:\n    codegen(s, tree, val);\n    if (val) {\n      gen_intern(s);\n    }\n    break;\n\n  case NODE_SELF:\n    if (val) {\n      genop_1(s, OP_LOADSELF, cursp());\n      push();\n    }\n    break;\n\n  case NODE_NIL:\n    if (val) {\n      genop_1(s, OP_LOADNIL, cursp());\n      push();\n    }\n    break;\n\n  case NODE_TRUE:\n    if (val) {\n      genop_1(s, OP_LOADT, cursp());\n      push();\n    }\n    break;\n\n  case NODE_FALSE:\n    if (val) {\n      genop_1(s, OP_LOADF, cursp());\n      push();\n    }\n    break;\n\n  case NODE_ALIAS:\n    {\n      int a = new_sym(s, nsym(tree->car));\n      int b = new_sym(s, nsym(tree->cdr));\n\n      genop_2(s, OP_ALIAS, a, b);\n      if (val) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n    }\n   break;\n\n  case NODE_UNDEF:\n    {\n      node *t = tree;\n\n      while (t) {\n        int symbol = new_sym(s, nsym(t->car));\n        genop_1(s, OP_UNDEF, symbol);\n        t = t->cdr;\n      }\n      if (val) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n    }\n    break;\n\n  case NODE_CLASS:\n    {\n      int idx;\n      node *body;\n\n      if (tree->car->car == (node*)0) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n      else if (tree->car->car == (node*)1) {\n        genop_1(s, OP_OCLASS, cursp());\n        push();\n      }\n      else {\n        codegen(s, tree->car->car, VAL);\n      }\n      if (tree->cdr->car) {\n        codegen(s, tree->cdr->car, VAL);\n      }\n      else {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n      pop(); pop();\n      idx = new_sym(s, nsym(tree->car->cdr));\n      genop_2(s, OP_CLASS, cursp(), idx);\n      body = tree->cdr->cdr->car;\n      if (nint(body->cdr->car) == NODE_BEGIN && body->cdr->cdr == NULL) {\n        genop_1(s, OP_LOADNIL, cursp());\n      }\n      else {\n        idx = scope_body(s, body, val);\n        genop_2(s, OP_EXEC, cursp(), idx);\n      }\n      if (val) {\n        push();\n      }\n    }\n    break;\n\n  case NODE_MODULE:\n    {\n      int idx;\n\n      if (tree->car->car == (node*)0) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n      else if (tree->car->car == (node*)1) {\n        genop_1(s, OP_OCLASS, cursp());\n        push();\n      }\n      else {\n        codegen(s, tree->car->car, VAL);\n      }\n      pop();\n      idx = new_sym(s, nsym(tree->car->cdr));\n      genop_2(s, OP_MODULE, cursp(), idx);\n      if (nint(tree->cdr->car->cdr->car) == NODE_BEGIN &&\n          tree->cdr->car->cdr->cdr == NULL) {\n        genop_1(s, OP_LOADNIL, cursp());\n      }\n      else {\n        idx = scope_body(s, tree->cdr->car, val);\n        genop_2(s, OP_EXEC, cursp(), idx);\n      }\n      if (val) {\n        push();\n      }\n    }\n    break;\n\n  case NODE_SCLASS:\n    {\n      int idx;\n\n      codegen(s, tree->car, VAL);\n      pop();\n      genop_1(s, OP_SCLASS, cursp());\n      if (nint(tree->cdr->car->cdr->car) == NODE_BEGIN &&\n          tree->cdr->car->cdr->cdr == NULL) {\n        genop_1(s, OP_LOADNIL, cursp());\n      }\n      else {\n        idx = scope_body(s, tree->cdr->car, val);\n        genop_2(s, OP_EXEC, cursp(), idx);\n      }\n      if (val) {\n        push();\n      }\n    }\n    break;\n\n  case NODE_DEF:\n    {\n      int sym = new_sym(s, nsym(tree->car));\n      int idx = lambda_body(s, tree->cdr, 0);\n\n      genop_1(s, OP_TCLASS, cursp());\n      push();\n      genop_2(s, OP_METHOD, cursp(), idx);\n      push(); pop();\n      pop();\n      genop_2(s, OP_DEF, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_SDEF:\n    {\n      node *recv = tree->car;\n      int sym = new_sym(s, nsym(tree->cdr->car));\n      int idx = lambda_body(s, tree->cdr->cdr, 0);\n\n      codegen(s, recv, VAL);\n      pop();\n      genop_1(s, OP_SCLASS, cursp());\n      push();\n      genop_2(s, OP_METHOD, cursp(), idx);\n      pop();\n      genop_2(s, OP_DEF, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_POSTEXE:\n    codegen(s, tree, NOVAL);\n    break;\n\n  default:\n    break;\n  }\n exit:\n  s->rlev = rlev;\n}",
    "label": "True"
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 2957,
    "line_new": 2957,
    "critical_vars": [
      "s2"
    ],
    "function": "codegen",
    "filename": "mruby/CVE-2022-0632/CVE-2022-0632_CWE-476_44f591aa8f7091e6ca6cb418e428ae6d4ceaf77d_codegen.c.diff",
    "function_code": "codegen(codegen_scope *s, node *tree, int val)\n{\n  int nt;\n  int rlev = s->rlev;\n\n  if (!tree) {\n    if (val) {\n      genop_1(s, OP_LOADNIL, cursp());\n      push();\n    }\n    return;\n  }\n\n  s->rlev++;\n  if (s->rlev > MRB_CODEGEN_LEVEL_MAX) {\n    codegen_error(s, \"too complex expression\");\n  }\n  if (s->irep && s->filename_index != tree->filename_index) {\n    mrb_sym fname = mrb_parser_get_filename(s->parser, s->filename_index);\n    const char *filename = mrb_sym_name_len(s->mrb, fname, NULL);\n\n    mrb_debug_info_append_file(s->mrb, s->irep->debug_info,\n                               filename, s->lines, s->debug_start_pos, s->pc);\n    s->debug_start_pos = s->pc;\n    s->filename_index = tree->filename_index;\n    s->filename_sym = mrb_parser_get_filename(s->parser, tree->filename_index);\n  }\n\n  nt = nint(tree->car);\n  s->lineno = tree->lineno;\n  tree = tree->cdr;\n  switch (nt) {\n  case NODE_BEGIN:\n    if (val && !tree) {\n      genop_1(s, OP_LOADNIL, cursp());\n      push();\n    }\n    while (tree) {\n      codegen(s, tree->car, tree->cdr ? NOVAL : val);\n      tree = tree->cdr;\n    }\n    break;\n\n  case NODE_RESCUE:\n    {\n      int noexc;\n      uint32_t exend, pos1, pos2, tmp;\n      struct loopinfo *lp;\n      int catch_entry, begin, end;\n\n      if (tree->car == NULL) goto exit;\n      lp = loop_push(s, LOOP_BEGIN);\n      lp->pc0 = new_label(s);\n      catch_entry = catch_handler_new(s);\n      begin = s->pc;\n      codegen(s, tree->car, VAL);\n      pop();\n      lp->type = LOOP_RESCUE;\n      end = s->pc;\n      noexc = genjmp_0(s, OP_JMP);\n      catch_handler_set(s, catch_entry, MRB_CATCH_RESCUE, begin, end, s->pc);\n      tree = tree->cdr;\n      exend = JMPLINK_START;\n      pos1 = JMPLINK_START;\n      if (tree->car) {\n        node *n2 = tree->car;\n        int exc = cursp();\n\n        genop_1(s, OP_EXCEPT, exc);\n        push();\n        while (n2) {\n          node *n3 = n2->car;\n          node *n4 = n3->car;\n\n          dispatch(s, pos1);\n          pos2 = JMPLINK_START;\n          do {\n            if (n4 && n4->car && nint(n4->car->car) == NODE_SPLAT) {\n              codegen(s, n4->car, VAL);\n              gen_move(s, cursp(), exc, 0);\n              push_n(2); pop_n(2); /* space for one arg and a block */\n              pop();\n              genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_SYM_2(s->mrb, __case_eqq)), 1);\n            }\n            else {\n              if (n4) {\n                codegen(s, n4->car, VAL);\n              }\n              else {\n                genop_2(s, OP_GETCONST, cursp(), new_sym(s, MRB_SYM_2(s->mrb, StandardError)));\n                push();\n              }\n              pop();\n              genop_2(s, OP_RESCUE, exc, cursp());\n            }\n            tmp = genjmp2(s, OP_JMPIF, cursp(), pos2, val);\n            pos2 = tmp;\n            if (n4) {\n              n4 = n4->cdr;\n            }\n          } while (n4);\n          pos1 = genjmp_0(s, OP_JMP);\n          dispatch_linked(s, pos2);\n\n          pop();\n          if (n3->cdr->car) {\n            gen_assignment(s, n3->cdr->car, NULL, exc, NOVAL);\n          }\n          if (n3->cdr->cdr->car) {\n            codegen(s, n3->cdr->cdr->car, val);\n            if (val) pop();\n          }\n          tmp = genjmp(s, OP_JMP, exend);\n          exend = tmp;\n          n2 = n2->cdr;\n          push();\n        }\n        if (pos1 != JMPLINK_START) {\n          dispatch(s, pos1);\n          genop_1(s, OP_RAISEIF, exc);\n        }\n      }\n      pop();\n      tree = tree->cdr;\n      dispatch(s, noexc);\n      if (tree->car) {\n        codegen(s, tree->car, val);\n      }\n      else if (val) {\n        push();\n      }\n      dispatch_linked(s, exend);\n      loop_pop(s, NOVAL);\n    }\n    break;\n\n  case NODE_ENSURE:\n    if (!tree->cdr || !tree->cdr->cdr ||\n        (nint(tree->cdr->cdr->car) == NODE_BEGIN &&\n         tree->cdr->cdr->cdr)) {\n      int catch_entry, begin, end, target;\n      int idx;\n\n      catch_entry = catch_handler_new(s);\n      begin = s->pc;\n      codegen(s, tree->car, val);\n      end = target = s->pc;\n      push();\n      idx = cursp();\n      genop_1(s, OP_EXCEPT, idx);\n      push();\n      codegen(s, tree->cdr->cdr, NOVAL);\n      pop();\n      genop_1(s, OP_RAISEIF, idx);\n      pop();\n      catch_handler_set(s, catch_entry, MRB_CATCH_ENSURE, begin, end, target);\n    }\n    else {                      /* empty ensure ignored */\n      codegen(s, tree->car, val);\n    }\n    break;\n\n  case NODE_LAMBDA:\n    if (val) {\n      int idx = lambda_body(s, tree, 1);\n\n      genop_2(s, OP_LAMBDA, cursp(), idx);\n      push();\n    }\n    break;\n\n  case NODE_BLOCK:\n    if (val) {\n      int idx = lambda_body(s, tree, 1);\n\n      genop_2(s, OP_BLOCK, cursp(), idx);\n      push();\n    }\n    break;\n\n  case NODE_IF:\n    {\n      uint32_t pos1, pos2;\n      mrb_bool nil_p = FALSE;\n      node *elsepart = tree->cdr->cdr->car;\n\n      if (!tree->car) {\n        codegen(s, elsepart, val);\n        goto exit;\n      }\n      if (true_always(tree->car)) {\n        codegen(s, tree->cdr->car, val);\n        goto exit;\n      }\n      if (false_always(tree->car)) {\n        codegen(s, elsepart, val);\n        goto exit;\n      }\n      if (nint(tree->car->car) == NODE_CALL) {\n        node *n = tree->car->cdr;\n        mrb_sym mid = nsym(n->cdr->car);\n        mrb_sym sym_nil_p = MRB_SYM_Q_2(s->mrb, nil);\n        if (mid == sym_nil_p && n->cdr->cdr->car == NULL) {\n          nil_p = TRUE;\n          codegen(s, n->car, VAL);\n        }\n      }\n      if (!nil_p) {\n        codegen(s, tree->car, VAL);\n      }\n      pop();\n      if (val || tree->cdr->car) {\n        if (nil_p) {\n          pos2 = genjmp2_0(s, OP_JMPNIL, cursp(), val);\n          pos1 = genjmp_0(s, OP_JMP);\n          dispatch(s, pos2);\n        }\n        else {\n          pos1 = genjmp2_0(s, OP_JMPNOT, cursp(), val);\n        }\n        codegen(s, tree->cdr->car, val);\n        if (val) pop();\n        if (elsepart || val) {\n          pos2 = genjmp_0(s, OP_JMP);\n          dispatch(s, pos1);\n          codegen(s, elsepart, val);\n          dispatch(s, pos2);\n        }\n        else {\n          dispatch(s, pos1);\n        }\n      }\n      else {                    /* empty then-part */\n        if (elsepart) {\n          if (nil_p) {\n            pos1 = genjmp2_0(s, OP_JMPNIL, cursp(), val);\n          }\n          else {\n            pos1 = genjmp2_0(s, OP_JMPIF, cursp(), val);\n          }\n          codegen(s, elsepart, val);\n          dispatch(s, pos1);\n        }\n        else if (val && !nil_p) {\n          genop_1(s, OP_LOADNIL, cursp());\n          push();\n        }\n      }\n    }\n    break;\n\n  case NODE_AND:\n    {\n      uint32_t pos;\n\n      if (true_always(tree->car)) {\n        codegen(s, tree->cdr, val);\n        goto exit;\n      }\n      if (false_always(tree->car)) {\n        codegen(s, tree->car, val);\n        goto exit;\n      }\n      codegen(s, tree->car, VAL);\n      pop();\n      pos = genjmp2_0(s, OP_JMPNOT, cursp(), val);\n      codegen(s, tree->cdr, val);\n      dispatch(s, pos);\n    }\n    break;\n\n  case NODE_OR:\n    {\n      uint32_t pos;\n\n      if (true_always(tree->car)) {\n        codegen(s, tree->car, val);\n        goto exit;\n      }\n      if (false_always(tree->car)) {\n        codegen(s, tree->cdr, val);\n        goto exit;\n      }\n      codegen(s, tree->car, VAL);\n      pop();\n      pos = genjmp2_0(s, OP_JMPIF, cursp(), val);\n      codegen(s, tree->cdr, val);\n      dispatch(s, pos);\n    }\n    break;\n\n  case NODE_WHILE:\n  case NODE_UNTIL:\n    {\n      if (true_always(tree->car)) {\n        if (nt == NODE_UNTIL) {\n          if (val) {\n            genop_1(s, OP_LOADNIL, cursp());\n            push();\n          }\n          goto exit;\n        }\n      }\n      else if (false_always(tree->car)) {\n        if (nt == NODE_WHILE) {\n          if (val) {\n            genop_1(s, OP_LOADNIL, cursp());\n            push();\n          }\n          goto exit;\n        }\n      }\n\n      uint32_t pos = JMPLINK_START;\n      struct loopinfo *lp = loop_push(s, LOOP_NORMAL);\n\n      if (!val) lp->reg = -1;\n      lp->pc0 = new_label(s);\n      codegen(s, tree->car, VAL);\n      pop();\n      if (nt == NODE_WHILE) {\n        pos = genjmp2_0(s, OP_JMPNOT, cursp(), NOVAL);\n      }\n      else {\n        pos = genjmp2_0(s, OP_JMPIF, cursp(), NOVAL);\n      }\n      lp->pc1 = new_label(s);\n      codegen(s, tree->cdr, NOVAL);\n      genjmp(s, OP_JMP, lp->pc0);\n      dispatch(s, pos);\n      loop_pop(s, val);\n    }\n    break;\n\n  case NODE_FOR:\n    for_body(s, tree);\n    if (val) push();\n    break;\n\n  case NODE_CASE:\n    {\n      int head = 0;\n      uint32_t pos1, pos2, pos3, tmp;\n      node *n;\n\n      pos3 = JMPLINK_START;\n      if (tree->car) {\n        head = cursp();\n        codegen(s, tree->car, VAL);\n      }\n      tree = tree->cdr;\n      while (tree) {\n        n = tree->car->car;\n        pos1 = pos2 = JMPLINK_START;\n        while (n) {\n          codegen(s, n->car, VAL);\n          if (head) {\n            gen_move(s, cursp(), head, 0);\n            push(); push(); pop(); pop(); pop();\n            if (nint(n->car->car) == NODE_SPLAT) {\n              genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_SYM_2(s->mrb, __case_eqq)), 1);\n            }\n            else {\n              genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_OPSYM_2(s->mrb, eqq)), 1);\n            }\n          }\n          else {\n            pop();\n          }\n          tmp = genjmp2(s, OP_JMPIF, cursp(), pos2, NOVAL);\n          pos2 = tmp;\n          n = n->cdr;\n        }\n        if (tree->car->car) {\n          pos1 = genjmp_0(s, OP_JMP);\n          dispatch_linked(s, pos2);\n        }\n        codegen(s, tree->car->cdr, val);\n        if (val) pop();\n        tmp = genjmp(s, OP_JMP, pos3);\n        pos3 = tmp;\n        dispatch(s, pos1);\n        tree = tree->cdr;\n      }\n      if (val) {\n        uint32_t pos = cursp();\n        genop_1(s, OP_LOADNIL, cursp());\n        if (pos3 != JMPLINK_START) dispatch_linked(s, pos3);\n        if (head) pop();\n        if (cursp() != pos) {\n          gen_move(s, cursp(), pos, 0);\n        }\n        push();\n      }\n      else {\n        if (pos3 != JMPLINK_START) {\n          dispatch_linked(s, pos3);\n        }\n        if (head) {\n          pop();\n        }\n      }\n    }\n    break;\n\n  case NODE_SCOPE:\n    scope_body(s, tree, NOVAL);\n    break;\n\n  case NODE_FCALL:\n  case NODE_CALL:\n    gen_call(s, tree, val, 0);\n    break;\n  case NODE_SCALL:\n    gen_call(s, tree, val, 1);\n    break;\n\n  case NODE_DOT2:\n    codegen(s, tree->car, val);\n    codegen(s, tree->cdr, val);\n    if (val) {\n      pop(); pop();\n      genop_1(s, OP_RANGE_INC, cursp());\n      push();\n    }\n    break;\n\n  case NODE_DOT3:\n    codegen(s, tree->car, val);\n    codegen(s, tree->cdr, val);\n    if (val) {\n      pop(); pop();\n      genop_1(s, OP_RANGE_EXC, cursp());\n      push();\n    }\n    break;\n\n  case NODE_COLON2:\n    {\n      int sym = new_sym(s, nsym(tree->cdr));\n\n      codegen(s, tree->car, VAL);\n      pop();\n      genop_2(s, OP_GETMCNST, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_COLON3:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_1(s, OP_OCLASS, cursp());\n      genop_2(s, OP_GETMCNST, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_ARRAY:\n    {\n      int n;\n\n      n = gen_values(s, tree, val, 0);\n      if (val) {\n        if (n >= 0) {\n          pop_n(n);\n          genop_2(s, OP_ARRAY, cursp(), n);\n        }\n        push();\n      }\n    }\n    break;\n\n  case NODE_HASH:\n  case NODE_KW_HASH:\n    {\n      int nk = gen_hash(s, tree, val, GEN_LIT_ARY_MAX);\n      if (val && nk >= 0) {\n        pop_n(nk*2);\n        genop_2(s, OP_HASH, cursp(), nk);\n        push();\n      }\n    }\n    break;\n\n  case NODE_SPLAT:\n    codegen(s, tree, val);\n    break;\n\n  case NODE_ASGN:\n    gen_assignment(s, tree->car, tree->cdr, 0, val);\n    break;\n\n  case NODE_MASGN:\n    {\n      int len = 0, n = 0, post = 0;\n      node *t = tree->cdr, *p;\n      int rhs = cursp();\n\n      if (nint(t->car) == NODE_ARRAY && t->cdr && nosplat(t->cdr)) {\n        /* fixed rhs */\n        t = t->cdr;\n        while (t) {\n          codegen(s, t->car, VAL);\n          len++;\n          t = t->cdr;\n        }\n        tree = tree->car;\n        if (tree->car) {                /* pre */\n          t = tree->car;\n          n = 0;\n          while (t) {\n            if (n < len) {\n              gen_assignment(s, t->car, NULL, rhs+n, NOVAL);\n              n++;\n            }\n            else {\n              genop_1(s, OP_LOADNIL, rhs+n);\n              gen_assignment(s, t->car, NULL, rhs+n, NOVAL);\n            }\n            t = t->cdr;\n          }\n        }\n        t = tree->cdr;\n        if (t) {\n          if (t->cdr) {         /* post count */\n            p = t->cdr->car;\n            while (p) {\n              post++;\n              p = p->cdr;\n            }\n          }\n          if (t->car) {         /* rest (len - pre - post) */\n            int rn;\n\n            if (len < post + n) {\n              rn = 0;\n            }\n            else {\n              rn = len - post - n;\n            }\n            genop_3(s, OP_ARRAY2, cursp(), rhs+n, rn);\n            gen_assignment(s, t->car, NULL, cursp(), NOVAL);\n            n += rn;\n          }\n          if (t->cdr && t->cdr->car) {\n            t = t->cdr->car;\n            while (n<len) {\n              gen_assignment(s, t->car, NULL, rhs+n, NOVAL);\n              t = t->cdr;\n              n++;\n            }\n          }\n        }\n        pop_n(len);\n        if (val) {\n          genop_2(s, OP_ARRAY, rhs, len);\n          push();\n        }\n      }\n      else {\n        /* variable rhs */\n        codegen(s, t, VAL);\n        gen_vmassignment(s, tree->car, rhs, val);\n        if (!val) {\n          pop();\n        }\n      }\n    }\n    break;\n\n  case NODE_OP_ASGN:\n    {\n      mrb_sym sym = nsym(tree->cdr->car);\n      mrb_int len;\n      const char *name = mrb_sym_name_len(s->mrb, sym, &len);\n      int idx, callargs = -1, vsp = -1;\n\n      if ((len == 2 && name[0] == '|' && name[1] == '|') &&\n          (nint(tree->car->car) == NODE_CONST ||\n           nint(tree->car->car) == NODE_CVAR)) {\n        int catch_entry, begin, end;\n        int noexc, exc;\n        struct loopinfo *lp;\n\n        lp = loop_push(s, LOOP_BEGIN);\n        lp->pc0 = new_label(s);\n        catch_entry = catch_handler_new(s);\n        begin = s->pc;\n        exc = cursp();\n        codegen(s, tree->car, VAL);\n        end = s->pc;\n        noexc = genjmp_0(s, OP_JMP);\n        lp->type = LOOP_RESCUE;\n        catch_handler_set(s, catch_entry, MRB_CATCH_RESCUE, begin, end, s->pc);\n        genop_1(s, OP_EXCEPT, exc);\n        genop_1(s, OP_LOADF, exc);\n        dispatch(s, noexc);\n        loop_pop(s, NOVAL);\n      }\n      else if (nint(tree->car->car) == NODE_CALL) {\n        node *n = tree->car->cdr;\n        int base, i, nargs = 0;\n        callargs = 0;\n\n        if (val) {\n          vsp = cursp();\n          push();\n        }\n        codegen(s, n->car, VAL);   /* receiver */\n        idx = new_sym(s, nsym(n->cdr->car));\n        base = cursp()-1;\n        if (n->cdr->cdr->car) {\n          nargs = gen_values(s, n->cdr->cdr->car->car, VAL, 13);\n          if (nargs >= 0) {\n            callargs = nargs;\n          }\n          else { /* varargs */\n            push();\n            nargs = 1;\n            callargs = CALL_MAXARGS;\n          }\n        }\n        /* copy receiver and arguments */\n        gen_move(s, cursp(), base, 1);\n        for (i=0; i<nargs; i++) {\n          gen_move(s, cursp()+i+1, base+i+1, 1);\n        }\n        push_n(nargs+2);pop_n(nargs+2); /* space for receiver, arguments and a block */\n        genop_3(s, OP_SEND, cursp(), idx, callargs);\n        push();\n      }\n      else {\n        codegen(s, tree->car, VAL);\n      }\n      if (len == 2 &&\n          ((name[0] == '|' && name[1] == '|') ||\n           (name[0] == '&' && name[1] == '&'))) {\n        uint32_t pos;\n\n        pop();\n        if (val) {\n          if (vsp >= 0) {\n            gen_move(s, vsp, cursp(), 1);\n          }\n          pos = genjmp2_0(s, name[0]=='|'?OP_JMPIF:OP_JMPNOT, cursp(), val);\n        }\n        else {\n          pos = genjmp2_0(s, name[0]=='|'?OP_JMPIF:OP_JMPNOT, cursp(), val);\n        }\n        codegen(s, tree->cdr->cdr->car, VAL);\n        pop();\n        if (val && vsp >= 0) {\n          gen_move(s, vsp, cursp(), 1);\n        }\n        if (nint(tree->car->car) == NODE_CALL) {\n          if (callargs == CALL_MAXARGS) {\n            pop();\n            genop_2(s, OP_ARYPUSH, cursp(), 1);\n          }\n          else {\n            pop_n(callargs);\n            callargs++;\n          }\n          pop();\n          idx = new_sym(s, attrsym(s, nsym(tree->car->cdr->cdr->car)));\n          genop_3(s, OP_SEND, cursp(), idx, callargs);\n        }\n        else {\n          gen_assignment(s, tree->car, NULL, cursp(), val);\n        }\n        dispatch(s, pos);\n        goto exit;\n      }\n      codegen(s, tree->cdr->cdr->car, VAL);\n      push(); pop();\n      pop(); pop();\n\n      if (len == 1 && name[0] == '+')  {\n        gen_addsub(s, OP_ADD, cursp());\n      }\n      else if (len == 1 && name[0] == '-')  {\n        gen_addsub(s, OP_SUB, cursp());\n      }\n      else if (len == 1 && name[0] == '*')  {\n        genop_1(s, OP_MUL, cursp());\n      }\n      else if (len == 1 && name[0] == '/')  {\n        genop_1(s, OP_DIV, cursp());\n      }\n      else if (len == 1 && name[0] == '<')  {\n        genop_1(s, OP_LT, cursp());\n      }\n      else if (len == 2 && name[0] == '<' && name[1] == '=')  {\n        genop_1(s, OP_LE, cursp());\n      }\n      else if (len == 1 && name[0] == '>')  {\n        genop_1(s, OP_GT, cursp());\n      }\n      else if (len == 2 && name[0] == '>' && name[1] == '=')  {\n        genop_1(s, OP_GE, cursp());\n      }\n      else {\n        idx = new_sym(s, sym);\n        genop_3(s, OP_SEND, cursp(), idx, 1);\n      }\n      if (callargs < 0) {\n        gen_assignment(s, tree->car, NULL, cursp(), val);\n      }\n      else {\n        if (val && vsp >= 0) {\n          gen_move(s, vsp, cursp(), 0);\n        }\n        if (callargs == CALL_MAXARGS) {\n          pop();\n          genop_2(s, OP_ARYPUSH, cursp(), 1);\n        }\n        else {\n          pop_n(callargs);\n          callargs++;\n        }\n        pop();\n        idx = new_sym(s, attrsym(s,nsym(tree->car->cdr->cdr->car)));\n        genop_3(s, OP_SEND, cursp(), idx, callargs);\n      }\n    }\n    break;\n\n  case NODE_SUPER:\n    {\n      codegen_scope *s2 = s;\n      int lv = 0;\n      int n = 0, nk = 0, st = 0;\n\n      push();\n      while (!s2->mscope) {\n        lv++;\n        s2 = s2->prev;\n        if (!s2) break;\n      }\n      if (tree) {\n        node *args = tree->car;\n        if (args) {\n          st = n = gen_values(s, args, VAL, 14);\n          if (n < 0) {\n            st = 1; n = 15;\n            push();\n          }\n        }\n        /* keyword arguments */\n        if (s2 && (s2->ainfo & 0x1) && tree->cdr->car) {\n          nk = gen_hash(s, tree->cdr->car->cdr, VAL, 14);\n          if (nk < 0) {st++; nk = 15;}\n          else st += nk*2;\n          n |= nk<<4;\n        }\n        /* block arguments */\n        if (tree->cdr->cdr) {\n          codegen(s, tree->cdr->cdr, VAL);\n        }\n        else if (s2) gen_blkmove(s, s2->ainfo, lv);\n        else {\n          genop_1(s, OP_LOADNIL, cursp());\n          push();\n        }\n      }\n      else {\n        if (s2) gen_blkmove(s, s2->ainfo, lv);\n        else {\n          genop_1(s, OP_LOADNIL, cursp());\n          push();\n        }\n      }\n      st++;\n      pop_n(st+1);\n      genop_2(s, OP_SUPER, cursp(), n);\n      if (val) push();\n    }\n    break;\n\n  case NODE_ZSUPER:\n    {\n      codegen_scope *s2 = s;\n      int lv = 0;\n      uint16_t ainfo = 0;\n      int n = CALL_MAXARGS;\n      int sp = cursp();\n\n      push();        /* room for receiver */\n      while (!s2->mscope) {\n        lv++;\n        s2 = s2->prev;\n        if (!s2) break;\n      }\n      if (s2 && s2->ainfo > 0) {\n        ainfo = s2->ainfo;\n      }\n      if (ainfo > 0) {\n        genop_2S(s, OP_ARGARY, cursp(), (ainfo<<4)|(lv & 0xf));\n        push(); push(); push();   /* ARGARY pushes 3 values at most */\n        pop(); pop(); pop();\n        /* keyword arguments */\n        if (ainfo & 0x1) {\n          n |= CALL_MAXARGS<<4;\n          push();\n        }\n        /* block argument */\n        if (tree && tree->cdr && tree->cdr->cdr) {\n          push();\n          codegen(s, tree->cdr->cdr, VAL);\n        }\n      }\n      else {\n        /* block argument */\n        if (tree && tree->cdr && tree->cdr->cdr) {\n          codegen(s, tree->cdr->cdr, VAL);\n        }\n        else {\n          gen_blkmove(s, 0, lv);\n        }\n        n = 0;\n      }\n      s->sp = sp;\n      genop_2(s, OP_SUPER, cursp(), n);\n      if (val) push();\n    }\n    break;\n\n  case NODE_RETURN:\n    if (tree) {\n      gen_retval(s, tree);\n    }\n    else {\n      genop_1(s, OP_LOADNIL, cursp());\n    }\n    if (s->loop) {\n      gen_return(s, OP_RETURN_BLK, cursp());\n    }\n    else {\n      gen_return(s, OP_RETURN, cursp());\n    }\n    if (val) push();\n    break;\n\n  case NODE_YIELD:\n    {\n      codegen_scope *s2 = s;\n      int lv = 0, ainfo = -1;\n      int n = 0, sendv = 0;\n\n      while (!s2->mscope) {\n        lv++;\n        s2 = s2->prev;\n        if (!s2) break;\n      }\n      if (s2) {\n        ainfo = (int)s2->ainfo;\n      }\n      if (ainfo < 0) codegen_error(s, \"invalid yield (SyntaxError)\");\n      push();\n      if (tree) {\n        n = gen_values(s, tree, VAL, 14);\n        if (n < 0) {\n          n = sendv = 1;\n          push();\n        }\n      }\n      push();pop(); /* space for a block */\n      pop_n(n+1);\n      genop_2S(s, OP_BLKPUSH, cursp(), (ainfo<<4)|(lv & 0xf));\n      if (sendv) n = CALL_MAXARGS;\n      genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_SYM_2(s->mrb, call)), n);\n      if (val) push();\n    }\n    break;\n\n  case NODE_BREAK:\n    loop_break(s, tree);\n    if (val) push();\n    break;\n\n  case NODE_NEXT:\n    if (!s->loop) {\n      raise_error(s, \"unexpected next\");\n    }\n    else if (s->loop->type == LOOP_NORMAL) {\n      codegen(s, tree, NOVAL);\n      genjmp(s, OP_JMPUW, s->loop->pc0);\n    }\n    else {\n      if (tree) {\n        codegen(s, tree, VAL);\n        pop();\n      }\n      else {\n        genop_1(s, OP_LOADNIL, cursp());\n      }\n      gen_return(s, OP_RETURN, cursp());\n    }\n    if (val) push();\n    break;\n\n  case NODE_REDO:\n    if (!s->loop || s->loop->type == LOOP_BEGIN || s->loop->type == LOOP_RESCUE) {\n      raise_error(s, \"unexpected redo\");\n    }\n    else {\n      genjmp(s, OP_JMPUW, s->loop->pc1);\n    }\n    if (val) push();\n    break;\n\n  case NODE_RETRY:\n    {\n      const char *msg = \"unexpected retry\";\n      const struct loopinfo *lp = s->loop;\n\n      while (lp && lp->type != LOOP_RESCUE) {\n        lp = lp->prev;\n      }\n      if (!lp) {\n        raise_error(s, msg);\n      }\n      else {\n        genjmp(s, OP_JMPUW, lp->pc0);\n      }\n      if (val) push();\n    }\n    break;\n\n  case NODE_LVAR:\n    if (val) {\n      int idx = lv_idx(s, nsym(tree));\n\n      if (idx > 0) {\n        gen_move(s, cursp(), idx, val);\n      }\n      else {\n        gen_getupvar(s, cursp(), nsym(tree));\n      }\n      push();\n    }\n    break;\n\n  case NODE_NVAR:\n    if (val) {\n      int idx = nint(tree);\n\n      gen_move(s, cursp(), idx, val);\n\n      push();\n    }\n    break;\n\n  case NODE_GVAR:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_GETGV, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_IVAR:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_GETIV, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_CVAR:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_GETCV, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_CONST:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_GETCONST, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_BACK_REF:\n    if (val) {\n      char buf[] = {'$', nchar(tree)};\n      int sym = new_sym(s, mrb_intern(s->mrb, buf, sizeof(buf)));\n\n      genop_2(s, OP_GETGV, cursp(), sym);\n      push();\n    }\n    break;\n\n  case NODE_NTH_REF:\n    if (val) {\n      mrb_state *mrb = s->mrb;\n      mrb_value str;\n      int sym;\n\n      str = mrb_format(mrb, \"$%d\", nint(tree));\n      sym = new_sym(s, mrb_intern_str(mrb, str));\n      genop_2(s, OP_GETGV, cursp(), sym);\n      push();\n    }\n    break;\n\n  case NODE_ARG:\n    /* should not happen */\n    break;\n\n  case NODE_BLOCK_ARG:\n    if (!tree) {\n      int idx = lv_idx(s, MRB_OPSYM_2(s->mrb, and));\n\n      if (idx == 0) {\n        codegen_error(s, \"no anonymous block argument\");\n      }\n      gen_move(s, cursp(), idx, val);\n      if (val) push();\n    }\n    else {\n      codegen(s, tree, val);\n    }\n    break;\n\n  case NODE_INT:\n    if (val) {\n      char *p = (char*)tree->car;\n      int base = nint(tree->cdr->car);\n      mrb_int i;\n      mrb_bool overflow;\n\n      i = readint(s, p, base, FALSE, &overflow);\n      if (overflow) {\n        int off = new_litbn(s, p, base, FALSE);\n        genop_2(s, OP_LOADL, cursp(), off);\n      }\n      else {\n        gen_int(s, cursp(), i);\n      }\n      push();\n    }\n    break;\n\n#ifndef MRB_NO_FLOAT\n  case NODE_FLOAT:\n    if (val) {\n      char *p = (char*)tree;\n      mrb_float f = mrb_float_read(p, NULL);\n      int off = new_lit(s, mrb_float_value(s->mrb, f));\n\n      genop_2(s, OP_LOADL, cursp(), off);\n      push();\n    }\n    break;\n#endif\n\n  case NODE_NEGATE:\n    {\n      nt = nint(tree->car);\n      switch (nt) {\n#ifndef MRB_NO_FLOAT\n      case NODE_FLOAT:\n        if (val) {\n          char *p = (char*)tree->cdr;\n          mrb_float f = mrb_float_read(p, NULL);\n          int off = new_lit(s, mrb_float_value(s->mrb, -f));\n\n          genop_2(s, OP_LOADL, cursp(), off);\n          push();\n        }\n        break;\n#endif\n\n      case NODE_INT:\n        if (val) {\n          char *p = (char*)tree->cdr->car;\n          int base = nint(tree->cdr->cdr->car);\n          mrb_int i;\n          mrb_bool overflow;\n\n          i = readint(s, p, base, TRUE, &overflow);\n          if (overflow) {\n            int off = new_litbn(s, p, base, TRUE);\n            genop_2(s, OP_LOADL, cursp(), off);\n          }\n          else {\n            gen_int(s, cursp(), i);\n          }\n          push();\n        }\n        break;\n\n      default:\n        if (val) {\n          codegen(s, tree, VAL);\n          pop();\n          push_n(2);pop_n(2); /* space for receiver&block */\n          mrb_sym minus = MRB_OPSYM_2(s->mrb, minus);\n          if (!gen_uniop(s, minus, cursp())) {\n            genop_3(s, OP_SEND, cursp(), new_sym(s, minus), 0);\n          }\n          push();\n        }\n        else {\n          codegen(s, tree, NOVAL);\n        }\n        break;\n      }\n    }\n    break;\n\n  case NODE_STR:\n    if (val) {\n      char *p = (char*)tree->car;\n      size_t len = (intptr_t)tree->cdr;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int off = new_lit(s, mrb_str_new(s->mrb, p, len));\n\n      mrb_gc_arena_restore(s->mrb, ai);\n      genop_2(s, OP_STRING, cursp(), off);\n      push();\n    }\n    break;\n\n  case NODE_HEREDOC:\n    tree = ((struct mrb_parser_heredoc_info *)tree)->doc;\n    /* fall through */\n  case NODE_DSTR:\n    if (val) {\n      node *n = tree;\n\n      if (!n) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n        break;\n      }\n      codegen(s, n->car, VAL);\n      n = n->cdr;\n      while (n) {\n        codegen(s, n->car, VAL);\n        pop(); pop();\n        genop_1(s, OP_STRCAT, cursp());\n        push();\n        n = n->cdr;\n      }\n    }\n    else {\n      node *n = tree;\n\n      while (n) {\n        if (nint(n->car->car) != NODE_STR) {\n          codegen(s, n->car, NOVAL);\n        }\n        n = n->cdr;\n      }\n    }\n    break;\n\n  case NODE_WORDS:\n    gen_literal_array(s, tree, FALSE, val);\n    break;\n\n  case NODE_SYMBOLS:\n    gen_literal_array(s, tree, TRUE, val);\n    break;\n\n  case NODE_DXSTR:\n    {\n      node *n;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int sym = new_sym(s, MRB_SYM_2(s->mrb, Kernel));\n\n      genop_1(s, OP_LOADSELF, cursp());\n      push();\n      codegen(s, tree->car, VAL);\n      n = tree->cdr;\n      while (n) {\n        if (nint(n->car->car) == NODE_XSTR) {\n          n->car->car = (struct mrb_ast_node*)(intptr_t)NODE_STR;\n          mrb_assert(!n->cdr); /* must be the end */\n        }\n        codegen(s, n->car, VAL);\n        pop(); pop();\n        genop_1(s, OP_STRCAT, cursp());\n        push();\n        n = n->cdr;\n      }\n      push();                   /* for block */\n      pop_n(3);\n      sym = new_sym(s, MRB_OPSYM_2(s->mrb, tick)); /* ` */\n      genop_3(s, OP_SEND, cursp(), sym, 1);\n      if (val) push();\n      mrb_gc_arena_restore(s->mrb, ai);\n    }\n    break;\n\n  case NODE_XSTR:\n    {\n      char *p = (char*)tree->car;\n      size_t len = (intptr_t)tree->cdr;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int off = new_lit(s, mrb_str_new(s->mrb, p, len));\n      int sym;\n\n      genop_1(s, OP_LOADSELF, cursp());\n      push();\n      genop_2(s, OP_STRING, cursp(), off);\n      push(); push();\n      pop_n(3);\n      sym = new_sym(s, MRB_OPSYM_2(s->mrb, tick)); /* ` */\n      genop_3(s, OP_SEND, cursp(), sym, 1);\n      if (val) push();\n      mrb_gc_arena_restore(s->mrb, ai);\n    }\n    break;\n\n  case NODE_REGX:\n    if (val) {\n      char *p1 = (char*)tree->car;\n      char *p2 = (char*)tree->cdr->car;\n      char *p3 = (char*)tree->cdr->cdr;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int sym = new_sym(s, mrb_intern_lit(s->mrb, REGEXP_CLASS));\n      int off = new_lit(s, mrb_str_new_cstr(s->mrb, p1));\n      int argc = 1;\n\n      genop_1(s, OP_OCLASS, cursp());\n      genop_2(s, OP_GETMCNST, cursp(), sym);\n      push();\n      genop_2(s, OP_STRING, cursp(), off);\n      push();\n      if (p2 || p3) {\n        if (p2) { /* opt */\n          off = new_lit(s, mrb_str_new_cstr(s->mrb, p2));\n          genop_2(s, OP_STRING, cursp(), off);\n        }\n        else {\n          genop_1(s, OP_LOADNIL, cursp());\n        }\n        push();\n        argc++;\n        if (p3) { /* enc */\n          off = new_lit(s, mrb_str_new(s->mrb, p3, 1));\n          genop_2(s, OP_STRING, cursp(), off);\n          push();\n          argc++;\n        }\n      }\n      push(); /* space for a block */\n      pop_n(argc+2);\n      sym = new_sym(s, MRB_SYM_2(s->mrb, compile));\n      genop_3(s, OP_SEND, cursp(), sym, argc);\n      mrb_gc_arena_restore(s->mrb, ai);\n      push();\n    }\n    break;\n\n  case NODE_DREGX:\n    if (val) {\n      node *n = tree->car;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int sym = new_sym(s, mrb_intern_lit(s->mrb, REGEXP_CLASS));\n      int argc = 1;\n      int off;\n      char *p;\n\n      genop_1(s, OP_OCLASS, cursp());\n      genop_2(s, OP_GETMCNST, cursp(), sym);\n      push();\n      codegen(s, n->car, VAL);\n      n = n->cdr;\n      while (n) {\n        codegen(s, n->car, VAL);\n        pop(); pop();\n        genop_1(s, OP_STRCAT, cursp());\n        push();\n        n = n->cdr;\n      }\n      n = tree->cdr->cdr;\n      if (n->car) { /* tail */\n        p = (char*)n->car;\n        off = new_lit(s, mrb_str_new_cstr(s->mrb, p));\n        codegen(s, tree->car, VAL);\n        genop_2(s, OP_STRING, cursp(), off);\n        pop();\n        genop_1(s, OP_STRCAT, cursp());\n        push();\n      }\n      if (n->cdr->car) { /* opt */\n        char *p2 = (char*)n->cdr->car;\n        off = new_lit(s, mrb_str_new_cstr(s->mrb, p2));\n        genop_2(s, OP_STRING, cursp(), off);\n        push();\n        argc++;\n      }\n      if (n->cdr->cdr) { /* enc */\n        char *p2 = (char*)n->cdr->cdr;\n        off = new_lit(s, mrb_str_new_cstr(s->mrb, p2));\n        genop_2(s, OP_STRING, cursp(), off);\n        push();\n        argc++;\n      }\n      push(); /* space for a block */\n      pop_n(argc+2);\n      sym = new_sym(s, MRB_SYM_2(s->mrb, compile));\n      genop_3(s, OP_SEND, cursp(), sym, argc);\n      mrb_gc_arena_restore(s->mrb, ai);\n      push();\n    }\n    else {\n      node *n = tree->car;\n\n      while (n) {\n        if (nint(n->car->car) != NODE_STR) {\n          codegen(s, n->car, NOVAL);\n        }\n        n = n->cdr;\n      }\n    }\n    break;\n\n  case NODE_SYM:\n    if (val) {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_LOADSYM, cursp(), sym);\n      push();\n    }\n    break;\n\n  case NODE_DSYM:\n    codegen(s, tree, val);\n    if (val) {\n      gen_intern(s);\n    }\n    break;\n\n  case NODE_SELF:\n    if (val) {\n      genop_1(s, OP_LOADSELF, cursp());\n      push();\n    }\n    break;\n\n  case NODE_NIL:\n    if (val) {\n      genop_1(s, OP_LOADNIL, cursp());\n      push();\n    }\n    break;\n\n  case NODE_TRUE:\n    if (val) {\n      genop_1(s, OP_LOADT, cursp());\n      push();\n    }\n    break;\n\n  case NODE_FALSE:\n    if (val) {\n      genop_1(s, OP_LOADF, cursp());\n      push();\n    }\n    break;\n\n  case NODE_ALIAS:\n    {\n      int a = new_sym(s, nsym(tree->car));\n      int b = new_sym(s, nsym(tree->cdr));\n\n      genop_2(s, OP_ALIAS, a, b);\n      if (val) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n    }\n   break;\n\n  case NODE_UNDEF:\n    {\n      node *t = tree;\n\n      while (t) {\n        int symbol = new_sym(s, nsym(t->car));\n        genop_1(s, OP_UNDEF, symbol);\n        t = t->cdr;\n      }\n      if (val) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n    }\n    break;\n\n  case NODE_CLASS:\n    {\n      int idx;\n      node *body;\n\n      if (tree->car->car == (node*)0) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n      else if (tree->car->car == (node*)1) {\n        genop_1(s, OP_OCLASS, cursp());\n        push();\n      }\n      else {\n        codegen(s, tree->car->car, VAL);\n      }\n      if (tree->cdr->car) {\n        codegen(s, tree->cdr->car, VAL);\n      }\n      else {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n      pop(); pop();\n      idx = new_sym(s, nsym(tree->car->cdr));\n      genop_2(s, OP_CLASS, cursp(), idx);\n      body = tree->cdr->cdr->car;\n      if (nint(body->cdr->car) == NODE_BEGIN && body->cdr->cdr == NULL) {\n        genop_1(s, OP_LOADNIL, cursp());\n      }\n      else {\n        idx = scope_body(s, body, val);\n        genop_2(s, OP_EXEC, cursp(), idx);\n      }\n      if (val) {\n        push();\n      }\n    }\n    break;\n\n  case NODE_MODULE:\n    {\n      int idx;\n\n      if (tree->car->car == (node*)0) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n      else if (tree->car->car == (node*)1) {\n        genop_1(s, OP_OCLASS, cursp());\n        push();\n      }\n      else {\n        codegen(s, tree->car->car, VAL);\n      }\n      pop();\n      idx = new_sym(s, nsym(tree->car->cdr));\n      genop_2(s, OP_MODULE, cursp(), idx);\n      if (nint(tree->cdr->car->cdr->car) == NODE_BEGIN &&\n          tree->cdr->car->cdr->cdr == NULL) {\n        genop_1(s, OP_LOADNIL, cursp());\n      }\n      else {\n        idx = scope_body(s, tree->cdr->car, val);\n        genop_2(s, OP_EXEC, cursp(), idx);\n      }\n      if (val) {\n        push();\n      }\n    }\n    break;\n\n  case NODE_SCLASS:\n    {\n      int idx;\n\n      codegen(s, tree->car, VAL);\n      pop();\n      genop_1(s, OP_SCLASS, cursp());\n      if (nint(tree->cdr->car->cdr->car) == NODE_BEGIN &&\n          tree->cdr->car->cdr->cdr == NULL) {\n        genop_1(s, OP_LOADNIL, cursp());\n      }\n      else {\n        idx = scope_body(s, tree->cdr->car, val);\n        genop_2(s, OP_EXEC, cursp(), idx);\n      }\n      if (val) {\n        push();\n      }\n    }\n    break;\n\n  case NODE_DEF:\n    {\n      int sym = new_sym(s, nsym(tree->car));\n      int idx = lambda_body(s, tree->cdr, 0);\n\n      genop_1(s, OP_TCLASS, cursp());\n      push();\n      genop_2(s, OP_METHOD, cursp(), idx);\n      push(); pop();\n      pop();\n      genop_2(s, OP_DEF, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_SDEF:\n    {\n      node *recv = tree->car;\n      int sym = new_sym(s, nsym(tree->cdr->car));\n      int idx = lambda_body(s, tree->cdr->cdr, 0);\n\n      codegen(s, recv, VAL);\n      pop();\n      genop_1(s, OP_SCLASS, cursp());\n      push();\n      genop_2(s, OP_METHOD, cursp(), idx);\n      pop();\n      genop_2(s, OP_DEF, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_POSTEXE:\n    codegen(s, tree, NOVAL);\n    break;\n\n  default:\n    break;\n  }\n exit:\n  s->rlev = rlev;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 143,
    "critical_vars": [
      "result"
    ],
    "function": "AP4_AtomSampleTable::GetSample",
    "filename": "Bento4/CVE-2017-14640/CVE-2017-14640_CWE-476_2f267f89f957088197f4b1fc254632d1645b415d_Ap4AtomSampleTable.cpp.diff",
    "function_code": "AP4_AtomSampleTable::GetSample(AP4_Ordinal index, \n                               AP4_Sample& sample)\n{\n    AP4_Result result;\n\n    // check that we have an stsc atom\n    if (!m_StscAtom) {\n        return AP4_ERROR_INVALID_FORMAT;\n    }\n    \n    // check that we have a chunk offset table\n    if (m_StcoAtom == NULL && m_Co64Atom == NULL) {\n        return AP4_ERROR_INVALID_FORMAT;\n    }\n\n    // MP4 uses 1-based indexes internally, so adjust by one\n    index++;\n\n    // find out in which chunk this sample is located\n    AP4_Ordinal chunk, skip, desc;\n    result = m_StscAtom->GetChunkForSample(index, chunk, skip, desc);\n    if (AP4_FAILED(result)) return result;\n    \n    // check that the result is within bounds\n    if (skip > index) return AP4_ERROR_INTERNAL;\n\n    // get the atom offset for this chunk\n    AP4_UI64 offset;\n    if (m_StcoAtom) {\n        AP4_UI32 offset_32;\n        result = m_StcoAtom->GetChunkOffset(chunk, offset_32);\n        offset = offset_32;\n    } else {\n        result = m_Co64Atom->GetChunkOffset(chunk, offset);\n    }\n    if (AP4_FAILED(result)) return result;\n    \n    // compute the additional offset inside the chunk\n    for (unsigned int i = index-skip; i < index; i++) {\n        AP4_Size size = 0;\n        if (m_StszAtom) {\n            result = m_StszAtom->GetSampleSize(i, size); \n        } else if (m_Stz2Atom) {\n            result = m_Stz2Atom->GetSampleSize(i, size); \n        } else {\n            result = AP4_ERROR_INVALID_FORMAT;\n        }\n        if (AP4_FAILED(result)) return result;\n        offset += size;\n    }\n\n    // set the description index\n    sample.SetDescriptionIndex(desc-1); // adjust for 0-based indexes\n\n    // set the dts and cts\n    AP4_UI32 cts_offset = 0;\n    AP4_UI64 dts        = 0;\n    AP4_UI32 duration   = 0;\n    result = m_SttsAtom->GetDts(index, dts, &duration);\n    if (AP4_FAILED(result)) return result;\n    sample.SetDuration(duration);\n    sample.SetDts(dts);\n    if (m_CttsAtom == NULL) {\n        sample.SetCts(dts);\n    } else {\n        result = m_CttsAtom->GetCtsOffset(index, cts_offset); \n\t    if (AP4_FAILED(result)) return result;\n        sample.SetCtsDelta(cts_offset);\n    }     \n\n    // set the size\n    AP4_Size sample_size = 0;\n    if (m_StszAtom) {\n        result = m_StszAtom->GetSampleSize(index, sample_size); \n    } else if (m_Stz2Atom) {\n        result = m_Stz2Atom->GetSampleSize(index, sample_size); \n    } else {\n        result = AP4_ERROR_INVALID_FORMAT;\n    }\n    if (AP4_FAILED(result)) return result;\n    sample.SetSize(sample_size);\n\n    // set the sync flag\n    if (m_StssAtom == NULL) {\n        sample.SetSync(true);\n    } else {\n        sample.SetSync(m_StssAtom->IsSampleSync(index));\n    }\n\n    // set the offset\n    sample.SetOffset(offset);\n\n    // set the data stream\n    sample.SetDataStream(m_SampleStream);\n\n\n    return AP4_SUCCESS;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 91,
    "critical_vars": [
      "m_StscAtom"
    ],
    "function": "AP4_AtomSampleTable::GetSample",
    "filename": "Bento4/CVE-2017-12476/CVE-2017-12476_CWE-476_4d3f0bebd5f8518fd775f671c12bea58c68e814e_Ap4AtomSampleTable.cpp.diff",
    "function_code": "AP4_AtomSampleTable::GetSample(AP4_Ordinal index, \n                               AP4_Sample& sample)\n{\n    AP4_Result result;\n\n    // check that we have an stsc atom\n    if (!m_StscAtom) {\n        return AP4_ERROR_INVALID_FORMAT;\n    }\n    \n    // check that we have a chunk offset table\n    if (m_StcoAtom == NULL && m_Co64Atom == NULL) {\n        return AP4_ERROR_INVALID_FORMAT;\n    }\n\n    // MP4 uses 1-based indexes internally, so adjust by one\n    index++;\n\n    // find out in which chunk this sample is located\n    AP4_Ordinal chunk, skip, desc;\n    result = m_StscAtom->GetChunkForSample(index, chunk, skip, desc);\n    if (AP4_FAILED(result)) return result;\n    \n    // check that the result is within bounds\n    if (skip > index) return AP4_ERROR_INTERNAL;\n\n    // get the atom offset for this chunk\n    AP4_UI64 offset;\n    if (m_StcoAtom) {\n        AP4_UI32 offset_32;\n        result = m_StcoAtom->GetChunkOffset(chunk, offset_32);\n        offset = offset_32;\n    } else {\n        result = m_Co64Atom->GetChunkOffset(chunk, offset);\n    }\n    if (AP4_FAILED(result)) return result;\n    \n    // compute the additional offset inside the chunk\n    for (unsigned int i = index-skip; i < index; i++) {\n        AP4_Size size = 0;\n        if (m_StszAtom) {\n            result = m_StszAtom->GetSampleSize(i, size); \n        } else if (m_Stz2Atom) {\n            result = m_Stz2Atom->GetSampleSize(i, size); \n        } else {\n            result = AP4_ERROR_INVALID_FORMAT;\n        }\n        if (AP4_FAILED(result)) return result;\n        offset += size;\n    }\n\n    // set the description index\n    sample.SetDescriptionIndex(desc-1); // adjust for 0-based indexes\n\n    // set the dts and cts\n    AP4_UI32 cts_offset = 0;\n    AP4_UI64 dts        = 0;\n    AP4_UI32 duration   = 0;\n    result = m_SttsAtom->GetDts(index, dts, &duration);\n    if (AP4_FAILED(result)) return result;\n    sample.SetDuration(duration);\n    sample.SetDts(dts);\n    if (m_CttsAtom == NULL) {\n        sample.SetCts(dts);\n    } else {\n        result = m_CttsAtom->GetCtsOffset(index, cts_offset); \n\t    if (AP4_FAILED(result)) return result;\n        sample.SetCtsDelta(cts_offset);\n    }     \n\n    // set the size\n    AP4_Size sample_size = 0;\n    if (m_StszAtom) {\n        result = m_StszAtom->GetSampleSize(index, sample_size); \n    } else if (m_Stz2Atom) {\n        result = m_Stz2Atom->GetSampleSize(index, sample_size); \n    } else {\n        result = AP4_ERROR_INVALID_FORMAT;\n    }\n    if (AP4_FAILED(result)) return result;\n    sample.SetSize(sample_size);\n\n    // set the sync flag\n    if (m_StssAtom == NULL) {\n        sample.SetSync(true);\n    } else {\n        sample.SetSync(m_StssAtom->IsSampleSync(index));\n    }\n\n    // set the offset\n    sample.SetOffset(offset);\n\n    // set the data stream\n    sample.SetDataStream(m_SampleStream);\n\n\n    return AP4_SUCCESS;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 83,
    "critical_vars": [
      "name_size"
    ],
    "function": "AP4_HdlrAtom::AP4_HdlrAtom",
    "filename": "Bento4/CVE-2017-14642/CVE-2017-14642_CWE-476_22192de5367fa0cee985917f092be4060b7c00b0_Ap4HdlrAtom.cpp.diff",
    "function_code": "AP4_HdlrAtom::AP4_HdlrAtom(AP4_UI32        size, \n                           AP4_UI08        version,\n                           AP4_UI32        flags,\n                           AP4_ByteStream& stream) :\n    AP4_Atom(AP4_ATOM_TYPE_HDLR, size, version, flags)\n{\n    AP4_UI32 predefined;\n    stream.ReadUI32(predefined);\n    stream.ReadUI32(m_HandlerType);\n    stream.ReadUI32(m_Reserved[0]);\n    stream.ReadUI32(m_Reserved[1]);\n    stream.ReadUI32(m_Reserved[2]);\n    \n    // read the name unless it is empty\n    int name_size = size-(AP4_FULL_ATOM_HEADER_SIZE+20);\n    if (name_size == 0) return;\n    char* name = new char[name_size+1];\n    stream.Read(name, name_size);\n    name[name_size] = '\\0'; // force a null termination\n    // handle a special case: the Quicktime files have a pascal\n    // string here, but ISO MP4 files have a C string.\n    // we try to detect a pascal encoding and correct it.\n    if (name[0] == name_size-1) {\n        m_HandlerName = name+1;\n    } else {\n        m_HandlerName = name;\n    }\n    delete[] name;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 83,
    "critical_vars": [
      "size"
    ],
    "function": "AP4_HdlrAtom::AP4_HdlrAtom",
    "filename": "Bento4/CVE-2017-14642/CVE-2017-14642_CWE-476_22192de5367fa0cee985917f092be4060b7c00b0_Ap4HdlrAtom.cpp.diff",
    "function_code": "AP4_HdlrAtom::AP4_HdlrAtom(AP4_UI32        size, \n                           AP4_UI08        version,\n                           AP4_UI32        flags,\n                           AP4_ByteStream& stream) :\n    AP4_Atom(AP4_ATOM_TYPE_HDLR, size, version, flags)\n{\n    AP4_UI32 predefined;\n    stream.ReadUI32(predefined);\n    stream.ReadUI32(m_HandlerType);\n    stream.ReadUI32(m_Reserved[0]);\n    stream.ReadUI32(m_Reserved[1]);\n    stream.ReadUI32(m_Reserved[2]);\n    \n    // read the name unless it is empty\n    if (size < AP4_FULL_ATOM_HEADER_SIZE+20) return;\n    AP4_UI32 name_size = size-(AP4_FULL_ATOM_HEADER_SIZE+20);\n    char* name = new char[name_size+1];\n    if (name == NULL) return;\n    stream.Read(name, name_size);\n    name[name_size] = '\\0'; // force a null termination\n    // handle a special case: the Quicktime files have a pascal\n    // string here, but ISO MP4 files have a C string.\n    // we try to detect a pascal encoding and correct it.\n    if (name[0] == name_size-1) {\n        m_HandlerName = name+1;\n    } else {\n        m_HandlerName = name;\n    }\n    delete[] name;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 1078,
    "critical_vars": [
      "targetDb"
    ],
    "function": "sqlcipher_exportFunc",
    "filename": "sqlcipher/CVE-2021-3119/CVE-2021-3119_CWE-476_cb71f53e8cea4802509f182fa5bead0ac6ab0e7f_crypto.c.diff",
    "function_code": "void sqlcipher_exportFunc(sqlite3_context *context, int argc, sqlite3_value **argv) {\n  sqlite3 *db = sqlite3_context_db_handle(context);\n  const char* targetDb, *sourceDb; \n  int targetDb_idx = 0;\n  u64 saved_flags = db->flags;        /* Saved value of the db->flags */\n  u32 saved_mDbFlags = db->mDbFlags;        /* Saved value of the db->mDbFlags */\n  int saved_nChange = db->nChange;      /* Saved value of db->nChange */\n  int saved_nTotalChange = db->nTotalChange; /* Saved value of db->nTotalChange */\n  u8 saved_mTrace = db->mTrace;        /* Saved value of db->mTrace */\n  int rc = SQLITE_OK;     /* Return code from service routines */\n  char *zSql = NULL;         /* SQL statements */\n  char *pzErrMsg = NULL;\n\n  if(argc != 1 && argc != 2) {\n    rc = SQLITE_ERROR;\n    pzErrMsg = sqlite3_mprintf(\"invalid number of arguments (%d) passed to sqlcipher_export\", argc);\n    goto end_of_export;\n  }\n\n  targetDb = (const char*) sqlite3_value_text(argv[0]);\n  sourceDb = (argc == 2) ? (char *) sqlite3_value_text(argv[1]) : \"main\";\n\n  /* if the name of the target is not main, but the index returned is zero \n     there is a mismatch and we should not proceed */\n  targetDb_idx =  sqlcipher_find_db_index(db, targetDb);\n  if(targetDb_idx == 0 && sqlite3StrICmp(\"main\", targetDb) != 0) {\n    rc = SQLITE_ERROR;\n    pzErrMsg = sqlite3_mprintf(\"unknown database %s\", targetDb);\n    goto end_of_export;\n  }\n  db->init.iDb = targetDb_idx;\n\n  db->flags |= SQLITE_WriteSchema | SQLITE_IgnoreChecks; \n  db->mDbFlags |= DBFLAG_PreferBuiltin | DBFLAG_Vacuum;\n  db->flags &= ~(u64)(SQLITE_ForeignKeys | SQLITE_ReverseOrder | SQLITE_Defensive | SQLITE_CountRows); \n  db->mTrace = 0;\n\n  /* Query the schema of the main database. Create a mirror schema\n  ** in the temporary database.\n  */\n  zSql = sqlite3_mprintf(\n    \"SELECT sql \"\n    \"  FROM %s.sqlite_master WHERE type='table' AND name!='sqlite_sequence'\"\n    \"   AND rootpage>0\"\n  , sourceDb);\n  rc = (zSql == NULL) ? SQLITE_NOMEM : sqlcipher_execExecSql(db, &pzErrMsg, zSql); \n  if( rc!=SQLITE_OK ) goto end_of_export;\n  sqlite3_free(zSql);\n\n  zSql = sqlite3_mprintf(\n    \"SELECT sql \"\n    \"  FROM %s.sqlite_master WHERE sql LIKE 'CREATE INDEX %%' \"\n  , sourceDb);\n  rc = (zSql == NULL) ? SQLITE_NOMEM : sqlcipher_execExecSql(db, &pzErrMsg, zSql); \n  if( rc!=SQLITE_OK ) goto end_of_export;\n  sqlite3_free(zSql);\n\n  zSql = sqlite3_mprintf(\n    \"SELECT sql \"\n    \"  FROM %s.sqlite_master WHERE sql LIKE 'CREATE UNIQUE INDEX %%'\"\n  , sourceDb);\n  rc = (zSql == NULL) ? SQLITE_NOMEM : sqlcipher_execExecSql(db, &pzErrMsg, zSql); \n  if( rc!=SQLITE_OK ) goto end_of_export;\n  sqlite3_free(zSql);\n\n  /* Loop through the tables in the main database. For each, do\n  ** an \"INSERT INTO rekey_db.xxx SELECT * FROM main.xxx;\" to copy\n  ** the contents to the temporary database.\n  */\n  zSql = sqlite3_mprintf(\n    \"SELECT 'INSERT INTO %s.' || quote(name) \"\n    \"|| ' SELECT * FROM %s.' || quote(name) || ';'\"\n    \"FROM %s.sqlite_master \"\n    \"WHERE type = 'table' AND name!='sqlite_sequence' \"\n    \"  AND rootpage>0\"\n  , targetDb, sourceDb, sourceDb);\n  rc = (zSql == NULL) ? SQLITE_NOMEM : sqlcipher_execExecSql(db, &pzErrMsg, zSql); \n  if( rc!=SQLITE_OK ) goto end_of_export;\n  sqlite3_free(zSql);\n\n  /* Copy over the contents of the sequence table\n  */\n  zSql = sqlite3_mprintf(\n    \"SELECT 'INSERT INTO %s.' || quote(name) \"\n    \"|| ' SELECT * FROM %s.' || quote(name) || ';' \"\n    \"FROM %s.sqlite_master WHERE name=='sqlite_sequence';\"\n  , targetDb, sourceDb, targetDb);\n  rc = (zSql == NULL) ? SQLITE_NOMEM : sqlcipher_execExecSql(db, &pzErrMsg, zSql); \n  if( rc!=SQLITE_OK ) goto end_of_export;\n  sqlite3_free(zSql);\n\n  /* Copy the triggers, views, and virtual tables from the main database\n  ** over to the temporary database.  None of these objects has any\n  ** associated storage, so all we have to do is copy their entries\n  ** from the SQLITE_MASTER table.\n  */\n  zSql = sqlite3_mprintf(\n    \"INSERT INTO %s.sqlite_master \"\n    \"  SELECT type, name, tbl_name, rootpage, sql\"\n    \"    FROM %s.sqlite_master\"\n    \"   WHERE type='view' OR type='trigger'\"\n    \"      OR (type='table' AND rootpage=0)\"\n  , targetDb, sourceDb);\n  rc = (zSql == NULL) ? SQLITE_NOMEM : sqlcipher_execSql(db, &pzErrMsg, zSql); \n  if( rc!=SQLITE_OK ) goto end_of_export;\n  sqlite3_free(zSql);\n\n  zSql = NULL;\nend_of_export:\n  db->init.iDb = 0;\n  db->flags = saved_flags;\n  db->mDbFlags = saved_mDbFlags;\n  db->nChange = saved_nChange;\n  db->nTotalChange = saved_nTotalChange;\n  db->mTrace = saved_mTrace;\n\n  if(zSql) sqlite3_free(zSql);\n\n  if(rc) {\n    if(pzErrMsg != NULL) {\n      sqlite3_result_error(context, pzErrMsg, -1);\n      sqlite3DbFree(db, pzErrMsg);\n    } else {\n      sqlite3_result_error(context, sqlite3ErrStr(rc), -1);\n    }\n  }\n}",
    "label": "True"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 75,
    "critical_vars": [
      "dctx->remaining"
    ],
    "function": "dnxhd_find_frame_end",
    "filename": "FFmpeg/CVE-2017-9608/CVE-2017-9608_CWE-476_611b35627488a8d0763e75c25ee0875c5b7987dd_dnxhd_parser.c.diff",
    "function_code": "static int dnxhd_find_frame_end(DNXHDParserContext *dctx,\n                                const uint8_t *buf, int buf_size)\n{\n    ParseContext *pc = &dctx->pc;\n    uint64_t state = pc->state64;\n    int pic_found = pc->frame_start_found;\n    int i = 0;\n\n    if (!pic_found) {\n        for (i = 0; i < buf_size; i++) {\n            state = (state << 8) | buf[i];\n            if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {\n                i++;\n                pic_found = 1;\n                dctx->cur_byte = 0;\n                dctx->remaining = 0;\n                break;\n            }\n        }\n    }\n\n    if (pic_found && !dctx->remaining) {\n        if (!buf_size) /* EOF considered as end of frame */\n            return 0;\n        for (; i < buf_size; i++) {\n            dctx->cur_byte++;\n            state = (state << 8) | buf[i];\n\n            if (dctx->cur_byte == 24) {\n                dctx->h = (state >> 32) & 0xFFFF;\n            } else if (dctx->cur_byte == 26) {\n                dctx->w = (state >> 32) & 0xFFFF;\n            } else if (dctx->cur_byte == 42) {\n                int cid = (state >> 32) & 0xFFFFFFFF;\n\n                if (cid <= 0)\n                    continue;\n\n                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);\n                if (dctx->remaining <= 0) {\n                    dctx->remaining = ff_dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);\n                    if (dctx->remaining <= 0)\n                        return dctx->remaining;\n                }\n                if (buf_size - i + 47 >= dctx->remaining) {\n                    int remaining = dctx->remaining;\n\n                    pc->frame_start_found = 0;\n                    pc->state64 = -1;\n                    dctx->cur_byte = 0;\n                    dctx->remaining = 0;\n                    return remaining;\n                } else {\n                    dctx->remaining -= buf_size;\n                }\n            }\n        }\n    } else if (pic_found) {\n        if (dctx->remaining > buf_size) {\n            dctx->remaining -= buf_size;\n        } else {\n            int remaining = dctx->remaining;\n\n            pc->frame_start_found = 0;\n            pc->state64 = -1;\n            dctx->cur_byte = 0;\n            dctx->remaining = 0;\n            return remaining;\n        }\n    }\n    pc->frame_start_found = pic_found;\n    pc->state64 = state;\n    return END_NOT_FOUND;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 71,
    "critical_vars": [
      "remaining"
    ],
    "function": "dnxhd_find_frame_end",
    "filename": "FFmpeg/CVE-2017-9608/CVE-2017-9608_CWE-476_611b35627488a8d0763e75c25ee0875c5b7987dd_dnxhd_parser.c.diff",
    "function_code": "static int dnxhd_find_frame_end(DNXHDParserContext *dctx,\n                                const uint8_t *buf, int buf_size)\n{\n    ParseContext *pc = &dctx->pc;\n    uint64_t state = pc->state64;\n    int pic_found = pc->frame_start_found;\n    int i = 0;\n\n    if (!pic_found) {\n        for (i = 0; i < buf_size; i++) {\n            state = (state << 8) | buf[i];\n            if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {\n                i++;\n                pic_found = 1;\n                dctx->cur_byte = 0;\n                dctx->remaining = 0;\n                break;\n            }\n        }\n    }\n\n    if (pic_found && !dctx->remaining) {\n        if (!buf_size) /* EOF considered as end of frame */\n            return 0;\n        for (; i < buf_size; i++) {\n            dctx->cur_byte++;\n            state = (state << 8) | buf[i];\n\n            if (dctx->cur_byte == 24) {\n                dctx->h = (state >> 32) & 0xFFFF;\n            } else if (dctx->cur_byte == 26) {\n                dctx->w = (state >> 32) & 0xFFFF;\n            } else if (dctx->cur_byte == 42) {\n                int cid = (state >> 32) & 0xFFFFFFFF;\n                int remaining;\n\n                if (cid <= 0)\n                    continue;\n\n                remaining = avpriv_dnxhd_get_frame_size(cid);\n                if (remaining <= 0) {\n                    remaining = ff_dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);\n                    if (remaining <= 0)\n                        continue;\n                }\n                dctx->remaining = remaining;\n                if (buf_size - i + 47 >= dctx->remaining) {\n                    int remaining = dctx->remaining;\n\n                    pc->frame_start_found = 0;\n                    pc->state64 = -1;\n                    dctx->cur_byte = 0;\n                    dctx->remaining = 0;\n                    return remaining;\n                } else {\n                    dctx->remaining -= buf_size;\n                }\n            }\n        }\n    } else if (pic_found) {\n        if (dctx->remaining > buf_size) {\n            dctx->remaining -= buf_size;\n        } else {\n            int remaining = dctx->remaining;\n\n            pc->frame_start_found = 0;\n            pc->state64 = -1;\n            dctx->cur_byte = 0;\n            dctx->remaining = 0;\n            return remaining;\n        }\n    }\n    pc->frame_start_found = pic_found;\n    pc->state64 = state;\n    return END_NOT_FOUND;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 355,
    "critical_vars": [
      "s"
    ],
    "function": "decode_main_header",
    "filename": "FFmpeg/CVE-2022-3341/CVE-2022-3341_CWE-476_9cf652cef49d74afe3d454f27d49eb1a1394951e_nutdec.c.diff",
    "function_code": "static int decode_main_header(NUTContext *nut)\n{\n    AVFormatContext *s = nut->avf;\n    AVIOContext *bc    = s->pb;\n    uint64_t tmp, end, length;\n    unsigned int stream_count;\n    int i, j, count, ret;\n    int tmp_stream, tmp_mul, tmp_pts, tmp_size, tmp_res, tmp_head_idx;\n\n    length = get_packetheader(nut, bc, 1, MAIN_STARTCODE);\n    end = length + avio_tell(bc);\n\n    nut->version = ffio_read_varlen(bc);\n    if (nut->version < NUT_MIN_VERSION ||\n        nut->version > NUT_MAX_VERSION) {\n        av_log(s, AV_LOG_ERROR, \"Version %d not supported.\\n\",\n               nut->version);\n        return AVERROR(ENOSYS);\n    }\n    if (nut->version > 3)\n        nut->minor_version = ffio_read_varlen(bc);\n\n    GET_V(stream_count, tmp > 0 && tmp <= NUT_MAX_STREAMS);\n\n    nut->max_distance = ffio_read_varlen(bc);\n    if (nut->max_distance > 65536) {\n        av_log(s, AV_LOG_DEBUG, \"max_distance %d\\n\", nut->max_distance);\n        nut->max_distance = 65536;\n    }\n\n    GET_V(nut->time_base_count, tmp > 0 && tmp < INT_MAX / sizeof(AVRational) && tmp < length/2);\n    nut->time_base = av_malloc_array(nut->time_base_count, sizeof(AVRational));\n    if (!nut->time_base)\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < nut->time_base_count; i++) {\n        GET_V(nut->time_base[i].num, tmp > 0 && tmp < (1ULL << 31));\n        GET_V(nut->time_base[i].den, tmp > 0 && tmp < (1ULL << 31));\n        if (av_gcd(nut->time_base[i].num, nut->time_base[i].den) != 1) {\n            av_log(s, AV_LOG_ERROR, \"invalid time base %d/%d\\n\",\n                   nut->time_base[i].num,\n                   nut->time_base[i].den);\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n    }\n    tmp_pts      = 0;\n    tmp_mul      = 1;\n    tmp_stream   = 0;\n    tmp_head_idx = 0;\n    for (i = 0; i < 256;) {\n        int tmp_flags  = ffio_read_varlen(bc);\n        int tmp_fields = ffio_read_varlen(bc);\n\n        if (tmp_fields > 0)\n            tmp_pts = get_s(bc);\n        if (tmp_fields > 1)\n            tmp_mul = ffio_read_varlen(bc);\n        if (tmp_fields > 2)\n            tmp_stream = ffio_read_varlen(bc);\n        if (tmp_fields > 3)\n            tmp_size = ffio_read_varlen(bc);\n        else\n            tmp_size = 0;\n        if (tmp_fields > 4)\n            tmp_res = ffio_read_varlen(bc);\n        else\n            tmp_res = 0;\n        if (tmp_fields > 5)\n            count = ffio_read_varlen(bc);\n        else\n            count = tmp_mul - (unsigned)tmp_size;\n        if (tmp_fields > 6)\n            get_s(bc);\n        if (tmp_fields > 7)\n            tmp_head_idx = ffio_read_varlen(bc);\n\n        while (tmp_fields-- > 8) {\n            if (bc->eof_reached) {\n                av_log(s, AV_LOG_ERROR, \"reached EOF while decoding main header\\n\");\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n            ffio_read_varlen(bc);\n        }\n\n        if (count <= 0 || count > 256 - (i <= 'N') - i) {\n            av_log(s, AV_LOG_ERROR, \"illegal count %d at %d\\n\", count, i);\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n        if (tmp_stream >= stream_count) {\n            av_log(s, AV_LOG_ERROR, \"illegal stream number %d >= %d\\n\",\n                   tmp_stream, stream_count);\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n        if (tmp_size < 0 || tmp_size > INT_MAX - count) {\n            av_log(s, AV_LOG_ERROR, \"illegal size\\n\");\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n\n        for (j = 0; j < count; j++, i++) {\n            if (i == 'N') {\n                nut->frame_code[i].flags = FLAG_INVALID;\n                j--;\n                continue;\n            }\n            nut->frame_code[i].flags          = tmp_flags;\n            nut->frame_code[i].pts_delta      = tmp_pts;\n            nut->frame_code[i].stream_id      = tmp_stream;\n            nut->frame_code[i].size_mul       = tmp_mul;\n            nut->frame_code[i].size_lsb       = tmp_size + j;\n            nut->frame_code[i].reserved_count = tmp_res;\n            nut->frame_code[i].header_idx     = tmp_head_idx;\n        }\n    }\n    av_assert0(nut->frame_code['N'].flags == FLAG_INVALID);\n\n    if (end > avio_tell(bc) + 4) {\n        int rem = 1024;\n        GET_V(nut->header_count, tmp < 128U);\n        nut->header_count++;\n        for (i = 1; i < nut->header_count; i++) {\n            uint8_t *hdr;\n            GET_V(nut->header_len[i], tmp > 0 && tmp < 256);\n            if (rem < nut->header_len[i]) {\n                av_log(s, AV_LOG_ERROR,\n                       \"invalid elision header %d : %d > %d\\n\",\n                       i, nut->header_len[i], rem);\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n            rem -= nut->header_len[i];\n            hdr = av_malloc(nut->header_len[i]);\n            if (!hdr) {\n                ret = AVERROR(ENOMEM);\n                goto fail;\n            }\n            avio_read(bc, hdr, nut->header_len[i]);\n            nut->header[i] = hdr;\n        }\n        av_assert0(nut->header_len[0] == 0);\n    }\n\n    // flags had been effectively introduced in version 4\n    if (nut->version > 3 && end > avio_tell(bc) + 4) {\n        nut->flags = ffio_read_varlen(bc);\n    }\n\n    if (skip_reserved(bc, end) || ffio_get_checksum(bc)) {\n        av_log(s, AV_LOG_ERROR, \"main header checksum mismatch\\n\");\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n\n    nut->stream = av_calloc(stream_count, sizeof(StreamContext));\n    if (!nut->stream) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n    for (i = 0; i < stream_count; i++)\n        avformat_new_stream(s, NULL);\n\n    return 0;\nfail:\n    av_freep(&nut->time_base);\n    for (i = 1; i < nut->header_count; i++) {\n        av_freep(&nut->header[i]);\n    }\n    nut->header_count = 0;\n    return ret;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 355,
    "critical_vars": [
      "s"
    ],
    "function": "decode_main_header",
    "filename": "FFmpeg/CVE-2022-3341/CVE-2022-3341_CWE-476_9cf652cef49d74afe3d454f27d49eb1a1394951e_nutdec.c.diff",
    "function_code": "static int decode_main_header(NUTContext *nut)\n{\n    AVFormatContext *s = nut->avf;\n    AVIOContext *bc    = s->pb;\n    uint64_t tmp, end, length;\n    unsigned int stream_count;\n    int i, j, count, ret;\n    int tmp_stream, tmp_mul, tmp_pts, tmp_size, tmp_res, tmp_head_idx;\n\n    length = get_packetheader(nut, bc, 1, MAIN_STARTCODE);\n    end = length + avio_tell(bc);\n\n    nut->version = ffio_read_varlen(bc);\n    if (nut->version < NUT_MIN_VERSION ||\n        nut->version > NUT_MAX_VERSION) {\n        av_log(s, AV_LOG_ERROR, \"Version %d not supported.\\n\",\n               nut->version);\n        return AVERROR(ENOSYS);\n    }\n    if (nut->version > 3)\n        nut->minor_version = ffio_read_varlen(bc);\n\n    GET_V(stream_count, tmp > 0 && tmp <= NUT_MAX_STREAMS);\n\n    nut->max_distance = ffio_read_varlen(bc);\n    if (nut->max_distance > 65536) {\n        av_log(s, AV_LOG_DEBUG, \"max_distance %d\\n\", nut->max_distance);\n        nut->max_distance = 65536;\n    }\n\n    GET_V(nut->time_base_count, tmp > 0 && tmp < INT_MAX / sizeof(AVRational) && tmp < length/2);\n    nut->time_base = av_malloc_array(nut->time_base_count, sizeof(AVRational));\n    if (!nut->time_base)\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < nut->time_base_count; i++) {\n        GET_V(nut->time_base[i].num, tmp > 0 && tmp < (1ULL << 31));\n        GET_V(nut->time_base[i].den, tmp > 0 && tmp < (1ULL << 31));\n        if (av_gcd(nut->time_base[i].num, nut->time_base[i].den) != 1) {\n            av_log(s, AV_LOG_ERROR, \"invalid time base %d/%d\\n\",\n                   nut->time_base[i].num,\n                   nut->time_base[i].den);\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n    }\n    tmp_pts      = 0;\n    tmp_mul      = 1;\n    tmp_stream   = 0;\n    tmp_head_idx = 0;\n    for (i = 0; i < 256;) {\n        int tmp_flags  = ffio_read_varlen(bc);\n        int tmp_fields = ffio_read_varlen(bc);\n\n        if (tmp_fields > 0)\n            tmp_pts = get_s(bc);\n        if (tmp_fields > 1)\n            tmp_mul = ffio_read_varlen(bc);\n        if (tmp_fields > 2)\n            tmp_stream = ffio_read_varlen(bc);\n        if (tmp_fields > 3)\n            tmp_size = ffio_read_varlen(bc);\n        else\n            tmp_size = 0;\n        if (tmp_fields > 4)\n            tmp_res = ffio_read_varlen(bc);\n        else\n            tmp_res = 0;\n        if (tmp_fields > 5)\n            count = ffio_read_varlen(bc);\n        else\n            count = tmp_mul - (unsigned)tmp_size;\n        if (tmp_fields > 6)\n            get_s(bc);\n        if (tmp_fields > 7)\n            tmp_head_idx = ffio_read_varlen(bc);\n\n        while (tmp_fields-- > 8) {\n            if (bc->eof_reached) {\n                av_log(s, AV_LOG_ERROR, \"reached EOF while decoding main header\\n\");\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n            ffio_read_varlen(bc);\n        }\n\n        if (count <= 0 || count > 256 - (i <= 'N') - i) {\n            av_log(s, AV_LOG_ERROR, \"illegal count %d at %d\\n\", count, i);\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n        if (tmp_stream >= stream_count) {\n            av_log(s, AV_LOG_ERROR, \"illegal stream number %d >= %d\\n\",\n                   tmp_stream, stream_count);\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n        if (tmp_size < 0 || tmp_size > INT_MAX - count) {\n            av_log(s, AV_LOG_ERROR, \"illegal size\\n\");\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n\n        for (j = 0; j < count; j++, i++) {\n            if (i == 'N') {\n                nut->frame_code[i].flags = FLAG_INVALID;\n                j--;\n                continue;\n            }\n            nut->frame_code[i].flags          = tmp_flags;\n            nut->frame_code[i].pts_delta      = tmp_pts;\n            nut->frame_code[i].stream_id      = tmp_stream;\n            nut->frame_code[i].size_mul       = tmp_mul;\n            nut->frame_code[i].size_lsb       = tmp_size + j;\n            nut->frame_code[i].reserved_count = tmp_res;\n            nut->frame_code[i].header_idx     = tmp_head_idx;\n        }\n    }\n    av_assert0(nut->frame_code['N'].flags == FLAG_INVALID);\n\n    if (end > avio_tell(bc) + 4) {\n        int rem = 1024;\n        GET_V(nut->header_count, tmp < 128U);\n        nut->header_count++;\n        for (i = 1; i < nut->header_count; i++) {\n            uint8_t *hdr;\n            GET_V(nut->header_len[i], tmp > 0 && tmp < 256);\n            if (rem < nut->header_len[i]) {\n                av_log(s, AV_LOG_ERROR,\n                       \"invalid elision header %d : %d > %d\\n\",\n                       i, nut->header_len[i], rem);\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n            rem -= nut->header_len[i];\n            hdr = av_malloc(nut->header_len[i]);\n            if (!hdr) {\n                ret = AVERROR(ENOMEM);\n                goto fail;\n            }\n            avio_read(bc, hdr, nut->header_len[i]);\n            nut->header[i] = hdr;\n        }\n        av_assert0(nut->header_len[0] == 0);\n    }\n\n    // flags had been effectively introduced in version 4\n    if (nut->version > 3 && end > avio_tell(bc) + 4) {\n        nut->flags = ffio_read_varlen(bc);\n    }\n\n    if (skip_reserved(bc, end) || ffio_get_checksum(bc)) {\n        av_log(s, AV_LOG_ERROR, \"main header checksum mismatch\\n\");\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n\n    nut->stream = av_calloc(stream_count, sizeof(StreamContext));\n    if (!nut->stream) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n    for (i = 0; i < stream_count; i++) {\n        if (!avformat_new_stream(s, NULL)) {\n            ret = AVERROR(ENOMEM);\n            goto fail;\n        }\n    }\n\n    return 0;\nfail:\n    av_freep(&nut->time_base);\n    for (i = 1; i < nut->header_count; i++) {\n        av_freep(&nut->header[i]);\n    }\n    nut->header_count = 0;\n    return ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "while-Condition",
    "line_old": 815,
    "critical_vars": [
      "nut"
    ],
    "function": "nut_read_header",
    "filename": "FFmpeg/CVE-2022-3341/CVE-2022-3341_CWE-476_9cf652cef49d74afe3d454f27d49eb1a1394951e_nutdec.c.diff",
    "function_code": "static int nut_read_header(AVFormatContext *s)\n{\n    NUTContext *nut = s->priv_data;\n    AVIOContext *bc = s->pb;\n    int64_t pos;\n    int initialized_stream_count;\n\n    nut->avf = s;\n\n    /* main header */\n    pos = 0;\n    do {\n        pos = find_startcode(bc, MAIN_STARTCODE, pos) + 1;\n        if (pos < 0 + 1) {\n            av_log(s, AV_LOG_ERROR, \"No main startcode found.\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n    } while (decode_main_header(nut) < 0);\n\n    /* stream headers */\n    pos = 0;\n    for (initialized_stream_count = 0; initialized_stream_count < s->nb_streams;) {\n        pos = find_startcode(bc, STREAM_STARTCODE, pos) + 1;\n        if (pos < 0 + 1) {\n            av_log(s, AV_LOG_ERROR, \"Not all stream headers found.\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        if (decode_stream_header(nut) >= 0)\n            initialized_stream_count++;\n    }\n\n    /* info headers */\n    pos = 0;\n    for (;;) {\n        uint64_t startcode = find_any_startcode(bc, pos);\n        pos = avio_tell(bc);\n\n        if (startcode == 0) {\n            av_log(s, AV_LOG_ERROR, \"EOF before video frames\\n\");\n            return AVERROR_INVALIDDATA;\n        } else if (startcode == SYNCPOINT_STARTCODE) {\n            nut->next_startcode = startcode;\n            break;\n        } else if (startcode != INFO_STARTCODE) {\n            continue;\n        }\n\n        decode_info_header(nut);\n    }\n\n    ffformatcontext(s)->data_offset = pos - 8;\n\n    if (bc->seekable & AVIO_SEEKABLE_NORMAL) {\n        int64_t orig_pos = avio_tell(bc);\n        find_and_decode_index(nut);\n        avio_seek(bc, orig_pos, SEEK_SET);\n    }\n    av_assert0(nut->next_startcode == SYNCPOINT_STARTCODE);\n\n    ff_metadata_conv_ctx(s, NULL, ff_nut_metadata_conv);\n\n    return 0;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 807,
    "critical_vars": [
      "ret"
    ],
    "function": "nut_read_header",
    "filename": "FFmpeg/CVE-2022-3341/CVE-2022-3341_CWE-476_9cf652cef49d74afe3d454f27d49eb1a1394951e_nutdec.c.diff",
    "function_code": "static int nut_read_header(AVFormatContext *s)\n{\n    NUTContext *nut = s->priv_data;\n    AVIOContext *bc = s->pb;\n    int64_t pos;\n    int initialized_stream_count, ret;\n\n    nut->avf = s;\n\n    /* main header */\n    pos = 0;\n    ret = 0;\n    do {\n        if (ret == AVERROR(ENOMEM))\n            return ret;\n\n        pos = find_startcode(bc, MAIN_STARTCODE, pos) + 1;\n        if (pos < 0 + 1) {\n            av_log(s, AV_LOG_ERROR, \"No main startcode found.\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n    } while ((ret = decode_main_header(nut)) < 0);\n\n    /* stream headers */\n    pos = 0;\n    for (initialized_stream_count = 0; initialized_stream_count < s->nb_streams;) {\n        pos = find_startcode(bc, STREAM_STARTCODE, pos) + 1;\n        if (pos < 0 + 1) {\n            av_log(s, AV_LOG_ERROR, \"Not all stream headers found.\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        if (decode_stream_header(nut) >= 0)\n            initialized_stream_count++;\n    }\n\n    /* info headers */\n    pos = 0;\n    for (;;) {\n        uint64_t startcode = find_any_startcode(bc, pos);\n        pos = avio_tell(bc);\n\n        if (startcode == 0) {\n            av_log(s, AV_LOG_ERROR, \"EOF before video frames\\n\");\n            return AVERROR_INVALIDDATA;\n        } else if (startcode == SYNCPOINT_STARTCODE) {\n            nut->next_startcode = startcode;\n            break;\n        } else if (startcode != INFO_STARTCODE) {\n            continue;\n        }\n\n        decode_info_header(nut);\n    }\n\n    ffformatcontext(s)->data_offset = pos - 8;\n\n    if (bc->seekable & AVIO_SEEKABLE_NORMAL) {\n        int64_t orig_pos = avio_tell(bc);\n        find_and_decode_index(nut);\n        avio_seek(bc, orig_pos, SEEK_SET);\n    }\n    av_assert0(nut->next_startcode == SYNCPOINT_STARTCODE);\n\n    ff_metadata_conv_ctx(s, NULL, ff_nut_metadata_conv);\n\n    return 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 261,
    "critical_vars": [
      "avctx->profile",
      "avctx->codec_id"
    ],
    "function": "ff_idctdsp_init",
    "filename": "FFmpeg/CVE-2018-12460/CVE-2018-12460_CWE-476_b3332a182f8ba33a34542e4a0370f38b914ccf7d_idctdsp.c.diff",
    "function_code": "av_cold void ff_idctdsp_init(IDCTDSPContext *c, AVCodecContext *avctx)\n{\n    const unsigned high_bit_depth = avctx->bits_per_raw_sample > 8;\n\n    if (avctx->lowres==1) {\n        c->idct_put  = ff_jref_idct4_put;\n        c->idct_add  = ff_jref_idct4_add;\n        c->idct      = ff_j_rev_dct4;\n        c->perm_type = FF_IDCT_PERM_NONE;\n    } else if (avctx->lowres==2) {\n        c->idct_put  = ff_jref_idct2_put;\n        c->idct_add  = ff_jref_idct2_add;\n        c->idct      = ff_j_rev_dct2;\n        c->perm_type = FF_IDCT_PERM_NONE;\n    } else if (avctx->lowres==3) {\n        c->idct_put  = ff_jref_idct1_put;\n        c->idct_add  = ff_jref_idct1_add;\n        c->idct      = ff_j_rev_dct1;\n        c->perm_type = FF_IDCT_PERM_NONE;\n    } else {\n        if (avctx->bits_per_raw_sample == 10 || avctx->bits_per_raw_sample == 9) {\n            /* 10-bit MPEG-4 Simple Studio Profile requires a higher precision IDCT\n               However, it only uses idct_put */\n            if (avctx->codec_id == AV_CODEC_ID_MPEG4 && avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO)\n                c->idct_put              = ff_simple_idct_put_int32_10bit;\n            else {\n                c->idct_put              = ff_simple_idct_put_int16_10bit;\n                c->idct_add              = ff_simple_idct_add_int16_10bit;\n                c->idct                  = ff_simple_idct_int16_10bit;\n            }\n            c->perm_type             = FF_IDCT_PERM_NONE;\n        } else if (avctx->bits_per_raw_sample == 12) {\n            c->idct_put              = ff_simple_idct_put_int16_12bit;\n            c->idct_add              = ff_simple_idct_add_int16_12bit;\n            c->idct                  = ff_simple_idct_int16_12bit;\n            c->perm_type             = FF_IDCT_PERM_NONE;\n        } else {\n            if (avctx->idct_algo == FF_IDCT_INT) {\n                c->idct_put  = ff_jref_idct_put;\n                c->idct_add  = ff_jref_idct_add;\n                c->idct      = ff_j_rev_dct;\n                c->perm_type = FF_IDCT_PERM_LIBMPEG2;\n#if CONFIG_FAANIDCT\n            } else if (avctx->idct_algo == FF_IDCT_FAAN) {\n                c->idct_put  = ff_faanidct_put;\n                c->idct_add  = ff_faanidct_add;\n                c->idct      = ff_faanidct;\n                c->perm_type = FF_IDCT_PERM_NONE;\n#endif /* CONFIG_FAANIDCT */\n            } else { // accurate/default\n                /* Be sure FF_IDCT_NONE will select this one, since it uses FF_IDCT_PERM_NONE */\n                c->idct_put  = ff_simple_idct_put_int16_8bit;\n                c->idct_add  = ff_simple_idct_add_int16_8bit;\n                c->idct      = ff_simple_idct_int16_8bit;\n                c->perm_type = FF_IDCT_PERM_NONE;\n            }\n        }\n    }\n\n    c->put_pixels_clamped        = ff_put_pixels_clamped_c;\n    c->put_signed_pixels_clamped = put_signed_pixels_clamped_c;\n    c->add_pixels_clamped        = ff_add_pixels_clamped_c;\n\n    if (CONFIG_MPEG4_DECODER && avctx->idct_algo == FF_IDCT_XVID)\n        ff_xvid_idct_init(c, avctx);\n\n    if (ARCH_AARCH64)\n        ff_idctdsp_init_aarch64(c, avctx, high_bit_depth);\n    if (ARCH_ALPHA)\n        ff_idctdsp_init_alpha(c, avctx, high_bit_depth);\n    if (ARCH_ARM)\n        ff_idctdsp_init_arm(c, avctx, high_bit_depth);\n    if (ARCH_PPC)\n        ff_idctdsp_init_ppc(c, avctx, high_bit_depth);\n    if (ARCH_X86)\n        ff_idctdsp_init_x86(c, avctx, high_bit_depth);\n    if (ARCH_MIPS)\n        ff_idctdsp_init_mips(c, avctx, high_bit_depth);\n\n    ff_init_scantable_permutation(c->idct_permutation,\n                                  c->perm_type);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 261,
    "critical_vars": [
      "c->mpeg4_studio_profile"
    ],
    "function": "ff_idctdsp_init",
    "filename": "FFmpeg/CVE-2018-12460/CVE-2018-12460_CWE-476_b3332a182f8ba33a34542e4a0370f38b914ccf7d_idctdsp.c.diff",
    "function_code": "av_cold void ff_idctdsp_init(IDCTDSPContext *c, AVCodecContext *avctx)\n{\n    const unsigned high_bit_depth = avctx->bits_per_raw_sample > 8;\n\n    if (avctx->lowres==1) {\n        c->idct_put  = ff_jref_idct4_put;\n        c->idct_add  = ff_jref_idct4_add;\n        c->idct      = ff_j_rev_dct4;\n        c->perm_type = FF_IDCT_PERM_NONE;\n    } else if (avctx->lowres==2) {\n        c->idct_put  = ff_jref_idct2_put;\n        c->idct_add  = ff_jref_idct2_add;\n        c->idct      = ff_j_rev_dct2;\n        c->perm_type = FF_IDCT_PERM_NONE;\n    } else if (avctx->lowres==3) {\n        c->idct_put  = ff_jref_idct1_put;\n        c->idct_add  = ff_jref_idct1_add;\n        c->idct      = ff_j_rev_dct1;\n        c->perm_type = FF_IDCT_PERM_NONE;\n    } else {\n        if (avctx->bits_per_raw_sample == 10 || avctx->bits_per_raw_sample == 9) {\n            /* 10-bit MPEG-4 Simple Studio Profile requires a higher precision IDCT\n               However, it only uses idct_put */\n            if (c->mpeg4_studio_profile)\n                c->idct_put              = ff_simple_idct_put_int32_10bit;\n            else {\n                c->idct_put              = ff_simple_idct_put_int16_10bit;\n                c->idct_add              = ff_simple_idct_add_int16_10bit;\n                c->idct                  = ff_simple_idct_int16_10bit;\n            }\n            c->perm_type             = FF_IDCT_PERM_NONE;\n        } else if (avctx->bits_per_raw_sample == 12) {\n            c->idct_put              = ff_simple_idct_put_int16_12bit;\n            c->idct_add              = ff_simple_idct_add_int16_12bit;\n            c->idct                  = ff_simple_idct_int16_12bit;\n            c->perm_type             = FF_IDCT_PERM_NONE;\n        } else {\n            if (avctx->idct_algo == FF_IDCT_INT) {\n                c->idct_put  = ff_jref_idct_put;\n                c->idct_add  = ff_jref_idct_add;\n                c->idct      = ff_j_rev_dct;\n                c->perm_type = FF_IDCT_PERM_LIBMPEG2;\n#if CONFIG_FAANIDCT\n            } else if (avctx->idct_algo == FF_IDCT_FAAN) {\n                c->idct_put  = ff_faanidct_put;\n                c->idct_add  = ff_faanidct_add;\n                c->idct      = ff_faanidct;\n                c->perm_type = FF_IDCT_PERM_NONE;\n#endif /* CONFIG_FAANIDCT */\n            } else { // accurate/default\n                /* Be sure FF_IDCT_NONE will select this one, since it uses FF_IDCT_PERM_NONE */\n                c->idct_put  = ff_simple_idct_put_int16_8bit;\n                c->idct_add  = ff_simple_idct_add_int16_8bit;\n                c->idct      = ff_simple_idct_int16_8bit;\n                c->perm_type = FF_IDCT_PERM_NONE;\n            }\n        }\n    }\n\n    c->put_pixels_clamped        = ff_put_pixels_clamped_c;\n    c->put_signed_pixels_clamped = put_signed_pixels_clamped_c;\n    c->add_pixels_clamped        = ff_add_pixels_clamped_c;\n\n    if (CONFIG_MPEG4_DECODER && avctx->idct_algo == FF_IDCT_XVID)\n        ff_xvid_idct_init(c, avctx);\n\n    if (ARCH_AARCH64)\n        ff_idctdsp_init_aarch64(c, avctx, high_bit_depth);\n    if (ARCH_ALPHA)\n        ff_idctdsp_init_alpha(c, avctx, high_bit_depth);\n    if (ARCH_ARM)\n        ff_idctdsp_init_arm(c, avctx, high_bit_depth);\n    if (ARCH_PPC)\n        ff_idctdsp_init_ppc(c, avctx, high_bit_depth);\n    if (ARCH_X86)\n        ff_idctdsp_init_x86(c, avctx, high_bit_depth);\n    if (ARCH_MIPS)\n        ff_idctdsp_init_mips(c, avctx, high_bit_depth);\n\n    ff_init_scantable_permutation(c->idct_permutation,\n                                  c->perm_type);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 2930,
    "critical_vars": [
      "s->ref"
    ],
    "function": "decode_nal_unit",
    "filename": "FFmpeg/CVE-2019-11338/CVE-2019-11338_CWE-476_54655623a82632e7624714d7b2a3e039dc5faa7e_hevcdec.c.diff",
    "function_code": "static int decode_nal_unit(HEVCContext *s, const H2645NAL *nal)\n{\n    HEVCLocalContext *lc = s->HEVClc;\n    GetBitContext *gb    = &lc->gb;\n    int ctb_addr_ts, ret;\n\n    *gb              = nal->gb;\n    s->nal_unit_type = nal->type;\n    s->temporal_id   = nal->temporal_id;\n\n    switch (s->nal_unit_type) {\n    case HEVC_NAL_VPS:\n        if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {\n            ret = s->avctx->hwaccel->decode_params(s->avctx,\n                                                   nal->type,\n                                                   nal->raw_data,\n                                                   nal->raw_size);\n            if (ret < 0)\n                goto fail;\n        }\n        ret = ff_hevc_decode_nal_vps(gb, s->avctx, &s->ps);\n        if (ret < 0)\n            goto fail;\n        break;\n    case HEVC_NAL_SPS:\n        if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {\n            ret = s->avctx->hwaccel->decode_params(s->avctx,\n                                                   nal->type,\n                                                   nal->raw_data,\n                                                   nal->raw_size);\n            if (ret < 0)\n                goto fail;\n        }\n        ret = ff_hevc_decode_nal_sps(gb, s->avctx, &s->ps,\n                                     s->apply_defdispwin);\n        if (ret < 0)\n            goto fail;\n        break;\n    case HEVC_NAL_PPS:\n        if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {\n            ret = s->avctx->hwaccel->decode_params(s->avctx,\n                                                   nal->type,\n                                                   nal->raw_data,\n                                                   nal->raw_size);\n            if (ret < 0)\n                goto fail;\n        }\n        ret = ff_hevc_decode_nal_pps(gb, s->avctx, &s->ps);\n        if (ret < 0)\n            goto fail;\n        break;\n    case HEVC_NAL_SEI_PREFIX:\n    case HEVC_NAL_SEI_SUFFIX:\n        if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {\n            ret = s->avctx->hwaccel->decode_params(s->avctx,\n                                                   nal->type,\n                                                   nal->raw_data,\n                                                   nal->raw_size);\n            if (ret < 0)\n                goto fail;\n        }\n        ret = ff_hevc_decode_nal_sei(gb, s->avctx, &s->sei, &s->ps, s->nal_unit_type);\n        if (ret < 0)\n            goto fail;\n        break;\n    case HEVC_NAL_TRAIL_R:\n    case HEVC_NAL_TRAIL_N:\n    case HEVC_NAL_TSA_N:\n    case HEVC_NAL_TSA_R:\n    case HEVC_NAL_STSA_N:\n    case HEVC_NAL_STSA_R:\n    case HEVC_NAL_BLA_W_LP:\n    case HEVC_NAL_BLA_W_RADL:\n    case HEVC_NAL_BLA_N_LP:\n    case HEVC_NAL_IDR_W_RADL:\n    case HEVC_NAL_IDR_N_LP:\n    case HEVC_NAL_CRA_NUT:\n    case HEVC_NAL_RADL_N:\n    case HEVC_NAL_RADL_R:\n    case HEVC_NAL_RASL_N:\n    case HEVC_NAL_RASL_R:\n        ret = hls_slice_header(s);\n        if (ret < 0)\n            return ret;\n\n        if (\n            (s->avctx->skip_frame >= AVDISCARD_BIDIR && s->sh.slice_type == HEVC_SLICE_B) ||\n            (s->avctx->skip_frame >= AVDISCARD_NONINTRA && s->sh.slice_type != HEVC_SLICE_I) ||\n            (s->avctx->skip_frame >= AVDISCARD_NONKEY && !IS_IRAP(s))) {\n            break;\n        }\n\n        if (s->sh.first_slice_in_pic_flag) {\n            if (s->ref) {\n                av_log(s->avctx, AV_LOG_ERROR, \"Two slices reporting being the first in the same frame.\\n\");\n                goto fail;\n            }\n            if (s->max_ra == INT_MAX) {\n                if (s->nal_unit_type == HEVC_NAL_CRA_NUT || IS_BLA(s)) {\n                    s->max_ra = s->poc;\n                } else {\n                    if (IS_IDR(s))\n                        s->max_ra = INT_MIN;\n                }\n            }\n\n            if ((s->nal_unit_type == HEVC_NAL_RASL_R || s->nal_unit_type == HEVC_NAL_RASL_N) &&\n                s->poc <= s->max_ra) {\n                s->is_decoded = 0;\n                break;\n            } else {\n                if (s->nal_unit_type == HEVC_NAL_RASL_R && s->poc > s->max_ra)\n                    s->max_ra = INT_MIN;\n            }\n\n            s->overlap ++;\n            ret = hevc_frame_start(s);\n            if (ret < 0)\n                return ret;\n        } else if (!s->ref) {\n            av_log(s->avctx, AV_LOG_ERROR, \"First slice in a frame missing.\\n\");\n            goto fail;\n        }\n\n        if (s->nal_unit_type != s->first_nal_type) {\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"Non-matching NAL types of the VCL NALUs: %d %d\\n\",\n                   s->first_nal_type, s->nal_unit_type);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (!s->sh.dependent_slice_segment_flag &&\n            s->sh.slice_type != HEVC_SLICE_I) {\n            ret = ff_hevc_slice_rpl(s);\n            if (ret < 0) {\n                av_log(s->avctx, AV_LOG_WARNING,\n                       \"Error constructing the reference lists for the current slice.\\n\");\n                goto fail;\n            }\n        }\n\n        if (s->sh.first_slice_in_pic_flag && s->avctx->hwaccel) {\n            ret = s->avctx->hwaccel->start_frame(s->avctx, NULL, 0);\n            if (ret < 0)\n                goto fail;\n        }\n\n        if (s->avctx->hwaccel) {\n            ret = s->avctx->hwaccel->decode_slice(s->avctx, nal->raw_data, nal->raw_size);\n            if (ret < 0)\n                goto fail;\n        } else {\n            if (s->threads_number > 1 && s->sh.num_entry_point_offsets > 0)\n                ctb_addr_ts = hls_slice_data_wpp(s, nal);\n            else\n                ctb_addr_ts = hls_slice_data(s);\n            if (ctb_addr_ts >= (s->ps.sps->ctb_width * s->ps.sps->ctb_height)) {\n                s->is_decoded = 1;\n            }\n\n            if (ctb_addr_ts < 0) {\n                ret = ctb_addr_ts;\n                goto fail;\n            }\n        }\n        break;\n    case HEVC_NAL_EOS_NUT:\n    case HEVC_NAL_EOB_NUT:\n        s->seq_decode = (s->seq_decode + 1) & 0xff;\n        s->max_ra     = INT_MAX;\n        break;\n    case HEVC_NAL_AUD:\n    case HEVC_NAL_FD_NUT:\n        break;\n    default:\n        av_log(s->avctx, AV_LOG_INFO,\n               \"Skipping NAL unit %d\\n\", s->nal_unit_type);\n    }\n\n    return 0;\nfail:\n    if (s->avctx->err_recognition & AV_EF_EXPLODE)\n        return ret;\n    return 0;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 2926,
    "critical_vars": [
      "ret"
    ],
    "function": "decode_nal_unit",
    "filename": "FFmpeg/CVE-2019-11338/CVE-2019-11338_CWE-476_54655623a82632e7624714d7b2a3e039dc5faa7e_hevcdec.c.diff",
    "function_code": "static int decode_nal_unit(HEVCContext *s, const H2645NAL *nal)\n{\n    HEVCLocalContext *lc = s->HEVClc;\n    GetBitContext *gb    = &lc->gb;\n    int ctb_addr_ts, ret;\n\n    *gb              = nal->gb;\n    s->nal_unit_type = nal->type;\n    s->temporal_id   = nal->temporal_id;\n\n    switch (s->nal_unit_type) {\n    case HEVC_NAL_VPS:\n        if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {\n            ret = s->avctx->hwaccel->decode_params(s->avctx,\n                                                   nal->type,\n                                                   nal->raw_data,\n                                                   nal->raw_size);\n            if (ret < 0)\n                goto fail;\n        }\n        ret = ff_hevc_decode_nal_vps(gb, s->avctx, &s->ps);\n        if (ret < 0)\n            goto fail;\n        break;\n    case HEVC_NAL_SPS:\n        if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {\n            ret = s->avctx->hwaccel->decode_params(s->avctx,\n                                                   nal->type,\n                                                   nal->raw_data,\n                                                   nal->raw_size);\n            if (ret < 0)\n                goto fail;\n        }\n        ret = ff_hevc_decode_nal_sps(gb, s->avctx, &s->ps,\n                                     s->apply_defdispwin);\n        if (ret < 0)\n            goto fail;\n        break;\n    case HEVC_NAL_PPS:\n        if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {\n            ret = s->avctx->hwaccel->decode_params(s->avctx,\n                                                   nal->type,\n                                                   nal->raw_data,\n                                                   nal->raw_size);\n            if (ret < 0)\n                goto fail;\n        }\n        ret = ff_hevc_decode_nal_pps(gb, s->avctx, &s->ps);\n        if (ret < 0)\n            goto fail;\n        break;\n    case HEVC_NAL_SEI_PREFIX:\n    case HEVC_NAL_SEI_SUFFIX:\n        if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {\n            ret = s->avctx->hwaccel->decode_params(s->avctx,\n                                                   nal->type,\n                                                   nal->raw_data,\n                                                   nal->raw_size);\n            if (ret < 0)\n                goto fail;\n        }\n        ret = ff_hevc_decode_nal_sei(gb, s->avctx, &s->sei, &s->ps, s->nal_unit_type);\n        if (ret < 0)\n            goto fail;\n        break;\n    case HEVC_NAL_TRAIL_R:\n    case HEVC_NAL_TRAIL_N:\n    case HEVC_NAL_TSA_N:\n    case HEVC_NAL_TSA_R:\n    case HEVC_NAL_STSA_N:\n    case HEVC_NAL_STSA_R:\n    case HEVC_NAL_BLA_W_LP:\n    case HEVC_NAL_BLA_W_RADL:\n    case HEVC_NAL_BLA_N_LP:\n    case HEVC_NAL_IDR_W_RADL:\n    case HEVC_NAL_IDR_N_LP:\n    case HEVC_NAL_CRA_NUT:\n    case HEVC_NAL_RADL_N:\n    case HEVC_NAL_RADL_R:\n    case HEVC_NAL_RASL_N:\n    case HEVC_NAL_RASL_R:\n        ret = hls_slice_header(s);\n        if (ret < 0)\n            return ret;\n        if (ret == 1) {\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n\n\n        if (\n            (s->avctx->skip_frame >= AVDISCARD_BIDIR && s->sh.slice_type == HEVC_SLICE_B) ||\n            (s->avctx->skip_frame >= AVDISCARD_NONINTRA && s->sh.slice_type != HEVC_SLICE_I) ||\n            (s->avctx->skip_frame >= AVDISCARD_NONKEY && !IS_IRAP(s))) {\n            break;\n        }\n\n        if (s->sh.first_slice_in_pic_flag) {\n            if (s->max_ra == INT_MAX) {\n                if (s->nal_unit_type == HEVC_NAL_CRA_NUT || IS_BLA(s)) {\n                    s->max_ra = s->poc;\n                } else {\n                    if (IS_IDR(s))\n                        s->max_ra = INT_MIN;\n                }\n            }\n\n            if ((s->nal_unit_type == HEVC_NAL_RASL_R || s->nal_unit_type == HEVC_NAL_RASL_N) &&\n                s->poc <= s->max_ra) {\n                s->is_decoded = 0;\n                break;\n            } else {\n                if (s->nal_unit_type == HEVC_NAL_RASL_R && s->poc > s->max_ra)\n                    s->max_ra = INT_MIN;\n            }\n\n            s->overlap ++;\n            ret = hevc_frame_start(s);\n            if (ret < 0)\n                return ret;\n        } else if (!s->ref) {\n            av_log(s->avctx, AV_LOG_ERROR, \"First slice in a frame missing.\\n\");\n            goto fail;\n        }\n\n        if (s->nal_unit_type != s->first_nal_type) {\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"Non-matching NAL types of the VCL NALUs: %d %d\\n\",\n                   s->first_nal_type, s->nal_unit_type);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (!s->sh.dependent_slice_segment_flag &&\n            s->sh.slice_type != HEVC_SLICE_I) {\n            ret = ff_hevc_slice_rpl(s);\n            if (ret < 0) {\n                av_log(s->avctx, AV_LOG_WARNING,\n                       \"Error constructing the reference lists for the current slice.\\n\");\n                goto fail;\n            }\n        }\n\n        if (s->sh.first_slice_in_pic_flag && s->avctx->hwaccel) {\n            ret = s->avctx->hwaccel->start_frame(s->avctx, NULL, 0);\n            if (ret < 0)\n                goto fail;\n        }\n\n        if (s->avctx->hwaccel) {\n            ret = s->avctx->hwaccel->decode_slice(s->avctx, nal->raw_data, nal->raw_size);\n            if (ret < 0)\n                goto fail;\n        } else {\n            if (s->threads_number > 1 && s->sh.num_entry_point_offsets > 0)\n                ctb_addr_ts = hls_slice_data_wpp(s, nal);\n            else\n                ctb_addr_ts = hls_slice_data(s);\n            if (ctb_addr_ts >= (s->ps.sps->ctb_width * s->ps.sps->ctb_height)) {\n                s->is_decoded = 1;\n            }\n\n            if (ctb_addr_ts < 0) {\n                ret = ctb_addr_ts;\n                goto fail;\n            }\n        }\n        break;\n    case HEVC_NAL_EOS_NUT:\n    case HEVC_NAL_EOB_NUT:\n        s->seq_decode = (s->seq_decode + 1) & 0xff;\n        s->max_ra     = INT_MAX;\n        break;\n    case HEVC_NAL_AUD:\n    case HEVC_NAL_FD_NUT:\n        break;\n    default:\n        av_log(s->avctx, AV_LOG_INFO,\n               \"Skipping NAL unit %d\\n\", s->nal_unit_type);\n    }\n\n    return 0;\nfail:\n    if (s->avctx->err_recognition & AV_EF_EXPLODE)\n        return ret;\n    return 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 165,
    "critical_vars": [
      "err"
    ],
    "function": "avpriv_ac3_parse_header",
    "filename": "FFmpeg/CVE-2018-13303/CVE-2018-13303_CWE-476_00e8181bd97c834fe60751b0c511d4bb97875f78_ac3_parser.c.diff",
    "function_code": "int avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *buf,\n                            size_t size)\n{\n    GetBitContext gb;\n    AC3HeaderInfo *hdr;\n    int err;\n\n    if (!*phdr)\n        *phdr = av_mallocz(sizeof(AC3HeaderInfo));\n    if (!*phdr)\n        return AVERROR(ENOMEM);\n    hdr = *phdr;\n\n    err = init_get_bits8(&gb, buf, size);\n    if (err < 0)\n        return AVERROR_INVALIDDATA;\n    err = ff_ac3_parse_header(&gb, hdr);\n    if (err < 0)\n        return AVERROR_INVALIDDATA;\n\n    return get_bits_count(&gb);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 3214,
    "critical_vars": [
      "s",
      "gb"
    ],
    "function": "ff_mpeg4_decode_picture_header",
    "filename": "FFmpeg/CVE-2018-13301/CVE-2018-13301_CWE-476_2aa9047486dbff12d9e040f917e5f799ed2fd78b_mpeg4videodec.c.diff",
    "function_code": "int ff_mpeg4_decode_picture_header(Mpeg4DecContext *ctx, GetBitContext *gb)\n{\n    MpegEncContext *s = &ctx->m;\n    unsigned startcode, v;\n    int ret;\n    int vol = 0;\n\n    /* search next start code */\n    align_get_bits(gb);\n\n    // If we have not switched to studio profile than we also did not switch bps\n    // that means something else (like a previous instance) outside set bps which\n    // would be inconsistant with the currect state, thus reset it\n    if (!s->studio_profile && s->avctx->bits_per_raw_sample != 8)\n        s->avctx->bits_per_raw_sample = 0;\n\n    if (s->codec_tag == AV_RL32(\"WV1F\") && show_bits(gb, 24) == 0x575630) {\n        skip_bits(gb, 24);\n        if (get_bits(gb, 8) == 0xF0)\n            goto end;\n    }\n\n    startcode = 0xff;\n    for (;;) {\n        if (get_bits_count(gb) >= gb->size_in_bits) {\n            if (gb->size_in_bits == 8 &&\n                (ctx->divx_version >= 0 || ctx->xvid_build >= 0) || s->codec_tag == AV_RL32(\"QMP4\")) {\n                av_log(s->avctx, AV_LOG_VERBOSE, \"frame skip %d\\n\", gb->size_in_bits);\n                return FRAME_SKIPPED;  // divx bug\n            } else\n                return AVERROR_INVALIDDATA;  // end of stream\n        }\n\n        /* use the bits after the test */\n        v = get_bits(gb, 8);\n        startcode = ((startcode << 8) | v) & 0xffffffff;\n\n        if ((startcode & 0xFFFFFF00) != 0x100)\n            continue;  // no startcode\n\n        if (s->avctx->debug & FF_DEBUG_STARTCODE) {\n            av_log(s->avctx, AV_LOG_DEBUG, \"startcode: %3X \", startcode);\n            if (startcode <= 0x11F)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Video Object Start\");\n            else if (startcode <= 0x12F)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Video Object Layer Start\");\n            else if (startcode <= 0x13F)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Reserved\");\n            else if (startcode <= 0x15F)\n                av_log(s->avctx, AV_LOG_DEBUG, \"FGS bp start\");\n            else if (startcode <= 0x1AF)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Reserved\");\n            else if (startcode == 0x1B0)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Seq Start\");\n            else if (startcode == 0x1B1)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Seq End\");\n            else if (startcode == 0x1B2)\n                av_log(s->avctx, AV_LOG_DEBUG, \"User Data\");\n            else if (startcode == 0x1B3)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Group of VOP start\");\n            else if (startcode == 0x1B4)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Video Session Error\");\n            else if (startcode == 0x1B5)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Start\");\n            else if (startcode == 0x1B6)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Video Object Plane start\");\n            else if (startcode == 0x1B7)\n                av_log(s->avctx, AV_LOG_DEBUG, \"slice start\");\n            else if (startcode == 0x1B8)\n                av_log(s->avctx, AV_LOG_DEBUG, \"extension start\");\n            else if (startcode == 0x1B9)\n                av_log(s->avctx, AV_LOG_DEBUG, \"fgs start\");\n            else if (startcode == 0x1BA)\n                av_log(s->avctx, AV_LOG_DEBUG, \"FBA Object start\");\n            else if (startcode == 0x1BB)\n                av_log(s->avctx, AV_LOG_DEBUG, \"FBA Object Plane start\");\n            else if (startcode == 0x1BC)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Mesh Object start\");\n            else if (startcode == 0x1BD)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Mesh Object Plane start\");\n            else if (startcode == 0x1BE)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Still Texture Object start\");\n            else if (startcode == 0x1BF)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Texture Spatial Layer start\");\n            else if (startcode == 0x1C0)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Texture SNR Layer start\");\n            else if (startcode == 0x1C1)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Texture Tile start\");\n            else if (startcode == 0x1C2)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Texture Shape Layer start\");\n            else if (startcode == 0x1C3)\n                av_log(s->avctx, AV_LOG_DEBUG, \"stuffing start\");\n            else if (startcode <= 0x1C5)\n                av_log(s->avctx, AV_LOG_DEBUG, \"reserved\");\n            else if (startcode <= 0x1FF)\n                av_log(s->avctx, AV_LOG_DEBUG, \"System start\");\n            av_log(s->avctx, AV_LOG_DEBUG, \" at %d\\n\", get_bits_count(gb));\n        }\n\n        if (startcode >= 0x120 && startcode <= 0x12F) {\n            if (vol) {\n                av_log(s->avctx, AV_LOG_WARNING, \"Ignoring multiple VOL headers\\n\");\n                continue;\n            }\n            vol++;\n            if ((ret = decode_vol_header(ctx, gb)) < 0)\n                return ret;\n        } else if (startcode == USER_DATA_STARTCODE) {\n            decode_user_data(ctx, gb);\n        } else if (startcode == GOP_STARTCODE) {\n            mpeg4_decode_gop_header(s, gb);\n        } else if (startcode == VOS_STARTCODE) {\n            mpeg4_decode_profile_level(s, gb);\n            if (s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&\n                (s->avctx->level > 0 && s->avctx->level < 9)) {\n                s->studio_profile = 1;\n                next_start_code_studio(gb);\n                extension_and_user_data(s, gb, 0);\n            }\n        } else if (startcode == VISUAL_OBJ_STARTCODE) {\n            if (s->studio_profile) {\n                if ((ret = decode_studiovisualobject(ctx, gb)) < 0)\n                    return ret;\n            } else\n                mpeg4_decode_visual_object(s, gb);\n        } else if (startcode == VOP_STARTCODE) {\n            break;\n        }\n\n        align_get_bits(gb);\n        startcode = 0xff;\n    }\n\nend:\n    if (s->avctx->flags & AV_CODEC_FLAG_LOW_DELAY)\n        s->low_delay = 1;\n    s->avctx->has_b_frames = !s->low_delay;\n\n    if (s->studio_profile) {\n        if (!s->avctx->bits_per_raw_sample) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Missing VOL header\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        return decode_studio_vop_header(ctx, gb);\n    } else\n        return decode_vop_header(ctx, gb);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 3214,
    "critical_vars": [
      "profile",
      "level"
    ],
    "function": "ff_mpeg4_decode_picture_header",
    "filename": "FFmpeg/CVE-2018-13301/CVE-2018-13301_CWE-476_2aa9047486dbff12d9e040f917e5f799ed2fd78b_mpeg4videodec.c.diff",
    "function_code": "int ff_mpeg4_decode_picture_header(Mpeg4DecContext *ctx, GetBitContext *gb)\n{\n    MpegEncContext *s = &ctx->m;\n    unsigned startcode, v;\n    int ret;\n    int vol = 0;\n\n    /* search next start code */\n    align_get_bits(gb);\n\n    // If we have not switched to studio profile than we also did not switch bps\n    // that means something else (like a previous instance) outside set bps which\n    // would be inconsistant with the currect state, thus reset it\n    if (!s->studio_profile && s->avctx->bits_per_raw_sample != 8)\n        s->avctx->bits_per_raw_sample = 0;\n\n    if (s->codec_tag == AV_RL32(\"WV1F\") && show_bits(gb, 24) == 0x575630) {\n        skip_bits(gb, 24);\n        if (get_bits(gb, 8) == 0xF0)\n            goto end;\n    }\n\n    startcode = 0xff;\n    for (;;) {\n        if (get_bits_count(gb) >= gb->size_in_bits) {\n            if (gb->size_in_bits == 8 &&\n                (ctx->divx_version >= 0 || ctx->xvid_build >= 0) || s->codec_tag == AV_RL32(\"QMP4\")) {\n                av_log(s->avctx, AV_LOG_VERBOSE, \"frame skip %d\\n\", gb->size_in_bits);\n                return FRAME_SKIPPED;  // divx bug\n            } else\n                return AVERROR_INVALIDDATA;  // end of stream\n        }\n\n        /* use the bits after the test */\n        v = get_bits(gb, 8);\n        startcode = ((startcode << 8) | v) & 0xffffffff;\n\n        if ((startcode & 0xFFFFFF00) != 0x100)\n            continue;  // no startcode\n\n        if (s->avctx->debug & FF_DEBUG_STARTCODE) {\n            av_log(s->avctx, AV_LOG_DEBUG, \"startcode: %3X \", startcode);\n            if (startcode <= 0x11F)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Video Object Start\");\n            else if (startcode <= 0x12F)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Video Object Layer Start\");\n            else if (startcode <= 0x13F)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Reserved\");\n            else if (startcode <= 0x15F)\n                av_log(s->avctx, AV_LOG_DEBUG, \"FGS bp start\");\n            else if (startcode <= 0x1AF)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Reserved\");\n            else if (startcode == 0x1B0)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Seq Start\");\n            else if (startcode == 0x1B1)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Seq End\");\n            else if (startcode == 0x1B2)\n                av_log(s->avctx, AV_LOG_DEBUG, \"User Data\");\n            else if (startcode == 0x1B3)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Group of VOP start\");\n            else if (startcode == 0x1B4)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Video Session Error\");\n            else if (startcode == 0x1B5)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Start\");\n            else if (startcode == 0x1B6)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Video Object Plane start\");\n            else if (startcode == 0x1B7)\n                av_log(s->avctx, AV_LOG_DEBUG, \"slice start\");\n            else if (startcode == 0x1B8)\n                av_log(s->avctx, AV_LOG_DEBUG, \"extension start\");\n            else if (startcode == 0x1B9)\n                av_log(s->avctx, AV_LOG_DEBUG, \"fgs start\");\n            else if (startcode == 0x1BA)\n                av_log(s->avctx, AV_LOG_DEBUG, \"FBA Object start\");\n            else if (startcode == 0x1BB)\n                av_log(s->avctx, AV_LOG_DEBUG, \"FBA Object Plane start\");\n            else if (startcode == 0x1BC)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Mesh Object start\");\n            else if (startcode == 0x1BD)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Mesh Object Plane start\");\n            else if (startcode == 0x1BE)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Still Texture Object start\");\n            else if (startcode == 0x1BF)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Texture Spatial Layer start\");\n            else if (startcode == 0x1C0)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Texture SNR Layer start\");\n            else if (startcode == 0x1C1)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Texture Tile start\");\n            else if (startcode == 0x1C2)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Texture Shape Layer start\");\n            else if (startcode == 0x1C3)\n                av_log(s->avctx, AV_LOG_DEBUG, \"stuffing start\");\n            else if (startcode <= 0x1C5)\n                av_log(s->avctx, AV_LOG_DEBUG, \"reserved\");\n            else if (startcode <= 0x1FF)\n                av_log(s->avctx, AV_LOG_DEBUG, \"System start\");\n            av_log(s->avctx, AV_LOG_DEBUG, \" at %d\\n\", get_bits_count(gb));\n        }\n\n        if (startcode >= 0x120 && startcode <= 0x12F) {\n            if (vol) {\n                av_log(s->avctx, AV_LOG_WARNING, \"Ignoring multiple VOL headers\\n\");\n                continue;\n            }\n            vol++;\n            if ((ret = decode_vol_header(ctx, gb)) < 0)\n                return ret;\n        } else if (startcode == USER_DATA_STARTCODE) {\n            decode_user_data(ctx, gb);\n        } else if (startcode == GOP_STARTCODE) {\n            mpeg4_decode_gop_header(s, gb);\n        } else if (startcode == VOS_STARTCODE) {\n            int profile, level;\n            mpeg4_decode_profile_level(s, gb, &profile, &level);\n            if (profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&\n                (level > 0 && level < 9)) {\n                s->studio_profile = 1;\n                next_start_code_studio(gb);\n                extension_and_user_data(s, gb, 0);\n            } else if (s->studio_profile) {\n                avpriv_request_sample(s->avctx, \"Mixes studio and non studio profile\\n\");\n                return AVERROR_PATCHWELCOME;\n            }\n            s->avctx->profile = profile;\n            s->avctx->level   = level;\n        } else if (startcode == VISUAL_OBJ_STARTCODE) {\n            if (s->studio_profile) {\n                if ((ret = decode_studiovisualobject(ctx, gb)) < 0)\n                    return ret;\n            } else\n                mpeg4_decode_visual_object(s, gb);\n        } else if (startcode == VOP_STARTCODE) {\n            break;\n        }\n\n        align_get_bits(gb);\n        startcode = 0xff;\n    }\n\nend:\n    if (s->avctx->flags & AV_CODEC_FLAG_LOW_DELAY)\n        s->low_delay = 1;\n    s->avctx->has_b_frames = !s->low_delay;\n\n    if (s->studio_profile) {\n        av_assert0(s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);\n        if (!s->avctx->bits_per_raw_sample) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Missing VOL header\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        return decode_studio_vop_header(ctx, gb);\n    } else\n        return decode_vop_header(ctx, gb);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 2119,
    "critical_vars": [
      "frame->color_primaries"
    ],
    "function": "show_frame",
    "filename": "FFmpeg/CVE-2017-14225/CVE-2017-14225_CWE-476_837cb4325b712ff1aab531bf41668933f61d75d2_ffprobe.c.diff",
    "function_code": "static void show_frame(WriterContext *w, AVFrame *frame, AVStream *stream,\n                       AVFormatContext *fmt_ctx)\n{\n    AVBPrint pbuf;\n    char val_str[128];\n    const char *s;\n    int i;\n\n    av_bprint_init(&pbuf, 1, AV_BPRINT_SIZE_UNLIMITED);\n\n    writer_print_section_header(w, SECTION_ID_FRAME);\n\n    s = av_get_media_type_string(stream->codecpar->codec_type);\n    if (s) print_str    (\"media_type\", s);\n    else   print_str_opt(\"media_type\", \"unknown\");\n    print_int(\"stream_index\",           stream->index);\n    print_int(\"key_frame\",              frame->key_frame);\n    print_ts  (\"pkt_pts\",               frame->pts);\n    print_time(\"pkt_pts_time\",          frame->pts, &stream->time_base);\n    print_ts  (\"pkt_dts\",               frame->pkt_dts);\n    print_time(\"pkt_dts_time\",          frame->pkt_dts, &stream->time_base);\n    print_ts  (\"best_effort_timestamp\", frame->best_effort_timestamp);\n    print_time(\"best_effort_timestamp_time\", frame->best_effort_timestamp, &stream->time_base);\n    print_duration_ts  (\"pkt_duration\",      frame->pkt_duration);\n    print_duration_time(\"pkt_duration_time\", frame->pkt_duration, &stream->time_base);\n    if (frame->pkt_pos != -1) print_fmt    (\"pkt_pos\", \"%\"PRId64, frame->pkt_pos);\n    else                      print_str_opt(\"pkt_pos\", \"N/A\");\n    if (frame->pkt_size != -1) print_val    (\"pkt_size\", frame->pkt_size, unit_byte_str);\n    else                       print_str_opt(\"pkt_size\", \"N/A\");\n\n    switch (stream->codecpar->codec_type) {\n        AVRational sar;\n\n    case AVMEDIA_TYPE_VIDEO:\n        print_int(\"width\",                  frame->width);\n        print_int(\"height\",                 frame->height);\n        s = av_get_pix_fmt_name(frame->format);\n        if (s) print_str    (\"pix_fmt\", s);\n        else   print_str_opt(\"pix_fmt\", \"unknown\");\n        sar = av_guess_sample_aspect_ratio(fmt_ctx, stream, frame);\n        if (sar.num) {\n            print_q(\"sample_aspect_ratio\", sar, ':');\n        } else {\n            print_str_opt(\"sample_aspect_ratio\", \"N/A\");\n        }\n        print_fmt(\"pict_type\",              \"%c\", av_get_picture_type_char(frame->pict_type));\n        print_int(\"coded_picture_number\",   frame->coded_picture_number);\n        print_int(\"display_picture_number\", frame->display_picture_number);\n        print_int(\"interlaced_frame\",       frame->interlaced_frame);\n        print_int(\"top_field_first\",        frame->top_field_first);\n        print_int(\"repeat_pict\",            frame->repeat_pict);\n\n        if (frame->color_range != AVCOL_RANGE_UNSPECIFIED)\n            print_str(\"color_range\", av_color_range_name(frame->color_range));\n        else\n            print_str_opt(\"color_range\", av_color_range_name(frame->color_range));\n\n        if (frame->colorspace != AVCOL_SPC_UNSPECIFIED)\n            print_str(\"color_space\", av_color_space_name(frame->colorspace));\n        else\n            print_str_opt(\"color_space\", av_color_space_name(frame->colorspace));\n\n        if (frame->color_primaries != AVCOL_PRI_UNSPECIFIED)\n            print_str(\"color_primaries\", av_color_primaries_name(frame->color_primaries));\n        else\n            print_str_opt(\"color_primaries\", av_color_primaries_name(frame->color_primaries));\n\n        if (frame->color_trc != AVCOL_TRC_UNSPECIFIED)\n            print_str(\"color_transfer\", av_color_transfer_name(frame->color_trc));\n        else\n            print_str_opt(\"color_transfer\", av_color_transfer_name(frame->color_trc));\n\n        if (frame->chroma_location != AVCHROMA_LOC_UNSPECIFIED)\n            print_str(\"chroma_location\", av_chroma_location_name(frame->chroma_location));\n        else\n            print_str_opt(\"chroma_location\", av_chroma_location_name(frame->chroma_location));\n        break;\n\n    case AVMEDIA_TYPE_AUDIO:\n        s = av_get_sample_fmt_name(frame->format);\n        if (s) print_str    (\"sample_fmt\", s);\n        else   print_str_opt(\"sample_fmt\", \"unknown\");\n        print_int(\"nb_samples\",         frame->nb_samples);\n        print_int(\"channels\", frame->channels);\n        if (frame->channel_layout) {\n            av_bprint_clear(&pbuf);\n            av_bprint_channel_layout(&pbuf, frame->channels,\n                                     frame->channel_layout);\n            print_str    (\"channel_layout\", pbuf.str);\n        } else\n            print_str_opt(\"channel_layout\", \"unknown\");\n        break;\n    }\n    if (do_show_frame_tags)\n        show_tags(w, frame->metadata, SECTION_ID_FRAME_TAGS);\n    if (do_show_log)\n        show_log(w, SECTION_ID_FRAME_LOGS, SECTION_ID_FRAME_LOG, do_show_log);\n    if (frame->nb_side_data) {\n        writer_print_section_header(w, SECTION_ID_FRAME_SIDE_DATA_LIST);\n        for (i = 0; i < frame->nb_side_data; i++) {\n            AVFrameSideData *sd = frame->side_data[i];\n            const char *name;\n\n            writer_print_section_header(w, SECTION_ID_FRAME_SIDE_DATA);\n            name = av_frame_side_data_name(sd->type);\n            print_str(\"side_data_type\", name ? name : \"unknown\");\n            if (sd->type == AV_FRAME_DATA_DISPLAYMATRIX && sd->size >= 9*4) {\n                writer_print_integers(w, \"displaymatrix\", sd->data, 9, \" %11d\", 3, 4, 1);\n                print_int(\"rotation\", av_display_rotation_get((int32_t *)sd->data));\n            } else if (sd->type == AV_FRAME_DATA_GOP_TIMECODE && sd->size >= 8) {\n                char tcbuf[AV_TIMECODE_STR_SIZE];\n                av_timecode_make_mpeg_tc_string(tcbuf, *(int64_t *)(sd->data));\n                print_str(\"timecode\", tcbuf);\n            } else if (sd->type == AV_FRAME_DATA_MASTERING_DISPLAY_METADATA) {\n                AVMasteringDisplayMetadata *metadata = (AVMasteringDisplayMetadata *)sd->data;\n\n                if (metadata->has_primaries) {\n                    print_q(\"red_x\", metadata->display_primaries[0][0], '/');\n                    print_q(\"red_y\", metadata->display_primaries[0][1], '/');\n                    print_q(\"green_x\", metadata->display_primaries[1][0], '/');\n                    print_q(\"green_y\", metadata->display_primaries[1][1], '/');\n                    print_q(\"blue_x\", metadata->display_primaries[2][0], '/');\n                    print_q(\"blue_y\", metadata->display_primaries[2][1], '/');\n\n                    print_q(\"white_point_x\", metadata->white_point[0], '/');\n                    print_q(\"white_point_y\", metadata->white_point[1], '/');\n                }\n\n                if (metadata->has_luminance) {\n                    print_q(\"min_luminance\", metadata->min_luminance, '/');\n                    print_q(\"max_luminance\", metadata->max_luminance, '/');\n                }\n            } else if (sd->type == AV_FRAME_DATA_CONTENT_LIGHT_LEVEL) {\n                AVContentLightMetadata *metadata = (AVContentLightMetadata *)sd->data;\n                print_int(\"max_content\", metadata->MaxCLL);\n                print_int(\"max_average\", metadata->MaxFALL);\n            } else if (sd->type == AV_FRAME_DATA_ICC_PROFILE) {\n                AVDictionaryEntry *tag = av_dict_get(sd->metadata, \"name\", NULL, AV_DICT_MATCH_CASE);\n                if (tag)\n                    print_str(tag->key, tag->value);\n                print_int(\"size\", sd->size);\n            }\n            writer_print_section_footer(w);\n        }\n        writer_print_section_footer(w);\n    }\n\n    writer_print_section_footer(w);\n\n    av_bprint_finalize(&pbuf, NULL);\n    fflush(stdout);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 2129,
    "critical_vars": [
      "w",
      "frame->color_primaries"
    ],
    "function": "show_frame",
    "filename": "FFmpeg/CVE-2017-14225/CVE-2017-14225_CWE-476_837cb4325b712ff1aab531bf41668933f61d75d2_ffprobe.c.diff",
    "function_code": "static void show_frame(WriterContext *w, AVFrame *frame, AVStream *stream,\n                       AVFormatContext *fmt_ctx)\n{\n    AVBPrint pbuf;\n    char val_str[128];\n    const char *s;\n    int i;\n\n    av_bprint_init(&pbuf, 1, AV_BPRINT_SIZE_UNLIMITED);\n\n    writer_print_section_header(w, SECTION_ID_FRAME);\n\n    s = av_get_media_type_string(stream->codecpar->codec_type);\n    if (s) print_str    (\"media_type\", s);\n    else   print_str_opt(\"media_type\", \"unknown\");\n    print_int(\"stream_index\",           stream->index);\n    print_int(\"key_frame\",              frame->key_frame);\n    print_ts  (\"pkt_pts\",               frame->pts);\n    print_time(\"pkt_pts_time\",          frame->pts, &stream->time_base);\n    print_ts  (\"pkt_dts\",               frame->pkt_dts);\n    print_time(\"pkt_dts_time\",          frame->pkt_dts, &stream->time_base);\n    print_ts  (\"best_effort_timestamp\", frame->best_effort_timestamp);\n    print_time(\"best_effort_timestamp_time\", frame->best_effort_timestamp, &stream->time_base);\n    print_duration_ts  (\"pkt_duration\",      frame->pkt_duration);\n    print_duration_time(\"pkt_duration_time\", frame->pkt_duration, &stream->time_base);\n    if (frame->pkt_pos != -1) print_fmt    (\"pkt_pos\", \"%\"PRId64, frame->pkt_pos);\n    else                      print_str_opt(\"pkt_pos\", \"N/A\");\n    if (frame->pkt_size != -1) print_val    (\"pkt_size\", frame->pkt_size, unit_byte_str);\n    else                       print_str_opt(\"pkt_size\", \"N/A\");\n\n    switch (stream->codecpar->codec_type) {\n        AVRational sar;\n\n    case AVMEDIA_TYPE_VIDEO:\n        print_int(\"width\",                  frame->width);\n        print_int(\"height\",                 frame->height);\n        s = av_get_pix_fmt_name(frame->format);\n        if (s) print_str    (\"pix_fmt\", s);\n        else   print_str_opt(\"pix_fmt\", \"unknown\");\n        sar = av_guess_sample_aspect_ratio(fmt_ctx, stream, frame);\n        if (sar.num) {\n            print_q(\"sample_aspect_ratio\", sar, ':');\n        } else {\n            print_str_opt(\"sample_aspect_ratio\", \"N/A\");\n        }\n        print_fmt(\"pict_type\",              \"%c\", av_get_picture_type_char(frame->pict_type));\n        print_int(\"coded_picture_number\",   frame->coded_picture_number);\n        print_int(\"display_picture_number\", frame->display_picture_number);\n        print_int(\"interlaced_frame\",       frame->interlaced_frame);\n        print_int(\"top_field_first\",        frame->top_field_first);\n        print_int(\"repeat_pict\",            frame->repeat_pict);\n\n        if (frame->color_range != AVCOL_RANGE_UNSPECIFIED)\n            print_str(\"color_range\", av_color_range_name(frame->color_range));\n        else\n            print_str_opt(\"color_range\", av_color_range_name(frame->color_range));\n\n        if (frame->colorspace != AVCOL_SPC_UNSPECIFIED)\n            print_str(\"color_space\", av_color_space_name(frame->colorspace));\n        else\n            print_str_opt(\"color_space\", av_color_space_name(frame->colorspace));\n\n        print_primaries(w, frame->color_primaries);\n\n        if (frame->color_trc != AVCOL_TRC_UNSPECIFIED)\n            print_str(\"color_transfer\", av_color_transfer_name(frame->color_trc));\n        else\n            print_str_opt(\"color_transfer\", av_color_transfer_name(frame->color_trc));\n\n        if (frame->chroma_location != AVCHROMA_LOC_UNSPECIFIED)\n            print_str(\"chroma_location\", av_chroma_location_name(frame->chroma_location));\n        else\n            print_str_opt(\"chroma_location\", av_chroma_location_name(frame->chroma_location));\n        break;\n\n    case AVMEDIA_TYPE_AUDIO:\n        s = av_get_sample_fmt_name(frame->format);\n        if (s) print_str    (\"sample_fmt\", s);\n        else   print_str_opt(\"sample_fmt\", \"unknown\");\n        print_int(\"nb_samples\",         frame->nb_samples);\n        print_int(\"channels\", frame->channels);\n        if (frame->channel_layout) {\n            av_bprint_clear(&pbuf);\n            av_bprint_channel_layout(&pbuf, frame->channels,\n                                     frame->channel_layout);\n            print_str    (\"channel_layout\", pbuf.str);\n        } else\n            print_str_opt(\"channel_layout\", \"unknown\");\n        break;\n    }\n    if (do_show_frame_tags)\n        show_tags(w, frame->metadata, SECTION_ID_FRAME_TAGS);\n    if (do_show_log)\n        show_log(w, SECTION_ID_FRAME_LOGS, SECTION_ID_FRAME_LOG, do_show_log);\n    if (frame->nb_side_data) {\n        writer_print_section_header(w, SECTION_ID_FRAME_SIDE_DATA_LIST);\n        for (i = 0; i < frame->nb_side_data; i++) {\n            AVFrameSideData *sd = frame->side_data[i];\n            const char *name;\n\n            writer_print_section_header(w, SECTION_ID_FRAME_SIDE_DATA);\n            name = av_frame_side_data_name(sd->type);\n            print_str(\"side_data_type\", name ? name : \"unknown\");\n            if (sd->type == AV_FRAME_DATA_DISPLAYMATRIX && sd->size >= 9*4) {\n                writer_print_integers(w, \"displaymatrix\", sd->data, 9, \" %11d\", 3, 4, 1);\n                print_int(\"rotation\", av_display_rotation_get((int32_t *)sd->data));\n            } else if (sd->type == AV_FRAME_DATA_GOP_TIMECODE && sd->size >= 8) {\n                char tcbuf[AV_TIMECODE_STR_SIZE];\n                av_timecode_make_mpeg_tc_string(tcbuf, *(int64_t *)(sd->data));\n                print_str(\"timecode\", tcbuf);\n            } else if (sd->type == AV_FRAME_DATA_MASTERING_DISPLAY_METADATA) {\n                AVMasteringDisplayMetadata *metadata = (AVMasteringDisplayMetadata *)sd->data;\n\n                if (metadata->has_primaries) {\n                    print_q(\"red_x\", metadata->display_primaries[0][0], '/');\n                    print_q(\"red_y\", metadata->display_primaries[0][1], '/');\n                    print_q(\"green_x\", metadata->display_primaries[1][0], '/');\n                    print_q(\"green_y\", metadata->display_primaries[1][1], '/');\n                    print_q(\"blue_x\", metadata->display_primaries[2][0], '/');\n                    print_q(\"blue_y\", metadata->display_primaries[2][1], '/');\n\n                    print_q(\"white_point_x\", metadata->white_point[0], '/');\n                    print_q(\"white_point_y\", metadata->white_point[1], '/');\n                }\n\n                if (metadata->has_luminance) {\n                    print_q(\"min_luminance\", metadata->min_luminance, '/');\n                    print_q(\"max_luminance\", metadata->max_luminance, '/');\n                }\n            } else if (sd->type == AV_FRAME_DATA_CONTENT_LIGHT_LEVEL) {\n                AVContentLightMetadata *metadata = (AVContentLightMetadata *)sd->data;\n                print_int(\"max_content\", metadata->MaxCLL);\n                print_int(\"max_average\", metadata->MaxFALL);\n            } else if (sd->type == AV_FRAME_DATA_ICC_PROFILE) {\n                AVDictionaryEntry *tag = av_dict_get(sd->metadata, \"name\", NULL, AV_DICT_MATCH_CASE);\n                if (tag)\n                    print_str(tag->key, tag->value);\n                print_int(\"size\", sd->size);\n            }\n            writer_print_section_footer(w);\n        }\n        writer_print_section_footer(w);\n    }\n\n    writer_print_section_footer(w);\n\n    av_bprint_finalize(&pbuf, NULL);\n    fflush(stdout);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 2519,
    "critical_vars": [
      "par->color_primaries"
    ],
    "function": "show_stream",
    "filename": "FFmpeg/CVE-2017-14225/CVE-2017-14225_CWE-476_837cb4325b712ff1aab531bf41668933f61d75d2_ffprobe.c.diff",
    "function_code": "static int show_stream(WriterContext *w, AVFormatContext *fmt_ctx, int stream_idx, InputStream *ist, int in_program)\n{\n    AVStream *stream = ist->st;\n    AVCodecParameters *par;\n    AVCodecContext *dec_ctx;\n    char val_str[128];\n    const char *s;\n    AVRational sar, dar;\n    AVBPrint pbuf;\n    const AVCodecDescriptor *cd;\n    int ret = 0;\n    const char *profile = NULL;\n\n    av_bprint_init(&pbuf, 1, AV_BPRINT_SIZE_UNLIMITED);\n\n    writer_print_section_header(w, in_program ? SECTION_ID_PROGRAM_STREAM : SECTION_ID_STREAM);\n\n    print_int(\"index\", stream->index);\n\n    par     = stream->codecpar;\n    dec_ctx = ist->dec_ctx;\n    if (cd = avcodec_descriptor_get(par->codec_id)) {\n        print_str(\"codec_name\", cd->name);\n        if (!do_bitexact) {\n            print_str(\"codec_long_name\",\n                      cd->long_name ? cd->long_name : \"unknown\");\n        }\n    } else {\n        print_str_opt(\"codec_name\", \"unknown\");\n        if (!do_bitexact) {\n            print_str_opt(\"codec_long_name\", \"unknown\");\n        }\n    }\n\n    if (!do_bitexact && (profile = avcodec_profile_name(par->codec_id, par->profile)))\n        print_str(\"profile\", profile);\n    else {\n        if (par->profile != FF_PROFILE_UNKNOWN) {\n            char profile_num[12];\n            snprintf(profile_num, sizeof(profile_num), \"%d\", par->profile);\n            print_str(\"profile\", profile_num);\n        } else\n            print_str_opt(\"profile\", \"unknown\");\n    }\n\n    s = av_get_media_type_string(par->codec_type);\n    if (s) print_str    (\"codec_type\", s);\n    else   print_str_opt(\"codec_type\", \"unknown\");\n#if FF_API_LAVF_AVCTX\n    if (dec_ctx)\n        print_q(\"codec_time_base\", dec_ctx->time_base, '/');\n#endif\n\n    /* print AVI/FourCC tag */\n    print_str(\"codec_tag_string\",    av_fourcc2str(par->codec_tag));\n    print_fmt(\"codec_tag\", \"0x%04\"PRIx32, par->codec_tag);\n\n    switch (par->codec_type) {\n    case AVMEDIA_TYPE_VIDEO:\n        print_int(\"width\",        par->width);\n        print_int(\"height\",       par->height);\n        if (dec_ctx) {\n            print_int(\"coded_width\",  dec_ctx->coded_width);\n            print_int(\"coded_height\", dec_ctx->coded_height);\n        }\n        print_int(\"has_b_frames\", par->video_delay);\n        sar = av_guess_sample_aspect_ratio(fmt_ctx, stream, NULL);\n        if (sar.den) {\n            print_q(\"sample_aspect_ratio\", sar, ':');\n            av_reduce(&dar.num, &dar.den,\n                      par->width  * sar.num,\n                      par->height * sar.den,\n                      1024*1024);\n            print_q(\"display_aspect_ratio\", dar, ':');\n        } else {\n            print_str_opt(\"sample_aspect_ratio\", \"N/A\");\n            print_str_opt(\"display_aspect_ratio\", \"N/A\");\n        }\n        s = av_get_pix_fmt_name(par->format);\n        if (s) print_str    (\"pix_fmt\", s);\n        else   print_str_opt(\"pix_fmt\", \"unknown\");\n        print_int(\"level\",   par->level);\n        if (par->color_range != AVCOL_RANGE_UNSPECIFIED)\n            print_str    (\"color_range\", av_color_range_name(par->color_range));\n        else\n            print_str_opt(\"color_range\", \"N/A\");\n\n        if (par->color_space != AVCOL_SPC_UNSPECIFIED)\n            print_str(\"color_space\", av_color_space_name(par->color_space));\n        else\n            print_str_opt(\"color_space\", av_color_space_name(par->color_space));\n\n        if (par->color_trc != AVCOL_TRC_UNSPECIFIED)\n            print_str(\"color_transfer\", av_color_transfer_name(par->color_trc));\n        else\n            print_str_opt(\"color_transfer\", av_color_transfer_name(par->color_trc));\n\n        if (par->color_primaries != AVCOL_PRI_UNSPECIFIED)\n            print_str(\"color_primaries\", av_color_primaries_name(par->color_primaries));\n        else\n            print_str_opt(\"color_primaries\", av_color_primaries_name(par->color_primaries));\n\n        if (par->chroma_location != AVCHROMA_LOC_UNSPECIFIED)\n            print_str(\"chroma_location\", av_chroma_location_name(par->chroma_location));\n        else\n            print_str_opt(\"chroma_location\", av_chroma_location_name(par->chroma_location));\n\n        if (par->field_order == AV_FIELD_PROGRESSIVE)\n            print_str(\"field_order\", \"progressive\");\n        else if (par->field_order == AV_FIELD_TT)\n            print_str(\"field_order\", \"tt\");\n        else if (par->field_order == AV_FIELD_BB)\n            print_str(\"field_order\", \"bb\");\n        else if (par->field_order == AV_FIELD_TB)\n            print_str(\"field_order\", \"tb\");\n        else if (par->field_order == AV_FIELD_BT)\n            print_str(\"field_order\", \"bt\");\n        else\n            print_str_opt(\"field_order\", \"unknown\");\n\n#if FF_API_PRIVATE_OPT\n        if (dec_ctx && dec_ctx->timecode_frame_start >= 0) {\n            char tcbuf[AV_TIMECODE_STR_SIZE];\n            av_timecode_make_mpeg_tc_string(tcbuf, dec_ctx->timecode_frame_start);\n            print_str(\"timecode\", tcbuf);\n        } else {\n            print_str_opt(\"timecode\", \"N/A\");\n        }\n#endif\n        if (dec_ctx)\n            print_int(\"refs\", dec_ctx->refs);\n        break;\n\n    case AVMEDIA_TYPE_AUDIO:\n        s = av_get_sample_fmt_name(par->format);\n        if (s) print_str    (\"sample_fmt\", s);\n        else   print_str_opt(\"sample_fmt\", \"unknown\");\n        print_val(\"sample_rate\",     par->sample_rate, unit_hertz_str);\n        print_int(\"channels\",        par->channels);\n\n        if (par->channel_layout) {\n            av_bprint_clear(&pbuf);\n            av_bprint_channel_layout(&pbuf, par->channels, par->channel_layout);\n            print_str    (\"channel_layout\", pbuf.str);\n        } else {\n            print_str_opt(\"channel_layout\", \"unknown\");\n        }\n\n        print_int(\"bits_per_sample\", av_get_bits_per_sample(par->codec_id));\n        break;\n\n    case AVMEDIA_TYPE_SUBTITLE:\n        if (par->width)\n            print_int(\"width\",       par->width);\n        else\n            print_str_opt(\"width\",   \"N/A\");\n        if (par->height)\n            print_int(\"height\",      par->height);\n        else\n            print_str_opt(\"height\",  \"N/A\");\n        break;\n    }\n\n    if (dec_ctx && dec_ctx->codec && dec_ctx->codec->priv_class && show_private_data) {\n        const AVOption *opt = NULL;\n        while (opt = av_opt_next(dec_ctx->priv_data,opt)) {\n            uint8_t *str;\n            if (opt->flags) continue;\n            if (av_opt_get(dec_ctx->priv_data, opt->name, 0, &str) >= 0) {\n                print_str(opt->name, str);\n                av_free(str);\n            }\n        }\n    }\n\n    if (fmt_ctx->iformat->flags & AVFMT_SHOW_IDS) print_fmt    (\"id\", \"0x%x\", stream->id);\n    else                                          print_str_opt(\"id\", \"N/A\");\n    print_q(\"r_frame_rate\",   stream->r_frame_rate,   '/');\n    print_q(\"avg_frame_rate\", stream->avg_frame_rate, '/');\n    print_q(\"time_base\",      stream->time_base,      '/');\n    print_ts  (\"start_pts\",   stream->start_time);\n    print_time(\"start_time\",  stream->start_time, &stream->time_base);\n    print_ts  (\"duration_ts\", stream->duration);\n    print_time(\"duration\",    stream->duration, &stream->time_base);\n    if (par->bit_rate > 0)     print_val    (\"bit_rate\", par->bit_rate, unit_bit_per_second_str);\n    else                       print_str_opt(\"bit_rate\", \"N/A\");\n#if FF_API_LAVF_AVCTX\n    if (stream->codec->rc_max_rate > 0) print_val (\"max_bit_rate\", stream->codec->rc_max_rate, unit_bit_per_second_str);\n    else                                print_str_opt(\"max_bit_rate\", \"N/A\");\n#endif\n    if (dec_ctx && dec_ctx->bits_per_raw_sample > 0) print_fmt(\"bits_per_raw_sample\", \"%d\", dec_ctx->bits_per_raw_sample);\n    else                                             print_str_opt(\"bits_per_raw_sample\", \"N/A\");\n    if (stream->nb_frames) print_fmt    (\"nb_frames\", \"%\"PRId64, stream->nb_frames);\n    else                   print_str_opt(\"nb_frames\", \"N/A\");\n    if (nb_streams_frames[stream_idx])  print_fmt    (\"nb_read_frames\", \"%\"PRIu64, nb_streams_frames[stream_idx]);\n    else                                print_str_opt(\"nb_read_frames\", \"N/A\");\n    if (nb_streams_packets[stream_idx]) print_fmt    (\"nb_read_packets\", \"%\"PRIu64, nb_streams_packets[stream_idx]);\n    else                                print_str_opt(\"nb_read_packets\", \"N/A\");\n    if (do_show_data)\n        writer_print_data(w, \"extradata\", par->extradata,\n                                          par->extradata_size);\n    writer_print_data_hash(w, \"extradata_hash\", par->extradata,\n                                                par->extradata_size);\n\n    /* Print disposition information */\n#define PRINT_DISPOSITION(flagname, name) do {                                \\\n        print_int(name, !!(stream->disposition & AV_DISPOSITION_##flagname)); \\\n    } while (0)\n\n    if (do_show_stream_disposition) {\n    writer_print_section_header(w, in_program ? SECTION_ID_PROGRAM_STREAM_DISPOSITION : SECTION_ID_STREAM_DISPOSITION);\n    PRINT_DISPOSITION(DEFAULT,          \"default\");\n    PRINT_DISPOSITION(DUB,              \"dub\");\n    PRINT_DISPOSITION(ORIGINAL,         \"original\");\n    PRINT_DISPOSITION(COMMENT,          \"comment\");\n    PRINT_DISPOSITION(LYRICS,           \"lyrics\");\n    PRINT_DISPOSITION(KARAOKE,          \"karaoke\");\n    PRINT_DISPOSITION(FORCED,           \"forced\");\n    PRINT_DISPOSITION(HEARING_IMPAIRED, \"hearing_impaired\");\n    PRINT_DISPOSITION(VISUAL_IMPAIRED,  \"visual_impaired\");\n    PRINT_DISPOSITION(CLEAN_EFFECTS,    \"clean_effects\");\n    PRINT_DISPOSITION(ATTACHED_PIC,     \"attached_pic\");\n    PRINT_DISPOSITION(TIMED_THUMBNAILS, \"timed_thumbnails\");\n    writer_print_section_footer(w);\n    }\n\n    if (do_show_stream_tags)\n        ret = show_tags(w, stream->metadata, in_program ? SECTION_ID_PROGRAM_STREAM_TAGS : SECTION_ID_STREAM_TAGS);\n\n    if (stream->nb_side_data) {\n        print_pkt_side_data(w, stream->codecpar, stream->side_data, stream->nb_side_data,\n                            SECTION_ID_STREAM_SIDE_DATA_LIST,\n                            SECTION_ID_STREAM_SIDE_DATA);\n    }\n\n    writer_print_section_footer(w);\n    av_bprint_finalize(&pbuf, NULL);\n    fflush(stdout);\n\n    return ret;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Fun-Call",
    "line_new": 2526,
    "critical_vars": [
      "par->color_primaries",
      "w"
    ],
    "function": "show_stream",
    "filename": "FFmpeg/CVE-2017-14225/CVE-2017-14225_CWE-476_837cb4325b712ff1aab531bf41668933f61d75d2_ffprobe.c.diff",
    "function_code": "static int show_stream(WriterContext *w, AVFormatContext *fmt_ctx, int stream_idx, InputStream *ist, int in_program)\n{\n    AVStream *stream = ist->st;\n    AVCodecParameters *par;\n    AVCodecContext *dec_ctx;\n    char val_str[128];\n    const char *s;\n    AVRational sar, dar;\n    AVBPrint pbuf;\n    const AVCodecDescriptor *cd;\n    int ret = 0;\n    const char *profile = NULL;\n\n    av_bprint_init(&pbuf, 1, AV_BPRINT_SIZE_UNLIMITED);\n\n    writer_print_section_header(w, in_program ? SECTION_ID_PROGRAM_STREAM : SECTION_ID_STREAM);\n\n    print_int(\"index\", stream->index);\n\n    par     = stream->codecpar;\n    dec_ctx = ist->dec_ctx;\n    if (cd = avcodec_descriptor_get(par->codec_id)) {\n        print_str(\"codec_name\", cd->name);\n        if (!do_bitexact) {\n            print_str(\"codec_long_name\",\n                      cd->long_name ? cd->long_name : \"unknown\");\n        }\n    } else {\n        print_str_opt(\"codec_name\", \"unknown\");\n        if (!do_bitexact) {\n            print_str_opt(\"codec_long_name\", \"unknown\");\n        }\n    }\n\n    if (!do_bitexact && (profile = avcodec_profile_name(par->codec_id, par->profile)))\n        print_str(\"profile\", profile);\n    else {\n        if (par->profile != FF_PROFILE_UNKNOWN) {\n            char profile_num[12];\n            snprintf(profile_num, sizeof(profile_num), \"%d\", par->profile);\n            print_str(\"profile\", profile_num);\n        } else\n            print_str_opt(\"profile\", \"unknown\");\n    }\n\n    s = av_get_media_type_string(par->codec_type);\n    if (s) print_str    (\"codec_type\", s);\n    else   print_str_opt(\"codec_type\", \"unknown\");\n#if FF_API_LAVF_AVCTX\n    if (dec_ctx)\n        print_q(\"codec_time_base\", dec_ctx->time_base, '/');\n#endif\n\n    /* print AVI/FourCC tag */\n    print_str(\"codec_tag_string\",    av_fourcc2str(par->codec_tag));\n    print_fmt(\"codec_tag\", \"0x%04\"PRIx32, par->codec_tag);\n\n    switch (par->codec_type) {\n    case AVMEDIA_TYPE_VIDEO:\n        print_int(\"width\",        par->width);\n        print_int(\"height\",       par->height);\n        if (dec_ctx) {\n            print_int(\"coded_width\",  dec_ctx->coded_width);\n            print_int(\"coded_height\", dec_ctx->coded_height);\n        }\n        print_int(\"has_b_frames\", par->video_delay);\n        sar = av_guess_sample_aspect_ratio(fmt_ctx, stream, NULL);\n        if (sar.den) {\n            print_q(\"sample_aspect_ratio\", sar, ':');\n            av_reduce(&dar.num, &dar.den,\n                      par->width  * sar.num,\n                      par->height * sar.den,\n                      1024*1024);\n            print_q(\"display_aspect_ratio\", dar, ':');\n        } else {\n            print_str_opt(\"sample_aspect_ratio\", \"N/A\");\n            print_str_opt(\"display_aspect_ratio\", \"N/A\");\n        }\n        s = av_get_pix_fmt_name(par->format);\n        if (s) print_str    (\"pix_fmt\", s);\n        else   print_str_opt(\"pix_fmt\", \"unknown\");\n        print_int(\"level\",   par->level);\n        if (par->color_range != AVCOL_RANGE_UNSPECIFIED)\n            print_str    (\"color_range\", av_color_range_name(par->color_range));\n        else\n            print_str_opt(\"color_range\", \"N/A\");\n\n        if (par->color_space != AVCOL_SPC_UNSPECIFIED)\n            print_str(\"color_space\", av_color_space_name(par->color_space));\n        else\n            print_str_opt(\"color_space\", av_color_space_name(par->color_space));\n\n        if (par->color_trc != AVCOL_TRC_UNSPECIFIED)\n            print_str(\"color_transfer\", av_color_transfer_name(par->color_trc));\n        else\n            print_str_opt(\"color_transfer\", av_color_transfer_name(par->color_trc));\n\n        print_primaries(w, par->color_primaries);\n\n        if (par->chroma_location != AVCHROMA_LOC_UNSPECIFIED)\n            print_str(\"chroma_location\", av_chroma_location_name(par->chroma_location));\n        else\n            print_str_opt(\"chroma_location\", av_chroma_location_name(par->chroma_location));\n\n        if (par->field_order == AV_FIELD_PROGRESSIVE)\n            print_str(\"field_order\", \"progressive\");\n        else if (par->field_order == AV_FIELD_TT)\n            print_str(\"field_order\", \"tt\");\n        else if (par->field_order == AV_FIELD_BB)\n            print_str(\"field_order\", \"bb\");\n        else if (par->field_order == AV_FIELD_TB)\n            print_str(\"field_order\", \"tb\");\n        else if (par->field_order == AV_FIELD_BT)\n            print_str(\"field_order\", \"bt\");\n        else\n            print_str_opt(\"field_order\", \"unknown\");\n\n#if FF_API_PRIVATE_OPT\n        if (dec_ctx && dec_ctx->timecode_frame_start >= 0) {\n            char tcbuf[AV_TIMECODE_STR_SIZE];\n            av_timecode_make_mpeg_tc_string(tcbuf, dec_ctx->timecode_frame_start);\n            print_str(\"timecode\", tcbuf);\n        } else {\n            print_str_opt(\"timecode\", \"N/A\");\n        }\n#endif\n        if (dec_ctx)\n            print_int(\"refs\", dec_ctx->refs);\n        break;\n\n    case AVMEDIA_TYPE_AUDIO:\n        s = av_get_sample_fmt_name(par->format);\n        if (s) print_str    (\"sample_fmt\", s);\n        else   print_str_opt(\"sample_fmt\", \"unknown\");\n        print_val(\"sample_rate\",     par->sample_rate, unit_hertz_str);\n        print_int(\"channels\",        par->channels);\n\n        if (par->channel_layout) {\n            av_bprint_clear(&pbuf);\n            av_bprint_channel_layout(&pbuf, par->channels, par->channel_layout);\n            print_str    (\"channel_layout\", pbuf.str);\n        } else {\n            print_str_opt(\"channel_layout\", \"unknown\");\n        }\n\n        print_int(\"bits_per_sample\", av_get_bits_per_sample(par->codec_id));\n        break;\n\n    case AVMEDIA_TYPE_SUBTITLE:\n        if (par->width)\n            print_int(\"width\",       par->width);\n        else\n            print_str_opt(\"width\",   \"N/A\");\n        if (par->height)\n            print_int(\"height\",      par->height);\n        else\n            print_str_opt(\"height\",  \"N/A\");\n        break;\n    }\n\n    if (dec_ctx && dec_ctx->codec && dec_ctx->codec->priv_class && show_private_data) {\n        const AVOption *opt = NULL;\n        while (opt = av_opt_next(dec_ctx->priv_data,opt)) {\n            uint8_t *str;\n            if (opt->flags) continue;\n            if (av_opt_get(dec_ctx->priv_data, opt->name, 0, &str) >= 0) {\n                print_str(opt->name, str);\n                av_free(str);\n            }\n        }\n    }\n\n    if (fmt_ctx->iformat->flags & AVFMT_SHOW_IDS) print_fmt    (\"id\", \"0x%x\", stream->id);\n    else                                          print_str_opt(\"id\", \"N/A\");\n    print_q(\"r_frame_rate\",   stream->r_frame_rate,   '/');\n    print_q(\"avg_frame_rate\", stream->avg_frame_rate, '/');\n    print_q(\"time_base\",      stream->time_base,      '/');\n    print_ts  (\"start_pts\",   stream->start_time);\n    print_time(\"start_time\",  stream->start_time, &stream->time_base);\n    print_ts  (\"duration_ts\", stream->duration);\n    print_time(\"duration\",    stream->duration, &stream->time_base);\n    if (par->bit_rate > 0)     print_val    (\"bit_rate\", par->bit_rate, unit_bit_per_second_str);\n    else                       print_str_opt(\"bit_rate\", \"N/A\");\n#if FF_API_LAVF_AVCTX\n    if (stream->codec->rc_max_rate > 0) print_val (\"max_bit_rate\", stream->codec->rc_max_rate, unit_bit_per_second_str);\n    else                                print_str_opt(\"max_bit_rate\", \"N/A\");\n#endif\n    if (dec_ctx && dec_ctx->bits_per_raw_sample > 0) print_fmt(\"bits_per_raw_sample\", \"%d\", dec_ctx->bits_per_raw_sample);\n    else                                             print_str_opt(\"bits_per_raw_sample\", \"N/A\");\n    if (stream->nb_frames) print_fmt    (\"nb_frames\", \"%\"PRId64, stream->nb_frames);\n    else                   print_str_opt(\"nb_frames\", \"N/A\");\n    if (nb_streams_frames[stream_idx])  print_fmt    (\"nb_read_frames\", \"%\"PRIu64, nb_streams_frames[stream_idx]);\n    else                                print_str_opt(\"nb_read_frames\", \"N/A\");\n    if (nb_streams_packets[stream_idx]) print_fmt    (\"nb_read_packets\", \"%\"PRIu64, nb_streams_packets[stream_idx]);\n    else                                print_str_opt(\"nb_read_packets\", \"N/A\");\n    if (do_show_data)\n        writer_print_data(w, \"extradata\", par->extradata,\n                                          par->extradata_size);\n    writer_print_data_hash(w, \"extradata_hash\", par->extradata,\n                                                par->extradata_size);\n\n    /* Print disposition information */\n#define PRINT_DISPOSITION(flagname, name) do {                                \\\n        print_int(name, !!(stream->disposition & AV_DISPOSITION_##flagname)); \\\n    } while (0)\n\n    if (do_show_stream_disposition) {\n    writer_print_section_header(w, in_program ? SECTION_ID_PROGRAM_STREAM_DISPOSITION : SECTION_ID_STREAM_DISPOSITION);\n    PRINT_DISPOSITION(DEFAULT,          \"default\");\n    PRINT_DISPOSITION(DUB,              \"dub\");\n    PRINT_DISPOSITION(ORIGINAL,         \"original\");\n    PRINT_DISPOSITION(COMMENT,          \"comment\");\n    PRINT_DISPOSITION(LYRICS,           \"lyrics\");\n    PRINT_DISPOSITION(KARAOKE,          \"karaoke\");\n    PRINT_DISPOSITION(FORCED,           \"forced\");\n    PRINT_DISPOSITION(HEARING_IMPAIRED, \"hearing_impaired\");\n    PRINT_DISPOSITION(VISUAL_IMPAIRED,  \"visual_impaired\");\n    PRINT_DISPOSITION(CLEAN_EFFECTS,    \"clean_effects\");\n    PRINT_DISPOSITION(ATTACHED_PIC,     \"attached_pic\");\n    PRINT_DISPOSITION(TIMED_THUMBNAILS, \"timed_thumbnails\");\n    writer_print_section_footer(w);\n    }\n\n    if (do_show_stream_tags)\n        ret = show_tags(w, stream->metadata, in_program ? SECTION_ID_PROGRAM_STREAM_TAGS : SECTION_ID_STREAM_TAGS);\n\n    if (stream->nb_side_data) {\n        print_pkt_side_data(w, stream->codecpar, stream->side_data, stream->nb_side_data,\n                            SECTION_ID_STREAM_SIDE_DATA_LIST,\n                            SECTION_ID_STREAM_SIDE_DATA);\n    }\n\n    writer_print_section_footer(w);\n    av_bprint_finalize(&pbuf, NULL);\n    fflush(stdout);\n\n    return ret;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 1038,
    "critical_vars": [
      "offset"
    ],
    "function": "MergeTrack",
    "filename": "gpac/CVE-2021-31260/CVE-2021-31260_CWE-476_df8fffd839fe5ae9acd82d26fd48280a397411d9_track.c.diff",
    "function_code": "GF_Err MergeTrack(GF_TrackBox *trak, GF_TrackFragmentBox *traf, GF_MovieFragmentBox *moof_box, u64 moof_offset, s32 compressed_diff, u64 *cumulated_offset, Bool is_first_merge)\n{\n\tu32 i, j, chunk_size, track_num;\n\tu64 base_offset, data_offset, traf_duration;\n\tu32 def_duration, DescIndex, def_size, def_flags;\n\tu32 duration, size, flags, prev_trun_data_offset, sample_index;\n\tu8 pad, sync;\n\tu16 degr;\n\tBool first_samp_in_traf=GF_TRUE;\n\tBool store_traf_map=GF_FALSE;\n\tu8 *moof_template=NULL;\n\tu32 moof_template_size=0;\n\tBool is_seg_start = GF_FALSE;\n\tu64 seg_start=0, sidx_start=0, sidx_end=0, frag_start=0, last_dts=0;\n\tGF_TrackFragmentRunBox *trun;\n\tGF_TrunEntry *ent;\n#ifdef GF_ENABLE_CTRN\n\tGF_TrackFragmentBox *traf_ref = NULL;\n#endif\n\n\tGF_Err stbl_AppendTime(GF_SampleTableBox *stbl, u32 duration, u32 nb_pack);\n\tGF_Err stbl_AppendSize(GF_SampleTableBox *stbl, u32 size, u32 nb_pack);\n\tGF_Err stbl_AppendChunk(GF_SampleTableBox *stbl, u64 offset);\n\tGF_Err stbl_AppendSampleToChunk(GF_SampleTableBox *stbl, u32 DescIndex, u32 samplesInChunk);\n\tGF_Err stbl_AppendCTSOffset(GF_SampleTableBox *stbl, s32 CTSOffset);\n\tGF_Err stbl_AppendRAP(GF_SampleTableBox *stbl, u8 isRap);\n\tGF_Err stbl_AppendPadding(GF_SampleTableBox *stbl, u8 padding);\n\tGF_Err stbl_AppendDegradation(GF_SampleTableBox *stbl, u16 DegradationPriority);\n\n\tif (trak->Header->trackID != traf->tfhd->trackID) return GF_OK;\n\tif (!trak->Media->information->sampleTable\n\t\t|| !trak->Media->information->sampleTable->SampleSize\n\t\t|| !trak->Media->information->sampleTable->TimeToSample\n\t\t|| !trak->Media->information->sampleTable->SampleToChunk\n\t\t|| !trak->Media->information->sampleTable->ChunkOffset\n\t) {\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tif (!traf->trex->track)\n\t\ttraf->trex->track = trak;\n\n\t//setup all our defaults\n\tDescIndex = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_DESC) ? traf->tfhd->sample_desc_index : traf->trex->def_sample_desc_index;\n\tif (!DescIndex) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] default sample description set to 0, likely broken ! Fixing to 1\\n\" ));\n\t\tDescIndex = 1;\n\t} else if (DescIndex > gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] default sample description set to %d but only %d sample description(s), likely broken ! Fixing to 1\\n\", DescIndex, gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes)));\n\t\tDescIndex = 1;\n\t}\n#ifdef GF_ENABLE_CTRN\n\tif (traf->trex->inherit_from_traf_id) {\n\t\tu32 traf_count = gf_list_count(moof_box->TrackList);\n\t\tfor (i=0; i<traf_count; i++) {\n\t\t\tGF_TrackFragmentBox *atraf = gf_list_get(moof_box->TrackList, i);\n\t\t\tif (atraf->tfhd && atraf->tfhd->trackID==traf->trex->inherit_from_traf_id) {\n\t\t\t\ttraf_ref = atraf;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tdef_duration = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_DUR) ? traf->tfhd->def_sample_duration : traf->trex->def_sample_duration;\n\tdef_size = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_SIZE) ? traf->tfhd->def_sample_size : traf->trex->def_sample_size;\n\tdef_flags = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_FLAGS) ? traf->tfhd->def_sample_flags : traf->trex->def_sample_flags;\n\n\t//locate base offset, by default use moof (dash-like)\n\tbase_offset = moof_offset;\n\t//explicit base offset, use it\n\tif (traf->tfhd->flags & GF_ISOM_TRAF_BASE_OFFSET)\n\t\tbase_offset = traf->tfhd->base_data_offset;\n\t//no moof offset and no explicit offset, the offset is the end of the last written chunk of\n\t//the previous traf. For the first traf, *cumulated_offset is actually moof offset\n\telse if (!(traf->tfhd->flags & GF_ISOM_MOOF_BASE_OFFSET))\n\t\tbase_offset = *cumulated_offset;\n\n\tchunk_size = 0;\n\tprev_trun_data_offset = 0;\n\tdata_offset = 0;\n\ttraf_duration = 0;\n\n\t/*in playback mode*/\n\tif (traf->tfdt && is_first_merge) {\n#ifndef GPAC_DISABLE_LOG\n\t\tif (trak->moov->mov->NextMoofNumber && trak->present_in_scalable_segment && trak->sample_count_at_seg_start && (trak->dts_at_seg_start != traf->tfdt->baseMediaDecodeTime)) {\n\t\t\ts32 drift = (s32) ((s64) traf->tfdt->baseMediaDecodeTime - (s64)trak->dts_at_seg_start);\n\t\t\tif (drift<0)  {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Warning: TFDT timing \"LLD\" less than cumulated timing \"LLD\" - using tfdt\\n\", traf->tfdt->baseMediaDecodeTime, trak->dts_at_seg_start ));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[iso file] TFDT timing \"LLD\" higher than cumulated timing \"LLD\" (last sample got extended in duration)\\n\", traf->tfdt->baseMediaDecodeTime, trak->dts_at_seg_start ));\n\t\t\t}\n\t\t}\n#endif\n\t\ttrak->dts_at_seg_start = traf->tfdt->baseMediaDecodeTime;\n\t}\n\telse if (traf->tfxd) {\n\t\ttrak->dts_at_seg_start = traf->tfxd->absolute_time_in_track_timescale;\n\t}\n\n\tif (traf->tfxd) {\n\t\ttrak->last_tfxd_value = traf->tfxd->absolute_time_in_track_timescale;\n\t\ttrak->last_tfxd_value += traf->tfxd->fragment_duration_in_track_timescale;\n\t}\n\tif (traf->tfrf) {\n\t\tif (trak->tfrf) gf_isom_box_del_parent(&trak->child_boxes, (GF_Box *)trak->tfrf);\n\t\ttrak->tfrf = traf->tfrf;\n\t\tgf_list_del_item(traf->child_boxes, traf->tfrf);\n\t\tgf_list_add(trak->child_boxes, trak->tfrf);\n\t}\n\n\tif (trak->moov->mov->signal_frag_bounds) {\n\t\tstore_traf_map = GF_TRUE;\n\t\tif (is_first_merge) {\n\t\t\tGF_MovieFragmentBox *moof_clone = NULL;\n\t\t\tgf_isom_box_freeze_order((GF_Box *)moof_box);\n\t\t\tgf_isom_clone_box((GF_Box *)moof_box, (GF_Box **)&moof_clone);\n\n\t\t\tif (moof_clone) {\n\t\t\t\tGF_BitStream *bs;\n\t\t\t\tfor (i=0; i<gf_list_count(moof_clone->TrackList); i++) {\n\t\t\t\t\tGF_TrackFragmentBox *traf_clone = gf_list_get(moof_clone->TrackList, i);\n\t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->TrackRuns);\n\t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sampleGroups);\n\t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sampleGroupsDescription);\n\t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sub_samples);\n\t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sai_offsets);\n\t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sai_sizes);\n\t\t\t\t\tif (traf_clone->sample_encryption) {\n\t\t\t\t\t\tgf_isom_box_del_parent(&traf_clone->child_boxes, (GF_Box *) traf_clone->sample_encryption);\n\t\t\t\t\t\ttraf_clone->sample_encryption = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif (traf_clone->sdtp) {\n\t\t\t\t\t\tgf_isom_box_del_parent(&traf_clone->child_boxes, (GF_Box *) traf_clone->sdtp);\n\t\t\t\t\t\ttraf_clone->sdtp = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_isom_box_size((GF_Box *)moof_clone);\n\t\t\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\t\t\t\tif (trak->moov->mov->seg_styp) {\n\t\t\t\t\tgf_isom_box_size(trak->moov->mov->seg_styp);\n\t\t\t\t\tgf_isom_box_write(trak->moov->mov->seg_styp, bs);\n\t\t\t\t}\n\t\t\t\tif (trak->moov->mov->root_sidx) {\n\t\t\t\t\tgf_isom_box_size((GF_Box *)trak->moov->mov->root_sidx);\n\t\t\t\t\tgf_isom_box_write((GF_Box *)trak->moov->mov->root_sidx, bs);\n\t\t\t\t}\n\t\t\t\tif (trak->moov->mov->seg_ssix) {\n\t\t\t\t\tgf_isom_box_size(trak->moov->mov->seg_ssix);\n\t\t\t\t\tgf_isom_box_write(trak->moov->mov->seg_ssix, bs);\n\t\t\t\t}\n\t\t\t\tgf_isom_box_write((GF_Box *)moof_clone, bs);\n\t\t\t\tgf_isom_box_del((GF_Box*)moof_clone);\n\n\t\t\t\tgf_bs_get_content(bs, &moof_template, &moof_template_size);\n\t\t\t\tgf_bs_del(bs);\n\t\t\t}\n\t\t}\n\t\tif (trak->moov->mov->seg_styp) {\n\t\t\tis_seg_start = GF_TRUE;\n\t\t\tseg_start = trak->moov->mov->styp_start_offset;\n\t\t}\n\t\tif (trak->moov->mov->root_sidx) {\n\t\t\tis_seg_start = GF_TRUE;\n\t\t\tsidx_start = trak->moov->mov->sidx_start_offset;\n\t\t\tsidx_end = trak->moov->mov->sidx_end_offset;\n\t\t\tif (! seg_start || (sidx_start<seg_start))\n\t\t\t\tseg_start = sidx_start;\n\t\t}\n\t\tfrag_start = trak->moov->mov->current_top_box_start;\n\t}\n\telse if (trak->moov->mov->store_traf_map) {\n\t\tstore_traf_map = GF_TRUE;\n\t}\n\n\n\tsample_index = 0;\n\ti=0;\n\twhile ((trun = (GF_TrackFragmentRunBox *)gf_list_enum(traf->TrackRuns, &i))) {\n\t\t//merge the run\n\t\tfor (j=0; j<trun->sample_count; j++) {\n\t\t\tGF_Err e;\n\t\t\ts32 cts_offset=0;\n\t\t\tif (j<trun->nb_samples) {\n\t\t\t\tent = &trun->samples[j];\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Track %d doesn't have enough trun entries (%d) compared to sample count (%d) in run\\n\", traf->trex->trackID, trun->nb_samples, trun->sample_count ));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsize = def_size;\n\t\t\tduration = def_duration;\n\t\t\tflags = def_flags;\n\n\t\t\t//CTS - if flag not set (trun or ctrn) defaults to 0 which is the base value after alloc\n\t\t\t//we just need to overrite its value if inherited\n\t\t\tcts_offset = ent->CTS_Offset;\n\n#ifdef GF_ENABLE_CTRN\n\t\t\tif (trun->use_ctrn) {\n\t\t\t\tif (!j && (trun->ctrn_flags & GF_ISOM_CTRN_FIRST_SAMPLE) ) {\n\t\t\t\t\tif (trun->ctrn_first_dur) duration = ent->Duration;\n\t\t\t\t\tif (trun->ctrn_first_size) size = ent->size;\n\t\t\t\t\tif (trun->ctrn_first_ctts) flags = ent->flags;\n\t\t\t\t} else {\n\t\t\t\t\tif (trun->ctrn_dur) duration = ent->Duration;\n\t\t\t\t\tif (trun->ctrn_size) size = ent->size;\n\t\t\t\t\tif (trun->ctrn_sample_flags) flags = ent->flags;\n\t\t\t\t}\n\t\t\t\t/*re-override*/\n\t\t\t\tif (trun->ctrn_flags & 0xF0) {\n\t\t\t\t\tGF_TrunEntry *ref_entry;\n\t\t\t\t\tif (!traf_ref) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Track %d use traf inheritance to track ID %d but reference traf not found\\n\", traf->trex->trackID, traf->trex->inherit_from_traf_id ));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tref_entry = traf_get_sample_entry(traf_ref, sample_index);\n\t\t\t\t\tif (!ref_entry) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Track %d use traf inheritance but sample %d not found in reference traf\\n\", traf->trex->trackID, sample_index+1 ));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_DUR)\n\t\t\t\t\t\tduration = ref_entry->Duration;\n\t\t\t\t\tif (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_SIZE)\n\t\t\t\t\t\tsize = ref_entry->size;\n\t\t\t\t\tif (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_FLAGS)\n\t\t\t\t\t\tflags = ref_entry->flags;\n\t\t\t\t\tif (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_CTSO)\n\t\t\t\t\t\tcts_offset = ref_entry->CTS_Offset;\n\t\t\t\t}\n\n\t\t\t} else\n#endif\n\t\t\t{\n\t\t\t\tif (trun->flags & GF_ISOM_TRUN_DURATION) duration = ent->Duration;\n\t\t\t\tif (trun->flags & GF_ISOM_TRUN_SIZE) size = ent->size;\n\t\t\t\tif (trun->flags & GF_ISOM_TRUN_FLAGS) {\n\t\t\t\t\tflags = ent->flags;\n\t\t\t\t} else if (!j && (trun->flags & GF_ISOM_TRUN_FIRST_FLAG)) {\n\t\t\t\t\tflags = trun->first_sample_flags;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsample_index++;\n\t\t\t/*store the resolved value in case we have inheritance*/\n\t\t\tent->size = size;\n\t\t\tent->Duration = duration;\n\t\t\tent->flags = flags;\n\t\t\tent->CTS_Offset = cts_offset;\n\n\t\t\tlast_dts += duration;\n\n\t\t\t//add size first\n\t\t\tif (!trak->Media->information->sampleTable->SampleSize) {\n\t\t\t\ttrak->Media->information->sampleTable->SampleSize = (GF_SampleSizeBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STSZ);\n\t\t\t\tif (!trak->Media->information->sampleTable->SampleSize)\n\t\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\te = stbl_AppendSize(trak->Media->information->sampleTable, size, ent->nb_pack);\n\t\t\tif (e) return e;\n\n\t\t\t//then TS\n\t\t\tif (!trak->Media->information->sampleTable->TimeToSample) {\n\t\t\t\ttrak->Media->information->sampleTable->TimeToSample = (GF_TimeToSampleBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STTS);\n\t\t\t\tif (!trak->Media->information->sampleTable->TimeToSample)\n\t\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\te = stbl_AppendTime(trak->Media->information->sampleTable, duration, ent->nb_pack);\n\t\t\tif (e) return e;\n\n\t\t\t//add chunk on first sample\n\t\t\tif (!j) {\n\t\t\t\tu64 final_offset;\n\t\t\t\tdata_offset = base_offset;\n\t\t\t\t//we have an explicit data offset for this trun\n\t\t\t\tif (trun->flags & GF_ISOM_TRUN_DATA_OFFSET) {\n\t\t\t\t\tdata_offset += trun->data_offset;\n\t\t\t\t\t/*reset chunk size since data is now relative to this trun*/\n\t\t\t\t\tchunk_size = 0;\n\t\t\t\t\t/*remember this data offset for following trun*/\n\t\t\t\t\tprev_trun_data_offset = trun->data_offset;\n\t\t\t\t\t/*if mdat is located after the moof, and the moof was compressed, adjust offset\n\t\t\t\t\totherwise the offset does not need adjustment*/\n\t\t\t\t\tif (trun->data_offset>=0) {\n\t\t\t\t\t\tdata_offset -= compressed_diff;\n\t\t\t\t\t\tprev_trun_data_offset -= compressed_diff;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//we had an explicit data offset for the previous trun, use it + chunk size\n\t\t\t\telse if (prev_trun_data_offset) {\n\t\t\t\t\t/*data offset is previous chunk size plus previous offset of the trun*/\n\t\t\t\t\tdata_offset += prev_trun_data_offset + chunk_size;\n\t\t\t\t}\n\t\t\t\t//no explicit data offset, continuous data after last data in previous chunk\n\t\t\t\telse {\n\t\t\t\t\tdata_offset += chunk_size;\n\t\t\t\t\t//data offset of first trun in first traf, adjust if compressed moof\n\t\t\t\t\tif ((i==1) && (trun->data_offset>=0)) {\n\t\t\t\t\t\tdata_offset -= compressed_diff;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfinal_offset = data_offset;\n\t\t\t\t//adjust offset if moov was also compressed and we are still in the same file\n\t\t\t\t//so that later call to gf_isom_get_sample properly adjust back the offset\n\t\t\t\tif (trak->moov->compressed_diff) {\n\t\t\t\t\tfinal_offset += trak->moov->compressed_diff;\n\t\t\t\t}\n\n\t\t\t\tif (!trak->Media->information->sampleTable->ChunkOffset) {\n\t\t\t\t\ttrak->Media->information->sampleTable->ChunkOffset = gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STCO);\n\t\t\t\t\tif (!trak->Media->information->sampleTable->ChunkOffset)\n\t\t\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t\te = stbl_AppendChunk(trak->Media->information->sampleTable, final_offset);\n\t\t\t\tif (e) return e;\n\t\t\t\t//then sampleToChunk\n\t\t\t\tif (!trak->Media->information->sampleTable->SampleToChunk) {\n\t\t\t\t\ttrak->Media->information->sampleTable->SampleToChunk = (GF_SampleToChunkBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STSC);\n\t\t\t\t\tif (!trak->Media->information->sampleTable->SampleToChunk)\n\t\t\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t\te = stbl_AppendSampleToChunk(trak->Media->information->sampleTable,\n\t\t\t\t                         DescIndex, trun->sample_count);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t\tchunk_size += size;\n\n\t\t\tif (store_traf_map && first_samp_in_traf) {\n\t\t\t\tfirst_samp_in_traf = GF_FALSE;\n\t\t\t\te = stbl_AppendTrafMap(trak->Media->information->sampleTable, is_seg_start, seg_start, frag_start, moof_template, moof_template_size, sidx_start, sidx_end);\n\t\t\t\tif (e) return e;\n\t\t\t\t//do not deallocate, the memory is now owned by traf map\n\t\t\t\tmoof_template = NULL;\n\t\t\t\tmoof_template_size = 0;\n\t\t\t}\n\t\t\tif (ent->nb_pack>1) {\n\t\t\t\tj+= ent->nb_pack-1;\n\t\t\t\ttraf_duration += ent->nb_pack*duration;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttraf_duration += duration;\n\n\t\t\te = stbl_AppendCTSOffset(trak->Media->information->sampleTable, cts_offset);\n\t\t\tif (e) return e;\n\t\t\t//flags\n\t\t\tsync = GF_ISOM_GET_FRAG_SYNC(flags);\n\t\t\tif (trak->Media->information->sampleTable->no_sync_found && sync) {\n\t\t\t\ttrak->Media->information->sampleTable->no_sync_found = 0;\n\t\t\t}\n\t\t\te = stbl_AppendRAP(trak->Media->information->sampleTable, sync);\n\t\t\tif (e) return e;\n\t\t\tpad = GF_ISOM_GET_FRAG_PAD(flags);\n\t\t\tif (pad) {\n\t\t\t\te = stbl_AppendPadding(trak->Media->information->sampleTable, pad);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t\tdegr = GF_ISOM_GET_FRAG_DEG(flags);\n\t\t\tif (degr) {\n\t\t\t\te = stbl_AppendDegradation(trak->Media->information->sampleTable, degr);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t\te = stbl_AppendDependencyType(trak->Media->information->sampleTable, GF_ISOM_GET_FRAG_LEAD(flags), GF_ISOM_GET_FRAG_DEPENDS(flags), GF_ISOM_GET_FRAG_DEPENDED(flags), GF_ISOM_GET_FRAG_REDUNDANT(flags));\n\t\t\tif (e) return e;\n\t\t}\n\t}\n\n\tif (trak->moov->mov->is_smooth && !traf->tfdt && !traf->tfxd) {\n\t\tif (is_first_merge)\n\t\t\ttrak->dts_at_seg_start = trak->dts_at_next_seg_start;\n\t\ttrak->dts_at_next_seg_start += last_dts;\n\t}\n\tif (traf_duration && trak->editBox && trak->editBox->editList) {\n\t\tfor (i=0; i<gf_list_count(trak->editBox->editList->entryList); i++) {\n\t\t\tGF_EdtsEntry *edts_e = gf_list_get(trak->editBox->editList->entryList, i);\n\t\t\tif (edts_e->was_empty_dur) {\n\t\t\t\tu64 extend_dur = traf_duration;\n\t\t\t\textend_dur *= trak->moov->mvhd->timeScale;\n\t\t\t\textend_dur /= trak->Media->mediaHeader->timeScale;\n\t\t\t\tedts_e->segmentDuration += extend_dur;\n\t\t\t}\n\t\t\telse if (!edts_e->segmentDuration) {\n\t\t\t\tedts_e->was_empty_dur = GF_TRUE;\n\t\t\t\tif ((s64) traf_duration > edts_e->mediaTime)\n\t\t\t\t\ttraf_duration -= edts_e->mediaTime;\n\t\t\t\telse\n\t\t\t\t\ttraf_duration = 0;\n\n\t\t\t\tedts_e->segmentDuration = traf_duration;\n\t\t\t\tedts_e->segmentDuration *= trak->moov->mvhd->timeScale;\n\t\t\t\tedts_e->segmentDuration /= trak->Media->mediaHeader->timeScale;\n\t\t\t}\n\n\t\t}\n\t}\n\n\t//in any case, update the cumulated offset\n\t//this will handle hypothetical files mixing MOOF offset and implicit non-moof offset\n\t*cumulated_offset = data_offset + chunk_size;\n\n\t/*merge sample groups*/\n\tif (traf->sampleGroups) {\n\t\tGF_List *groups;\n\t\tGF_List *groupDescs;\n\t\tBool is_identical_sgpd = GF_TRUE;\n\t\tu32 *new_idx = NULL, new_idx_count=0;\n\n\t\tif (!trak->Media->information->sampleTable->sampleGroups)\n\t\t\ttrak->Media->information->sampleTable->sampleGroups = gf_list_new();\n\n\t\tif (!trak->Media->information->sampleTable->sampleGroupsDescription)\n\t\t\ttrak->Media->information->sampleTable->sampleGroupsDescription = gf_list_new();\n\n\t\tgroupDescs = trak->Media->information->sampleTable->sampleGroupsDescription;\n\t\tfor (i=0; i<gf_list_count(traf->sampleGroupsDescription); i++) {\n\t\t\tGF_SampleGroupDescriptionBox *new_sgdesc = NULL;\n\t\t\tGF_SampleGroupDescriptionBox *sgdesc = gf_list_get(traf->sampleGroupsDescription, i);\n\t\t\tfor (j=0; j<gf_list_count(groupDescs); j++) {\n\t\t\t\tnew_sgdesc = gf_list_get(groupDescs, j);\n\t\t\t\tif (new_sgdesc->grouping_type==sgdesc->grouping_type) break;\n\t\t\t\tnew_sgdesc = NULL;\n\t\t\t}\n\t\t\t/*new description, move it to our sample table*/\n\t\t\tif (!new_sgdesc) {\n\t\t\t\tgf_list_add(groupDescs, sgdesc);\n\t\t\t\tgf_list_add(trak->Media->information->sampleTable->child_boxes, sgdesc);\n\t\t\t\tgf_list_rem(traf->sampleGroupsDescription, i);\n\t\t\t\tgf_list_del_item(traf->child_boxes, sgdesc);\n\t\t\t\ti--;\n\t\t\t}\n\t\t\t/*merge descriptions*/\n\t\t\telse {\n\t\t\t\tu32 count;\n\n\t\t\t\tis_identical_sgpd = gf_isom_is_identical_sgpd(new_sgdesc, sgdesc, 0);\n\t\t\t\tif (is_identical_sgpd)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tnew_idx_count = gf_list_count(sgdesc->group_descriptions);\n\t\t\t\tnew_idx = (u32 *)gf_malloc(new_idx_count * sizeof(u32));\n\t\t\t\tif (!new_idx) return GF_OUT_OF_MEM;\n\n\t\t\t\tcount = 0;\n\t\t\t\twhile (gf_list_count(sgdesc->group_descriptions)) {\n\t\t\t\t\tvoid *sgpd_entry = gf_list_get(sgdesc->group_descriptions, 0);\n\t\t\t\t\tBool new_entry = GF_TRUE;\n\n\t\t\t\t\tfor (j = 0; j < gf_list_count(new_sgdesc->group_descriptions); j++) {\n\t\t\t\t\t\tvoid *ptr = gf_list_get(new_sgdesc->group_descriptions, j);\n\t\t\t\t\t\tif (gf_isom_is_identical_sgpd(sgpd_entry, ptr, new_sgdesc->grouping_type)) {\n\t\t\t\t\t\t\tnew_idx[count] = j + 1;\n\t\t\t\t\t\t\tcount ++;\n\t\t\t\t\t\t\tnew_entry = GF_FALSE;\n\t\t\t\t\t\t\tgf_free(sgpd_entry);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (new_entry) {\n\t\t\t\t\t\tgf_list_add(new_sgdesc->group_descriptions, sgpd_entry);\n\t\t\t\t\t\tnew_idx[count] = gf_list_count(new_sgdesc->group_descriptions);\n\t\t\t\t\t\tcount ++;\n\t\t\t\t\t}\n\n\t\t\t\t\tgf_list_rem(sgdesc->group_descriptions, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tgroups = trak->Media->information->sampleTable->sampleGroups;\n\t\tfor (i=0; i<gf_list_count(traf->sampleGroups); i++) {\n\t\t\tGF_SampleGroupBox *stbl_group = NULL;\n\t\t\tGF_SampleGroupBox *frag_group = gf_list_get(traf->sampleGroups, i);\n\n\n\t\t\tfor (j=0; j<gf_list_count(groups); j++) {\n\t\t\t\tstbl_group = gf_list_get(groups, j);\n\t\t\t\tif ((frag_group->grouping_type==stbl_group->grouping_type) && (frag_group->grouping_type_parameter==stbl_group->grouping_type_parameter))\n\t\t\t\t\tbreak;\n\t\t\t\tstbl_group = NULL;\n\t\t\t}\n\t\t\tif (!stbl_group) {\n\t\t\t\tstbl_group = (GF_SampleGroupBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_SBGP);\n\t\t\t\tif (!stbl_group) return GF_OUT_OF_MEM;\n\t\t\t\tstbl_group->grouping_type = frag_group->grouping_type;\n\t\t\t\tstbl_group->grouping_type_parameter = frag_group->grouping_type_parameter;\n\t\t\t\tstbl_group->version = frag_group->version;\n\t\t\t\tgf_list_add(groups, stbl_group);\n\t\t\t}\n\n\t\t\tif (is_identical_sgpd) {\n\t\t\t\t//adjust sgpd index: in traf index start at 0x1001\n\t\t\t\tfor (j = 0; j < frag_group->entry_count; j++)\n\t\t\t\t\tfrag_group->sample_entries[j].group_description_index &= 0x0FFFF;\n\t\t\t\tif (frag_group->entry_count && stbl_group->entry_count &&\n\t\t\t\t        (frag_group->sample_entries[0].group_description_index==stbl_group->sample_entries[stbl_group->entry_count-1].group_description_index)\n\t\t\t\t   ) {\n\t\t\t\t\tstbl_group->sample_entries[stbl_group->entry_count - 1].sample_count += frag_group->sample_entries[0].sample_count;\n\t\t\t\t\tif (frag_group->entry_count>1) {\n\t\t\t\t\t\tstbl_group->sample_entries = gf_realloc(stbl_group->sample_entries, sizeof(GF_SampleGroupEntry) * (stbl_group->entry_count + frag_group->entry_count - 1));\n\t\t\t\t\t\tmemcpy(&stbl_group->sample_entries[stbl_group->entry_count], &frag_group->sample_entries[1], sizeof(GF_SampleGroupEntry) * (frag_group->entry_count - 1));\n\t\t\t\t\t\tstbl_group->entry_count += frag_group->entry_count - 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tstbl_group->sample_entries = gf_realloc(stbl_group->sample_entries, sizeof(GF_SampleGroupEntry) * (stbl_group->entry_count + frag_group->entry_count));\n\t\t\t\t\tmemcpy(&stbl_group->sample_entries[stbl_group->entry_count], &frag_group->sample_entries[0], sizeof(GF_SampleGroupEntry) * frag_group->entry_count);\n\t\t\t\t\tstbl_group->entry_count += frag_group->entry_count;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstbl_group->sample_entries = gf_realloc(stbl_group->sample_entries, sizeof(GF_SampleGroupEntry) * (stbl_group->entry_count + frag_group->entry_count));\n\t\t\t\t//adjust sgpd index\n\t\t\t\tfor (j = 0; j < frag_group->entry_count; j++) {\n\t\t\t\t\tu32 sgidx = frag_group->sample_entries[j].group_description_index;\n\t\t\t\t\tif (sgidx > 0x10000) {\n\t\t\t\t\t\tsgidx -= 0x10001;\n\t\t\t\t\t\tif (sgidx>=new_idx_count) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[isobmf] corrupted sample group index in fragment %d but only %d group descriptions in fragment\\n\", sgidx, new_idx_count));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfrag_group->sample_entries[j].group_description_index = new_idx[sgidx];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmemcpy(&stbl_group->sample_entries[stbl_group->entry_count], &frag_group->sample_entries[0], sizeof(GF_SampleGroupEntry) * frag_group->entry_count);\n\t\t\t\tstbl_group->entry_count += frag_group->entry_count;\n\t\t\t}\n\t\t}\n\n\t\tif (new_idx) gf_free(new_idx);\n\t}\n\n\t/*content is encrypted*/\n\ttrack_num = gf_isom_get_tracknum_from_id(trak->moov, trak->Header->trackID);\n\tif (gf_isom_is_cenc_media(trak->moov->mov, track_num, DescIndex)\n\t\t|| traf->sample_encryption) {\n\t\t/*Merge sample auxiliary encryption information*/\n\t\tGF_SampleEncryptionBox *senc = NULL;\n\t\tu32 scheme_type;\n\t\tgf_isom_get_cenc_info(trak->moov->mov, track_num, DescIndex, NULL, &scheme_type, NULL);\n\n\t\tif (traf->sample_encryption) {\n\t\t\tfor (i = 0; i < gf_list_count(trak->Media->information->sampleTable->child_boxes); i++) {\n\t\t\t\tGF_Box *a = (GF_Box *)gf_list_get(trak->Media->information->sampleTable->child_boxes, i);\n\t\t\t\tif (a->type != traf->sample_encryption->type) continue;\n\n\t\t\t\tif ((a->type ==GF_ISOM_BOX_TYPE_UUID) && (((GF_UUIDBox *)a)->internal_4cc == GF_ISOM_BOX_UUID_PSEC)) {\n\t\t\t\t\tsenc = (GF_SampleEncryptionBox *)a;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (a->type ==GF_ISOM_BOX_TYPE_SENC) {\n\t\t\t\t\tsenc = (GF_SampleEncryptionBox *)a;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!senc && trak->sample_encryption)\n\t\t\t\tsenc = trak->sample_encryption;\n\n\t\t\tif (!senc) {\n\t\t\t\tif (traf->sample_encryption->piff_type==1) {\n\t\t\t\t\tsenc = (GF_SampleEncryptionBox *)gf_isom_create_piff_psec_box(1, 0x2, 0, 0, NULL);\n\t\t\t\t} else {\n\t\t\t\t\tsenc = gf_isom_create_samp_enc_box(1, 0x2);\n\t\t\t\t}\n\n\t\t\t\tif (!trak->Media->information->sampleTable->child_boxes) trak->Media->information->sampleTable->child_boxes = gf_list_new();\n\n\t\t\t\ttrak->sample_encryption = senc;\n\t\t\t\tif (!trak->child_boxes) trak->child_boxes = gf_list_new();\n\t\t\t\tgf_list_add(trak->child_boxes, senc);\n\t\t\t}\n\t\t}\n\n\t\t/*get sample auxiliary information by saiz/saio rather than by parsing senc box*/\n\t\tif (gf_isom_cenc_has_saiz_saio_traf(traf, scheme_type)) {\n\t\t\tu32 nb_saio;\n\t\t\tu32 aux_info_type;\n\t\t\tu64 offset;\n\t\t\tGF_Err e;\n\t\t\tBool is_encrypted;\n\t\t\tGF_SampleAuxiliaryInfoOffsetBox *saio = NULL;\n\t\t\tGF_SampleAuxiliaryInfoSizeBox *saiz = NULL;\n\n\t\t\toffset = nb_saio = 0;\n\n\t\t\tfor (i = 0; i < gf_list_count(traf->sai_offsets); i++) {\n\t\t\t\tsaio = (GF_SampleAuxiliaryInfoOffsetBox *)gf_list_get(traf->sai_offsets, i);\n\t\t\t\taux_info_type = saio->aux_info_type;\n\t\t\t\tif (!aux_info_type) aux_info_type = scheme_type;\n\n\t\t\t\t/*if we have only 1 sai_offsets, assume that its type is cenc*/\n\t\t\t\tif ((aux_info_type == GF_ISOM_CENC_SCHEME) || (aux_info_type == GF_ISOM_CBC_SCHEME) ||\n\t\t\t\t\t(aux_info_type == GF_ISOM_CENS_SCHEME) || (aux_info_type == GF_ISOM_CBCS_SCHEME) ||\n\t\t\t\t\t(gf_list_count(traf->sai_offsets) == 1)) {\n\t\t\t\t\toffset = saio->offsets[0] + moof_offset;\n\t\t\t\t\tnb_saio = saio->entry_count;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < gf_list_count(traf->sai_sizes); i++) {\n\t\t\t\tsaiz = (GF_SampleAuxiliaryInfoSizeBox *)gf_list_get(traf->sai_sizes, i);\n\t\t\t\taux_info_type = saiz->aux_info_type;\n\t\t\t\tif (!aux_info_type) aux_info_type = scheme_type;\n\t\t\t\t/*if we have only 1 sai_sizes, assume that its type is cenc*/\n\t\t\t\tif ((aux_info_type == GF_ISOM_CENC_SCHEME) || (aux_info_type == GF_ISOM_CBC_SCHEME) ||\n\t\t\t\t\t(aux_info_type == GF_ISOM_CENS_SCHEME) || (aux_info_type == GF_ISOM_CBCS_SCHEME) ||\n\t\t\t\t\t(gf_list_count(traf->sai_sizes) == 1)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (saiz && saio && senc) {\n\t\t\t\tfor (i = 0; i < saiz->sample_count; i++) {\n\t\t\t\t\tGF_CENCSampleAuxInfo *sai;\n\t\t\t\t\tconst u8 *key_info=NULL;\n\t\t\t\t\tu32 key_info_size;\n\t\t\t\t\tu64 cur_position;\n\t\t\t\t\tif (nb_saio != 1)\n\t\t\t\t\t\toffset = saio->offsets[i] + moof_offset;\n\t\t\t\t\tsize = saiz->default_sample_info_size ? saiz->default_sample_info_size : saiz->sample_info_size[i];\n\n\t\t\t\t\tcur_position = gf_bs_get_position(trak->moov->mov->movieFileMap->bs);\n\t\t\t\t\tgf_bs_seek(trak->moov->mov->movieFileMap->bs, offset);\n\n\t\t\t\t\tGF_SAFEALLOC(sai, GF_CENCSampleAuxInfo);\n\t\t\t\t\tif (!sai) return GF_OUT_OF_MEM;\n\n\t\t\t\t\te = gf_isom_get_sample_cenc_info_internal(trak, traf, senc, i+1, &is_encrypted, NULL, NULL, &key_info, &key_info_size);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[isobmf] could not get cenc info for sample %d: %s\\n\", i+1, gf_error_to_string(e) ));\n\t\t\t\t\t\treturn e;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (is_encrypted) {\n\t\t\t\t\t\tsai->cenc_data_size = size;\n\t\t\t\t\t\tsai->cenc_data = gf_malloc(sizeof(u8)*size);\n\t\t\t\t\t\tif (!sai->cenc_data) return GF_OUT_OF_MEM;\n\t\t\t\t\t\tgf_bs_read_data(trak->moov->mov->movieFileMap->bs, sai->cenc_data, sai->cenc_data_size);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsai->isNotProtected=1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (key_info) {\n\t\t\t\t\t\t//not multikey\n\t\t\t\t\t\tif (!key_info[0]) {\n\t\t\t\t\t\t\t//size greater than IV\n\t\t\t\t\t\t\tif (size > key_info[3])\n\t\t\t\t\t\t\t\tsenc->flags = 0x00000002;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//multikey, always use subsamples\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tsenc->flags = 0x00000002;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\n\t\t\t\t\tgf_bs_seek(trak->moov->mov->movieFileMap->bs, cur_position);\n\n\t\t\t\t\tgf_list_add(senc->samp_aux_info, sai);\n\n\t\t\t\t\te = gf_isom_cenc_merge_saiz_saio(senc, trak->Media->information->sampleTable, offset, size);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t\tif (nb_saio == 1)\n\t\t\t\t\t\toffset += size;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (traf->sample_encryption) {\n\t\t\tsenc_Parse(trak->moov->mov->movieFileMap->bs, trak, traf, traf->sample_encryption);\n\t\t\ttrak->sample_encryption->AlgorithmID = traf->sample_encryption->AlgorithmID;\n\t\t\tif (!trak->sample_encryption->IV_size)\n\t\t\t\ttrak->sample_encryption->IV_size = traf->sample_encryption->IV_size;\n\t\t\tif (!trak->sample_encryption->samp_aux_info) trak->sample_encryption->samp_aux_info = gf_list_new();\n\t\t\tgf_list_transfer(trak->sample_encryption->samp_aux_info, traf->sample_encryption->samp_aux_info);\n\t\t\tif (traf->sample_encryption->flags & 0x00000002)\n\t\t\t\ttrak->sample_encryption->flags |= 0x00000002;\n\t\t}\n\t}\n\treturn GF_OK;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1038,
    "critical_vars": [
      "saio->offsets",
      "saio->entry_count"
    ],
    "function": "MergeTrack",
    "filename": "gpac/CVE-2021-31260/CVE-2021-31260_CWE-476_df8fffd839fe5ae9acd82d26fd48280a397411d9_track.c.diff",
    "function_code": "GF_Err MergeTrack(GF_TrackBox *trak, GF_TrackFragmentBox *traf, GF_MovieFragmentBox *moof_box, u64 moof_offset, s32 compressed_diff, u64 *cumulated_offset, Bool is_first_merge)\n{\n\tu32 i, j, chunk_size, track_num;\n\tu64 base_offset, data_offset, traf_duration;\n\tu32 def_duration, DescIndex, def_size, def_flags;\n\tu32 duration, size, flags, prev_trun_data_offset, sample_index;\n\tu8 pad, sync;\n\tu16 degr;\n\tBool first_samp_in_traf=GF_TRUE;\n\tBool store_traf_map=GF_FALSE;\n\tu8 *moof_template=NULL;\n\tu32 moof_template_size=0;\n\tBool is_seg_start = GF_FALSE;\n\tu64 seg_start=0, sidx_start=0, sidx_end=0, frag_start=0, last_dts=0;\n\tGF_TrackFragmentRunBox *trun;\n\tGF_TrunEntry *ent;\n#ifdef GF_ENABLE_CTRN\n\tGF_TrackFragmentBox *traf_ref = NULL;\n#endif\n\n\tGF_Err stbl_AppendTime(GF_SampleTableBox *stbl, u32 duration, u32 nb_pack);\n\tGF_Err stbl_AppendSize(GF_SampleTableBox *stbl, u32 size, u32 nb_pack);\n\tGF_Err stbl_AppendChunk(GF_SampleTableBox *stbl, u64 offset);\n\tGF_Err stbl_AppendSampleToChunk(GF_SampleTableBox *stbl, u32 DescIndex, u32 samplesInChunk);\n\tGF_Err stbl_AppendCTSOffset(GF_SampleTableBox *stbl, s32 CTSOffset);\n\tGF_Err stbl_AppendRAP(GF_SampleTableBox *stbl, u8 isRap);\n\tGF_Err stbl_AppendPadding(GF_SampleTableBox *stbl, u8 padding);\n\tGF_Err stbl_AppendDegradation(GF_SampleTableBox *stbl, u16 DegradationPriority);\n\n\tif (trak->Header->trackID != traf->tfhd->trackID) return GF_OK;\n\tif (!trak->Media->information->sampleTable\n\t\t|| !trak->Media->information->sampleTable->SampleSize\n\t\t|| !trak->Media->information->sampleTable->TimeToSample\n\t\t|| !trak->Media->information->sampleTable->SampleToChunk\n\t\t|| !trak->Media->information->sampleTable->ChunkOffset\n\t) {\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tif (!traf->trex->track)\n\t\ttraf->trex->track = trak;\n\n\t//setup all our defaults\n\tDescIndex = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_DESC) ? traf->tfhd->sample_desc_index : traf->trex->def_sample_desc_index;\n\tif (!DescIndex) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] default sample description set to 0, likely broken ! Fixing to 1\\n\" ));\n\t\tDescIndex = 1;\n\t} else if (DescIndex > gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] default sample description set to %d but only %d sample description(s), likely broken ! Fixing to 1\\n\", DescIndex, gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes)));\n\t\tDescIndex = 1;\n\t}\n#ifdef GF_ENABLE_CTRN\n\tif (traf->trex->inherit_from_traf_id) {\n\t\tu32 traf_count = gf_list_count(moof_box->TrackList);\n\t\tfor (i=0; i<traf_count; i++) {\n\t\t\tGF_TrackFragmentBox *atraf = gf_list_get(moof_box->TrackList, i);\n\t\t\tif (atraf->tfhd && atraf->tfhd->trackID==traf->trex->inherit_from_traf_id) {\n\t\t\t\ttraf_ref = atraf;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tdef_duration = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_DUR) ? traf->tfhd->def_sample_duration : traf->trex->def_sample_duration;\n\tdef_size = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_SIZE) ? traf->tfhd->def_sample_size : traf->trex->def_sample_size;\n\tdef_flags = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_FLAGS) ? traf->tfhd->def_sample_flags : traf->trex->def_sample_flags;\n\n\t//locate base offset, by default use moof (dash-like)\n\tbase_offset = moof_offset;\n\t//explicit base offset, use it\n\tif (traf->tfhd->flags & GF_ISOM_TRAF_BASE_OFFSET)\n\t\tbase_offset = traf->tfhd->base_data_offset;\n\t//no moof offset and no explicit offset, the offset is the end of the last written chunk of\n\t//the previous traf. For the first traf, *cumulated_offset is actually moof offset\n\telse if (!(traf->tfhd->flags & GF_ISOM_MOOF_BASE_OFFSET))\n\t\tbase_offset = *cumulated_offset;\n\n\tchunk_size = 0;\n\tprev_trun_data_offset = 0;\n\tdata_offset = 0;\n\ttraf_duration = 0;\n\n\t/*in playback mode*/\n\tif (traf->tfdt && is_first_merge) {\n#ifndef GPAC_DISABLE_LOG\n\t\tif (trak->moov->mov->NextMoofNumber && trak->present_in_scalable_segment && trak->sample_count_at_seg_start && (trak->dts_at_seg_start != traf->tfdt->baseMediaDecodeTime)) {\n\t\t\ts32 drift = (s32) ((s64) traf->tfdt->baseMediaDecodeTime - (s64)trak->dts_at_seg_start);\n\t\t\tif (drift<0)  {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Warning: TFDT timing \"LLD\" less than cumulated timing \"LLD\" - using tfdt\\n\", traf->tfdt->baseMediaDecodeTime, trak->dts_at_seg_start ));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[iso file] TFDT timing \"LLD\" higher than cumulated timing \"LLD\" (last sample got extended in duration)\\n\", traf->tfdt->baseMediaDecodeTime, trak->dts_at_seg_start ));\n\t\t\t}\n\t\t}\n#endif\n\t\ttrak->dts_at_seg_start = traf->tfdt->baseMediaDecodeTime;\n\t}\n\telse if (traf->tfxd) {\n\t\ttrak->dts_at_seg_start = traf->tfxd->absolute_time_in_track_timescale;\n\t}\n\n\tif (traf->tfxd) {\n\t\ttrak->last_tfxd_value = traf->tfxd->absolute_time_in_track_timescale;\n\t\ttrak->last_tfxd_value += traf->tfxd->fragment_duration_in_track_timescale;\n\t}\n\tif (traf->tfrf) {\n\t\tif (trak->tfrf) gf_isom_box_del_parent(&trak->child_boxes, (GF_Box *)trak->tfrf);\n\t\ttrak->tfrf = traf->tfrf;\n\t\tgf_list_del_item(traf->child_boxes, traf->tfrf);\n\t\tgf_list_add(trak->child_boxes, trak->tfrf);\n\t}\n\n\tif (trak->moov->mov->signal_frag_bounds) {\n\t\tstore_traf_map = GF_TRUE;\n\t\tif (is_first_merge) {\n\t\t\tGF_MovieFragmentBox *moof_clone = NULL;\n\t\t\tgf_isom_box_freeze_order((GF_Box *)moof_box);\n\t\t\tgf_isom_clone_box((GF_Box *)moof_box, (GF_Box **)&moof_clone);\n\n\t\t\tif (moof_clone) {\n\t\t\t\tGF_BitStream *bs;\n\t\t\t\tfor (i=0; i<gf_list_count(moof_clone->TrackList); i++) {\n\t\t\t\t\tGF_TrackFragmentBox *traf_clone = gf_list_get(moof_clone->TrackList, i);\n\t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->TrackRuns);\n\t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sampleGroups);\n\t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sampleGroupsDescription);\n\t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sub_samples);\n\t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sai_offsets);\n\t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sai_sizes);\n\t\t\t\t\tif (traf_clone->sample_encryption) {\n\t\t\t\t\t\tgf_isom_box_del_parent(&traf_clone->child_boxes, (GF_Box *) traf_clone->sample_encryption);\n\t\t\t\t\t\ttraf_clone->sample_encryption = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif (traf_clone->sdtp) {\n\t\t\t\t\t\tgf_isom_box_del_parent(&traf_clone->child_boxes, (GF_Box *) traf_clone->sdtp);\n\t\t\t\t\t\ttraf_clone->sdtp = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_isom_box_size((GF_Box *)moof_clone);\n\t\t\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\t\t\t\tif (trak->moov->mov->seg_styp) {\n\t\t\t\t\tgf_isom_box_size(trak->moov->mov->seg_styp);\n\t\t\t\t\tgf_isom_box_write(trak->moov->mov->seg_styp, bs);\n\t\t\t\t}\n\t\t\t\tif (trak->moov->mov->root_sidx) {\n\t\t\t\t\tgf_isom_box_size((GF_Box *)trak->moov->mov->root_sidx);\n\t\t\t\t\tgf_isom_box_write((GF_Box *)trak->moov->mov->root_sidx, bs);\n\t\t\t\t}\n\t\t\t\tif (trak->moov->mov->seg_ssix) {\n\t\t\t\t\tgf_isom_box_size(trak->moov->mov->seg_ssix);\n\t\t\t\t\tgf_isom_box_write(trak->moov->mov->seg_ssix, bs);\n\t\t\t\t}\n\t\t\t\tgf_isom_box_write((GF_Box *)moof_clone, bs);\n\t\t\t\tgf_isom_box_del((GF_Box*)moof_clone);\n\n\t\t\t\tgf_bs_get_content(bs, &moof_template, &moof_template_size);\n\t\t\t\tgf_bs_del(bs);\n\t\t\t}\n\t\t}\n\t\tif (trak->moov->mov->seg_styp) {\n\t\t\tis_seg_start = GF_TRUE;\n\t\t\tseg_start = trak->moov->mov->styp_start_offset;\n\t\t}\n\t\tif (trak->moov->mov->root_sidx) {\n\t\t\tis_seg_start = GF_TRUE;\n\t\t\tsidx_start = trak->moov->mov->sidx_start_offset;\n\t\t\tsidx_end = trak->moov->mov->sidx_end_offset;\n\t\t\tif (! seg_start || (sidx_start<seg_start))\n\t\t\t\tseg_start = sidx_start;\n\t\t}\n\t\tfrag_start = trak->moov->mov->current_top_box_start;\n\t}\n\telse if (trak->moov->mov->store_traf_map) {\n\t\tstore_traf_map = GF_TRUE;\n\t}\n\n\n\tsample_index = 0;\n\ti=0;\n\twhile ((trun = (GF_TrackFragmentRunBox *)gf_list_enum(traf->TrackRuns, &i))) {\n\t\t//merge the run\n\t\tfor (j=0; j<trun->sample_count; j++) {\n\t\t\tGF_Err e;\n\t\t\ts32 cts_offset=0;\n\t\t\tif (j<trun->nb_samples) {\n\t\t\t\tent = &trun->samples[j];\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Track %d doesn't have enough trun entries (%d) compared to sample count (%d) in run\\n\", traf->trex->trackID, trun->nb_samples, trun->sample_count ));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsize = def_size;\n\t\t\tduration = def_duration;\n\t\t\tflags = def_flags;\n\n\t\t\t//CTS - if flag not set (trun or ctrn) defaults to 0 which is the base value after alloc\n\t\t\t//we just need to overrite its value if inherited\n\t\t\tcts_offset = ent->CTS_Offset;\n\n#ifdef GF_ENABLE_CTRN\n\t\t\tif (trun->use_ctrn) {\n\t\t\t\tif (!j && (trun->ctrn_flags & GF_ISOM_CTRN_FIRST_SAMPLE) ) {\n\t\t\t\t\tif (trun->ctrn_first_dur) duration = ent->Duration;\n\t\t\t\t\tif (trun->ctrn_first_size) size = ent->size;\n\t\t\t\t\tif (trun->ctrn_first_ctts) flags = ent->flags;\n\t\t\t\t} else {\n\t\t\t\t\tif (trun->ctrn_dur) duration = ent->Duration;\n\t\t\t\t\tif (trun->ctrn_size) size = ent->size;\n\t\t\t\t\tif (trun->ctrn_sample_flags) flags = ent->flags;\n\t\t\t\t}\n\t\t\t\t/*re-override*/\n\t\t\t\tif (trun->ctrn_flags & 0xF0) {\n\t\t\t\t\tGF_TrunEntry *ref_entry;\n\t\t\t\t\tif (!traf_ref) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Track %d use traf inheritance to track ID %d but reference traf not found\\n\", traf->trex->trackID, traf->trex->inherit_from_traf_id ));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tref_entry = traf_get_sample_entry(traf_ref, sample_index);\n\t\t\t\t\tif (!ref_entry) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Track %d use traf inheritance but sample %d not found in reference traf\\n\", traf->trex->trackID, sample_index+1 ));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_DUR)\n\t\t\t\t\t\tduration = ref_entry->Duration;\n\t\t\t\t\tif (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_SIZE)\n\t\t\t\t\t\tsize = ref_entry->size;\n\t\t\t\t\tif (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_FLAGS)\n\t\t\t\t\t\tflags = ref_entry->flags;\n\t\t\t\t\tif (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_CTSO)\n\t\t\t\t\t\tcts_offset = ref_entry->CTS_Offset;\n\t\t\t\t}\n\n\t\t\t} else\n#endif\n\t\t\t{\n\t\t\t\tif (trun->flags & GF_ISOM_TRUN_DURATION) duration = ent->Duration;\n\t\t\t\tif (trun->flags & GF_ISOM_TRUN_SIZE) size = ent->size;\n\t\t\t\tif (trun->flags & GF_ISOM_TRUN_FLAGS) {\n\t\t\t\t\tflags = ent->flags;\n\t\t\t\t} else if (!j && (trun->flags & GF_ISOM_TRUN_FIRST_FLAG)) {\n\t\t\t\t\tflags = trun->first_sample_flags;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsample_index++;\n\t\t\t/*store the resolved value in case we have inheritance*/\n\t\t\tent->size = size;\n\t\t\tent->Duration = duration;\n\t\t\tent->flags = flags;\n\t\t\tent->CTS_Offset = cts_offset;\n\n\t\t\tlast_dts += duration;\n\n\t\t\t//add size first\n\t\t\tif (!trak->Media->information->sampleTable->SampleSize) {\n\t\t\t\ttrak->Media->information->sampleTable->SampleSize = (GF_SampleSizeBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STSZ);\n\t\t\t\tif (!trak->Media->information->sampleTable->SampleSize)\n\t\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\te = stbl_AppendSize(trak->Media->information->sampleTable, size, ent->nb_pack);\n\t\t\tif (e) return e;\n\n\t\t\t//then TS\n\t\t\tif (!trak->Media->information->sampleTable->TimeToSample) {\n\t\t\t\ttrak->Media->information->sampleTable->TimeToSample = (GF_TimeToSampleBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STTS);\n\t\t\t\tif (!trak->Media->information->sampleTable->TimeToSample)\n\t\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\te = stbl_AppendTime(trak->Media->information->sampleTable, duration, ent->nb_pack);\n\t\t\tif (e) return e;\n\n\t\t\t//add chunk on first sample\n\t\t\tif (!j) {\n\t\t\t\tu64 final_offset;\n\t\t\t\tdata_offset = base_offset;\n\t\t\t\t//we have an explicit data offset for this trun\n\t\t\t\tif (trun->flags & GF_ISOM_TRUN_DATA_OFFSET) {\n\t\t\t\t\tdata_offset += trun->data_offset;\n\t\t\t\t\t/*reset chunk size since data is now relative to this trun*/\n\t\t\t\t\tchunk_size = 0;\n\t\t\t\t\t/*remember this data offset for following trun*/\n\t\t\t\t\tprev_trun_data_offset = trun->data_offset;\n\t\t\t\t\t/*if mdat is located after the moof, and the moof was compressed, adjust offset\n\t\t\t\t\totherwise the offset does not need adjustment*/\n\t\t\t\t\tif (trun->data_offset>=0) {\n\t\t\t\t\t\tdata_offset -= compressed_diff;\n\t\t\t\t\t\tprev_trun_data_offset -= compressed_diff;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//we had an explicit data offset for the previous trun, use it + chunk size\n\t\t\t\telse if (prev_trun_data_offset) {\n\t\t\t\t\t/*data offset is previous chunk size plus previous offset of the trun*/\n\t\t\t\t\tdata_offset += prev_trun_data_offset + chunk_size;\n\t\t\t\t}\n\t\t\t\t//no explicit data offset, continuous data after last data in previous chunk\n\t\t\t\telse {\n\t\t\t\t\tdata_offset += chunk_size;\n\t\t\t\t\t//data offset of first trun in first traf, adjust if compressed moof\n\t\t\t\t\tif ((i==1) && (trun->data_offset>=0)) {\n\t\t\t\t\t\tdata_offset -= compressed_diff;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfinal_offset = data_offset;\n\t\t\t\t//adjust offset if moov was also compressed and we are still in the same file\n\t\t\t\t//so that later call to gf_isom_get_sample properly adjust back the offset\n\t\t\t\tif (trak->moov->compressed_diff) {\n\t\t\t\t\tfinal_offset += trak->moov->compressed_diff;\n\t\t\t\t}\n\n\t\t\t\tif (!trak->Media->information->sampleTable->ChunkOffset) {\n\t\t\t\t\ttrak->Media->information->sampleTable->ChunkOffset = gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STCO);\n\t\t\t\t\tif (!trak->Media->information->sampleTable->ChunkOffset)\n\t\t\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t\te = stbl_AppendChunk(trak->Media->information->sampleTable, final_offset);\n\t\t\t\tif (e) return e;\n\t\t\t\t//then sampleToChunk\n\t\t\t\tif (!trak->Media->information->sampleTable->SampleToChunk) {\n\t\t\t\t\ttrak->Media->information->sampleTable->SampleToChunk = (GF_SampleToChunkBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STSC);\n\t\t\t\t\tif (!trak->Media->information->sampleTable->SampleToChunk)\n\t\t\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t\te = stbl_AppendSampleToChunk(trak->Media->information->sampleTable,\n\t\t\t\t                         DescIndex, trun->sample_count);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t\tchunk_size += size;\n\n\t\t\tif (store_traf_map && first_samp_in_traf) {\n\t\t\t\tfirst_samp_in_traf = GF_FALSE;\n\t\t\t\te = stbl_AppendTrafMap(trak->Media->information->sampleTable, is_seg_start, seg_start, frag_start, moof_template, moof_template_size, sidx_start, sidx_end);\n\t\t\t\tif (e) return e;\n\t\t\t\t//do not deallocate, the memory is now owned by traf map\n\t\t\t\tmoof_template = NULL;\n\t\t\t\tmoof_template_size = 0;\n\t\t\t}\n\t\t\tif (ent->nb_pack>1) {\n\t\t\t\tj+= ent->nb_pack-1;\n\t\t\t\ttraf_duration += ent->nb_pack*duration;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttraf_duration += duration;\n\n\t\t\te = stbl_AppendCTSOffset(trak->Media->information->sampleTable, cts_offset);\n\t\t\tif (e) return e;\n\t\t\t//flags\n\t\t\tsync = GF_ISOM_GET_FRAG_SYNC(flags);\n\t\t\tif (trak->Media->information->sampleTable->no_sync_found && sync) {\n\t\t\t\ttrak->Media->information->sampleTable->no_sync_found = 0;\n\t\t\t}\n\t\t\te = stbl_AppendRAP(trak->Media->information->sampleTable, sync);\n\t\t\tif (e) return e;\n\t\t\tpad = GF_ISOM_GET_FRAG_PAD(flags);\n\t\t\tif (pad) {\n\t\t\t\te = stbl_AppendPadding(trak->Media->information->sampleTable, pad);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t\tdegr = GF_ISOM_GET_FRAG_DEG(flags);\n\t\t\tif (degr) {\n\t\t\t\te = stbl_AppendDegradation(trak->Media->information->sampleTable, degr);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t\te = stbl_AppendDependencyType(trak->Media->information->sampleTable, GF_ISOM_GET_FRAG_LEAD(flags), GF_ISOM_GET_FRAG_DEPENDS(flags), GF_ISOM_GET_FRAG_DEPENDED(flags), GF_ISOM_GET_FRAG_REDUNDANT(flags));\n\t\t\tif (e) return e;\n\t\t}\n\t}\n\n\tif (trak->moov->mov->is_smooth && !traf->tfdt && !traf->tfxd) {\n\t\tif (is_first_merge)\n\t\t\ttrak->dts_at_seg_start = trak->dts_at_next_seg_start;\n\t\ttrak->dts_at_next_seg_start += last_dts;\n\t}\n\tif (traf_duration && trak->editBox && trak->editBox->editList) {\n\t\tfor (i=0; i<gf_list_count(trak->editBox->editList->entryList); i++) {\n\t\t\tGF_EdtsEntry *edts_e = gf_list_get(trak->editBox->editList->entryList, i);\n\t\t\tif (edts_e->was_empty_dur) {\n\t\t\t\tu64 extend_dur = traf_duration;\n\t\t\t\textend_dur *= trak->moov->mvhd->timeScale;\n\t\t\t\textend_dur /= trak->Media->mediaHeader->timeScale;\n\t\t\t\tedts_e->segmentDuration += extend_dur;\n\t\t\t}\n\t\t\telse if (!edts_e->segmentDuration) {\n\t\t\t\tedts_e->was_empty_dur = GF_TRUE;\n\t\t\t\tif ((s64) traf_duration > edts_e->mediaTime)\n\t\t\t\t\ttraf_duration -= edts_e->mediaTime;\n\t\t\t\telse\n\t\t\t\t\ttraf_duration = 0;\n\n\t\t\t\tedts_e->segmentDuration = traf_duration;\n\t\t\t\tedts_e->segmentDuration *= trak->moov->mvhd->timeScale;\n\t\t\t\tedts_e->segmentDuration /= trak->Media->mediaHeader->timeScale;\n\t\t\t}\n\n\t\t}\n\t}\n\n\t//in any case, update the cumulated offset\n\t//this will handle hypothetical files mixing MOOF offset and implicit non-moof offset\n\t*cumulated_offset = data_offset + chunk_size;\n\n\t/*merge sample groups*/\n\tif (traf->sampleGroups) {\n\t\tGF_List *groups;\n\t\tGF_List *groupDescs;\n\t\tBool is_identical_sgpd = GF_TRUE;\n\t\tu32 *new_idx = NULL, new_idx_count=0;\n\n\t\tif (!trak->Media->information->sampleTable->sampleGroups)\n\t\t\ttrak->Media->information->sampleTable->sampleGroups = gf_list_new();\n\n\t\tif (!trak->Media->information->sampleTable->sampleGroupsDescription)\n\t\t\ttrak->Media->information->sampleTable->sampleGroupsDescription = gf_list_new();\n\n\t\tgroupDescs = trak->Media->information->sampleTable->sampleGroupsDescription;\n\t\tfor (i=0; i<gf_list_count(traf->sampleGroupsDescription); i++) {\n\t\t\tGF_SampleGroupDescriptionBox *new_sgdesc = NULL;\n\t\t\tGF_SampleGroupDescriptionBox *sgdesc = gf_list_get(traf->sampleGroupsDescription, i);\n\t\t\tfor (j=0; j<gf_list_count(groupDescs); j++) {\n\t\t\t\tnew_sgdesc = gf_list_get(groupDescs, j);\n\t\t\t\tif (new_sgdesc->grouping_type==sgdesc->grouping_type) break;\n\t\t\t\tnew_sgdesc = NULL;\n\t\t\t}\n\t\t\t/*new description, move it to our sample table*/\n\t\t\tif (!new_sgdesc) {\n\t\t\t\tgf_list_add(groupDescs, sgdesc);\n\t\t\t\tgf_list_add(trak->Media->information->sampleTable->child_boxes, sgdesc);\n\t\t\t\tgf_list_rem(traf->sampleGroupsDescription, i);\n\t\t\t\tgf_list_del_item(traf->child_boxes, sgdesc);\n\t\t\t\ti--;\n\t\t\t}\n\t\t\t/*merge descriptions*/\n\t\t\telse {\n\t\t\t\tu32 count;\n\n\t\t\t\tis_identical_sgpd = gf_isom_is_identical_sgpd(new_sgdesc, sgdesc, 0);\n\t\t\t\tif (is_identical_sgpd)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tnew_idx_count = gf_list_count(sgdesc->group_descriptions);\n\t\t\t\tnew_idx = (u32 *)gf_malloc(new_idx_count * sizeof(u32));\n\t\t\t\tif (!new_idx) return GF_OUT_OF_MEM;\n\n\t\t\t\tcount = 0;\n\t\t\t\twhile (gf_list_count(sgdesc->group_descriptions)) {\n\t\t\t\t\tvoid *sgpd_entry = gf_list_get(sgdesc->group_descriptions, 0);\n\t\t\t\t\tBool new_entry = GF_TRUE;\n\n\t\t\t\t\tfor (j = 0; j < gf_list_count(new_sgdesc->group_descriptions); j++) {\n\t\t\t\t\t\tvoid *ptr = gf_list_get(new_sgdesc->group_descriptions, j);\n\t\t\t\t\t\tif (gf_isom_is_identical_sgpd(sgpd_entry, ptr, new_sgdesc->grouping_type)) {\n\t\t\t\t\t\t\tnew_idx[count] = j + 1;\n\t\t\t\t\t\t\tcount ++;\n\t\t\t\t\t\t\tnew_entry = GF_FALSE;\n\t\t\t\t\t\t\tgf_free(sgpd_entry);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (new_entry) {\n\t\t\t\t\t\tgf_list_add(new_sgdesc->group_descriptions, sgpd_entry);\n\t\t\t\t\t\tnew_idx[count] = gf_list_count(new_sgdesc->group_descriptions);\n\t\t\t\t\t\tcount ++;\n\t\t\t\t\t}\n\n\t\t\t\t\tgf_list_rem(sgdesc->group_descriptions, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tgroups = trak->Media->information->sampleTable->sampleGroups;\n\t\tfor (i=0; i<gf_list_count(traf->sampleGroups); i++) {\n\t\t\tGF_SampleGroupBox *stbl_group = NULL;\n\t\t\tGF_SampleGroupBox *frag_group = gf_list_get(traf->sampleGroups, i);\n\n\n\t\t\tfor (j=0; j<gf_list_count(groups); j++) {\n\t\t\t\tstbl_group = gf_list_get(groups, j);\n\t\t\t\tif ((frag_group->grouping_type==stbl_group->grouping_type) && (frag_group->grouping_type_parameter==stbl_group->grouping_type_parameter))\n\t\t\t\t\tbreak;\n\t\t\t\tstbl_group = NULL;\n\t\t\t}\n\t\t\tif (!stbl_group) {\n\t\t\t\tstbl_group = (GF_SampleGroupBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_SBGP);\n\t\t\t\tif (!stbl_group) return GF_OUT_OF_MEM;\n\t\t\t\tstbl_group->grouping_type = frag_group->grouping_type;\n\t\t\t\tstbl_group->grouping_type_parameter = frag_group->grouping_type_parameter;\n\t\t\t\tstbl_group->version = frag_group->version;\n\t\t\t\tgf_list_add(groups, stbl_group);\n\t\t\t}\n\n\t\t\tif (is_identical_sgpd) {\n\t\t\t\t//adjust sgpd index: in traf index start at 0x1001\n\t\t\t\tfor (j = 0; j < frag_group->entry_count; j++)\n\t\t\t\t\tfrag_group->sample_entries[j].group_description_index &= 0x0FFFF;\n\t\t\t\tif (frag_group->entry_count && stbl_group->entry_count &&\n\t\t\t\t        (frag_group->sample_entries[0].group_description_index==stbl_group->sample_entries[stbl_group->entry_count-1].group_description_index)\n\t\t\t\t   ) {\n\t\t\t\t\tstbl_group->sample_entries[stbl_group->entry_count - 1].sample_count += frag_group->sample_entries[0].sample_count;\n\t\t\t\t\tif (frag_group->entry_count>1) {\n\t\t\t\t\t\tstbl_group->sample_entries = gf_realloc(stbl_group->sample_entries, sizeof(GF_SampleGroupEntry) * (stbl_group->entry_count + frag_group->entry_count - 1));\n\t\t\t\t\t\tmemcpy(&stbl_group->sample_entries[stbl_group->entry_count], &frag_group->sample_entries[1], sizeof(GF_SampleGroupEntry) * (frag_group->entry_count - 1));\n\t\t\t\t\t\tstbl_group->entry_count += frag_group->entry_count - 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tstbl_group->sample_entries = gf_realloc(stbl_group->sample_entries, sizeof(GF_SampleGroupEntry) * (stbl_group->entry_count + frag_group->entry_count));\n\t\t\t\t\tmemcpy(&stbl_group->sample_entries[stbl_group->entry_count], &frag_group->sample_entries[0], sizeof(GF_SampleGroupEntry) * frag_group->entry_count);\n\t\t\t\t\tstbl_group->entry_count += frag_group->entry_count;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstbl_group->sample_entries = gf_realloc(stbl_group->sample_entries, sizeof(GF_SampleGroupEntry) * (stbl_group->entry_count + frag_group->entry_count));\n\t\t\t\t//adjust sgpd index\n\t\t\t\tfor (j = 0; j < frag_group->entry_count; j++) {\n\t\t\t\t\tu32 sgidx = frag_group->sample_entries[j].group_description_index;\n\t\t\t\t\tif (sgidx > 0x10000) {\n\t\t\t\t\t\tsgidx -= 0x10001;\n\t\t\t\t\t\tif (sgidx>=new_idx_count) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[isobmf] corrupted sample group index in fragment %d but only %d group descriptions in fragment\\n\", sgidx, new_idx_count));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfrag_group->sample_entries[j].group_description_index = new_idx[sgidx];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmemcpy(&stbl_group->sample_entries[stbl_group->entry_count], &frag_group->sample_entries[0], sizeof(GF_SampleGroupEntry) * frag_group->entry_count);\n\t\t\t\tstbl_group->entry_count += frag_group->entry_count;\n\t\t\t}\n\t\t}\n\n\t\tif (new_idx) gf_free(new_idx);\n\t}\n\n\t/*content is encrypted*/\n\ttrack_num = gf_isom_get_tracknum_from_id(trak->moov, trak->Header->trackID);\n\tif (gf_isom_is_cenc_media(trak->moov->mov, track_num, DescIndex)\n\t\t|| traf->sample_encryption) {\n\t\t/*Merge sample auxiliary encryption information*/\n\t\tGF_SampleEncryptionBox *senc = NULL;\n\t\tu32 scheme_type;\n\t\tgf_isom_get_cenc_info(trak->moov->mov, track_num, DescIndex, NULL, &scheme_type, NULL);\n\n\t\tif (traf->sample_encryption) {\n\t\t\tfor (i = 0; i < gf_list_count(trak->Media->information->sampleTable->child_boxes); i++) {\n\t\t\t\tGF_Box *a = (GF_Box *)gf_list_get(trak->Media->information->sampleTable->child_boxes, i);\n\t\t\t\tif (a->type != traf->sample_encryption->type) continue;\n\n\t\t\t\tif ((a->type ==GF_ISOM_BOX_TYPE_UUID) && (((GF_UUIDBox *)a)->internal_4cc == GF_ISOM_BOX_UUID_PSEC)) {\n\t\t\t\t\tsenc = (GF_SampleEncryptionBox *)a;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (a->type ==GF_ISOM_BOX_TYPE_SENC) {\n\t\t\t\t\tsenc = (GF_SampleEncryptionBox *)a;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!senc && trak->sample_encryption)\n\t\t\t\tsenc = trak->sample_encryption;\n\n\t\t\tif (!senc) {\n\t\t\t\tif (traf->sample_encryption->piff_type==1) {\n\t\t\t\t\tsenc = (GF_SampleEncryptionBox *)gf_isom_create_piff_psec_box(1, 0x2, 0, 0, NULL);\n\t\t\t\t} else {\n\t\t\t\t\tsenc = gf_isom_create_samp_enc_box(1, 0x2);\n\t\t\t\t}\n\n\t\t\t\tif (!trak->Media->information->sampleTable->child_boxes) trak->Media->information->sampleTable->child_boxes = gf_list_new();\n\n\t\t\t\ttrak->sample_encryption = senc;\n\t\t\t\tif (!trak->child_boxes) trak->child_boxes = gf_list_new();\n\t\t\t\tgf_list_add(trak->child_boxes, senc);\n\t\t\t}\n\t\t}\n\n\t\t/*get sample auxiliary information by saiz/saio rather than by parsing senc box*/\n\t\tif (gf_isom_cenc_has_saiz_saio_traf(traf, scheme_type)) {\n\t\t\tu32 nb_saio;\n\t\t\tu32 aux_info_type;\n\t\t\tu64 offset;\n\t\t\tGF_Err e;\n\t\t\tBool is_encrypted;\n\t\t\tGF_SampleAuxiliaryInfoOffsetBox *saio = NULL;\n\t\t\tGF_SampleAuxiliaryInfoSizeBox *saiz = NULL;\n\n\t\t\toffset = nb_saio = 0;\n\n\t\t\tfor (i = 0; i < gf_list_count(traf->sai_offsets); i++) {\n\t\t\t\tsaio = (GF_SampleAuxiliaryInfoOffsetBox *)gf_list_get(traf->sai_offsets, i);\n\t\t\t\taux_info_type = saio->aux_info_type;\n\t\t\t\tif (!aux_info_type) aux_info_type = scheme_type;\n\n\t\t\t\t/*if we have only 1 sai_offsets, assume that its type is cenc*/\n\t\t\t\tif ((aux_info_type == GF_ISOM_CENC_SCHEME) || (aux_info_type == GF_ISOM_CBC_SCHEME) ||\n\t\t\t\t\t(aux_info_type == GF_ISOM_CENS_SCHEME) || (aux_info_type == GF_ISOM_CBCS_SCHEME) ||\n\t\t\t\t\t(gf_list_count(traf->sai_offsets) == 1)) {\n\t\t\t\t\tif (saio->offsets && saio->entry_count) {\n\t\t\t\t\t\toffset = saio->offsets[0] + moof_offset;\n\t\t\t\t\t\tnb_saio = saio->entry_count;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsaio = NULL;\n\t\t\t}\n\t\t\tfor (i = 0; i < gf_list_count(traf->sai_sizes); i++) {\n\t\t\t\tsaiz = (GF_SampleAuxiliaryInfoSizeBox *)gf_list_get(traf->sai_sizes, i);\n\t\t\t\taux_info_type = saiz->aux_info_type;\n\t\t\t\tif (!aux_info_type) aux_info_type = scheme_type;\n\t\t\t\t/*if we have only 1 sai_sizes, assume that its type is cenc*/\n\t\t\t\tif ((aux_info_type == GF_ISOM_CENC_SCHEME) || (aux_info_type == GF_ISOM_CBC_SCHEME) ||\n\t\t\t\t\t(aux_info_type == GF_ISOM_CENS_SCHEME) || (aux_info_type == GF_ISOM_CBCS_SCHEME) ||\n\t\t\t\t\t(gf_list_count(traf->sai_sizes) == 1)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsaiz = NULL;\n\t\t\t}\n\t\t\tif (saiz && saio && senc) {\n\t\t\t\tfor (i = 0; i < saiz->sample_count; i++) {\n\t\t\t\t\tGF_CENCSampleAuxInfo *sai;\n\t\t\t\t\tconst u8 *key_info=NULL;\n\t\t\t\t\tu32 key_info_size;\n\t\t\t\t\tu64 cur_position;\n\t\t\t\t\tif (nb_saio != 1)\n\t\t\t\t\t\toffset = saio->offsets[i] + moof_offset;\n\t\t\t\t\tsize = saiz->default_sample_info_size ? saiz->default_sample_info_size : saiz->sample_info_size[i];\n\n\t\t\t\t\tcur_position = gf_bs_get_position(trak->moov->mov->movieFileMap->bs);\n\t\t\t\t\tgf_bs_seek(trak->moov->mov->movieFileMap->bs, offset);\n\n\t\t\t\t\tGF_SAFEALLOC(sai, GF_CENCSampleAuxInfo);\n\t\t\t\t\tif (!sai) return GF_OUT_OF_MEM;\n\n\t\t\t\t\te = gf_isom_get_sample_cenc_info_internal(trak, traf, senc, i+1, &is_encrypted, NULL, NULL, &key_info, &key_info_size);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[isobmf] could not get cenc info for sample %d: %s\\n\", i+1, gf_error_to_string(e) ));\n\t\t\t\t\t\treturn e;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (is_encrypted) {\n\t\t\t\t\t\tsai->cenc_data_size = size;\n\t\t\t\t\t\tsai->cenc_data = gf_malloc(sizeof(u8)*size);\n\t\t\t\t\t\tif (!sai->cenc_data) return GF_OUT_OF_MEM;\n\t\t\t\t\t\tgf_bs_read_data(trak->moov->mov->movieFileMap->bs, sai->cenc_data, sai->cenc_data_size);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsai->isNotProtected=1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (key_info) {\n\t\t\t\t\t\t//not multikey\n\t\t\t\t\t\tif (!key_info[0]) {\n\t\t\t\t\t\t\t//size greater than IV\n\t\t\t\t\t\t\tif (size > key_info[3])\n\t\t\t\t\t\t\t\tsenc->flags = 0x00000002;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//multikey, always use subsamples\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tsenc->flags = 0x00000002;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\n\t\t\t\t\tgf_bs_seek(trak->moov->mov->movieFileMap->bs, cur_position);\n\n\t\t\t\t\tgf_list_add(senc->samp_aux_info, sai);\n\n\t\t\t\t\te = gf_isom_cenc_merge_saiz_saio(senc, trak->Media->information->sampleTable, offset, size);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t\tif (nb_saio == 1)\n\t\t\t\t\t\toffset += size;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (traf->sample_encryption) {\n\t\t\tsenc_Parse(trak->moov->mov->movieFileMap->bs, trak, traf, traf->sample_encryption);\n\t\t\ttrak->sample_encryption->AlgorithmID = traf->sample_encryption->AlgorithmID;\n\t\t\tif (!trak->sample_encryption->IV_size)\n\t\t\t\ttrak->sample_encryption->IV_size = traf->sample_encryption->IV_size;\n\t\t\tif (!trak->sample_encryption->samp_aux_info) trak->sample_encryption->samp_aux_info = gf_list_new();\n\t\t\tgf_list_transfer(trak->sample_encryption->samp_aux_info, traf->sample_encryption->samp_aux_info);\n\t\t\tif (traf->sample_encryption->flags & 0x00000002)\n\t\t\t\ttrak->sample_encryption->flags |= 0x00000002;\n\t\t}\n\t}\n\treturn GF_OK;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 4709,
    "critical_vars": [
      "val"
    ],
    "function": "gf_bs_read_ue_log_idx3",
    "filename": "gpac/CVE-2021-40564/CVE-2021-40564_CWE-476_cf6771c857eb9a290e2c19ddacfdd3ed98b27618_av_parsers.c.diff",
    "function_code": "u32 gf_bs_read_ue_log_idx3(GF_BitStream *bs, const char *fname, s32 idx1, s32 idx2, s32 idx3)\n{\n\tu32 val=0, code;\n\ts32 nb_lead = -1;\n\tu32 bits = 0;\n\tfor (code=0; !code; nb_lead++) {\n\t\tif (nb_lead>=32) {\n\t\t\t//gf_bs_read_int keeps returning 0 on EOS, so if no more bits available, rbsp was truncated otherwise code is broken in rbsp)\n\t\t\t//we only test once nb_lead>=32 to avoid testing at each bit read\n\t\t\tif (!gf_bs_available(bs)) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[Core] exp-golomb read failed, not enough bits in bitstream !\\n\"));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[Core] corrupted exp-golomb code, %d leading zeros, max 31 allowed !\\n\", nb_lead));\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\tcode = gf_bs_read_int(bs, 1);\n\t\tbits++;\n\t}\n\n\tif (nb_lead) {\n\t\tval = gf_bs_read_int(bs, nb_lead);\n\t\tval += (1 << nb_lead) - 1;\n\t\tbits += nb_lead;\n\t}\n\n\tif (fname) {\n\t\tgf_bs_log_idx(bs, bits, fname, val, idx1, idx2, idx3);\n\t}\n\treturn val;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 4708,
    "critical_vars": [
      "leads"
    ],
    "function": "gf_bs_read_ue_log_idx3",
    "filename": "gpac/CVE-2021-40564/CVE-2021-40564_CWE-476_cf6771c857eb9a290e2c19ddacfdd3ed98b27618_av_parsers.c.diff",
    "function_code": "u32 gf_bs_read_ue_log_idx3(GF_BitStream *bs, const char *fname, s32 idx1, s32 idx2, s32 idx3)\n{\n\tu32 val=0, code;\n\ts32 nb_lead = -1;\n\tu32 bits = 0;\n\tfor (code=0; !code; nb_lead++) {\n\t\tif (nb_lead>=32) {\n\t\t\t//gf_bs_read_int keeps returning 0 on EOS, so if no more bits available, rbsp was truncated otherwise code is broken in rbsp)\n\t\t\t//we only test once nb_lead>=32 to avoid testing at each bit read\n\t\t\tif (!gf_bs_available(bs)) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[Core] exp-golomb read failed, not enough bits in bitstream !\\n\"));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[Core] corrupted exp-golomb code, %d leading zeros, max 31 allowed !\\n\", nb_lead));\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\tcode = gf_bs_read_int(bs, 1);\n\t\tbits++;\n\t}\n\n\tif (nb_lead) {\n\t\tu32 leads=1;\n\t\tval = gf_bs_read_int(bs, nb_lead);\n\t\tleads <<= nb_lead;\n\t\tleads -= 1;\n\t\tval += leads;\n//\t\tval += (1 << nb_lead) - 1;\n\t\tbits += nb_lead;\n\t}\n\n\tif (fname) {\n\t\tgf_bs_log_idx(bs, bits, fname, val, idx1, idx2, idx3);\n\t}\n\treturn val;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 759,
    "critical_vars": [
      "field.far_ptr",
      "sdump"
    ],
    "function": "gf_dump_vrml_simple_field",
    "filename": "gpac/CVE-2022-1035/CVE-2022-1035_CWE-476_3718d583c6ade191dc7979c64f48c001ca6f0243_scene_dump.c.diff",
    "function_code": "static void gf_dump_vrml_simple_field(GF_SceneDumper *sdump, GF_FieldInfo field, GF_Node *parent)\n{\n\tu32 i, sf_type;\n\tGF_ChildNodeItem *list;\n\tvoid *slot_ptr;\n\n\tswitch (field.fieldType) {\n\tcase GF_SG_VRML_SFNODE:\n\t\tassert ( *(GF_Node **)field.far_ptr);\n\t\tgf_dump_vrml_node(sdump, *(GF_Node **)field.far_ptr, 0, NULL);\n\t\treturn;\n\tcase GF_SG_VRML_MFNODE:\n\t\tlist = * ((GF_ChildNodeItem **) field.far_ptr);\n\t\tassert( list );\n\t\tsdump->indent++;\n\t\twhile (list) {\n\t\t\tgf_dump_vrml_node(sdump, list->node, 1, NULL);\n\t\t\tlist = list->next;\n\t\t}\n\t\tsdump->indent--;\n\t\treturn;\n\tcase GF_SG_VRML_SFCOMMANDBUFFER:\n\t\treturn;\n\t}\n\tif (gf_sg_vrml_is_sf_field(field.fieldType)) {\n\t\tif (sdump->XMLDump) StartAttribute(sdump, \"value\");\n\t\tgf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, parent);\n\t\tif (sdump->XMLDump) EndAttribute(sdump);\n\t} else {\n\t\tGenMFField *mffield;\n\t\tmffield = (GenMFField *) field.far_ptr;\n\t\tsf_type = gf_sg_vrml_get_sf_type(field.fieldType);\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"[\");\n\t\t} else if (sf_type==GF_SG_VRML_SFSTRING) {\n\t\t\tgf_fprintf(sdump->trace, \" value=\\'\");\n\t\t} else {\n\t\t\tStartAttribute(sdump, \"value\");\n\t\t}\n\t\tfor (i=0; i<mffield->count; i++) {\n\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\t/*this is to cope with single MFString which shall appear as SF in XMT*/\n\t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, parent);\n\t\t}\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"]\");\n\t\t} else if (sf_type==GF_SG_VRML_SFSTRING) {\n\t\t\tgf_fprintf(sdump->trace, \"\\'\");\n\t\t} else {\n\t\t\tEndAttribute(sdump);\n\t\t}\n\t}\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "for-Condition",
    "line_new": 788,
    "critical_vars": [
      "mffield"
    ],
    "function": "gf_dump_vrml_simple_field",
    "filename": "gpac/CVE-2022-2549/CVE-2022-2549_CWE-476_0102c5d4db7fdbf08b5b591b2a6264de33867a07_scene_dump.c.diff",
    "function_code": "static void gf_dump_vrml_simple_field(GF_SceneDumper *sdump, GF_FieldInfo field, GF_Node *parent)\n{\n\tu32 i, sf_type;\n\tGF_ChildNodeItem *list;\n\tvoid *slot_ptr;\n\n\tswitch (field.fieldType) {\n\tcase GF_SG_VRML_SFNODE:\n\t\tgf_dump_vrml_node(sdump, field.far_ptr ? *(GF_Node **)field.far_ptr : NULL, 0, NULL);\n\t\treturn;\n\tcase GF_SG_VRML_MFNODE:\n\t\tlist = * ((GF_ChildNodeItem **) field.far_ptr);\n\t\tassert( list );\n\t\tsdump->indent++;\n\t\twhile (list) {\n\t\t\tgf_dump_vrml_node(sdump, list->node, 1, NULL);\n\t\t\tlist = list->next;\n\t\t}\n\t\tsdump->indent--;\n\t\treturn;\n\tcase GF_SG_VRML_SFCOMMANDBUFFER:\n\t\treturn;\n\t}\n\tif (gf_sg_vrml_is_sf_field(field.fieldType)) {\n\t\tif (sdump->XMLDump) StartAttribute(sdump, \"value\");\n\t\tgf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, parent);\n\t\tif (sdump->XMLDump) EndAttribute(sdump);\n\t} else {\n\t\tGenMFField *mffield;\n\t\tmffield = (GenMFField *) field.far_ptr;\n\t\tsf_type = gf_sg_vrml_get_sf_type(field.fieldType);\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"[\");\n\t\t} else if (sf_type==GF_SG_VRML_SFSTRING) {\n\t\t\tgf_fprintf(sdump->trace, \" value=\\'\");\n\t\t} else {\n\t\t\tStartAttribute(sdump, \"value\");\n\t\t}\n\t\tfor (i=0; i<mffield->count; i++) {\n\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\t/*this is to cope with single MFString which shall appear as SF in XMT*/\n\t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, parent);\n\t\t}\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"]\");\n\t\t} else if (sf_type==GF_SG_VRML_SFSTRING) {\n\t\t\tgf_fprintf(sdump->trace, \"\\'\");\n\t\t} else {\n\t\t\tEndAttribute(sdump);\n\t\t}\n\t}\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 941,
    "critical_vars": [
      "mffield"
    ],
    "function": "gf_dump_vrml_field",
    "filename": "gpac/CVE-2022-2549/CVE-2022-2549_CWE-476_0102c5d4db7fdbf08b5b591b2a6264de33867a07_scene_dump.c.diff",
    "function_code": "static void gf_dump_vrml_field(GF_SceneDumper *sdump, GF_Node *node, GF_FieldInfo field)\n{\n\tu32 i, sf_type;\n\tBool needs_field_container;\n\tGF_ChildNodeItem *list;\n\tvoid *slot_ptr;\n\n\tswitch (field.fieldType) {\n\tcase GF_SG_VRML_SFNODE:\n\t\tassert ( *(GF_Node **)field.far_ptr);\n\n\t\tif (sdump->XMLDump) {\n\t\t\tif (!sdump->X3DDump) {\n\t\t\t\tStartElement(sdump, (char *) field.name);\n\t\t\t\tEndElementHeader(sdump, 1);\n\t\t\t\tsdump->indent++;\n\t\t\t}\n\t\t} else {\n\t\t\tStartAttribute(sdump, field.name);\n\t\t}\n\t\tgf_dump_vrml_node(sdump, *(GF_Node **)field.far_ptr, 0, NULL);\n\n\t\tif (sdump->XMLDump) {\n\t\t\tif (!sdump->X3DDump) {\n\t\t\t\tsdump->indent--;\n\t\t\t\tEndElement(sdump, (char *) field.name, 1);\n\t\t\t}\n\t\t} else {\n\t\t\tEndAttribute(sdump);\n\t\t}\n\t\treturn;\n\tcase GF_SG_VRML_MFNODE:\n\t\tneeds_field_container = 0;\n\t\tif (sdump->XMLDump && sdump->X3DDump) {\n\t\t\tu32 count, nb_ndt;\n\t\t\tGF_FieldInfo info;\n\t\t\tif (!strcmp(field.name, \"children\")) {\n\t\t\t\tneeds_field_container = 0;\n\t\t\t} else {\n\t\t\t\tnb_ndt = 0;\n\t\t\t\tcount = gf_node_get_field_count(node);\n\t\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\t\tgf_node_get_field(node, i, &info);\n\t\t\t\t\tif ((info.eventType==GF_SG_EVENT_IN) || (info.eventType==GF_SG_EVENT_OUT)) continue;\n\t\t\t\t\tif (info.NDTtype==field.NDTtype) nb_ndt++;\n\t\t\t\t}\n\t\t\t\tneeds_field_container = (nb_ndt>1) ? 1 : 0;\n\t\t\t}\n\t\t}\n\n#ifndef GPAC_DISABLE_X3D\n\t\tif (!sdump->X3DDump) {\n\t\t\tif (gf_node_get_tag(node)==TAG_X3D_Switch) field.name = \"choice\";\n\t\t}\n#endif\n\t\tlist = * ((GF_ChildNodeItem **) field.far_ptr);\n\t\tassert(list);\n\t\tif (!sdump->XMLDump || !sdump->X3DDump) StartList(sdump, field.name);\n\t\tsdump->indent++;\n\t\twhile (list) {\n\t\t\tgf_dump_vrml_node(sdump, list->node, 1, needs_field_container ? (char *) field.name : NULL);\n\t\t\tlist = list->next;\n\t\t}\n\t\tsdump->indent--;\n\t\tif (!sdump->XMLDump || !sdump->X3DDump) EndList(sdump, field.name);\n\t\treturn;\n\tcase GF_SG_VRML_SFCOMMANDBUFFER:\n\t{\n\t\tSFCommandBuffer *cb = (SFCommandBuffer *)field.far_ptr;\n\t\tStartElement(sdump, (char *) field.name);\n\t\tEndElementHeader(sdump, 1);\n\t\tsdump->indent++;\n\t\tif (!gf_list_count(cb->commandList)) {\n\t\t\t/*the arch does not allow for that (we would need a codec and so on, or decompress the command list\n\t\t\tin all cases...)*/\n\t\t\tif (sdump->trace && cb->bufferSize) {\n\t\t\t\tif (sdump->XMLDump) gf_fprintf(sdump->trace, \"<!--SFCommandBuffer cannot be dumped while playing - use MP4Box instead-->\\n\");\n\t\t\t\telse gf_fprintf(sdump->trace, \"#SFCommandBuffer cannot be dumped while playing - use MP4Box instead\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tgf_sm_dump_command_list(sdump, cb->commandList, sdump->indent, 0);\n\t\t}\n\t\tsdump->indent--;\n\t\tEndElement(sdump, (char *) field.name, 1);\n\t}\n\treturn;\n\n\tcase GF_SG_VRML_MFATTRREF:\n\t\tif (sdump->XMLDump) {\n\t\t\tMFAttrRef *ar = (MFAttrRef *)field.far_ptr;\n\t\t\tStartElement(sdump, (char *) field.name);\n\t\t\tEndElementHeader(sdump, 1);\n\t\t\tsdump->indent++;\n\n\t\t\tfor (i=0; i<ar->count; i++) {\n\t\t\t\tif (ar->vals[i].node) {\n\t\t\t\t\tGF_FieldInfo pinfo;\n\t\t\t\t\tDUMP_IND(sdump);\n\t\t\t\t\tgf_node_get_field(ar->vals[i].node, ar->vals[i].fieldIndex, &pinfo);\n\t\t\t\t\tgf_fprintf(sdump->trace, \"<store node=\\\"\");\n\t\t\t\t\tscene_dump_vrml_id(sdump, ar->vals[i].node);\n\t\t\t\t\tgf_fprintf(sdump->trace, \"\\\" field=\\\"%s\\\"/>\\n\", pinfo.name);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsdump->indent--;\n\t\t\tEndElement(sdump, (char *) field.name, 1);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\t}\n\n\n\tif (gf_sg_vrml_is_sf_field(field.fieldType)) {\n\t\tStartAttribute(sdump, field.name);\n\t\tgf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, node);\n\t\tEndAttribute(sdump);\n\t} else {\n\t\tGenMFField *mffield = (GenMFField *) field.far_ptr;\n\t\tsf_type = gf_sg_vrml_get_sf_type(field.fieldType);\n\n\t\tif (sdump->XMLDump && sdump->X3DDump) {\n\t\t\tswitch (sf_type) {\n\t\t\tcase GF_SG_VRML_SFSTRING:\n\t\t\tcase GF_SG_VRML_SFSCRIPT:\n\t\t\tcase GF_SG_VRML_SFURL:\n\t\t\t\tgf_fprintf(sdump->trace, \" %s=\\'\", (char *) field.name);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tStartAttribute(sdump, field.name);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tStartAttribute(sdump, field.name);\n\t\t}\n\n\t\tif (!sdump->XMLDump) gf_fprintf(sdump->trace, \"[\");\n\t\tif (mffield) {\n\t\t\tfor (i=0; i<mffield->count; i++) {\n\t\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n\t\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, node);\n\t\t\t}\n\t\t}\n\t\tif (!sdump->XMLDump) gf_fprintf(sdump->trace, \"]\");\n\n\t\tif (sdump->XMLDump && sdump->X3DDump) {\n\t\t\tswitch (sf_type) {\n\t\t\tcase GF_SG_VRML_SFSTRING:\n\t\t\tcase GF_SG_VRML_SFSCRIPT:\n\t\t\tcase GF_SG_VRML_SFURL:\n\t\t\t\tgf_fprintf(sdump->trace, \"\\'\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tEndAttribute(sdump);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tEndAttribute(sdump);\n\t\t}\n\t}\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "for-Condition",
    "line_new": 941,
    "critical_vars": [
      "i",
      "mffield"
    ],
    "function": "gf_dump_vrml_field",
    "filename": "gpac/CVE-2022-2549/CVE-2022-2549_CWE-476_0102c5d4db7fdbf08b5b591b2a6264de33867a07_scene_dump.c.diff",
    "function_code": "static void gf_dump_vrml_field(GF_SceneDumper *sdump, GF_Node *node, GF_FieldInfo field)\n{\n\tu32 i, sf_type;\n\tBool needs_field_container;\n\tGF_ChildNodeItem *list;\n\tvoid *slot_ptr;\n\n\tswitch (field.fieldType) {\n\tcase GF_SG_VRML_SFNODE:\n\t\tassert ( *(GF_Node **)field.far_ptr);\n\n\t\tif (sdump->XMLDump) {\n\t\t\tif (!sdump->X3DDump) {\n\t\t\t\tStartElement(sdump, (char *) field.name);\n\t\t\t\tEndElementHeader(sdump, 1);\n\t\t\t\tsdump->indent++;\n\t\t\t}\n\t\t} else {\n\t\t\tStartAttribute(sdump, field.name);\n\t\t}\n\t\tgf_dump_vrml_node(sdump, *(GF_Node **)field.far_ptr, 0, NULL);\n\n\t\tif (sdump->XMLDump) {\n\t\t\tif (!sdump->X3DDump) {\n\t\t\t\tsdump->indent--;\n\t\t\t\tEndElement(sdump, (char *) field.name, 1);\n\t\t\t}\n\t\t} else {\n\t\t\tEndAttribute(sdump);\n\t\t}\n\t\treturn;\n\tcase GF_SG_VRML_MFNODE:\n\t\tneeds_field_container = 0;\n\t\tif (sdump->XMLDump && sdump->X3DDump) {\n\t\t\tu32 count, nb_ndt;\n\t\t\tGF_FieldInfo info;\n\t\t\tif (!strcmp(field.name, \"children\")) {\n\t\t\t\tneeds_field_container = 0;\n\t\t\t} else {\n\t\t\t\tnb_ndt = 0;\n\t\t\t\tcount = gf_node_get_field_count(node);\n\t\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\t\tgf_node_get_field(node, i, &info);\n\t\t\t\t\tif ((info.eventType==GF_SG_EVENT_IN) || (info.eventType==GF_SG_EVENT_OUT)) continue;\n\t\t\t\t\tif (info.NDTtype==field.NDTtype) nb_ndt++;\n\t\t\t\t}\n\t\t\t\tneeds_field_container = (nb_ndt>1) ? 1 : 0;\n\t\t\t}\n\t\t}\n\n#ifndef GPAC_DISABLE_X3D\n\t\tif (!sdump->X3DDump) {\n\t\t\tif (gf_node_get_tag(node)==TAG_X3D_Switch) field.name = \"choice\";\n\t\t}\n#endif\n\t\tlist = * ((GF_ChildNodeItem **) field.far_ptr);\n\t\tassert(list);\n\t\tif (!sdump->XMLDump || !sdump->X3DDump) StartList(sdump, field.name);\n\t\tsdump->indent++;\n\t\twhile (list) {\n\t\t\tgf_dump_vrml_node(sdump, list->node, 1, needs_field_container ? (char *) field.name : NULL);\n\t\t\tlist = list->next;\n\t\t}\n\t\tsdump->indent--;\n\t\tif (!sdump->XMLDump || !sdump->X3DDump) EndList(sdump, field.name);\n\t\treturn;\n\tcase GF_SG_VRML_SFCOMMANDBUFFER:\n\t{\n\t\tSFCommandBuffer *cb = (SFCommandBuffer *)field.far_ptr;\n\t\tStartElement(sdump, (char *) field.name);\n\t\tEndElementHeader(sdump, 1);\n\t\tsdump->indent++;\n\t\tif (!gf_list_count(cb->commandList)) {\n\t\t\t/*the arch does not allow for that (we would need a codec and so on, or decompress the command list\n\t\t\tin all cases...)*/\n\t\t\tif (sdump->trace && cb->bufferSize) {\n\t\t\t\tif (sdump->XMLDump) gf_fprintf(sdump->trace, \"<!--SFCommandBuffer cannot be dumped while playing - use MP4Box instead-->\\n\");\n\t\t\t\telse gf_fprintf(sdump->trace, \"#SFCommandBuffer cannot be dumped while playing - use MP4Box instead\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tgf_sm_dump_command_list(sdump, cb->commandList, sdump->indent, 0);\n\t\t}\n\t\tsdump->indent--;\n\t\tEndElement(sdump, (char *) field.name, 1);\n\t}\n\treturn;\n\n\tcase GF_SG_VRML_MFATTRREF:\n\t\tif (sdump->XMLDump) {\n\t\t\tMFAttrRef *ar = (MFAttrRef *)field.far_ptr;\n\t\t\tStartElement(sdump, (char *) field.name);\n\t\t\tEndElementHeader(sdump, 1);\n\t\t\tsdump->indent++;\n\n\t\t\tfor (i=0; i<ar->count; i++) {\n\t\t\t\tif (ar->vals[i].node) {\n\t\t\t\t\tGF_FieldInfo pinfo;\n\t\t\t\t\tDUMP_IND(sdump);\n\t\t\t\t\tgf_node_get_field(ar->vals[i].node, ar->vals[i].fieldIndex, &pinfo);\n\t\t\t\t\tgf_fprintf(sdump->trace, \"<store node=\\\"\");\n\t\t\t\t\tscene_dump_vrml_id(sdump, ar->vals[i].node);\n\t\t\t\t\tgf_fprintf(sdump->trace, \"\\\" field=\\\"%s\\\"/>\\n\", pinfo.name);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsdump->indent--;\n\t\t\tEndElement(sdump, (char *) field.name, 1);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\t}\n\n\n\tif (gf_sg_vrml_is_sf_field(field.fieldType)) {\n\t\tStartAttribute(sdump, field.name);\n\t\tgf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, node);\n\t\tEndAttribute(sdump);\n\t} else {\n\t\tGenMFField *mffield = (GenMFField *) field.far_ptr;\n\t\tsf_type = gf_sg_vrml_get_sf_type(field.fieldType);\n\n\t\tif (sdump->XMLDump && sdump->X3DDump) {\n\t\t\tswitch (sf_type) {\n\t\t\tcase GF_SG_VRML_SFSTRING:\n\t\t\tcase GF_SG_VRML_SFSCRIPT:\n\t\t\tcase GF_SG_VRML_SFURL:\n\t\t\t\tgf_fprintf(sdump->trace, \" %s=\\'\", (char *) field.name);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tStartAttribute(sdump, field.name);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tStartAttribute(sdump, field.name);\n\t\t}\n\n\t\tif (!sdump->XMLDump) gf_fprintf(sdump->trace, \"[\");\n\t\tfor (i=0; mffield && (i<mffield->count); i++) {\n\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, node);\n\t\t}\n\t\tif (!sdump->XMLDump) gf_fprintf(sdump->trace, \"]\");\n\n\t\tif (sdump->XMLDump && sdump->X3DDump) {\n\t\t\tswitch (sf_type) {\n\t\t\tcase GF_SG_VRML_SFSTRING:\n\t\t\tcase GF_SG_VRML_SFSCRIPT:\n\t\t\tcase GF_SG_VRML_SFURL:\n\t\t\t\tgf_fprintf(sdump->trace, \"\\'\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tEndAttribute(sdump);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tEndAttribute(sdump);\n\t\t}\n\t}\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 401,
    "critical_vars": [
      "p"
    ],
    "function": "nhmldump_send_header",
    "filename": "gpac/CVE-2020-23930/CVE-2020-23930_CWE-476_9eeac00b38348c664dfeae2525bba0cf1bc32349_write_nhml.c.diff",
    "function_code": "static void nhmldump_send_header(GF_NHMLDumpCtx *ctx)\n{\n\tGF_FilterPacket *dst_pck;\n\tchar nhml[1024];\n\tu32 size;\n\tu8 *output;\n\tconst GF_PropertyValue *p;\n\n\tctx->szRootName = \"NHNTStream\";\n\tif (ctx->dims) {\n\t\tctx->szRootName = \"DIMSStream\";\n\t}\n\n\tif (!ctx->filep) {\n\t\tsprintf(nhml, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n\");\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t}\n\n\t/*write header*/\n\tsprintf(nhml, \"<%s version=\\\"1.0\\\" \", ctx->szRootName);\n\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\n\n\tNHML_PRINT_UINT(GF_PROP_PID_ID, NULL, \"trackID\")\n\tNHML_PRINT_UINT(GF_PROP_PID_TIMESCALE, NULL, \"timeScale\")\n\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_IN_IOD);\n\tif (p && p->value.boolean) {\n\t\tsprintf(nhml, \"inRootOD=\\\"yes\\\" \");\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t}\n\n\tif (ctx->oti && (ctx->oti<GF_CODECID_LAST_MPEG4_MAPPING)) {\n\t\tsprintf(nhml, \"streamType=\\\"%d\\\" objectTypeIndication=\\\"%d\\\" \", ctx->streamtype, ctx->oti);\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32)strlen(nhml));\n\t} else {\n\t\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_SUBTYPE);\n\t\tif (p) {\n\t\t\tsprintf(nhml, \"%s=\\\"%s\\\" \", \"mediaType\", gf_4cc_to_str(p->value.uint));\n\t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\n\t\t\tNHML_PRINT_4CC(GF_PROP_PID_ISOM_SUBTYPE, \"mediaSubType\", \"mediaSubType\")\n\t\t} else {\n\t\t\tNHML_PRINT_4CC(GF_PROP_PID_CODECID, NULL, \"codecID\")\n\t\t}\n\t}\n\n\tif (ctx->w && ctx->h) {\n\t\t//compatibility with old arch, we might want to remove this\n\t\tswitch (ctx->streamtype) {\n\t\tcase GF_STREAM_VISUAL:\n\t\tcase GF_STREAM_SCENE:\n\t\t\tsprintf(nhml, \"width=\\\"%d\\\" height=\\\"%d\\\" \", ctx->w, ctx->h);\n\t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\telse if (ctx->sr && ctx->chan) {\n\t\tsprintf(nhml, \"sampleRate=\\\"%d\\\" numChannels=\\\"%d\\\" \", ctx->sr, ctx->chan);\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\tsprintf(nhml, \"sampleRate=\\\"%d\\\" numChannels=\\\"%d\\\" \", ctx->sr, ctx->chan);\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_AUDIO_FORMAT);\n\t\tif (p)\n\t\t\tsprintf(nhml, \"bitsPerSample=\\\"%d\\\" \", gf_audio_fmt_bit_depth(p->value.uint));\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t}\n\n\tNHML_PRINT_4CC(0, \"codec_vendor\", \"codecVendor\")\n\tNHML_PRINT_UINT(0, \"codec_version\", \"codecVersion\")\n\tNHML_PRINT_UINT(0, \"codec_revision\", \"codecRevision\")\n\tNHML_PRINT_STRING(0, \"compressor_name\", \"compressorName\")\n\tNHML_PRINT_UINT(0, \"temporal_quality\", \"temporalQuality\")\n\tNHML_PRINT_UINT(0, \"spatial_quality\", \"spatialQuality\")\n\tNHML_PRINT_UINT(0, \"hres\", \"horizontalResolution\")\n\tNHML_PRINT_UINT(0, \"vres\", \"verticalResolution\")\n\tNHML_PRINT_UINT(GF_PROP_PID_BIT_DEPTH_Y, NULL, \"bitDepth\")\n\n\tNHML_PRINT_STRING(0, \"meta:xmlns\", \"xml_namespace\")\n\tNHML_PRINT_STRING(0, \"meta:schemaloc\", \"xml_schema_location\")\n\tNHML_PRINT_STRING(0, \"meta:mime\", \"mime_type\")\n\n\tNHML_PRINT_STRING(0, \"meta:config\", \"config\")\n\tNHML_PRINT_STRING(0, \"meta:aux_mimes\", \"aux_mime_type\")\n\n\tif (ctx->codecid == GF_CODECID_DIMS) {\n\t\tif (gf_filter_pid_get_property_str(ctx->ipid, \"meta:xmlns\")==NULL) {\n\t\t\tsprintf(nhml, \"xmlns=\\\"http://www.3gpp.org/richmedia\\\" \");\n\t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\t}\n\n\t\tNHML_PRINT_UINT(0, \"dims:profile\", \"profile\")\n\t\tNHML_PRINT_UINT(0, \"dims:level\", \"level\")\n\t\tNHML_PRINT_UINT(0, \"dims:pathComponents\", \"pathComponents\")\n\n\t\tp = gf_filter_pid_get_property_str(ctx->ipid, \"dims:fullRequestHost\");\n\t\tif (p) {\n\t\t\tsprintf(nhml, \"useFullRequestHost=\\\"%s\\\" \", p->value.boolean ? \"yes\" : \"no\");\n\t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\t}\n\t\tp = gf_filter_pid_get_property_str(ctx->ipid, \"dims:streamType\");\n\t\tif (p) {\n\t\t\tsprintf(nhml, \"stream_type=\\\"%s\\\" \", p->value.boolean ? \"primary\" : \"secondary\");\n\t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\t}\n\t\tp = gf_filter_pid_get_property_str(ctx->ipid, \"dims:redundant\");\n\t\tif (p) {\n\t\t\tsprintf(nhml, \"contains_redundant=\\\"%s\\\" \", (p->value.uint==1) ? \"main\" : ((p->value.uint==1) ? \"redundant\" : \"main+redundant\") );\n\t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\t}\n\t\tNHML_PRINT_UINT(0, \"dims:scriptTypes\", \"scriptTypes\")\n\t}\n\n\t//send DCD\n\tif (ctx->opid_info) {\n\t\tsprintf(nhml, \"specificInfoFile=\\\"%s\\\" \", gf_file_basename(ctx->info_file) );\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\n\t\tdst_pck = gf_filter_pck_new_shared(ctx->opid_info, ctx->dcfg, ctx->dcfg_size, NULL);\n\t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);\n\t\tgf_filter_pck_set_readonly(dst_pck);\n\t\tgf_filter_pck_send(dst_pck);\n\t}\n\n\tNHML_PRINT_STRING(0, \"meta:encoding\", \"encoding\")\n\tNHML_PRINT_STRING(0, \"meta:contentEncoding\", \"content_encoding\")\n\tctx->uncompress = GF_FALSE;\n\tif (p) {\n\t\tif (!strcmp(p->value.string, \"deflate\")) ctx->uncompress = GF_TRUE;\n\t\telse {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[NHMLMx] content_encoding %s not supported\\n\", p->value.string ));\n\t\t}\n\t}\n\n\tif (ctx->opid_mdia) {\n\t\tsprintf(nhml, \"baseMediaFile=\\\"%s\\\" \", gf_file_basename(ctx->media_file) );\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t}\n\tsprintf(nhml, \">\\n\");\n\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\n\tgf_bs_get_content_no_truncate(ctx->bs_w, &ctx->nhml_buffer, &size, &ctx->nhml_buffer_size);\n\n\tif (ctx->filep) {\n\t\tgf_fwrite(ctx->nhml_buffer, size, ctx->filep);\n\t\treturn;\n\t}\n\n\tdst_pck = gf_filter_pck_new_alloc(ctx->opid_nhml, size, &output);\n\tmemcpy(output, ctx->nhml_buffer, size);\n\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_FALSE);\n\tgf_filter_pck_send(dst_pck);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 58,
    "critical_vars": [
      "is_qt_text"
    ],
    "function": "gf_isom_get_text_description",
    "filename": "gpac/CVE-2021-32139/CVE-2021-32139_CWE-476_d527325a9b72218612455a534a508f9e1753f76e_tx3g.c.diff",
    "function_code": "GF_Err gf_isom_get_text_description(GF_ISOFile *movie, u32 trackNumber, u32 descriptionIndex, GF_TextSampleDescriptor **out_desc)\n{\n\tGF_TrackBox *trak;\n\tu32 i;\n\tBool is_qt_text = GF_FALSE;\n\tGF_Tx3gSampleEntryBox *txt;\n\n\tif (!descriptionIndex || !out_desc) return GF_BAD_PARAM;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\n\tswitch (trak->Media->handler->handlerType) {\n\tcase GF_ISOM_MEDIA_TEXT:\n\tcase GF_ISOM_MEDIA_SUBT:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\ttxt = (GF_Tx3gSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, descriptionIndex - 1);\n\tif (!txt) return GF_BAD_PARAM;\n\tswitch (txt->type) {\n\tcase GF_ISOM_BOX_TYPE_TX3G:\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_TEXT:\n\t\tis_qt_text = GF_TRUE;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\t(*out_desc) = (GF_TextSampleDescriptor *) gf_odf_desc_new(GF_ODF_TX3G_TAG);\n\tif (! (*out_desc) ) return GF_OUT_OF_MEM;\n\t(*out_desc)->back_color = txt->back_color;\n\t(*out_desc)->default_pos = txt->default_box;\n\t(*out_desc)->default_style = txt->default_style;\n\t(*out_desc)->displayFlags = txt->displayFlags;\n\t(*out_desc)->vert_justif = txt->vertical_justification;\n\t(*out_desc)->horiz_justif = txt->horizontal_justification;\n\tif (is_qt_text) {\n\t\tGF_TextSampleEntryBox *qt_txt = (GF_TextSampleEntryBox *) txt;\n\t\tif (qt_txt->textName) {\n\t\t\t(*out_desc)->font_count = 1;\n\t\t\t(*out_desc)->fonts = (GF_FontRecord *) gf_malloc(sizeof(GF_FontRecord));\n\t\t\t(*out_desc)->fonts[0].fontName = gf_strdup(qt_txt->textName);\n\t\t}\n\t} else {\n\t\t(*out_desc)->font_count = txt->font_table->entry_count;\n\t\t(*out_desc)->fonts = (GF_FontRecord *) gf_malloc(sizeof(GF_FontRecord) * txt->font_table->entry_count);\n\t\tfor (i=0; i<txt->font_table->entry_count; i++) {\n\t\t\t(*out_desc)->fonts[i].fontID = txt->font_table->fonts[i].fontID;\n\t\t\tif (txt->font_table->fonts[i].fontName)\n\t\t\t\t(*out_desc)->fonts[i].fontName = gf_strdup(txt->font_table->fonts[i].fontName);\n\t\t}\n\t}\n\treturn GF_OK;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 73,
    "critical_vars": [
      "qt_txt"
    ],
    "function": "gf_isom_get_text_description",
    "filename": "gpac/CVE-2021-32139/CVE-2021-32139_CWE-476_d527325a9b72218612455a534a508f9e1753f76e_tx3g.c.diff",
    "function_code": "GF_Err gf_isom_get_text_description(GF_ISOFile *movie, u32 trackNumber, u32 descriptionIndex, GF_TextSampleDescriptor **out_desc)\n{\n\tGF_TrackBox *trak;\n\tu32 i;\n\tGF_Tx3gSampleEntryBox *txt = NULL;\n\tGF_TextSampleEntryBox *qt_txt = NULL;\n\tif (!descriptionIndex || !out_desc) return GF_BAD_PARAM;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\n\tswitch (trak->Media->handler->handlerType) {\n\tcase GF_ISOM_MEDIA_TEXT:\n\tcase GF_ISOM_MEDIA_SUBT:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\ttxt = (GF_Tx3gSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, descriptionIndex - 1);\n\tif (!txt) return GF_BAD_PARAM;\n\tswitch (txt->type) {\n\tcase GF_ISOM_BOX_TYPE_TX3G:\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_TEXT:\n\t\tqt_txt = (GF_TextSampleEntryBox *)txt;\n\t\ttxt = NULL;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\t(*out_desc) = (GF_TextSampleDescriptor *) gf_odf_desc_new(GF_ODF_TX3G_TAG);\n\tif (! (*out_desc) ) return GF_OUT_OF_MEM;\n\n\tif (qt_txt) {\n\t\t(*out_desc)->back_color = rgb_48_to_32(qt_txt->background_color);\n\t\t(*out_desc)->default_pos = qt_txt->default_box;\n\t\t(*out_desc)->default_style.style_flags = qt_txt->fontFace;\n\t\t(*out_desc)->default_style.text_color = rgb_48_to_32(qt_txt->foreground_color);\n\t\t(*out_desc)->displayFlags = qt_txt->displayFlags;\n\t\t(*out_desc)->vert_justif = -1;\n\t\t(*out_desc)->horiz_justif = qt_txt->textJustification;\n\t\tif (qt_txt->textName) {\n\t\t\t(*out_desc)->font_count = 1;\n\t\t\t(*out_desc)->fonts = (GF_FontRecord *) gf_malloc(sizeof(GF_FontRecord));\n\t\t\t(*out_desc)->fonts[0].fontName = gf_strdup(qt_txt->textName);\n\t\t}\n\t} else {\n\t\t(*out_desc)->back_color = txt->back_color;\n\t\t(*out_desc)->default_pos = txt->default_box;\n\t\t(*out_desc)->default_style = txt->default_style;\n\t\t(*out_desc)->displayFlags = txt->displayFlags;\n\t\t(*out_desc)->vert_justif = txt->vertical_justification;\n\t\t(*out_desc)->horiz_justif = txt->horizontal_justification;\n\t\t(*out_desc)->font_count = txt->font_table->entry_count;\n\t\t(*out_desc)->fonts = (GF_FontRecord *) gf_malloc(sizeof(GF_FontRecord) * txt->font_table->entry_count);\n\t\tfor (i=0; i<txt->font_table->entry_count; i++) {\n\t\t\t(*out_desc)->fonts[i].fontID = txt->font_table->fonts[i].fontID;\n\t\t\tif (txt->font_table->fonts[i].fontName)\n\t\t\t\t(*out_desc)->fonts[i].fontName = gf_strdup(txt->font_table->fonts[i].fontName);\n\t\t}\n\t}\n\treturn GF_OK;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 714,
    "critical_vars": [
      "is_qt_text"
    ],
    "function": "gf_isom_write_tx3g",
    "filename": "gpac/CVE-2021-32139/CVE-2021-32139_CWE-476_d527325a9b72218612455a534a508f9e1753f76e_tx3g.c.diff",
    "function_code": "static void gf_isom_write_tx3g(GF_Tx3gSampleEntryBox *a, GF_BitStream *bs, u32 sidx, u32 sidx_offset)\n{\n\tu32 size, j, fount_count;\n\tBool is_qt_text = (a->type==GF_ISOM_BOX_TYPE_TEXT) ? GF_TRUE : GF_FALSE;\n\tconst char *qt_fontname = NULL;\n\tvoid gpp_write_rgba(GF_BitStream *bs, u32 col);\n\tvoid gpp_write_box(GF_BitStream *bs, GF_BoxRecord *rec);\n\tvoid gpp_write_style(GF_BitStream *bs, GF_StyleRecord *rec);\n\n\n\tif (sidx_offset) gf_bs_write_u8(bs, sidx + sidx_offset);\n\n\t/*SINCE WINCE HAS A READONLY VERSION OF MP4 WE MUST DO IT BY HAND*/\n\tsize = 8 + 18 + 8 + 12;\n\tsize += 8 + 2;\n\tfount_count = 0;\n\tif (is_qt_text) {\n\t\tGF_TextSampleEntryBox *qt = (GF_TextSampleEntryBox *)a;\n\t\tif (qt->textName) {\n\t\t\tqt_fontname = qt->textName;\n\t\t\tfount_count = 1;\n\t\t}\n\t} else {\n\t\tif (a->font_table) {\n\t\t\tfount_count = a->font_table->entry_count;\n\t\t\tfor (j=0; j<fount_count; j++) {\n\t\t\t\tsize += 3;\n\t\t\t\tif (a->font_table->fonts[j].fontName) size += (u32) strlen(a->font_table->fonts[j].fontName);\n\t\t\t}\n\t\t}\n\t}\n\t/*write TextSampleEntry box*/\n\tgf_bs_write_u32(bs, size);\n\tgf_bs_write_u32(bs, a->type);\n\tgf_bs_write_data(bs, a->reserved, 6);\n\tgf_bs_write_u16(bs, a->dataReferenceIndex);\n\tgf_bs_write_u32(bs, a->displayFlags);\n\tgf_bs_write_u8(bs, a->horizontal_justification);\n\tgf_bs_write_u8(bs, a->vertical_justification);\n\tgpp_write_rgba(bs, a->back_color);\n\tgpp_write_box(bs, &a->default_box);\n\tgpp_write_style(bs, &a->default_style);\n\t/*write font table box*/\n\tsize -= (8 + 18 + 8 + 12);\n\tgf_bs_write_u32(bs, size);\n\tgf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_FTAB);\n\n\tgf_bs_write_u16(bs, fount_count);\n\tfor (j=0; j<fount_count; j++) {\n\t\tif (is_qt_text) {\n\t\t\tgf_bs_write_u16(bs, 0);\n\t\t\tif (qt_fontname) {\n\t\t\t\tu32 len = (u32) strlen(qt_fontname);\n\t\t\t\tgf_bs_write_u8(bs, len);\n\t\t\t\tgf_bs_write_data(bs, qt_fontname, len);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u8(bs, 0);\n\t\t\t}\n\t\t} else {\n\t\t\tgf_bs_write_u16(bs, a->font_table->fonts[j].fontID);\n\t\t\tif (a->font_table->fonts[j].fontName) {\n\t\t\t\tu32 len = (u32) strlen(a->font_table->fonts[j].fontName);\n\t\t\t\tgf_bs_write_u8(bs, len);\n\t\t\t\tgf_bs_write_data(bs, a->font_table->fonts[j].fontName, len);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u8(bs, 0);\n\t\t\t}\n\t\t}\n\t}\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 738,
    "critical_vars": [
      "qt->textName",
      "qt"
    ],
    "function": "gf_isom_write_tx3g",
    "filename": "gpac/CVE-2021-32139/CVE-2021-32139_CWE-476_d527325a9b72218612455a534a508f9e1753f76e_tx3g.c.diff",
    "function_code": "static void gf_isom_write_tx3g(GF_Tx3gSampleEntryBox *_a, GF_BitStream *bs, u32 sidx, u32 sidx_offset)\n{\n\tu32 size, j, fount_count;\n\tconst char *qt_fontname = NULL;\n\tvoid gpp_write_rgba(GF_BitStream *bs, u32 col);\n\tvoid gpp_write_box(GF_BitStream *bs, GF_BoxRecord *rec);\n\tvoid gpp_write_style(GF_BitStream *bs, GF_StyleRecord *rec);\n\n\tGF_TextSampleEntryBox *qt = (_a->type==GF_ISOM_BOX_TYPE_TEXT) ? (GF_TextSampleEntryBox *)_a : NULL;\n\tGF_Tx3gSampleEntryBox *ttxt = (_a->type!=GF_ISOM_BOX_TYPE_TEXT) ? (GF_Tx3gSampleEntryBox *)_a : NULL;\n\n\tif (sidx_offset) gf_bs_write_u8(bs, sidx + sidx_offset);\n\n\t/*SINCE WINCE HAS A READONLY VERSION OF MP4 WE MUST DO IT BY HAND*/\n\tsize = 8 + 18 + 8 + 12;\n\tsize += 8 + 2;\n\tfount_count = 0;\n\tif (qt && qt->textName) {\n\t\tqt_fontname = qt->textName;\n\t\tfount_count = 1;\n\t} else if (ttxt && ttxt->font_table) {\n\t\tfount_count = ttxt->font_table->entry_count;\n\t\tfor (j=0; j<fount_count; j++) {\n\t\t\tsize += 3;\n\t\t\tif (ttxt->font_table->fonts[j].fontName)\n\t\t\t\tsize += (u32) strlen(ttxt->font_table->fonts[j].fontName);\n\t\t}\n\t}\n\t/*write TextSampleEntry box*/\n\tgf_bs_write_u32(bs, size);\n\tgf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_TX3G);\n\tgf_bs_write_data(bs, _a->reserved, 6);\n\tgf_bs_write_u16(bs, _a->dataReferenceIndex);\n\tgf_bs_write_u32(bs, _a->displayFlags);\n\tif (qt) {\n\t\tGF_StyleRecord sr;\n\t\tmemset(&sr, 0, sizeof(GF_StyleRecord));\n\t\tgf_bs_write_u8(bs, qt->textJustification);\n\t\tgf_bs_write_u8(bs, (u8) -1);\n\t\tgpp_write_rgba(bs, rgb_48_to_32(qt->background_color) );\n\t\tgpp_write_box(bs, &qt->default_box);\n\t\tsr.text_color = rgb_48_to_32(qt->foreground_color);\n\t\tsr.style_flags = qt->fontFace;\n\t\tgpp_write_style(bs, &sr);\n\t} else {\n\t\tgf_bs_write_u8(bs, ttxt->horizontal_justification);\n\t\tgf_bs_write_u8(bs, ttxt->vertical_justification);\n\t\tgpp_write_rgba(bs, ttxt->back_color);\n\t\tgpp_write_box(bs, &ttxt->default_box);\n\t\tgpp_write_style(bs, &ttxt->default_style);\n\t}\n\t/*write font table box*/\n\tsize -= (8 + 18 + 8 + 12);\n\tgf_bs_write_u32(bs, size);\n\tgf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_FTAB);\n\n\tgf_bs_write_u16(bs, fount_count);\n\tfor (j=0; j<fount_count; j++) {\n\t\tif (qt) {\n\t\t\tgf_bs_write_u16(bs, 0);\n\t\t\tif (qt_fontname) {\n\t\t\t\tu32 len = (u32) strlen(qt_fontname);\n\t\t\t\tgf_bs_write_u8(bs, len);\n\t\t\t\tgf_bs_write_data(bs, qt_fontname, len);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u8(bs, 0);\n\t\t\t}\n\t\t} else {\n\t\t\tgf_bs_write_u16(bs, ttxt->font_table->fonts[j].fontID);\n\t\t\tif (ttxt->font_table->fonts[j].fontName) {\n\t\t\t\tu32 len = (u32) strlen(ttxt->font_table->fonts[j].fontName);\n\t\t\t\tgf_bs_write_u8(bs, len);\n\t\t\t\tgf_bs_write_data(bs, ttxt->font_table->fonts[j].fontName, len);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u8(bs, 0);\n\t\t\t}\n\t\t}\n\t}\n}",
    "label": "False"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 2879,
    "critical_vars": [
      "e"
    ],
    "function": "gf_isom_fragment_add_sample_ex",
    "filename": "gpac/CVE-2023-2840/CVE-2023-2840_CWE-476_ba59206b3225f0e8e95a27eff41cb1c49ddf9a37_movie_fragments.c.diff",
    "function_code": "GF_Err gf_isom_fragment_add_sample_ex(GF_ISOFile *movie, GF_ISOTrackID TrackID, const GF_ISOSample *sample, u32 DescIndex,\n                                   u32 Duration, u8 PaddingBits, u16 DegradationPriority, Bool redundant_coding, void **ref, u32 ref_offset)\n{\n\tu32 count, buffer_size;\n\tu8 *buffer;\n\tu64 pos;\n\tGF_ISOSample *od_sample = NULL;\n\tGF_TrunEntry ent, *prev_ent;\n\tGF_TrackFragmentBox *traf, *traf_2;\n\tGF_TrackFragmentRunBox *trun;\n\n\tif (!movie->moof || !(movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) || !sample)\n\t\treturn GF_BAD_PARAM;\n\n\ttraf = gf_isom_get_traf(movie, TrackID);\n\tif (!traf)\n\t\treturn GF_BAD_PARAM;\n\n\tif (!traf->tfhd->sample_desc_index)\n\t\ttraf->tfhd->sample_desc_index = DescIndex ? DescIndex : traf->trex->def_sample_desc_index;\n\n\tpos = gf_bs_get_position(movie->editFileMap->bs);\n\n\n\t//WARNING: we change stream description, create a new TRAF\n\tif ( DescIndex && (traf->tfhd->sample_desc_index != DescIndex)) {\n\t\t//if we're caching flush the current run\n\t\tif (traf->DataCache && !traf->use_sample_interleave) {\n\t\t\tcount = gf_list_count(traf->TrackRuns);\n\t\t\tif (count) {\n\t\t\t\ttrun = (GF_TrackFragmentRunBox *)gf_list_get(traf->TrackRuns, count-1);\n\t\t\t\ttrun->data_offset = (u32) (pos - movie->moof->fragment_offset - 8);\n\t\t\t\tgf_bs_get_content(trun->cache, &buffer, &buffer_size);\n\t\t\t\tgf_bs_write_data(movie->editFileMap->bs, buffer, buffer_size);\n\t\t\t\tgf_bs_del(trun->cache);\n\t\t\t\ttrun->cache = NULL;\n\t\t\t\tgf_free(buffer);\n\t\t\t}\n\t\t}\n\t\ttraf_2 = (GF_TrackFragmentBox *) gf_isom_box_new_parent(&movie->moof->child_boxes, GF_ISOM_BOX_TYPE_TRAF);\n\t\tif (!traf_2) return GF_OUT_OF_MEM;\n\t\ttraf_2->trex = traf->trex;\n\t\ttraf_2->tfhd = (GF_TrackFragmentHeaderBox *) gf_isom_box_new_parent(&traf_2->child_boxes, GF_ISOM_BOX_TYPE_TFHD);\n\t\tif (!traf_2->tfhd) return GF_OUT_OF_MEM;\n\t\ttraf_2->tfhd->trackID = traf->tfhd->trackID;\n\t\t//keep the same offset\n\t\ttraf_2->tfhd->base_data_offset = movie->moof->fragment_offset + 8;\n\t\tgf_list_add(movie->moof->TrackList, traf_2);\n\n\t\t//duplicate infos\n\t\ttraf_2->IFrameSwitching = traf->IFrameSwitching;\n\t\ttraf_2->use_sample_interleave = traf->use_sample_interleave;\n\t\ttraf_2->interleave_id = traf->interleave_id;\n\t\ttraf_2->truns_first = traf->truns_first;\n\t\ttraf_2->truns_v1 = traf->truns_v1;\n\t\ttraf_2->large_tfdt = traf->large_tfdt;\n\t\ttraf_2->DataCache  = traf->DataCache;\n\t\ttraf_2->tfhd->sample_desc_index  = DescIndex;\n\n\t\t//switch them ...\n\t\ttraf = traf_2;\n\t}\n\n\tpos = movie->moof->trun_ref_size ? (8+movie->moof->trun_ref_size) : gf_bs_get_position(movie->editFileMap->bs);\n\n\t//check if we need a new trun entry\n\tcount = (traf->use_sample_interleave && traf->force_new_trun) ? 0 : gf_list_count(traf->TrackRuns);\n\tif (count) {\n\t\ttrun = (GF_TrackFragmentRunBox *)gf_list_get(traf->TrackRuns, count-1);\n\t\t//check data offset when no caching as trun entries shall ALWAYS be contiguous samples\n\t\tif (!traf->DataCache && (movie->moof->fragment_offset + 8 + trun->data_offset + trun->run_size != pos) )\n\t\t\tcount = 0;\n\n\t\t//check I-frame detection\n\t\tif (traf->IFrameSwitching && sample->IsRAP)\n\t\t\tcount = 0;\n\n\t\tif (traf->DataCache && (traf->DataCache==trun->sample_count) && !traf->use_sample_interleave)\n\t\t\tcount = 0;\n\n\t\tif (traf->force_new_trun)\n\t\t\tcount = 0;\n\n\t\t//if data cache is on and we're changing TRUN, store the cache and update data offset\n\t\tif (!count && traf->DataCache && !traf->use_sample_interleave) {\n\t\t\ttrun->data_offset = (u32) (pos - movie->moof->fragment_offset - 8);\n\t\t\tgf_bs_get_content(trun->cache, &buffer, &buffer_size);\n\t\t\tgf_bs_write_data(movie->editFileMap->bs, buffer, buffer_size);\n\t\t\tgf_bs_del(trun->cache);\n\t\t\ttrun->cache = NULL;\n\t\t\tgf_free(buffer);\n\t\t}\n\t}\n\ttraf->force_new_trun = 0;\n\n\t//new run\n\tif (!count) {\n\t\ttrun = (GF_TrackFragmentRunBox *) gf_isom_box_new_parent(&traf->child_boxes, GF_ISOM_BOX_TYPE_TRUN);\n\t\tif (!trun) return GF_OUT_OF_MEM;\n\t\t//store data offset (we have the 8 btyes offset of the MDAT)\n\t\ttrun->data_offset = (u32) (pos - movie->moof->fragment_offset - 8);\n\t\tgf_list_add(traf->TrackRuns, trun);\n#ifdef GF_ENABLE_CTRN\n\t\ttrun->use_ctrn = traf->use_ctrn;\n\t\ttrun->use_inherit = traf->use_inherit;\n\t\ttrun->ctso_multiplier = traf->trex->def_sample_duration;\n#endif\n\t\ttrun->interleave_id = traf->interleave_id;\n\t\tif (traf->truns_v1)\n\t\t\ttrun->version = 1;\n\n\t\t//if we use data caching, create a bitstream\n\t\tif (traf->DataCache)\n\t\t\ttrun->cache = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t}\n\n\tmemset(&ent, 0, sizeof(GF_TrunEntry));\n\tent.CTS_Offset = sample->CTS_Offset;\n\tent.Duration = Duration;\n\tent.dts = sample->DTS;\n\tent.nb_pack = sample->nb_pack;\n\tent.flags = GF_ISOM_FORMAT_FRAG_FLAGS(PaddingBits, sample->IsRAP, DegradationPriority);\n\tif (sample->IsRAP) {\n\t\tent.flags |= GF_ISOM_GET_FRAG_DEPEND_FLAGS(0, 2, 0, (redundant_coding ? 1 : 0) );\n\t\tent.SAP_type = sample->IsRAP;\n\t}\n\tif (trun->nb_samples) {\n\t\tprev_ent = &trun->samples[trun->nb_samples-1];\n\t} else {\n\t\tprev_ent = NULL;\n\t}\n\n\tif (prev_ent && (prev_ent->dts || !prev_ent->Duration) && sample->DTS) {\n\t\tu32 nsamp = prev_ent->nb_pack ? prev_ent->nb_pack : 1;\n\t\tif (nsamp*prev_ent->Duration != sample->DTS - prev_ent->dts)\n\t\t\tprev_ent->Duration = (u32) (sample->DTS - prev_ent->dts) / nsamp;\n\t}\n\tif (trun->nb_samples >= trun->sample_alloc) {\n\t\ttrun->sample_alloc += 50;\n\t\tif (trun->nb_samples >= trun->sample_alloc) trun->sample_alloc = trun->nb_samples+1;\n\t\ttrun->samples = gf_realloc(trun->samples, sizeof(GF_TrunEntry)*trun->sample_alloc);\n\t\tif (!trun->samples) return GF_OUT_OF_MEM;\n\t}\n\n\t//rewrite OD frames\n\tif (traf->trex->track->Media->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\t//this may fail if dependencies are not well done ...\n\t\tGF_Err e = Media_ParseODFrame(traf->trex->track->Media, sample, &od_sample);\n\t\tif (!od_sample) return e;\n\t\tsample = od_sample;\n\t}\n\n\tent.size = sample->dataLength;\n\ttrun->samples[trun->nb_samples] = ent;\n\ttrun->nb_samples ++;\n\ttrun->run_size += ent.size;\n\n\tif (sample->CTS_Offset<0) {\n\t\ttrun->version = 1;\n\t}\n\ttrun->sample_count += sample->nb_pack ? sample->nb_pack : 1;\n\n\t//finally write the data\n\tif (sample->dataLength) {\n\t\tu32 res = 0;\n\t\tif (!traf->DataCache) {\n\t\t\tif (movie->moof_first && movie->on_block_out && (ref || trun->sample_refs)) {\n\t\t\t\tGF_TrafSampleRef *sref;\n\t\t\t\tif (!trun->sample_refs) trun->sample_refs = gf_list_new();\n\t\t\t\tGF_SAFEALLOC(sref, GF_TrafSampleRef);\n\t\t\t\tif (!sref) return GF_OUT_OF_MEM;\n\t\t\t\tif (ref && *ref && !od_sample) {\n\t\t\t\t\tsref->data = sample->data;\n\t\t\t\t\tsref->len = sample->dataLength;\n\t\t\t\t\tsref->ref = *ref;\n\t\t\t\t\tsref->ref_offset = ref_offset;\n\t\t\t\t\t*ref = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tsref->data = gf_malloc(sample->dataLength);\n\t\t\t\t\tif (!sref->data) {\n\t\t\t\t\t\tgf_free(sref);\n\t\t\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(sref->data, sample->data, sample->dataLength);\n\t\t\t\t\tsref->len = sample->dataLength;\n\t\t\t\t}\n\t\t\t\tres = sref->len;\n\t\t\t\ttraf->trun_ref_size += res;\n\t\t\t\tmovie->moof->trun_ref_size += res;\n\t\t\t\tgf_list_add(trun->sample_refs, sref);\n\t\t\t} else {\n\t\t\t\tres = gf_bs_write_data(movie->editFileMap->bs, sample->data, sample->dataLength);\n\t\t\t}\n\t\t} else if (trun->cache) {\n\t\t\tres = gf_bs_write_data(trun->cache, sample->data, sample->dataLength);\n\t\t} else {\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\tif (res!=sample->dataLength) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso fragment] Could not add a sample with a size of %u bytes\\n\", sample->dataLength));\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\n\t}\n\tif (od_sample) gf_isom_sample_del(&od_sample);\n\n\tif (traf->trex->tfra) {\n\t\tGF_RandomAccessEntry *raf;\n\t\traf = &traf->trex->tfra->entries[traf->trex->tfra->nb_entries-1];\n\t\t//if sample is sync, store its time and trun number\n\t\tif (!raf->trun_number && sample->IsRAP) {\n\t\t\traf->time = sample->DTS + sample->CTS_Offset;\n\t\t\traf->trun_number = gf_list_count(traf->TrackRuns);\n\t\t\traf->sample_number = trun->sample_count;\n\t\t}\n\t}\n\treturn GF_OK;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Var-Declaration",
    "line_old": 83,
    "critical_vars": [
      "e"
    ],
    "function": "abst_box_read",
    "filename": "gpac/CVE-2021-32132/CVE-2021-32132_CWE-476_e74be5976a6fee059c638050a237893f7e9a3b23_box_code_adobe.c.diff",
    "function_code": "GF_Err abst_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;\n\tint i;\n\tu32 tmp_strsize;\n\tchar *tmp_str;\n\tBool zfound=GF_FALSE;\n\tGF_Err e;\n\n\tISOM_DECREASE_SIZE(ptr, 25)\n\tptr->bootstrapinfo_version = gf_bs_read_u32(bs);\n\tptr->profile = gf_bs_read_int(bs, 2);\n\tptr->live = gf_bs_read_int(bs, 1);\n\tptr->update = gf_bs_read_int(bs, 1);\n\tptr->reserved = gf_bs_read_int(bs, 4);\n\tptr->time_scale = gf_bs_read_u32(bs);\n\tptr->current_media_time = gf_bs_read_u64(bs);\n\tptr->smpte_time_code_offset = gf_bs_read_u64(bs);\n\n\ti=0;\n\tif (ptr->size<8) return GF_ISOM_INVALID_FILE;\n\ttmp_strsize =(u32)ptr->size;\n\ttmp_str = gf_malloc(sizeof(char)*tmp_strsize);\n\tif (!tmp_str) return GF_OUT_OF_MEM;\n\tmemset(tmp_str, 0, sizeof(char)*tmp_strsize);\n\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i]) {\n\t\t\tzfound = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (!zfound)\n\t\treturn GF_ISOM_INVALID_FILE;\n\tif (i) {\n\t\tptr->movie_identifier = gf_strdup(tmp_str);\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->server_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->server_entry_count; i++) {\n\t\tint j=0;\n\t\tzfound = GF_FALSE;\n\t\ttmp_strsize=(u32)ptr->size;\n\t\twhile (tmp_strsize) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j]) {\n\t\t\t\tzfound = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\tif (!zfound)\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tif (j) {\n\t\t\tgf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);\n\t\t}\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->quality_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tint j=0;\n\t\tzfound = GF_FALSE;\n\t\ttmp_strsize=(u32)ptr->size;\n\t\twhile (tmp_strsize) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j]) {\n\t\t\t\tzfound = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\n\t\tif (!zfound)\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tif (j) {\n\t\t\tgf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);\n\t\t}\n\t}\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size;\n\tzfound = GF_FALSE;\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i]) {\n\t\t\tzfound = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (!zfound)\n\t\treturn GF_ISOM_INVALID_FILE;\n\tif (i) {\n\t\tptr->drm_data = gf_strdup(tmp_str);\n\t}\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size;\n\tzfound = GF_FALSE;\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i]) {\n\t\t\tzfound = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (!zfound)\n\t\treturn GF_ISOM_INVALID_FILE;\n\tif (i) {\n\t\tptr->meta_data = gf_strdup(tmp_str);\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->segment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->segment_run_table_count; i++) {\n\t\tGF_AdobeSegmentRunTableBox *asrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&asrt, bs);\n\t\tif (e) {\n\t\t\tif (asrt) gf_isom_box_del((GF_Box*)asrt);\n\t\t\tgf_free(tmp_str);\n\t\t\treturn e;\n\t\t}\n\t\tgf_list_add(ptr->segment_run_table_entries, asrt);\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->fragment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->fragment_run_table_count; i++) {\n\t\tGF_AdobeFragmentRunTableBox *afrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&afrt, bs);\n\t\tif (e) {\n\t\t\tif (afrt) gf_isom_box_del((GF_Box*)afrt);\n\t\t\tgf_free(tmp_str);\n\t\t\treturn e;\n\t\t}\n\t\tgf_list_add(ptr->fragment_run_table_entries, afrt);\n\t}\n\n\tgf_free(tmp_str);\n\n\treturn GF_OK;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 83,
    "critical_vars": [
      "e"
    ],
    "function": "abst_box_read",
    "filename": "gpac/CVE-2021-32132/CVE-2021-32132_CWE-476_e74be5976a6fee059c638050a237893f7e9a3b23_box_code_adobe.c.diff",
    "function_code": "GF_Err abst_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;\n\tint i;\n\tu32 tmp_strsize;\n\tchar *tmp_str;\n\tBool zfound=GF_FALSE;\n\tGF_Err e = GF_OK;\n\n\tISOM_DECREASE_SIZE(ptr, 25)\n\tptr->bootstrapinfo_version = gf_bs_read_u32(bs);\n\tptr->profile = gf_bs_read_int(bs, 2);\n\tptr->live = gf_bs_read_int(bs, 1);\n\tptr->update = gf_bs_read_int(bs, 1);\n\tptr->reserved = gf_bs_read_int(bs, 4);\n\tptr->time_scale = gf_bs_read_u32(bs);\n\tptr->current_media_time = gf_bs_read_u64(bs);\n\tptr->smpte_time_code_offset = gf_bs_read_u64(bs);\n\n\ti=0;\n\tif (ptr->size<8) return GF_ISOM_INVALID_FILE;\n\ttmp_strsize =(u32)ptr->size;\n\ttmp_str = gf_malloc(sizeof(char)*tmp_strsize);\n\tif (!tmp_str) return GF_OUT_OF_MEM;\n\tmemset(tmp_str, 0, sizeof(char)*tmp_strsize);\n\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i]) {\n\t\t\tzfound = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (!zfound) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\tif (i) {\n\t\tptr->movie_identifier = gf_strdup(tmp_str);\n\t}\n\n\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\tptr->server_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->server_entry_count; i++) {\n\t\tint j=0;\n\t\tzfound = GF_FALSE;\n\t\ttmp_strsize=(u32)ptr->size;\n\t\twhile (tmp_strsize) {\n\t\t\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j]) {\n\t\t\t\tzfound = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\tif (!zfound) {\n\t\t\te = GF_ISOM_INVALID_FILE;\n\t\t\tgoto exit;\n\t\t}\n\t\tif (j) {\n\t\t\tgf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);\n\t\t}\n\t}\n\tif (ptr->server_entry_count != gf_list_count(ptr->server_entry_table)) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\n\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\tptr->quality_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tint j=0;\n\t\tzfound = GF_FALSE;\n\t\ttmp_strsize=(u32)ptr->size;\n\t\twhile (tmp_strsize) {\n\t\t\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j]) {\n\t\t\t\tzfound = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\n\t\tif (!zfound) {\n\t\t\te = GF_ISOM_INVALID_FILE;\n\t\t\tgoto exit;\n\t\t}\n\t\tif (j) {\n\t\t\tgf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);\n\t\t}\n\t}\n\tif (ptr->quality_entry_count != gf_list_count(ptr->quality_entry_table)) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size;\n\tzfound = GF_FALSE;\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i]) {\n\t\t\tzfound = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (!zfound) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\n\tif (i) {\n\t\tptr->drm_data = gf_strdup(tmp_str);\n\t}\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size;\n\tzfound = GF_FALSE;\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i]) {\n\t\t\tzfound = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (!zfound) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\n\tif (i) {\n\t\tptr->meta_data = gf_strdup(tmp_str);\n\t}\n\n\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\tptr->segment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->segment_run_table_count; i++) {\n\t\tGF_AdobeSegmentRunTableBox *asrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&asrt, bs);\n\t\tif (e) {\n\t\t\tif (asrt) gf_isom_box_del((GF_Box*)asrt);\n\t\t\tgoto exit;\n\t\t}\n\t\tgf_list_add(ptr->segment_run_table_entries, asrt);\n\t}\n\tif (ptr->segment_run_table_count != gf_list_count(ptr->segment_run_table_entries)) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\n\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\tptr->fragment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->fragment_run_table_count; i++) {\n\t\tGF_AdobeFragmentRunTableBox *afrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&afrt, bs);\n\t\tif (e) {\n\t\t\tif (afrt) gf_isom_box_del((GF_Box*)afrt);\n\t\t\tgoto exit;\n\t\t}\n\t\tgf_list_add(ptr->fragment_run_table_entries, afrt);\n\t}\n\tif (ptr->fragment_run_table_count != gf_list_count(ptr->fragment_run_table_entries)) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\nexit:\n\tgf_free(tmp_str);\n\treturn e;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 1627,
    "critical_vars": [
      "dump",
      "sdp"
    ],
    "function": "dump_isom_sdp",
    "filename": "gpac/CVE-2020-23932/CVE-2020-23932_CWE-476_ce01bd15f711d4575b7424b54b3a395ec64c1784_filedump.c.diff",
    "function_code": "#ifndef GPAC_DISABLE_ISOM_HINTING\n\nvoid dump_isom_sdp(GF_ISOFile *file, char *inName, Bool is_final_name)\n{\n\tconst char *sdp;\n\tu32 size, i;\n\tFILE *dump;\n\n\tif (inName) {\n\t\tchar szBuf[1024];\n\t\tstrcpy(szBuf, inName);\n\t\tif (!is_final_name) {\n\t\t\tchar *ext = strchr(szBuf, '.');\n\t\t\tif (ext) ext[0] = 0;\n\t\t\tstrcat(szBuf, \"_sdp.txt\");\n\t\t}\n\t\tdump = gf_fopen(szBuf, \"wt\");\n\t\tif (!dump) {\n\t\t\tfprintf(stderr, \"Failed to open %s for dumping\\n\", szBuf);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tdump = stdout;\n\t\tfprintf(dump, \"* File SDP content *\\n\\n\");\n\t}\n\t//get the movie SDP\n\tgf_isom_sdp_get(file, &sdp, &size);\n\tfprintf(dump, \"%s\", sdp);\n\tfprintf(dump, \"\\r\\n\");\n\n\t//then tracks\n\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\tif (gf_isom_get_media_type(file, i+1) != GF_ISOM_MEDIA_HINT) continue;\n\t\tgf_isom_sdp_track_get(file, i+1, &sdp, &size);\n\t\tfprintf(dump, \"%s\", sdp);\n\t}\n\tfprintf(dump, \"\\n\\n\");",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 1627,
    "critical_vars": [
      "sdp",
      "size"
    ],
    "function": "dump_isom_sdp",
    "filename": "gpac/CVE-2020-23932/CVE-2020-23932_CWE-476_ce01bd15f711d4575b7424b54b3a395ec64c1784_filedump.c.diff",
    "function_code": "#ifndef GPAC_DISABLE_ISOM_HINTING\n\nvoid dump_isom_sdp(GF_ISOFile *file, char *inName, Bool is_final_name)\n{\n\tconst char *sdp;\n\tu32 size, i;\n\tFILE *dump;\n\n\tif (inName) {\n\t\tchar szBuf[1024];\n\t\tstrcpy(szBuf, inName);\n\t\tif (!is_final_name) {\n\t\t\tchar *ext = strchr(szBuf, '.');\n\t\t\tif (ext) ext[0] = 0;\n\t\t\tstrcat(szBuf, \"_sdp.txt\");\n\t\t}\n\t\tdump = gf_fopen(szBuf, \"wt\");\n\t\tif (!dump) {\n\t\t\tfprintf(stderr, \"Failed to open %s for dumping\\n\", szBuf);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tdump = stdout;\n\t\tfprintf(dump, \"* File SDP content *\\n\\n\");\n\t}\n\t//get the movie SDP\n\tgf_isom_sdp_get(file, &sdp, &size);\n\tif (sdp && size)\n\t\tfprintf(dump, \"%s\", sdp);\n\tfprintf(dump, \"\\r\\n\");\n\n\t//then tracks\n\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\tif (gf_isom_get_media_type(file, i+1) != GF_ISOM_MEDIA_HINT) continue;\n\t\tgf_isom_sdp_track_get(file, i+1, &sdp, &size);\n\t\tfprintf(dump, \"%s\", sdp);\n\t}\n\tfprintf(dump, \"\\n\\n\");",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "for-Condition",
    "line_old": 11086,
    "critical_vars": [
      "i"
    ],
    "function": "gitn_box_del",
    "filename": "gpac/CVE-2021-4043/CVE-2021-4043_CWE-476_64a2e1b799352ac7d7aad1989bc06e7b0f2b01db_box_code_base.c.diff",
    "function_code": "\nvoid gitn_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *)s;\n\tif (ptr == NULL) return;\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tif (ptr->entries[i].name) gf_free(ptr->entries[i].name);\n\t}\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 11086,
    "critical_vars": [
      "ptr->entries"
    ],
    "function": "gitn_box_del",
    "filename": "gpac/CVE-2021-4043/CVE-2021-4043_CWE-476_64a2e1b799352ac7d7aad1989bc06e7b0f2b01db_box_code_base.c.diff",
    "function_code": "\nvoid gitn_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->entries) {\n\t\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\t\tif (ptr->entries[i].name) gf_free(ptr->entries[i].name);\n\t\t}\n\t\tgf_free(ptr->entries);\n\t}\n\tgf_free(ptr);",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 5365,
    "critical_vars": [
      "GF_MPEGSampleEntryBox"
    ],
    "function": "gf_isom_set_extraction_slc",
    "filename": "gpac/CVE-2021-31258/CVE-2021-31258_CWE-476_ebfa346eff05049718f7b80041093b4c5581c24e_isom_write.c.diff",
    "function_code": "GF_Err gf_isom_set_extraction_slc(GF_ISOFile *the_file, u32 trackNumber, u32 StreamDescriptionIndex, const GF_SLConfig *slConfig)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_Err e;\n\tGF_SLConfig **slc;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, StreamDescriptionIndex, &entry, NULL);\n\tif (e) return e;\n\n\t//we must be sure we are not using a remote ESD\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\tif (((GF_MPEGSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = & ((GF_MPEGSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tif (((GF_MPEGAudioSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = & ((GF_MPEGAudioSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tif (((GF_MPEGVisualSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = & ((GF_MPEGVisualSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tif (*slc) {\n\t\tgf_odf_desc_del((GF_Descriptor *)*slc);\n\t\t*slc = NULL;\n\t}\n\tif (!slConfig) return GF_OK;\n\t//finally duplicate the SL\n\treturn gf_odf_desc_copy((GF_Descriptor *) slConfig, (GF_Descriptor **) slc);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 134,
    "critical_vars": [
      "ref->trackRef",
      "mpod->trackIDs"
    ],
    "function": "Media_RewriteODFrame",
    "filename": "gpac/CVE-2021-32440/CVE-2021-32440_CWE-476_f0ba83717b6e4d7a15a1676d1fe06152e199b011_media_odf.c.diff",
    "function_code": "GF_Err Media_RewriteODFrame(GF_MediaBox *mdia, GF_ISOSample *sample)\n{\n\tGF_Err e;\n\tGF_ODCodec *ODdecode;\n\tGF_ODCodec *ODencode;\n\tGF_ODCom *com;\n\n\t//the commands we proceed\n\tGF_ESDUpdate *esdU, *esdU2;\n\tGF_ESDRemove *esdR, *esdR2;\n\tGF_ODUpdate *odU, *odU2;\n\n\t//the desc they contain\n\tGF_ObjectDescriptor *od;\n\tGF_IsomObjectDescriptor *isom_od;\n\tGF_ESD *esd;\n\tGF_ES_ID_Ref *ref;\n\tGF_Descriptor *desc;\n\tGF_TrackReferenceTypeBox *mpod;\n\tu32 i, j, skipped;\n\n\tif (!mdia || !sample || !sample->data || !sample->dataLength) return GF_BAD_PARAM;\n\n\tmpod = NULL;\n\te = Track_FindRef(mdia->mediaTrack, GF_ISOM_BOX_TYPE_MPOD, &mpod);\n\tif (e) return e;\n\t//no references, nothing to do...\n\tif (!mpod || !mpod->trackIDs) return GF_OK;\n\n\tODdecode = gf_odf_codec_new();\n\tif (!ODdecode) return GF_OUT_OF_MEM;\n\tODencode = gf_odf_codec_new();\n\tif (!ODencode) {\n\t\tgf_odf_codec_del(ODdecode);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\te = gf_odf_codec_set_au(ODdecode, sample->data, sample->dataLength);\n\tif (e) goto err_exit;\n\te = gf_odf_codec_decode(ODdecode);\n\tif (e) goto err_exit;\n\n\twhile (1) {\n\t\tcom = gf_odf_codec_get_com(ODdecode);\n\t\tif (!com) break;\n\n\t\t//we only need to rewrite commands with ESDs inside: ESDUpdate and ODUpdate\n\t\tswitch (com->tag) {\n\t\tcase GF_ODF_OD_UPDATE_TAG:\n\t\t\todU = (GF_ODUpdate *) com;\n\t\t\todU2 = (GF_ODUpdate *) gf_odf_com_new(GF_ODF_OD_UPDATE_TAG);\n\n\t\t\ti=0;\n\t\t\twhile ((desc = (GF_Descriptor*)gf_list_enum(odU->objectDescriptors, &i))) {\n\t\t\t\tswitch (desc->tag) {\n\t\t\t\tcase GF_ODF_OD_TAG:\n\t\t\t\tcase GF_ODF_ISOM_OD_TAG:\n\t\t\t\t//IOD can be used in OD streams\n\t\t\t\tcase GF_ODF_ISOM_IOD_TAG:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t\t}\n\t\t\t\te = gf_odf_desc_copy(desc, (GF_Descriptor **)&isom_od);\n\t\t\t\tif (e) goto err_exit;\n\n\t\t\t\t//create our OD...\n\t\t\t\tif (desc->tag == GF_ODF_ISOM_IOD_TAG) {\n\t\t\t\t\tod = (GF_ObjectDescriptor *) gf_malloc(sizeof(GF_InitialObjectDescriptor));\n\t\t\t\t} else {\n\t\t\t\t\tod = (GF_ObjectDescriptor *) gf_malloc(sizeof(GF_ObjectDescriptor));\n\t\t\t\t}\n\t\t\t\tif (!od) {\n\t\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\t\tgoto err_exit;\n\t\t\t\t}\n\t\t\t\tod->ESDescriptors = gf_list_new();\n\t\t\t\t//and duplicate...\n\t\t\t\tod->objectDescriptorID = isom_od->objectDescriptorID;\n\t\t\t\tod->tag = GF_ODF_OD_TAG;\n\t\t\t\tod->URLString = isom_od->URLString;\n\t\t\t\tisom_od->URLString = NULL;\n\t\t\t\tod->extensionDescriptors = isom_od->extensionDescriptors;\n\t\t\t\tisom_od->extensionDescriptors = NULL;\n\t\t\t\tod->IPMP_Descriptors = isom_od->IPMP_Descriptors;\n\t\t\t\tisom_od->IPMP_Descriptors = NULL;\n\t\t\t\tod->OCIDescriptors = isom_od->OCIDescriptors;\n\t\t\t\tisom_od->OCIDescriptors = NULL;\n\n\t\t\t\t//init as IOD\n\t\t\t\tif (isom_od->tag == GF_ODF_ISOM_IOD_TAG) {\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->audio_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->audio_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->inlineProfileFlag = ((GF_IsomInitialObjectDescriptor *)isom_od)->inlineProfileFlag;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->graphics_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->graphics_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->OD_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->OD_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->scene_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->scene_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->visual_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->visual_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->IPMPToolList = ((GF_IsomInitialObjectDescriptor *)isom_od)->IPMPToolList;\n\t\t\t\t\t((GF_IsomInitialObjectDescriptor *)isom_od)->IPMPToolList = NULL;\n\t\t\t\t}\n\n\t\t\t\t//then rewrite the ESDesc\n\t\t\t\tj=0;\n\t\t\t\twhile ((ref = (GF_ES_ID_Ref*)gf_list_enum(isom_od->ES_ID_RefDescriptors, &j))) {\n\t\t\t\t\tif (!mpod->trackIDs || !ref->trackRef || (ref->trackRef>mpod->trackIDCount)) continue;\n\t\t\t\t\t//if the ref index is not valid, skip this desc...\n\t\t\t\t\tif (gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1]) == NULL) continue;\n\t\t\t\t\t//OK, get the esd\n\t\t\t\t\te = GetESDForTime(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1], sample->DTS, &esd);\n\t\t\t\t\tif (!e) e = gf_odf_desc_add_desc((GF_Descriptor *) od, (GF_Descriptor *) esd);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tgf_odf_desc_del((GF_Descriptor *)od);\n\t\t\t\t\t\tgf_odf_com_del((GF_ODCom **)&odU2);\n\t\t\t\t\t\tgf_odf_desc_del((GF_Descriptor *)isom_od);\n\t\t\t\t\t\tgf_odf_com_del((GF_ODCom **)&odU);\n\t\t\t\t\t\tgoto err_exit;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t//delete our desc\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *)isom_od);\n\t\t\t\tgf_list_add(odU2->objectDescriptors, od);\n\t\t\t}\n\t\t\t//clean a bit\n\t\t\tgf_odf_com_del((GF_ODCom **)&odU);\n\t\t\tgf_odf_codec_add_com(ODencode, (GF_ODCom *)odU2);\n\t\t\tbreak;\n\n\t\tcase GF_ODF_ESD_UPDATE_TAG:\n\t\t\tesdU = (GF_ESDUpdate *) com;\n\t\t\tesdU2 = (GF_ESDUpdate *) gf_odf_com_new(GF_ODF_ESD_UPDATE_TAG);\n\t\t\tesdU2->ODID = esdU->ODID;\n\t\t\ti=0;\n\t\t\twhile ((ref = (GF_ES_ID_Ref*)gf_list_enum(esdU->ESDescriptors, &i))) {\n\t\t\t\tif (!mpod->trackIDs || !ref->trackRef || (ref->trackRef>mpod->trackIDCount)) continue;\n\t\t\t\t//if the ref index is not valid, skip this desc...\n\t\t\t\tif (gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1]) == NULL) continue;\n\t\t\t\t//OK, get the esd\n\t\t\t\te = GetESDForTime(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1], sample->DTS, &esd);\n\t\t\t\tif (e) goto err_exit;\n\t\t\t\tgf_list_add(esdU2->ESDescriptors, esd);\n\t\t\t}\n\t\t\tgf_odf_com_del((GF_ODCom **)&esdU);\n\t\t\tgf_odf_codec_add_com(ODencode, (GF_ODCom *)esdU2);\n\t\t\tbreak;\n\n\t\t//brand new case: the ESRemove follows the same principle according to the spec...\n\t\tcase GF_ODF_ESD_REMOVE_REF_TAG:\n\t\t\t//both commands have the same structure, only the tags change\n\t\t\tesdR = (GF_ESDRemove *) com;\n\t\t\tesdR2 = (GF_ESDRemove *) gf_odf_com_new(GF_ODF_ESD_REMOVE_TAG);\n\t\t\tesdR2->ODID = esdR->ODID;\n\t\t\tesdR2->NbESDs = esdR->NbESDs;\n\t\t\t//alloc our stuff\n\t\t\tesdR2->ES_ID = (unsigned short*)gf_malloc(sizeof(u32) * esdR->NbESDs);\n\t\t\tif (!esdR2->ES_ID) {\n\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\t\t\tskipped = 0;\n\t\t\t//get the ES_ID in the mpod indicated in the ES_ID[]\n\t\t\tfor (i = 0; i < esdR->NbESDs; i++) {\n\t\t\t\tif (!mpod->trackIDs || !esdR->ES_ID[i] || (esdR->ES_ID[i]>mpod->trackIDCount)) continue;\n\t\t\t\t//if the ref index is not valid, remove this desc...\n\t\t\t\tif (gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[esdR->ES_ID[i] - 1]) == NULL) {\n\t\t\t\t\tskipped ++;\n\t\t\t\t} else {\n\t\t\t\t\t//the command in the file has the ref index of the trackID in the mpod\n\t\t\t\t\tesdR2->ES_ID[i - skipped] = mpod->trackIDs[esdR->ES_ID[i] - 1];\n\t\t\t\t}\n\t\t\t}\n\t\t\t//gf_realloc...\n\t\t\tif (skipped && (skipped != esdR2->NbESDs) ) {\n\t\t\t\tesdR2->NbESDs -= skipped;\n\t\t\t\tesdR2->ES_ID = (unsigned short*)gf_realloc(esdR2->ES_ID, sizeof(u32) * esdR2->NbESDs);\n\t\t\t}\n\t\t\tgf_odf_com_del((GF_ODCom **)&esdR);\n\t\t\tgf_odf_codec_add_com(ODencode, (GF_ODCom *)esdR2);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\te = gf_odf_codec_add_com(ODencode, com);\n\t\t\tif (e) goto err_exit;\n\t\t}\n\t}\n\t//encode our new AU\n\te = gf_odf_codec_encode(ODencode, 1);\n\tif (e) goto err_exit;\n\n\t//and set the buffer in the sample\n\tgf_free(sample->data);\n\tsample->data = NULL;\n\tsample->dataLength = 0;\n\te = gf_odf_codec_get_au(ODencode, &sample->data, &sample->dataLength);\n\nerr_exit:\n\tgf_odf_codec_del(ODdecode);\n\tgf_odf_codec_del(ODencode);\n\treturn e;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 1684,
    "critical_vars": [
      "crc"
    ],
    "function": "naludmx_queue_param_set",
    "filename": "gpac/CVE-2021-40563/CVE-2021-40563_CWE-476_5ce0c906ed8599d218036b18b78e8126a496f137_reframe_nalu.c.diff",
    "function_code": "static void naludmx_queue_param_set(GF_NALUDmxCtx *ctx, char *data, u32 size, u32 ps_type, s32 ps_id)\n{\n\tGF_List *list = NULL, *alt_list = NULL;\n\tGF_NALUFFParam *sl;\n\tu32 i, count;\n\tu32 crc = gf_crc_32(data, size);\n\n\tif (ctx->codecid==GF_CODECID_HEVC) {\n\t\tswitch (ps_type) {\n\t\tcase GF_HEVC_NALU_VID_PARAM:\n\t\t\tif (!ctx->vps) ctx->vps = gf_list_new();\n\t\t\tlist = ctx->vps;\n\t\t\tbreak;\n\t\tcase GF_HEVC_NALU_SEQ_PARAM:\n\t\t\tlist = ctx->sps;\n\t\t\tbreak;\n\t\tcase GF_HEVC_NALU_PIC_PARAM:\n\t\t\tlist = ctx->pps;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(0);\n\t\t\treturn;\n\t\t}\n\t} else if (ctx->codecid==GF_CODECID_VVC) {\n\t\tswitch (ps_type) {\n\t\tcase GF_VVC_NALU_VID_PARAM:\n\t\t\tif (!ctx->vps) ctx->vps = gf_list_new();\n\t\t\tlist = ctx->vps;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_SEQ_PARAM:\n\t\t\tlist = ctx->sps;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_PIC_PARAM:\n\t\t\tlist = ctx->pps;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_DEC_PARAM:\n\t\t\tif (!ctx->vvc_dci) ctx->vvc_dci = gf_list_new();\n\t\t\tlist = ctx->vvc_dci;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_APS_PREFIX:\n\t\t\tif (!ctx->vvc_aps_pre) ctx->vvc_aps_pre = gf_list_new();\n\t\t\tlist = ctx->vvc_aps_pre;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(0);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tswitch (ps_type) {\n\t\tcase GF_AVC_NALU_SVC_SUBSEQ_PARAM:\n\t\tcase GF_AVC_NALU_SEQ_PARAM:\n\t\t\tlist = ctx->sps;\n\t\t\tbreak;\n\t\tcase GF_AVC_NALU_PIC_PARAM:\n\t\t\tlist = ctx->pps;\n\t\t\talt_list = ctx->pps_svc;\n\t\t\tbreak;\n\t\tcase GF_AVC_NALU_SEQ_PARAM_EXT:\n\t\t\tif (!ctx->sps_ext) ctx->sps_ext = gf_list_new();\n\t\t\tlist = ctx->sps_ext;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(0);\n\t\t\treturn;\n\t\t}\n\t}\n\tsl = NULL;\n\tcount = gf_list_count(list);\n\tfor (i=0; i<count; i++) {\n\t\tsl = gf_list_get(list, i);\n\t\tif (sl->id != ps_id) {\n\t\t\tsl = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\t//same ID, same CRC, we don't change our state\n\t\tif (sl->crc == crc) return;\n\t\tbreak;\n\t}\n\t//handle alt PPS list for SVC\n\tif (!sl && alt_list) {\n\t\tcount = gf_list_count(alt_list);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tsl = gf_list_get(alt_list, i);\n\t\t\tif (sl->id != ps_id) {\n\t\t\t\tsl = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//same ID, same CRC, we don't change our state\n\t\t\tif (sl->crc == crc) return;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (sl) {\n\t\t//otherwise we keep this new param set\n\t\tsl->data = gf_realloc(sl->data, size);\n\t\tmemcpy(sl->data, data, size);\n\t\tsl->size = size;\n\t\tsl->crc = crc;\n\t\tctx->ps_modified = GF_TRUE;\n\t\treturn;\n\t}\n\t//TODO we might want to purge the list after a while !!\n\n\tGF_SAFEALLOC(sl, GF_NALUFFParam);\n\tif (!sl) return;\n\tsl->data = gf_malloc(sizeof(char) * size);\n\tif (!sl->data) {\n\t\tgf_free(sl);\n\t\treturn;\n\t}\n\tmemcpy(sl->data, data, size);\n\tsl->size = size;\n\tsl->id = ps_id;\n\tsl->crc = crc;\n\n\tctx->ps_modified = GF_TRUE;\n\tgf_list_add(list, sl);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Var-Declaration",
    "line_new": 1683,
    "critical_vars": [
      "crc"
    ],
    "function": "naludmx_queue_param_set",
    "filename": "gpac/CVE-2021-40563/CVE-2021-40563_CWE-476_5ce0c906ed8599d218036b18b78e8126a496f137_reframe_nalu.c.diff",
    "function_code": "static void naludmx_queue_param_set(GF_NALUDmxCtx *ctx, char *data, u32 size, u32 ps_type, s32 ps_id)\n{\n\tGF_List *list = NULL, *alt_list = NULL;\n\tGF_NALUFFParam *sl;\n\tu32 i, count, crc;\n\n\tif (!size) return;\n\tcrc = gf_crc_32(data, size);\n\n\tif (ctx->codecid==GF_CODECID_HEVC) {\n\t\tswitch (ps_type) {\n\t\tcase GF_HEVC_NALU_VID_PARAM:\n\t\t\tif (!ctx->vps) ctx->vps = gf_list_new();\n\t\t\tlist = ctx->vps;\n\t\t\tbreak;\n\t\tcase GF_HEVC_NALU_SEQ_PARAM:\n\t\t\tlist = ctx->sps;\n\t\t\tbreak;\n\t\tcase GF_HEVC_NALU_PIC_PARAM:\n\t\t\tlist = ctx->pps;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(0);\n\t\t\treturn;\n\t\t}\n\t} else if (ctx->codecid==GF_CODECID_VVC) {\n\t\tswitch (ps_type) {\n\t\tcase GF_VVC_NALU_VID_PARAM:\n\t\t\tif (!ctx->vps) ctx->vps = gf_list_new();\n\t\t\tlist = ctx->vps;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_SEQ_PARAM:\n\t\t\tlist = ctx->sps;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_PIC_PARAM:\n\t\t\tlist = ctx->pps;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_DEC_PARAM:\n\t\t\tif (!ctx->vvc_dci) ctx->vvc_dci = gf_list_new();\n\t\t\tlist = ctx->vvc_dci;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_APS_PREFIX:\n\t\t\tif (!ctx->vvc_aps_pre) ctx->vvc_aps_pre = gf_list_new();\n\t\t\tlist = ctx->vvc_aps_pre;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(0);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tswitch (ps_type) {\n\t\tcase GF_AVC_NALU_SVC_SUBSEQ_PARAM:\n\t\tcase GF_AVC_NALU_SEQ_PARAM:\n\t\t\tlist = ctx->sps;\n\t\t\tbreak;\n\t\tcase GF_AVC_NALU_PIC_PARAM:\n\t\t\tlist = ctx->pps;\n\t\t\talt_list = ctx->pps_svc;\n\t\t\tbreak;\n\t\tcase GF_AVC_NALU_SEQ_PARAM_EXT:\n\t\t\tif (!ctx->sps_ext) ctx->sps_ext = gf_list_new();\n\t\t\tlist = ctx->sps_ext;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(0);\n\t\t\treturn;\n\t\t}\n\t}\n\tsl = NULL;\n\tcount = gf_list_count(list);\n\tfor (i=0; i<count; i++) {\n\t\tsl = gf_list_get(list, i);\n\t\tif (sl->id != ps_id) {\n\t\t\tsl = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\t//same ID, same CRC, we don't change our state\n\t\tif (sl->crc == crc) return;\n\t\tbreak;\n\t}\n\t//handle alt PPS list for SVC\n\tif (!sl && alt_list) {\n\t\tcount = gf_list_count(alt_list);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tsl = gf_list_get(alt_list, i);\n\t\t\tif (sl->id != ps_id) {\n\t\t\t\tsl = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//same ID, same CRC, we don't change our state\n\t\t\tif (sl->crc == crc) return;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (sl) {\n\t\t//otherwise we keep this new param set\n\t\tsl->data = gf_realloc(sl->data, size);\n\t\tmemcpy(sl->data, data, size);\n\t\tsl->size = size;\n\t\tsl->crc = crc;\n\t\tctx->ps_modified = GF_TRUE;\n\t\treturn;\n\t}\n\t//TODO we might want to purge the list after a while !!\n\n\tGF_SAFEALLOC(sl, GF_NALUFFParam);\n\tif (!sl) return;\n\tsl->data = gf_malloc(sizeof(char) * size);\n\tif (!sl->data) {\n\t\tgf_free(sl);\n\t\treturn;\n\t}\n\tmemcpy(sl->data, data, size);\n\tsl->size = size;\n\tsl->id = ps_id;\n\tsl->crc = crc;\n\n\tctx->ps_modified = GF_TRUE;\n\tgf_list_add(list, sl);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 1968,
    "critical_vars": [
      "n",
      "AVI->fdes",
      "u32",
      "AVI->idx"
    ],
    "function": "avi_parse_input_file",
    "filename": "gpac/CVE-2023-4681/CVE-2023-4681_CWE-476_4bac19ad854159b21ba70d8ab7c4e1cd1db8ea1c_avilib.c.diff",
    "function_code": "int avi_parse_input_file(avi_t *AVI, int getIndex)\n{\n\tint rate, scale, idx_type;\n\ts64 n, i;\n\tunsigned char *hdrl_data;\n\tu64 header_offset=0;\n\tint hdrl_len=0;\n\tint nvi, nai[AVI_MAX_TRACKS], ioff;\n\tu64 tot[AVI_MAX_TRACKS];\n\tu32 j;\n\tint lasttag = 0;\n\tint vids_strh_seen = 0;\n\tint vids_strf_seen = 0;\n\tint auds_strh_seen = 0;\n\t//  int auds_strf_seen = 0;\n\tint num_stream = 0;\n\tchar data[256];\n\ts64 oldpos=-1, newpos=-1;\n\n\tint aud_chunks = 0;\n\tif (!AVI) {\n\t   AVI_errno = AVI_ERR_OPEN;\n\t   return 0;\n\t}\n\n\t/* Read first 12 bytes and check that this is an AVI file */\n\tif (avi_read(AVI->fdes,data,12) != 12 )\n\t\tERR_EXIT(AVI_ERR_READ)\n\n\tif (strnicmp(data  ,\"RIFF\",4) !=0 || strnicmp(data+8,\"AVI \",4) !=0 )\n\t\tERR_EXIT(AVI_ERR_NO_AVI)\n\n\t/* Go through the AVI file and extract the header list,\n\t   the start position of the 'movi' list and an optionally\n\t   present idx1 tag */\n\n\thdrl_data = 0;\n\n\twhile(1)\n\t{\n\t\tif( avi_read(AVI->fdes,data,8) != 8 ) break; /* We assume it's EOF */\n\t\tnewpos = gf_ftell(AVI->fdes);\n\t\tif(oldpos==newpos) {\n\t\t\t/* This is a broken AVI stream... */\n\t\t\treturn -1;\n\t\t}\n\t\toldpos=newpos;\n\n\t\tn = str2ulong((unsigned char *)data+4);\n\t\tn = PAD_EVEN(n);\n\n\t\tif(strnicmp(data,\"LIST\",4) == 0)\n\t\t{\n\t\t\tif( avi_read(AVI->fdes,data,4) != 4 ) ERR_EXIT(AVI_ERR_READ)\n\t\t\t\tn -= 4;\n\t\t\tif(strnicmp(data,\"hdrl\",4) == 0)\n\t\t\t{\n\t\t\t\tif (n>0xFFFFFFFF) ERR_EXIT(AVI_ERR_READ)\n\t\t\t\thdrl_len = (u32) n;\n\t\t\t\thdrl_data = (unsigned char *) gf_malloc((u32)n);\n\t\t\t\tif(hdrl_data==0) ERR_EXIT(AVI_ERR_NO_MEM);\n\n\t\t\t\t// offset of header\n\n\t\t\t\theader_offset = gf_ftell(AVI->fdes);\n\n\t\t\t\tif( avi_read(AVI->fdes,(char *)hdrl_data, (u32) n) != n ) ERR_EXIT(AVI_ERR_READ)\n\t\t\t\t}\n\t\t\telse if(strnicmp(data,\"movi\",4) == 0)\n\t\t\t{\n\t\t\t\tAVI->movi_start = gf_ftell(AVI->fdes);\n\t\t\t\tif (gf_fseek(AVI->fdes,n,SEEK_CUR)==(u64)-1) break;\n\t\t\t}\n\t\t\telse if (gf_fseek(AVI->fdes,n,SEEK_CUR)==(u64)-1) break;\n\t\t}\n\t\telse if(strnicmp(data,\"idx1\",4) == 0)\n\t\t{\n\t\t\t/* n must be a multiple of 16, but the reading does not\n\t\t\t   break if this is not the case */\n\n\t\t\tAVI->n_idx = AVI->max_idx = (u32) (n/16);\n\t\t\tAVI->idx = (unsigned  char((*)[16]) ) gf_malloc((u32)n);\n\t\t\tif(AVI->idx==0) ERR_EXIT(AVI_ERR_NO_MEM)\n\t\t\t\tif(avi_read(AVI->fdes, (char *) AVI->idx, (u32) n) != n ) {\n\t\t\t\t\tgf_free( AVI->idx);\n\t\t\t\t\tAVI->idx=NULL;\n\t\t\t\t\tAVI->n_idx = 0;\n\t\t\t\t}\n\t\t}\n\t\telse\n\t\t\tgf_fseek(AVI->fdes,n,SEEK_CUR);\n\t}\n\n\tif(!hdrl_data      ) ERR_EXIT(AVI_ERR_NO_HDRL)\n\t\tif(!AVI->movi_start) ERR_EXIT(AVI_ERR_NO_MOVI)\n\n\t\t\t/* Interpret the header list */\n\n\t\t\tfor(i=0; i<hdrl_len;)\n\t\t\t{\n\t\t\t\t/* List tags are completly ignored */\n\n#ifdef DEBUG_ODML\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] TAG %c%c%c%c\\n\", (hdrl_data+i)[0], (hdrl_data+i)[1], (hdrl_data+i)[2], (hdrl_data+i)[3]));\n#endif\n\n\t\t\t\tif(strnicmp((char *)hdrl_data+i,\"LIST\",4)==0) {\n\t\t\t\t\ti+= 12;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tn = str2ulong(hdrl_data+i+4);\n\t\t\t\tn = PAD_EVEN(n);\n\t\t\t\tif (i+n>hdrl_len) ERR_EXIT(AVI_ERR_READ)\n\n\n\t\t\t\t/* Interpret the tag and its args */\n\n\t\t\t\tif(strnicmp((char *)hdrl_data+i,\"strh\",4)==0)\n\t\t\t\t{\n\t\t\t\t\ti += 8;\n#ifdef DEBUG_ODML\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] TAG   %c%c%c%c\\n\", (hdrl_data+i)[0], (hdrl_data+i)[1], (hdrl_data+i)[2], (hdrl_data+i)[3]));\n#endif\n\t\t\t\t\tif(strnicmp((char *)hdrl_data+i,\"vids\",4) == 0 && !vids_strh_seen)\n\t\t\t\t\t{\n\t\t\t\t\t\tmemcpy(AVI->compressor,hdrl_data+i+4,4);\n\t\t\t\t\t\tAVI->compressor[4] = 0;\n\n\t\t\t\t\t\t// ThOe\n\t\t\t\t\t\tAVI->v_codech_off = header_offset + i+4;\n\n\t\t\t\t\t\tscale = str2ulong(hdrl_data+i+20);\n\t\t\t\t\t\trate  = str2ulong(hdrl_data+i+24);\n\t\t\t\t\t\tif(scale!=0) AVI->fps = (double)rate/(double)scale;\n\t\t\t\t\t\tAVI->video_frames = str2ulong(hdrl_data+i+32);\n\t\t\t\t\t\tAVI->video_strn = num_stream;\n\t\t\t\t\t\tAVI->max_len = 0;\n\t\t\t\t\t\tvids_strh_seen = 1;\n\t\t\t\t\t\tlasttag = 1; /* vids */\n\t\t\t\t\t\tmemcpy(&AVI->video_stream_header, hdrl_data + i,\n\t\t\t\t\t\t       sizeof(alAVISTREAMHEADER));\n\t\t\t\t\t}\n\t\t\t\t\telse if (strnicmp ((char *)hdrl_data+i,\"auds\",4) ==0 && ! auds_strh_seen)\n\t\t\t\t\t{\n\n\t\t\t\t\t\t//inc audio tracks\n\t\t\t\t\t\tAVI->aptr=AVI->anum;\n\t\t\t\t\t\t++AVI->anum;\n\n\t\t\t\t\t\tif(AVI->anum > AVI_MAX_TRACKS) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] error - only %d audio tracks supported\\n\", AVI_MAX_TRACKS));\n\t\t\t\t\t\t\treturn(-1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_bytes = str2ulong(hdrl_data+i+32)*avi_sampsize(AVI, 0);\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_strn = num_stream;\n\n\t\t\t\t\t\t// if samplesize==0 -> vbr\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_vbr = !str2ulong(hdrl_data+i+44);\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].padrate = str2ulong(hdrl_data+i+24);\n\t\t\t\t\t\tmemcpy(&AVI->stream_headers[AVI->aptr], hdrl_data + i,\n\t\t\t\t\t\t       sizeof(alAVISTREAMHEADER));\n\n\t\t\t\t\t\t//\t   auds_strh_seen = 1;\n\t\t\t\t\t\tlasttag = 2; /* auds */\n\n\t\t\t\t\t\t// ThOe\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_codech_off = header_offset + i;\n\n\t\t\t\t\t}\n\t\t\t\t\telse if (strnicmp ((char*)hdrl_data+i,\"iavs\",4) ==0 && ! auds_strh_seen) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] AVILIB: error - DV AVI Type 1 no supported\\n\"));\n\t\t\t\t\t\treturn (-1);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tlasttag = 0;\n\t\t\t\t\tnum_stream++;\n\t\t\t\t}\n\t\t\t\telse if(strnicmp((char*)hdrl_data+i,\"dmlh\",4) == 0) {\n\t\t\t\t\tAVI->total_frames = str2ulong(hdrl_data+i+8);\n#ifdef DEBUG_ODML\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] real number of frames %d\\n\", AVI->total_frames));\n#endif\n\t\t\t\t\ti += 8;\n\t\t\t\t}\n\t\t\t\telse if(strnicmp((char *)hdrl_data+i,\"strf\",4)==0)\n\t\t\t\t{\n\t\t\t\t\ti += 8;\n\t\t\t\t\tif(lasttag == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\talBITMAPINFOHEADER bih;\n\n\t\t\t\t\t\tmemcpy(&bih, hdrl_data + i, sizeof(alBITMAPINFOHEADER));\n\t\t\t\t\t\tbih.bi_size = str2ulong((unsigned char *)&bih.bi_size);\n\n\t\t\t\t\t\tif (i + bih.bi_size > hdrl_len) ERR_EXIT(AVI_ERR_READ)\n\n\t\t\t\t\t\tAVI->bitmap_info_header = (alBITMAPINFOHEADER *) gf_malloc(bih.bi_size);\n\t\t\t\t\t\tif (AVI->bitmap_info_header != NULL)\n\t\t\t\t\t\t\tmemcpy(AVI->bitmap_info_header, hdrl_data + i, bih.bi_size);\n\n\t\t\t\t\t\tAVI->width  = str2ulong(hdrl_data+i+4);\n\t\t\t\t\t\tAVI->height = str2ulong(hdrl_data+i+8);\n\t\t\t\t\t\tvids_strf_seen = 1;\n\t\t\t\t\t\t//ThOe\n\t\t\t\t\t\tAVI->v_codecf_off = header_offset + i+16;\n\n\t\t\t\t\t\tmemcpy(AVI->compressor2, hdrl_data+i+16, 4);\n\t\t\t\t\t\tAVI->compressor2[4] = 0;\n\n\t\t\t\t\t\tif (n>40) {\n\t\t\t\t\t\t\tif (n>0xFFFFFFFF) ERR_EXIT(AVI_ERR_READ)\n\t\t\t\t\t\t\tAVI->extradata_size = (u32) (n - 40);\n\t\t\t\t\t\t\tAVI->extradata = gf_malloc(sizeof(u8)* AVI->extradata_size);\n\t\t\t\t\t\t\tif (!AVI->extradata) ERR_EXIT(AVI_ERR_NO_MEM)\n\t\t\t\t\t\t\tmemcpy(AVI->extradata, hdrl_data + i + 40, AVI->extradata_size);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\telse if(lasttag == 2)\n\t\t\t\t\t{\n\t\t\t\t\t\talWAVEFORMATEX *wfe;\n\t\t\t\t\t\tchar *nwfe;\n\t\t\t\t\t\tint wfes;\n\n\t\t\t\t\t\tif ((u32) (hdrl_len - i) < sizeof(alWAVEFORMATEX))\n\t\t\t\t\t\t\twfes = (int) (hdrl_len - i);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\twfes = sizeof(alWAVEFORMATEX);\n\t\t\t\t\t\twfe = (alWAVEFORMATEX *)gf_malloc(sizeof(alWAVEFORMATEX));\n\t\t\t\t\t\tif (wfe != NULL) {\n\t\t\t\t\t\t\tmemset(wfe, 0, sizeof(alWAVEFORMATEX));\n\t\t\t\t\t\t\tmemcpy(wfe, hdrl_data + i, wfes);\n\t\t\t\t\t\t\tif (str2ushort((unsigned char *)&wfe->cb_size) != 0) {\n\t\t\t\t\t\t\t\tnwfe = (char *)\n\t\t\t\t\t\t\t\t       gf_realloc(wfe, sizeof(alWAVEFORMATEX) +\n\t\t\t\t\t\t\t\t                  str2ushort((unsigned char *)&wfe->cb_size));\n\t\t\t\t\t\t\t\tif (nwfe != 0) {\n\t\t\t\t\t\t\t\t\ts64 lpos = gf_ftell(AVI->fdes);\n\t\t\t\t\t\t\t\t\tgf_fseek(AVI->fdes, header_offset + i + sizeof(alWAVEFORMATEX),\n\t\t\t\t\t\t\t\t\t         SEEK_SET);\n\t\t\t\t\t\t\t\t\twfe = (alWAVEFORMATEX *)nwfe;\n\t\t\t\t\t\t\t\t\tnwfe = &nwfe[sizeof(alWAVEFORMATEX)];\n\t\t\t\t\t\t\t\t\tavi_read(AVI->fdes, nwfe,\n\t\t\t\t\t\t\t\t\t         str2ushort((unsigned char *)&wfe->cb_size));\n\t\t\t\t\t\t\t\t\tgf_fseek(AVI->fdes, lpos, SEEK_SET);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tAVI->wave_format_ex[AVI->aptr] = wfe;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_fmt   = str2ushort(hdrl_data+i  );\n\n\t\t\t\t\t\t//ThOe\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_codecf_off = header_offset + i;\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_chans = str2ushort(hdrl_data+i+2);\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_rate  = str2ulong (hdrl_data+i+4);\n\t\t\t\t\t\t//ThOe: read mp3bitrate\n\t\t\t\t\t\tAVI->track[AVI->aptr].mp3rate = 8*str2ulong(hdrl_data+i+8)/1000;\n\t\t\t\t\t\t//:ThOe\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_bits  = str2ushort(hdrl_data+i+14);\n\t\t\t\t\t\t//            auds_strf_seen = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(strnicmp((char*)hdrl_data+i,\"indx\",4) == 0) {\n\t\t\t\t\tchar *a;\n\n\t\t\t\t\tif(lasttag == 1) // V I D E O\n\t\t\t\t\t{\n\n\t\t\t\t\t\ta = (char*)hdrl_data+i;\n\t\t\t\t\t\tint avail = hdrl_len-i;\n\t\t\t\t\t\tif (avail<32) ERR_EXIT(AVI_ERR_READ)\n\n\t\t\t\t\t\tAVI->video_superindex = (avisuperindex_chunk *) gf_malloc (sizeof (avisuperindex_chunk));\n\t\t\t\t\t\tmemset(AVI->video_superindex, 0, sizeof (avisuperindex_chunk));\n\t\t\t\t\t\tmemcpy (AVI->video_superindex->fcc, a, 4);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->video_superindex->dwSize = str2ulong((unsigned char *)a);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->video_superindex->wLongsPerEntry = str2ushort((unsigned char *)a);\n\t\t\t\t\t\ta += 2;\n\t\t\t\t\t\tAVI->video_superindex->bIndexSubType = *a;\n\t\t\t\t\t\ta += 1;\n\t\t\t\t\t\tAVI->video_superindex->bIndexType = *a;\n\t\t\t\t\t\ta += 1;\n\t\t\t\t\t\tAVI->video_superindex->nEntriesInUse = str2ulong((unsigned char *)a);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tmemcpy (AVI->video_superindex->dwChunkId, a, 4);\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\t// 3 * reserved\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\tif (AVI->video_superindex->bIndexSubType != 0) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] Invalid Header, bIndexSubType != 0\\n\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tavail -= 32;\n\t\t\t\t\t\tif (avail < AVI->video_superindex->nEntriesInUse*16) ERR_EXIT(AVI_ERR_READ)\n\n\t\t\t\t\t\tAVI->video_superindex->aIndex = (avisuperindex_entry*)\n\t\t\t\t\t\t                                gf_malloc (AVI->video_superindex->wLongsPerEntry * AVI->video_superindex->nEntriesInUse * sizeof (u32));\n\n\t\t\t\t\t\t// position of ix## chunks\n\t\t\t\t\t\tfor (j=0; j<AVI->video_superindex->nEntriesInUse; ++j) {\n\t\t\t\t\t\t\tAVI->video_superindex->aIndex[j].qwOffset = str2ullong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 8;\n\t\t\t\t\t\t\tAVI->video_superindex->aIndex[j].dwSize = str2ulong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\t\tAVI->video_superindex->aIndex[j].dwDuration = str2ulong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 4;\n\n#ifdef DEBUG_ODML\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d] 0x%llx 0x%lx %lu\\n\", j,\n\t\t\t\t\t\t\t                                        (unsigned int long)AVI->video_superindex->aIndex[j].qwOffset,\n\t\t\t\t\t\t\t                                        (unsigned long)AVI->video_superindex->aIndex[j].dwSize,\n\t\t\t\t\t\t\t                                        (unsigned long)AVI->video_superindex->aIndex[j].dwDuration));\n#endif\n\t\t\t\t\t\t}\n\n\n#ifdef DEBUG_ODML\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] FOURCC \\\"%c%c%c%c\\\"\\n\", AVI->video_superindex->fcc[0], AVI->video_superindex->fcc[1],\n\t\t\t\t\t\t                                        AVI->video_superindex->fcc[2], AVI->video_superindex->fcc[3]));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] LEN \\\"%ld\\\"\\n\", (long)AVI->video_superindex->dwSize));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] wLongsPerEntry \\\"%d\\\"\\n\", AVI->video_superindex->wLongsPerEntry));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] bIndexSubType \\\"%d\\\"\\n\", AVI->video_superindex->bIndexSubType));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] bIndexType \\\"%d\\\"\\n\", AVI->video_superindex->bIndexType));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] nEntriesInUse \\\"%ld\\\"\\n\", (long)AVI->video_superindex->nEntriesInUse));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] dwChunkId \\\"%c%c%c%c\\\"\\n\", AVI->video_superindex->dwChunkId[0], AVI->video_superindex->dwChunkId[1],\n\t\t\t\t\t\t                                        AVI->video_superindex->dwChunkId[2], AVI->video_superindex->dwChunkId[3]));\n#endif\n\n\t\t\t\t\t\tAVI->is_opendml = 1;\n\n\t\t\t\t\t}\n\t\t\t\t\telse if(lasttag == 2) // A U D I O\n\t\t\t\t\t{\n\n\t\t\t\t\t\ta = (char*) hdrl_data+i;\n\t\t\t\t\t\tint avail = hdrl_len-i;\n\t\t\t\t\t\tif (avail<32) ERR_EXIT(AVI_ERR_READ)\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex = (avisuperindex_chunk *) gf_malloc (sizeof (avisuperindex_chunk));\n\t\t\t\t\t\tmemcpy (AVI->track[AVI->aptr].audio_superindex->fcc, a, 4);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->dwSize = str2ulong((unsigned char*)a);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->wLongsPerEntry = str2ushort((unsigned char*)a);\n\t\t\t\t\t\ta += 2;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->bIndexSubType = *a;\n\t\t\t\t\t\ta += 1;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->bIndexType = *a;\n\t\t\t\t\t\ta += 1;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->nEntriesInUse = str2ulong((unsigned char*)a);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tmemcpy (AVI->track[AVI->aptr].audio_superindex->dwChunkId, a, 4);\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\t// 3 * reserved\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\tif (AVI->track[AVI->aptr].audio_superindex->bIndexSubType != 0) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] Invalid Header, bIndexSubType != 0\\n\"));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tavail -= 32;\n\t\t\t\t\t\tif (avail < AVI->track[AVI->aptr].audio_superindex->nEntriesInUse*16) ERR_EXIT(AVI_ERR_READ)\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->aIndex = (avisuperindex_entry*)\n\t\t\t\t\t\t        gf_malloc (AVI->track[AVI->aptr].audio_superindex->wLongsPerEntry *\n\t\t\t\t\t\t                   AVI->track[AVI->aptr].audio_superindex->nEntriesInUse * sizeof (u32));\n\n\t\t\t\t\t\t// position of ix## chunks\n\t\t\t\t\t\tfor (j=0; j<AVI->track[AVI->aptr].audio_superindex->nEntriesInUse; ++j) {\n\t\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->aIndex[j].qwOffset = str2ullong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 8;\n\t\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->aIndex[j].dwSize = str2ulong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->aIndex[j].dwDuration = str2ulong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 4;\n\n#ifdef DEBUG_ODML\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d] 0x%llx 0x%lx %lu\\n\", j,\n\t\t\t\t\t\t\t                                        (unsigned int long)AVI->track[AVI->aptr].audio_superindex->aIndex[j].qwOffset,\n\t\t\t\t\t\t\t                                        (unsigned long)AVI->track[AVI->aptr].audio_superindex->aIndex[j].dwSize,\n\t\t\t\t\t\t\t                                        (unsigned long)AVI->track[AVI->aptr].audio_superindex->aIndex[j].dwDuration));\n#endif\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->stdindex = NULL;\n\n#ifdef DEBUG_ODML\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] FOURCC \\\"%.4s\\\"\\n\", AVI->track[AVI->aptr].audio_superindex->fcc));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] LEN \\\"%ld\\\"\\n\", (long)AVI->track[AVI->aptr].audio_superindex->dwSize));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] wLongsPerEntry \\\"%d\\\"\\n\", AVI->track[AVI->aptr].audio_superindex->wLongsPerEntry));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] bIndexSubType \\\"%d\\\"\\n\", AVI->track[AVI->aptr].audio_superindex->bIndexSubType));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] bIndexType \\\"%d\\\"\\n\", AVI->track[AVI->aptr].audio_superindex->bIndexType));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] nEntriesInUse \\\"%ld\\\"\\n\", (long)AVI->track[AVI->aptr].audio_superindex->nEntriesInUse));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] dwChunkId \\\"%.4s\\\"\\n\", AVI->track[AVI->aptr].audio_superindex->dwChunkId[0]));\n#endif\n\n\t\t\t\t\t}\n\t\t\t\t\ti += 8;\n\t\t\t\t}\n\t\t\t\telse if((strnicmp((char*)hdrl_data+i,\"JUNK\",4) == 0) ||\n\t\t\t\t        (strnicmp((char*)hdrl_data+i,\"strn\",4) == 0) ||\n\t\t\t\t        (strnicmp((char*)hdrl_data+i,\"vprp\",4) == 0)) {\n\t\t\t\t\ti += 8;\n\t\t\t\t\t// do not reset lasttag\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\ti += 8;\n\t\t\t\t\tlasttag = 0;\n\t\t\t\t}\n\t\t\t\t//GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] adding %ld bytes\\n\", (int int)n));\n\n\t\t\t\ti += (u32) n;\n\t\t\t}\n\n\tgf_free(hdrl_data);\n\n\tif(!vids_strh_seen || !vids_strf_seen) ERR_EXIT(AVI_ERR_NO_VIDS)\n\n\t\tAVI->video_tag[0] = AVI->video_strn/10 + '0';\n\tAVI->video_tag[1] = AVI->video_strn%10 + '0';\n\tAVI->video_tag[2] = 'd';\n\tAVI->video_tag[3] = 'b';\n\n\t/* Audio tag is set to \"99wb\" if no audio present */\n\tif(!AVI->track[0].a_chans) AVI->track[0].audio_strn = 99;\n\n\t{\n\t\tint tk=0;\n\t\tfor(j=0; j<AVI->anum+1; ++j) {\n\t\t\tif (j == AVI->video_strn) continue;\n\t\t\tAVI->track[tk].audio_tag[0] = j/10 + '0';\n\t\t\tAVI->track[tk].audio_tag[1] = j%10 + '0';\n\t\t\tAVI->track[tk].audio_tag[2] = 'w';\n\t\t\tAVI->track[tk].audio_tag[3] = 'b';\n\t\t\t++tk;\n\t\t}\n\t}\n\n\tgf_fseek(AVI->fdes,AVI->movi_start,SEEK_SET);\n\n\tif(!getIndex) return(0);\n\n\t/* if the file has an idx1, check if this is relative\n\t   to the start of the file or to the start of the movi list */\n\n\tidx_type = 0;\n\n\tif(AVI->idx)\n\t{\n\t\ts64 pos, len;\n\n\t\t/* Search the first videoframe in the idx1 and look where\n\t\t   it is in the file */\n\n\t\tfor(i=0; i<AVI->n_idx; i++)\n\t\t\tif( strnicmp((char *)AVI->idx[i],(char *)AVI->video_tag,3)==0 ) break;\n\t\tif(i>=AVI->n_idx) ERR_EXIT(AVI_ERR_NO_VIDS)\n\n\t\t\tpos = str2ulong(AVI->idx[i]+ 8);\n\t\tlen = str2ulong(AVI->idx[i]+12);\n\n\t\tgf_fseek(AVI->fdes,pos,SEEK_SET);\n\t\tif(avi_read(AVI->fdes,data,8)!=8) ERR_EXIT(AVI_ERR_READ)\n\t\t\tif( strnicmp(data,(char *)AVI->idx[i],4)==0 && str2ulong((unsigned char *)data+4)==len )\n\t\t\t{\n\t\t\t\tidx_type = 1; /* Index from start of file */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tgf_fseek(AVI->fdes,pos+AVI->movi_start-4,SEEK_SET);\n\t\t\t\tif(avi_read(AVI->fdes,data,8)!=8) ERR_EXIT(AVI_ERR_READ)\n\t\t\t\t\tif( strnicmp(data,(char *)AVI->idx[i],4)==0 && str2ulong((unsigned char *)data+4)==len )\n\t\t\t\t\t{\n\t\t\t\t\t\tidx_type = 2; /* Index from start of movi list */\n\t\t\t\t\t}\n\t\t\t}\n\t\t/* idx_type remains 0 if neither of the two tests above succeeds */\n\t}\n\n\n\tif(idx_type == 0 && !AVI->is_opendml && !AVI->total_frames)\n\t{\n\t\t/* we must search through the file to get the index */\n\n\t\tgf_fseek(AVI->fdes, AVI->movi_start, SEEK_SET);\n\n\t\tAVI->n_idx = 0;\n\n\t\twhile(1)\n\t\t{\n\t\t\tif( avi_read(AVI->fdes,data,8) != 8 ) break;\n\t\t\tn = str2ulong((unsigned char *)data+4);\n\n\t\t\t/* The movi list may contain sub-lists, ignore them */\n\n\t\t\tif(strnicmp(data,\"LIST\",4)==0)\n\t\t\t{\n\t\t\t\tgf_fseek(AVI->fdes,4,SEEK_CUR);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Check if we got a tag ##db, ##dc or ##wb */\n\n\t\t\tif( ( (data[2]=='d' || data[2]=='D') &&\n\t\t\t        (data[3]=='b' || data[3]=='B' || data[3]=='c' || data[3]=='C') )\n\t\t\t        || ( (data[2]=='w' || data[2]=='W') &&\n\t\t\t             (data[3]=='b' || data[3]=='B') ) )\n\t\t\t{\n\t\t\t\tu64 __pos = gf_ftell(AVI->fdes) - 8;\n\t\t\t\tavi_add_index_entry(AVI,(unsigned char *)data,0,__pos,n);\n\t\t\t}\n\n\t\t\tgf_fseek(AVI->fdes,PAD_EVEN(n),SEEK_CUR);\n\t\t}\n\t\tidx_type = 1;\n\t}\n\n\t// ************************\n\t// OPENDML\n\t// ************************\n\n\t// read extended index chunks\n\tif (AVI->is_opendml) {\n\t\tu64 offset = 0;\n\t\thdrl_len = 4+4+2+1+1+4+4+8+4;\n\t\tchar *en, *chunk_start;\n\t\tint k = 0;\n\t\tu32 audtr = 0;\n\t\tu32 nrEntries = 0;\n\n\t\tAVI->video_index = NULL;\n\n\t\tnvi = 0;\n\t\tfor(audtr=0; audtr<AVI->anum; ++audtr) {\n\t\t\tnai[audtr] = 0;\n\t\t\ttot[audtr] = 0;\n\t\t}\n\n\t\t// ************************\n\t\t// VIDEO\n\t\t// ************************\n\n\t\tfor (j=0; j<AVI->video_superindex->nEntriesInUse; j++) {\n\n\t\t\t// read from file\n\t\t\tchunk_start = en = (char*) gf_malloc ((u32) (AVI->video_superindex->aIndex[j].dwSize+hdrl_len) );\n\n\t\t\tif (gf_fseek(AVI->fdes, AVI->video_superindex->aIndex[j].qwOffset, SEEK_SET) == (u64)-1) {\n\t\t\t\tgf_free(chunk_start);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (avi_read(AVI->fdes, en, (u32) (AVI->video_superindex->aIndex[j].dwSize+hdrl_len) ) <= 0) {\n\t\t\t\tgf_free(chunk_start);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnrEntries = str2ulong((unsigned char*)en + 12);\n#ifdef DEBUG_ODML\n\t\t\t//GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d:0] Video nrEntries %ld\\n\", j, nrEntries));\n#endif\n\t\t\toffset = str2ullong((unsigned char*)en + 20);\n\n\t\t\t// skip header\n\t\t\ten += hdrl_len;\n\t\t\tnvi += nrEntries;\n\t\t\tAVI->video_index = (video_index_entry *) gf_realloc (AVI->video_index, nvi * sizeof (video_index_entry));\n\t\t\tif (!AVI->video_index) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] out of mem (size = %ld)\\n\", nvi * sizeof (video_index_entry)));\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\twhile (k < nvi) {\n\n\t\t\t\tAVI->video_index[k].pos = offset + str2ulong((unsigned char*)en);\n\t\t\t\ten += 4;\n\t\t\t\tAVI->video_index[k].len = str2ulong_len((unsigned char*)en);\n\t\t\t\tAVI->video_index[k].key = str2ulong_key((unsigned char*)en);\n\t\t\t\ten += 4;\n\n\t\t\t\t// completely empty chunk\n\t\t\t\tif (AVI->video_index[k].pos-offset == 0 && AVI->video_index[k].len == 0) {\n\t\t\t\t\tk--;\n\t\t\t\t\tnvi--;\n\t\t\t\t}\n\n#ifdef DEBUG_ODML\n\t\t\t\t/*\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d] POS 0x%llX len=%d key=%s offset (%llx) (%ld)\\n\", k,\n\t\t\t\t  AVI->video_index[k].pos,\n\t\t\t\t  (int)AVI->video_index[k].len,\n\t\t\t\t  AVI->video_index[k].key?\"yes\":\"no \", offset,\n\t\t\t\t  AVI->video_superindex->aIndex[j].dwSize));\n\t\t\t\t  */\n#endif\n\n\t\t\t\tk++;\n\t\t\t}\n\n\t\t\tgf_free(chunk_start);\n\t\t}\n\n\t\tAVI->video_frames = nvi;\n\t\t// this should deal with broken 'rec ' odml files.\n\t\tif (AVI->video_frames == 0) {\n\t\t\tAVI->is_opendml=0;\n\t\t\tgoto multiple_riff;\n\t\t}\n\n\t\t// ************************\n\t\t// AUDIO\n\t\t// ************************\n\n\t\tfor(audtr=0; audtr<AVI->anum; ++audtr) {\n\n\t\t\tk = 0;\n\t\t\tif (!AVI->track[audtr].audio_superindex) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] (%s) cannot read audio index for track %d\\n\", __FILE__, audtr));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (j=0; j<AVI->track[audtr].audio_superindex->nEntriesInUse; j++) {\n\n\t\t\t\t// read from file\n\t\t\t\tchunk_start = en = (char*)gf_malloc ((u32) (AVI->track[audtr].audio_superindex->aIndex[j].dwSize+hdrl_len));\n\n\t\t\t\tif (gf_fseek(AVI->fdes, AVI->track[audtr].audio_superindex->aIndex[j].qwOffset, SEEK_SET) == (u64)-1) {\n\t\t\t\t\tgf_free(chunk_start);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (avi_read(AVI->fdes, en, (u32) (AVI->track[audtr].audio_superindex->aIndex[j].dwSize+hdrl_len)) <= 0) {\n\t\t\t\t\tgf_free(chunk_start);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tnrEntries = str2ulong((unsigned char*)en + 12);\n\t\t\t\t//if (nrEntries > 50) nrEntries = 2; // XXX\n#ifdef DEBUG_ODML\n\t\t\t\t//GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d:%d] Audio nrEntries %ld\\n\", j, audtr, nrEntries));\n#endif\n\t\t\t\toffset = str2ullong((unsigned char*)en + 20);\n\n\t\t\t\t// skip header\n\t\t\t\ten += hdrl_len;\n\t\t\t\tnai[audtr] += nrEntries;\n\t\t\t\tAVI->track[audtr].audio_index = (audio_index_entry *) gf_realloc (AVI->track[audtr].audio_index, nai[audtr] * sizeof (audio_index_entry));\n\n\t\t\t\twhile (k < nai[audtr]) {\n\n\t\t\t\t\tAVI->track[audtr].audio_index[k].pos = offset + str2ulong((unsigned char*)en);\n\t\t\t\t\ten += 4;\n\t\t\t\t\tAVI->track[audtr].audio_index[k].len = str2ulong_len((unsigned char*)en);\n\t\t\t\t\ten += 4;\n\t\t\t\t\tAVI->track[audtr].audio_index[k].tot = tot[audtr];\n\t\t\t\t\ttot[audtr] += AVI->track[audtr].audio_index[k].len;\n\n#ifdef DEBUG_ODML\n\t\t\t\t\t/*\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d:%d] POS 0x%llX len=%d offset (%llx) (%ld)\\n\", k, audtr,\n\t\t\t\t\t  AVI->track[audtr].audio_index[k].pos,\n\t\t\t\t\t  (int)AVI->track[audtr].audio_index[k].len,\n\t\t\t\t\t  offset, AVI->track[audtr].audio_superindex->aIndex[j].dwSize));\n\t\t\t\t\t  */\n#endif\n\n\t\t\t\t\t++k;\n\t\t\t\t}\n\n\t\t\t\tgf_free(chunk_start);\n\t\t\t}\n\n\t\t\tAVI->track[audtr].audio_chunks = nai[audtr];\n\t\t\tAVI->track[audtr].audio_bytes = tot[audtr];\n\t\t}\n\t} // is opendml\n\n\telse if (AVI->total_frames && !AVI->is_opendml && idx_type==0) {\n\n\t\t// *********************\n\t\t// MULTIPLE RIFF CHUNKS (and no index)\n\t\t// *********************\n\nmultiple_riff:\n\n\t\tgf_fseek(AVI->fdes, AVI->movi_start, SEEK_SET);\n\n\t\tAVI->n_idx = 0;\n\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] Reconstructing index...\"));\n\n\t\t// Number of frames; only one audio track supported\n\t\tnvi = AVI->video_frames = AVI->total_frames;\n\t\tnai[0] = AVI->track[0].audio_chunks = AVI->total_frames;\n\t\tfor(j=1; j<AVI->anum; ++j) AVI->track[j].audio_chunks = 0;\n\n\t\tAVI->video_index = (video_index_entry *) gf_malloc(nvi*sizeof(video_index_entry));\n\n\t\tif(AVI->video_index==0) ERR_EXIT(AVI_ERR_NO_MEM);\n\n\t\tfor(j=0; j<AVI->anum; ++j) {\n\t\t\tif(AVI->track[j].audio_chunks) {\n\t\t\t\tAVI->track[j].audio_index = (audio_index_entry *) gf_malloc((nai[j]+1)*sizeof(audio_index_entry));\n\t\t\t\tmemset(AVI->track[j].audio_index, 0, (nai[j]+1)*(sizeof(audio_index_entry)));\n\t\t\t\tif(AVI->track[j].audio_index==0) ERR_EXIT(AVI_ERR_NO_MEM);\n\t\t\t}\n\t\t}\n\n\t\tnvi = 0;\n\t\tfor(j=0; j<AVI->anum; ++j) {\n\t\t\tnai[j] = 0;\n\t\t\ttot[j] = 0;\n\t\t}\n\n\t\taud_chunks = AVI->total_frames;\n\n\t\twhile(1)\n\t\t{\n\t\t\tif (nvi >= AVI->total_frames) break;\n\n\t\t\tif( avi_read(AVI->fdes,data,8) != 8 ) break;\n\t\t\tn = str2ulong((unsigned char *)data+4);\n\n\n\t\t\tj=0;\n\n\t\t\tif (aud_chunks - nai[j] -1 <= 0) {\n\t\t\t\taud_chunks += AVI->total_frames;\n\t\t\t\tAVI->track[j].audio_index = (audio_index_entry *)\n\t\t\t\t                            gf_realloc( AVI->track[j].audio_index, (aud_chunks+1)*sizeof(audio_index_entry));\n\t\t\t\tif (!AVI->track[j].audio_index) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] Internal error in avilib -- no mem\\n\"));\n\t\t\t\t\tAVI_errno = AVI_ERR_NO_MEM;\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Check if we got a tag ##db, ##dc or ##wb */\n\n\t\t\t// VIDEO\n\t\t\tif(\n\t\t\t    (data[0]=='0' || data[1]=='0') &&\n\t\t\t    (data[2]=='d' || data[2]=='D') &&\n\t\t\t    (data[3]=='b' || data[3]=='B' || data[3]=='c' || data[3]=='C') ) {\n\n\t\t\t\tAVI->video_index[nvi].key = 0x0;\n\t\t\t\tAVI->video_index[nvi].pos = gf_ftell(AVI->fdes);\n\t\t\t\tAVI->video_index[nvi].len = (u32) n;\n\n\t\t\t\t/*\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] Frame %ld pos %\"LLD\" len %\"LLD\" key %ld\\n\",\n\t\t\t\t    nvi, AVI->video_index[nvi].pos,  AVI->video_index[nvi].len, (long)AVI->video_index[nvi].key));\n\t\t\t\t    */\n\t\t\t\tnvi++;\n\t\t\t\tgf_fseek(AVI->fdes,PAD_EVEN(n),SEEK_CUR);\n\t\t\t}\n\n\t\t\t//AUDIO\n\t\t\telse if(\n\t\t\t    (data[0]=='0' || data[1]=='1') &&\n\t\t\t    (data[2]=='w' || data[2]=='W') &&\n\t\t\t    (data[3]=='b' || data[3]=='B') ) {\n\n\n\t\t\t\tAVI->track[j].audio_index[nai[j]].pos = gf_ftell(AVI->fdes);\n\t\t\t\tAVI->track[j].audio_index[nai[j]].len = (u32) n;\n\t\t\t\tAVI->track[j].audio_index[nai[j]].tot = tot[j];\n\t\t\t\ttot[j] += AVI->track[j].audio_index[nai[j]].len;\n\t\t\t\tnai[j]++;\n\n\t\t\t\tgf_fseek(AVI->fdes,PAD_EVEN(n),SEEK_CUR);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgf_fseek(AVI->fdes,-4,SEEK_CUR);\n\t\t\t}\n\n\t\t}\n\t\tif (nvi < AVI->total_frames) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[avilib] Uh? Some frames seems missing (%ld/%d)\\n\",\n\t\t\t        nvi,  AVI->total_frames));\n\t\t}\n\n\n\t\tAVI->video_frames = nvi;\n\t\tAVI->track[0].audio_chunks = nai[0];\n\n\t\tfor(j=0; j<AVI->anum; ++j) AVI->track[j].audio_bytes = tot[j];\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] done. nvi=%ld nai=%ld tot=%ld\\n\", nvi, nai[0], tot[0]));\n\n\t} // total_frames but no indx chunk (xawtv does this)\n\n\telse\n\n\t{\n\t\t// ******************\n\t\t// NO OPENDML\n\t\t// ******************\n\n\t\t/* Now generate the video index and audio index arrays */\n\n\t\tnvi = 0;\n\t\tfor(j=0; j<AVI->anum; ++j) nai[j] = 0;\n\n\t\tfor(i=0; i<AVI->n_idx; i++) {\n\n\t\t\tif(strnicmp((char *)AVI->idx[i],AVI->video_tag,3) == 0) nvi++;\n\n\t\t\tfor(j=0; j<AVI->anum; ++j) if(strnicmp((char *)AVI->idx[i], AVI->track[j].audio_tag,4) == 0) nai[j]++;\n\t\t}\n\n\t\tAVI->video_frames = nvi;\n\t\tfor(j=0; j<AVI->anum; ++j) AVI->track[j].audio_chunks = nai[j];\n\n\n\t\tif(AVI->video_frames==0) ERR_EXIT(AVI_ERR_NO_VIDS);\n\t\tAVI->video_index = (video_index_entry *) gf_malloc(nvi*sizeof(video_index_entry));\n\t\tif(AVI->video_index==0) ERR_EXIT(AVI_ERR_NO_MEM);\n\n\t\tfor(j=0; j<AVI->anum; ++j) {\n\t\t\tif(AVI->track[j].audio_chunks) {\n\t\t\t\tAVI->track[j].audio_index = (audio_index_entry *) gf_malloc((nai[j]+1)*sizeof(audio_index_entry));\n\t\t\t\tmemset(AVI->track[j].audio_index, 0, (nai[j]+1)*(sizeof(audio_index_entry)));\n\t\t\t\tif(AVI->track[j].audio_index==0) ERR_EXIT(AVI_ERR_NO_MEM);\n\t\t\t}\n\t\t}\n\n\t\tnvi = 0;\n\t\tfor(j=0; j<AVI->anum; ++j) {\n\t\t\tnai[j] = 0;\n\t\t\ttot[j] = 0;\n\t\t}\n\n\t\tioff = idx_type == 1 ? 8 : (u32)AVI->movi_start+4;\n\n\t\tfor(i=0; i<AVI->n_idx; i++) {\n\n\t\t\t//video\n\t\t\tif(strnicmp((char *)AVI->idx[i],AVI->video_tag,3) == 0) {\n\t\t\t\tAVI->video_index[nvi].key = str2ulong(AVI->idx[i]+ 4);\n\t\t\t\tAVI->video_index[nvi].pos = str2ulong(AVI->idx[i]+ 8)+ioff;\n\t\t\t\tAVI->video_index[nvi].len = str2ulong(AVI->idx[i]+12);\n\t\t\t\tnvi++;\n\t\t\t}\n\n\t\t\t//audio\n\t\t\tfor(j=0; j<AVI->anum; ++j) {\n\n\t\t\t\tif(strnicmp((char *)AVI->idx[i],AVI->track[j].audio_tag,4) == 0) {\n\t\t\t\t\tAVI->track[j].audio_index[nai[j]].pos = str2ulong(AVI->idx[i]+ 8)+ioff;\n\t\t\t\t\tAVI->track[j].audio_index[nai[j]].len = str2ulong(AVI->idx[i]+12);\n\t\t\t\t\tAVI->track[j].audio_index[nai[j]].tot = tot[j];\n\t\t\t\t\ttot[j] += AVI->track[j].audio_index[nai[j]].len;\n\t\t\t\t\tnai[j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tfor(j=0; j<AVI->anum; ++j) AVI->track[j].audio_bytes = tot[j];\n\n\t} // is no opendml\n\n\t/* Reposition the file */\n\n\tgf_fseek(AVI->fdes,AVI->movi_start,SEEK_SET);\n\tAVI->video_pos = 0;\n\n\treturn(0);\n}",
    "label": "True"
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 1951,
    "line_new": 1951,
    "critical_vars": [
      "n",
      "AVI->fdes",
      "u32"
    ],
    "function": "avi_parse_input_file",
    "filename": "gpac/CVE-2023-4681/CVE-2023-4681_CWE-476_4bac19ad854159b21ba70d8ab7c4e1cd1db8ea1c_avilib.c.diff",
    "function_code": "int avi_parse_input_file(avi_t *AVI, int getIndex)\n{\n\tint rate, scale, idx_type;\n\ts64 n, i;\n\tunsigned char *hdrl_data;\n\tu64 header_offset=0;\n\tint hdrl_len=0;\n\tint nvi, nai[AVI_MAX_TRACKS], ioff;\n\tu64 tot[AVI_MAX_TRACKS];\n\tu32 j;\n\tint lasttag = 0;\n\tint vids_strh_seen = 0;\n\tint vids_strf_seen = 0;\n\tint auds_strh_seen = 0;\n\t//  int auds_strf_seen = 0;\n\tint num_stream = 0;\n\tchar data[256];\n\ts64 oldpos=-1, newpos=-1;\n\n\tint aud_chunks = 0;\n\tif (!AVI) {\n\t   AVI_errno = AVI_ERR_OPEN;\n\t   return 0;\n\t}\n\n\t/* Read first 12 bytes and check that this is an AVI file */\n\tif (avi_read(AVI->fdes,data,12) != 12 )\n\t\tERR_EXIT(AVI_ERR_READ)\n\n\tif (strnicmp(data  ,\"RIFF\",4) !=0 || strnicmp(data+8,\"AVI \",4) !=0 )\n\t\tERR_EXIT(AVI_ERR_NO_AVI)\n\n\t/* Go through the AVI file and extract the header list,\n\t   the start position of the 'movi' list and an optionally\n\t   present idx1 tag */\n\n\thdrl_data = 0;\n\n\twhile(1)\n\t{\n\t\tif( avi_read(AVI->fdes,data,8) != 8 ) break; /* We assume it's EOF */\n\t\tnewpos = gf_ftell(AVI->fdes);\n\t\tif(oldpos==newpos) {\n\t\t\t/* This is a broken AVI stream... */\n\t\t\treturn -1;\n\t\t}\n\t\toldpos=newpos;\n\n\t\tn = str2ulong((unsigned char *)data+4);\n\t\tn = PAD_EVEN(n);\n\n\t\tif(strnicmp(data,\"LIST\",4) == 0)\n\t\t{\n\t\t\tif( avi_read(AVI->fdes,data,4) != 4 ) ERR_EXIT(AVI_ERR_READ)\n\t\t\t\tn -= 4;\n\t\t\tif(strnicmp(data,\"hdrl\",4) == 0)\n\t\t\t{\n\t\t\t\tif (n>0xFFFFFFFF) ERR_EXIT(AVI_ERR_READ)\n\t\t\t\thdrl_len = (u32) n;\n\t\t\t\thdrl_data = (unsigned char *) gf_malloc((u32)n);\n\t\t\t\tif(hdrl_data==0) ERR_EXIT(AVI_ERR_NO_MEM);\n\n\t\t\t\t// offset of header\n\n\t\t\t\theader_offset = gf_ftell(AVI->fdes);\n\n\t\t\t\tif( avi_read(AVI->fdes,(char *)hdrl_data, (u32) n) != n ) {\n\t\t\t\t\tif (hdrl_data) gf_free(hdrl_data);\n\t\t\t\t\tERR_EXIT(AVI_ERR_READ)\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(strnicmp(data,\"movi\",4) == 0)\n\t\t\t{\n\t\t\t\tAVI->movi_start = gf_ftell(AVI->fdes);\n\t\t\t\tif (gf_fseek(AVI->fdes,n,SEEK_CUR)==(u64)-1) break;\n\t\t\t}\n\t\t\telse if (gf_fseek(AVI->fdes,n,SEEK_CUR)==(u64)-1) break;\n\t\t}\n\t\telse if(strnicmp(data,\"idx1\",4) == 0)\n\t\t{\n\t\t\t/* n must be a multiple of 16, but the reading does not\n\t\t\t   break if this is not the case */\n\n\t\t\tAVI->n_idx = AVI->max_idx = (u32) (n/16);\n\t\t\tAVI->idx = (unsigned  char((*)[16]) ) gf_malloc((u32)n);\n\t\t\tif(AVI->idx==0) {\n\t\t\t\tif (hdrl_data) gf_free(hdrl_data);\n\t\t\t\tERR_EXIT(AVI_ERR_NO_MEM)\n\t\t\t}\n\t\t\tif(avi_read(AVI->fdes, (char *) AVI->idx, (u32) n) != n ) {\n\t\t\t\tgf_free( AVI->idx);\n\t\t\t\tAVI->idx=NULL;\n\t\t\t\tAVI->n_idx = 0;\n\t\t\t\tif (hdrl_data) gf_free(hdrl_data);\n\t\t\t\tERR_EXIT(AVI_ERR_READ)\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tgf_fseek(AVI->fdes,n,SEEK_CUR);\n\t}\n\n\tif(!hdrl_data) ERR_EXIT(AVI_ERR_NO_HDRL)\n\tif(!AVI->movi_start) ERR_EXIT(AVI_ERR_NO_MOVI)\n\n\t\t\t/* Interpret the header list */\n\n\t\t\tfor(i=0; i<hdrl_len;)\n\t\t\t{\n\t\t\t\t/* List tags are completly ignored */\n\n#ifdef DEBUG_ODML\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] TAG %c%c%c%c\\n\", (hdrl_data+i)[0], (hdrl_data+i)[1], (hdrl_data+i)[2], (hdrl_data+i)[3]));\n#endif\n\n\t\t\t\tif(strnicmp((char *)hdrl_data+i,\"LIST\",4)==0) {\n\t\t\t\t\ti+= 12;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tn = str2ulong(hdrl_data+i+4);\n\t\t\t\tn = PAD_EVEN(n);\n\t\t\t\tif (i+n>hdrl_len) ERR_EXIT(AVI_ERR_READ)\n\n\n\t\t\t\t/* Interpret the tag and its args */\n\n\t\t\t\tif(strnicmp((char *)hdrl_data+i,\"strh\",4)==0)\n\t\t\t\t{\n\t\t\t\t\ti += 8;\n#ifdef DEBUG_ODML\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] TAG   %c%c%c%c\\n\", (hdrl_data+i)[0], (hdrl_data+i)[1], (hdrl_data+i)[2], (hdrl_data+i)[3]));\n#endif\n\t\t\t\t\tif(strnicmp((char *)hdrl_data+i,\"vids\",4) == 0 && !vids_strh_seen)\n\t\t\t\t\t{\n\t\t\t\t\t\tmemcpy(AVI->compressor,hdrl_data+i+4,4);\n\t\t\t\t\t\tAVI->compressor[4] = 0;\n\n\t\t\t\t\t\t// ThOe\n\t\t\t\t\t\tAVI->v_codech_off = header_offset + i+4;\n\n\t\t\t\t\t\tscale = str2ulong(hdrl_data+i+20);\n\t\t\t\t\t\trate  = str2ulong(hdrl_data+i+24);\n\t\t\t\t\t\tif(scale!=0) AVI->fps = (double)rate/(double)scale;\n\t\t\t\t\t\tAVI->video_frames = str2ulong(hdrl_data+i+32);\n\t\t\t\t\t\tAVI->video_strn = num_stream;\n\t\t\t\t\t\tAVI->max_len = 0;\n\t\t\t\t\t\tvids_strh_seen = 1;\n\t\t\t\t\t\tlasttag = 1; /* vids */\n\t\t\t\t\t\tmemcpy(&AVI->video_stream_header, hdrl_data + i,\n\t\t\t\t\t\t       sizeof(alAVISTREAMHEADER));\n\t\t\t\t\t}\n\t\t\t\t\telse if (strnicmp ((char *)hdrl_data+i,\"auds\",4) ==0 && ! auds_strh_seen)\n\t\t\t\t\t{\n\n\t\t\t\t\t\t//inc audio tracks\n\t\t\t\t\t\tAVI->aptr=AVI->anum;\n\t\t\t\t\t\t++AVI->anum;\n\n\t\t\t\t\t\tif(AVI->anum > AVI_MAX_TRACKS) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] error - only %d audio tracks supported\\n\", AVI_MAX_TRACKS));\n\t\t\t\t\t\t\treturn(-1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_bytes = str2ulong(hdrl_data+i+32)*avi_sampsize(AVI, 0);\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_strn = num_stream;\n\n\t\t\t\t\t\t// if samplesize==0 -> vbr\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_vbr = !str2ulong(hdrl_data+i+44);\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].padrate = str2ulong(hdrl_data+i+24);\n\t\t\t\t\t\tmemcpy(&AVI->stream_headers[AVI->aptr], hdrl_data + i,\n\t\t\t\t\t\t       sizeof(alAVISTREAMHEADER));\n\n\t\t\t\t\t\t//\t   auds_strh_seen = 1;\n\t\t\t\t\t\tlasttag = 2; /* auds */\n\n\t\t\t\t\t\t// ThOe\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_codech_off = header_offset + i;\n\n\t\t\t\t\t}\n\t\t\t\t\telse if (strnicmp ((char*)hdrl_data+i,\"iavs\",4) ==0 && ! auds_strh_seen) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] AVILIB: error - DV AVI Type 1 no supported\\n\"));\n\t\t\t\t\t\treturn (-1);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tlasttag = 0;\n\t\t\t\t\tnum_stream++;\n\t\t\t\t}\n\t\t\t\telse if(strnicmp((char*)hdrl_data+i,\"dmlh\",4) == 0) {\n\t\t\t\t\tAVI->total_frames = str2ulong(hdrl_data+i+8);\n#ifdef DEBUG_ODML\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] real number of frames %d\\n\", AVI->total_frames));\n#endif\n\t\t\t\t\ti += 8;\n\t\t\t\t}\n\t\t\t\telse if(strnicmp((char *)hdrl_data+i,\"strf\",4)==0)\n\t\t\t\t{\n\t\t\t\t\ti += 8;\n\t\t\t\t\tif(lasttag == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\talBITMAPINFOHEADER bih;\n\n\t\t\t\t\t\tmemcpy(&bih, hdrl_data + i, sizeof(alBITMAPINFOHEADER));\n\t\t\t\t\t\tbih.bi_size = str2ulong((unsigned char *)&bih.bi_size);\n\n\t\t\t\t\t\tif (i + bih.bi_size > hdrl_len) ERR_EXIT(AVI_ERR_READ)\n\n\t\t\t\t\t\tAVI->bitmap_info_header = (alBITMAPINFOHEADER *) gf_malloc(bih.bi_size);\n\t\t\t\t\t\tif (AVI->bitmap_info_header != NULL)\n\t\t\t\t\t\t\tmemcpy(AVI->bitmap_info_header, hdrl_data + i, bih.bi_size);\n\n\t\t\t\t\t\tAVI->width  = str2ulong(hdrl_data+i+4);\n\t\t\t\t\t\tAVI->height = str2ulong(hdrl_data+i+8);\n\t\t\t\t\t\tvids_strf_seen = 1;\n\t\t\t\t\t\t//ThOe\n\t\t\t\t\t\tAVI->v_codecf_off = header_offset + i+16;\n\n\t\t\t\t\t\tmemcpy(AVI->compressor2, hdrl_data+i+16, 4);\n\t\t\t\t\t\tAVI->compressor2[4] = 0;\n\n\t\t\t\t\t\tif (n>40) {\n\t\t\t\t\t\t\tif (n>0xFFFFFFFF) ERR_EXIT(AVI_ERR_READ)\n\t\t\t\t\t\t\tAVI->extradata_size = (u32) (n - 40);\n\t\t\t\t\t\t\tAVI->extradata = gf_malloc(sizeof(u8)* AVI->extradata_size);\n\t\t\t\t\t\t\tif (!AVI->extradata) ERR_EXIT(AVI_ERR_NO_MEM)\n\t\t\t\t\t\t\tmemcpy(AVI->extradata, hdrl_data + i + 40, AVI->extradata_size);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\telse if(lasttag == 2)\n\t\t\t\t\t{\n\t\t\t\t\t\talWAVEFORMATEX *wfe;\n\t\t\t\t\t\tchar *nwfe;\n\t\t\t\t\t\tint wfes;\n\n\t\t\t\t\t\tif ((u32) (hdrl_len - i) < sizeof(alWAVEFORMATEX))\n\t\t\t\t\t\t\twfes = (int) (hdrl_len - i);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\twfes = sizeof(alWAVEFORMATEX);\n\t\t\t\t\t\twfe = (alWAVEFORMATEX *)gf_malloc(sizeof(alWAVEFORMATEX));\n\t\t\t\t\t\tif (wfe != NULL) {\n\t\t\t\t\t\t\tmemset(wfe, 0, sizeof(alWAVEFORMATEX));\n\t\t\t\t\t\t\tmemcpy(wfe, hdrl_data + i, wfes);\n\t\t\t\t\t\t\tif (str2ushort((unsigned char *)&wfe->cb_size) != 0) {\n\t\t\t\t\t\t\t\tnwfe = (char *)\n\t\t\t\t\t\t\t\t       gf_realloc(wfe, sizeof(alWAVEFORMATEX) +\n\t\t\t\t\t\t\t\t                  str2ushort((unsigned char *)&wfe->cb_size));\n\t\t\t\t\t\t\t\tif (nwfe != 0) {\n\t\t\t\t\t\t\t\t\ts64 lpos = gf_ftell(AVI->fdes);\n\t\t\t\t\t\t\t\t\tgf_fseek(AVI->fdes, header_offset + i + sizeof(alWAVEFORMATEX),\n\t\t\t\t\t\t\t\t\t         SEEK_SET);\n\t\t\t\t\t\t\t\t\twfe = (alWAVEFORMATEX *)nwfe;\n\t\t\t\t\t\t\t\t\tnwfe = &nwfe[sizeof(alWAVEFORMATEX)];\n\t\t\t\t\t\t\t\t\tavi_read(AVI->fdes, nwfe,\n\t\t\t\t\t\t\t\t\t         str2ushort((unsigned char *)&wfe->cb_size));\n\t\t\t\t\t\t\t\t\tgf_fseek(AVI->fdes, lpos, SEEK_SET);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tAVI->wave_format_ex[AVI->aptr] = wfe;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_fmt   = str2ushort(hdrl_data+i  );\n\n\t\t\t\t\t\t//ThOe\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_codecf_off = header_offset + i;\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_chans = str2ushort(hdrl_data+i+2);\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_rate  = str2ulong (hdrl_data+i+4);\n\t\t\t\t\t\t//ThOe: read mp3bitrate\n\t\t\t\t\t\tAVI->track[AVI->aptr].mp3rate = 8*str2ulong(hdrl_data+i+8)/1000;\n\t\t\t\t\t\t//:ThOe\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_bits  = str2ushort(hdrl_data+i+14);\n\t\t\t\t\t\t//            auds_strf_seen = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(strnicmp((char*)hdrl_data+i,\"indx\",4) == 0) {\n\t\t\t\t\tchar *a;\n\n\t\t\t\t\tif(lasttag == 1) // V I D E O\n\t\t\t\t\t{\n\n\t\t\t\t\t\ta = (char*)hdrl_data+i;\n\t\t\t\t\t\tint avail = hdrl_len-i;\n\t\t\t\t\t\tif (avail<32) ERR_EXIT(AVI_ERR_READ)\n\n\t\t\t\t\t\tAVI->video_superindex = (avisuperindex_chunk *) gf_malloc (sizeof (avisuperindex_chunk));\n\t\t\t\t\t\tmemset(AVI->video_superindex, 0, sizeof (avisuperindex_chunk));\n\t\t\t\t\t\tmemcpy (AVI->video_superindex->fcc, a, 4);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->video_superindex->dwSize = str2ulong((unsigned char *)a);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->video_superindex->wLongsPerEntry = str2ushort((unsigned char *)a);\n\t\t\t\t\t\ta += 2;\n\t\t\t\t\t\tAVI->video_superindex->bIndexSubType = *a;\n\t\t\t\t\t\ta += 1;\n\t\t\t\t\t\tAVI->video_superindex->bIndexType = *a;\n\t\t\t\t\t\ta += 1;\n\t\t\t\t\t\tAVI->video_superindex->nEntriesInUse = str2ulong((unsigned char *)a);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tmemcpy (AVI->video_superindex->dwChunkId, a, 4);\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\t// 3 * reserved\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\tif (AVI->video_superindex->bIndexSubType != 0) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] Invalid Header, bIndexSubType != 0\\n\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tavail -= 32;\n\t\t\t\t\t\tif (avail < AVI->video_superindex->nEntriesInUse*16) ERR_EXIT(AVI_ERR_READ)\n\n\t\t\t\t\t\tAVI->video_superindex->aIndex = (avisuperindex_entry*)\n\t\t\t\t\t\t                                gf_malloc (AVI->video_superindex->wLongsPerEntry * AVI->video_superindex->nEntriesInUse * sizeof (u32));\n\n\t\t\t\t\t\t// position of ix## chunks\n\t\t\t\t\t\tfor (j=0; j<AVI->video_superindex->nEntriesInUse; ++j) {\n\t\t\t\t\t\t\tAVI->video_superindex->aIndex[j].qwOffset = str2ullong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 8;\n\t\t\t\t\t\t\tAVI->video_superindex->aIndex[j].dwSize = str2ulong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\t\tAVI->video_superindex->aIndex[j].dwDuration = str2ulong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 4;\n\n#ifdef DEBUG_ODML\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d] 0x%llx 0x%lx %lu\\n\", j,\n\t\t\t\t\t\t\t                                        (unsigned int long)AVI->video_superindex->aIndex[j].qwOffset,\n\t\t\t\t\t\t\t                                        (unsigned long)AVI->video_superindex->aIndex[j].dwSize,\n\t\t\t\t\t\t\t                                        (unsigned long)AVI->video_superindex->aIndex[j].dwDuration));\n#endif\n\t\t\t\t\t\t}\n\n\n#ifdef DEBUG_ODML\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] FOURCC \\\"%c%c%c%c\\\"\\n\", AVI->video_superindex->fcc[0], AVI->video_superindex->fcc[1],\n\t\t\t\t\t\t                                        AVI->video_superindex->fcc[2], AVI->video_superindex->fcc[3]));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] LEN \\\"%ld\\\"\\n\", (long)AVI->video_superindex->dwSize));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] wLongsPerEntry \\\"%d\\\"\\n\", AVI->video_superindex->wLongsPerEntry));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] bIndexSubType \\\"%d\\\"\\n\", AVI->video_superindex->bIndexSubType));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] bIndexType \\\"%d\\\"\\n\", AVI->video_superindex->bIndexType));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] nEntriesInUse \\\"%ld\\\"\\n\", (long)AVI->video_superindex->nEntriesInUse));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] dwChunkId \\\"%c%c%c%c\\\"\\n\", AVI->video_superindex->dwChunkId[0], AVI->video_superindex->dwChunkId[1],\n\t\t\t\t\t\t                                        AVI->video_superindex->dwChunkId[2], AVI->video_superindex->dwChunkId[3]));\n#endif\n\n\t\t\t\t\t\tAVI->is_opendml = 1;\n\n\t\t\t\t\t}\n\t\t\t\t\telse if(lasttag == 2) // A U D I O\n\t\t\t\t\t{\n\n\t\t\t\t\t\ta = (char*) hdrl_data+i;\n\t\t\t\t\t\tint avail = hdrl_len-i;\n\t\t\t\t\t\tif (avail<32) ERR_EXIT(AVI_ERR_READ)\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex = (avisuperindex_chunk *) gf_malloc (sizeof (avisuperindex_chunk));\n\t\t\t\t\t\tmemcpy (AVI->track[AVI->aptr].audio_superindex->fcc, a, 4);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->dwSize = str2ulong((unsigned char*)a);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->wLongsPerEntry = str2ushort((unsigned char*)a);\n\t\t\t\t\t\ta += 2;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->bIndexSubType = *a;\n\t\t\t\t\t\ta += 1;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->bIndexType = *a;\n\t\t\t\t\t\ta += 1;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->nEntriesInUse = str2ulong((unsigned char*)a);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tmemcpy (AVI->track[AVI->aptr].audio_superindex->dwChunkId, a, 4);\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\t// 3 * reserved\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\tif (AVI->track[AVI->aptr].audio_superindex->bIndexSubType != 0) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] Invalid Header, bIndexSubType != 0\\n\"));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tavail -= 32;\n\t\t\t\t\t\tif (avail < AVI->track[AVI->aptr].audio_superindex->nEntriesInUse*16) ERR_EXIT(AVI_ERR_READ)\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->aIndex = (avisuperindex_entry*)\n\t\t\t\t\t\t        gf_malloc (AVI->track[AVI->aptr].audio_superindex->wLongsPerEntry *\n\t\t\t\t\t\t                   AVI->track[AVI->aptr].audio_superindex->nEntriesInUse * sizeof (u32));\n\n\t\t\t\t\t\t// position of ix## chunks\n\t\t\t\t\t\tfor (j=0; j<AVI->track[AVI->aptr].audio_superindex->nEntriesInUse; ++j) {\n\t\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->aIndex[j].qwOffset = str2ullong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 8;\n\t\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->aIndex[j].dwSize = str2ulong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->aIndex[j].dwDuration = str2ulong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 4;\n\n#ifdef DEBUG_ODML\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d] 0x%llx 0x%lx %lu\\n\", j,\n\t\t\t\t\t\t\t                                        (unsigned int long)AVI->track[AVI->aptr].audio_superindex->aIndex[j].qwOffset,\n\t\t\t\t\t\t\t                                        (unsigned long)AVI->track[AVI->aptr].audio_superindex->aIndex[j].dwSize,\n\t\t\t\t\t\t\t                                        (unsigned long)AVI->track[AVI->aptr].audio_superindex->aIndex[j].dwDuration));\n#endif\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->stdindex = NULL;\n\n#ifdef DEBUG_ODML\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] FOURCC \\\"%.4s\\\"\\n\", AVI->track[AVI->aptr].audio_superindex->fcc));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] LEN \\\"%ld\\\"\\n\", (long)AVI->track[AVI->aptr].audio_superindex->dwSize));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] wLongsPerEntry \\\"%d\\\"\\n\", AVI->track[AVI->aptr].audio_superindex->wLongsPerEntry));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] bIndexSubType \\\"%d\\\"\\n\", AVI->track[AVI->aptr].audio_superindex->bIndexSubType));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] bIndexType \\\"%d\\\"\\n\", AVI->track[AVI->aptr].audio_superindex->bIndexType));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] nEntriesInUse \\\"%ld\\\"\\n\", (long)AVI->track[AVI->aptr].audio_superindex->nEntriesInUse));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] dwChunkId \\\"%.4s\\\"\\n\", AVI->track[AVI->aptr].audio_superindex->dwChunkId[0]));\n#endif\n\n\t\t\t\t\t}\n\t\t\t\t\ti += 8;\n\t\t\t\t}\n\t\t\t\telse if((strnicmp((char*)hdrl_data+i,\"JUNK\",4) == 0) ||\n\t\t\t\t        (strnicmp((char*)hdrl_data+i,\"strn\",4) == 0) ||\n\t\t\t\t        (strnicmp((char*)hdrl_data+i,\"vprp\",4) == 0)) {\n\t\t\t\t\ti += 8;\n\t\t\t\t\t// do not reset lasttag\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\ti += 8;\n\t\t\t\t\tlasttag = 0;\n\t\t\t\t}\n\t\t\t\t//GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] adding %ld bytes\\n\", (int int)n));\n\n\t\t\t\ti += (u32) n;\n\t\t\t}\n\n\tgf_free(hdrl_data);\n\n\tif(!vids_strh_seen || !vids_strf_seen) ERR_EXIT(AVI_ERR_NO_VIDS)\n\n\t\tAVI->video_tag[0] = AVI->video_strn/10 + '0';\n\tAVI->video_tag[1] = AVI->video_strn%10 + '0';\n\tAVI->video_tag[2] = 'd';\n\tAVI->video_tag[3] = 'b';\n\n\t/* Audio tag is set to \"99wb\" if no audio present */\n\tif(!AVI->track[0].a_chans) AVI->track[0].audio_strn = 99;\n\n\t{\n\t\tint tk=0;\n\t\tfor(j=0; j<AVI->anum+1; ++j) {\n\t\t\tif (j == AVI->video_strn) continue;\n\t\t\tAVI->track[tk].audio_tag[0] = j/10 + '0';\n\t\t\tAVI->track[tk].audio_tag[1] = j%10 + '0';\n\t\t\tAVI->track[tk].audio_tag[2] = 'w';\n\t\t\tAVI->track[tk].audio_tag[3] = 'b';\n\t\t\t++tk;\n\t\t}\n\t}\n\n\tgf_fseek(AVI->fdes,AVI->movi_start,SEEK_SET);\n\n\tif(!getIndex) return(0);\n\n\t/* if the file has an idx1, check if this is relative\n\t   to the start of the file or to the start of the movi list */\n\n\tidx_type = 0;\n\n\tif(AVI->idx)\n\t{\n\t\ts64 pos, len;\n\n\t\t/* Search the first videoframe in the idx1 and look where\n\t\t   it is in the file */\n\n\t\tfor(i=0; i<AVI->n_idx; i++)\n\t\t\tif( strnicmp((char *)AVI->idx[i],(char *)AVI->video_tag,3)==0 ) break;\n\t\tif(i>=AVI->n_idx) ERR_EXIT(AVI_ERR_NO_VIDS)\n\n\t\t\tpos = str2ulong(AVI->idx[i]+ 8);\n\t\tlen = str2ulong(AVI->idx[i]+12);\n\n\t\tgf_fseek(AVI->fdes,pos,SEEK_SET);\n\t\tif(avi_read(AVI->fdes,data,8)!=8) ERR_EXIT(AVI_ERR_READ)\n\t\t\tif( strnicmp(data,(char *)AVI->idx[i],4)==0 && str2ulong((unsigned char *)data+4)==len )\n\t\t\t{\n\t\t\t\tidx_type = 1; /* Index from start of file */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tgf_fseek(AVI->fdes,pos+AVI->movi_start-4,SEEK_SET);\n\t\t\t\tif(avi_read(AVI->fdes,data,8)!=8) ERR_EXIT(AVI_ERR_READ)\n\t\t\t\t\tif( strnicmp(data,(char *)AVI->idx[i],4)==0 && str2ulong((unsigned char *)data+4)==len )\n\t\t\t\t\t{\n\t\t\t\t\t\tidx_type = 2; /* Index from start of movi list */\n\t\t\t\t\t}\n\t\t\t}\n\t\t/* idx_type remains 0 if neither of the two tests above succeeds */\n\t}\n\n\n\tif(idx_type == 0 && !AVI->is_opendml && !AVI->total_frames)\n\t{\n\t\t/* we must search through the file to get the index */\n\n\t\tgf_fseek(AVI->fdes, AVI->movi_start, SEEK_SET);\n\n\t\tAVI->n_idx = 0;\n\n\t\twhile(1)\n\t\t{\n\t\t\tif( avi_read(AVI->fdes,data,8) != 8 ) break;\n\t\t\tn = str2ulong((unsigned char *)data+4);\n\n\t\t\t/* The movi list may contain sub-lists, ignore them */\n\n\t\t\tif(strnicmp(data,\"LIST\",4)==0)\n\t\t\t{\n\t\t\t\tgf_fseek(AVI->fdes,4,SEEK_CUR);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Check if we got a tag ##db, ##dc or ##wb */\n\n\t\t\tif( ( (data[2]=='d' || data[2]=='D') &&\n\t\t\t        (data[3]=='b' || data[3]=='B' || data[3]=='c' || data[3]=='C') )\n\t\t\t        || ( (data[2]=='w' || data[2]=='W') &&\n\t\t\t             (data[3]=='b' || data[3]=='B') ) )\n\t\t\t{\n\t\t\t\tu64 __pos = gf_ftell(AVI->fdes) - 8;\n\t\t\t\tavi_add_index_entry(AVI,(unsigned char *)data,0,__pos,n);\n\t\t\t}\n\n\t\t\tgf_fseek(AVI->fdes,PAD_EVEN(n),SEEK_CUR);\n\t\t}\n\t\tidx_type = 1;\n\t}\n\n\t// ************************\n\t// OPENDML\n\t// ************************\n\n\t// read extended index chunks\n\tif (AVI->is_opendml) {\n\t\tu64 offset = 0;\n\t\thdrl_len = 4+4+2+1+1+4+4+8+4;\n\t\tchar *en, *chunk_start;\n\t\tint k = 0;\n\t\tu32 audtr = 0;\n\t\tu32 nrEntries = 0;\n\n\t\tAVI->video_index = NULL;\n\n\t\tnvi = 0;\n\t\tfor(audtr=0; audtr<AVI->anum; ++audtr) {\n\t\t\tnai[audtr] = 0;\n\t\t\ttot[audtr] = 0;\n\t\t}\n\n\t\t// ************************\n\t\t// VIDEO\n\t\t// ************************\n\n\t\tfor (j=0; j<AVI->video_superindex->nEntriesInUse; j++) {\n\n\t\t\t// read from file\n\t\t\tchunk_start = en = (char*) gf_malloc ((u32) (AVI->video_superindex->aIndex[j].dwSize+hdrl_len) );\n\n\t\t\tif (gf_fseek(AVI->fdes, AVI->video_superindex->aIndex[j].qwOffset, SEEK_SET) == (u64)-1) {\n\t\t\t\tgf_free(chunk_start);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (avi_read(AVI->fdes, en, (u32) (AVI->video_superindex->aIndex[j].dwSize+hdrl_len) ) <= 0) {\n\t\t\t\tgf_free(chunk_start);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnrEntries = str2ulong((unsigned char*)en + 12);\n#ifdef DEBUG_ODML\n\t\t\t//GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d:0] Video nrEntries %ld\\n\", j, nrEntries));\n#endif\n\t\t\toffset = str2ullong((unsigned char*)en + 20);\n\n\t\t\t// skip header\n\t\t\ten += hdrl_len;\n\t\t\tnvi += nrEntries;\n\t\t\tAVI->video_index = (video_index_entry *) gf_realloc (AVI->video_index, nvi * sizeof (video_index_entry));\n\t\t\tif (!AVI->video_index) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] out of mem (size = %ld)\\n\", nvi * sizeof (video_index_entry)));\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\twhile (k < nvi) {\n\n\t\t\t\tAVI->video_index[k].pos = offset + str2ulong((unsigned char*)en);\n\t\t\t\ten += 4;\n\t\t\t\tAVI->video_index[k].len = str2ulong_len((unsigned char*)en);\n\t\t\t\tAVI->video_index[k].key = str2ulong_key((unsigned char*)en);\n\t\t\t\ten += 4;\n\n\t\t\t\t// completely empty chunk\n\t\t\t\tif (AVI->video_index[k].pos-offset == 0 && AVI->video_index[k].len == 0) {\n\t\t\t\t\tk--;\n\t\t\t\t\tnvi--;\n\t\t\t\t}\n\n#ifdef DEBUG_ODML\n\t\t\t\t/*\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d] POS 0x%llX len=%d key=%s offset (%llx) (%ld)\\n\", k,\n\t\t\t\t  AVI->video_index[k].pos,\n\t\t\t\t  (int)AVI->video_index[k].len,\n\t\t\t\t  AVI->video_index[k].key?\"yes\":\"no \", offset,\n\t\t\t\t  AVI->video_superindex->aIndex[j].dwSize));\n\t\t\t\t  */\n#endif\n\n\t\t\t\tk++;\n\t\t\t}\n\n\t\t\tgf_free(chunk_start);\n\t\t}\n\n\t\tAVI->video_frames = nvi;\n\t\t// this should deal with broken 'rec ' odml files.\n\t\tif (AVI->video_frames == 0) {\n\t\t\tAVI->is_opendml=0;\n\t\t\tgoto multiple_riff;\n\t\t}\n\n\t\t// ************************\n\t\t// AUDIO\n\t\t// ************************\n\n\t\tfor(audtr=0; audtr<AVI->anum; ++audtr) {\n\n\t\t\tk = 0;\n\t\t\tif (!AVI->track[audtr].audio_superindex) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] (%s) cannot read audio index for track %d\\n\", __FILE__, audtr));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (j=0; j<AVI->track[audtr].audio_superindex->nEntriesInUse; j++) {\n\n\t\t\t\t// read from file\n\t\t\t\tchunk_start = en = (char*)gf_malloc ((u32) (AVI->track[audtr].audio_superindex->aIndex[j].dwSize+hdrl_len));\n\n\t\t\t\tif (gf_fseek(AVI->fdes, AVI->track[audtr].audio_superindex->aIndex[j].qwOffset, SEEK_SET) == (u64)-1) {\n\t\t\t\t\tgf_free(chunk_start);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (avi_read(AVI->fdes, en, (u32) (AVI->track[audtr].audio_superindex->aIndex[j].dwSize+hdrl_len)) <= 0) {\n\t\t\t\t\tgf_free(chunk_start);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tnrEntries = str2ulong((unsigned char*)en + 12);\n\t\t\t\t//if (nrEntries > 50) nrEntries = 2; // XXX\n#ifdef DEBUG_ODML\n\t\t\t\t//GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d:%d] Audio nrEntries %ld\\n\", j, audtr, nrEntries));\n#endif\n\t\t\t\toffset = str2ullong((unsigned char*)en + 20);\n\n\t\t\t\t// skip header\n\t\t\t\ten += hdrl_len;\n\t\t\t\tnai[audtr] += nrEntries;\n\t\t\t\tAVI->track[audtr].audio_index = (audio_index_entry *) gf_realloc (AVI->track[audtr].audio_index, nai[audtr] * sizeof (audio_index_entry));\n\n\t\t\t\twhile (k < nai[audtr]) {\n\n\t\t\t\t\tAVI->track[audtr].audio_index[k].pos = offset + str2ulong((unsigned char*)en);\n\t\t\t\t\ten += 4;\n\t\t\t\t\tAVI->track[audtr].audio_index[k].len = str2ulong_len((unsigned char*)en);\n\t\t\t\t\ten += 4;\n\t\t\t\t\tAVI->track[audtr].audio_index[k].tot = tot[audtr];\n\t\t\t\t\ttot[audtr] += AVI->track[audtr].audio_index[k].len;\n\n#ifdef DEBUG_ODML\n\t\t\t\t\t/*\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d:%d] POS 0x%llX len=%d offset (%llx) (%ld)\\n\", k, audtr,\n\t\t\t\t\t  AVI->track[audtr].audio_index[k].pos,\n\t\t\t\t\t  (int)AVI->track[audtr].audio_index[k].len,\n\t\t\t\t\t  offset, AVI->track[audtr].audio_superindex->aIndex[j].dwSize));\n\t\t\t\t\t  */\n#endif\n\n\t\t\t\t\t++k;\n\t\t\t\t}\n\n\t\t\t\tgf_free(chunk_start);\n\t\t\t}\n\n\t\t\tAVI->track[audtr].audio_chunks = nai[audtr];\n\t\t\tAVI->track[audtr].audio_bytes = tot[audtr];\n\t\t}\n\t} // is opendml\n\n\telse if (AVI->total_frames && !AVI->is_opendml && idx_type==0) {\n\n\t\t// *********************\n\t\t// MULTIPLE RIFF CHUNKS (and no index)\n\t\t// *********************\n\nmultiple_riff:\n\n\t\tgf_fseek(AVI->fdes, AVI->movi_start, SEEK_SET);\n\n\t\tAVI->n_idx = 0;\n\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] Reconstructing index...\"));\n\n\t\t// Number of frames; only one audio track supported\n\t\tnvi = AVI->video_frames = AVI->total_frames;\n\t\tnai[0] = AVI->track[0].audio_chunks = AVI->total_frames;\n\t\tfor(j=1; j<AVI->anum; ++j) AVI->track[j].audio_chunks = 0;\n\n\t\tAVI->video_index = (video_index_entry *) gf_malloc(nvi*sizeof(video_index_entry));\n\n\t\tif(AVI->video_index==0) ERR_EXIT(AVI_ERR_NO_MEM);\n\n\t\tfor(j=0; j<AVI->anum; ++j) {\n\t\t\tif(AVI->track[j].audio_chunks) {\n\t\t\t\tAVI->track[j].audio_index = (audio_index_entry *) gf_malloc((nai[j]+1)*sizeof(audio_index_entry));\n\t\t\t\tmemset(AVI->track[j].audio_index, 0, (nai[j]+1)*(sizeof(audio_index_entry)));\n\t\t\t\tif(AVI->track[j].audio_index==0) ERR_EXIT(AVI_ERR_NO_MEM);\n\t\t\t}\n\t\t}\n\n\t\tnvi = 0;\n\t\tfor(j=0; j<AVI->anum; ++j) {\n\t\t\tnai[j] = 0;\n\t\t\ttot[j] = 0;\n\t\t}\n\n\t\taud_chunks = AVI->total_frames;\n\n\t\twhile(1)\n\t\t{\n\t\t\tif (nvi >= AVI->total_frames) break;\n\n\t\t\tif( avi_read(AVI->fdes,data,8) != 8 ) break;\n\t\t\tn = str2ulong((unsigned char *)data+4);\n\n\n\t\t\tj=0;\n\n\t\t\tif (aud_chunks - nai[j] -1 <= 0) {\n\t\t\t\taud_chunks += AVI->total_frames;\n\t\t\t\tAVI->track[j].audio_index = (audio_index_entry *)\n\t\t\t\t                            gf_realloc( AVI->track[j].audio_index, (aud_chunks+1)*sizeof(audio_index_entry));\n\t\t\t\tif (!AVI->track[j].audio_index) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] Internal error in avilib -- no mem\\n\"));\n\t\t\t\t\tAVI_errno = AVI_ERR_NO_MEM;\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Check if we got a tag ##db, ##dc or ##wb */\n\n\t\t\t// VIDEO\n\t\t\tif(\n\t\t\t    (data[0]=='0' || data[1]=='0') &&\n\t\t\t    (data[2]=='d' || data[2]=='D') &&\n\t\t\t    (data[3]=='b' || data[3]=='B' || data[3]=='c' || data[3]=='C') ) {\n\n\t\t\t\tAVI->video_index[nvi].key = 0x0;\n\t\t\t\tAVI->video_index[nvi].pos = gf_ftell(AVI->fdes);\n\t\t\t\tAVI->video_index[nvi].len = (u32) n;\n\n\t\t\t\t/*\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] Frame %ld pos %\"LLD\" len %\"LLD\" key %ld\\n\",\n\t\t\t\t    nvi, AVI->video_index[nvi].pos,  AVI->video_index[nvi].len, (long)AVI->video_index[nvi].key));\n\t\t\t\t    */\n\t\t\t\tnvi++;\n\t\t\t\tgf_fseek(AVI->fdes,PAD_EVEN(n),SEEK_CUR);\n\t\t\t}\n\n\t\t\t//AUDIO\n\t\t\telse if(\n\t\t\t    (data[0]=='0' || data[1]=='1') &&\n\t\t\t    (data[2]=='w' || data[2]=='W') &&\n\t\t\t    (data[3]=='b' || data[3]=='B') ) {\n\n\n\t\t\t\tAVI->track[j].audio_index[nai[j]].pos = gf_ftell(AVI->fdes);\n\t\t\t\tAVI->track[j].audio_index[nai[j]].len = (u32) n;\n\t\t\t\tAVI->track[j].audio_index[nai[j]].tot = tot[j];\n\t\t\t\ttot[j] += AVI->track[j].audio_index[nai[j]].len;\n\t\t\t\tnai[j]++;\n\n\t\t\t\tgf_fseek(AVI->fdes,PAD_EVEN(n),SEEK_CUR);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgf_fseek(AVI->fdes,-4,SEEK_CUR);\n\t\t\t}\n\n\t\t}\n\t\tif (nvi < AVI->total_frames) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[avilib] Uh? Some frames seems missing (%ld/%d)\\n\",\n\t\t\t        nvi,  AVI->total_frames));\n\t\t}\n\n\n\t\tAVI->video_frames = nvi;\n\t\tAVI->track[0].audio_chunks = nai[0];\n\n\t\tfor(j=0; j<AVI->anum; ++j) AVI->track[j].audio_bytes = tot[j];\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] done. nvi=%ld nai=%ld tot=%ld\\n\", nvi, nai[0], tot[0]));\n\n\t} // total_frames but no indx chunk (xawtv does this)\n\n\telse\n\n\t{\n\t\t// ******************\n\t\t// NO OPENDML\n\t\t// ******************\n\n\t\t/* Now generate the video index and audio index arrays */\n\n\t\tnvi = 0;\n\t\tfor(j=0; j<AVI->anum; ++j) nai[j] = 0;\n\n\t\tfor(i=0; i<AVI->n_idx; i++) {\n\n\t\t\tif(strnicmp((char *)AVI->idx[i],AVI->video_tag,3) == 0) nvi++;\n\n\t\t\tfor(j=0; j<AVI->anum; ++j) if(strnicmp((char *)AVI->idx[i], AVI->track[j].audio_tag,4) == 0) nai[j]++;\n\t\t}\n\n\t\tAVI->video_frames = nvi;\n\t\tfor(j=0; j<AVI->anum; ++j) AVI->track[j].audio_chunks = nai[j];\n\n\n\t\tif(AVI->video_frames==0) ERR_EXIT(AVI_ERR_NO_VIDS);\n\t\tAVI->video_index = (video_index_entry *) gf_malloc(nvi*sizeof(video_index_entry));\n\t\tif(AVI->video_index==0) ERR_EXIT(AVI_ERR_NO_MEM);\n\n\t\tfor(j=0; j<AVI->anum; ++j) {\n\t\t\tif(AVI->track[j].audio_chunks) {\n\t\t\t\tAVI->track[j].audio_index = (audio_index_entry *) gf_malloc((nai[j]+1)*sizeof(audio_index_entry));\n\t\t\t\tmemset(AVI->track[j].audio_index, 0, (nai[j]+1)*(sizeof(audio_index_entry)));\n\t\t\t\tif(AVI->track[j].audio_index==0) ERR_EXIT(AVI_ERR_NO_MEM);\n\t\t\t}\n\t\t}\n\n\t\tnvi = 0;\n\t\tfor(j=0; j<AVI->anum; ++j) {\n\t\t\tnai[j] = 0;\n\t\t\ttot[j] = 0;\n\t\t}\n\n\t\tioff = idx_type == 1 ? 8 : (u32)AVI->movi_start+4;\n\n\t\tfor(i=0; i<AVI->n_idx; i++) {\n\n\t\t\t//video\n\t\t\tif(strnicmp((char *)AVI->idx[i],AVI->video_tag,3) == 0) {\n\t\t\t\tAVI->video_index[nvi].key = str2ulong(AVI->idx[i]+ 4);\n\t\t\t\tAVI->video_index[nvi].pos = str2ulong(AVI->idx[i]+ 8)+ioff;\n\t\t\t\tAVI->video_index[nvi].len = str2ulong(AVI->idx[i]+12);\n\t\t\t\tnvi++;\n\t\t\t}\n\n\t\t\t//audio\n\t\t\tfor(j=0; j<AVI->anum; ++j) {\n\n\t\t\t\tif(strnicmp((char *)AVI->idx[i],AVI->track[j].audio_tag,4) == 0) {\n\t\t\t\t\tAVI->track[j].audio_index[nai[j]].pos = str2ulong(AVI->idx[i]+ 8)+ioff;\n\t\t\t\t\tAVI->track[j].audio_index[nai[j]].len = str2ulong(AVI->idx[i]+12);\n\t\t\t\t\tAVI->track[j].audio_index[nai[j]].tot = tot[j];\n\t\t\t\t\ttot[j] += AVI->track[j].audio_index[nai[j]].len;\n\t\t\t\t\tnai[j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tfor(j=0; j<AVI->anum; ++j) AVI->track[j].audio_bytes = tot[j];\n\n\t} // is no opendml\n\n\t/* Reposition the file */\n\n\tgf_fseek(AVI->fdes,AVI->movi_start,SEEK_SET);\n\tAVI->video_pos = 0;\n\n\treturn(0);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Fun-Call",
    "line_old": 2883,
    "critical_vars": [
      "av1c->version",
      "av1c->seq_profile",
      "av1c->seq_level_idx_0",
      "av1c->seq_tier_0",
      "stderr"
    ],
    "function": "DumpTrackInfo",
    "filename": "gpac/CVE-2021-32138/CVE-2021-32138_CWE-476_289ffce3e0d224d314f5f92a744d5fe35999f20b_filedump.c.diff",
    "function_code": "void gf_inspect_format_timecode(const u8 *data, u32 size, u32 tmcd_flags, u32 tc_num, u32 tc_den, u32 tmcd_fpt, char szFmt[100]);\n\nvoid DumpTrackInfo(GF_ISOFile *file, GF_ISOTrackID trackID, Bool full_dump, Bool is_track_num, Bool dump_m4sys)\n{\n\tchar szCodec[RFC6381_CODEC_NAME_SIZE_MAX];\n\tDouble scale, max_rate, rate;\n\tBool is_od_track = 0;\n\tu32 trackNum, i, j, ts, mtype, msub_type, timescale, sr, nb_ch, count, alt_group, nb_groups, nb_edits, cdur, csize, bps, pfmt, codecid;\n\tu64 time_slice, dur, size;\n\ts32 cts_shift;\n\tGF_ESD *esd;\n\tchar szDur[50];\n\tchar *lang;\n\n\tif (!is_track_num) {\n\t\ttrackNum = gf_isom_get_track_by_id(file, trackID);\n\t} else {\n\t\ttrackNum = trackID;\n\t\ttrackID = gf_isom_get_track_id(file, trackNum);\n\t}\n\tif (!trackNum) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"No track with ID %d found\\n\", trackID));\n\t\treturn;\n\t}\n\n\ttimescale = gf_isom_get_media_timescale(file, trackNum);\n\tfprintf(stderr, \"# Track %d Info - ID %d - TimeScale %d\\n\", trackNum, trackID, timescale);\n\n\tdur = gf_isom_get_media_original_duration(file, trackNum);\n\tsize = gf_isom_get_media_duration(file, trackNum);\n\tfprintf(stderr, \"Media Duration %s \", format_duration(dur, timescale, szDur));\n\tif (dur != size)\n\t\tfprintf(stderr, \" (recomputed %s)\", format_duration(size, timescale, szDur));\n\tfprintf(stderr, \"\\n\");\n\n\tif (gf_isom_check_data_reference(file, trackNum, 1) != GF_OK) {\n\t\tM4_LOG(GF_LOG_WARNING, (\"Track uses external data reference not supported by GPAC!\\n\"));\n\t}\n\n\tnb_edits = gf_isom_get_edits_count(file, trackNum);\n\tif (nb_edits)\n\t\tfprintf(stderr, \"Track has %d edits: track duration is %s\\n\", nb_edits, format_duration(gf_isom_get_track_duration(file, trackNum), gf_isom_get_timescale(file), szDur));\n\n\tcts_shift = gf_isom_get_composition_offset_shift(file, trackNum);\n\tif (cts_shift)\n\t\tfprintf(stderr, \"Track composition offset shift (negative CTS offset): %d\\n\", cts_shift);\n\n\tif (gf_isom_is_track_in_root_od(file, trackNum) ) fprintf(stderr, \"Track is present in Root OD\\n\");\n\tif (!gf_isom_is_track_enabled(file, trackNum))  fprintf(stderr, \"Track is disabled\\n\");\n\tgf_isom_get_media_language(file, trackNum, &lang);\n\tfprintf(stderr, \"Media Info: Language \\\"%s (%s)\\\" - \", GetLanguage(lang), lang );\n\tgf_free(lang);\n\tmtype = gf_isom_get_media_type(file, trackNum);\n\tfprintf(stderr, \"Type \\\"%s:\", gf_4cc_to_str(mtype));\n\tmsub_type = gf_isom_get_mpeg4_subtype(file, trackNum, 1);\n\tif (!msub_type) msub_type = gf_isom_get_media_subtype(file, trackNum, 1);\n\tfprintf(stderr, \"%s\\\" - %d samples\\n\", gf_4cc_to_str(msub_type), gf_isom_get_sample_count(file, trackNum));\n\n\tpfmt = gf_pixel_fmt_from_qt_type(msub_type);\n\tcodecid = gf_codec_id_from_isobmf(msub_type);\n\n\tcount = gf_isom_get_track_kind_count(file, trackNum);\n\tfor (i = 0; i < count; i++) {\n\t\tchar *kind_scheme, *kind_value;\n\t\tgf_isom_get_track_kind(file, trackNum, i, &kind_scheme, &kind_value);\n\t\tfprintf(stderr, \"Kind: %s - %s\\n\", kind_scheme ? kind_scheme : \"null\", kind_value ? kind_value : \"null\");\n\t\tif (kind_scheme) gf_free(kind_scheme);\n\t\tif (kind_value) gf_free(kind_value);\n\t}\n\n\tif (gf_isom_is_track_fragmented(file, trackID) ) {\n\t\tu32 defaultDuration, defaultSize, defaultDescriptionIndex, defaultRandomAccess;\n\t\tu8 defaultPadding;\n\t\tu16 defaultDegradationPriority;\n\t\tu32 frag_samples;\n\t\tu64 frag_duration;\n\t\tgf_isom_get_fragmented_samples_info(file, trackID, &frag_samples, &frag_duration);\n\t\tfprintf(stderr, \"Fragmented track: %d samples - Media Duration %s\\n\", frag_samples, format_duration(frag_duration, timescale, szDur));\n\n\t\tgf_isom_get_fragment_defaults(file, trackNum, &defaultDuration, &defaultSize, &defaultDescriptionIndex, &defaultRandomAccess, &defaultPadding, &defaultDegradationPriority);\n\n\t\tfprintf(stderr, \"Fragment sample defaults: duration %d size %d stsd %d sync %d padding %d degradation_priority %d\\n\",\n\t\t\t\tdefaultDuration, defaultSize, defaultDescriptionIndex, defaultRandomAccess,\n\t\t\t\t(u32) defaultPadding, (u32) defaultDegradationPriority\n\t\t);\n\t}\n\n\tif (!gf_isom_is_self_contained(file, trackNum, 1)) {\n\t\tconst char *url, *urn;\n\t\tgf_isom_get_data_reference(file, trackNum, 1, &url, &urn);\n\t\tfprintf(stderr, \"Media Data Location: %s\\n\", url ? url : urn);\n\t}\n\n\tif (full_dump) {\n\t\tconst char *handler_name;\n\t\tgf_isom_get_handler_name(file, trackNum, &handler_name);\n\t\tfprintf(stderr, \"Handler name: %s\\n\", handler_name);\n\t}\n\n\tprint_udta(file, trackNum, GF_FALSE);\n\n\tif (gf_isom_is_video_handler_type(mtype) ) {\n\t\ts32 tx, ty;\n\t\tu32 w, h;\n\t\tu16 bit_depth;\n\n\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\tgf_isom_get_visual_bit_depth(file, trackNum, 1, &bit_depth);\n\t\tfprintf(stderr, \"Visual Sample Entry Info: width=%d height=%d (depth=%d bits)\\n\", w, h, (int)bit_depth);\n\n\t\tgf_isom_get_track_layout_info(file, trackNum, &w, &h, &tx, &ty, NULL);\n\t\tfprintf(stderr, \"Visual Track layout: x=%d y=%d width=%d height=%d\\n\", tx, ty, w, h);\n\t}\n\n\tgf_isom_get_audio_info(file, trackNum, 1, &sr, &nb_ch, &bps);\n\tgf_isom_set_nalu_extract_mode(file, trackNum, GF_ISOM_NALU_EXTRACT_INSPECT);\n\n\tmsub_type = gf_isom_get_media_subtype(file, trackNum, 1);\n\tif (msub_type==GF_ISOM_SUBTYPE_MPEG4_CRYP)\n\t\tgf_isom_get_original_format_type(file, trackNum, 1, &msub_type);\n\n\tif ((msub_type==GF_ISOM_SUBTYPE_MPEG4)\n\t        || (msub_type==GF_ISOM_SUBTYPE_AVC_H264)\n\t        || (msub_type==GF_ISOM_SUBTYPE_AVC2_H264)\n\t        || (msub_type==GF_ISOM_SUBTYPE_AVC3_H264)\n\t        || (msub_type==GF_ISOM_SUBTYPE_AVC4_H264)\n\t        || (msub_type==GF_ISOM_SUBTYPE_SVC_H264)\n\t        || (msub_type==GF_ISOM_SUBTYPE_MVC_H264)\n\t        || (msub_type==GF_ISOM_SUBTYPE_LSR1)\n\t        || (msub_type==GF_ISOM_SUBTYPE_HVC1)\n\t        || (msub_type==GF_ISOM_SUBTYPE_HEV1)\n\t        || (msub_type==GF_ISOM_SUBTYPE_HVC2)\n\t        || (msub_type==GF_ISOM_SUBTYPE_HEV2)\n\t        || (msub_type==GF_ISOM_SUBTYPE_LHV1)\n\t        || (msub_type==GF_ISOM_SUBTYPE_LHE1)\n\t        || (msub_type==GF_ISOM_SUBTYPE_HVT1)\n\t   )  {\n\t\tesd = gf_isom_get_esd(file, trackNum, 1);\n\t\tif (!esd || !esd->decoderConfig) {\n\t\t\tM4_LOG(GF_LOG_WARNING, (\"WARNING: Broken MPEG-4 Track\\n\"));\n\t\t\tif (esd) gf_odf_desc_del((GF_Descriptor *)esd);\n\t\t} else {\n\t\t\tconst char *st = gf_stream_type_name(esd->decoderConfig->streamType);\n\t\t\tif (dump_m4sys) {\n\t\t\t\tif (st) {\n\t\t\t\t\tfprintf(stderr, \"MPEG-4 Config%s%s Stream - ObjectTypeIndication 0x%02x\\n\",\n\t\t\t\t\t\t\tfull_dump ? \"\\n\\t\" : \": \", st, esd->decoderConfig->objectTypeIndication);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"MPEG-4 Config%sStream Type 0x%02x - ObjectTypeIndication 0x%02x\\n\",\n\t\t\t\t\t\t\tfull_dump ? \"\\n\\t\" : \": \", esd->decoderConfig->streamType, esd->decoderConfig->objectTypeIndication);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (esd->decoderConfig->streamType==GF_STREAM_OD)\n\t\t\t\tis_od_track=1;\n\n\t\t\tif (esd->decoderConfig->streamType==GF_STREAM_VISUAL) {\n\t\t\t\tu32 w, h;\n\t\t\t\tu16 rvc_predef;\n\t\t\t\tw = h = 0;\n\t\t\t\tif (esd->decoderConfig->objectTypeIndication==GF_CODECID_MPEG4_PART2) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\tif (!esd->decoderConfig->decoderSpecificInfo) {\n#else\n\t\t\t\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\t\t\t\tfprintf(stderr, \"MPEG-4 Visual Size %d x %d\\n\", w, h);\n#endif\n\t\t\t\t\t\tM4_LOG(GF_LOG_WARNING, (\"Non-compliant MPEG-4 Visual track: video_object_layer infos not found in sample description\\n\"));\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\t} else {\n\t\t\t\t\t\tGF_M4VDecSpecInfo dsi;\n\t\t\t\t\t\tgf_m4v_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &dsi);\n\t\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\t\t\t\t\tw = dsi.width;\n\t\t\t\t\t\th = dsi.height;\n\t\t\t\t\t\tfprintf(stderr, \"MPEG-4 Visual Size %d x %d - %s\\n\", w, h, gf_m4v_get_profile_name(dsi.VideoPL));\n\t\t\t\t\t\tif (dsi.par_den && dsi.par_num) {\n\t\t\t\t\t\t\tu32 tw, th;\n\t\t\t\t\t\t\tgf_isom_get_track_layout_info(file, trackNum, &tw, &th, NULL, NULL, NULL);\n\t\t\t\t\t\t\tfprintf(stderr, \"Pixel Aspect Ratio %d:%d - Indicated track size %d x %d\\n\", dsi.par_num, dsi.par_den, tw, th);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t} else if (gf_isom_get_avc_svc_type(file, trackNum, 1) != GF_ISOM_AVCTYPE_NONE) {\n\t\t\t\t\tGF_AVCConfig *avccfg, *svccfg, *mvccfg;\n\n\t\t\t\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\t\t\t\tfprintf(stderr, \"AVC/H264 Video - Visual Size %d x %d\\n\", w, h);\n\n\t\t\t\t\tavccfg = gf_isom_avc_config_get(file, trackNum, 1);\n\t\t\t\t\tsvccfg = gf_isom_svc_config_get(file, trackNum, 1);\n\t\t\t\t\tmvccfg = gf_isom_mvc_config_get(file, trackNum, 1);\n\t\t\t\t\tif (!avccfg && !svccfg && !mvccfg) {\n\t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"\\tNon-compliant AVC track: SPS/PPS not found in sample description\\n\"));\n\t\t\t\t\t} else if (avccfg) {\n\t\t\t\t\t\tfprintf(stderr, \"\\tAVC Info: %d SPS - %d PPS\", gf_list_count(avccfg->sequenceParameterSets) , gf_list_count(avccfg->pictureParameterSets) );\n\t\t\t\t\t\tfprintf(stderr, \" - Profile %s @ Level %g\\n\", gf_avc_get_profile_name(avccfg->AVCProfileIndication), ((Double)avccfg->AVCLevelIndication)/10.0 );\n\t\t\t\t\t\tfprintf(stderr, \"\\tNAL Unit length bits: %d\\n\", 8*avccfg->nal_unit_size);\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\t\tfor (i=0; i<gf_list_count(avccfg->sequenceParameterSets); i++) {\n\t\t\t\t\t\t\ts32 par_n, par_d;\n\t\t\t\t\t\t\tGF_NALUFFParam *slc = gf_list_get(avccfg->sequenceParameterSets, i);\n\t\t\t\t\t\t\tgf_avc_get_sps_info(slc->data, slc->size, NULL, NULL, NULL, &par_n, &par_d);\n\t\t\t\t\t\t\tif ((par_n>0) && (par_d>0)) {\n\t\t\t\t\t\t\t\tu32 tw, th;\n\t\t\t\t\t\t\t\tgf_isom_get_track_layout_info(file, trackNum, &tw, &th, NULL, NULL, NULL);\n\t\t\t\t\t\t\t\tfprintf(stderr, \"\\tPixel Aspect Ratio %d:%d - Indicated track size %d x %d\\n\", par_n, par_d, tw, th);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!full_dump) break;\n\t\t\t\t\t\t}\n#endif\n\n\t\t\t\t\t\tif (avccfg->chroma_bit_depth) {\n\t\t\t\t\t\t\tfprintf(stderr, \"\\tChroma format %s - Luma bit depth %d - chroma bit depth %d\\n\", gf_avc_hevc_get_chroma_format_name(avccfg->chroma_format), avccfg->luma_bit_depth, avccfg->chroma_bit_depth);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tprint_config_hash(avccfg->sequenceParameterSets, \"SPS\");\n\t\t\t\t\t\tprint_config_hash(avccfg->pictureParameterSets, \"PPS\");\n\n\t\t\t\t\t\tgf_odf_avc_cfg_del(avccfg);\n\t\t\t\t\t}\n\t\t\t\t\tif (svccfg) {\n\t\t\t\t\t\tfprintf(stderr, \"\\n\\tSVC Info: %d SPS - %d PPS - Profile %s @ Level %g\\n\", gf_list_count(svccfg->sequenceParameterSets) , gf_list_count(svccfg->pictureParameterSets), gf_avc_get_profile_name(svccfg->AVCProfileIndication), ((Double)svccfg->AVCLevelIndication)/10.0 );\n\t\t\t\t\t\tfprintf(stderr, \"\\tSVC NAL Unit length bits: %d\\n\", 8*svccfg->nal_unit_size);\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\t\tfor (i=0; i<gf_list_count(svccfg->sequenceParameterSets); i++) {\n\t\t\t\t\t\t\tGF_NALUFFParam *slc = gf_list_get(svccfg->sequenceParameterSets, i);\n\t\t\t\t\t\t\tif (slc) {\n\t\t\t\t\t\t\t\ts32 par_n, par_d;\n\t\t\t\t\t\t\t\tu32 s_w, s_h, sps_id;\n\t\t\t\t\t\t\t\tgf_avc_get_sps_info(slc->data, slc->size, &sps_id, &s_w, &s_h, &par_n, &par_d);\n\t\t\t\t\t\t\t\tfprintf(stderr, \"\\t\\tSPS ID %d - Visual Size %d x %d\\n\", sps_id, s_w, s_h);\n\t\t\t\t\t\t\t\tif ((par_n>0) && (par_d>0)) {\n\t\t\t\t\t\t\t\t\tu32 tw, th;\n\t\t\t\t\t\t\t\t\tgf_isom_get_track_layout_info(file, trackNum, &tw, &th, NULL, NULL, NULL);\n\t\t\t\t\t\t\t\t\tfprintf(stderr, \"\\tPixel Aspect Ratio %d:%d - Indicated track size %d x %d\\n\", par_n, par_d, tw, th);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t\tprint_config_hash(svccfg->sequenceParameterSets, \"SPS\");\n\t\t\t\t\t\tprint_config_hash(svccfg->pictureParameterSets, \"PPS\");\n\t\t\t\t\t\tprint_config_hash(svccfg->sequenceParameterSetExtensions, \"SPSEx\");\n\n\t\t\t\t\t\tgf_odf_avc_cfg_del(svccfg);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (mvccfg) {\n\t\t\t\t\t\tfprintf(stderr, \"\\n\\tMVC Info: %d SPS - %d PPS - Profile %s @ Level %g\\n\", gf_list_count(mvccfg->sequenceParameterSets) , gf_list_count(mvccfg->pictureParameterSets), gf_avc_get_profile_name(mvccfg->AVCProfileIndication), ((Double)mvccfg->AVCLevelIndication)/10.0 );\n\t\t\t\t\t\tfprintf(stderr, \"\\tMVC NAL Unit length bits: %d\\n\", 8*mvccfg->nal_unit_size);\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\t\tfor (i=0; i<gf_list_count(mvccfg->sequenceParameterSets); i++) {\n\t\t\t\t\t\t\tGF_NALUFFParam *slc = gf_list_get(mvccfg->sequenceParameterSets, i);\n\t\t\t\t\t\t\tif (slc) {\n\t\t\t\t\t\t\t\tu32 s_w, s_h, sps_id;\n\t\t\t\t\t\t\t\ts32 par_n, par_d;\n\t\t\t\t\t\t\t\tgf_avc_get_sps_info(slc->data, slc->size, &sps_id, &s_w, &s_h, &par_n, &par_d);\n\t\t\t\t\t\t\t\tfprintf(stderr, \"\\t\\tSPS ID %d - Visual Size %d x %d\\n\", sps_id, s_w, s_h);\n\t\t\t\t\t\t\t\tif ((par_n>0) && (par_d>0)) {\n\t\t\t\t\t\t\t\t\tu32 tw, th;\n\t\t\t\t\t\t\t\t\tgf_isom_get_track_layout_info(file, trackNum, &tw, &th, NULL, NULL, NULL);\n\t\t\t\t\t\t\t\t\tfprintf(stderr, \"\\tPixel Aspect Ratio %d:%d - Indicated track size %d x %d\\n\", par_n, par_d, tw, th);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t\tprint_config_hash(mvccfg->sequenceParameterSets, \"SPS\");\n\t\t\t\t\t\tprint_config_hash(mvccfg->pictureParameterSets, \"PPS\");\n\t\t\t\t\t\tgf_odf_avc_cfg_del(mvccfg);\n\t\t\t\t\t}\n\n\t\t\t\t} else if ((esd->decoderConfig->objectTypeIndication==GF_CODECID_HEVC)\n\t\t\t\t           || (esd->decoderConfig->objectTypeIndication==GF_CODECID_LHVC)\n\t\t\t\t          ) {\n\t\t\t\t\tGF_HEVCConfig *hevccfg, *lhvccfg;\n\t\t\t\t\tGF_OperatingPointsInformation *oinf;\n#if !defined(GPAC_DISABLE_AV_PARSERS) && !defined(GPAC_DISABLE_HEVC)\n\t\t\t\t\tHEVCState hevc_state;\n\t\t\t\t\tmemset(&hevc_state, 0, sizeof(HEVCState));\n\t\t\t\t\thevc_state.sps_active_idx = -1;\n#endif\n\n\t\t\t\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\t\t\t\tfprintf(stderr, \"HEVC Video - Visual Size %d x %d\\n\", w, h);\n\t\t\t\t\thevccfg = gf_isom_hevc_config_get(file, trackNum, 1);\n\t\t\t\t\tlhvccfg = gf_isom_lhvc_config_get(file, trackNum, 1);\n\n\t\t\t\t\tif (msub_type==GF_ISOM_SUBTYPE_HVT1) {\n\t\t\t\t\t\tconst u8 *data;\n\t\t\t\t\t\tu32 tsize;\n\t\t\t\t\t\tu32  is_default, tx,ty,tw,th, id, independent;\n\t\t\t\t\t\tBool full_frame;\n\t\t\t\t\t\tif (gf_isom_get_tile_info(file, trackNum, 1, &is_default, &id, &independent, &full_frame, &tx, &ty, &tw, &th)) {\n\t\t\t\t\t\t\tfprintf(stderr, \"\\tHEVC Tile - ID %d independent %d (x,y,w,h)=%d,%d,%d,%d \\n\", id, independent, tx, ty, tw, th);\n\t\t\t\t\t\t} else if (gf_isom_get_sample_group_info(file, trackNum, 1, GF_ISOM_SAMPLE_GROUP_TRIF, &is_default, &data, &tsize)) {\n\t\t\t\t\t\t\tfprintf(stderr, \"\\tHEVC Tile track containing a tile set\\n\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfprintf(stderr, \"\\tHEVC Tile track without tiling info\\n\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (!hevccfg && !lhvccfg) {\n\t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"\\tNon-compliant HEVC track: No hvcC or shcC found in sample description\\n\"));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (gf_isom_get_reference_count(file, trackNum, GF_ISOM_REF_SABT)) {\n\t\t\t\t\t\tfprintf(stderr, \"\\tHEVC Tile base track\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tif (hevccfg) {\n\t\t\t\t\t\tdump_hevc_track_info(file, trackNum, hevccfg\n#if !defined(GPAC_DISABLE_AV_PARSERS) && !defined(GPAC_DISABLE_HEVC)\n\t\t\t\t\t\t\t, &hevc_state\n#endif\n\t\t\t\t\t\t);\n\t\t\t\t\t\tgf_odf_hevc_cfg_del(hevccfg);\n\t\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tif (lhvccfg) {\n\t\t\t\t\t\tdump_hevc_track_info(file, trackNum, lhvccfg\n#if !defined(GPAC_DISABLE_AV_PARSERS) && !defined(GPAC_DISABLE_HEVC)\n\t\t\t\t\t\t\t, &hevc_state\n#endif\n\t\t\t\t\t\t);\n\t\t\t\t\t\tgf_odf_hevc_cfg_del(lhvccfg);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (gf_isom_get_oinf_info(file, trackNum, &oinf)) {\n\t\t\t\t\t\tfprintf(stderr, \"\\n\\tOperating Points Information -\");\n\t\t\t\t\t\tfprintf(stderr, \" scalability_mask %d (\", oinf->scalability_mask);\n\t\t\t\t\t\tswitch (oinf->scalability_mask) {\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tfprintf(stderr, \"Multiview\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\tfprintf(stderr, \"Spatial scalability\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 8:\n\t\t\t\t\t\t\tfprintf(stderr, \"Auxilary\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tfprintf(stderr, \"unknown\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//TODO: need to dump more info ?\n\t\t\t\t\t\tfprintf(stderr, \") num_profile_tier_level %d \", gf_list_count(oinf->profile_tier_levels) );\n\t\t\t\t\t\tfprintf(stderr, \" num_operating_points %d dependency layers %d \\n\", gf_list_count(oinf->operating_points), gf_list_count(oinf->dependency_layers) );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*OGG media*/\n\t\t\t\telse if (esd->decoderConfig->objectTypeIndication==GF_CODECID_THEORA) {\n\t\t\t\t\tchar *szName;\n\t\t\t\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\t\t\t\tif (!strnicmp((char *) &esd->decoderConfig->decoderSpecificInfo->data[3], \"theora\", 6)) szName = \"Theora\";\n\t\t\t\t\telse szName = \"Unknown\";\n\t\t\t\t\tfprintf(stderr, \"Ogg/%s video / GPAC Mux  - Visual Size %d x %d\\n\", szName, w, h);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t//check if we know this codec from its OTI\n\t\t\t\t\tu32 codec_id = gf_codecid_from_oti(GF_STREAM_VISUAL, esd->decoderConfig->objectTypeIndication);\n\t\t\t\t\tif (codec_id) {\n\t\t\t\t\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\t\t\t\t\tfprintf(stderr, \"%s - Visual Size %d x %d\\n\", gf_codecid_name(codec_id), w, h);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!w || !h) {\n\t\t\t\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\t\t\t\tfprintf(stderr, \"Visual Size %d x %d\\n\", w, h);\n\t\t\t\t}\n\t\t\t\tif (gf_isom_get_rvc_config(file, trackNum, 1, &rvc_predef, NULL, NULL, NULL)==GF_OK) {\n\t\t\t\t\tfprintf(stderr, \"Has RVC signaled - Predefined configuration %d\\n\", rvc_predef);\n\t\t\t\t}\n\n\t\t\t} else if (esd->decoderConfig->streamType==GF_STREAM_AUDIO) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\tGF_M4ADecSpecInfo a_cfg;\n\t\t\t\tGF_Err e;\n\t\t\t\tu32 oti;\n#endif\n\t\t\t\tu32 codec_id;\n\t\t\t\tBool is_mp2 = GF_FALSE;\n\t\t\t\tswitch (esd->decoderConfig->objectTypeIndication) {\n\t\t\t\tcase GF_CODECID_AAC_MPEG2_MP:\n\t\t\t\tcase GF_CODECID_AAC_MPEG2_LCP:\n\t\t\t\tcase GF_CODECID_AAC_MPEG2_SSRP:\n\t\t\t\t\tis_mp2 = GF_TRUE;\n\t\t\t\tcase GF_CODECID_AAC_MPEG4:\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\tif (!esd->decoderConfig->decoderSpecificInfo)\n\t\t\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t\telse\n\t\t\t\t\t\te = gf_m4a_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &a_cfg);\n\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Corrupted AAC Config\\n\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchar *signaling = \"implicit\";\n\t\t\t\t\t\tchar *heaac = \"\";\n\t\t\t\t\t\tif (!is_mp2 && a_cfg.has_sbr) {\n\t\t\t\t\t\t\tif (a_cfg.has_ps) heaac = \"(HE-AAC v2) \";\n\t\t\t\t\t\t\telse heaac = \"(HE-AAC v1) \";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (a_cfg.base_object_type==2) {\n\t\t\t\t\t\t\tif (a_cfg.has_ps || a_cfg.has_sbr)\n\t\t\t\t\t\t\t\tsignaling = \"backward compatible\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsignaling = \"hierarchical\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfprintf(stderr, \"%s (AOT=%d %s) %s- %d Channel(s) - SampleRate %d\", gf_m4a_object_type_name(a_cfg.base_object_type), a_cfg.base_object_type, signaling, heaac, a_cfg.nb_chan, a_cfg.base_sr);\n\t\t\t\t\t\tif (is_mp2) fprintf(stderr, \" (MPEG-2 Signaling)\");\n\t\t\t\t\t\tif (a_cfg.has_sbr) fprintf(stderr, \" - SBR: SampleRate %d Type %s\", a_cfg.sbr_sr, gf_m4a_object_type_name(a_cfg.sbr_object_type));\n\t\t\t\t\t\tif (a_cfg.has_ps) fprintf(stderr, \" - PS\");\n\t\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t\t}\n#else\n\t\t\t\t\tfprintf(stderr, \"MPEG-2/4 Audio - %d Channels - SampleRate %d\\n\", nb_ch, sr);\n#endif\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_CODECID_MPEG2_PART3:\n\t\t\t\tcase GF_CODECID_MPEG_AUDIO:\n\t\t\t\t\tif (msub_type == GF_ISOM_SUBTYPE_MPEG4_CRYP) {\n\t\t\t\t\t\tfprintf(stderr, \"MPEG-1/2 Audio - %d Channels - SampleRate %d\\n\", nb_ch, sr);\n\t\t\t\t\t} else {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\t\tGF_ISOSample *samp = gf_isom_get_sample(file, trackNum, 1, &oti);\n\t\t\t\t\t\tif (samp) {\n\t\t\t\t\t\t\tu32 mhdr = GF_4CC((u8)samp->data[0], (u8)samp->data[1], (u8)samp->data[2], (u8)samp->data[3]);\n\t\t\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\t\t\t\t\t\tfprintf(stderr, \"%s Audio - %d Channel(s) - SampleRate %d - Layer %d\\n\",\n\t\t\t\t\t\t\t        gf_mp3_version_name(mhdr),\n\t\t\t\t\t\t\t        gf_mp3_num_channels(mhdr),\n\t\t\t\t\t\t\t        gf_mp3_sampling_rate(mhdr),\n\t\t\t\t\t\t\t        gf_mp3_layer(mhdr)\n\t\t\t\t\t\t\t       );\n\t\t\t\t\t\t\tgf_isom_sample_del(&samp);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error fetching sample: %s\\n\", gf_error_to_string(gf_isom_last_error(file)) ));\n\t\t\t\t\t\t}\n#else\n\t\t\t\t\t\tfprintf(stderr, \"MPEG-1/2 Audio - %d Channels - SampleRate %d\\n\", nb_ch, sr);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_CODECID_EVRC:\n\t\t\t\t\tfprintf(stderr, \"EVRC Audio - Sample Rate 8000 - 1 channel\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_CODECID_SMV:\n\t\t\t\t\tfprintf(stderr, \"SMV Audio - Sample Rate 8000 - 1 channel\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_CODECID_QCELP:\n\t\t\t\t\tfprintf(stderr, \"QCELP Audio - Sample Rate 8000 - 1 channel\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t/*packetVideo hack for EVRC...*/\n\t\t\t\tcase GF_CODECID_EVRC_PV:\n\t\t\t\t\tif (esd->decoderConfig->decoderSpecificInfo && (esd->decoderConfig->decoderSpecificInfo->dataLength==8)\n\t\t\t\t\t        && !strnicmp((char *)esd->decoderConfig->decoderSpecificInfo->data, \"pvmm\", 4)) {\n\t\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\t\t\t\t\tfprintf(stderr, \"EVRC Audio (PacketVideo Mux) - Sample Rate 8000 - 1 channel\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tcodec_id = gf_codecid_from_oti(GF_STREAM_AUDIO, esd->decoderConfig->objectTypeIndication);\n\t\t\t\t\tif (codec_id) {\n\t\t\t\t\t\tfprintf(stderr, \"%s - Sample Rate %d - %d channel(s)\\n\", gf_codecid_name(codec_id), sr, nb_ch);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (esd->decoderConfig->streamType==GF_STREAM_SCENE) {\n\t\t\t\tif (esd->decoderConfig->objectTypeIndication<=4) {\n\t\t\t\t\tGF_BIFSConfig *b_cfg = gf_odf_get_bifs_config(esd->decoderConfig->decoderSpecificInfo, esd->decoderConfig->objectTypeIndication);\n\t\t\t\t\tfprintf(stderr, \"BIFS Scene description - %s stream\\n\", b_cfg->elementaryMasks ? \"Animation\" : \"Command\");\n\t\t\t\t\tif (full_dump && !b_cfg->elementaryMasks) {\n\t\t\t\t\t\tfprintf(stderr, \"\\tWidth %d Height %d Pixel Metrics %s\\n\", b_cfg->pixelWidth, b_cfg->pixelHeight, b_cfg->pixelMetrics ? \"yes\" : \"no\");\n\t\t\t\t\t}\n\t\t\t\t\tgf_odf_desc_del((GF_Descriptor *)b_cfg);\n\t\t\t\t} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_AFX) {\n\t\t\t\t\tu8 tag = esd->decoderConfig->decoderSpecificInfo ? esd->decoderConfig->decoderSpecificInfo->data[0] : 0xFF;\n\t\t\t\t\tconst char *afxtype = gf_stream_type_afx_name(tag);\n\t\t\t\t\tfprintf(stderr, \"AFX Stream - type %s (%d)\\n\", afxtype, tag);\n\t\t\t\t} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_FONT) {\n\t\t\t\t\tfprintf(stderr, \"Font Data stream\\n\");\n\t\t\t\t} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_LASER) {\n\t\t\t\t\tGF_LASERConfig l_cfg;\n\t\t\t\t\tgf_odf_get_laser_config(esd->decoderConfig->decoderSpecificInfo, &l_cfg);\n\t\t\t\t\tfprintf(stderr, \"LASER Stream - %s\\n\", l_cfg.newSceneIndicator ? \"Full Scene\" : \"Scene Segment\");\n\t\t\t\t} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_TEXT_MPEG4) {\n\t\t\t\t\tfprintf(stderr, \"MPEG-4 Streaming Text stream\\n\");\n\t\t\t\t} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_SYNTHESIZED_TEXTURE) {\n\t\t\t\t\tfprintf(stderr, \"Synthetized Texture stream stream\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tM4_LOG(GF_LOG_WARNING, (\"Unknown Systems stream OTI %d\\n\", esd->decoderConfig->objectTypeIndication));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*sync is only valid if we open all tracks to take care of default MP4 sync..*/\n\t\t\tif (!full_dump) {\n\t\t\t\tif (dump_m4sys) {\n\t\t\t\t\tif (!esd->OCRESID || (esd->OCRESID == esd->ESID))\n\t\t\t\t\t\tfprintf(stderr, \"Self-synchronized\\n\");\n\t\t\t\t\telse\n\t\t\t\t\t\tfprintf(stderr, \"Synchronized on stream %d\\n\", esd->OCRESID);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"\\tDecoding Buffer size %d - Bitrate: avg %d - max %d kbps\\n\", esd->decoderConfig->bufferSizeDB, esd->decoderConfig->avgBitrate/1000, esd->decoderConfig->maxBitrate/1000);\n\t\t\t\tif (esd->dependsOnESID)\n\t\t\t\t\tfprintf(stderr, \"\\tDepends on stream %d for decoding\\n\", esd->dependsOnESID);\n\t\t\t\telse\n\t\t\t\t\tfprintf(stderr, \"\\tNo stream dependencies for decoding\\n\");\n\n\t\t\t\tfprintf(stderr, \"\\tStreamPriority %d\\n\", esd->streamPriority);\n\t\t\t\tif (esd->URLString) fprintf(stderr, \"\\tRemote Data Source %s\\n\", esd->URLString);\n\t\t\t}\n\t\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\t\t}\n\t} else if (msub_type == GF_ISOM_SUBTYPE_AV01) {\n\t\tGF_AV1Config *av1c;\n\t\tu32 w, h;\n\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\tfprintf(stderr, \"\\tAOM AV1 stream - Resolution %d x %d\\n\", w, h);\n\n\t\tav1c = gf_isom_av1_config_get(file, trackNum, 1);\n\t\tfprintf(stderr, \"\\tversion=%u, profile=%u, level_idx0=%u, tier=%u\\n\", (u32)av1c->version, (u32)av1c->seq_profile, (u32)av1c->seq_level_idx_0, (u32)av1c->seq_tier_0);\n\t\tfprintf(stderr, \"\\thigh_bitdepth=%u, twelve_bit=%u, monochrome=%u\\n\", (u32)av1c->high_bitdepth, (u32)av1c->twelve_bit, (u32)av1c->monochrome);\n\t\tfprintf(stderr, \"\\tchroma: subsampling_x=%u, subsampling_y=%u, sample_position=%u\\n\", (u32)av1c->chroma_subsampling_x, (u32)av1c->chroma_subsampling_y, (u32)av1c->chroma_sample_position);\n\n\t\tif (av1c->initial_presentation_delay_present)\n\t\t\tfprintf(stderr, \"\\tInitial presentation delay %u\\n\", (u32) av1c->initial_presentation_delay_minus_one+1);\n\n\t\tcount = gf_list_count(av1c->obu_array);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tu8 hash[20];\n\t\t\tGF_AV1_OBUArrayEntry *obu = gf_list_get(av1c->obu_array, i);\n\t\t\tgf_sha1_csum((u8*)obu->obu, (u32)obu->obu_length, hash);\n\t\t\tfprintf(stderr, \"\\tOBU#%d %s hash: \", i+1, gf_av1_get_obu_name(obu->obu_type) );\n\t\t\tfor (j=0; j<20; j++) fprintf(stderr, \"%02X\", hash[j]);\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t}\n\t\tgf_odf_av1_cfg_del(av1c);\n\t} else if (msub_type == GF_ISOM_SUBTYPE_3GP_H263) {\n\t\tu32 w, h;\n\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\tfprintf(stderr, \"\\t3GPP H263 stream - Resolution %d x %d\\n\", w, h);\n\t} else if (msub_type == GF_ISOM_SUBTYPE_MJP2) {\n\t\tu32 w, h;\n\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\tfprintf(stderr, \"\\tMotionJPEG2000 stream - Resolution %d x %d\\n\", w, h);\n\t} else if ((msub_type == GF_ISOM_SUBTYPE_3GP_AMR) || (msub_type == GF_ISOM_SUBTYPE_3GP_AMR_WB)) {\n\t\tfprintf(stderr, \"\\t3GPP AMR%s stream - Sample Rate %d - %d channel(s) %d bps\\n\", (msub_type == GF_ISOM_SUBTYPE_3GP_AMR_WB) ? \" Wide Band\" : \"\", sr, nb_ch, (u32) bps);\n\t} else if (msub_type == GF_ISOM_SUBTYPE_3GP_EVRC) {\n\t\tfprintf(stderr, \"\\t3GPP EVRC stream - Sample Rate %d - %d channel(s) %d bps\\n\", sr, nb_ch, (u32) bps);\n\t} else if (msub_type == GF_ISOM_SUBTYPE_3GP_QCELP) {\n\t\tfprintf(stderr, \"\\t3GPP QCELP stream - Sample Rate %d - %d channel(s) %d bps\\n\", sr, nb_ch, (u32) bps);\n\t} else if (msub_type == GF_ISOM_SUBTYPE_MP3) {\n\t\tfprintf(stderr, \"\\tMPEG 1/2 Audio stream - Sample Rate %d - %d channel(s) %d bps\\n\", sr, nb_ch, (u32) bps);\n\t} else if ((msub_type == GF_ISOM_SUBTYPE_AC3) || (msub_type == GF_ISOM_SUBTYPE_EC3)) {\n\t\tu32 br = 0;\n\t\tconst char *lfe = \"\";\n\t\tBool is_ec3 = (msub_type == GF_ISOM_SUBTYPE_EC3) ? GF_TRUE : GF_FALSE;\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tGF_AC3Config *ac3 = gf_isom_ac3_config_get(file, trackNum, 1);\n\t\tif (ac3) {\n\t\t\tnb_ch = gf_ac3_get_channels(ac3->streams[0].acmod);\n\t\t\tfor (i=0; i<ac3->streams[0].nb_dep_sub; ++i) {\n\t\t\t\tassert(ac3->streams[0].nb_dep_sub == 1);\n\t\t\t\tnb_ch += gf_ac3_get_channels(ac3->streams[0].chan_loc);\n\t\t\t}\n\t\t\tif (ac3->streams[0].lfon) lfe = \".1\";\n\t\t\tbr = ac3->is_ec3 ? ac3->brcode : gf_ac3_get_bitrate(ac3->brcode);\n\t\t\tis_ec3 = ac3->is_ec3;\n\t\t\tgf_free(ac3);\n\t\t}\n#endif\n\t\tfprintf(stderr, \"\\t%s stream - Sample Rate %d - %d%s channel(s) - bitrate %d\\n\", is_ec3 ? \"EC-3\" : \"AC-3\", sr, nb_ch, lfe, br);\n\t} else if (msub_type == GF_ISOM_SUBTYPE_3GP_SMV) {\n\t\tfprintf(stderr, \"\\t3GPP SMV stream - Sample Rate %d - %d channel(s) %d bits per samples\\n\", sr, nb_ch, (u32) bps);\n\t} else if (msub_type == GF_ISOM_SUBTYPE_3GP_DIMS) {\n\t\tu32 w, h;\n\t\tGF_DIMSDescription dims;\n\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\n\t\tgf_isom_get_dims_description(file, trackNum, 1, &dims);\n\t\tfprintf(stderr, \"\\t3GPP DIMS stream - size %d x %d - Profile %d - Level %d\\n\", w, h, dims.profile, dims.level);\n\t\tfprintf(stderr, \"\\tpathComponents: %d - useFullRequestHost: %s\\n\", dims.pathComponents, dims.fullRequestHost ? \"yes\" : \"no\");\n\t\tfprintf(stderr, \"\\tstream type: %s - redundant: %s\\n\", dims.streamType ? \"primary\" : \"secondary\", (dims.containsRedundant==1) ? \"main\" : ((dims.containsRedundant==2) ? \"redundant\" : \"main+redundant\") );\n\t\tif (dims.textEncoding[0]) fprintf(stderr, \"\\ttext encoding %s\\n\", dims.textEncoding);\n\t\tif (dims.contentEncoding[0]) fprintf(stderr, \"\\tcontent encoding %s\\n\", dims.contentEncoding);\n\t\tif (dims.content_script_types) fprintf(stderr, \"\\tscript languages %s\\n\", dims.content_script_types);\n\t} else if (mtype==GF_ISOM_MEDIA_HINT) {\n\t\tu32 refTrack;\n\t\ts32 refCount = gf_isom_get_reference_count(file, trackNum, GF_ISOM_REF_HINT);\n\t\tif (refCount>0) {\n\t\t\tfprintf(stderr, \"Streaming Hint Track for track%s \", (refCount>1) ? \"s\" :\"\");\n\t\t\tfor (i=0; i<(u32) refCount; i++) {\n\t\t\t\tgf_isom_get_reference(file, trackNum, GF_ISOM_REF_HINT, i+1, &refTrack);\n\t\t\t\tif (i) fprintf(stderr, \" - \");\n\t\t\t\tfprintf(stderr, \"ID %d\", gf_isom_get_track_id(file, refTrack));\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t} else {\n\t\t\tfprintf(stderr, \"Streaming Hint Track (no refs)\\n\");\n\t\t}\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\t\trefCount = gf_isom_get_payt_count(file, trackNum);\n\t\tif (refCount>0) {\n\t\t\tfor (i=0; i<(u32) refCount; i++) {\n\t\t\t\tconst char *name = gf_isom_get_payt_info(file, trackNum, i+1, &refTrack);\n\t\t\t\tfprintf(stderr, \"\\tPayload ID %d: type %s\\n\", refTrack, name);\n\t\t\t}\n\t\t}\n#endif\n\t} else if (mtype==GF_ISOM_MEDIA_FLASH) {\n\t\tfprintf(stderr, \"Macromedia Flash Movie\\n\");\n\t} else if ((mtype==GF_ISOM_MEDIA_TEXT) || (mtype==GF_ISOM_MEDIA_SUBT) || (mtype==GF_ISOM_MEDIA_MPEG_SUBT)) {\n\t\tu32 w, h;\n\t\ts16 l;\n\t\ts32 tx, ty;\n\t\tconst char *content_encoding = NULL;\n\t\tconst char *mime = NULL;\n\t\tconst char *config  = NULL;\n\t\tconst char *_namespace = NULL;\n\t\tconst char *schema_loc = NULL;\n\t\tconst char *auxiliary_mimes = NULL;\n\t\tgf_isom_get_track_layout_info(file, trackNum, &w, &h, &tx, &ty, &l);\n\t\tif (msub_type == GF_ISOM_SUBTYPE_SBTT) {\n\t\t\tgf_isom_stxt_get_description(file, trackNum, 1, &mime, &content_encoding, &config);\n\t\t\tfprintf(stderr, \"Textual Subtitle Stream \");\n\t\t\tfprintf(stderr, \"- mime %s\", mime);\n\t\t\tif (content_encoding != NULL) {\n\t\t\t\tfprintf(stderr, \" - encoding %s\", content_encoding);\n\t\t\t}\n\t\t\tif (config != NULL) {\n\t\t\t\tfprintf(stderr, \" - %d bytes config\", (u32) strlen(config));\n\t\t\t}\n\t\t} else if (msub_type == GF_ISOM_SUBTYPE_STXT) {\n\t\t\tgf_isom_stxt_get_description(file, trackNum, 1, &mime, &content_encoding, &config);\n\t\t\tfprintf(stderr, \"Simple Timed Text Stream \");\n\t\t\tfprintf(stderr, \"- mime %s\", mime);\n\t\t\tif (content_encoding != NULL) {\n\t\t\t\tfprintf(stderr, \" - encoding %s\", content_encoding);\n\t\t\t}\n\t\t\tif (config != NULL) {\n\t\t\t\tfprintf(stderr, \" - %d bytes config\", (u32) strlen(config));\n\t\t\t}\n\t\t} else if (msub_type == GF_ISOM_SUBTYPE_STPP) {\n\t\t\tgf_isom_xml_subtitle_get_description(file, trackNum, 1, &_namespace, &schema_loc, &auxiliary_mimes);\n\t\t\tfprintf(stderr, \"XML Subtitle Stream \");\n\t\t\tfprintf(stderr, \"- namespace %s\", _namespace);\n\t\t\tif (schema_loc != NULL) {\n\t\t\t\tfprintf(stderr, \" - schema-location %s\", schema_loc);\n\t\t\t}\n\t\t\tif (auxiliary_mimes != NULL) {\n\t\t\t\tfprintf(stderr, \" - auxiliary-mime-types %s\", auxiliary_mimes);\n\t\t\t}\n\t\t} else {\n\t\t\tfprintf(stderr, \"Unknown Text Stream\");\n\t\t}\n\t\tfprintf(stderr, \"\\n Size %d x %d - Translation X=%d Y=%d - Layer %d\\n\", w, h, tx, ty, l);\n\t} else if (mtype == GF_ISOM_MEDIA_META) {\n\t\tconst char *content_encoding = NULL;\n\t\tif (msub_type == GF_ISOM_SUBTYPE_METT) {\n\t\t\tconst char *mime = NULL;\n\t\t\tconst char *config  = NULL;\n\t\t\tgf_isom_stxt_get_description(file, trackNum, 1, &mime, &content_encoding, &config);\n\t\t\tfprintf(stderr, \"Textual Metadata Stream - mime %s\", mime);\n\t\t\tif (content_encoding != NULL) {\n\t\t\t\tfprintf(stderr, \" - encoding %s\", content_encoding);\n\t\t\t}\n\t\t\tif (config != NULL) {\n\t\t\t\tfprintf(stderr, \" - %d bytes config\", (u32) strlen(config));\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t} else if (msub_type == GF_ISOM_SUBTYPE_METX) {\n\t\t\tconst char *_namespace = NULL;\n\t\t\tconst char *schema_loc = NULL;\n\t\t\tgf_isom_get_xml_metadata_description(file, trackNum, 1, &_namespace, &schema_loc, &content_encoding);\n\t\t\tfprintf(stderr, \"XML Metadata Stream - namespace %s\", _namespace);\n\t\t\tif (content_encoding != NULL) {\n\t\t\t\tfprintf(stderr, \" - encoding %s\", content_encoding);\n\t\t\t}\n\t\t\tif (schema_loc != NULL) {\n\t\t\t\tfprintf(stderr, \" - schema-location %s\", schema_loc);\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t} else {\n\t\t\tfprintf(stderr, \"Unknown Metadata Stream\\n\");\n\t\t}\n\t} else if ((msub_type==GF_ISOM_SUBTYPE_VVC1) || (msub_type==GF_ISOM_SUBTYPE_VVI1)) {\n\t\tGF_VVCConfig *vvccfg;\n\t\tu32 w, h;\n#if !defined(GPAC_DISABLE_AV_PARSERS)\n\t\tVVCState *vvc_state;\n\t\tGF_SAFEALLOC(vvc_state, VVCState);\n\t\tif (vvc_state) vvc_state->sps_active_idx = -1;\n#endif\n\n\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\tfprintf(stderr, \"VVC Video - Visual Size %d x %d\\n\", w, h);\n\t\tvvccfg = gf_isom_vvc_config_get(file, trackNum, 1);\n\n\t\tif (!vvccfg) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Non-compliant VVC track: No vvcC found in sample description\\n\"));\n\t\t} else {\n\t\t\tdump_vvc_track_info(file, trackNum, vvccfg\n#if !defined(GPAC_DISABLE_AV_PARSERS)\n\t\t\t\t, vvc_state\n#endif\n\t\t\t);\n\t\t\tgf_odf_vvc_cfg_del(vvccfg);\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t}\n#if !defined(GPAC_DISABLE_AV_PARSERS)\n\t\tif (vvc_state) gf_free(vvc_state);\n#endif\n\t} else if ((msub_type == GF_ISOM_SUBTYPE_MH3D_MHA1) || (msub_type == GF_ISOM_SUBTYPE_MH3D_MHA2)\n\t\t\t|| (msub_type == GF_ISOM_SUBTYPE_MH3D_MHM1) || (msub_type == GF_ISOM_SUBTYPE_MH3D_MHM2)\n\t) {\n\t\tconst u8 *compat_profiles;\n\t\tu32 nb_compat_profiles;\n\t\tBool valid = GF_FALSE;\n\t\tBool allow_inband = GF_FALSE;\n\t\tif ( (msub_type == GF_ISOM_SUBTYPE_MH3D_MHM1) || (msub_type == GF_ISOM_SUBTYPE_MH3D_MHM2))\n\t\t\tallow_inband = GF_TRUE;\n\n\t\tfprintf(stderr, \"\\tMPEG-H Audio stream - Sample Rate %d\\n\", sr);\n\n\t\tesd = gf_media_map_esd(file, trackNum, 1);\n\t\tif (!esd || !esd->decoderConfig || !esd->decoderConfig->decoderSpecificInfo\n\t\t\t|| !esd->decoderConfig->decoderSpecificInfo->data\n\t\t) {\n\t\t\tif (allow_inband) {\n\t\t\t\tGF_ISOSample *samp = gf_isom_get_sample(file, trackNum, 1, NULL);\n\t\t\t\tif (samp) {\n\t\t\t\t\tu64 ch_layout=0;\n\t\t\t\t\ts32 PL = gf_mpegh_get_mhas_pl(samp->data, samp->dataLength, &ch_layout);\n\t\t\t\t\tif (PL>=0) {\n\t\t\t\t\t\tfprintf(stderr, \"\\tProfileLevelIndication: 0x%02X\", PL);\n\t\t\t\t\t\tif (ch_layout)\n\t\t\t\t\t\t\tfprintf(stderr, \" - Reference Channel Layout %s\", gf_audio_fmt_get_layout_name(ch_layout) );\n\t\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tgf_isom_sample_del(&samp);\n\t\t\t\t}\n\t\t\t\tvalid = GF_TRUE;\n\t\t\t}\n\t\t} else if (esd->decoderConfig->decoderSpecificInfo->dataLength>=5) {\n\t\t\tfprintf(stderr, \"\\tProfileLevelIndication: 0x%02X - Reference Channel Layout %s\\n\", esd->decoderConfig->decoderSpecificInfo->data[1]\n\t\t\t\t, gf_audio_fmt_get_layout_name_from_cicp(esd->decoderConfig->decoderSpecificInfo->data[2])\n\t\t\t);\n\t\t\tvalid = GF_TRUE;\n\t\t}\n\t\tif (!valid) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Invalid MPEG-H audio config\\n\"));\n\t\t}\n\t\tif (esd) gf_odf_desc_del((GF_Descriptor *)esd);\n\t\tcompat_profiles = gf_isom_get_mpegh_compatible_profiles(file, trackNum, 1, &nb_compat_profiles);\n\t\tfor (i=0; i<nb_compat_profiles; i++) {\n\t\t\tif (!i)\n\t\t\t\tfprintf(stderr, \"\\tCompatible profiles:\");\n\t\t\tfprintf(stderr, \" 0x%02X\", compat_profiles[i]);\n\t\t}\n\t\tif (i) fprintf(stderr, \"\\n\");\n\t} else if (msub_type==GF_ISOM_SUBTYPE_MLPA) {\n\t\tu32 fmt, prate;\n\t\tif (gf_isom_truehd_config_get(file, trackNum, 1, &fmt, &prate) != GF_OK) {\n\t\t\tfprintf(stderr, \"\\tInvalid TrueHD audio config\\n\");\n\t\t}\n\t\tfprintf(stderr, \"TrueHD Audio stream - Sample Rate %u - channels %u - format %u peak rate %u\\n\", sr, nb_ch, fmt, prate);\n\t} else if (codecid) {\n\t\tif (gf_isom_is_video_handler_type(mtype) ) {\n\t\t\tu32 w, h;\n\t\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\t\tfprintf(stderr, \"%s - Resolution %d x %d\\n\", gf_codecid_name(codecid), w, h);\n\t\t} else if (mtype==GF_ISOM_MEDIA_AUDIO) {\n\t\t\tgf_isom_get_audio_info(file, trackNum, 1, &sr, &nb_ch, NULL);\n\t\t\tfprintf(stderr, \"%s - Sample Rate %d - %d channel(s)\\n\", gf_codecid_name(codecid), sr, nb_ch);\n\t\t} else {\n\t\t\tfprintf(stderr, \"%s\\n\", gf_codecid_name(codecid) );\n\t\t}\n\t} else if (pfmt) {\n\t\tu32 w, h;\n\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\tfprintf(stderr, \"Raw video %s - Resolution %d x %d\\n\", gf_pixel_fmt_name(pfmt), w, h);\n\t} else if (msub_type==GF_QT_SUBTYPE_TMCD) {\n\t\tu32 stsd_idx;\n\t\tGF_ISOSample *sample = gf_isom_get_sample(file, trackNum, 1, &stsd_idx);\n\t\tfprintf(stderr, \"Time Code stream\\n\");\n\t\tif (sample) {\n\t\t\tchar szTimecode[100];\n\t\t\tu32 tmcd_flags, tmcd_num, tmcd_den, tmcd_fpt;\n\n\t\t\tgf_isom_get_tmcd_config(file, trackNum, stsd_idx, &tmcd_flags, &tmcd_num, &tmcd_den, &tmcd_fpt);\n\n\t\t\tgf_inspect_format_timecode(sample->data, sample->dataLength, tmcd_flags, tmcd_num, tmcd_den, tmcd_fpt, szTimecode);\n\n\t\t\tgf_isom_sample_del(&sample);\n\t\t\tfprintf(stderr, \"\\tFirst timecode: %s\\n\", szTimecode);\n\t\t}\n\t} else {\n\t\tGF_GenericSampleDescription *udesc;\n\n\t\tudesc = gf_isom_get_generic_sample_description(file, trackNum, 1);\n\t\tif (udesc) {\n\t\t\tif (gf_isom_is_video_handler_type(mtype) ) {\n                fprintf(stderr, \"%s - Compressor \\\"%s\\\" - Resolution %d x %d\\n\",\n\t\t\t\t\t\t( (mtype == GF_ISOM_MEDIA_VISUAL ? \"Visual\" : \"Auxiliary Video\") ),\n                        udesc->compressor_name, udesc->width, udesc->height);\n\t\t\t} else if (mtype==GF_ISOM_MEDIA_AUDIO) {\n\t\t\t\tfprintf(stderr, \"Audio - Sample Rate %d - %d channel(s)\\n\", udesc->samplerate, udesc->nb_channels);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"Unknown media type\\n\");\n\t\t\t}\n\t\t\tif (udesc->vendor_code)\n\t\t\t\tfprintf(stderr, \"\\tVendor code \\\"%s\\\" - Version %d - revision %d\\n\", gf_4cc_to_str(udesc->vendor_code), udesc->version, udesc->revision);\n\n\t\t\tif (udesc->extension_buf) {\n\t\t\t\tfprintf(stderr, \"\\tCodec configuration data size: %d bytes\\n\", udesc->extension_buf_size);\n\t\t\t\tgf_free(udesc->extension_buf);\n\t\t\t}\n\t\t\tgf_free(udesc);\n\t\t} else {\n\t\t\tfprintf(stderr, \"Unknown track type\\n\");\n\t\t}\n\t}\n\n\n\t/*Crypto info*/\n\tif (gf_isom_is_track_encrypted(file, trackNum)) {\n\t\tconst char *scheme_URI, *KMS_URI;\n\t\tu32 scheme_type, version;\n\t\tu32 IV_size;\n\t\tBool use_sel_enc;\n\n\t\tif (gf_isom_is_ismacryp_media(file, trackNum, 1)) {\n\t\t\tgf_isom_get_ismacryp_info(file, trackNum, 1, NULL, &scheme_type, &version, &scheme_URI, &KMS_URI, &use_sel_enc, &IV_size, NULL);\n\t\t\tfprintf(stderr, \"\\n\\tProtected by ISMA E&A scheme %s (version %d)\\n\", gf_4cc_to_str(scheme_type), version);\n\t\t\tif (scheme_URI) fprintf(stderr, \"scheme location: %s\\n\", scheme_URI);\n\t\t\tif (KMS_URI) {\n\t\t\t\tif (!strnicmp(KMS_URI, \"(key)\", 5)) fprintf(stderr, \"\\tKMS location: key in file\\n\");\n\t\t\t\telse fprintf(stderr, \"\\tKMS location: %s\\n\", KMS_URI);\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\tSelective Encryption: %s\\n\", use_sel_enc ? \"Yes\" : \"No\");\n\t\t\tif (IV_size) fprintf(stderr, \"\\tInitialization Vector size: %d bits\\n\", IV_size*8);\n\t\t} else if (gf_isom_is_omadrm_media(file, trackNum, 1)) {\n\t\t\tconst char *textHdrs;\n\t\t\tu32 enc_type, hdr_len;\n\t\t\tu64 orig_len;\n\t\t\tgf_isom_get_omadrm_info(file, trackNum, 1, NULL, &scheme_type, &version, &scheme_URI, &KMS_URI, &textHdrs, &hdr_len, &orig_len, &enc_type, &use_sel_enc, &IV_size, NULL);\n\t\t\tfprintf(stderr, \"\\n\\tProtected by OMA DRM scheme %s (version %d)\\n\", gf_4cc_to_str(scheme_type), version);\n\t\t\tfprintf(stderr, \"\\tRights Issuer: %s\\n\", KMS_URI);\n\t\t\tfprintf(stderr, \"\\tContent ID: %s\\n\", scheme_URI);\n\t\t\tif (textHdrs) {\n\t\t\t\tu32 offset;\n\t\t\t\tconst char *start = textHdrs;\n\t\t\t\tfprintf(stderr, \"\\tOMA Textual Headers:\\n\");\n\t\t\t\ti=0;\n\t\t\t\toffset=0;\n\t\t\t\twhile (i<hdr_len) {\n\t\t\t\t\tif (start[i]==0) {\n\t\t\t\t\t\tfprintf(stderr, \"\\t\\t%s\\n\", start+offset);\n\t\t\t\t\t\toffset=i+1;\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\\\tt%s\\n\", start+offset);\n\t\t\t}\n\t\t\tif (orig_len) fprintf(stderr, \"\\tOriginal media size \"LLD\"\\n\", orig_len);\n\t\t\tfprintf(stderr, \"\\tEncryption algorithm %s\\n\", (enc_type==1) ? \"AEA 128 CBC\" : (enc_type ? \"AEA 128 CTR\" : \"None\"));\n\t\t\tfprintf(stderr, \"\\tSelective Encryption: %s\\n\", use_sel_enc ? \"Yes\" : \"No\");\n\t\t\tif (IV_size) fprintf(stderr, \"\\tInitialization Vector size: %d bits\\n\", IV_size*8);\n\t\t} else if(gf_isom_is_cenc_media(file, trackNum, 1)) {\n\t\t\tconst u8 *def_key;\n\t\t\tu32 def_key_size;\n\t\t\tBool IsEncrypted;\n\t\t\tu8 crypt_byte_block, skip_byte_block;\n\t\t\tIV_size = 0;\n\t\t\tgf_isom_get_cenc_info(file, trackNum, 1, NULL, &scheme_type, &version);\n\n\t\t\tgf_isom_cenc_get_default_info(file, trackNum, 1, NULL, &IsEncrypted, &crypt_byte_block, &skip_byte_block, &def_key, &def_key_size);\n\n\t\t\tfprintf(stderr, \"\\n\\tProtected by CENC scheme %s version 0x%08X\", gf_4cc_to_str(scheme_type), version);\n\n\t\t\tif (crypt_byte_block && skip_byte_block)\n\t\t\t\tfprintf(stderr, \" - Pattern %d:%d\", (u32) skip_byte_block, (u32) crypt_byte_block);\n\t\t\tif (def_key && def_key[0])\n\t\t\t\tfprintf(stderr, \" - MultiKey\");\n\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t\tdump_key_info(def_key, def_key_size, IsEncrypted);\n\n\t\t} else if(gf_isom_is_adobe_protection_media(file, trackNum, 1)) {\n\t\t\tgf_isom_get_adobe_protection_info(file, trackNum, 1, NULL, &scheme_type, &version, NULL);\n\t\t\tfprintf(stderr, \"\\nProtected by Adobe scheme %s (version %d)\\n\", gf_4cc_to_str(scheme_type), version);\n\t\t} else {\n\t\t\tfprintf(stderr, \"\\nProtected by unknown scheme %s\\n\", gf_4cc_to_str(gf_isom_is_media_encrypted(file, trackNum, 0) ));\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t}\n\n\tif ( gf_media_get_rfc_6381_codec_name(file, trackNum, szCodec, GF_FALSE, GF_FALSE) == GF_OK) {\n\t\tfprintf(stderr, \"\\tRFC6381 Codec Parameters: %s\\n\", szCodec);\n\t}\n\n\n\tDumpMetaItem(file, 0, trackNum, \"\\tTrack Meta\");\n\n\tgf_isom_get_track_switch_group_count(file, trackNum, &alt_group, &nb_groups);\n\tif (alt_group) {\n\t\tfprintf(stderr, \"Alternate Group ID %d\\n\", alt_group);\n\t\tfor (i=0; i<nb_groups; i++) {\n\t\t\tu32 nb_crit, switchGroupID;\n\t\t\tconst u32 *criterias = gf_isom_get_track_switch_parameter(file, trackNum, i+1, &switchGroupID, &nb_crit);\n\t\t\tif (!nb_crit) {\n\t\t\t\tfprintf(stderr, \"\\tNo criteria in %s group\\n\", switchGroupID ? \"switch\" : \"alternate\");\n\t\t\t} else {\n\t\t\t\tif (switchGroupID) {\n\t\t\t\t\tfprintf(stderr, \"\\tSwitchGroup ID %d criterias: \", switchGroupID);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"\\tAlternate Group criterias: \");\n\t\t\t\t}\n\t\t\t\tfor (j=0; j<nb_crit; j++) {\n\t\t\t\t\tif (j) fprintf(stderr, \" \");\n\t\t\t\t\tfprintf(stderr, \"%s\", gf_4cc_to_str(criterias[j]) );\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch (gf_isom_has_sync_points(file, trackNum)) {\n\tcase 0:\n\t\tfprintf(stderr, \"\\tAll samples are sync\\n\");\n\t\tbreak;\n\tcase 1:\n\t{\n\t\tu32 nb_sync = gf_isom_get_sync_point_count(file, trackNum) - 1;\n\t\tif (! nb_sync) {\n\t\t\tfprintf(stderr, \"\\tOnly one sync sample\\n\");\n\t\t} else {\n\t\t\tfprintf(stderr, \"\\tAverage GOP length: %d samples\\n\", gf_isom_get_sample_count(file, trackNum) / nb_sync);\n\t\t}\n\t}\n\tbreak;\n\tcase 2:\n\t\tfprintf(stderr, \"\\tNo sync sample found\\n\");\n\t\tbreak;\n\t}\n\tfprintf(stderr, \"\\tMax sample duration: %d / %d\\n\", gf_isom_get_max_sample_delta(file, trackNum), timescale);\n\n\tif (!full_dump) {\n\t\tfprintf(stderr, \"\\n\");\n\t\treturn;\n\t}\n\n\tdur = size = 0;\n\tmax_rate = rate = 0;\n\ttime_slice = 0;\n\tts = gf_isom_get_media_timescale(file, trackNum);\n\tcsize = gf_isom_get_constant_sample_size(file, trackNum);\n\tcdur = gf_isom_get_constant_sample_duration(file, trackNum);\n\tcount = gf_isom_get_sample_count(file, trackNum);\n\tif (csize && cdur) {\n\t\tsize = count * csize;\n\t\tdur = cdur * count;\n\t} else {\n\n\t\tfor (j=0; j<count; j++) {\n\t\t\tGF_ISOSample *samp;\n\t\t\tif (is_od_track) {\n\t\t\t\tsamp = gf_isom_get_sample(file, trackNum, j+1, NULL);\n\t\t\t} else {\n\t\t\t\tsamp = gf_isom_get_sample_info(file, trackNum, j+1, NULL, NULL);\n\t\t\t}\n\t\t\tif (!samp) {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Failed to fetch sample %d\\n\", j+1));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdur = samp->DTS+samp->CTS_Offset;\n\t\t\tsize += samp->dataLength;\n\t\t\trate += samp->dataLength;\n\t\t\tif (samp->DTS - time_slice > ts) {\n\t\t\t\tDouble max_tmp = rate * ts / (samp->DTS - time_slice);\n\t\t\t\tif (max_rate < max_tmp )\n\t\t\t\t\tmax_rate = max_tmp;\n\n\t\t\t\trate = 0;\n\t\t\t\ttime_slice = samp->DTS;\n\t\t\t}\n\t\t\tgf_isom_sample_del(&samp);\n\t\t}\n\t}\n\tfprintf(stderr, \"\\nComputed info from media:\\n\");\n\tif (csize && cdur) {\n\t\tfprintf(stderr, \"\\tConstant sample size %d bytes and dur %d / %d\\n\", csize, cdur, ts);\n\t}\n\tscale = 1000.0 / ts;\n\tdur = (u64) (scale * dur);\n\tfprintf(stderr, \"\\tTotal size \"LLU\" bytes - Total samples duration \"LLU\" ms\\n\", size, dur);\n\tif (!dur) {\n\t\tfprintf(stderr, \"\\n\");\n\t\treturn;\n\t}\n\t/*rate in byte, dur is in ms*/\n\trate = 8000.0 * size / dur;\n\n\tif (!max_rate)\n\t\tmax_rate = rate;\n\telse\n\t\tmax_rate *= 8.0;\n\n\tif (rate >= 1500) {\n\t\tfprintf(stderr, \"\\tAverage rate %.2f kbps - Max Rate %.2f kbps\\n\", rate/1000, max_rate/1000);\n\t} else {\n\t\tfprintf(stderr, \"\\tAverage rate %.2f bps - Max Rate %.2f bps\\n\", rate, max_rate);\n\t}\n\n\t{\n\t\tu32 dmin, dmax, davg, smin, smax, savg;\n\t\tgf_isom_get_chunks_infos(file, trackNum, &dmin, &davg, &dmax, &smin, &savg, &smax);\n\t\tfprintf(stderr, \"\\tChunk durations: min %d ms - max %d ms - average %d ms\\n\", (1000*dmin)/ts, (1000*dmax)/ts, (1000*davg)/ts);\n\t\tfprintf(stderr, \"\\tChunk sizes (bytes): min %d - max %d - average %d\\n\", smin, smax, savg);\n\t}\n\tfprintf(stderr, \"\\n\");\n\n\tcount = gf_isom_get_chapter_count(file, trackNum);\n\tif (count) {\n\t\tconst char *name;\n\t\tu64 time;\n\t\tfprintf(stderr, \"\\nChapters:\\n\");\n\t\tfor (j=0; j<count; j++) {\n\t\t\tgf_isom_get_chapter(file, trackNum, j+1, &time, &name);\n\t\t\tfprintf(stderr, \"\\tChapter #%d - %s - \\\"%s\\\"\\n\", j+1, format_duration(time, 1000, szDur), name);\n\t\t}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 2883,
    "critical_vars": [
      "av1c"
    ],
    "function": "DumpTrackInfo",
    "filename": "gpac/CVE-2021-32138/CVE-2021-32138_CWE-476_289ffce3e0d224d314f5f92a744d5fe35999f20b_filedump.c.diff",
    "function_code": "void gf_inspect_format_timecode(const u8 *data, u32 size, u32 tmcd_flags, u32 tc_num, u32 tc_den, u32 tmcd_fpt, char szFmt[100]);\n\nvoid DumpTrackInfo(GF_ISOFile *file, GF_ISOTrackID trackID, Bool full_dump, Bool is_track_num, Bool dump_m4sys)\n{\n\tchar szCodec[RFC6381_CODEC_NAME_SIZE_MAX];\n\tDouble scale, max_rate, rate;\n\tBool is_od_track = 0;\n\tu32 trackNum, i, j, ts, mtype, msub_type, timescale, sr, nb_ch, count, alt_group, nb_groups, nb_edits, cdur, csize, bps, pfmt, codecid;\n\tu64 time_slice, dur, size;\n\ts32 cts_shift;\n\tGF_ESD *esd;\n\tchar szDur[50];\n\tchar *lang;\n\n\tif (!is_track_num) {\n\t\ttrackNum = gf_isom_get_track_by_id(file, trackID);\n\t} else {\n\t\ttrackNum = trackID;\n\t\ttrackID = gf_isom_get_track_id(file, trackNum);\n\t}\n\tif (!trackNum) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"No track with ID %d found\\n\", trackID));\n\t\treturn;\n\t}\n\n\ttimescale = gf_isom_get_media_timescale(file, trackNum);\n\tfprintf(stderr, \"# Track %d Info - ID %d - TimeScale %d\\n\", trackNum, trackID, timescale);\n\n\tdur = gf_isom_get_media_original_duration(file, trackNum);\n\tsize = gf_isom_get_media_duration(file, trackNum);\n\tfprintf(stderr, \"Media Duration %s \", format_duration(dur, timescale, szDur));\n\tif (dur != size)\n\t\tfprintf(stderr, \" (recomputed %s)\", format_duration(size, timescale, szDur));\n\tfprintf(stderr, \"\\n\");\n\n\tif (gf_isom_check_data_reference(file, trackNum, 1) != GF_OK) {\n\t\tM4_LOG(GF_LOG_WARNING, (\"Track uses external data reference not supported by GPAC!\\n\"));\n\t}\n\n\tnb_edits = gf_isom_get_edits_count(file, trackNum);\n\tif (nb_edits)\n\t\tfprintf(stderr, \"Track has %d edits: track duration is %s\\n\", nb_edits, format_duration(gf_isom_get_track_duration(file, trackNum), gf_isom_get_timescale(file), szDur));\n\n\tcts_shift = gf_isom_get_composition_offset_shift(file, trackNum);\n\tif (cts_shift)\n\t\tfprintf(stderr, \"Track composition offset shift (negative CTS offset): %d\\n\", cts_shift);\n\n\tif (gf_isom_is_track_in_root_od(file, trackNum) ) fprintf(stderr, \"Track is present in Root OD\\n\");\n\tif (!gf_isom_is_track_enabled(file, trackNum))  fprintf(stderr, \"Track is disabled\\n\");\n\tgf_isom_get_media_language(file, trackNum, &lang);\n\tfprintf(stderr, \"Media Info: Language \\\"%s (%s)\\\" - \", GetLanguage(lang), lang );\n\tgf_free(lang);\n\tmtype = gf_isom_get_media_type(file, trackNum);\n\tfprintf(stderr, \"Type \\\"%s:\", gf_4cc_to_str(mtype));\n\tmsub_type = gf_isom_get_mpeg4_subtype(file, trackNum, 1);\n\tif (!msub_type) msub_type = gf_isom_get_media_subtype(file, trackNum, 1);\n\tfprintf(stderr, \"%s\\\" - %d samples\\n\", gf_4cc_to_str(msub_type), gf_isom_get_sample_count(file, trackNum));\n\n\tpfmt = gf_pixel_fmt_from_qt_type(msub_type);\n\tcodecid = gf_codec_id_from_isobmf(msub_type);\n\n\tcount = gf_isom_get_track_kind_count(file, trackNum);\n\tfor (i = 0; i < count; i++) {\n\t\tchar *kind_scheme, *kind_value;\n\t\tgf_isom_get_track_kind(file, trackNum, i, &kind_scheme, &kind_value);\n\t\tfprintf(stderr, \"Kind: %s - %s\\n\", kind_scheme ? kind_scheme : \"null\", kind_value ? kind_value : \"null\");\n\t\tif (kind_scheme) gf_free(kind_scheme);\n\t\tif (kind_value) gf_free(kind_value);\n\t}\n\n\tif (gf_isom_is_track_fragmented(file, trackID) ) {\n\t\tu32 defaultDuration, defaultSize, defaultDescriptionIndex, defaultRandomAccess;\n\t\tu8 defaultPadding;\n\t\tu16 defaultDegradationPriority;\n\t\tu32 frag_samples;\n\t\tu64 frag_duration;\n\t\tgf_isom_get_fragmented_samples_info(file, trackID, &frag_samples, &frag_duration);\n\t\tfprintf(stderr, \"Fragmented track: %d samples - Media Duration %s\\n\", frag_samples, format_duration(frag_duration, timescale, szDur));\n\n\t\tgf_isom_get_fragment_defaults(file, trackNum, &defaultDuration, &defaultSize, &defaultDescriptionIndex, &defaultRandomAccess, &defaultPadding, &defaultDegradationPriority);\n\n\t\tfprintf(stderr, \"Fragment sample defaults: duration %d size %d stsd %d sync %d padding %d degradation_priority %d\\n\",\n\t\t\t\tdefaultDuration, defaultSize, defaultDescriptionIndex, defaultRandomAccess,\n\t\t\t\t(u32) defaultPadding, (u32) defaultDegradationPriority\n\t\t);\n\t}\n\n\tif (!gf_isom_is_self_contained(file, trackNum, 1)) {\n\t\tconst char *url, *urn;\n\t\tgf_isom_get_data_reference(file, trackNum, 1, &url, &urn);\n\t\tfprintf(stderr, \"Media Data Location: %s\\n\", url ? url : urn);\n\t}\n\n\tif (full_dump) {\n\t\tconst char *handler_name;\n\t\tgf_isom_get_handler_name(file, trackNum, &handler_name);\n\t\tfprintf(stderr, \"Handler name: %s\\n\", handler_name);\n\t}\n\n\tprint_udta(file, trackNum, GF_FALSE);\n\n\tif (gf_isom_is_video_handler_type(mtype) ) {\n\t\ts32 tx, ty;\n\t\tu32 w, h;\n\t\tu16 bit_depth;\n\n\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\tgf_isom_get_visual_bit_depth(file, trackNum, 1, &bit_depth);\n\t\tfprintf(stderr, \"Visual Sample Entry Info: width=%d height=%d (depth=%d bits)\\n\", w, h, (int)bit_depth);\n\n\t\tgf_isom_get_track_layout_info(file, trackNum, &w, &h, &tx, &ty, NULL);\n\t\tfprintf(stderr, \"Visual Track layout: x=%d y=%d width=%d height=%d\\n\", tx, ty, w, h);\n\t}\n\n\tgf_isom_get_audio_info(file, trackNum, 1, &sr, &nb_ch, &bps);\n\tgf_isom_set_nalu_extract_mode(file, trackNum, GF_ISOM_NALU_EXTRACT_INSPECT);\n\n\tmsub_type = gf_isom_get_media_subtype(file, trackNum, 1);\n\tif (msub_type==GF_ISOM_SUBTYPE_MPEG4_CRYP)\n\t\tgf_isom_get_original_format_type(file, trackNum, 1, &msub_type);\n\n\tif ((msub_type==GF_ISOM_SUBTYPE_MPEG4)\n\t        || (msub_type==GF_ISOM_SUBTYPE_AVC_H264)\n\t        || (msub_type==GF_ISOM_SUBTYPE_AVC2_H264)\n\t        || (msub_type==GF_ISOM_SUBTYPE_AVC3_H264)\n\t        || (msub_type==GF_ISOM_SUBTYPE_AVC4_H264)\n\t        || (msub_type==GF_ISOM_SUBTYPE_SVC_H264)\n\t        || (msub_type==GF_ISOM_SUBTYPE_MVC_H264)\n\t        || (msub_type==GF_ISOM_SUBTYPE_LSR1)\n\t        || (msub_type==GF_ISOM_SUBTYPE_HVC1)\n\t        || (msub_type==GF_ISOM_SUBTYPE_HEV1)\n\t        || (msub_type==GF_ISOM_SUBTYPE_HVC2)\n\t        || (msub_type==GF_ISOM_SUBTYPE_HEV2)\n\t        || (msub_type==GF_ISOM_SUBTYPE_LHV1)\n\t        || (msub_type==GF_ISOM_SUBTYPE_LHE1)\n\t        || (msub_type==GF_ISOM_SUBTYPE_HVT1)\n\t   )  {\n\t\tesd = gf_isom_get_esd(file, trackNum, 1);\n\t\tif (!esd || !esd->decoderConfig) {\n\t\t\tM4_LOG(GF_LOG_WARNING, (\"WARNING: Broken MPEG-4 Track\\n\"));\n\t\t\tif (esd) gf_odf_desc_del((GF_Descriptor *)esd);\n\t\t} else {\n\t\t\tconst char *st = gf_stream_type_name(esd->decoderConfig->streamType);\n\t\t\tif (dump_m4sys) {\n\t\t\t\tif (st) {\n\t\t\t\t\tfprintf(stderr, \"MPEG-4 Config%s%s Stream - ObjectTypeIndication 0x%02x\\n\",\n\t\t\t\t\t\t\tfull_dump ? \"\\n\\t\" : \": \", st, esd->decoderConfig->objectTypeIndication);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"MPEG-4 Config%sStream Type 0x%02x - ObjectTypeIndication 0x%02x\\n\",\n\t\t\t\t\t\t\tfull_dump ? \"\\n\\t\" : \": \", esd->decoderConfig->streamType, esd->decoderConfig->objectTypeIndication);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (esd->decoderConfig->streamType==GF_STREAM_OD)\n\t\t\t\tis_od_track=1;\n\n\t\t\tif (esd->decoderConfig->streamType==GF_STREAM_VISUAL) {\n\t\t\t\tu32 w, h;\n\t\t\t\tu16 rvc_predef;\n\t\t\t\tw = h = 0;\n\t\t\t\tif (esd->decoderConfig->objectTypeIndication==GF_CODECID_MPEG4_PART2) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\tif (!esd->decoderConfig->decoderSpecificInfo) {\n#else\n\t\t\t\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\t\t\t\tfprintf(stderr, \"MPEG-4 Visual Size %d x %d\\n\", w, h);\n#endif\n\t\t\t\t\t\tM4_LOG(GF_LOG_WARNING, (\"Non-compliant MPEG-4 Visual track: video_object_layer infos not found in sample description\\n\"));\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\t} else {\n\t\t\t\t\t\tGF_M4VDecSpecInfo dsi;\n\t\t\t\t\t\tgf_m4v_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &dsi);\n\t\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\t\t\t\t\tw = dsi.width;\n\t\t\t\t\t\th = dsi.height;\n\t\t\t\t\t\tfprintf(stderr, \"MPEG-4 Visual Size %d x %d - %s\\n\", w, h, gf_m4v_get_profile_name(dsi.VideoPL));\n\t\t\t\t\t\tif (dsi.par_den && dsi.par_num) {\n\t\t\t\t\t\t\tu32 tw, th;\n\t\t\t\t\t\t\tgf_isom_get_track_layout_info(file, trackNum, &tw, &th, NULL, NULL, NULL);\n\t\t\t\t\t\t\tfprintf(stderr, \"Pixel Aspect Ratio %d:%d - Indicated track size %d x %d\\n\", dsi.par_num, dsi.par_den, tw, th);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t} else if (gf_isom_get_avc_svc_type(file, trackNum, 1) != GF_ISOM_AVCTYPE_NONE) {\n\t\t\t\t\tGF_AVCConfig *avccfg, *svccfg, *mvccfg;\n\n\t\t\t\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\t\t\t\tfprintf(stderr, \"AVC/H264 Video - Visual Size %d x %d\\n\", w, h);\n\n\t\t\t\t\tavccfg = gf_isom_avc_config_get(file, trackNum, 1);\n\t\t\t\t\tsvccfg = gf_isom_svc_config_get(file, trackNum, 1);\n\t\t\t\t\tmvccfg = gf_isom_mvc_config_get(file, trackNum, 1);\n\t\t\t\t\tif (!avccfg && !svccfg && !mvccfg) {\n\t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"\\tNon-compliant AVC track: SPS/PPS not found in sample description\\n\"));\n\t\t\t\t\t} else if (avccfg) {\n\t\t\t\t\t\tfprintf(stderr, \"\\tAVC Info: %d SPS - %d PPS\", gf_list_count(avccfg->sequenceParameterSets) , gf_list_count(avccfg->pictureParameterSets) );\n\t\t\t\t\t\tfprintf(stderr, \" - Profile %s @ Level %g\\n\", gf_avc_get_profile_name(avccfg->AVCProfileIndication), ((Double)avccfg->AVCLevelIndication)/10.0 );\n\t\t\t\t\t\tfprintf(stderr, \"\\tNAL Unit length bits: %d\\n\", 8*avccfg->nal_unit_size);\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\t\tfor (i=0; i<gf_list_count(avccfg->sequenceParameterSets); i++) {\n\t\t\t\t\t\t\ts32 par_n, par_d;\n\t\t\t\t\t\t\tGF_NALUFFParam *slc = gf_list_get(avccfg->sequenceParameterSets, i);\n\t\t\t\t\t\t\tgf_avc_get_sps_info(slc->data, slc->size, NULL, NULL, NULL, &par_n, &par_d);\n\t\t\t\t\t\t\tif ((par_n>0) && (par_d>0)) {\n\t\t\t\t\t\t\t\tu32 tw, th;\n\t\t\t\t\t\t\t\tgf_isom_get_track_layout_info(file, trackNum, &tw, &th, NULL, NULL, NULL);\n\t\t\t\t\t\t\t\tfprintf(stderr, \"\\tPixel Aspect Ratio %d:%d - Indicated track size %d x %d\\n\", par_n, par_d, tw, th);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!full_dump) break;\n\t\t\t\t\t\t}\n#endif\n\n\t\t\t\t\t\tif (avccfg->chroma_bit_depth) {\n\t\t\t\t\t\t\tfprintf(stderr, \"\\tChroma format %s - Luma bit depth %d - chroma bit depth %d\\n\", gf_avc_hevc_get_chroma_format_name(avccfg->chroma_format), avccfg->luma_bit_depth, avccfg->chroma_bit_depth);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tprint_config_hash(avccfg->sequenceParameterSets, \"SPS\");\n\t\t\t\t\t\tprint_config_hash(avccfg->pictureParameterSets, \"PPS\");\n\n\t\t\t\t\t\tgf_odf_avc_cfg_del(avccfg);\n\t\t\t\t\t}\n\t\t\t\t\tif (svccfg) {\n\t\t\t\t\t\tfprintf(stderr, \"\\n\\tSVC Info: %d SPS - %d PPS - Profile %s @ Level %g\\n\", gf_list_count(svccfg->sequenceParameterSets) , gf_list_count(svccfg->pictureParameterSets), gf_avc_get_profile_name(svccfg->AVCProfileIndication), ((Double)svccfg->AVCLevelIndication)/10.0 );\n\t\t\t\t\t\tfprintf(stderr, \"\\tSVC NAL Unit length bits: %d\\n\", 8*svccfg->nal_unit_size);\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\t\tfor (i=0; i<gf_list_count(svccfg->sequenceParameterSets); i++) {\n\t\t\t\t\t\t\tGF_NALUFFParam *slc = gf_list_get(svccfg->sequenceParameterSets, i);\n\t\t\t\t\t\t\tif (slc) {\n\t\t\t\t\t\t\t\ts32 par_n, par_d;\n\t\t\t\t\t\t\t\tu32 s_w, s_h, sps_id;\n\t\t\t\t\t\t\t\tgf_avc_get_sps_info(slc->data, slc->size, &sps_id, &s_w, &s_h, &par_n, &par_d);\n\t\t\t\t\t\t\t\tfprintf(stderr, \"\\t\\tSPS ID %d - Visual Size %d x %d\\n\", sps_id, s_w, s_h);\n\t\t\t\t\t\t\t\tif ((par_n>0) && (par_d>0)) {\n\t\t\t\t\t\t\t\t\tu32 tw, th;\n\t\t\t\t\t\t\t\t\tgf_isom_get_track_layout_info(file, trackNum, &tw, &th, NULL, NULL, NULL);\n\t\t\t\t\t\t\t\t\tfprintf(stderr, \"\\tPixel Aspect Ratio %d:%d - Indicated track size %d x %d\\n\", par_n, par_d, tw, th);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t\tprint_config_hash(svccfg->sequenceParameterSets, \"SPS\");\n\t\t\t\t\t\tprint_config_hash(svccfg->pictureParameterSets, \"PPS\");\n\t\t\t\t\t\tprint_config_hash(svccfg->sequenceParameterSetExtensions, \"SPSEx\");\n\n\t\t\t\t\t\tgf_odf_avc_cfg_del(svccfg);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (mvccfg) {\n\t\t\t\t\t\tfprintf(stderr, \"\\n\\tMVC Info: %d SPS - %d PPS - Profile %s @ Level %g\\n\", gf_list_count(mvccfg->sequenceParameterSets) , gf_list_count(mvccfg->pictureParameterSets), gf_avc_get_profile_name(mvccfg->AVCProfileIndication), ((Double)mvccfg->AVCLevelIndication)/10.0 );\n\t\t\t\t\t\tfprintf(stderr, \"\\tMVC NAL Unit length bits: %d\\n\", 8*mvccfg->nal_unit_size);\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\t\tfor (i=0; i<gf_list_count(mvccfg->sequenceParameterSets); i++) {\n\t\t\t\t\t\t\tGF_NALUFFParam *slc = gf_list_get(mvccfg->sequenceParameterSets, i);\n\t\t\t\t\t\t\tif (slc) {\n\t\t\t\t\t\t\t\tu32 s_w, s_h, sps_id;\n\t\t\t\t\t\t\t\ts32 par_n, par_d;\n\t\t\t\t\t\t\t\tgf_avc_get_sps_info(slc->data, slc->size, &sps_id, &s_w, &s_h, &par_n, &par_d);\n\t\t\t\t\t\t\t\tfprintf(stderr, \"\\t\\tSPS ID %d - Visual Size %d x %d\\n\", sps_id, s_w, s_h);\n\t\t\t\t\t\t\t\tif ((par_n>0) && (par_d>0)) {\n\t\t\t\t\t\t\t\t\tu32 tw, th;\n\t\t\t\t\t\t\t\t\tgf_isom_get_track_layout_info(file, trackNum, &tw, &th, NULL, NULL, NULL);\n\t\t\t\t\t\t\t\t\tfprintf(stderr, \"\\tPixel Aspect Ratio %d:%d - Indicated track size %d x %d\\n\", par_n, par_d, tw, th);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t\tprint_config_hash(mvccfg->sequenceParameterSets, \"SPS\");\n\t\t\t\t\t\tprint_config_hash(mvccfg->pictureParameterSets, \"PPS\");\n\t\t\t\t\t\tgf_odf_avc_cfg_del(mvccfg);\n\t\t\t\t\t}\n\n\t\t\t\t} else if ((esd->decoderConfig->objectTypeIndication==GF_CODECID_HEVC)\n\t\t\t\t           || (esd->decoderConfig->objectTypeIndication==GF_CODECID_LHVC)\n\t\t\t\t          ) {\n\t\t\t\t\tGF_HEVCConfig *hevccfg, *lhvccfg;\n\t\t\t\t\tGF_OperatingPointsInformation *oinf;\n#if !defined(GPAC_DISABLE_AV_PARSERS) && !defined(GPAC_DISABLE_HEVC)\n\t\t\t\t\tHEVCState hevc_state;\n\t\t\t\t\tmemset(&hevc_state, 0, sizeof(HEVCState));\n\t\t\t\t\thevc_state.sps_active_idx = -1;\n#endif\n\n\t\t\t\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\t\t\t\tfprintf(stderr, \"HEVC Video - Visual Size %d x %d\\n\", w, h);\n\t\t\t\t\thevccfg = gf_isom_hevc_config_get(file, trackNum, 1);\n\t\t\t\t\tlhvccfg = gf_isom_lhvc_config_get(file, trackNum, 1);\n\n\t\t\t\t\tif (msub_type==GF_ISOM_SUBTYPE_HVT1) {\n\t\t\t\t\t\tconst u8 *data;\n\t\t\t\t\t\tu32 tsize;\n\t\t\t\t\t\tu32  is_default, tx,ty,tw,th, id, independent;\n\t\t\t\t\t\tBool full_frame;\n\t\t\t\t\t\tif (gf_isom_get_tile_info(file, trackNum, 1, &is_default, &id, &independent, &full_frame, &tx, &ty, &tw, &th)) {\n\t\t\t\t\t\t\tfprintf(stderr, \"\\tHEVC Tile - ID %d independent %d (x,y,w,h)=%d,%d,%d,%d \\n\", id, independent, tx, ty, tw, th);\n\t\t\t\t\t\t} else if (gf_isom_get_sample_group_info(file, trackNum, 1, GF_ISOM_SAMPLE_GROUP_TRIF, &is_default, &data, &tsize)) {\n\t\t\t\t\t\t\tfprintf(stderr, \"\\tHEVC Tile track containing a tile set\\n\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfprintf(stderr, \"\\tHEVC Tile track without tiling info\\n\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (!hevccfg && !lhvccfg) {\n\t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"\\tNon-compliant HEVC track: No hvcC or shcC found in sample description\\n\"));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (gf_isom_get_reference_count(file, trackNum, GF_ISOM_REF_SABT)) {\n\t\t\t\t\t\tfprintf(stderr, \"\\tHEVC Tile base track\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tif (hevccfg) {\n\t\t\t\t\t\tdump_hevc_track_info(file, trackNum, hevccfg\n#if !defined(GPAC_DISABLE_AV_PARSERS) && !defined(GPAC_DISABLE_HEVC)\n\t\t\t\t\t\t\t, &hevc_state\n#endif\n\t\t\t\t\t\t);\n\t\t\t\t\t\tgf_odf_hevc_cfg_del(hevccfg);\n\t\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tif (lhvccfg) {\n\t\t\t\t\t\tdump_hevc_track_info(file, trackNum, lhvccfg\n#if !defined(GPAC_DISABLE_AV_PARSERS) && !defined(GPAC_DISABLE_HEVC)\n\t\t\t\t\t\t\t, &hevc_state\n#endif\n\t\t\t\t\t\t);\n\t\t\t\t\t\tgf_odf_hevc_cfg_del(lhvccfg);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (gf_isom_get_oinf_info(file, trackNum, &oinf)) {\n\t\t\t\t\t\tfprintf(stderr, \"\\n\\tOperating Points Information -\");\n\t\t\t\t\t\tfprintf(stderr, \" scalability_mask %d (\", oinf->scalability_mask);\n\t\t\t\t\t\tswitch (oinf->scalability_mask) {\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tfprintf(stderr, \"Multiview\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\tfprintf(stderr, \"Spatial scalability\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 8:\n\t\t\t\t\t\t\tfprintf(stderr, \"Auxilary\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tfprintf(stderr, \"unknown\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//TODO: need to dump more info ?\n\t\t\t\t\t\tfprintf(stderr, \") num_profile_tier_level %d \", gf_list_count(oinf->profile_tier_levels) );\n\t\t\t\t\t\tfprintf(stderr, \" num_operating_points %d dependency layers %d \\n\", gf_list_count(oinf->operating_points), gf_list_count(oinf->dependency_layers) );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*OGG media*/\n\t\t\t\telse if (esd->decoderConfig->objectTypeIndication==GF_CODECID_THEORA) {\n\t\t\t\t\tchar *szName;\n\t\t\t\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\t\t\t\tif (!strnicmp((char *) &esd->decoderConfig->decoderSpecificInfo->data[3], \"theora\", 6)) szName = \"Theora\";\n\t\t\t\t\telse szName = \"Unknown\";\n\t\t\t\t\tfprintf(stderr, \"Ogg/%s video / GPAC Mux  - Visual Size %d x %d\\n\", szName, w, h);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t//check if we know this codec from its OTI\n\t\t\t\t\tu32 codec_id = gf_codecid_from_oti(GF_STREAM_VISUAL, esd->decoderConfig->objectTypeIndication);\n\t\t\t\t\tif (codec_id) {\n\t\t\t\t\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\t\t\t\t\tfprintf(stderr, \"%s - Visual Size %d x %d\\n\", gf_codecid_name(codec_id), w, h);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!w || !h) {\n\t\t\t\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\t\t\t\tfprintf(stderr, \"Visual Size %d x %d\\n\", w, h);\n\t\t\t\t}\n\t\t\t\tif (gf_isom_get_rvc_config(file, trackNum, 1, &rvc_predef, NULL, NULL, NULL)==GF_OK) {\n\t\t\t\t\tfprintf(stderr, \"Has RVC signaled - Predefined configuration %d\\n\", rvc_predef);\n\t\t\t\t}\n\n\t\t\t} else if (esd->decoderConfig->streamType==GF_STREAM_AUDIO) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\tGF_M4ADecSpecInfo a_cfg;\n\t\t\t\tGF_Err e;\n\t\t\t\tu32 oti;\n#endif\n\t\t\t\tu32 codec_id;\n\t\t\t\tBool is_mp2 = GF_FALSE;\n\t\t\t\tswitch (esd->decoderConfig->objectTypeIndication) {\n\t\t\t\tcase GF_CODECID_AAC_MPEG2_MP:\n\t\t\t\tcase GF_CODECID_AAC_MPEG2_LCP:\n\t\t\t\tcase GF_CODECID_AAC_MPEG2_SSRP:\n\t\t\t\t\tis_mp2 = GF_TRUE;\n\t\t\t\tcase GF_CODECID_AAC_MPEG4:\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\tif (!esd->decoderConfig->decoderSpecificInfo)\n\t\t\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t\telse\n\t\t\t\t\t\te = gf_m4a_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &a_cfg);\n\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Corrupted AAC Config\\n\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchar *signaling = \"implicit\";\n\t\t\t\t\t\tchar *heaac = \"\";\n\t\t\t\t\t\tif (!is_mp2 && a_cfg.has_sbr) {\n\t\t\t\t\t\t\tif (a_cfg.has_ps) heaac = \"(HE-AAC v2) \";\n\t\t\t\t\t\t\telse heaac = \"(HE-AAC v1) \";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (a_cfg.base_object_type==2) {\n\t\t\t\t\t\t\tif (a_cfg.has_ps || a_cfg.has_sbr)\n\t\t\t\t\t\t\t\tsignaling = \"backward compatible\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsignaling = \"hierarchical\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfprintf(stderr, \"%s (AOT=%d %s) %s- %d Channel(s) - SampleRate %d\", gf_m4a_object_type_name(a_cfg.base_object_type), a_cfg.base_object_type, signaling, heaac, a_cfg.nb_chan, a_cfg.base_sr);\n\t\t\t\t\t\tif (is_mp2) fprintf(stderr, \" (MPEG-2 Signaling)\");\n\t\t\t\t\t\tif (a_cfg.has_sbr) fprintf(stderr, \" - SBR: SampleRate %d Type %s\", a_cfg.sbr_sr, gf_m4a_object_type_name(a_cfg.sbr_object_type));\n\t\t\t\t\t\tif (a_cfg.has_ps) fprintf(stderr, \" - PS\");\n\t\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t\t}\n#else\n\t\t\t\t\tfprintf(stderr, \"MPEG-2/4 Audio - %d Channels - SampleRate %d\\n\", nb_ch, sr);\n#endif\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_CODECID_MPEG2_PART3:\n\t\t\t\tcase GF_CODECID_MPEG_AUDIO:\n\t\t\t\t\tif (msub_type == GF_ISOM_SUBTYPE_MPEG4_CRYP) {\n\t\t\t\t\t\tfprintf(stderr, \"MPEG-1/2 Audio - %d Channels - SampleRate %d\\n\", nb_ch, sr);\n\t\t\t\t\t} else {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\t\tGF_ISOSample *samp = gf_isom_get_sample(file, trackNum, 1, &oti);\n\t\t\t\t\t\tif (samp) {\n\t\t\t\t\t\t\tu32 mhdr = GF_4CC((u8)samp->data[0], (u8)samp->data[1], (u8)samp->data[2], (u8)samp->data[3]);\n\t\t\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\t\t\t\t\t\tfprintf(stderr, \"%s Audio - %d Channel(s) - SampleRate %d - Layer %d\\n\",\n\t\t\t\t\t\t\t        gf_mp3_version_name(mhdr),\n\t\t\t\t\t\t\t        gf_mp3_num_channels(mhdr),\n\t\t\t\t\t\t\t        gf_mp3_sampling_rate(mhdr),\n\t\t\t\t\t\t\t        gf_mp3_layer(mhdr)\n\t\t\t\t\t\t\t       );\n\t\t\t\t\t\t\tgf_isom_sample_del(&samp);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error fetching sample: %s\\n\", gf_error_to_string(gf_isom_last_error(file)) ));\n\t\t\t\t\t\t}\n#else\n\t\t\t\t\t\tfprintf(stderr, \"MPEG-1/2 Audio - %d Channels - SampleRate %d\\n\", nb_ch, sr);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_CODECID_EVRC:\n\t\t\t\t\tfprintf(stderr, \"EVRC Audio - Sample Rate 8000 - 1 channel\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_CODECID_SMV:\n\t\t\t\t\tfprintf(stderr, \"SMV Audio - Sample Rate 8000 - 1 channel\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_CODECID_QCELP:\n\t\t\t\t\tfprintf(stderr, \"QCELP Audio - Sample Rate 8000 - 1 channel\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t/*packetVideo hack for EVRC...*/\n\t\t\t\tcase GF_CODECID_EVRC_PV:\n\t\t\t\t\tif (esd->decoderConfig->decoderSpecificInfo && (esd->decoderConfig->decoderSpecificInfo->dataLength==8)\n\t\t\t\t\t        && !strnicmp((char *)esd->decoderConfig->decoderSpecificInfo->data, \"pvmm\", 4)) {\n\t\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\t\t\t\t\tfprintf(stderr, \"EVRC Audio (PacketVideo Mux) - Sample Rate 8000 - 1 channel\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tcodec_id = gf_codecid_from_oti(GF_STREAM_AUDIO, esd->decoderConfig->objectTypeIndication);\n\t\t\t\t\tif (codec_id) {\n\t\t\t\t\t\tfprintf(stderr, \"%s - Sample Rate %d - %d channel(s)\\n\", gf_codecid_name(codec_id), sr, nb_ch);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (esd->decoderConfig->streamType==GF_STREAM_SCENE) {\n\t\t\t\tif (esd->decoderConfig->objectTypeIndication<=4) {\n\t\t\t\t\tGF_BIFSConfig *b_cfg = gf_odf_get_bifs_config(esd->decoderConfig->decoderSpecificInfo, esd->decoderConfig->objectTypeIndication);\n\t\t\t\t\tfprintf(stderr, \"BIFS Scene description - %s stream\\n\", b_cfg->elementaryMasks ? \"Animation\" : \"Command\");\n\t\t\t\t\tif (full_dump && !b_cfg->elementaryMasks) {\n\t\t\t\t\t\tfprintf(stderr, \"\\tWidth %d Height %d Pixel Metrics %s\\n\", b_cfg->pixelWidth, b_cfg->pixelHeight, b_cfg->pixelMetrics ? \"yes\" : \"no\");\n\t\t\t\t\t}\n\t\t\t\t\tgf_odf_desc_del((GF_Descriptor *)b_cfg);\n\t\t\t\t} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_AFX) {\n\t\t\t\t\tu8 tag = esd->decoderConfig->decoderSpecificInfo ? esd->decoderConfig->decoderSpecificInfo->data[0] : 0xFF;\n\t\t\t\t\tconst char *afxtype = gf_stream_type_afx_name(tag);\n\t\t\t\t\tfprintf(stderr, \"AFX Stream - type %s (%d)\\n\", afxtype, tag);\n\t\t\t\t} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_FONT) {\n\t\t\t\t\tfprintf(stderr, \"Font Data stream\\n\");\n\t\t\t\t} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_LASER) {\n\t\t\t\t\tGF_LASERConfig l_cfg;\n\t\t\t\t\tgf_odf_get_laser_config(esd->decoderConfig->decoderSpecificInfo, &l_cfg);\n\t\t\t\t\tfprintf(stderr, \"LASER Stream - %s\\n\", l_cfg.newSceneIndicator ? \"Full Scene\" : \"Scene Segment\");\n\t\t\t\t} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_TEXT_MPEG4) {\n\t\t\t\t\tfprintf(stderr, \"MPEG-4 Streaming Text stream\\n\");\n\t\t\t\t} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_SYNTHESIZED_TEXTURE) {\n\t\t\t\t\tfprintf(stderr, \"Synthetized Texture stream stream\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tM4_LOG(GF_LOG_WARNING, (\"Unknown Systems stream OTI %d\\n\", esd->decoderConfig->objectTypeIndication));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*sync is only valid if we open all tracks to take care of default MP4 sync..*/\n\t\t\tif (!full_dump) {\n\t\t\t\tif (dump_m4sys) {\n\t\t\t\t\tif (!esd->OCRESID || (esd->OCRESID == esd->ESID))\n\t\t\t\t\t\tfprintf(stderr, \"Self-synchronized\\n\");\n\t\t\t\t\telse\n\t\t\t\t\t\tfprintf(stderr, \"Synchronized on stream %d\\n\", esd->OCRESID);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"\\tDecoding Buffer size %d - Bitrate: avg %d - max %d kbps\\n\", esd->decoderConfig->bufferSizeDB, esd->decoderConfig->avgBitrate/1000, esd->decoderConfig->maxBitrate/1000);\n\t\t\t\tif (esd->dependsOnESID)\n\t\t\t\t\tfprintf(stderr, \"\\tDepends on stream %d for decoding\\n\", esd->dependsOnESID);\n\t\t\t\telse\n\t\t\t\t\tfprintf(stderr, \"\\tNo stream dependencies for decoding\\n\");\n\n\t\t\t\tfprintf(stderr, \"\\tStreamPriority %d\\n\", esd->streamPriority);\n\t\t\t\tif (esd->URLString) fprintf(stderr, \"\\tRemote Data Source %s\\n\", esd->URLString);\n\t\t\t}\n\t\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\t\t}\n\t} else if (msub_type == GF_ISOM_SUBTYPE_AV01) {\n\t\tGF_AV1Config *av1c;\n\t\tu32 w, h;\n\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\tfprintf(stderr, \"\\tAOM AV1 stream - Resolution %d x %d\\n\", w, h);\n\n\t\tav1c = gf_isom_av1_config_get(file, trackNum, 1);\n\t\tif (!av1c) {\n\t\t\tfprintf(stderr, \"\\tCorrupted av1 config\\n\");\n\t\t} else {\n\t\t\tfprintf(stderr, \"\\tversion=%u, profile=%u, level_idx0=%u, tier=%u\\n\", (u32)av1c->version, (u32)av1c->seq_profile, (u32)av1c->seq_level_idx_0, (u32)av1c->seq_tier_0);\n\t\t\tfprintf(stderr, \"\\thigh_bitdepth=%u, twelve_bit=%u, monochrome=%u\\n\", (u32)av1c->high_bitdepth, (u32)av1c->twelve_bit, (u32)av1c->monochrome);\n\t\t\tfprintf(stderr, \"\\tchroma: subsampling_x=%u, subsampling_y=%u, sample_position=%u\\n\", (u32)av1c->chroma_subsampling_x, (u32)av1c->chroma_subsampling_y, (u32)av1c->chroma_sample_position);\n\n\t\t\tif (av1c->initial_presentation_delay_present)\n\t\t\t\tfprintf(stderr, \"\\tInitial presentation delay %u\\n\", (u32) av1c->initial_presentation_delay_minus_one+1);\n\n\t\t\tcount = gf_list_count(av1c->obu_array);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tu8 hash[20];\n\t\t\t\tGF_AV1_OBUArrayEntry *obu = gf_list_get(av1c->obu_array, i);\n\t\t\t\tgf_sha1_csum((u8*)obu->obu, (u32)obu->obu_length, hash);\n\t\t\t\tfprintf(stderr, \"\\tOBU#%d %s hash: \", i+1, gf_av1_get_obu_name(obu->obu_type) );\n\t\t\t\tfor (j=0; j<20; j++) fprintf(stderr, \"%02X\", hash[j]);\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t\tgf_odf_av1_cfg_del(av1c);\n\t\t}\n\t} else if (msub_type == GF_ISOM_SUBTYPE_3GP_H263) {\n\t\tu32 w, h;\n\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\tfprintf(stderr, \"\\t3GPP H263 stream - Resolution %d x %d\\n\", w, h);\n\t} else if (msub_type == GF_ISOM_SUBTYPE_MJP2) {\n\t\tu32 w, h;\n\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\tfprintf(stderr, \"\\tMotionJPEG2000 stream - Resolution %d x %d\\n\", w, h);\n\t} else if ((msub_type == GF_ISOM_SUBTYPE_3GP_AMR) || (msub_type == GF_ISOM_SUBTYPE_3GP_AMR_WB)) {\n\t\tfprintf(stderr, \"\\t3GPP AMR%s stream - Sample Rate %d - %d channel(s) %d bps\\n\", (msub_type == GF_ISOM_SUBTYPE_3GP_AMR_WB) ? \" Wide Band\" : \"\", sr, nb_ch, (u32) bps);\n\t} else if (msub_type == GF_ISOM_SUBTYPE_3GP_EVRC) {\n\t\tfprintf(stderr, \"\\t3GPP EVRC stream - Sample Rate %d - %d channel(s) %d bps\\n\", sr, nb_ch, (u32) bps);\n\t} else if (msub_type == GF_ISOM_SUBTYPE_3GP_QCELP) {\n\t\tfprintf(stderr, \"\\t3GPP QCELP stream - Sample Rate %d - %d channel(s) %d bps\\n\", sr, nb_ch, (u32) bps);\n\t} else if (msub_type == GF_ISOM_SUBTYPE_MP3) {\n\t\tfprintf(stderr, \"\\tMPEG 1/2 Audio stream - Sample Rate %d - %d channel(s) %d bps\\n\", sr, nb_ch, (u32) bps);\n\t} else if ((msub_type == GF_ISOM_SUBTYPE_AC3) || (msub_type == GF_ISOM_SUBTYPE_EC3)) {\n\t\tu32 br = 0;\n\t\tconst char *lfe = \"\";\n\t\tBool is_ec3 = (msub_type == GF_ISOM_SUBTYPE_EC3) ? GF_TRUE : GF_FALSE;\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tGF_AC3Config *ac3 = gf_isom_ac3_config_get(file, trackNum, 1);\n\t\tif (ac3) {\n\t\t\tnb_ch = gf_ac3_get_channels(ac3->streams[0].acmod);\n\t\t\tfor (i=0; i<ac3->streams[0].nb_dep_sub; ++i) {\n\t\t\t\tassert(ac3->streams[0].nb_dep_sub == 1);\n\t\t\t\tnb_ch += gf_ac3_get_channels(ac3->streams[0].chan_loc);\n\t\t\t}\n\t\t\tif (ac3->streams[0].lfon) lfe = \".1\";\n\t\t\tbr = ac3->is_ec3 ? ac3->brcode : gf_ac3_get_bitrate(ac3->brcode);\n\t\t\tis_ec3 = ac3->is_ec3;\n\t\t\tgf_free(ac3);\n\t\t}\n#endif\n\t\tfprintf(stderr, \"\\t%s stream - Sample Rate %d - %d%s channel(s) - bitrate %d\\n\", is_ec3 ? \"EC-3\" : \"AC-3\", sr, nb_ch, lfe, br);\n\t} else if (msub_type == GF_ISOM_SUBTYPE_3GP_SMV) {\n\t\tfprintf(stderr, \"\\t3GPP SMV stream - Sample Rate %d - %d channel(s) %d bits per samples\\n\", sr, nb_ch, (u32) bps);\n\t} else if (msub_type == GF_ISOM_SUBTYPE_3GP_DIMS) {\n\t\tu32 w, h;\n\t\tGF_DIMSDescription dims;\n\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\n\t\tgf_isom_get_dims_description(file, trackNum, 1, &dims);\n\t\tfprintf(stderr, \"\\t3GPP DIMS stream - size %d x %d - Profile %d - Level %d\\n\", w, h, dims.profile, dims.level);\n\t\tfprintf(stderr, \"\\tpathComponents: %d - useFullRequestHost: %s\\n\", dims.pathComponents, dims.fullRequestHost ? \"yes\" : \"no\");\n\t\tfprintf(stderr, \"\\tstream type: %s - redundant: %s\\n\", dims.streamType ? \"primary\" : \"secondary\", (dims.containsRedundant==1) ? \"main\" : ((dims.containsRedundant==2) ? \"redundant\" : \"main+redundant\") );\n\t\tif (dims.textEncoding[0]) fprintf(stderr, \"\\ttext encoding %s\\n\", dims.textEncoding);\n\t\tif (dims.contentEncoding[0]) fprintf(stderr, \"\\tcontent encoding %s\\n\", dims.contentEncoding);\n\t\tif (dims.content_script_types) fprintf(stderr, \"\\tscript languages %s\\n\", dims.content_script_types);\n\t} else if (mtype==GF_ISOM_MEDIA_HINT) {\n\t\tu32 refTrack;\n\t\ts32 refCount = gf_isom_get_reference_count(file, trackNum, GF_ISOM_REF_HINT);\n\t\tif (refCount>0) {\n\t\t\tfprintf(stderr, \"Streaming Hint Track for track%s \", (refCount>1) ? \"s\" :\"\");\n\t\t\tfor (i=0; i<(u32) refCount; i++) {\n\t\t\t\tgf_isom_get_reference(file, trackNum, GF_ISOM_REF_HINT, i+1, &refTrack);\n\t\t\t\tif (i) fprintf(stderr, \" - \");\n\t\t\t\tfprintf(stderr, \"ID %d\", gf_isom_get_track_id(file, refTrack));\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t} else {\n\t\t\tfprintf(stderr, \"Streaming Hint Track (no refs)\\n\");\n\t\t}\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\t\trefCount = gf_isom_get_payt_count(file, trackNum);\n\t\tif (refCount>0) {\n\t\t\tfor (i=0; i<(u32) refCount; i++) {\n\t\t\t\tconst char *name = gf_isom_get_payt_info(file, trackNum, i+1, &refTrack);\n\t\t\t\tfprintf(stderr, \"\\tPayload ID %d: type %s\\n\", refTrack, name);\n\t\t\t}\n\t\t}\n#endif\n\t} else if (mtype==GF_ISOM_MEDIA_FLASH) {\n\t\tfprintf(stderr, \"Macromedia Flash Movie\\n\");\n\t} else if ((mtype==GF_ISOM_MEDIA_TEXT) || (mtype==GF_ISOM_MEDIA_SUBT) || (mtype==GF_ISOM_MEDIA_MPEG_SUBT)) {\n\t\tu32 w, h;\n\t\ts16 l;\n\t\ts32 tx, ty;\n\t\tconst char *content_encoding = NULL;\n\t\tconst char *mime = NULL;\n\t\tconst char *config  = NULL;\n\t\tconst char *_namespace = NULL;\n\t\tconst char *schema_loc = NULL;\n\t\tconst char *auxiliary_mimes = NULL;\n\t\tgf_isom_get_track_layout_info(file, trackNum, &w, &h, &tx, &ty, &l);\n\t\tif (msub_type == GF_ISOM_SUBTYPE_SBTT) {\n\t\t\tgf_isom_stxt_get_description(file, trackNum, 1, &mime, &content_encoding, &config);\n\t\t\tfprintf(stderr, \"Textual Subtitle Stream \");\n\t\t\tfprintf(stderr, \"- mime %s\", mime);\n\t\t\tif (content_encoding != NULL) {\n\t\t\t\tfprintf(stderr, \" - encoding %s\", content_encoding);\n\t\t\t}\n\t\t\tif (config != NULL) {\n\t\t\t\tfprintf(stderr, \" - %d bytes config\", (u32) strlen(config));\n\t\t\t}\n\t\t} else if (msub_type == GF_ISOM_SUBTYPE_STXT) {\n\t\t\tgf_isom_stxt_get_description(file, trackNum, 1, &mime, &content_encoding, &config);\n\t\t\tfprintf(stderr, \"Simple Timed Text Stream \");\n\t\t\tfprintf(stderr, \"- mime %s\", mime);\n\t\t\tif (content_encoding != NULL) {\n\t\t\t\tfprintf(stderr, \" - encoding %s\", content_encoding);\n\t\t\t}\n\t\t\tif (config != NULL) {\n\t\t\t\tfprintf(stderr, \" - %d bytes config\", (u32) strlen(config));\n\t\t\t}\n\t\t} else if (msub_type == GF_ISOM_SUBTYPE_STPP) {\n\t\t\tgf_isom_xml_subtitle_get_description(file, trackNum, 1, &_namespace, &schema_loc, &auxiliary_mimes);\n\t\t\tfprintf(stderr, \"XML Subtitle Stream \");\n\t\t\tfprintf(stderr, \"- namespace %s\", _namespace);\n\t\t\tif (schema_loc != NULL) {\n\t\t\t\tfprintf(stderr, \" - schema-location %s\", schema_loc);\n\t\t\t}\n\t\t\tif (auxiliary_mimes != NULL) {\n\t\t\t\tfprintf(stderr, \" - auxiliary-mime-types %s\", auxiliary_mimes);\n\t\t\t}\n\t\t} else {\n\t\t\tfprintf(stderr, \"Unknown Text Stream\");\n\t\t}\n\t\tfprintf(stderr, \"\\n Size %d x %d - Translation X=%d Y=%d - Layer %d\\n\", w, h, tx, ty, l);\n\t} else if (mtype == GF_ISOM_MEDIA_META) {\n\t\tconst char *content_encoding = NULL;\n\t\tif (msub_type == GF_ISOM_SUBTYPE_METT) {\n\t\t\tconst char *mime = NULL;\n\t\t\tconst char *config  = NULL;\n\t\t\tgf_isom_stxt_get_description(file, trackNum, 1, &mime, &content_encoding, &config);\n\t\t\tfprintf(stderr, \"Textual Metadata Stream - mime %s\", mime);\n\t\t\tif (content_encoding != NULL) {\n\t\t\t\tfprintf(stderr, \" - encoding %s\", content_encoding);\n\t\t\t}\n\t\t\tif (config != NULL) {\n\t\t\t\tfprintf(stderr, \" - %d bytes config\", (u32) strlen(config));\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t} else if (msub_type == GF_ISOM_SUBTYPE_METX) {\n\t\t\tconst char *_namespace = NULL;\n\t\t\tconst char *schema_loc = NULL;\n\t\t\tgf_isom_get_xml_metadata_description(file, trackNum, 1, &_namespace, &schema_loc, &content_encoding);\n\t\t\tfprintf(stderr, \"XML Metadata Stream - namespace %s\", _namespace);\n\t\t\tif (content_encoding != NULL) {\n\t\t\t\tfprintf(stderr, \" - encoding %s\", content_encoding);\n\t\t\t}\n\t\t\tif (schema_loc != NULL) {\n\t\t\t\tfprintf(stderr, \" - schema-location %s\", schema_loc);\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t} else {\n\t\t\tfprintf(stderr, \"Unknown Metadata Stream\\n\");\n\t\t}\n\t} else if ((msub_type==GF_ISOM_SUBTYPE_VVC1) || (msub_type==GF_ISOM_SUBTYPE_VVI1)) {\n\t\tGF_VVCConfig *vvccfg;\n\t\tu32 w, h;\n#if !defined(GPAC_DISABLE_AV_PARSERS)\n\t\tVVCState *vvc_state;\n\t\tGF_SAFEALLOC(vvc_state, VVCState);\n\t\tif (vvc_state) vvc_state->sps_active_idx = -1;\n#endif\n\n\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\tif (full_dump) fprintf(stderr, \"\\t\");\n\t\tfprintf(stderr, \"VVC Video - Visual Size %d x %d\\n\", w, h);\n\t\tvvccfg = gf_isom_vvc_config_get(file, trackNum, 1);\n\n\t\tif (!vvccfg) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Non-compliant VVC track: No vvcC found in sample description\\n\"));\n\t\t} else {\n\t\t\tdump_vvc_track_info(file, trackNum, vvccfg\n#if !defined(GPAC_DISABLE_AV_PARSERS)\n\t\t\t\t, vvc_state\n#endif\n\t\t\t);\n\t\t\tgf_odf_vvc_cfg_del(vvccfg);\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t}\n#if !defined(GPAC_DISABLE_AV_PARSERS)\n\t\tif (vvc_state) gf_free(vvc_state);\n#endif\n\t} else if ((msub_type == GF_ISOM_SUBTYPE_MH3D_MHA1) || (msub_type == GF_ISOM_SUBTYPE_MH3D_MHA2)\n\t\t\t|| (msub_type == GF_ISOM_SUBTYPE_MH3D_MHM1) || (msub_type == GF_ISOM_SUBTYPE_MH3D_MHM2)\n\t) {\n\t\tconst u8 *compat_profiles;\n\t\tu32 nb_compat_profiles;\n\t\tBool valid = GF_FALSE;\n\t\tBool allow_inband = GF_FALSE;\n\t\tif ( (msub_type == GF_ISOM_SUBTYPE_MH3D_MHM1) || (msub_type == GF_ISOM_SUBTYPE_MH3D_MHM2))\n\t\t\tallow_inband = GF_TRUE;\n\n\t\tfprintf(stderr, \"\\tMPEG-H Audio stream - Sample Rate %d\\n\", sr);\n\n\t\tesd = gf_media_map_esd(file, trackNum, 1);\n\t\tif (!esd || !esd->decoderConfig || !esd->decoderConfig->decoderSpecificInfo\n\t\t\t|| !esd->decoderConfig->decoderSpecificInfo->data\n\t\t) {\n\t\t\tif (allow_inband) {\n\t\t\t\tGF_ISOSample *samp = gf_isom_get_sample(file, trackNum, 1, NULL);\n\t\t\t\tif (samp) {\n\t\t\t\t\tu64 ch_layout=0;\n\t\t\t\t\ts32 PL = gf_mpegh_get_mhas_pl(samp->data, samp->dataLength, &ch_layout);\n\t\t\t\t\tif (PL>=0) {\n\t\t\t\t\t\tfprintf(stderr, \"\\tProfileLevelIndication: 0x%02X\", PL);\n\t\t\t\t\t\tif (ch_layout)\n\t\t\t\t\t\t\tfprintf(stderr, \" - Reference Channel Layout %s\", gf_audio_fmt_get_layout_name(ch_layout) );\n\t\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tgf_isom_sample_del(&samp);\n\t\t\t\t}\n\t\t\t\tvalid = GF_TRUE;\n\t\t\t}\n\t\t} else if (esd->decoderConfig->decoderSpecificInfo->dataLength>=5) {\n\t\t\tfprintf(stderr, \"\\tProfileLevelIndication: 0x%02X - Reference Channel Layout %s\\n\", esd->decoderConfig->decoderSpecificInfo->data[1]\n\t\t\t\t, gf_audio_fmt_get_layout_name_from_cicp(esd->decoderConfig->decoderSpecificInfo->data[2])\n\t\t\t);\n\t\t\tvalid = GF_TRUE;\n\t\t}\n\t\tif (!valid) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Invalid MPEG-H audio config\\n\"));\n\t\t}\n\t\tif (esd) gf_odf_desc_del((GF_Descriptor *)esd);\n\t\tcompat_profiles = gf_isom_get_mpegh_compatible_profiles(file, trackNum, 1, &nb_compat_profiles);\n\t\tfor (i=0; i<nb_compat_profiles; i++) {\n\t\t\tif (!i)\n\t\t\t\tfprintf(stderr, \"\\tCompatible profiles:\");\n\t\t\tfprintf(stderr, \" 0x%02X\", compat_profiles[i]);\n\t\t}\n\t\tif (i) fprintf(stderr, \"\\n\");\n\t} else if (msub_type==GF_ISOM_SUBTYPE_MLPA) {\n\t\tu32 fmt, prate;\n\t\tif (gf_isom_truehd_config_get(file, trackNum, 1, &fmt, &prate) != GF_OK) {\n\t\t\tfprintf(stderr, \"\\tInvalid TrueHD audio config\\n\");\n\t\t}\n\t\tfprintf(stderr, \"TrueHD Audio stream - Sample Rate %u - channels %u - format %u peak rate %u\\n\", sr, nb_ch, fmt, prate);\n\t} else if (codecid) {\n\t\tif (gf_isom_is_video_handler_type(mtype) ) {\n\t\t\tu32 w, h;\n\t\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\t\tfprintf(stderr, \"%s - Resolution %d x %d\\n\", gf_codecid_name(codecid), w, h);\n\t\t} else if (mtype==GF_ISOM_MEDIA_AUDIO) {\n\t\t\tgf_isom_get_audio_info(file, trackNum, 1, &sr, &nb_ch, NULL);\n\t\t\tfprintf(stderr, \"%s - Sample Rate %d - %d channel(s)\\n\", gf_codecid_name(codecid), sr, nb_ch);\n\t\t} else {\n\t\t\tfprintf(stderr, \"%s\\n\", gf_codecid_name(codecid) );\n\t\t}\n\t} else if (pfmt) {\n\t\tu32 w, h;\n\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n\t\tfprintf(stderr, \"Raw video %s - Resolution %d x %d\\n\", gf_pixel_fmt_name(pfmt), w, h);\n\t} else if (msub_type==GF_QT_SUBTYPE_TMCD) {\n\t\tu32 stsd_idx;\n\t\tGF_ISOSample *sample = gf_isom_get_sample(file, trackNum, 1, &stsd_idx);\n\t\tfprintf(stderr, \"Time Code stream\\n\");\n\t\tif (sample) {\n\t\t\tchar szTimecode[100];\n\t\t\tu32 tmcd_flags, tmcd_num, tmcd_den, tmcd_fpt;\n\n\t\t\tgf_isom_get_tmcd_config(file, trackNum, stsd_idx, &tmcd_flags, &tmcd_num, &tmcd_den, &tmcd_fpt);\n\n\t\t\tgf_inspect_format_timecode(sample->data, sample->dataLength, tmcd_flags, tmcd_num, tmcd_den, tmcd_fpt, szTimecode);\n\n\t\t\tgf_isom_sample_del(&sample);\n\t\t\tfprintf(stderr, \"\\tFirst timecode: %s\\n\", szTimecode);\n\t\t}\n\t} else {\n\t\tGF_GenericSampleDescription *udesc;\n\n\t\tudesc = gf_isom_get_generic_sample_description(file, trackNum, 1);\n\t\tif (udesc) {\n\t\t\tif (gf_isom_is_video_handler_type(mtype) ) {\n                fprintf(stderr, \"%s - Compressor \\\"%s\\\" - Resolution %d x %d\\n\",\n\t\t\t\t\t\t( (mtype == GF_ISOM_MEDIA_VISUAL ? \"Visual\" : \"Auxiliary Video\") ),\n                        udesc->compressor_name, udesc->width, udesc->height);\n\t\t\t} else if (mtype==GF_ISOM_MEDIA_AUDIO) {\n\t\t\t\tfprintf(stderr, \"Audio - Sample Rate %d - %d channel(s)\\n\", udesc->samplerate, udesc->nb_channels);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"Unknown media type\\n\");\n\t\t\t}\n\t\t\tif (udesc->vendor_code)\n\t\t\t\tfprintf(stderr, \"\\tVendor code \\\"%s\\\" - Version %d - revision %d\\n\", gf_4cc_to_str(udesc->vendor_code), udesc->version, udesc->revision);\n\n\t\t\tif (udesc->extension_buf) {\n\t\t\t\tfprintf(stderr, \"\\tCodec configuration data size: %d bytes\\n\", udesc->extension_buf_size);\n\t\t\t\tgf_free(udesc->extension_buf);\n\t\t\t}\n\t\t\tgf_free(udesc);\n\t\t} else {\n\t\t\tfprintf(stderr, \"Unknown track type\\n\");\n\t\t}\n\t}\n\n\n\t/*Crypto info*/\n\tif (gf_isom_is_track_encrypted(file, trackNum)) {\n\t\tconst char *scheme_URI, *KMS_URI;\n\t\tu32 scheme_type, version;\n\t\tu32 IV_size;\n\t\tBool use_sel_enc;\n\n\t\tif (gf_isom_is_ismacryp_media(file, trackNum, 1)) {\n\t\t\tgf_isom_get_ismacryp_info(file, trackNum, 1, NULL, &scheme_type, &version, &scheme_URI, &KMS_URI, &use_sel_enc, &IV_size, NULL);\n\t\t\tfprintf(stderr, \"\\n\\tProtected by ISMA E&A scheme %s (version %d)\\n\", gf_4cc_to_str(scheme_type), version);\n\t\t\tif (scheme_URI) fprintf(stderr, \"scheme location: %s\\n\", scheme_URI);\n\t\t\tif (KMS_URI) {\n\t\t\t\tif (!strnicmp(KMS_URI, \"(key)\", 5)) fprintf(stderr, \"\\tKMS location: key in file\\n\");\n\t\t\t\telse fprintf(stderr, \"\\tKMS location: %s\\n\", KMS_URI);\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\tSelective Encryption: %s\\n\", use_sel_enc ? \"Yes\" : \"No\");\n\t\t\tif (IV_size) fprintf(stderr, \"\\tInitialization Vector size: %d bits\\n\", IV_size*8);\n\t\t} else if (gf_isom_is_omadrm_media(file, trackNum, 1)) {\n\t\t\tconst char *textHdrs;\n\t\t\tu32 enc_type, hdr_len;\n\t\t\tu64 orig_len;\n\t\t\tgf_isom_get_omadrm_info(file, trackNum, 1, NULL, &scheme_type, &version, &scheme_URI, &KMS_URI, &textHdrs, &hdr_len, &orig_len, &enc_type, &use_sel_enc, &IV_size, NULL);\n\t\t\tfprintf(stderr, \"\\n\\tProtected by OMA DRM scheme %s (version %d)\\n\", gf_4cc_to_str(scheme_type), version);\n\t\t\tfprintf(stderr, \"\\tRights Issuer: %s\\n\", KMS_URI);\n\t\t\tfprintf(stderr, \"\\tContent ID: %s\\n\", scheme_URI);\n\t\t\tif (textHdrs) {\n\t\t\t\tu32 offset;\n\t\t\t\tconst char *start = textHdrs;\n\t\t\t\tfprintf(stderr, \"\\tOMA Textual Headers:\\n\");\n\t\t\t\ti=0;\n\t\t\t\toffset=0;\n\t\t\t\twhile (i<hdr_len) {\n\t\t\t\t\tif (start[i]==0) {\n\t\t\t\t\t\tfprintf(stderr, \"\\t\\t%s\\n\", start+offset);\n\t\t\t\t\t\toffset=i+1;\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\\\tt%s\\n\", start+offset);\n\t\t\t}\n\t\t\tif (orig_len) fprintf(stderr, \"\\tOriginal media size \"LLD\"\\n\", orig_len);\n\t\t\tfprintf(stderr, \"\\tEncryption algorithm %s\\n\", (enc_type==1) ? \"AEA 128 CBC\" : (enc_type ? \"AEA 128 CTR\" : \"None\"));\n\t\t\tfprintf(stderr, \"\\tSelective Encryption: %s\\n\", use_sel_enc ? \"Yes\" : \"No\");\n\t\t\tif (IV_size) fprintf(stderr, \"\\tInitialization Vector size: %d bits\\n\", IV_size*8);\n\t\t} else if(gf_isom_is_cenc_media(file, trackNum, 1)) {\n\t\t\tconst u8 *def_key;\n\t\t\tu32 def_key_size;\n\t\t\tBool IsEncrypted;\n\t\t\tu8 crypt_byte_block, skip_byte_block;\n\t\t\tIV_size = 0;\n\t\t\tgf_isom_get_cenc_info(file, trackNum, 1, NULL, &scheme_type, &version);\n\n\t\t\tgf_isom_cenc_get_default_info(file, trackNum, 1, NULL, &IsEncrypted, &crypt_byte_block, &skip_byte_block, &def_key, &def_key_size);\n\n\t\t\tfprintf(stderr, \"\\n\\tProtected by CENC scheme %s version 0x%08X\", gf_4cc_to_str(scheme_type), version);\n\n\t\t\tif (crypt_byte_block && skip_byte_block)\n\t\t\t\tfprintf(stderr, \" - Pattern %d:%d\", (u32) skip_byte_block, (u32) crypt_byte_block);\n\t\t\tif (def_key && def_key[0])\n\t\t\t\tfprintf(stderr, \" - MultiKey\");\n\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t\tdump_key_info(def_key, def_key_size, IsEncrypted);\n\n\t\t} else if(gf_isom_is_adobe_protection_media(file, trackNum, 1)) {\n\t\t\tgf_isom_get_adobe_protection_info(file, trackNum, 1, NULL, &scheme_type, &version, NULL);\n\t\t\tfprintf(stderr, \"\\nProtected by Adobe scheme %s (version %d)\\n\", gf_4cc_to_str(scheme_type), version);\n\t\t} else {\n\t\t\tfprintf(stderr, \"\\nProtected by unknown scheme %s\\n\", gf_4cc_to_str(gf_isom_is_media_encrypted(file, trackNum, 0) ));\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t}\n\n\tif ( gf_media_get_rfc_6381_codec_name(file, trackNum, szCodec, GF_FALSE, GF_FALSE) == GF_OK) {\n\t\tfprintf(stderr, \"\\tRFC6381 Codec Parameters: %s\\n\", szCodec);\n\t}\n\n\n\tDumpMetaItem(file, 0, trackNum, \"\\tTrack Meta\");\n\n\tgf_isom_get_track_switch_group_count(file, trackNum, &alt_group, &nb_groups);\n\tif (alt_group) {\n\t\tfprintf(stderr, \"Alternate Group ID %d\\n\", alt_group);\n\t\tfor (i=0; i<nb_groups; i++) {\n\t\t\tu32 nb_crit, switchGroupID;\n\t\t\tconst u32 *criterias = gf_isom_get_track_switch_parameter(file, trackNum, i+1, &switchGroupID, &nb_crit);\n\t\t\tif (!nb_crit) {\n\t\t\t\tfprintf(stderr, \"\\tNo criteria in %s group\\n\", switchGroupID ? \"switch\" : \"alternate\");\n\t\t\t} else {\n\t\t\t\tif (switchGroupID) {\n\t\t\t\t\tfprintf(stderr, \"\\tSwitchGroup ID %d criterias: \", switchGroupID);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"\\tAlternate Group criterias: \");\n\t\t\t\t}\n\t\t\t\tfor (j=0; j<nb_crit; j++) {\n\t\t\t\t\tif (j) fprintf(stderr, \" \");\n\t\t\t\t\tfprintf(stderr, \"%s\", gf_4cc_to_str(criterias[j]) );\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch (gf_isom_has_sync_points(file, trackNum)) {\n\tcase 0:\n\t\tfprintf(stderr, \"\\tAll samples are sync\\n\");\n\t\tbreak;\n\tcase 1:\n\t{\n\t\tu32 nb_sync = gf_isom_get_sync_point_count(file, trackNum) - 1;\n\t\tif (! nb_sync) {\n\t\t\tfprintf(stderr, \"\\tOnly one sync sample\\n\");\n\t\t} else {\n\t\t\tfprintf(stderr, \"\\tAverage GOP length: %d samples\\n\", gf_isom_get_sample_count(file, trackNum) / nb_sync);\n\t\t}\n\t}\n\tbreak;\n\tcase 2:\n\t\tfprintf(stderr, \"\\tNo sync sample found\\n\");\n\t\tbreak;\n\t}\n\tfprintf(stderr, \"\\tMax sample duration: %d / %d\\n\", gf_isom_get_max_sample_delta(file, trackNum), timescale);\n\n\tif (!full_dump) {\n\t\tfprintf(stderr, \"\\n\");\n\t\treturn;\n\t}\n\n\tdur = size = 0;\n\tmax_rate = rate = 0;\n\ttime_slice = 0;\n\tts = gf_isom_get_media_timescale(file, trackNum);\n\tcsize = gf_isom_get_constant_sample_size(file, trackNum);\n\tcdur = gf_isom_get_constant_sample_duration(file, trackNum);\n\tcount = gf_isom_get_sample_count(file, trackNum);\n\tif (csize && cdur) {\n\t\tsize = count * csize;\n\t\tdur = cdur * count;\n\t} else {\n\n\t\tfor (j=0; j<count; j++) {\n\t\t\tGF_ISOSample *samp;\n\t\t\tif (is_od_track) {\n\t\t\t\tsamp = gf_isom_get_sample(file, trackNum, j+1, NULL);\n\t\t\t} else {\n\t\t\t\tsamp = gf_isom_get_sample_info(file, trackNum, j+1, NULL, NULL);\n\t\t\t}\n\t\t\tif (!samp) {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Failed to fetch sample %d\\n\", j+1));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdur = samp->DTS+samp->CTS_Offset;\n\t\t\tsize += samp->dataLength;\n\t\t\trate += samp->dataLength;\n\t\t\tif (samp->DTS - time_slice > ts) {\n\t\t\t\tDouble max_tmp = rate * ts / (samp->DTS - time_slice);\n\t\t\t\tif (max_rate < max_tmp )\n\t\t\t\t\tmax_rate = max_tmp;\n\n\t\t\t\trate = 0;\n\t\t\t\ttime_slice = samp->DTS;\n\t\t\t}\n\t\t\tgf_isom_sample_del(&samp);\n\t\t}\n\t}\n\tfprintf(stderr, \"\\nComputed info from media:\\n\");\n\tif (csize && cdur) {\n\t\tfprintf(stderr, \"\\tConstant sample size %d bytes and dur %d / %d\\n\", csize, cdur, ts);\n\t}\n\tscale = 1000.0 / ts;\n\tdur = (u64) (scale * dur);\n\tfprintf(stderr, \"\\tTotal size \"LLU\" bytes - Total samples duration \"LLU\" ms\\n\", size, dur);\n\tif (!dur) {\n\t\tfprintf(stderr, \"\\n\");\n\t\treturn;\n\t}\n\t/*rate in byte, dur is in ms*/\n\trate = 8000.0 * size / dur;\n\n\tif (!max_rate)\n\t\tmax_rate = rate;\n\telse\n\t\tmax_rate *= 8.0;\n\n\tif (rate >= 1500) {\n\t\tfprintf(stderr, \"\\tAverage rate %.2f kbps - Max Rate %.2f kbps\\n\", rate/1000, max_rate/1000);\n\t} else {\n\t\tfprintf(stderr, \"\\tAverage rate %.2f bps - Max Rate %.2f bps\\n\", rate, max_rate);\n\t}\n\n\t{\n\t\tu32 dmin, dmax, davg, smin, smax, savg;\n\t\tgf_isom_get_chunks_infos(file, trackNum, &dmin, &davg, &dmax, &smin, &savg, &smax);\n\t\tfprintf(stderr, \"\\tChunk durations: min %d ms - max %d ms - average %d ms\\n\", (1000*dmin)/ts, (1000*dmax)/ts, (1000*davg)/ts);\n\t\tfprintf(stderr, \"\\tChunk sizes (bytes): min %d - max %d - average %d\\n\", smin, smax, savg);\n\t}\n\tfprintf(stderr, \"\\n\");\n\n\tcount = gf_isom_get_chapter_count(file, trackNum);\n\tif (count) {\n\t\tconst char *name;\n\t\tu64 time;\n\t\tfprintf(stderr, \"\\nChapters:\\n\");\n\t\tfor (j=0; j<count; j++) {\n\t\t\tgf_isom_get_chapter(file, trackNum, j+1, &time, &name);\n\t\t\tfprintf(stderr, \"\\tChapter #%d - %s - \\\"%s\\\"\\n\", j+1, format_duration(time, 1000, szDur), name);\n\t\t}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 90,
    "critical_vars": [
      "realmstr"
    ],
    "function": "ec_verify",
    "filename": "krb5/CVE-2021-36222/CVE-2021-36222_CWE-476_fc98f520caefff2e5ee9a0026fdf5109944b3562_kdc_preauth_ec.c.diff",
    "function_code": "ec_verify(krb5_context context, krb5_data *req_pkt, krb5_kdc_req *request,\n          krb5_enc_tkt_part *enc_tkt_reply, krb5_pa_data *data,\n          krb5_kdcpreauth_callbacks cb, krb5_kdcpreauth_rock rock,\n          krb5_kdcpreauth_moddata moddata,\n          krb5_kdcpreauth_verify_respond_fn respond, void *arg)\n{\n    krb5_error_code retval = 0;\n    krb5_enc_data *enc = NULL;\n    krb5_data scratch, plain;\n    krb5_keyblock *armor_key = cb->fast_armor(context, rock);\n    krb5_pa_enc_ts *ts = NULL;\n    krb5_keyblock *client_keys = NULL;\n    krb5_keyblock *challenge_key = NULL;\n    krb5_keyblock *kdc_challenge_key;\n    krb5_kdcpreauth_modreq modreq = NULL;\n    int i = 0;\n    char *ai = NULL, *realmstr = NULL;\n    krb5_data realm = request->server->realm;\n\n    plain.data = NULL;\n\n    if (armor_key == NULL) {\n        retval = ENOENT;\n        k5_setmsg(context, ENOENT,\n                  _(\"Encrypted Challenge used outside of FAST tunnel\"));\n    }\n    scratch.data = (char *) data->contents;\n    scratch.length = data->length;\n    if (retval == 0)\n        retval = decode_krb5_enc_data(&scratch, &enc);\n    if (retval == 0) {\n        plain.data =  malloc(enc->ciphertext.length);\n        plain.length = enc->ciphertext.length;\n        if (plain.data == NULL)\n            retval = ENOMEM;\n    }\n\n    /* Check for a configured FAST ec auth indicator. */\n    realmstr = k5memdup0(realm.data, realm.length, &retval);\n    if (realmstr != NULL)\n        retval = profile_get_string(context->profile, KRB5_CONF_REALMS,\n                                    realmstr,\n                                    KRB5_CONF_ENCRYPTED_CHALLENGE_INDICATOR,\n                                    NULL, &ai);\n\n    if (retval == 0)\n        retval = cb->client_keys(context, rock, &client_keys);\n    if (retval == 0) {\n        for (i = 0; client_keys[i].enctype&& (retval == 0); i++ ) {\n            retval = krb5_c_fx_cf2_simple(context,\n                                          armor_key, \"clientchallengearmor\",\n                                          &client_keys[i], \"challengelongterm\",\n                                          &challenge_key);\n            if (retval == 0)\n                retval  = krb5_c_decrypt(context, challenge_key,\n                                         KRB5_KEYUSAGE_ENC_CHALLENGE_CLIENT,\n                                         NULL, enc, &plain);\n            if (challenge_key)\n                krb5_free_keyblock(context, challenge_key);\n            challenge_key = NULL;\n            if (retval == 0)\n                break;\n            /*We failed to decrypt. Try next key*/\n            retval = 0;\n        }\n        if (client_keys[i].enctype == 0) {\n            retval = KRB5KDC_ERR_PREAUTH_FAILED;\n            k5_setmsg(context, retval,\n                      _(\"Incorrect password in encrypted challenge\"));\n        }\n    }\n    if (retval == 0)\n        retval = decode_krb5_pa_enc_ts(&plain, &ts);\n    if (retval == 0)\n        retval = krb5_check_clockskew(context, ts->patimestamp);\n    if (retval == 0) {\n        enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;\n        /*\n         * If this fails, we won't generate a reply to the client.  That may\n         * cause the client to fail, but at this point the KDC has considered\n         * this a success, so the return value is ignored.\n         */\n        if (krb5_c_fx_cf2_simple(context, armor_key, \"kdcchallengearmor\",\n                                 &client_keys[i], \"challengelongterm\",\n                                 &kdc_challenge_key) == 0) {\n            modreq = (krb5_kdcpreauth_modreq)kdc_challenge_key;\n            if (ai != NULL)\n                cb->add_auth_indicator(context, rock, ai);\n        }\n    }\n    cb->free_keys(context, rock, client_keys);\n    if (plain.data)\n        free(plain.data);\n    if (enc)\n        krb5_free_enc_data(context, enc);\n    if (ts)\n        krb5_free_pa_enc_ts(context, ts);\n    free(realmstr);\n    free(ai);\n\n    (*respond)(arg, retval, modreq, NULL, NULL);\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 90,
    "critical_vars": [
      "retval"
    ],
    "function": "ec_verify",
    "filename": "krb5/CVE-2021-36222/CVE-2021-36222_CWE-476_fc98f520caefff2e5ee9a0026fdf5109944b3562_kdc_preauth_ec.c.diff",
    "function_code": "ec_verify(krb5_context context, krb5_data *req_pkt, krb5_kdc_req *request,\n          krb5_enc_tkt_part *enc_tkt_reply, krb5_pa_data *data,\n          krb5_kdcpreauth_callbacks cb, krb5_kdcpreauth_rock rock,\n          krb5_kdcpreauth_moddata moddata,\n          krb5_kdcpreauth_verify_respond_fn respond, void *arg)\n{\n    krb5_error_code retval = 0;\n    krb5_enc_data *enc = NULL;\n    krb5_data scratch, plain;\n    krb5_keyblock *armor_key = cb->fast_armor(context, rock);\n    krb5_pa_enc_ts *ts = NULL;\n    krb5_keyblock *client_keys = NULL;\n    krb5_keyblock *challenge_key = NULL;\n    krb5_keyblock *kdc_challenge_key;\n    krb5_kdcpreauth_modreq modreq = NULL;\n    int i = 0;\n    char *ai = NULL, *realmstr = NULL;\n    krb5_data realm = request->server->realm;\n\n    plain.data = NULL;\n\n    if (armor_key == NULL) {\n        retval = ENOENT;\n        k5_setmsg(context, ENOENT,\n                  _(\"Encrypted Challenge used outside of FAST tunnel\"));\n    }\n    scratch.data = (char *) data->contents;\n    scratch.length = data->length;\n    if (retval == 0)\n        retval = decode_krb5_enc_data(&scratch, &enc);\n    if (retval == 0) {\n        plain.data =  malloc(enc->ciphertext.length);\n        plain.length = enc->ciphertext.length;\n        if (plain.data == NULL)\n            retval = ENOMEM;\n    }\n\n    /* Check for a configured FAST ec auth indicator. */\n    if (retval == 0)\n        realmstr = k5memdup0(realm.data, realm.length, &retval);\n    if (realmstr != NULL)\n        retval = profile_get_string(context->profile, KRB5_CONF_REALMS,\n                                    realmstr,\n                                    KRB5_CONF_ENCRYPTED_CHALLENGE_INDICATOR,\n                                    NULL, &ai);\n\n    if (retval == 0)\n        retval = cb->client_keys(context, rock, &client_keys);\n    if (retval == 0) {\n        for (i = 0; client_keys[i].enctype&& (retval == 0); i++ ) {\n            retval = krb5_c_fx_cf2_simple(context,\n                                          armor_key, \"clientchallengearmor\",\n                                          &client_keys[i], \"challengelongterm\",\n                                          &challenge_key);\n            if (retval == 0)\n                retval  = krb5_c_decrypt(context, challenge_key,\n                                         KRB5_KEYUSAGE_ENC_CHALLENGE_CLIENT,\n                                         NULL, enc, &plain);\n            if (challenge_key)\n                krb5_free_keyblock(context, challenge_key);\n            challenge_key = NULL;\n            if (retval == 0)\n                break;\n            /*We failed to decrypt. Try next key*/\n            retval = 0;\n        }\n        if (client_keys[i].enctype == 0) {\n            retval = KRB5KDC_ERR_PREAUTH_FAILED;\n            k5_setmsg(context, retval,\n                      _(\"Incorrect password in encrypted challenge\"));\n        }\n    }\n    if (retval == 0)\n        retval = decode_krb5_pa_enc_ts(&plain, &ts);\n    if (retval == 0)\n        retval = krb5_check_clockskew(context, ts->patimestamp);\n    if (retval == 0) {\n        enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;\n        /*\n         * If this fails, we won't generate a reply to the client.  That may\n         * cause the client to fail, but at this point the KDC has considered\n         * this a success, so the return value is ignored.\n         */\n        if (krb5_c_fx_cf2_simple(context, armor_key, \"kdcchallengearmor\",\n                                 &client_keys[i], \"challengelongterm\",\n                                 &kdc_challenge_key) == 0) {\n            modreq = (krb5_kdcpreauth_modreq)kdc_challenge_key;\n            if (ai != NULL)\n                cb->add_auth_indicator(context, rock, ai);\n        }\n    }\n    cb->free_keys(context, rock, client_keys);\n    if (plain.data)\n        free(plain.data);\n    if (enc)\n        krb5_free_enc_data(context, enc);\n    if (ts)\n        krb5_free_pa_enc_ts(context, ts);\n    free(realmstr);\n    free(ai);\n\n    (*respond)(arg, retval, modreq, NULL, NULL);\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 318,
    "critical_vars": [
      "pol_name",
      "ld",
      "st",
      "context",
      "ent",
      "policy"
    ],
    "function": "krb5_ldap_get_password_policy_from_dn",
    "filename": "krb5/CVE-2014-5353/CVE-2014-5353_CWE-476_d1f707024f1d0af6e54a18885322d70fa15ec4d3_ldap_pwd_policy.c.diff",
    "function_code": "krb5_ldap_get_password_policy_from_dn(krb5_context context, char *pol_name,\n                                      char *pol_dn, osa_policy_ent_t *policy)\n{\n    krb5_error_code             st=0, tempst=0;\n    LDAP                        *ld=NULL;\n    LDAPMessage                 *result=NULL,*ent=NULL;\n    kdb5_dal_handle             *dal_handle=NULL;\n    krb5_ldap_context           *ldap_context=NULL;\n    krb5_ldap_server_handle     *ldap_server_handle=NULL;\n\n    /* Clear the global error string */\n    krb5_clear_error_message(context);\n\n    /* validate the input parameters */\n    if (pol_dn == NULL)\n        return EINVAL;\n\n    *policy = NULL;\n    SETUP_CONTEXT();\n    GET_HANDLE();\n\n    *(policy) = (osa_policy_ent_t) malloc(sizeof(osa_policy_ent_rec));\n    if (*policy == NULL) {\n        st = ENOMEM;\n        goto cleanup;\n    }\n    memset(*policy, 0, sizeof(osa_policy_ent_rec));\n\n    LDAP_SEARCH(pol_dn, LDAP_SCOPE_BASE, \"(objectclass=krbPwdPolicy)\", password_policy_attributes);\n\n    ent=ldap_first_entry(ld, result);\n    if (ent != NULL) {\n        if ((st = populate_policy(context, ld, ent, pol_name, *policy)) != 0)\n            goto cleanup;\n    }\n\ncleanup:\n    ldap_msgfree(result);\n    if (st != 0) {\n        if (*policy != NULL) {\n            krb5_ldap_free_password_policy(context, *policy);\n            *policy = NULL;\n        }\n    }\n\n    krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);\n    return st;\n}",
    "label": "True"
  },
  {
    "patch_model": "Replace",
    "change_type": "if-Condition",
    "line_old": 317,
    "line_new": 317,
    "critical_vars": [
      "ent"
    ],
    "function": "krb5_ldap_get_password_policy_from_dn",
    "filename": "krb5/CVE-2014-5353/CVE-2014-5353_CWE-476_d1f707024f1d0af6e54a18885322d70fa15ec4d3_ldap_pwd_policy.c.diff",
    "function_code": "krb5_ldap_get_password_policy_from_dn(krb5_context context, char *pol_name,\n                                      char *pol_dn, osa_policy_ent_t *policy)\n{\n    krb5_error_code             st=0, tempst=0;\n    LDAP                        *ld=NULL;\n    LDAPMessage                 *result=NULL,*ent=NULL;\n    kdb5_dal_handle             *dal_handle=NULL;\n    krb5_ldap_context           *ldap_context=NULL;\n    krb5_ldap_server_handle     *ldap_server_handle=NULL;\n\n    /* Clear the global error string */\n    krb5_clear_error_message(context);\n\n    /* validate the input parameters */\n    if (pol_dn == NULL)\n        return EINVAL;\n\n    *policy = NULL;\n    SETUP_CONTEXT();\n    GET_HANDLE();\n\n    *(policy) = (osa_policy_ent_t) malloc(sizeof(osa_policy_ent_rec));\n    if (*policy == NULL) {\n        st = ENOMEM;\n        goto cleanup;\n    }\n    memset(*policy, 0, sizeof(osa_policy_ent_rec));\n\n    LDAP_SEARCH(pol_dn, LDAP_SCOPE_BASE, \"(objectclass=krbPwdPolicy)\", password_policy_attributes);\n\n    ent=ldap_first_entry(ld, result);\n    if (ent == NULL) {\n        st = KRB5_KDB_NOENTRY;\n        goto cleanup;\n    }\n    st = populate_policy(context, ld, ent, pol_name, *policy);\n\ncleanup:\n    ldap_msgfree(result);\n    if (st != 0) {\n        if (*policy != NULL) {\n            krb5_ldap_free_password_policy(context, *policy);\n            *policy = NULL;\n        }\n    }\n\n    krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);\n    return st;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 742,
    "critical_vars": [
      "request->client",
      "request->server",
      "kdc_active_realm"
    ],
    "function": "validate_as_request",
    "filename": "krb5/CVE-2016-3120/CVE-2016-3120_CWE-476_93b4a6306a0026cf1cc31ac4bd8a49ba5d034ba7_kdc_util.c.diff",
    "function_code": "validate_as_request(kdc_realm_t *kdc_active_realm,\n                    register krb5_kdc_req *request, krb5_db_entry client,\n                    krb5_db_entry server, krb5_timestamp kdc_time,\n                    const char **status, krb5_pa_data ***e_data)\n{\n    int errcode;\n    krb5_error_code ret;\n\n    /*\n     * If an option is set that is only allowed in TGS requests, complain.\n     */\n    if (request->kdc_options & AS_INVALID_OPTIONS) {\n        *status = \"INVALID AS OPTIONS\";\n        return KDC_ERR_BADOPTION;\n    }\n\n    /* The client must not be expired */\n    if (client.expiration && client.expiration < kdc_time) {\n        *status = \"CLIENT EXPIRED\";\n        if (vague_errors)\n            return(KRB_ERR_GENERIC);\n        else\n            return(KDC_ERR_NAME_EXP);\n    }\n\n    /* The client's password must not be expired, unless the server is\n       a KRB5_KDC_PWCHANGE_SERVICE. */\n    if (client.pw_expiration && client.pw_expiration < kdc_time &&\n        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {\n        *status = \"CLIENT KEY EXPIRED\";\n        if (vague_errors)\n            return(KRB_ERR_GENERIC);\n        else\n            return(KDC_ERR_KEY_EXP);\n    }\n\n    /* The server must not be expired */\n    if (server.expiration && server.expiration < kdc_time) {\n        *status = \"SERVICE EXPIRED\";\n        return(KDC_ERR_SERVICE_EXP);\n    }\n\n    /*\n     * If the client requires password changing, then only allow the\n     * pwchange service.\n     */\n    if (isflagset(client.attributes, KRB5_KDB_REQUIRES_PWCHANGE) &&\n        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {\n        *status = \"REQUIRED PWCHANGE\";\n        return(KDC_ERR_KEY_EXP);\n    }\n\n    /* Client and server must allow postdating tickets */\n    if ((isflagset(request->kdc_options, KDC_OPT_ALLOW_POSTDATE) ||\n         isflagset(request->kdc_options, KDC_OPT_POSTDATED)) &&\n        (isflagset(client.attributes, KRB5_KDB_DISALLOW_POSTDATED) ||\n         isflagset(server.attributes, KRB5_KDB_DISALLOW_POSTDATED))) {\n        *status = \"POSTDATE NOT ALLOWED\";\n        return(KDC_ERR_CANNOT_POSTDATE);\n    }\n\n    /*\n     * A Windows KDC will return KDC_ERR_PREAUTH_REQUIRED instead of\n     * KDC_ERR_POLICY in the following case:\n     *\n     *   - KDC_OPT_FORWARDABLE is set in KDCOptions but local\n     *     policy has KRB5_KDB_DISALLOW_FORWARDABLE set for the\n     *     client, and;\n     *   - KRB5_KDB_REQUIRES_PRE_AUTH is set for the client but\n     *     preauthentication data is absent in the request.\n     *\n     * Hence, this check most be done after the check for preauth\n     * data, and is now performed by validate_forwardable() (the\n     * contents of which were previously below).\n     */\n\n    /* Client and server must allow proxiable tickets */\n    if (isflagset(request->kdc_options, KDC_OPT_PROXIABLE) &&\n        (isflagset(client.attributes, KRB5_KDB_DISALLOW_PROXIABLE) ||\n         isflagset(server.attributes, KRB5_KDB_DISALLOW_PROXIABLE))) {\n        *status = \"PROXIABLE NOT ALLOWED\";\n        return(KDC_ERR_POLICY);\n    }\n\n    /* Check to see if client is locked out */\n    if (isflagset(client.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {\n        *status = \"CLIENT LOCKED OUT\";\n        return(KDC_ERR_CLIENT_REVOKED);\n    }\n\n    /* Check to see if server is locked out */\n    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {\n        *status = \"SERVICE LOCKED OUT\";\n        return(KDC_ERR_S_PRINCIPAL_UNKNOWN);\n    }\n\n    /* Check to see if server is allowed to be a service */\n    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_SVR)) {\n        *status = \"SERVICE NOT ALLOWED\";\n        return(KDC_ERR_MUST_USE_USER2USER);\n    }\n\n    if (check_anon(kdc_active_realm, request->client, request->server) != 0) {\n        *status = \"ANONYMOUS NOT ALLOWED\";\n        return(KDC_ERR_POLICY);\n    }\n\n    /* Perform KDB module policy checks. */\n    ret = krb5_db_check_policy_as(kdc_context, request, &client, &server,\n                                  kdc_time, status, e_data);\n    if (ret && ret != KRB5_PLUGIN_OP_NOTSUPP)\n        return errcode_to_protocol(ret);\n\n    /* Check against local policy. */\n    errcode = against_local_policy_as(request, client, server,\n                                      kdc_time, status, e_data);\n    if (errcode)\n        return errcode;\n\n    return 0;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 742,
    "critical_vars": [
      "request->server",
      "client.princ",
      "kdc_active_realm"
    ],
    "function": "validate_as_request",
    "filename": "krb5/CVE-2016-3120/CVE-2016-3120_CWE-476_93b4a6306a0026cf1cc31ac4bd8a49ba5d034ba7_kdc_util.c.diff",
    "function_code": "validate_as_request(kdc_realm_t *kdc_active_realm,\n                    register krb5_kdc_req *request, krb5_db_entry client,\n                    krb5_db_entry server, krb5_timestamp kdc_time,\n                    const char **status, krb5_pa_data ***e_data)\n{\n    int errcode;\n    krb5_error_code ret;\n\n    /*\n     * If an option is set that is only allowed in TGS requests, complain.\n     */\n    if (request->kdc_options & AS_INVALID_OPTIONS) {\n        *status = \"INVALID AS OPTIONS\";\n        return KDC_ERR_BADOPTION;\n    }\n\n    /* The client must not be expired */\n    if (client.expiration && client.expiration < kdc_time) {\n        *status = \"CLIENT EXPIRED\";\n        if (vague_errors)\n            return(KRB_ERR_GENERIC);\n        else\n            return(KDC_ERR_NAME_EXP);\n    }\n\n    /* The client's password must not be expired, unless the server is\n       a KRB5_KDC_PWCHANGE_SERVICE. */\n    if (client.pw_expiration && client.pw_expiration < kdc_time &&\n        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {\n        *status = \"CLIENT KEY EXPIRED\";\n        if (vague_errors)\n            return(KRB_ERR_GENERIC);\n        else\n            return(KDC_ERR_KEY_EXP);\n    }\n\n    /* The server must not be expired */\n    if (server.expiration && server.expiration < kdc_time) {\n        *status = \"SERVICE EXPIRED\";\n        return(KDC_ERR_SERVICE_EXP);\n    }\n\n    /*\n     * If the client requires password changing, then only allow the\n     * pwchange service.\n     */\n    if (isflagset(client.attributes, KRB5_KDB_REQUIRES_PWCHANGE) &&\n        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {\n        *status = \"REQUIRED PWCHANGE\";\n        return(KDC_ERR_KEY_EXP);\n    }\n\n    /* Client and server must allow postdating tickets */\n    if ((isflagset(request->kdc_options, KDC_OPT_ALLOW_POSTDATE) ||\n         isflagset(request->kdc_options, KDC_OPT_POSTDATED)) &&\n        (isflagset(client.attributes, KRB5_KDB_DISALLOW_POSTDATED) ||\n         isflagset(server.attributes, KRB5_KDB_DISALLOW_POSTDATED))) {\n        *status = \"POSTDATE NOT ALLOWED\";\n        return(KDC_ERR_CANNOT_POSTDATE);\n    }\n\n    /*\n     * A Windows KDC will return KDC_ERR_PREAUTH_REQUIRED instead of\n     * KDC_ERR_POLICY in the following case:\n     *\n     *   - KDC_OPT_FORWARDABLE is set in KDCOptions but local\n     *     policy has KRB5_KDB_DISALLOW_FORWARDABLE set for the\n     *     client, and;\n     *   - KRB5_KDB_REQUIRES_PRE_AUTH is set for the client but\n     *     preauthentication data is absent in the request.\n     *\n     * Hence, this check most be done after the check for preauth\n     * data, and is now performed by validate_forwardable() (the\n     * contents of which were previously below).\n     */\n\n    /* Client and server must allow proxiable tickets */\n    if (isflagset(request->kdc_options, KDC_OPT_PROXIABLE) &&\n        (isflagset(client.attributes, KRB5_KDB_DISALLOW_PROXIABLE) ||\n         isflagset(server.attributes, KRB5_KDB_DISALLOW_PROXIABLE))) {\n        *status = \"PROXIABLE NOT ALLOWED\";\n        return(KDC_ERR_POLICY);\n    }\n\n    /* Check to see if client is locked out */\n    if (isflagset(client.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {\n        *status = \"CLIENT LOCKED OUT\";\n        return(KDC_ERR_CLIENT_REVOKED);\n    }\n\n    /* Check to see if server is locked out */\n    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {\n        *status = \"SERVICE LOCKED OUT\";\n        return(KDC_ERR_S_PRINCIPAL_UNKNOWN);\n    }\n\n    /* Check to see if server is allowed to be a service */\n    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_SVR)) {\n        *status = \"SERVICE NOT ALLOWED\";\n        return(KDC_ERR_MUST_USE_USER2USER);\n    }\n\n    if (check_anon(kdc_active_realm, client.princ, request->server) != 0) {\n        *status = \"ANONYMOUS NOT ALLOWED\";\n        return(KDC_ERR_POLICY);\n    }\n\n    /* Perform KDB module policy checks. */\n    ret = krb5_db_check_policy_as(kdc_context, request, &client, &server,\n                                  kdc_time, status, e_data);\n    if (ret && ret != KRB5_PLUGIN_OP_NOTSUPP)\n        return errcode_to_protocol(ret);\n\n    /* Check against local policy. */\n    errcode = against_local_policy_as(request, client, server,\n                                      kdc_time, status, e_data);\n    if (errcode)\n        return errcode;\n\n    return 0;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "if-Condition",
    "line_old": 752,
    "critical_vars": [
      "vstart",
      "vdaux"
    ],
    "function": "*store_versioninfo_gnu_verdef",
    "filename": "radare2/CVE-2017-16359/CVE-2017-16359_CWE-476_fbaf24bce7ea4211e4608b3ab6c1b45702cb243d_elf.c.diff",
    "function_code": "static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) {\n\tconst char *section_name = \"\";\n\tconst char *link_section_name = \"\";\n\tchar *end = NULL;\n\tElf_(Shdr) *link_shdr = NULL;\n\tut8 dfs[sizeof (Elf_(Verdef))] = {0};\n\tSdb *sdb;\n\tint cnt, i;\n\tif (shdr->sh_link > bin->ehdr.e_shnum) {\n\t\treturn false;\n\t}\n\tlink_shdr = &bin->shdr[shdr->sh_link];\n\tif ((int)shdr->sh_size < 1) {\n\t\treturn false;\n\t}\n\tElf_(Verdef) *defs = calloc (shdr->sh_size, sizeof (char));\n\tif (!defs) {\n\t\treturn false;\n\t}\n\tif (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {\n\t\tsection_name = &bin->shstrtab[shdr->sh_name];\n\t}\n\tif (link_shdr && bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) {\n\t\tlink_section_name = &bin->shstrtab[link_shdr->sh_name];\n\t}\n\tif (!defs) {\n\t\tbprintf (\"Warning: Cannot allocate memory (Check Elf_(Verdef))\\n\");\n\t\treturn NULL;\n\t}\n\tsdb = sdb_new0 ();\n\tend = (char *)defs + shdr->sh_size;\n\tsdb_set (sdb, \"section_name\", section_name, 0);\n\tsdb_num_set (sdb, \"entries\", shdr->sh_info, 0);\n\tsdb_num_set (sdb, \"addr\", shdr->sh_addr, 0);\n\tsdb_num_set (sdb, \"offset\", shdr->sh_offset, 0);\n\tsdb_num_set (sdb, \"link\", shdr->sh_link, 0);\n\tsdb_set (sdb, \"link_section_name\", link_section_name, 0);\n\n\tfor (cnt = 0, i = 0; i >= 0 && cnt < shdr->sh_info && ((char *)defs + i < end); ++cnt) {\n\t\tSdb *sdb_verdef = sdb_new0 ();\n\t\tchar *vstart = ((char*)defs) + i;\n\t\tchar key[32] = {0};\n\t\tElf_(Verdef) *verdef = (Elf_(Verdef)*)vstart;\n\t\tElf_(Verdaux) aux = {0};\n\t\tint j = 0;\n\t\tint isum = 0;\n\n\t\tr_buf_read_at (bin->b, shdr->sh_offset + i, dfs, sizeof (Elf_(Verdef)));\n\t\tverdef->vd_version = READ16 (dfs, j)\n\t\tverdef->vd_flags = READ16 (dfs, j)\n\t\tverdef->vd_ndx = READ16 (dfs, j)\n\t\tverdef->vd_cnt = READ16 (dfs, j)\n\t\tverdef->vd_hash = READ32 (dfs, j)\n\t\tverdef->vd_aux = READ32 (dfs, j)\n\t\tverdef->vd_next = READ32 (dfs, j)\n\t\tint vdaux = verdef->vd_aux;\n\t\tif (vdaux < 1 || vstart + vdaux < vstart) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\t\tvstart += vdaux;\n\t\tif (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tj = 0;\n\t\taux.vda_name = READ32 (vstart, j)\n\t\taux.vda_next = READ32 (vstart, j)\n\n\t\tisum = i + verdef->vd_aux;\n\t\tif (aux.vda_name > bin->dynstr_size) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tsdb_num_set (sdb_verdef, \"idx\", i, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_version\", verdef->vd_version, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_ndx\", verdef->vd_ndx, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_cnt\", verdef->vd_cnt, 0);\n\t\tsdb_set (sdb_verdef, \"vda_name\", &bin->dynstr[aux.vda_name], 0);\n\t\tsdb_set (sdb_verdef, \"flags\", get_ver_flags (verdef->vd_flags), 0);\n\n\t\tfor (j = 1; j < verdef->vd_cnt; ++j) {\n\t\t\tint k;\n\t\t\tSdb *sdb_parent = sdb_new0 ();\n\t\t\tisum += aux.vda_next;\n\t\t\tvstart += aux.vda_next;\n\t\t\tif (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) {\n\t\t\t\tsdb_free (sdb_verdef);\n\t\t\t\tsdb_free (sdb_parent);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tk = 0;\n\t\t\taux.vda_name = READ32 (vstart, k)\n\t\t\taux.vda_next = READ32 (vstart, k)\n\t\t\tif (aux.vda_name > bin->dynstr_size) {\n\t\t\t\tsdb_free (sdb_verdef);\n\t\t\t\tsdb_free (sdb_parent);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tsdb_num_set (sdb_parent, \"idx\", isum, 0);\n\t\t\tsdb_num_set (sdb_parent, \"parent\", j, 0);\n\t\t\tsdb_set (sdb_parent, \"vda_name\", &bin->dynstr[aux.vda_name], 0);\n\t\t\tsnprintf (key, sizeof (key), \"parent%d\", j - 1);\n\t\t\tsdb_ns_set (sdb_verdef, key, sdb_parent);\n\t\t}\n\n\t\tsnprintf (key, sizeof (key), \"verdef%d\", cnt);\n\t\tsdb_ns_set (sdb, key, sdb_verdef);\n\t\tif (!verdef->vd_next) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\t\tif ((st32)verdef->vd_next < 1) {\n\t\t\teprintf (\"Warning: Invalid vd_next in the ELF version\\n\");\n\t\t\tbreak;\n\t\t}\n\t\ti += verdef->vd_next;\n\t}\n\tfree (defs);\n\treturn sdb;\nout_error:\n\tfree (defs);\n\tsdb_free (sdb);\n\treturn NULL;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "Assignment",
    "line_new": 737,
    "critical_vars": [
      "vstart_off"
    ],
    "function": "*store_versioninfo_gnu_verdef",
    "filename": "radare2/CVE-2017-16359/CVE-2017-16359_CWE-476_fbaf24bce7ea4211e4608b3ab6c1b45702cb243d_elf.c.diff",
    "function_code": "static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) {\n\tconst char *section_name = \"\";\n\tconst char *link_section_name = \"\";\n\tchar *end = NULL;\n\tElf_(Shdr) *link_shdr = NULL;\n\tut8 dfs[sizeof (Elf_(Verdef))] = {0};\n\tSdb *sdb;\n\tint cnt, i;\n\tif (shdr->sh_link > bin->ehdr.e_shnum) {\n\t\treturn false;\n\t}\n\tlink_shdr = &bin->shdr[shdr->sh_link];\n\tif ((int)shdr->sh_size < 1) {\n\t\treturn false;\n\t}\n\tElf_(Verdef) *defs = calloc (shdr->sh_size, sizeof (char));\n\tif (!defs) {\n\t\treturn false;\n\t}\n\tif (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {\n\t\tsection_name = &bin->shstrtab[shdr->sh_name];\n\t}\n\tif (link_shdr && bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) {\n\t\tlink_section_name = &bin->shstrtab[link_shdr->sh_name];\n\t}\n\tif (!defs) {\n\t\tbprintf (\"Warning: Cannot allocate memory (Check Elf_(Verdef))\\n\");\n\t\treturn NULL;\n\t}\n\tsdb = sdb_new0 ();\n\tend = (char *)defs + shdr->sh_size;\n\tsdb_set (sdb, \"section_name\", section_name, 0);\n\tsdb_num_set (sdb, \"entries\", shdr->sh_info, 0);\n\tsdb_num_set (sdb, \"addr\", shdr->sh_addr, 0);\n\tsdb_num_set (sdb, \"offset\", shdr->sh_offset, 0);\n\tsdb_num_set (sdb, \"link\", shdr->sh_link, 0);\n\tsdb_set (sdb, \"link_section_name\", link_section_name, 0);\n\n\tfor (cnt = 0, i = 0; i >= 0 && cnt < shdr->sh_info && ((char *)defs + i < end); ++cnt) {\n\t\tSdb *sdb_verdef = sdb_new0 ();\n\t\tchar *vstart = ((char*)defs) + i;\n\t\tsize_t vstart_off = i;\n\t\tchar key[32] = {0};\n\t\tElf_(Verdef) *verdef = (Elf_(Verdef)*)vstart;\n\t\tElf_(Verdaux) aux = {0};\n\t\tint j = 0;\n\t\tint isum = 0;\n\n\t\tr_buf_read_at (bin->b, shdr->sh_offset + i, dfs, sizeof (Elf_(Verdef)));\n\t\tverdef->vd_version = READ16 (dfs, j)\n\t\tverdef->vd_flags = READ16 (dfs, j)\n\t\tverdef->vd_ndx = READ16 (dfs, j)\n\t\tverdef->vd_cnt = READ16 (dfs, j)\n\t\tverdef->vd_hash = READ32 (dfs, j)\n\t\tverdef->vd_aux = READ32 (dfs, j)\n\t\tverdef->vd_next = READ32 (dfs, j)\n\t\tint vdaux = verdef->vd_aux;\n\t\tif (vdaux < 1 || shdr->sh_size - vstart_off < vdaux) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\t\tvstart += vdaux;\n\t\tvstart_off += vdaux;\n\t\tif (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tj = 0;\n\t\taux.vda_name = READ32 (vstart, j)\n\t\taux.vda_next = READ32 (vstart, j)\n\n\t\tisum = i + verdef->vd_aux;\n\t\tif (aux.vda_name > bin->dynstr_size) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tsdb_num_set (sdb_verdef, \"idx\", i, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_version\", verdef->vd_version, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_ndx\", verdef->vd_ndx, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_cnt\", verdef->vd_cnt, 0);\n\t\tsdb_set (sdb_verdef, \"vda_name\", &bin->dynstr[aux.vda_name], 0);\n\t\tsdb_set (sdb_verdef, \"flags\", get_ver_flags (verdef->vd_flags), 0);\n\n\t\tfor (j = 1; j < verdef->vd_cnt; ++j) {\n\t\t\tint k;\n\t\t\tSdb *sdb_parent = sdb_new0 ();\n\t\t\tisum += aux.vda_next;\n\t\t\tvstart += aux.vda_next;\n\t\t\tvstart_off += aux.vda_next;\n\t\t\tif (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) {\n\t\t\t\tsdb_free (sdb_verdef);\n\t\t\t\tsdb_free (sdb_parent);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tk = 0;\n\t\t\taux.vda_name = READ32 (vstart, k)\n\t\t\taux.vda_next = READ32 (vstart, k)\n\t\t\tif (aux.vda_name > bin->dynstr_size) {\n\t\t\t\tsdb_free (sdb_verdef);\n\t\t\t\tsdb_free (sdb_parent);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tsdb_num_set (sdb_parent, \"idx\", isum, 0);\n\t\t\tsdb_num_set (sdb_parent, \"parent\", j, 0);\n\t\t\tsdb_set (sdb_parent, \"vda_name\", &bin->dynstr[aux.vda_name], 0);\n\t\t\tsnprintf (key, sizeof (key), \"parent%d\", j - 1);\n\t\t\tsdb_ns_set (sdb_verdef, key, sdb_parent);\n\t\t}\n\n\t\tsnprintf (key, sizeof (key), \"verdef%d\", cnt);\n\t\tsdb_ns_set (sdb, key, sdb_verdef);\n\t\tif (!verdef->vd_next) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\t\tif ((st32)verdef->vd_next < 1) {\n\t\t\teprintf (\"Warning: Invalid vd_next in the ELF version\\n\");\n\t\t\tbreak;\n\t\t}\n\t\ti += verdef->vd_next;\n\t}\n\tfree (defs);\n\treturn sdb;\nout_error:\n\tfree (defs);\n\tsdb_free (sdb);\n\treturn NULL;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "while-Condition",
    "line_old": 118,
    "critical_vars": [
      "true"
    ],
    "function": "*r_bin_ne_get_symbols",
    "filename": "radare2/CVE-2022-1283/CVE-2022-1283_CWE-476_18d1d064bf599a255d55f09fca3104776fc34a67_ne.c.diff",
    "function_code": "RList *r_bin_ne_get_symbols(r_bin_ne_obj_t *bin) {\n\tRBinSymbol *sym;\n\tut16 off = bin->ne_header->ResidNamTable + bin->header_offset;\n\tRList *symbols = r_list_newf (free);\n\tif (!symbols) {\n\t\treturn NULL;\n\t}\n\tRList *entries = r_bin_ne_get_entrypoints (bin);\n\tbool resident = true, first = true;\n\twhile (true) {\n\t\tut8 sz = r_buf_read8_at (bin->buf, off);\n\t\tif (!sz) {\n\t\t\tfirst = true;\n\t\t\tif (resident) {\n\t\t\t\tresident = false;\n\t\t\t\toff = bin->ne_header->OffStartNonResTab;\n\t\t\t\tsz = r_buf_read8_at (bin->buf, off);\n\t\t\t\tif (!sz) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tchar *name = malloc ((ut64)sz + 1);\n\t\tif (!name) {\n\t\t\tbreak;\n\t\t}\n\t\toff++;\n\t\tr_buf_read_at (bin->buf, off, (ut8 *)name, sz);\n\t\tname[sz] = '\\0';\n\t\toff += sz;\n\t\tsym = R_NEW0 (RBinSymbol);\n\t\tif (!sym) {\n\t\t\tbreak;\n\t\t}\n\t\tsym->name = name;\n\t\tif (!first) {\n\t\t\tsym->bind = R_BIN_BIND_GLOBAL_STR;\n\t\t}\n\t\tut16 entry_off = r_buf_read_le16_at (bin->buf, off);\n\t\toff += 2;\n\t\tRBinAddr *entry = r_list_get_n (entries, entry_off);\n\t\tif (entry) {\n\t\t\tsym->paddr = entry->paddr;\n\t\t} else {\n\t\t\tsym->paddr = -1;\n\t\t}\n\t\tsym->ordinal = entry_off;\n\t\tr_list_append (symbols, sym);\n\t\tfirst = false;\n\t}\n\tRListIter *it;\n\tRBinAddr *en;\n\tint i = 1;\n\tr_list_foreach (entries, it, en) {\n\t\tif (!r_list_find (symbols, &en->paddr, __find_symbol_by_paddr)) {\n\t\t\tsym = R_NEW0 (RBinSymbol);\n\t\t\tif (!sym) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsym->name = r_str_newf (\"entry%d\", i - 1);\n\t\t\tsym->paddr = en->paddr;\n\t\t\tsym->bind = R_BIN_BIND_GLOBAL_STR;\n\t\t\tsym->ordinal = i;\n\t\t\tr_list_append (symbols, sym);\n\t\t}\n\t\ti++;\n\t}\n\tbin->symbols = symbols;\n\treturn symbols;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "while-Condition",
    "line_new": 118,
    "critical_vars": [
      "entries"
    ],
    "function": "*r_bin_ne_get_symbols",
    "filename": "radare2/CVE-2022-1283/CVE-2022-1283_CWE-476_18d1d064bf599a255d55f09fca3104776fc34a67_ne.c.diff",
    "function_code": "RList *r_bin_ne_get_symbols(r_bin_ne_obj_t *bin) {\n\tRBinSymbol *sym;\n\tut16 off = bin->ne_header->ResidNamTable + bin->header_offset;\n\tRList *symbols = r_list_newf (free);\n\tif (!symbols) {\n\t\treturn NULL;\n\t}\n\tRList *entries = r_bin_ne_get_entrypoints (bin);\n\tbool resident = true, first = true;\n\twhile (entries) {\n\t\tut8 sz = r_buf_read8_at (bin->buf, off);\n\t\tif (!sz) {\n\t\t\tfirst = true;\n\t\t\tif (resident) {\n\t\t\t\tresident = false;\n\t\t\t\toff = bin->ne_header->OffStartNonResTab;\n\t\t\t\tsz = r_buf_read8_at (bin->buf, off);\n\t\t\t\tif (!sz) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tchar *name = malloc ((ut64)sz + 1);\n\t\tif (!name) {\n\t\t\tbreak;\n\t\t}\n\t\toff++;\n\t\tr_buf_read_at (bin->buf, off, (ut8 *)name, sz);\n\t\tname[sz] = '\\0';\n\t\toff += sz;\n\t\tsym = R_NEW0 (RBinSymbol);\n\t\tif (!sym) {\n\t\t\tbreak;\n\t\t}\n\t\tsym->name = name;\n\t\tif (!first) {\n\t\t\tsym->bind = R_BIN_BIND_GLOBAL_STR;\n\t\t}\n\t\tut16 entry_off = r_buf_read_le16_at (bin->buf, off);\n\t\toff += 2;\n\t\tRBinAddr *entry = r_list_get_n (entries, entry_off);\n\t\tif (entry) {\n\t\t\tsym->paddr = entry->paddr;\n\t\t} else {\n\t\t\tsym->paddr = -1;\n\t\t}\n\t\tsym->ordinal = entry_off;\n\t\tr_list_append (symbols, sym);\n\t\tfirst = false;\n\t}\n\tRListIter *it;\n\tRBinAddr *en;\n\tint i = 1;\n\tr_list_foreach (entries, it, en) {\n\t\tif (!r_list_find (symbols, &en->paddr, __find_symbol_by_paddr)) {\n\t\t\tsym = R_NEW0 (RBinSymbol);\n\t\t\tif (!sym) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsym->name = r_str_newf (\"entry%d\", i - 1);\n\t\t\tsym->paddr = en->paddr;\n\t\t\tsym->bind = R_BIN_BIND_GLOBAL_STR;\n\t\t\tsym->ordinal = i;\n\t\t\tr_list_append (symbols, sym);\n\t\t}\n\t\ti++;\n\t}\n\tbin->symbols = symbols;\n\treturn symbols;\n}",
    "label": "False"
  },
  {
    "patch_model": "Delete",
    "change_type": "Assignment",
    "line_old": 245,
    "critical_vars": [
      "obj->cache_buf"
    ],
    "function": "load_buffer",
    "filename": "radare2/CVE-2022-0419/CVE-2022-0419_CWE-476_feaa4e7f7399c51ee6f52deb84dc3f795b4035d6_bin_xnu_kernelcache.c.diff",
    "function_code": "static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {\n\tRBuffer *fbuf = r_buf_ref (buf);\n\tstruct MACH0_(opts_t) opts;\n\tMACH0_(opts_set_default) (&opts, bf);\n\tstruct MACH0_(obj_t) *main_mach0 = MACH0_(new_buf) (fbuf, &opts);\n\tif (!main_mach0) {\n\t\treturn false;\n\t}\n\n\tRRebaseInfo *rebase_info = r_rebase_info_new_from_mach0 (fbuf, main_mach0);\n\tRKernelCacheObj *obj = NULL;\n\n\tRPrelinkRange *prelink_range = get_prelink_info_range_from_mach0 (main_mach0);\n\tif (!prelink_range) {\n\t\tgoto beach;\n\t}\n\n\tobj = R_NEW0 (RKernelCacheObj);\n\tif (!obj) {\n\t\tR_FREE (prelink_range);\n\t\tgoto beach;\n\t}\n\n\tRCFValueDict *prelink_info = NULL;\n\tif (main_mach0->hdr.filetype != MH_FILESET && prelink_range->range.size) {\n\t\tprelink_info = r_cf_value_dict_parse (fbuf, prelink_range->range.offset,\n\t\t\t\tprelink_range->range.size, R_CF_OPTION_SKIP_NSDATA);\n\t\tif (!prelink_info) {\n\t\t\tR_FREE (prelink_range);\n\t\t\tR_FREE (obj);\n\t\t\tgoto beach;\n\t\t}\n\t}\n\n\tif (!pending_bin_files) {\n\t\tpending_bin_files = r_list_new ();\n\t\tif (!pending_bin_files) {\n\t\t\tR_FREE (prelink_range);\n\t\t\tR_FREE (obj);\n\t\t\tR_FREE (prelink_info);\n\t\t\tgoto beach;\n\t\t}\n\t}\n\n\tobj->mach0 = main_mach0;\n\tobj->rebase_info = rebase_info;\n\tobj->prelink_info = prelink_info;\n\tobj->cache_buf = fbuf;\n\tobj->pa2va_exec = prelink_range->pa2va_exec;\n\tobj->pa2va_data = prelink_range->pa2va_data;\n\n\tR_FREE (prelink_range);\n\n\t*bin_obj = obj;\n\n\tr_list_push (pending_bin_files, bf);\n\n\tif (rebase_info || main_mach0->chained_starts) {\n\t\tRIO *io = bf->rbin->iob.io;\n\t\tswizzle_io_read (obj, io);\n\t}\n\n\treturn true;\n\nbeach:\n\tr_buf_free (fbuf);\n\tobj->cache_buf = NULL;\n\tMACH0_(mach0_free) (main_mach0);\n\treturn false;\n}",
    "label": "True"
  },
  {
    "patch_model": "Add",
    "change_type": "if-Condition",
    "line_new": 245,
    "critical_vars": [
      "obj"
    ],
    "function": "load_buffer",
    "filename": "radare2/CVE-2022-0419/CVE-2022-0419_CWE-476_feaa4e7f7399c51ee6f52deb84dc3f795b4035d6_bin_xnu_kernelcache.c.diff",
    "function_code": "static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {\n\tRBuffer *fbuf = r_buf_ref (buf);\n\tstruct MACH0_(opts_t) opts;\n\tMACH0_(opts_set_default) (&opts, bf);\n\tstruct MACH0_(obj_t) *main_mach0 = MACH0_(new_buf) (fbuf, &opts);\n\tif (!main_mach0) {\n\t\treturn false;\n\t}\n\n\tRRebaseInfo *rebase_info = r_rebase_info_new_from_mach0 (fbuf, main_mach0);\n\tRKernelCacheObj *obj = NULL;\n\n\tRPrelinkRange *prelink_range = get_prelink_info_range_from_mach0 (main_mach0);\n\tif (!prelink_range) {\n\t\tgoto beach;\n\t}\n\n\tobj = R_NEW0 (RKernelCacheObj);\n\tif (!obj) {\n\t\tR_FREE (prelink_range);\n\t\tgoto beach;\n\t}\n\n\tRCFValueDict *prelink_info = NULL;\n\tif (main_mach0->hdr.filetype != MH_FILESET && prelink_range->range.size) {\n\t\tprelink_info = r_cf_value_dict_parse (fbuf, prelink_range->range.offset,\n\t\t\t\tprelink_range->range.size, R_CF_OPTION_SKIP_NSDATA);\n\t\tif (!prelink_info) {\n\t\t\tR_FREE (prelink_range);\n\t\t\tR_FREE (obj);\n\t\t\tgoto beach;\n\t\t}\n\t}\n\n\tif (!pending_bin_files) {\n\t\tpending_bin_files = r_list_new ();\n\t\tif (!pending_bin_files) {\n\t\t\tR_FREE (prelink_range);\n\t\t\tR_FREE (obj);\n\t\t\tR_FREE (prelink_info);\n\t\t\tgoto beach;\n\t\t}\n\t}\n\n\tobj->mach0 = main_mach0;\n\tobj->rebase_info = rebase_info;\n\tobj->prelink_info = prelink_info;\n\tobj->cache_buf = fbuf;\n\tobj->pa2va_exec = prelink_range->pa2va_exec;\n\tobj->pa2va_data = prelink_range->pa2va_data;\n\n\tR_FREE (prelink_range);\n\n\t*bin_obj = obj;\n\n\tr_list_push (pending_bin_files, bf);\n\n\tif (rebase_info || main_mach0->chained_starts) {\n\t\tRIO *io = bf->rbin->iob.io;\n\t\tswizzle_io_read (obj, io);\n\t}\n\n\treturn true;\n\nbeach:\n\tr_buf_free (fbuf);\n\tif (obj) {\n\t\tobj->cache_buf = NULL;\n\t}\n\tMACH0_(mach0_free) (main_mach0);\n\treturn false;\n}",
    "label": "False"
  }
]